optional commands supported   */
					    /* (1 = yes, 0 = no):	     */
					    /* bit 0 - chip erase.	     */
					    /* bit 1 - suspend erase.	     */
					    /* bit 2 - suspend write	     */
					    /* bit 3 - lock/unlock.	     */
					    /* bit 4 - queued erase.	     */
  ULONG    afterSuspend;	    /* functions supported after     */
					    /* suspend (1 = yes, 0 = no):    */
					    /* bit 0 - write after erase     */
					    /*	       suspend. 	     */
} CFI;

CFI mtdVars_cfiscs[SOCKETS];

#define thisCFI   ((CFI *)vol.mtdVars)

/*----------------------------------------------------------------------*/
/*			    c f i s c s B y t e S i z e 		*/
/*									*/
/* Identify the card size for byte mode.				*/
/* Sets the value of flash.noOfChips.					*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	amdCmdRoutine	: Routine to read-id AMD/Fujitsu style at	*/
/*			  a specific location. If null, Intel procedure */
/*			  is used.					*/
/*	idOffset	: Chip offset to use for identification 	*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 = OK, otherwise failed (invalid Flash array)*/
/*----------------------------------------------------------------------*/

FLStatus cfiscsByteSize(FLFlash vol)
{
  CHAR queryIdStr[ID_STR_LENGTH + 1] = QUERY_ID_STR;

  FlashPTR flashPtr = (FlashPTR) flMap(vol.socket, 0);
  tffsWriteByteFlash(flashPtr + (0x55 * vol.interleaving), QUERY);
  /* We leave the first chip in QUERY mode, so that we can		*/
  /* discover an address wraparound.					*/

  for (vol.noOfChips = 0;	/* Scan the chips */
       vol.noOfChips < 2000;  /* Big enough ? */
       vol.noOfChips += vol.interleaving) {
    LONG i;

    flashPtr = (FlashPTR) flMap(vol.socket, vol.noOfChips * vol.chipSize);

    /* Check for address wraparound to the first chip */
    if (vol.noOfChips > 0 &&
	(queryIdStr[0] == tffsReadByteFlash(flashPtr +
			  0x10 * vol.interleaving * thisCFI->multiplier) &&
	 queryIdStr[1] == tffsReadByteFlash(flashPtr +
			  0x11 * vol.interleaving * thisCFI->multiplier) &&
	 queryIdStr[2] == tffsReadByteFlash(flashPtr +
			  0x12 * vol.interleaving * thisCFI->multiplier)))
      goto noMoreChips;    /* wraparound */

    /* Check if chip displays the "QRY" ID string */
    for (i = (vol.noOfChips ? 0 : 1); i < vol.interleaving; i++) {
       tffsWriteByteFlash(flashPtr + vol.interleaving * 0x55 + i, QUERY);
       if (queryIdStr[0] != tffsReadByteFlash(flashPtr +
			    0x10 * vol.interleaving * thisCFI->multiplier + i) ||
	   queryIdStr[1] != tffsReadByteFlash(flashPtr +
			    0x11 * vol.interleaving * thisCFI->multiplier + i) ||
	   queryIdStr[2] != tffsReadByteFlash(flashPtr +
			    0x12 * vol.interleaving * thisCFI->multiplier + i))
	goto noMoreChips;  /* This "chip" doesn't respond correctly, so we're done */

      tffsWriteByteFlash(flashPtr+i, READ_ARRAY);
    }
  }

noMoreChips:
  flashPtr = (FlashPTR) flMap(vol.socket, 0);
  tffsWriteByteFlash(flashPtr, READ_ARRAY);		/* reset the original chip */

  return (vol.noOfChips == 0) ? flUnknownMedia : flOK;
}


/*----------------------------------------------------------------------*/
/*			 c f i s c s B y t e I d e n t i f y		*/
/*									*/
/* Identify the Flash type for cards in byte mode.			*/
/* Sets the value of flash.type (JEDEC id) & flash.interleaving.	*/
/* Calculate the number of times each byte of data appears in READ_ID	*/
/* and QUERY commands.							*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 = OK, otherwise failed (invalid Flash array)*/
/*----------------------------------------------------------------------*/
FLStatus cfiscsByteIdentify(FLFlash vol)
{
  LONG inlv, mul;
  FlashPTR flashPtr = (FlashPTR) flMap(vol.socket, 0);

  for (inlv = 1; inlv <= 8; inlv++) /* let us assume that interleaving is 8 */
    tffsWriteByteFlash(flashPtr+inlv, READ_ARRAY);    /* and reset all the interleaved chips  */

  for (inlv = 1; inlv <= 8; inlv++) {
    for (mul = 1; mul <= 8; mul++) {   /* try all possibilities */
      LONG letter;

      tffsWriteByteFlash(flashPtr + 0x55 * inlv, QUERY);

      for (letter = 0; letter < ID_STR_LENGTH; letter++) {  /* look for "QRY" id string */
    CHAR idChar = '?';
	LONG offset, counter;

	switch (letter) {
	  case 0:
	    idChar = 'Q';
	    break;
	  case 1:
	    idChar = 'R';
	    break;
	  case 2:
	    idChar = 'Y';
	    break;
	}

	for (counter = 0, offset = (0x10 + letter) * inlv * mul;
	     counter < mul;
	     counter++, offset += inlv)  /*  each character should appear mul times */
	  if (tffsReadByteFlash(flashPtr+offset) != idChar)
	    break;

	if (counter < mul)  /* no match */
	  break;
      }

      tffsWriteByteFlash(flashPtr + 0x55 * inlv, READ_ARRAY);  /* reset the chip */
      if (letter >= ID_STR_LENGTH)
	goto checkInlv;
    }
  }

checkInlv:

  if (inlv > 8) 		  /* too much */
    return flUnknownMedia;

  if (inlv & (inlv - 1))
    return flUnknownMedia;	    /* not a power of 2, no way ! */

  vol.interleaving = (unsigned short)inlv;
  thisCFI->multiplier = mul;
  tffsWriteByteFlash(flashPtr + 0x55 * inlv, QUERY);
  vol.type = (FlashType) ((tffsReadByteFlash(flashPtr) << 8) |
			    tffsReadByteFlash(flashPtr + inlv * thisCFI->multiplier));
  tffsWriteByteFlash(flashPtr+inlv, READ_ARRAY);

  return flOK;

}


/*----------------------------------------------------------------------*/
/*		      c f i s c s W o r d S i z e			*/
/*									*/
/* Identify the card size for a word-mode Flash array.			*/
/* Sets the value of flash.noOfChips.					*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 = OK, otherwise failed (invalid Flash array)*/
/*----------------------------------------------------------------------*/
FLStatus cfiscsWordSize(FLFlash vol)
{
  CHAR queryIdStr[ID_STR_LENGTH + 1] = QUERY_ID_STR;

  FlashWPTR flashPtr = (FlashWPTR) flMap(vol.socket, 0);
  tffsWriteWordFlash(flashPtr, CLEAR_STATUS);
  tffsWriteWordFlash(flashPtr+0x55, QUERY);
  /* We leave the first chip in QUERY mode, so that we can		*/
  /* discover an address wraparound.					*/

  for (vol.noOfChips = 1;	/* Scan the chips */
       vol.noOfChips < 2000;  /* Big enough ? */
       vol.noOfChips++) {
    flashPtr = (FlashWPTR) flMap(vol.socket, vol.noOfChips * vol.chipSize);

    if ((tffsReadWordFlash(flashPtr+0x10) == (USHORT)queryIdStr[0]) &&
	(tffsReadWordFlash(flashPtr+0x11) == (USHORT)queryIdStr[1]) &&
	(tffsReadWordFlash(flashPtr+0x12) == (USHORT)queryIdStr[2]))
      break;	  /* We've wrapped around to the first chip ! */

    tffsWriteWordFlash(flashPtr+0x55, QUERY);
    if ((tffsReadWordFlash(flashPtr+0x10) != (USHORT)queryIdStr[0]) ||
	(tffsReadWordFlash(flashPtr+0x11) != (USHORT)queryIdStr[1]) ||
	(tffsReadWordFlash(flashPtr+0x12) != (USHORT)queryIdStr[2]))
      break;

    tffsWriteWordFlash(flashPtr, CLEAR_STATUS);
    tffsWriteWordFlash(flashPtr, READ_ARRAY);
  }

  flashPtr = (FlashWPTR) flMap(vol.socket, 0);
  tffsWriteWordFlash(flashPtr, READ_ARRAY);

  return flOK;
}

/*----------------------------------------------------------------------*/
/*		      g e t B y t e C F I				*/
/*									*/
/* Load important CFI data to the CFI structure in a byte-mode. 	*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 = OK, otherwise failed.			*/
/*----------------------------------------------------------------------*/

FLStatus getByteCFI(FLFlash vol)
{
  ULONG primaryTable, secondaryTable;
  CHAR queryIdStr[ID_STR_LENGTH + 1] = QUERY_ID_STR;
  CHAR priIdStr[ID_STR_LENGTH + 1] = PRIMARY_ID_STR;
  FlashPTR flashPtr;

  DEBUG_PRINT(("Debug: reading CFI for byte mode.\n"));

  flashPtr = (FlashPTR)flMap(vol.socket, 0);
  tffsWriteByteFlash(flashPtr + 0x55 * vol.interleaving, QUERY);

  vol.interleaving *= (unsigned short)thisCFI->multiplier; /* jump over the copies of the
						same byte */

  /* look for the query identification string "QRY" */
  if (queryIdStr[0] != tffsReadByteFlash(flashPtr + 0x10 * vol.interleaving) ||
      queryIdStr[1] != tffsReadByteFlash(flashPtr + 0x11 * vol.interleaving) ||
      queryIdStr[2] != tffsReadByteFlash(flashPtr + 0x12 * vol.interleaving)) {
    DEBUG_PRINT(("Debug: did not recognize CFI.\n"));
    return flUnknownMedia;
  }

  /* check the command set ID */
  thisCFI->commandSetId = tffsReadByteFlash(flashPtr +0x13 * vol.interleaving) |
			  ((ULONG)tffsReadByteFlash(flashPtr + 0x14 * vol.interleaving) << 8);
  if (thisCFI->commandSetId != INTEL_COMMAND_SET &&
      thisCFI->commandSetId != AMDFUJ_COMMAND_SET) {
    DEBUG_PRINT(("Debug: did not recognize command set.\n"));
    return flUnknownMedia;
  }
  /* get address for primary algorithm extended table. */
  primaryTable = tffsReadByteFlash(flashPtr + 0x15 * vol.interleaving) |
		 ((ULONG)tffsReadByteFlash(flashPtr + 0x16 * vol.interleaving) << 8);

  /* check alternate command set ID. */
  thisCFI->altCommandSetId = tffsReadByteFlash(flashPtr + 0x17 * vol.interleaving) |
			     ((ULONG)tffsReadByteFlash(flashPtr + 0x18 * vol.interleaving) << 8);
  if (thisCFI->altCommandSetId != INTEL_ALT_COMMAND_SET &&
      thisCFI->altCommandSetId != AMDFUJ_ALT_COMMAND_SET &&
      thisCFI->altCommandSetId != ALT_NOT_SUPPORTED)
    return flUnknownMedia;

  /* get address for secondary algorithm extended table. */
  secondaryTable = tffsReadByteFlash(flashPtr + 0x19 * vol.interleaving) |
		   ((ULONG)tffsReadByteFlash(flashPtr + 0x1a * vol.interleaving) << 8);

  thisCFI->vpp = tffsReadByteFlash(flashPtr + 0x1d * vol.interleaving);

  vol.chipSize = 1L << tffsReadByteFlash(flashPtr + 0x27 * vol.interleaving);

  thisCFI->maxBytesWrite = 1L << (tffsReadByteFlash(flashPtr + 0x2a * vol.interleaving) |
			   ((ULONG)tffsReadByteFlash(flashPtr + 0x2b * vol.interleaving) << 8));


  /* divide by multiplier because interleaving is multiplied by multiplier */
  vol.erasableBlockSize = (tffsReadByteFlash(flashPtr + 0x2f * vol.interleaving) |
			    ((ULONG)tffsReadByteFlash(flashPtr + 0x30 * vol.interleaving)) << 8) *
			    0x100L * vol.interleaving / thisCFI->multiplier;

  /* In this part we access the primary extended table implemented by Intel.
     If the device uses a different extended table, it should be accessed
     according to the vendor specifications. */
  if ((primaryTable) && (thisCFI->commandSetId == INTEL_COMMAND_SET)) {
    /* look for the primary table identification string "PRI" */
    if (priIdStr[0] != tffsReadByteFlash(flashPtr + primaryTable * vol.interleaving) ||
	priIdStr[1] != tffsReadByteFlash(flashPtr + (primaryTable + 1) * vol.interleaving) ||
	priIdStr[2] != tffsReadByteFlash(flashPtr + (primaryTable + 2) * vol.interleaving))
      return flUnknownMedia;

    thisCFI->optionalCommands = tffsReadByteFlash(flashPtr + (primaryTable + 5) * vol.interleaving) |
				((LONG)tffsReadByteFlash(flashPtr + (primaryTable + 6) *
						  vol.interleaving) << 8) |
				((LONG)tffsReadByteFlash(flashPtr + (primaryTable + 7) *
						  vol.interleaving) << 16) |
				((LONG)tffsReadByteFlash(flashPtr + (primaryTable + 8) *
						  vol.interleaving) << 24);

    thisCFI->afterSuspend = tffsReadByteFlash(flashPtr + (primaryTable + 9) * vol.interleaving);
  }
  else {
    thisCFI->optionalCommands = 0;
    thisCFI->afterSuspend = 0;
  }

  tffsWriteByteFlash(flashPtr, READ_ARRAY);

  vol.interleaving /= (unsigned short)thisCFI->multiplier; /* return to the real interleaving*/

  return flOK;
}

/*----------------------------------------------------------------------*/
/*		      g e t W o r d C F I				*/
/*									*/
/* Load important CFI data to the CFI structure in a word-mode. 	*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 = OK, otherwise failed.			*/
/*----------------------------------------------------------------------*/

FLStatus getWordCFI(FLFlash vol)
{
  ULONG primaryTable, secondaryTable;
  CHAR queryIdStr[ID_STR_LENGTH + 1] = QUERY_ID_STR;
  CHAR priIdStr[ID_STR_LENGTH + 1] = PRIMARY_ID_STR;
  FlashWPTR flashPtr;

  DEBUG_PRINT(("Debug: reading CFI for word mode.\n"));

  flashPtr = (FlashWPTR)flMap(vol.socket, 0);
  tffsWriteWordFlash(flashPtr+0x55, QUERY);

  /* look for the query identification string "QRY" */
  if (queryIdStr[0] != (CHAR)tffsReadWordFlash(flashPtr+0x10) ||
      queryIdStr[1] != (CHAR)tffsReadWordFlash(flashPtr+0x11) ||
      queryIdStr[2] != (CHAR)tffsReadWordFlash(flashPtr+0x12)) {
    DEBUG_PRINT(("Debug: did not recognize CFI.\n"));
    return flUnknownMedia;
  }

  /* check the command set ID */
  thisCFI->commandSetId = tffsReadWordFlash(flashPtr+0x13) |
			 (tffsReadWordFlash(flashPtr+0x14) << 8);
  if (thisCFI->commandSetId != INTEL_COMMAND_SET &&
      thisCFI->commandSetId != AMDFUJ_COMMAND_SET) {
    DEBUG_PRINT(("Debug: did not recognize command set.\n"));
    return flUnknownMedia;
  }

  /* get address for primary algorithm extended table. */
  primaryTable = tffsReadWordFlash(flashPtr+0x15) |
		(tffsReadWordFlash(flashPtr+0x16) << 8);

  /* check alternate command set ID. */
  thisCFI->altCommandSetId = tffsReadWordFlash(flashPtr+0x17) |
			    (tffsReadWordFlash(flashPtr+0x18) << 8);
  if (thisCFI->altCommandSetId != INTEL_ALT_COMMAND_SET &&
      thisCFI->altCommandSetId != AMDFUJ_ALT_COMMAND_SET &&
      thisCFI->altCommandSetId != ALT_NOT_SUPPORTED)
    return flUnknownMedia;

  /* get address for secondary algorithm extended table. */
  secondaryTable = tffsReadWordFlash(flashPtr+0x19) |
		  (tffsReadWordFlash(flashPtr+0x1a) << 8);

  thisCFI->vpp = tffsReadWordFlash(flashPtr+0x1d);

  vol.chipSize = 1L << tffsReadWordFlash(flashPtr+0x27);

  thisCFI->maxBytesWrite = 1L << (tffsReadWordFlash(flashPtr+0x2a) |
				 (tffsReadWordFlash(flashPtr+0x2b) << 8));

  vol.erasableBlockSize = (tffsReadWordFlash(flashPtr+0x2f) |
			  (tffsReadWordFlash(flashPtr+0x30) << 8)) * 0x100L;

  /* In this part we access the primary extended table implemented by Intel.
     If the device uses a different extended table, it should be accessed
     according to the vendor specifications. */
  if ((primaryTable) && (thisCFI->commandSetId == INTEL_COMMAND_SET)) {
    /* look for the primary table identification string "PRI" */
    if (priIdStr[0] != (CHAR)tffsReadWordFlash(flashPtr+primaryTable) ||
	priIdStr[1] != (CHAR)tffsReadWordFlash(flashPtr+primaryTable + 1) ||
	priIdStr[2] != (CHAR)tffsReadWordFlash(flashPtr+primaryTable + 2))
      return flUnknownMedia;

    thisCFI->optionalCommands = tffsReadWordFlash(flashPtr+primaryTable + 5) |
				(tffsReadWordFlash(flashPtr+primaryTable + 6) << 8) |
				((LONG)tffsReadWordFlash(flashPtr+primaryTable + 7) << 16) |
				((LONG)tffsReadWordFlash(flashPtr+primaryTable + 8) << 24);

    thisCFI->afterSuspend = tffsReadWordFlash(flashPtr+primaryTable + 9);
  }
  else {
    thisCFI->optionalCommands = 0;
    thisCFI->afterSuspend = 0;
  }

  tffsWriteWordFlash(flashPtr, READ_ARRAY);

  return flOK;
}

/*----------------------------------------------------------------------*/
/*			c f i s c s B y t e W r i t e			*/
/*									*/
/* Write a block of bytes to Flash in a byte-mode.			*/
/*									*/
/* This routine will be registered as the MTD flash.write routine	*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	address 	: Card address to write to			*/
/*	buffer		: Address of data to write			*/
/*	length		: Number of bytes to write			*/
/*	mode		: write mode (overwrite yes/no) 		*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/
FLStatus cfiscsByteWrite(FLFlash vol,
				CardAddress address,
				const VOID FAR1 *buffer,
				dword length,
				word mode)
{
  FLStatus status = flOK;
  FlashPTR flashPtr;
  ULONG i, from, eachWrite;
  const CHAR FAR1 *temp = (const CHAR FAR1 *)buffer;
  /* Set timeout to 5 seconds from now */
  ULONG writeTimeout = flMsecCounter + 5000;

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    checkStatus(flNeedVpp(vol.socket));
#endif

  if (thisCFI->maxBytesWrite > 1) /* multi-byte write supported */
    eachWrite = thisCFI->maxBytesWrite * vol.interleaving;
  else
    eachWrite = vol.interleaving;

  for (from = 0; from < (ULONG) length && status == flOK; from += eachWrite) {
    LONG thisLength = length - from;
    FlashPTR currPtr;
    ULONG tailBytes, lengthByte;
    CHAR FAR1 *fromPtr;
    UCHAR byteToWrite;

    if ((ULONG)thisLength > eachWrite)
      thisLength = eachWrite;

    lengthByte = thisLength / vol.interleaving;
    tailBytes = thisLength % vol.interleaving;

    flashPtr = (FlashPTR) flMap(vol.socket, address + from);

    for (i = 0, currPtr = flashPtr;
	 i < (ULONG) vol.interleaving && i < (ULONG) thisLength;
	 i++, currPtr++) {
      do {
	tffsWriteByteFlash(currPtr, WRITE_TO_BUFFER);
      } while (!(tffsReadByteFlash(currPtr) & SR_READY) && (flMsecCounter < writeTimeout));
      if (!(tffsReadByteFlash(currPtr) & SR_READY)) {
	DEBUG_PRINT(("Debug: timeout error in CFISCS write.\n"));
	status = flWriteFault;
      }
      byteToWrite = i < tailBytes ? (UCHAR) lengthByte : (UCHAR) (lengthByte - 1);
      tffsWriteByteFlash(currPtr, byteToWrite);
    }

    for(i = 0, currPtr = flashPtr,fromPtr = (CHAR *)temp + from;
	i < (ULONG) thisLength;
	i++, flashPtr++, fromPtr++)
      tffsWriteByteFlash(currPtr, *fromPtr);


    for (i = 0, currPtr = flashPtr;
	 i < (ULONG) vol.interleaving && i < (ULONG) thisLength;
	 i++, currPtr++)
      tffsWriteByteFlash(currPtr, CONFIRM_WRITE);

    for (i = 0, currPtr = flashPtr;
	 i < (ULONG) vol.interleaving && i < (ULONG) thisLength;
	 i++, currPtr++) {
      while (!(tffsReadByteFlash(currPtr) & SR_READY) && (flMsecCounter < writeTimeout))
	;
      if (!(tffsReadByteFlash(currPtr) & SR_READY)) {
	DEBUG_PRINT(("Debug: timeout error in CFISCS write.\n"));
	status = flWriteFault;
      }
      if (tffsReadByteFlash(currPtr) & WSM_ERROR) {
	DEBUG_PRINT(("Debug: error in CFISCS write.\n"));
	status = (tffsReadByteFlash(currPtr) & SR_VPP_ERROR) ? flVppFailure : flWriteFault;
	tffsWriteByteFlash(currPtr, CLEAR_STATUS);
      }
      tffsWriteByteFlash(currPtr, READ_ARRAY);
    }
  }

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    flDontNeedVpp(vol.socket);
#endif

  flashPtr = (FlashPTR) flMap(vol.socket, address);
  /* verify the data */
  if (status == flOK) {
    for(i = 0; i < (ULONG) length - 4; i += 4) {
      if (tffsReadDwordFlash((PUCHAR)(flashPtr+i)) != *(ULONG *)(temp+i)) {
	DEBUG_PRINT(("Debug: CFISCS write failed in verification.\n"));
	status = flWriteFault;
      }
    }
    for(; i < (ULONG) length; i++) {
      if (tffsReadByteFlash(flashPtr+i) != *(UCHAR *)(temp+i)) {
	DEBUG_PRINT(("Debug: CFISCS write failed in verification.\n"));
	status = flWriteFault;
      }
    }
  }

  return status;

}

/*----------------------------------------------------------------------*/
/*			c f i s c s W o r d W r i t e			*/
/*									*/
/* Write a block of bytes to Flash in a word-mode.			*/
/*									*/
/* This routine will be registered as the MTD flash.write routine	*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	address 	: Card address to write to			*/
/*	buffer		: Address of data to write			*/
/*	length		: Number of bytes to write			*/
/*	mode		: write mode (overwrite yes/no) 		*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/
FLStatus cfiscsWordWrite(FLFlash vol,
				CardAddress address,
				const VOID FAR1 *buffer,
				dword length,
				word mode)
{
  FLStatus status = flOK;
  FlashPTR byteFlashPtr;
  FlashWPTR flashPtr;
  ULONG from;
	ULONG i, eachWrite;
  const CHAR FAR1 *temp = (const CHAR FAR1 *)buffer;
  /* Set timeout to 5 seconds from now */
  ULONG writeTimeout = flMsecCounter + 5000;

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

  if ((length & 1) || (address & 1))	/* Only write words on word-boundary */
    return flBadParameter;

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    checkStatus(flNeedVpp(vol.socket));
#endif

  if (thisCFI->maxBytesWrite > 1) /* multi-byte write supported */
    eachWrite = thisCFI->maxBytesWrite / 2;   /* we are counting words */
  else
    eachWrite = 1;

  /* we assume that the interleaving is 1. */
  for (from = 0; (from < length / 2) && (status == flOK); from += eachWrite) {
    USHORT *fromPtr;
    ULONG thisLength = (length / 2) - from;

    if (thisLength > eachWrite)
      thisLength = eachWrite;

    flashPtr = (FlashWPTR)flMap(vol.socket, address + from * 2);

    do {
      tffsWriteWordFlash(flashPtr, WRITE_TO_BUFFER);
    } while (!(tffsReadByteFlash(flashPtr) & SR_READY) && (flMsecCounter < writeTimeout));
    if (!(tffsReadByteFlash(flashPtr) & SR_READY)) {
      DEBUG_PRINT(("Debug: timeout error in CFISCS write.\n"));
      status = flWriteFault;
    }
    tffsWriteWordFlash(flashPtr, (USHORT) (thisLength - 1));

    for(i = 0, fromPtr = (USHORT *)(temp + from * 2);
	i < thisLength;
	i++, fromPtr++)
      tffsWriteWordFlash(flashPtr + i, *fromPtr);


    tffsWriteWordFlash(flashPtr, CONFIRM_WRITE);

    while (!(tffsReadByteFlash(flashPtr) & SR_READY) && (flMsecCounter < writeTimeout))
      ;
    if (!(tffsReadByteFlash(flashPtr) & SR_READY)) {
      DEBUG_PRINT(("Debug: timeout error in CFISCS write.\n"));
      status = flWriteFault;
    }
    if (tffsReadByteFlash(flashPtr) & WSM_ERROR) {
      DEBUG_PRINT(("Debug: CFISCS write error.\n"));
      status = (tffsReadByteFlash(flashPtr) & SR_VPP_ERROR) ? flVppFailure : flWriteFault;
      tffsWriteWordFlash(flashPtr, CLEAR_STATUS);
    }
    tffsWriteWordFlash(flashPtr, READ_ARRAY);
  }

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    flDontNeedVpp(vol.socket);
#endif

  byteFlashPtr = (FlashPTR) flMap(vol.socket, address);
  /* verify the data */
  if (status == flOK) {
    for(i = 0; i < length - 4; i += 4) {
      if (tffsReadDwordFlash((PUCHAR)(byteFlashPtr+i)) != *(ULONG *)(temp+i)) {
	DEBUG_PRINT(("Debug: CFISCS write failed in verification.\n"));
	status = flWriteFault;
      }
    }
    for(; i < length; i++) {
      if (tffsReadByteFlash(byteFlashPtr+i) != *(UCHAR *)(temp+i)) {
	DEBUG_PRINT(("Debug: CFISCS write failed in verification.\n"));
	status = flWriteFault;
      }
    }
  }

  return status;
}


/************************************************************************/
/*		  Auxiliary routines for cfiscsByteErase		*/
/************************************************************************/

/*----------------------------------------------------------------------*/
/*			m a k e C o m m a n d				*/
/*									*/
/* Create a command to write to the flash. This routine is used for	*/
/* byte mode, write command to the relevant chip and 0xff to the other	*/
/* chip if interleaving is greater than 1, or write the command if	*/
/* interleaving is 1.							*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	command 	: Command to be written to the media		*/
/*	chip		: first chip (0) or second chip (1)		*/
/*									*/
/* Returns:								*/
/*	The command that should be written to the media 		*/
/*----------------------------------------------------------------------*/

USHORT makeCommand(FLFlash vol, USHORT command, LONG chip)
{
  if ((vol.interleaving == 1) || (chip == 0))
    return command | 0xff00;
  else
    return (command << 8) | 0xff;
}

/*----------------------------------------------------------------------*/
/*			g e t D a t a					*/
/*									*/
/* Read the lower byte or the upper byte from a given word.		*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	wordData	: the given word				*/
/*	chip		: if chip = 0 read lower byte			*/
/*			  if chip = 1 read upper byte			*/
/*									*/
/* Returns:								*/
/*	The byte that was read. 					*/
/*----------------------------------------------------------------------*/

UCHAR getData(FLFlash vol, USHORT wordData, LONG chip)
{
  if ((vol.interleaving == 1) || (chip == 0))
    return (UCHAR)wordData;	     /* lower byte */
  else
    return (UCHAR)(wordData >> 8);   /* upper byte */
}

/*----------------------------------------------------------------------*/
/*			c f i s c s B y t e E r a s e			*/
/*									*/
/* Erase one or more contiguous Flash erasable blocks in a byte-mode.	*/
/*									*/
/* This routine will be registered as the MTD flash.erase routine	*/
/*									*/
/* Parameters:								*/
/*	vol		   : Pointer identifying drive			*/
/*	firstErasableBlock : Number of first block to erase		*/
/*	numOfErasableBlocks: Number of blocks to erase			*/
/*									*/
/* Returns:								*/
/*	FLStatus	   : 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

FLStatus cfiscsByteErase(FLFlash vol,
				word firstErasableBlock,
				word numOfErasableBlocks)
{
  LONG iBlock;
  /* Set timeout to 5 seconds from now */
  ULONG writeTimeout = flMsecCounter + 5000;

  FLStatus status = flOK;	/* unless proven otherwise */

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    checkStatus(flNeedVpp(vol.socket));
#endif

  for (iBlock = 0; iBlock < numOfErasableBlocks && status == flOK; iBlock++) {
    LONG j;
    FLBoolean finished;

    FlashWPTR flashPtr = (FlashWPTR)
			 flMap(vol.socket, (firstErasableBlock + iBlock) * vol.erasableBlockSize);

    for (j = 0; j * 2 < vol.interleaving; j++) {  /* access chips in pairs */
      LONG i;

      for (i = 0; i < (vol.interleaving == 1 ? 1 : 2); i++) { /* write to each chip seperately */
	if (thisCFI->optionalCommands & QUEUED_ERASE_SUPPORT) {
	  do {
	    tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, SETUP_QUEUE_ERASE, i));
	  } while (!(getData(&vol, tffsReadWordFlash(flashPtr+j), i) & SR_READY) &&
		   (flMsecCounter < writeTimeout));
	  if (!(getData(&vol, tffsReadWordFlash(flashPtr+j), i) & SR_READY)) {
	    DEBUG_PRINT(("Debug: timeout error in CFISCS erase.\n"));
	    status = flWriteFault;
	  }
	  else
	    tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, CONFIRM_ERASE, i));
	}
	else {
	  tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, SETUP_BLOCK_ERASE, i));
	  tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, CONFIRM_ERASE, i));
	}
      }
    }

    do {
#ifdef FL_BACKGROUND
      if (thisCFI->optionalCommands & SUSPEND_ERASE_SUPPORT) {
	while (flForeground(1) == BG_SUSPEND) { 	 /* suspend */
	  for (j = 0; j < vol.interleaving; j += 2, flashPtr++) {
	    LONG i;

	    for (i = 0; i < (vol.interleaving == 1 ? 1 : 2); i++) {
	      tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, READ_STATUS, i));
	      if (!(getData(&vol, tffsReadWordFlash(flashPtr+j), i) & SR_READY)) {
		tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, SUSPEND_ERASE, i));
		tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, READ_STATUS, i));
		while (!(getData(&vol, tffsReadWordFlash(flashPtr+j), i) & SR_READY))
		;
	      }
	      tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, READ_ARRAY, i));
	    }
	  }
	}
      }
#endif
      finished = TRUE;
      for (j = 0; j * 2 < vol.interleaving; j++) {
	LONG i;

	for (i = 0; i < (vol.interleaving == 1 ? 1 : 2); i++) {
	  tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, READ_STATUS, i));
	  if (!(getData(&vol, tffsReadWordFlash(flashPtr+j), i) & SR_READY))
	    finished = FALSE;
	  else if (getData(&vol, tffsReadWordFlash(flashPtr+j), i) & SR_ERASE_SUSPEND) {
	    tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, RESUME_ERASE, i));
	    finished = FALSE;
	  }
	  else {
	    if (getData(&vol, tffsReadWordFlash(flashPtr+j), i) & WSM_ERROR) {
	      DEBUG_PRINT(("Debug: CFISCS erase error.\n"));
	      status = (getData(&vol, tffsReadWordFlash(flashPtr+j), i) & SR_VPP_ERROR) ?
			flVppFailure : flWriteFault;
	      tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, CLEAR_STATUS, i));
	    }
	    tffsWriteWordFlash(flashPtr+j, makeCommand(&vol, READ_ARRAY, i));
	  }
	}
      }
      flDelayMsecs(1);
    } while (!finished);
  }

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    flDontNeedVpp(vol.socket);
#endif

  return status;
}

/*----------------------------------------------------------------------*/
/*			c f i s c s W o r d E r a s e			*/
/*									*/
/* Erase one or more contiguous Flash erasable blocks in a word-mode	*/
/*									*/
/* This routine will be registered as the MTD flash.erase routine	*/
/*									*/
/* Parameters:								*/
/*	vol		   : Pointer identifying drive			*/
/*	firstErasableBlock : Number of first block to erase		*/
/*	numOfErasableBlocks: Number of blocks to erase			*/
/*									*/
/* Returns:								*/
/*	FLStatus	   : 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/
FLStatus cfiscsWordErase(FLFlash vol,
				word firstErasableBlock,
				word numOfErasableBlocks)
{
  FLStatus status = flOK;	/* unless proven otherwise */
  LONG iBlock;
  /* Set timeout to 5 seconds from now */
  ULONG writeTimeout = flMsecCounter + 5000;

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    checkStatus(flNeedVpp(vol.socket));
#endif

  for (iBlock = 0; iBlock < numOfErasableBlocks && status == flOK; iBlock++) {
    FLBoolean finished;

    FlashWPTR flashPtr = (FlashWPTR)
			 flMap(vol.socket,(firstErasableBlock + iBlock) * vol.erasableBlockSize);

    if (thisCFI->optionalCommands & QUEUED_ERASE_SUPPORT) {
      do {
	tffsWriteWordFlash(flashPtr, SETUP_QUEUE_ERASE);
      } while (!(tffsReadByteFlash(flashPtr) & SR_READY) && (flMsecCounter < writeTimeout));
      if (!(tffsReadByteFlash(flashPtr) & SR_READY)) {
	DEBUG_PRINT(("Debug: timeout error in CFISCS erase.\n"));
	status = flWriteFault;
      }
      else
	tffsWriteWordFlash(flashPtr, CONFIRM_ERASE);
    }
    else {
      tffsWriteWordFlash(flashPtr, SETUP_BLOCK_ERASE);
      tffsWriteWordFlash(flashPtr, CONFIRM_ERASE);
    }

    do {
#ifdef FL_BACKGROUND
      if (thisCFI->optionalCommands & SUSPEND_ERASE_SUPPORT) {
	while (flForeground(1) == BG_SUSPEND) { 	/* suspend */
	  if (!(tffsReadByteFlash(flashPtr) & SR_READY)) {
	    tffsWriteWordFlash(flashPtr, SUSPEND_ERASE);
	    tffsWriteWordFlash(flashPtr, READ_STATUS);
	    while (!(tffsReadByteFlash(flashPtr) & SR_READY))
	      ;
	  }
	  tffsWriteWordFlash(flashPtr, READ_ARRAY);
	}
      }
#endif

      finished = TRUE;

      if (!(tffsReadByteFlash(flashPtr) & SR_READY))
	finished = FALSE;
      else if (tffsReadByteFlash(flashPtr) & SR_ERASE_SUSPEND) {
	tffsWriteWordFlash(flashPtr, RESUME_ERASE);
	finished = FALSE;
      }
      else {
	if (tffsReadByteFlash(flashPtr) & WSM_ERROR) {
	  DEBUG_PRINT(("Debug: CFISCS erase error.\n"));
	  status = (tffsReadByteFlash(flashPtr) & SR_VPP_ERROR) ? flVppFailure : flWriteFault;
	  tffsWriteWordFlash(flashPtr, CLEAR_STATUS);
	}
	tffsWriteWordFlash(flashPtr, READ_ARRAY);
      }
      flDelayMsecs(1);
    } while (!finished);
  }

#ifdef SOCKET_12_VOLTS
  if (thisCFI->vpp)
    flDontNeedVpp(vol.socket);
#endif

  return status;
}


/*----------------------------------------------------------------------*/
/*			  c f i s c s M a p				*/
/*									*/
/* Map through buffer. This routine will be registered as the map	*/
/* routine for this MTD.						*/
/*									*/
/* Parameters:								*/
/*	vol	: Pointer identifying drive				*/
/*	address : Flash address to be mapped.				*/
/*	length	: number of bytes to map.				*/
/*									*/
/* Returns:								*/
/*	Pointer to the buffer data was mapped to.			*/
/*									*/
/*----------------------------------------------------------------------*/

VOID FAR0 *cfiscsMap (FLFlash vol, CardAddress address, int length)
{
  vol.socket->remapped = TRUE;
  return mapThroughBuffer(&vol,address,length);
}


/*----------------------------------------------------------------------*/
/*			  c f i s c s R e a d				*/
/*									*/
/* Read some data from the flash. This routine will be registered as	*/
/* the read routine for this MTD.					*/
/*									*/
/* Parameters:								*/
/*	vol	: Pointer identifying drive				*/
/*	address : Address to read from. 				*/
/*	buffer	: buffer to read to.					*/
/*	length	: number of bytes to read (up to sector size).		*/
/*	modes	: EDC flag etc. 					*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failed.		*/
/*									*/
/*----------------------------------------------------------------------*/

FLStatus cfiscsRead(FLFlash vol,
			 CardAddress address,
			 VOID FAR1 *buffer,
			 dword length,
			 word modes)
{
  ULONG i;
  UCHAR * byteBuffer;
  FlashPTR byteFlashPtr;
  ULONG * doubleWordBuffer = (ULONG *)buffer;
  FlashDPTR doubleWordFlashPtr = (FlashDPTR)flMap(vol.socket, address);

  for (i = 0; i < length - 4; i += 4, doubleWordBuffer++, doubleWordFlashPtr++) {
    *doubleWordBuffer = tffsReadDwordFlash(doubleWordFlashPtr);
  }
  byteBuffer = (UCHAR *)doubleWordBuffer;
  byteFlashPtr = (FlashPTR)doubleWordFlashPtr;
  for(; i < length; i++, byteBuffer++, byteFlashPtr++) {
    *byteBuffer = tffsReadByteFlash(byteFlashPtr);
  }
  return flOK ;
}


/*----------------------------------------------------------------------*/
/*		       c f i s c s I d e n t i f y			*/
/*									*/
/* Identifies media based on SCS/CFI and registers as an MTD for	*/
/* such.								*/
/*									*/
/* This routine will be placed on the MTD list in custom.h. It must be	*/
/* an extern routine.							*/
/*									*/
/* On successful identification, the Flash structure is filled out and	*/
/* the write and erase routines registered.				*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on positive identificaion, failed otherwise */
/*----------------------------------------------------------------------*/
FLStatus cfiscsIdentify(FLFlash vol)
{
  FlashWPTR flashPtr;
  CHAR queryIdStr[ID_STR_LENGTH + 1] = QUERY_ID_STR;

  DEBUG_PRINT(("Debug: entering CFISCS identification routine.\n"));

  flSetWindowBusWidth(vol.socket, 16);/* use 16-bits */
  flSetWindowSpeed(vol.socket, 150);  /* 120 nsec. */
  flSetWindowSize(vol.socket, 2);	/* 8 KBytes */

  vol.mtdVars = &mtdVars_cfiscs[flSocketNoOf(vol.socket)];

  /* try word mode first */
  flashPtr = (FlashWPTR)flMap(vol.socket, 0);
  tffsWriteWordFlash(flashPtr+0x55, QUERY);
  if ((tffsReadWordFlash(flashPtr+0x10) == (USHORT)queryIdStr[0]) &&
      (tffsReadWordFlash(flashPtr+0x11) == (USHORT)queryIdStr[1]) &&
      (tffsReadWordFlash(flashPtr+0x12) == (USHORT)queryIdStr[2])) {
    vol.type = (tffsReadWordFlash(flashPtr) << 8) |
		tffsReadWordFlash(flashPtr+1);
    vol.interleaving = 1;
    thisCFI->wordMode = TRUE;
    vol.write = cfiscsWordWrite;
    vol.erase = cfiscsWordErase;
    checkStatus(getWordCFI(&vol));
    DEBUG_PRINT(("Debug: identified 16-bit CFISCS.\n"));
  }
  else {      /* Use standard identification routine to detect byte-mode */
    checkStatus(cfiscsByteIdentify(&vol));
    thisCFI->wordMode = FALSE;
    vol.write = cfiscsByteWrite;
    vol.erase = cfiscsByteErase;
    checkStatus(getByteCFI(&vol));
    DEBUG_PRINT(("Debug: identified 8-bit CFISCS.\n"));
  }

  checkStatus(thisCFI->wordMode ? cfiscsWordSize(&vol) : cfiscsByteSize(&vol));

  vol.map = cfiscsMap;
  vol.read = cfiscsRead;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*		     f l R e g i s t e r C F I S C S			*/
/*									*/
/* Registers this MTD for use						*/
/*									*/
/* Parameters:								*/
/*	None								*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failure		*/
/*----------------------------------------------------------------------*/

FLStatus flRegisterCFISCS(VOID)
{
  if (noOfMTDs >= MTDS)
    return flTooManyComponents;

  mtdTable[noOfMTDs++] = cfiscsIdentify;

  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\bddefs.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/BDDEFS.H_V  $
 * 
 *    Rev 1.4   Jan 17 2002 23:00:00   oris
 * Replace FLFlash record with a pointer to FLFlash record (TrueFFS now uses only SOCKETS number of FLFlash records).
 * Removed SINGLE_BUFFER ifdef.
 * Added partition parameter to setBusy.
 * 
 *    Rev 1.3   Mar 28 2001 05:59:22   oris
 * copywrite dates.
 * Added empty line at the end of the file
 * left alligned all # directives
 * Removed dismountLowLevel extern prototype
 *
 *    Rev 1.2   Feb 18 2001 14:22:58   oris
 * Removed driveHandle field from volume record.
 *
 *    Rev 1.1   Feb 12 2001 12:51:08   oris
 * Changed the mutex field to a pointer to support TrueFFS 5.0 mutex mechanism
 *
 *    Rev 1.0   Feb 02 2001 12:04:16   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef BDDEFS_H
#define BDDEFS_H

#include "fltl.h"
#include "flsocket.h"
#include "flbuffer.h"
#include "stdcomp.h"

typedef struct {
  char          flags;                  /* See description in flreq.h */
  unsigned      sectorsPerCluster;      /* Cluster size in sectors */
  unsigned      maxCluster;             /* highest cluster no. */
  unsigned      bytesPerCluster;        /* Bytes per cluster */
  unsigned      bootSectorNo;           /* Sector no. of DOS boot sector */
  unsigned      firstFATSectorNo;       /* Sector no. of 1st FAT */
  unsigned      secondFATSectorNo;      /* Sector no. of 2nd FAT */
  unsigned      numberOfFATS;           /* number of FAT copies */
  unsigned      sectorsPerFAT;          /* Sectors per FAT copy */
  unsigned      rootDirectorySectorNo;  /* Sector no. of root directory */
  unsigned      sectorsInRootDirectory; /* No. of sectors in root directory */
  unsigned      firstDataSectorNo;      /* 1st cluster sector no. */
  unsigned      allocationRover;        /* rover pointer for allocation */

#if FILES > 0
  FLBuffer      volBuffer;              /* Define a sector buffer */
#endif
  FLMutex*      volExecInProgress;
  FLFlash FAR2* flash;                  /* flash structure for low level operations */
  TL            tl;                     /* Translation layer methods */
  FLSocket      *socket;                /* Pointer to socket */
#ifdef WRITE_PROTECTION
  unsigned long password[2];
#endif
#ifdef WRITE_EXB_IMAGE
  dword binaryLength;        /* Actual binary area taken by the exb      */
  byte  moduleNo;            /* Currently written module                 */
#endif /* WRITE_EXB_IMAGE */
} Volume;

/* drive handle masks */

#if defined(FILES) && FILES > 0
typedef struct {
  long          currentPosition;        /* current byte offset in file */
#define         ownerDirCluster currentPosition /* 1st cluster of owner directory */
  long          fileSize;               /* file size in bytes */
  SectorNo      directorySector;        /* sector of directory containing file */
  unsigned      currentCluster;         /* cluster of current position */
  unsigned char directoryIndex;         /* entry no. in directory sector */
  unsigned char flags;                  /* See description below */
  Volume *      fileVol;                /* Drive of file */
} File;

/* File flag definitions */
#define FILE_MODIFIED           4       /* File was modified */
#define FILE_IS_OPEN            8       /* File entry is used */
#define FILE_IS_DIRECTORY    0x10       /* File is a directory */
#define FILE_IS_ROOT_DIR     0x20       /* File is root directory */
#define FILE_READ_ONLY       0x40       /* Writes not allowed */
#define FILE_MUST_OPEN       0x80       /* Create file if not found */
#endif /* FILES > 0 */

/* #define buffer (vol.volBuffer) */
#define execInProgress (vol.volExecInProgress)

extern FLStatus dismountVolume(Volume vol);
extern FLBoolean initDone;      /* Initialization already done */
extern Volume   vols[VOLUMES];
extern FLStatus setBusy(Volume vol, FLBoolean state, byte partition);
const void FAR0 *findSector(Volume vol, SectorNo sectorNo);
FLStatus dismountFS(Volume vol,FLStatus status);
#if FILES>0
void initFS(void);
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\doc2exb.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOC2EXB.H_V  $
 * 
 *    Rev 1.11   Apr 15 2002 07:35:22   oris
 * Make sure all relevant structures will allow easy little endian conversion.
 * 
 *    Rev 1.10   Feb 19 2002 20:58:38   oris
 * Moved include directive and routine  prototypes to C file.
 * 
 *    Rev 1.9   Jan 21 2002 20:44:12   oris
 * Added DiskOnChip Millennium Plus 16MB firmware family definition.
 * 
 *    Rev 1.8   Jan 17 2002 22:58:42   oris
 * Added INFTL_NEAR_HEAP_SIZE, FIRMWARE_NO_MASK, STRONG_ARM_IPL  definitions.
 * Removed different firmware STACK sizes.
 * Added parameter to getExbInfo() (firmware add to).
 * Added tffsFarHeapSize to exbStruct record.
 * 
 *    Rev 1.7   Jul 13 2001 01:01:06   oris
 * Added constant stack space for each of the different DiskOnChip.
 * 
 *    Rev 1.6   Jun 17 2001 08:17:24   oris
 * Changed placeExbByBuffer exbflags argument to word instead of byte to  support /empty flag.
 * Added LEAVE_EMPTY and EXB_IN_ROM flags.
 * 
 *    Rev 1.5   Apr 09 2001 15:05:14   oris
 * End with an empty line.
 * 
 *    Rev 1.4   Apr 03 2001 14:39:54   oris
 * Add iplMod512 and splMod512 fields to the exbStruct record.
 *
 *    Rev 1.3   Apr 02 2001 00:56:48   oris
 * Added EBDA_SUPPORT flag.
 * Bug fix of NO_PNP_HEADER flag.
 * Changed ifdef of h file from doc2hdrs_h to doc2exb_h.
 *
 *    Rev 1.2   Apr 01 2001 07:50:00   oris
 * Updated copywrite notice.
 * Changed LEmin to dword
 * Added DOC2300_FAMILY_FIRMWARE firmware types.
 *
 *    Rev 1.1   Feb 08 2001 10:32:06   oris
 * Seperated file signature into 2 fields signature and TrueFFS vesion to make it eligned
 *
 *    Rev 1.0   Feb 02 2001 13:10:58   oris
 * Initial revision.
 *
 */


/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Project : TrueFFS source code                                              *
*                                                                            *
* Name : doc2exb.h                                                           *
*                                                                            *
* Description : M-Systems EXB firmware files and media definitions and       *
*               data structures                                              *
*                                                                            *
*****************************************************************************/

#ifndef DOC2EXB_H
#define DOC2EXB_H

#include "docbdk.h"

#ifdef BDK_ACCESS
extern BDKVol*  bdkVol;         /* pointer to current binary partition */
#endif

/**********************************/
/* EXB file structure definitions */
/**********************************/

/* EXB Flag definitions */
#define INSTALL_FIRST     1
#define EXB_IN_ROM        2
#define QUIET             4
#define INT15_DISABLE     8
#define FLOPPY            0x10
#define SIS5598           0x20
#define EBDA_SUPPORT      0x40
#define NO_PNP_HEADER     0x80
#define LEAVE_EMPTY       0x100 
#define FIRMWARE_NO_MASK  0xd00 /* Up to 8 firmwares */
#define FIRMWARE_NO_SHIFT 9

/* Firmware types */
#define DOC2000_FAMILY_FIRMWARE      1
#define DOCPLUS_FAMILY_FIRMWARE      2
#define DOC2300_FAMILY_FIRMWARE      3
#define DOCPLUS_INT1_FAMILY_FIRMWARE 4

/* Firmware stack constant */
#ifdef VERIFY_WRITE
#define INFTL_NEAR_HEAP_SIZE sizeof(FLBuffer)+(SECTOR_SIZE<<1)+READ_BACK_BUFFER_SIZE
#else
#define INFTL_NEAR_HEAP_SIZE sizeof(FLBuffer)+(SECTOR_SIZE<<1)
#endif /* VERIFY_WRITE */
#define DEFAULT_DOC_STACK 2*1024

/*General definitions */
#define MAX_CODE_MODULES        6
#define ANAND_MARK_ADDRESS      0x406
#define ANAND_MARK_SIZE         2
#define EXB_SIGN_OFFSET         8
#define INVALID_MODULE_NO       0xff
#define SIGN_SPL                ""    /* EXB binary signature */
#define SIGN_MSYS               "OSAK"    /* EXB file signature   */
#define SIGN_MSYS_SIZE          4
/* File specific record specifing data for all firmwares in the file */

typedef struct {
  byte  mSysSign[SIGN_MSYS_SIZE];       /* identification signature */
  byte  osakVer[SIGN_MSYS_SIZE];        /* identification signature */
  LEmin fileSize;                       /* Total file size */
  LEmin noOfFirmwares;                  /* Number of firmware supported by this file */
} ExbGlobalHeader;
/*-------------------------------------*/

/* File specific record specifing data for a specific firmwares in the file */

typedef struct {
  LEmin type;                           /* Firmware type (must fit the H/W)  */
  LEmin startOffset;                    /* Firmware start offset in the file */
  LEmin endOffset;                      /* Firmware end offset in the file   */
  LEmin splStartOffset;                 /* SPL start offset in the file      */
  LEmin splEndOffset;                   /* SPL end offset in the file        */
} FirmwareHeader;
/*-------------------------------------*/

/* data structure representing BIOS extention header */

typedef struct{
  unsigned char  signature[2]; /* BIOS extention signature (0xAA55) */
  unsigned char  lenMod512; /* length in unsigned chars modulo 512 */
} BIOSHeader;
/*-------------------------------------*/

/* data structure representing IPL header */

typedef struct{
  BIOSHeader     biosHdr;
  byte           jmpOpcode[3];     /* jmp start_of_code                      */
  byte           dummy;            /* dummy byte                             */
  byte           msysStr[17];      /* ORG  7h ManStr DB '(C)M-Systems1998',0 */
  word           pciHeader;        /* ORG 18h   ; PCI header                 */
  word           pnpHeader;        /* ORG 1Ah   ; P&P header                 */
  byte           dummy0[4];        /* Actual address must be shifted by 4 '0'*/
  LEushort       windowBase;       /* ORG 20h   ; explicit DOC window base   */
  Unaligned      spl_offset;       /* DFORMAT !!!                            */
  Unaligned      spl_size;         /* spl actual size                        */
  byte           spl_chksum;       /* 55                                     */
} IplHeader;
/*-------------------------------------*/

/* data structure representing SPL header */

typedef struct{
  unsigned char  jmpOpcode[2];
  BIOSHeader     biosHdr;
      /* Note: At run-time biosHdr.lenMod512 contains size of entire DOC 2000
      boot area modulo 512 as set by DFORMAT  */
  Unaligned      runtimeID;        /* filled in by DFORMAT  */
  Unaligned      tffsHeapSize;     /* filled in by DFORMAT  */
  unsigned char  chksumFix;        /* changed by DFORMAT */
  unsigned char  version;
  unsigned char  subversion;
  char           copyright[29];    /* "SPL_DiskOnChip (c) M-Systems", 0 */
  Unaligned      windowBase;       /* filled in by DFORMAT */
  Unaligned4     exbOffset;        /* filled in by DFORMAT */
} SplHeader;
/*------------------------------------- */

/* data structure representing TFFS header */

typedef struct{
  BIOSHeader     biosHdr;
  unsigned char  jmpOpcode[3];
  char           tffsId[4];         /* "TFFS" */
  unsigned char  exbFlags;          /* filled in by writeExbDriverImage() */
  Unaligned      heapLen;           /* not used for now */
  Unaligned      windowBase;        /* passed by SPL and saved here */
  unsigned char  chksumFix;         /* changed by writeExbDriverImage() */
  Unaligned      runtimeID;         /* passed by SPL and saved here */
  unsigned char  firstDiskNumber;   /* filled in............  */
  unsigned char  lastDiskNumber;    /* ..........at run-time */
  Unaligned      versionNo;         /* filled in at run-time */
} TffsHeader;
/* ------------------------------------- */

/* data structure representing Socket Services  header */

typedef struct{
  BIOSHeader     biosHdr;
  unsigned char  jmpOpcode[3];
  char           tffsId[4];         /* "TFFS" */
  unsigned char  exbFlags;          /* filled in by writeExbDriverImage() */
  unsigned char  heapLen;           /* not used for now */
  Unaligned      windowBase;        /* filled in at run-time */
  unsigned char  chksumFix;         /* changed by writeExbDriverImage() */
} SSHeader;
/* ------------------------------------- */

/* Work space for writting the exb file */

typedef struct{
  word  exbFlags;            /* For the complete list see doc2hdrs.h     */
  word  iplMod512;           /* Size of the IPL module divided by 512    */
  word  splMod512;           /* Size of the SPL module divided by 512    */
  dword splMediaAddr;        /* Start of the SPL module media address    */
  dword ssMediaAddr;         /* Start of the SS module media address     */
  dword exbRealSize;         /* Actual binary area + bad blocks          */
  word  moduleLength;        /* Length of the modules in divided by 512  */
  dword tffsHeapSize;        /* TFFS needed heap size                    */
  word  tffsFarHeapSize;     /* TFFS needed far heap size                */
  word  bufferOffset;        /* Curret Offset inside the internal buffer */
  dword exbFileEnd;          /* Offset of the last Byte of the files     */
  dword exbFileOffset;       /* Current Offset inside the EXB file       */
  dword splStart;            /* First SPL byte offset                    */
  dword splEnd;              /* Last SPL byte offset                     */
  dword firmwareEnd;         /* End offset of the specific firmware      */
  dword firmwareStart;       /* Start offset of the specific firmware    */
  FLBuffer *buffer;          /* Internal 512 byte buffer                 */
} exbStruct;

#endif /* DOC2EXB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\blockdev.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/BLOCKDEV.H_V  $
 * 
 *    Rev 1.20   Apr 15 2002 07:34:06   oris
 * Bug fix - FL_IPL_MODE_XSCALE define was set to 3 instead of 4 and therefore caused FL_IPL_DOWNLOAD and FL_IPL_MODE_SA to be set as well.
 * 
 *    Rev 1.19   Feb 19 2002 20:58:20   oris
 * Removed warnings.
 * Moved FLFunctionNo enumerator to dedicated file flfuncno.h
 * Added include directive for cleaner customer usage.
 * 
 *    Rev 1.18   Jan 29 2002 20:07:16   oris
 * Moved flParsePath declaration to the end of the file.
 * Changed LOW_LEVEL compilation flag with FL_LOW_LEVEL to prevent definition clashes.
 * Added documentation of irFlags in flMountVolume (returns no of hidden sectors of the media).
 * flSetEnvVolume, flSetEnvSocket , flSetEnvAll , flSetDocBusRoutine , flGetDocBusRoutine, flBuildGeometry , bdCall and flExit
 * Added FL_IPL_MODE_XSCALE definition and change FL_IPL_XXX values.
 * 
 *    Rev 1.17   Jan 28 2002 21:23:46   oris
 * Changed FL_NFTL_CACHE_ENABLED to FL_TL_CACHE_ENABLED.
 * Changed flSetDocBusRoutine interface and added flGetDocBusRoutine. 
 * 
 *    Rev 1.16   Jan 23 2002 23:30:54   oris
 * Added documentation of irData and irLength to flCheckVolume.
 * 
 *    Rev 1.15   Jan 20 2002 20:27:40   oris
 * Added TL_NORMAL_FORMAT flag was added to bdFormatPhisycalDrive instead of 0 (in the comments).
 * Removed TL_QUICK_MOUNT_FORMAT flag definition.
 * 
 *    Rev 1.14   Jan 17 2002 22:57:18   oris
 * Added flClearQuickMountInfo() routine - FL_CLEAR_QUICK_MOUNT_INFO
 * Added flVerifyVolume() routine - FL_VERIFY_VOLUME
 * Added DiskOnChip Millennium Plus 16MB type
 * Changed the order of FLEnvVars enumerator.
 * Added FLEnvVars values for :
 *       FL_SECTORS_VERIFIED_PER_FOLDING 
 *       FL_SUSPEND_MODE
 *       FL_VERIFY_WRITE_OTHER
 *       FL_MTD_BUS_ACCESS_TYPE
 *       FL_VERIFY_WRITE_BDTL
 *       FL_VERIFY_WRITE_BINARY
 * flSetEnv() routine was changed into 3 different routines: flSetEnvVolume / flSetEnvSocket / flSetEnvAll
 * Removed TL_SINGLE_FLOOR_FORMATTING flag definition from format routine.
 * Added flSetDocBusRoutines prototype and required definitions.
 * 
 *    Rev 1.13   Nov 21 2001 11:39:36   oris
 * Changed FL_VERIFY_WRITE_MODE to FL_MTD_VERIFY_WRITE.
 * 
 *    Rev 1.12   Nov 08 2001 10:44:18   oris
 * Added FL_VERIFY_WRITE_MODE enumerator type for the flSetEnv routine .
 * Moved environment variable states definitions to flbase.h.
 * 
 *    Rev 1.11   Sep 15 2001 23:44:30   oris
 * Placed flDeepPowerDownMone under LOW_LEVEL compilation flag.
 * 
 *    Rev 1.10   May 17 2001 16:50:32   oris
 * Removed warnings.
 * 
 *    Rev 1.9   May 16 2001 21:16:22   oris
 * Added the Binary state (0,1) of the environment variables to meaningful definitions.
 * Removed LAST function enumerator.
 * Improved documentation.
 * 
 *    Rev 1.8   May 06 2001 22:41:14   oris
 * Added SUPPORT_WRITE_IPL_ROUTIN capability.
 * 
 *    Rev 1.7   Apr 30 2001 17:57:50   oris
 * Added required defintions to support the flMarkDeleteOnFlash environment variable. 
 * 
 *    Rev 1.6   Apr 24 2001 17:05:52   oris
 * Changed bdcall function numbers in order to allow future grouth.
 * 
 *    Rev 1.5   Apr 01 2001 07:49:04   oris
 * Added FL_READ_IPL .
 * flChangeEnvironmentVariable prototype removed.
 * Moved s/w protection definitions from iovtl.h to blockdev.h
 * Changed s\w and h\w to s/w and h/w.
 * Added flBuildGeometry prototype 
 * Moved bdcall prototype to the end of the file with the rest of the prototypes.
 * 
 *    Rev 1.4   Feb 18 2001 14:15:38   oris
 * Changed function enums order.
 *
 *    Rev 1.3   Feb 14 2001 01:44:16   oris
 * Changed capabilities from defined flags to an enumerator
 * Improoved documentation of readBBT, writeBBT InquireCapabilities, countVolumes
 * Added environment variables defintions
 *
 *    Rev 1.2   Feb 13 2001 02:08:42   oris
 * Moved LOCKED_OTP and DEEP_POWER_DOWN to flflash.h
 * Moved TL_FORMAT_FAT and TL_FORMAT_COMPRESSION to flformat.h
 * Added extern declaration for flSetEnv routine.
 *
 *    Rev 1.1   Feb 12 2001 11:54:46   oris
 * Added baseAddress in flGetPhysicalInfo as irLength.
 * Added boot sectors in flMountVolumes as irFlags.
 * Change order of routines definition.
 *
 *    Rev 1.0   Feb 04 2001 18:05:04   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef BLOCKDEV_H
#define BLOCKDEV_H

#include "flreq.h"
#include "flfuncno.h"
#include "docsys.h"

#ifdef FORMAT_VOLUME
#include "dosformt.h"
#endif /* FORMAT_VOLUME */
#ifdef WRITE_EXB_IMAGE
#include "doc2exb.h"
#else
#ifdef BDK_ACCESS
#include "docbdk.h"
#endif /* BDK_ACCESS */
#endif /* WRITE_EXB_IMAGE */



/*----------------------------------------------------------------------*/
/*                           b d C a l l                                */
/*                                                                      */
/* Common entry-point to all TrueFFS functions. Macros are to call      */
/* individual function, which are separately described below.           */
/*                                                                      */
/* Parameters:                                                          */
/*        function   : Block device driver function code (listed below) */
/*        ioreq      : IOreq structure                                  */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus   : 0 on success, otherwise failed                   */
/*----------------------------------------------------------------------*/

#if FILES > 0
#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                     f l F l u s h B u f f e r                        */
/*                                                                      */
/* If there is relevant data in the RAM buffer then writes it on        */
/*   the flash memory.                                                  */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle  : Drive number (0, 1, ...)                          */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flFlushBuffer(ioreq)        bdCall(FL_FLUSH_BUFFER,ioreq)

#endif                                  /* READ_ONLY */
/*----------------------------------------------------------------------*/
/*                      f l O p e n F i l e                             */
/*                                                                      */
/* Opens an existing file or creates a new file. Creates a file handle  */
/* for further file processing.                                         */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irFlags         : Access and action options, defined below    */
/*        irPath          : path of file to open                        */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irHandle        : New file handle for open file               */
/*                                                                      */
/*----------------------------------------------------------------------*/

/** Values of irFlags for flOpenFile: */

#define ACCESS_MODE_MASK   3 /* Mask for access mode bits */

/* Individual flags */

#define ACCESS_READ_WRITE  1 /* Allow read and write */
#define ACCESS_CREATE      2 /* Create new file      */

/* Access mode combinations */

#define OPEN_FOR_READ      0 /* open existing file for read-only         */
#define OPEN_FOR_UPDATE    1 /* open existing file for read/write access */
#define OPEN_FOR_WRITE     3 /* create a new file, even if it exists     */


#define flOpenFile(ioreq)        bdCall(FL_OPEN_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*                      f l C l o s e F i l e                           */
/*                                                                      */
/* Closes an open file, records file size and dates in directory and    */
/* releases file handle.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Handle of file to close.                    */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flCloseFile(ioreq)      bdCall(FL_CLOSE_FILE,ioreq)

#ifndef FL_READ_ONLY
#ifdef SPLIT_JOIN_FILE

/*------------------------------------------------------------------------*/
/*                      f l S p l i t F i l e                             */
/*                                                                        */
/* Splits the file into two files. The original file contains the first   */
/* part, and a new file (which is created for that purpose) contains      */
/* the second part. If the current position is on a cluster               */
/* boundary, the file will be split at the current position. Otherwise,   */
/* the cluster of the current position is duplicated, one copy is the     */
/* first cluster of the new file, and the other is the last cluster of the*/
/* original file, which now ends at the current position.                 */
/*                                                                        */
/* Parameters:                                                            */
/*        file            : file to split.                                */
/*      irPath          : Path name of the new file.                      */
/*                                                                        */
/* Returns:                                                               */
/*        irHandle        : handle of the new file.                       */
/*        FLStatus        : 0 on success, otherwise failed.               */
/*                                                                        */
/*------------------------------------------------------------------------*/

#define flSplitFile(ioreq)     bdCall(FL_SPLIT_FILE,ioreq)


/*------------------------------------------------------------------------*/
/*                      f l J o i n F i l e                               */
/*                                                                        */
/* joins two files. If the end of the first file is on a cluster          */
/* boundary, the files will be joined there. Otherwise, the data in       */
/* the second file from the beginning until the offset that is equal to   */
/* the offset in cluster of the end of the first file will be lost. The   */
/* rest of the second file will be joined to the first file at the end of */
/* the first file. On exit, the first file is the expanded file and the   */
/* second file is deleted.                                                */
/* Note: The second file will be open by this function, it is advised to  */
/*         close it before calling this function in order to avoid        */
/*         inconsistencies.                                               */
/*                                                                        */
/* Parameters:                                                            */
/*        file            : file to join to.                              */
/*        irPath          : Path name of the file to be joined.           */
/*                                                                        */
/* Return:                                                                */
/*        FLStatus        : 0 on success, otherwise failed.               */
/*                                                                        */
/*------------------------------------------------------------------------*/

#define flJoinFile(ioreq)     bdCall(FL_JOIN_FILE,ioreq)

#endif /* SPLIT_JOIN_FILE */
#endif /* FL_READ_ONLY */
/*----------------------------------------------------------------------*/
/*                      f l R e a d F i l e                             */
/*                                                                      */
/* Reads from the current position in the file to the user-buffer.      */
/* Parameters:                                                          */
/*        irHandle     : Handle of file to read.                        */
/*        irData       : Address of user buffer                         */
/*        irLength     : Number of bytes to read. If the read extends   */
/*                       beyond the end-of-file, the read is truncated  */
/*                       at the end-of-file.                            */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus     : 0 on success, otherwise failed                 */
/*        irLength     : Actual number of bytes read                    */
/*----------------------------------------------------------------------*/

#define flReadFile(ioreq)        bdCall(FL_READ_FILE,ioreq)

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                      f l W r i t e F i l e                           */
/*                                                                      */
/* Writes from the current position in the file from the user-buffer.   */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Handle of file to write.                    */
/*        irData          : Address of user buffer                      */
/*        irLength        : Number of bytes to write.                   */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irLength        : Actual number of bytes written              */
/*----------------------------------------------------------------------*/

#define flWriteFile(ioreq)        bdCall(FL_WRITE_FILE,ioreq)

#endif  /* FL_READ_ONLY */
/*----------------------------------------------------------------------*/
/*                      f l S e e k F i l e                             */
/*                                                                      */
/* Sets the current position in the file, relative to file start, end or*/
/* current position.                                                    */
/* Note: This function will not move the file pointer beyond the        */
/* beginning or end of file, so the actual file position may be         */
/* different from the required. The actual position is indicated on     */
/* return.                                                              */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle  : File handle to close.                             */
/*        irLength  : Offset to set position.                           */
/*        irFlags   : Method code                                       */
/*                     SEEK_START: absolute offset from start of file   */
/*                     SEEK_CURR:  signed offset from current position  */
/*                     SEEK_END:   signed offset from end of file       */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irLength        : Actual absolute offset from start of file   */
/*----------------------------------------------------------------------*/

/* Values of irFlags for flSeekFile: */

#define   SEEK_START   0        /* offset from start of file    */
#define   SEEK_CURR    1        /* offset from current position */
#define   SEEK_END     2        /* offset from end of file      */


#define flSeekFile(ioreq)        bdCall(FL_SEEK_FILE,ioreq)

/*----------------------------------------------------------------------*/
/*                          f l F i n d F i l e                         */
/*                                                                      */
/* Finds a file entry in a directory, optionally modifying the file     */
/* time/date and/or attributes.                                         */
/* Files may be found by handle no. provided they are open, or by name. */
/* Only the Hidden, System or Read-only attributes may be modified.     */
/* Entries may be found for any existing file or directory other than   */
/* the root. A DirectoryEntry structure describing the file is copied   */
/* to a user buffer.                                                    */
/*                                                                      */
/* The DirectoryEntry structure is defined in dosformt.h                */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle     : If by name: Drive number (socket+partitions)   */
/*                       else      : Handle of open file                */
/*        irPath       : If by name: Specifies a file or directory path */
/*        irFlags      : Options flags                                  */
/*                        FIND_BY_HANDLE: Find open file by handle.     */
/*                                        Default is access by path.    */
/*                        SET_DATETIME:   Update time/date from buffer  */
/*                        SET_ATTRIBUTES: Update attributes from buffer */
/*        irDirEntry   : Address of user buffer to receive a            */
/*                       DirectoryEntry structure                       */
/*                                                                      */
/* Returns:                                                             */
/*        irLength        : Modified                                    */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

/** Bit assignment of irFlags for flFindFile: */

#define SET_DATETIME     1   /* Change date/time                        */
#define SET_ATTRIBUTES   2   /* Change attributes                       */
#define FIND_BY_HANDLE   4   /* Find file by handle rather than by name */

#define        flFindFile(ioreq)        bdCall(FL_FIND_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*                 f l F i n d F i r s t F i l e                        */
/*                                                                      */
/* Finds the first file entry in a directory.                           */
/* This function is used in combination with the flFindNextFile call,   */
/* which returns the remaining file entries in a directory sequentially.*/
/* Entries are returned according to the unsorted directory order.      */
/* flFindFirstFile creates a file handle, which is returned by it. Calls*/
/* to flFindNextFile will provide this file handle. When flFindNextFile */
/* returns 'noMoreEntries', the file handle is automatically closed.    */
/* Alternatively the file handle can be closed by a 'closeFile' call    */
/* before actually reaching the end of directory.                       */
/* A DirectoryEntry structure is copied to the user buffer describing   */
/* each file found. This structure is defined in dosformt.h.            */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle      : Drive number (0, 1, ...)                      */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irPath         : Specifies a directory path                   */
/*        irData         : Address of user buffer to receive a          */
/*                         DirectoryEntry structure                     */
/*                                                                      */
/* Returns:                                                             */
/*        irHandle       : File handle to use for subsequent operations */
/*        FLStatus       : 0 on success, otherwise failed               */
/*----------------------------------------------------------------------*/

#define        flFindFirstFile(ioreq)        bdCall(FL_FIND_FIRST_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*                 f l F i n d N e x t F i l e                          */
/*                                                                      */
/* See the description of 'flFindFirstFile'.                            */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : File handle returned by flFindFirstFile.    */
/*        irData          : Address of user buffer to receive a         */
/*                          DirectoryEntry structure                    */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define        flFindNextFile(ioreq)        bdCall(FL_FIND_NEXT_FILE,ioreq)

/*----------------------------------------------------------------------*/
/*                      f l G e t D i s k I n f o                       */
/*                                                                      */
/* Returns general allocation information.                              */
/*                                                                      */
/* The bytes/sector, sector/cluster, total cluster and free cluster     */
/* information are returned into a DiskInfo structure.                  */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irData          : Address of DiskInfo structure               */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

typedef struct {
  unsigned        bytesPerSector;
  unsigned        sectorsPerCluster;
  unsigned        totalClusters;
  unsigned        freeClusters;
} DiskInfo;

#define flGetDiskInfo(ioreq)        bdCall(FL_GET_DISK_INFO,ioreq)

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                      f l D e l e t e F i l e                         */
/*                                                                      */
/* Deletes a file.                                                      */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irPath          : path of file to delete                      */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flDeleteFile(ioreq)        bdCall(FL_DELETE_FILE,ioreq)

#ifdef RENAME_FILE

/*----------------------------------------------------------------------*/
/*                      f l R e n a m e F i l e                         */
/*                                                                      */
/* Renames a file to another name.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irPath          : path of existing file                       */
/*        irData          : path of new name.                           */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flRenameFile(ioreq)        bdCall(FL_RENAME_FILE,ioreq)

#endif /* RENAME_FILE */

#ifdef SUB_DIRECTORY

/*----------------------------------------------------------------------*/
/*                      f l M a k e D i r                               */
/*                                                                      */
/* Creates a new directory.                                             */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irPath          : path of new directory.                      */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flMakeDir(ioreq)        bdCall(FL_MAKE_DIR,ioreq)

/*----------------------------------------------------------------------*/
/*                      f l R e m o v e D i r                           */
/*                                                                      */
/* Removes an empty directory.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irPath          : path of directory to remove.                */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flRemoveDir(ioreq)        bdCall(FL_REMOVE_DIR,ioreq)

#endif /* SUB_DIRECTORY */
#endif /* FL_READ_ONLY */

#endif /* FILES > 0 */

/*----------------------------------------------------------------------*/
/*                     V o l u m e I n f o R e c o r d                  */
/*                                                                      */
/* A structure that holds general information about the media. The      */
/* information includes Physical Info (see flGetPhysicalInfo), Logical  */
/* partition (number of sectors and CHS), boot area size, S/W versions  */
/* Media life-time etc.                                                 */
/* A pointer to this structure is passed to the function flVolumeInfo   */
/* where it receives the relevant data.                                 */
/*----------------------------------------------------------------------*/

typedef struct {
  unsigned long  logicalSectors;    /*  number of logical sectors                  */
  unsigned long  bootAreaSize;      /*  boot area size                             */
  unsigned long  baseAddress;       /*  physical base address                      */
#ifdef FL_LOW_LEVEL
  unsigned short flashType;         /*  JEDEC id of the flash                      */
  unsigned long  physicalSize;      /*  physical size of the media                 */
  unsigned short physicalUnitSize;  /*  Erasable block size                        */
  char DOCType;                     /*  DiskOnChip type (MDoc/Doc2000)             */
  char lifeTime;                    /*  Life time indicator for the media (1-10)   */
                                    /*  1 - the media is fresh,                    */
                                    /*  10 - the media is close to its end of life */
#endif
  char driverVer[10];               /*  driver version (NULL terminated string)    */
  char OSAKVer[10];                 /*  OSAK version that driver is based on
                                        (NULL terminated string)                   */
#ifdef ABS_READ_WRITE
  unsigned long cylinders;          /*  Media.....                                 */
  unsigned long heads;              /*            geometry......                   */
  unsigned long sectors;            /*                            parameters.      */
#endif
} VolumeInfoRecord;

/*----------------------------------------------------------------------*/
/*             f l V o l u m e I n f o                                  */
/*                                                                      */
/* Get general information about the media.                             */
/*                                                                      */
/* Parameters:                                                          */
/*      irHandle        : Socket number (0,1,..)                        */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*      irData    : Address of user buffer to read general              */
/*                          information into.                           */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flVolumeInfo(ioreq) bdCall(FL_VOLUME_INFO,ioreq)

/*----------------------------------------------------------------------*/
/*                f l C o u n t V o l u m e s                           */
/*                                                                      */
/* Counts the number of volumes on the Flash device.                    */
/*                                                                      */
/* This routine is applicable only for TL that can accomdate more then  */
/* a single volume on a flash medium. other TL's will simply return 1   */
/* while not even tring to access the medium.                           */
/*                                                                      */
/* Not all the volumes can neccesaryly be mounted. A drive formated     */
/* with a read protection will be registered but can not be accessed.   */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Socket number ( 0,1,2...  )                 */
/*                        : Partition number ( 0,1,2...  )              */
/*        irFlags         : Returns the number of partitions            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define flCountVolumes(ioreq)        bdCall(FL_COUNT_VOLUMES,ioreq)

/*----------------------------------------------------------------------*/
/*                f l C l e a r Q u i c k M o u n t I n f o             */
/*                                                                      */
/* Clear all quick mount informtion.                                    */
/*                                                                      */
/* Must be called before calling mount volume routines.                 */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Socket number ( 0,1,2...  )                 */
/*                        : Partition number ( 0,1,2...  )              */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define flClearQuickMountInfo(ioreq) bdCall(FL_CLEAR_QUICK_MOUNT_INFO,ioreq)

/*----------------------------------------------------------------------*/
/*                      f l M o u n t V o l u m e                       */
/*                                                                      */
/* Mounts, verifies or dismounts the Flash medium.                      */
/*                                                                      */
/* In case the inserted volume has changed, or on the first access to   */
/* the file system, it should be mounted before file operations can be  */
/* done on it.                                                          */
/*                                                                      */
/* The volume automatically becomes unmounted if it is removed or       */
/* changed.                                                             */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Socket number (0, 1, ...)                   */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */
/*        irFlags         : Number of hidden sectors.                   */ 
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flMountVolume(ioreq)        bdCall(FL_MOUNT_VOLUME,ioreq)

/*----------------------------------------------------------------------*/
/*                  f l A b s M o u n t V o l u m e                     */
/*                                                                      */
/* Mounts, verifies or dismounts the Flash medium.                      */
/*                                                                      */
/* The volume automatically becomes unmounted if it is removed or       */
/* changed.                                                             */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Socket number (0, 1, ...)                   */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flAbsMountVolume(ioreq)        bdCall(FL_ABS_MOUNT,ioreq)

/*----------------------------------------------------------------------*/
/*                  f l V e r i f y V o l u m e                         */
/*                                                                      */
/* Verifies a mounted volume for partialy written sectors.              */
/*                                                                      */
/* Note: The volume must be mounted first.                              */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Socket number (0, 1, ...)                   */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */
/*        irData          : Must be set to NULL                         */
/*        irLength        : Must be set to 0                            */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flVerifyVolume(ioreq)        bdCall(FL_VERIFY_VOLUME,ioreq)

/*----------------------------------------------------------------------*/
/*                   f l D i s m o u n t V o l u m e                    */
/*                                                                      */
/* Dismounts the volume.                                                */
/* This call is not normally necessary, unless it is known the volume   */
/* will soon be removed.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus                : 0 on success, otherwise failed      */
/*----------------------------------------------------------------------*/

#define flDismountVolume(ioreq)        bdCall(FL_DISMOUNT_VOLUME,ioreq)


/*----------------------------------------------------------------------*/
/*                     f l C h e c k V o l u m e                        */
/*                                                                      */
/* Verifies that the current volume is mounted.                         */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flCheckVolume(ioreq)        bdCall(FL_CHECK_VOLUME,ioreq)

/*----------------------------------------------------------------------*/
/*                        r e a d B B T                                 */
/*                                                                      */
/* Read Bad Blocks Table of device to user buffer                       */
/*                                                                      */
/* Note: The user buffer is filled with the address of the bad units    */
/*       the buffer maximum size is 2% of the number of TL units of the */
/*       specific device * 4 bytes. therfore a 8M device of 8KB erase   */
/*       zone will need a maximum size buffer of 1024 * 0.02 * 4 = 82B  */
/*       and a 192M with 16KB erase zones will need 960Bytes            */
/*                                                                      */
/* Note: the buffer is not initialized by the function                  */
/*                                                                      */
/* Parameters:                                                          */
/*      irData          : User buffer.                                  */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      irLength        : returns the media size                        */
/*      irFlags         : returns the actual number of badBlocks        */
/*----------------------------------------------------------------------*/

#define flReadBBT(ioreq) bdCall(FL_READ_BBT,ioreq)

/*----------------------------------------------------------------------*/
/*                 f l S e c t o r s I n V o l u m e                    */
/*                                                                      */
/* Returns number of virtual sectors in volume.                         */
/*                                                                      */
/* In case the inserted volume is not mounted, returns current status.  */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle  : Drive number (0, 1, ...)                          */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*      irLength        : number of virtual sectors in volume           */
/*----------------------------------------------------------------------*/

#define flSectorsInVolume(ioreq)        bdCall(FL_SECTORS_IN_VOLUME,ioreq)



#ifndef FL_READ_ONLY
#ifdef DEFRAGMENT_VOLUME

/*----------------------------------------------------------------------*/
/*                      f l D e f r a g m e n t V o l u m e             */
/*                                                                      */
/* Performs a general defragmentation and recycling of non-writable     */
/* Flash areas, to achieve optimal write speed.                         */
/*                                                                      */
/* NOTE: The required number of sectors (in irLength) may be changed    */
/* (from another execution thread) while defragmentation is active. In  */
/* particular, the defragmentation may be cut short after it began by   */
/* modifying the irLength field to 0.                                   */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle  : Drive number (0, 1, ...)                          */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irLength  : Minimum number of sectors to make available for   */
/*                    writes.                                           */
/*                                                                      */
/* Returns:                                                             */
/*        irLength  : Actual number of sectors available for writes     */
/*        FLStatus  : 0 on success, otherwise failed                    */
/*----------------------------------------------------------------------*/

#define flDefragmentVolume(ioreq)        bdCall(FL_DEFRAGMENT_VOLUME,ioreq)

#endif /* DEFRAGMENT_VOLUME */

#ifdef FORMAT_VOLUME

/*----------------------------------------------------------------------*/
/*                    f l F o r m a t V o l u m e                       */
/*                                                                      */
/* Performs  formatting of the DiskOnChip.                              */
/*  All existing data is destroyed.                                     */
/*                                                                      */
/* Note : This routine does not support some of the new feature         */
/*        introduces in OSAK 5.0 and was left in order to support       */
/*        backwards compatibility with application build on OSAK 4.2    */
/*        and down.                                                     */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle  : Socket number (0, 1, ...)                         */
/*                  : Partition number must be 0                        */
/*        irFlags   : TL_FORMAT          : Translation layer formatting */
/*                                         + FAT formating              */
/*                    TL_FORMAT_IF_NEEDED: Translation layer formatting */
/*                                         only if current format is    */
/*                                         invalid + FAT format         */
/*                  : FAT_ONLY_FORMAT    : FAT only formatting          */
/*                  : TL_FORMAT_ONLY     : Translation layer formatting */
/*                                         without FAT format           */
/*        irData    : Address of FormatParams structure to use          */
/*                              (defined in format.h)                   */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flFormatVolume(ioreq) bdCall(BD_FORMAT_VOLUME,ioreq)

/** Values of irFlags for flLowLevelFormat: */

#define FAT_ONLY_FORMAT     0
#define TL_FORMAT           1
#define TL_FORMAT_IF_NEEDED 2
#define TL_FORMAT_ONLY      8

/*----------------------------------------------------------------------*/
/*            f l F o r m a t P h i s i c a l D r i v e                 */
/*                                                                      */
/* Performs formatting of the DiskOnChip.                               */
/* All existing data is destroyed.                                      */
/*                                                                      */
/* Note : This routine is the format routine for OSAK 5.0 and up.       */
/* Note : This routine is the format routine for OSAK 5.0               */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle : Socket number (0, 1, ...)                          */
/*                   Partition number must be 0                         */
/*        irFlags  :                                                    */
/*              TL_NORMAL_FORMAT       : Normal format                  */
/*              TL_LEAVE_BINARY_AREA   : Leave the previous binary area */
/*        irData          : Address of FormatParams2 structure to use   */
/*                              (defined in format.h)                   */
/* Returns:                                                             */
/*        FLStatus  : 0 on success, otherwise failed                    */
/*----------------------------------------------------------------------*/

#define flFormatPhysicalDrive(ioreq) bdCall(BD_FORMAT_PHYSICAL_DRIVE,ioreq)
#define    TL_NORMAL_FORMAT            0
#define    TL_LEAVE_BINARY_AREA        8

/*----------------------------------------------------------------------*/
/*           f l F o r m a t L o g i c a l D r i v e                    */
/*                                                                      */
/* Performs formatting of a single block device partition of a          */
/* DiskOnChip. All existing data of the partition is destroyed.         */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle  : Drive number (0, 1, ...)                          */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irData    : Address of BDTLPartitionFormatParams structure    */
/*                    to use (defined in format.h)                      */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flFormatLogicalDrive(ioreq) bdCall(BD_FORMAT_LOGICAL_DRIVE,ioreq)

/*----------------------------------------------------------------------*/
/*                        w r i t e B B T                               */
/*                                                                      */
/* Erase the flash medium while marking bad block with 2 zeros in the   */
/* first page of the unit. This state is the virgin state of the flash  */
/* device allowing it to be reformated while incorporating the written  */
/* bad blocks.                                                          */
/*                                                                      */
/* Note that tl units are marked and not actual erasable blocks         */
/*                                                                      */
/* Parameters:                                                          */
/*      irData          : User buffer.                                  */
/*      irLength        : Size of the media to erase.                   */
/*      irFlags         : User buffer length in bytes.                  */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/
#define flWriteBBT(ioreq) bdCall(FL_WRITE_BBT,ioreq)

#endif /* FORMAT_VOLUME */
#endif /*FL_READ_ONLY */

#ifdef ABS_READ_WRITE

/*----------------------------------------------------------------------*/
/*                           f l A b s R e a d                          */
/*                                                                      */
/* Reads absolute sectors by sector no.                                 */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irData          : Address of user buffer to read into         */
/*        irSectorNo      : First sector no. to read (sector 0 is the   */
/*                          DOS boot sector).                           */
/*        irSectorCount   : Number of consectutive sectors to read      */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irSectorCount        : Number of sectors actually read        */
/*----------------------------------------------------------------------*/

#define flAbsRead(ioreq)        bdCall(FL_ABS_READ,ioreq)

/*----------------------------------------------------------------------*/
/*                         f l A b s A d d r e s s                      */
/*                                                                      */
/* Returns the current physical media offset of an absolute sector by   */
/* sector no.                                                           */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irSectorNo      : Sector no. to address (sector 0 is the DOS  */
/*                          boot sector)                                */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irCount         : Offset of the sector on the physical media  */
/*----------------------------------------------------------------------*/

#define flAbsAddress(ioreq)                bdCall(FL_ABS_ADDRESS,ioreq)

/*----------------------------------------------------------------------*/
/*                           f l G e t B P B                            */
/*                                                                      */
/* Reads the BIOS Parameter Block from the boot sector                  */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irData          : Address of user buffer to read BPB into     */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flGetBPB(ioreq)                bdCall(FL_GET_BPB,ioreq)

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                         f l A b s W r i t e                          */
/*                                                                      */
/* Writes absolute sectors by sector no.                                */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irData          : Address of user buffer to write from        */
/*        irSectorNo      : First sector no. to write (sector 0 is the  */
/*                          DOS boot sector).                           */
/*        irSectorCount   : Number of consectutive sectors to write     */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irSectorCount   : Number of sectors actually written          */
/*----------------------------------------------------------------------*/

#define flAbsWrite(ioreq)        bdCall(FL_ABS_WRITE,ioreq)

/*----------------------------------------------------------------------*/
/*                         f l A b s D e l e t e                        */
/*                                                                      */
/* Marks absolute sectors by sector no. as deleted.                     */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irSectorNo      : First sector no. to delete (sector 0 is the */
/*                          DOS boot sector).                           */
/*        irSectorCount   : Number of consectutive sectors to delete    */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irSectorCount        : Number of sectors actually deleted     */
/*----------------------------------------------------------------------*/

#define flAbsDelete(ioreq)        bdCall(FL_ABS_DELETE,ioreq)

#ifdef WRITE_PROTECTION
/*----------------------------------------------------------------------*/
/*              f l W r i t e P r o t e c t i o n                       */
/*                                                                      */
/* Put and remove write protection from the volume                      */
/*                                                                      */
/* Note partition number 0 protectes the binary partition as well       */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irFlags         : FL_PROTECT=remove, FL_UNPROTECT=put         */
/*                          and FL_UNLOCK=unlock                        */
/*        irData          : password (8 bytes)                          */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flWriteProtection(ioreq) bdCall(FL_WRITE_PROTECTION,ioreq)
#define FL_PROTECT   0
#define FL_UNPROTECT 1
#define FL_UNLOCK    2
#endif /* WRITE_PROTETION */
#endif /* FL_READ_ONLY */
#endif /* ABS_READ_WRITE */

#ifdef FL_LOW_LEVEL

/*----------------------------------------------------------------------*/
/*                          P h y s i c a l I n f o                     */
/*                                                                      */
/* A structure that holds physical information about the media. The     */
/* information includes JEDEC ID, unit size and media size. Pointer     */
/* to this structure is passed to the function flGetPhysicalInfo where  */
/* it receives the relevant data.                                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

typedef struct {
  unsigned short type;         /* Flash device type (JEDEC id)         */
  char           mediaType;    /* type of media see below              */
  long int       unitSize;     /* Smallest physically erasable size
                                  (with interleaving taken in account) */
  long int       mediaSize;    /* media size in bytes                  */
  long int       chipSize;     /* individual chip size in bytes        */
  int            interleaving; /* device interleaving                  */
} PhysicalInfo;

/* media types */
#define FL_NOT_DOC     0
#define FL_DOC         1
#define FL_MDOC        2
#define FL_DOC2000TSOP 3
#define FL_MDOCP_16    4
#define FL_MDOCP       5

 
/*----------------------------------------------------------------------*/
/*                         f l G e t P h y s i c a l I n f o            */
/*                                                                      */
/* Get physical information of the media. The information includes      */
/* JEDEC ID, unit size and media size.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Socket number (0,1,..)                      */
/*        irData          : Address of user buffer to read physical     */
/*                          information into.                           */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irLength        : Window base address. note mast be cast to   */
/*                          unsigned.                                   */
/*----------------------------------------------------------------------*/

#define flGetPhysicalInfo(ioreq)        bdCall(FL_GET_PHYSICAL_INFO, ioreq)

/*----------------------------------------------------------------------*/
/*                             f l P h y s i c a l R e a d              */
/*                                                                      */
/* Read from a physical address.                                        */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle         : Socket number (0,1,..)                     */
/*        irAddress        : Physical address to read from.             */
/*        irByteCount      : Number of bytes to read.                   */
/*        irData           : Address of user buffer to read into.       */
/*        irFlags          : Method mode                                */
/*                        EDC:       Activate ECC/EDC                   */
/*                        EXTRA:     Read/write spare area              */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flPhysicalRead(ioreq)                bdCall(FL_PHYSICAL_READ,ioreq)


#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                    f l P h y s i c a l W r i t e                     */
/*                                                                      */
/* Write to a physical address.                                         */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Socket number (0,1,..)                      */
/*        irAddress       : Physical address to write to.               */
/*        irByteCount     : Number of bytes to write.                   */
/*        irData          : Address of user buffer to write from.       */
/*        irFlags         : Method mode                                 */
/*                        EDC:       Activate ECC/EDC                   */
/*                        EXTRA:     Read/write spare area              */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flPhysicalWrite(ioreq)                bdCall(FL_PHYSICAL_WRITE,ioreq)

/* Bit assignment of irFlags for flPhysicalRead or flPhysicalWrite: */
/*   ( defined in file flflash.h )                                  */
/* #define OVERWRITE    1        *//* Overwriting non-erased area   */
/* #define EDC          2        *//* Activate ECC/EDC              */
/* #define EXTRA        4        *//* Read/write spare area         */

/*----------------------------------------------------------------------*/
/*                    f l P h y s i c a l E r a s e                     */
/*                                                                      */
/* Erase physical units.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle       : Socket number (0,1,..)                       */
/*        irUnitNo        : First unit to erase.                        */
/*        irUnitCount     : Number of units to erase.                   */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flPhysicalErase(ioreq)                bdCall(FL_PHYSICAL_ERASE,ioreq)

#endif /* FL_READ_ONLY */

#ifdef BDK_ACCESS

 /*-------------------------------------------------------------------
 * bdkReadInit - Init read operations on the DiskOnChip starting
 *       at 'startUnit', with a size of 'areaLen' bytes and 'signature'.
 *
 * Note: Blocks in the DiskOnChip are marked with a 4-character signature
 *       followed by a 4-digit hexadecimal number.
 *
 * Parameters:
 *             'irHandle'      - Drive number (0, 1, ...)
 *                        bits 7-4 - Partition # (zero based)           
 *                        bits 3-0 - Socket # (zero based)               
 *             'irData'         - bdkParams record
 *                startingBlock - unit number of the sub-partition to start reading from
 *                length        - number of bytes to read
 *                oldSign       - signature of the sub-partition
 *                flags         - EDC or not
 *                signOffset    - signature offset 0 or 8
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWReadProtect     - HW read protection was triggerd
 *-------------------------------------------------------------------*/

#define bdkReadInit(ioreq) bdCall(FL_BINARY_READ_INIT,ioreq)

/*-------------------------------------------------------------------
 * bdkReadBlock - Read to 'buffer' from the DiskOnChip BDK Image area.
 *
 * Note: Before the first use of this function 'bdkCopyBootAreaInit'
 *       must be called
 *
 * Parameters:
 *             'irHandle'      - Drive number (0, 1, ...)
 *                    bits 7-4 - Partition # (zero based)           
 *                    bits 3-0 - Socket # (zero based)               
 *             'irData'         - bdkParams record
 *                length        - number of bytes to read
 *                bdkBuffer     - buffer to read into
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWReadProtect     - HW read protection was triggerd
 *-------------------------------------------------------------------*/

#define bdkReadBlock(ioreq) bdCall(FL_BINARY_READ_BLOCK,ioreq)

/*-------------------------------------------------------------------
 * bdkWriteInit - Init update operations on the DiskOnChip starting
 *       at 'startUnit', with a size of 'areaLen' bytes and 'signature'.
 *
 * Note: Blocks in the DiskOnChip are marked with a 4-character signature
 *       followed by a 4-digit hexadecimal number.
 *
 * Parameters:
 *             'irHandle'       - Drive number (0, 1, ...)
 *                     bits 7-4 - Partition # (zero based)           
 *                     bits 3-0 - Socket # (zero based)               
 *             'irData'         - bdkParams record
 *                startingBlock - unit number of the sub-partition to start writting to
 *                length        - number of bytes to write
 *                oldSign       - signature of the sub-partition
 *                flags         - EDC \ BDK_COMPLETE_IMAGE_UPDATE
 *                signOffset    - signature offset 0 or 8
 *
 * Return:     flOK              - success
 *             flGeneralFailure  - DiskOnChip ASIC was not found
 *             flUnknownMedia    - fail in Flash chips recognition
 *             flNoSpaceInVolume - 'areaLen' is bigger than BootImage length
 *-------------------------------------------------------------------*/

#define bdkWriteInit(ioreq) bdCall(FL_BINARY_WRITE_INIT,ioreq)

/*-------------------------------------------------------------------
 * bdkWriteBlock - Write 'buffer' to the DiskOnChip BDK Image area.
 *
 * Note: Before the first use of this function 'bdkUpdateBootAreaInit'
 *       must be called
 *
 * Parameters:
 *             'irHandle'       - Drive number (0, 1, ...)
 *                     bits 7-4 - Partition # (zero based)           
 *                     bits 3-0 - Socket # (zero based)               
 *             'irData'         - bdkParams record
 *                length        - number of bytes to write
 *                bdkBuffer     - buffer to write from
 *                flags         - ERASE_BEFORE_WRITE
 *
 * Return:     flOK              - success
 *             flBadLength       - buffer length > Erasable Block Size
 *             flWriteFault      - fail in buffer writing
 *             flNoSpaceInVolume - end of media was prematurely reached
 *-------------------------------------------------------------------*/

#define bdkWriteBlock(ioreq) bdCall(FL_BINARY_WRITE_BLOCK,ioreq)

/*-------------------------------------------------------------------
 * bdkErase - erase given number of blockdsin the BDK area.
 *
 *  Erase given number of blockds in the binary sub partition.
 *
 * Parameters: ioreq
 *             'irHandle'       - Drive number (0, 1, ...)
 *                     bits 7-4 - Partition # (zero based)           
 *                     bits 3-0 - Socket # (zero based)               
 *             'irData'         - bdkParams record
 *                startingBlock - unit number of the sub-partition to start erasing from
 *                length        - number of blocks to erase
 *                oldSign       - signature of the sub-partition
 *                signOffset    - signature offset 0 or 8
 *
 * Return:     flOK              - success
 *             flBadLength       - buffer length > Erasable Block Size
 *             flWriteFault      - fail in buffer writing
 *             flNoSpaceInVolume - end of media was prematurely reached
 *-------------------------------------------------------------------*/

#define bdkErase(ioreq) bdCall(FL_BINARY_ERASE,ioreq)

/*-------------------------------------------------------------------
 * bdkCreate - create new BDK partition .
 *
 *  Init create operations on the DiskOnChip starting at 'startUnit', with
 *  a # of 'units' and 'signature'.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-character signature
 *         followed by a 4-digit hexadecimal number.
 *
 * Parameters: ioreq
 *             'irHandle'       - Drive number (0, 1, ...)
 *                     bits 7-4 - Partition # (zero based)           
 *                     bits 3-0 - Socket # (zero based)               
 *             'irData'         - bdkParams record
 *                length        - number of blocks to create
 *                oldSign       - signature of the sub-partition
 *                newSign       - the replacing signature
 *                signOffset    - signature offset 0 or 8
 *
 * Return:     flOK              - success
 *             flBadLength       - buffer length > Erasable Block Size
 *             flWriteFault      - fail in buffer writing
 *             flNoSpaceInVolume - end of media was prematurely reached
 *-------------------------------------------------------------------*/

#define bdkCreate(ioreq) bdCall(FL_BINARY_CREATE,ioreq)

/*----------------------------------------------------------------------*/
/*                    b d k P a r t i t i o n I n f o                   */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : volume number                               */
/*        irData          : pointer to structure that hold socket       */
/*                          parameters                                  */
/*        irLength        : Physical size of the binary volume          */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus         : 0 on success, otherwise failed.            */
/*----------------------------------------------------------------------*/

#define bdkPartitionInfo(ioreq) bdCall(FL_BINARY_PARTITION_INFO,ioreq)

#endif /* BDK_ACCESS */
#ifdef HW_OTP
/*----------------------------------------------------------------------*/
/*                         f l O T P S i z e                            */
/*                                                                      */
/* Get the OTP size and stated                                          */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*                        4 LSB - Socket number                         */
/*  irLength         : The size of the used OTP area in bytes           */
/*  irCount          : The size of the OTP ara in bytes                 */
/*  irFlags          : LOCKED_OTP for a locked area otherwise unlocked  */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flOTPSize(ioreq) bdCall(FL_OTP_SIZE,ioreq)

/* LOCKED_OTP 1  defined in flflash.h */

/*----------------------------------------------------------------------*/
/*                         f l O T P R e a d                            */
/*                                                                      */
/* Read from the OTP area                                               */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*                        4 LSB - Socket number                         */
/*  irData           : pointer to user buffer to read into              */
/*  irLength         : number of bytes to read                          */
/*  irCount          : offset to read from (starting at the begining of */
/*                     the OTP area                                     */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus   : 0 on success, otherwise failed                   */
/*----------------------------------------------------------------------*/

#define flOTPRead(ioreq) bdCall(FL_OTP_READ,ioreq)

/*----------------------------------------------------------------------*/
/*                 f l O T P W r i t e A n d L o c k                    */
/*                                                                      */
/* Write to the OTP area while locking it at the end.                   */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*                        4 LSB - Socket number                         */
/*  irData           : pointer to user buffer to write from             */
/*  irLength         : number of bytes to write                         */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus   : 0 on success, otherwise failed                   */
/*----------------------------------------------------------------------*/

#define flOTPWriteAndLock(ioreq) bdCall(FL_OTP_WRITE,ioreq)

/*----------------------------------------------------------------------*/
/*                     f l G e t U n i q u e I D                        */
/*                                                                      */
/* Returns the 16 bytes device unique ID                                */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*                        4 LSB - Socket number                         */
/*  irData           : pointer to a 16 bytes buffer to read into the    */
/*                     unique ID data                                   */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irData          : 16 bytes unique ID buffer                   */
/*----------------------------------------------------------------------*/

#define flGetUniqueID(ioreq) bdCall(FL_UNIQUE_ID,ioreq)

/*----------------------------------------------------------------------*/
/*                f l G e t C u s t o m e r I D                         */
/*                                                                      */
/* Returns the 4 bytes customer ID                                      */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*                        4 LSB - Socket number                         */
/*  irData           : pointer to a 4 bytes buffer to read into the     */
/*                     customer ID                                      */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irData          : 4 bytes unique ID buffer                    */
/*----------------------------------------------------------------------*/

#define flGetCustomerID(ioreq) bdCall(FL_CUSTOMER_ID,ioreq)
#endif /* HW_OTP */

#ifdef FL_LOW_LEVEL
/*----------------------------------------------------------------------*/
/*             f l D e e p P o w e r D o w n M o d e                    */
/*                                                                      */
/* Forces the device into and out of the deep power down mode           */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*                        4 LSB - Socket number                         */
/*  irFlags          : DEEP_POWER_DOWN forces the low power consumption */
/*                     mode. otherwise turning to the regular mode      */
/*                                                                      */
/* Returns: None                                                        */
/*----------------------------------------------------------------------*/

#define flDeepPowerDownMode(ioreq) bdCall(FL_DEEP_POWER_DOWN_MODE,ioreq)

/* DEEP_POWER_DOWN 1 defined in flflash.h */

#endif /* FL_LOW_LEVEL */

/*----------------------------------------------------------------------*/
/*             f l I n q u i r e C a p a b i l i t i e s                */
/*                                                                      */
/* Get the specific device S/W and H/W capabilities                     */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*                        4 LSB - Socket number                         */
/*      irLength        : One of the capabilities below to examine      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      irLength        : Either CAPABILITY_NOT_SUPPORTED or            */
/*                        CAPABILITY_SUPPORTED.                         */
/*----------------------------------------------------------------------*/

#define flInquireCapabilities(ioreq) bdCall(FL_INQUIRE_CAPABILITIES,ioreq)

/* capabilities flags */
typedef enum{
   CAPABILITY_NOT_SUPPORTED           = 0,
   CAPABILITY_SUPPORTED               = 1,
   SUPPORT_UNERASABLE_BBT             = 2,
   SUPPORT_MULTIPLE_BDTL_PARTITIONS   = 3,
   SUPPORT_MULTIPLE_BINARY_PARTITIONS = 4,
   SUPPORT_HW_PROTECTION              = 5,
   SUPPORT_HW_LOCK_KEY                = 6,
   SUPPORT_CUSTOMER_ID                = 7,
   SUPPORT_UNIQUE_ID                  = 8,
   SUPPORT_DEEP_POWER_DOWN_MODE       = 9,
   SUPPORT_OTP_AREA                   = 10,
   SUPPORT_WRITE_IPL_ROUTINE          = 11
}FLCapability;

/*----------------------------------------------------------------------*/
/*                   f l P l a c e E x b B y B u f f e r                */
/*                                                                      */
/* Place M-systems firmware file on the media.                          */
/* This routine analizes the exb file calclats the media space needed   */
/* for it taking only the device specific code.                         */
/* In addition the routine customizes the file and places it on the     */
/* media.                                                               */
/*                                                                      */
/* Note : The media must be already formated with enough binary area    */
/* already marked with the SPL signature. This routine is best used     */
/* with the format routine where the format routine is givven the first */
/* 512 bytes while the rest of the file is given with this routine      */
/*                                                                      */
/* Parameters:                                                          */
/*      irHandle      : Socket number (0,1,..)                          */
/*                      4 LSB - Socket number                           */
/*      irData        : Buffer containing the entire/part of EXB file   */
/*      irLength      : Size of the current buffer                      */
/*      irWindowBase  : Optional window base address to be loaded to    */
/*      irFlags       : One of the following exb flags                  */
/*                   : INSTALL_FIRST - Install device as drive C:       */
/*                     FLOPPY        - Install device as drive A:       */
/*                     QUIET          - Do not show TFFS titles         */
/*                     INT15_DISABLE - Do not hook int 15               */
/*                     SIS5598       - Support for SIS5598 platforms    */
/*                     NO_PNP_HEADER - Do not place the PNP bios header */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flPlaceExbByBuffer(ioreq) bdCall(FL_PLACE_EXB,ioreq)

/*----------------------------------------------------------------------*/
/*                   f l W r i t e I P L                                */
/*                                                                      */
/* Place a user buffer to both copies of the IPL area                   */
/*                                                                      */
/* Note : This routine is applicable only to docPlus famaly devices     */
/*        Doc2000 family devices will return flFeatureNotSupported      */
/*                                                                      */
/* Parameters:                                                          */
/*      irHandle      : Socket number (0,1,..)                          */
/*                      4 LSB - Socket number                           */
/*      irData        : Pointer to user buffer                          */
/*      irLength      : Size of the buffer                              */
/*      irFlags       : See flags bellow                                */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flWriteIPL(ioreq) bdCall(FL_WRITE_IPL,ioreq)

/*
 * defined in flflash.h
 *
 * FL_IPL_MODE_NORMAL 0 - Written as usual
 * FL_IPL_DOWNLOAD    1 - Download new IPL when done
 * FL_IPL_MODE_SA     2 - Written with Strong Arm mode enabled
 * FL_IPL_MODE_XSCALE 4 - Written with X-Scale mode enabled
 */

/*----------------------------------------------------------------------*/
/*                           r e a d I P L                              */
/*                                                                      */
/* Read IPL to user buffer.                                             */
/*                                                                      */
/* Note : Read length must be a multiplication of 512 bytes             */
/* Note : Causes DiskOnChip Millennium Plus to download (i,e protection */
/*        key will be removed from all partitions.                      */
/*                                                                      */
/* Parameters:                                                          */
/*      irHandle      : Socket number (0,1,..)                          */
/*                      4 LSB - Socket number                           */
/*      irData        : Pointer to user buffer                          */
/*      irLength      : Size of the buffer                              */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flReadIPL(ioreq) bdCall(FL_READ_IPL,ioreq)

#endif /* FL_LOW_LEVEL */

/*----------------------------------------------------------------------*/
/*                 f l U p d a t e S o c k e t P a r a m s              */
/*                                                                      */
/* Pass socket parameters to the socket interface layer.                */
/* This function should be called after the socket parameters (like     */
/* size and base) are known. If these parameters are known at           */
/* registration time then there is no need to use this function, and    */
/* the parameters can be passed to the registration routine.            */
/* The structure passed in irData is specific for each socket interface.*/
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : volume number                               */
/*        irData          : pointer to structure that hold socket       */
/*                          parameters                                  */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus         : 0 on success, otherwise failed.            */
/*----------------------------------------------------------------------*/

#define flUpdateSocketParams(ioreq)        bdCall(FL_UPDATE_SOCKET_PARAMS,ioreq)

#ifdef HW_PROTECTION
/*----------------------------------------------------------------------*/
/*              f l I d e n t i f y P r o t e c t i o n                 */
/*              b d k I d e n t i f y P r o t e c t i o n               */
/*                                                                      */
/* Returns the specified partitions protection attributes               */
/*                                                                      */
/* Parameters:                                                          */
/*        irHandle        : Drive number (0, 1, ...)                    */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*        irFlags    CHANGEABLE_PROTECTION - changeable protection type  */
/*                   PROTECTABLE     - partition can recieve protection */
/*                   READ_PROTECTED  - partition is read protected      */
/*                   WRITE_PROTECTED - partition is write protected     */
/*                   LOCK_ENABLED    - HW lock signal is enabled        */
/*                   LOCK_ASSERTED   - HW lock signal is asserted       */
/*                   KEY_INSERTED    - key is inserted (not currently   */
/*                                     protected.                       */
/*----------------------------------------------------------------------*/

#define flIdentifyProtection(ioreq) bdCall(FL_PROTECTION_GET_TYPE,ioreq)
#define bdkIdentifyProtection(ioreq) bdCall(FL_BINARY_PROTECTION_GET_TYPE,ioreq)

/* Protection partition flags (see flbase.h)*/

/*----------------------------------------------------------------------*/
/*              f l I n s e r t P r o t e c t i o n K e y               */
/*              b d k I n s e r t P r o t e c t i o n K e y             */
/*                                                                      */
/* Insert the protection key in order to remove the protection of the   */
/* partititon specified by the drive handle                             */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Drive number (0, 1, ...)                         */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*  irData           : pointer to an 8 bytes key array                  */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flInsertProtectionKey(ioreq) bdCall(FL_PROTECTION_INSERT_KEY,ioreq)
#define bdkInsertProtectionKey(ioreq) bdCall(FL_BINARY_PROTECTION_INSERT_KEY,ioreq)

/*----------------------------------------------------------------------*/
/*              f l R e m o v e P r o t e c t i o n K e y               */
/*              b d k R e m o v e P r o t e c t i o n K e y             */
/*                                                                      */
/* Remove the protection key making the partition protected again       */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Drive number (0, 1, ...)                         */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flRemoveProtectionKey(ioreq) bdCall(FL_PROTECTION_REMOVE_KEY,ioreq)
#define bdkRemoveProtectionKey(ioreq) bdCall(FL_BINARY_PROTECTION_REMOVE_KEY,ioreq)

/*----------------------------------------------------------------------*/
/*         f l H a r d w a r e P r o t e c t i o n L o c k              */
/*         b d k H a r d w a r e P r o t e c t i o n L o c k            */
/*                                                                      */
/* Enabled or disabled the affect of the hardware LOCK signal           */
/* The hardware lock signal disables the removal of protection through  */
/* the key therfore the partition will remain protected until the       */
/* hardware LOCK signal will be removed                                 */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Drive number (0, 1, ...)                         */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*        irFlags    : LOCK_ENABLED locks the partition otherwise       */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flHardwareProtectionLock(ioreq) bdCall(FL_PROTECTION_SET_LOCK,ioreq)
#define bdkHardwareProtectionLock(ioreq) bdCall(FL_BINARY_PROTECTION_CHANGE_LOCK,ioreq)

/*----------------------------------------------------------------------*/
/*          f l C h a n g e P r o t e c t i o n K e y                   */
/*          b d k C h a n g e P r o t e c t i o n K e y                 */
/*                                                                      */
/* Changes the current protection key with a new one.                   */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Drive number (0, 1, ...)                         */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*  irData           : Pointer to the new 8 bytes key array             */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flChangeProtectionKey(ioreq) bdCall(FL_PROTECTION_CHANGE_KEY,ioreq)
#define bdkChangeProtectionKey(ioreq) bdCall(FL_BINARY_PROTECTION_CHANGE_KEY,ioreq)

/*----------------------------------------------------------------------*/
/*              f l C h a n g e P r o t e c t i o n T y p e             */
/*              b d k C h a n g e P r o t e c t i o n T y p e           */
/*                                                                      */
/* Changes the protection attributes of the partitions.                 */
/* In order for a partition to change its protection type (without      */
/* reformating the media) it must have the CHANGEABLE_PRTOECTION        */
/* attribute.                                                           */
/*                                                                      */
/* Parameters:                                                          */
/*  irHandle         : Drive number (0, 1, ...)                         */
/*                        bits 7-4 - Partition # (zero based)           */
/*                        bits 3-0 - Socket # (zero based)              */ 
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#define flChangeProtectionType(ioreq) bdCall(FL_PROTECTION_CHANGE_TYPE,ioreq)
#define bdkChangeProtectionType(ioreq) bdCall(FL_BINARY_PROTECTION_SET_TYPE,ioreq)

#endif /* HW_PROTECTION */
#ifdef EXIT

/*----------------------------------------------------------------------*/
/*                            f l E x i t                               */
/*                                                                      */
/* If the application ever exits, flExit should be called before exit.  */
/* flExit flushes all buffers, closes all open files, powers down the   */
/* sockets and removes the interval timer.                              */
/*                                                                      */
/* Parameters:                                                          */
/*        None                                                          */
/*                                                                      */
/* Returns:                                                             */
/*        Nothing                                                       */
/*----------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
void NAMING_CONVENTION flExit(void);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* EXIT */

#ifdef ENVIRONMENT_VARS
typedef enum {        /* Variable type code for flSetEnv routin */
      FL_ENV_VARS_PER_SYSTEM          = 0,
      FL_IS_RAM_CHECK_ENABLED         = 1,
      FL_TL_CACHE_ENABLED             = 2,
      FL_DOC_8BIT_ACCESS              = 3,
      FL_MULTI_DOC_ENABLED            = 4,      
      FL_SET_MAX_CHAIN                = 5,
      FL_MARK_DELETE_ON_FLASH         = 6,
      FL_MTL_POLICY                   = 7,
      FL_SECTORS_VERIFIED_PER_FOLDING = 8,
      FL_SUSPEND_MODE                 = 9,

      FL_ENV_VARS_PER_SOCKET          = 100,
      FL_VERIFY_WRITE_OTHER           = 101,
      FL_MTD_BUS_ACCESS_TYPE          = 102,

      FL_ENV_VARS_PER_VOLUME          = 200,
      FL_SET_POLICY                   = 201,
      FL_VERIFY_WRITE_BDTL            = 202,
      FL_VERIFY_WRITE_BINARY          = 203
      
} FLEnvVars;

/*----------------------------------------------------------------------*/
/*                   f l S e t E n v V o l u m e                        */
/*                                                                      */
/* Change one of TrueFFS environment variables for a specific partition */
/*                                                                      */
/* Note : This routine is used by all other flSetEnv routines.          */
/*        In order to effect variables that are common to several       */
/*        sockets or volumes use INVALID_VOLUME_NUMBER                  */
/*                                                                      */
/* Parameters:                                                          */
/*      variableType    : variable type to cahnge                       */
/*      socket          : Associated socket                             */
/*      volume          : Associated volume (partition)                 */
/*      value           : varaible value                                */
/*                                                                      */
/* Note: Variables common to al sockets must be addressed using socket  */
/*       0 and volume 0.                                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      prevValue       : The previous value of the variable            */
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
FLStatus NAMING_CONVENTION flSetEnvVolume(FLEnvVars variableType ,
                  byte socket,byte volume ,
                  dword value, dword FAR2 *prevValue);
#ifdef __cplusplus
}
#endif /* __cplusplus */

/*----------------------------------------------------------------------*/
/*                       f l S e t E n v S o c k e t                    */
/*                                                                      */
/* Change one of TrueFFS environment variables for a specific sockets.  */
/*                                                                      */
/* Parameters:                                                          */
/*      variableType    : variable type to cahnge                       */
/*      socket          : socket number                                 */
/*      value           : varaible value                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      prevValue       : The previous value of the variable            */
/*                        if there are more then 1 partition in that    */
/*                        socket , the first partition value is returned*/
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
FLStatus NAMING_CONVENTION flSetEnvSocket(FLEnvVars variableType , byte socket ,
                        dword value, dword FAR2 *prevValue);
#ifdef __cplusplus
}
#endif /* __cplusplus */

/*----------------------------------------------------------------------*/
/*                       f l S e t E n v All                            */
/*                                                                      */
/* Change one of TrueFFS environment variables for all systems, sockets */
/* and partitions.                                                      */
/*                                                                      */
/* Parameters:                                                          */
/*      variableType    : variable type to cahnge                       */
/*      value           : varaible value                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      prevValue       : The previous value of the variable            */
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
FLStatus NAMING_CONVENTION flSetEnvAll(FLEnvVars variableType , dword value, dword FAR2 *prevValue);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* ENVIRONMENT_VARS */

/*----------------------------------------------------------------------*/
/*                   f l B u i l d G e o m e t r y                      */
/*                                                                      */
/* Get C/H/S information of the disk according to number of sectors.    */
/*                                                                      */
/* Parameters:                                                          */
/*  capacity    : Number of Sectors in Volume                           */
/*  cylinders   : Pointer to Number of Cylinders                        */
/*  heads       : Pointer to Number of Heads                            */
/*  sectors     : Pointer to Number of Sectors per Track                */
/*  oldFormat   : True for one sector per culoster                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
void NAMING_CONVENTION flBuildGeometry(dword capacity, dword FAR2 *cylinders,
             dword FAR2 *heads,dword FAR2 *sectors, FLBoolean oldFormat);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifndef FL_NO_USE_FUNC

/*----------------------------------------------------------------------*/
/*                  f l S e t D o c B u s R o u t i n e                 */
/*                                                                      */
/* Set user defined memory acces routines for DiskOnChip.               */
/*                                                                      */
/* Parameters:                                                          */
/*      socket      : Socket number to install routine for.             */
/*      structPtr   : Pointer to function structure.                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
FLStatus NAMING_CONVENTION flSetDocBusRoutine(byte socket, FLAccessStruct FAR1 * structPtr);
#ifdef __cplusplus
}
#endif /* __cplusplus */

/*----------------------------------------------------------------------*/
/*                  f l G e t D o c B u s R o u t i n e                 */
/*                                                                      */
/* Get currently installed memory access routines for DiskOnChip.       */
/*                                                                      */
/* Parameters:                                                          */
/*      socket      : Socket number to install routine for.             */
/*      structPtr   : Pointer to function structure.                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
FLStatus NAMING_CONVENTION flGetDocBusRoutine(byte socket, FLAccessStruct FAR1 * structPtr);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* FL_NO_USE_FUNC */
/*----------------------------------------------------------------------*/
/*                         b d C a l l                                  */
/*                                                                      */
/* Common entry-point to all file-system functions. Macros are          */
/* to call individual function, which are separately described below.   */
/*                                                                      */
/* Parameters:                                                          */
/*      function        : file-system function code (listed below)      */
/*      ioreq           : IOreq structure                               */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
FLStatus NAMING_CONVENTION bdCall(FLFunctionNo functionNo, IOreq FAR2 *ioreq);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifdef PARSE_PATH

/*----------------------------------------------------------------------*/
/*                      f l P a r s e P a t h                           */
/*                                                                      */
/* Converts a DOS-like path string to a simple-path array.              */
/*                                                                      */
/* Note: Array length received in irPath must be greater than the       */
/* number of path components in the path to convert.                    */
/*                                                                      */
/* Parameters:                                                          */
/*        irData          : address of path string to convert           */
/*        irPath          : address of array to receive parsed-path.    */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

extern FLStatus NAMING_CONVENTION flParsePath(IOreq FAR2 *ioreq);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* PARSE_PATH */
#endif /* BLOCKDEV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\doc2exb.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOC2EXB.C_V  $
 *
 *    Rev 1.26   Apr 15 2002 07:35:12   oris
 * Moved doc2exb internal functions declaration to blockdev.c.
 * Make sure all relevant data is stored in little endian format.
 *
 *    Rev 1.25   Feb 19 2002 20:58:28   oris
 * Moved include directive and routine  prototypes from H file.
 *
 *    Rev 1.24   Jan 23 2002 23:31:18   oris
 * Removed warnings.
 * Replaced Alon based DiskOnChip writeIPL code with the MTD writeIPL routine.
 *
 *    Rev 1.23   Jan 21 2002 20:44:02   oris
 * Bad support for firmware other then the default 3 firmwares (TrueFFS 4.3 backward compatibility firmware).
 * Added support for DiskOnChip Millennium Plus 16MB firmware.
 * Missing far heap initialization for DiskOnChip 2000 firmware.
 *
 *    Rev 1.22   Jan 17 2002 22:58:32   oris
 * Added new flags for placeExbByBuffer - Choose firmware to place
 * Added firmware number to getExbInfo().
 * Changed debug print to Dformat print.
 * Removed exb size calculation when writing SPL - It is done as part of the firmware build
 * Added support for far malloc heap.
 * All DiskOnChip use the same STACK size definition.
 *
 *    Rev 1.21   Nov 08 2001 10:44:50   oris
 * Removed warnings.
 *
 *    Rev 1.20   Sep 24 2001 18:23:10   oris
 * Removed warnings.
 *
 *    Rev 1.19   Sep 16 2001 21:47:42   oris
 * Bug fix - support for 1KB IPL code for DiskOnChip2000 tsop.
 *
 *    Rev 1.18   Sep 15 2001 23:44:54   oris
 * Bug fix - The last 512 bytes of the last firmware were not written, and IPL was not loaded.
 *
 *    Rev 1.17   Jul 30 2001 17:57:36   oris
 * Removed warrnings
 *
 *    Rev 1.16   Jul 30 2001 00:20:52   oris
 * Support new IPL and SPL formats.
 *
 *    Rev 1.15   Jul 13 2001 01:00:08   oris
 * Changed constant stack space from magic numbers to contents.
 * Added erase before write for the binary write operation.
 *
 *    Rev 1.14   Jun 17 2001 08:17:16   oris
 * Changed placeExbByBuffer exbflags argument to word instead of byte to  support /empty flag.
 * Adjust exb size field to fit OSAK 4.3 format.
 * Added \empty flag - Leaves exb space empty.
 *
 *    Rev 1.13   May 29 2001 19:47:12   oris
 * Bug fix - trueffs heap size discounted boot units (heap too small)
 * Doc2000 exbOffset hardcoded to 40.
 *
 *    Rev 1.12   May 16 2001 21:16:50   oris
 * Change "data" named variables to flData to avoid name clashes.
 * Removed warnings.
 *
 *    Rev 1.11   May 09 2001 00:31:52   oris
 * Bug fix - Added check status to intializaion routine of place EXB by buffer.
 *
 *    Rev 1.10   May 06 2001 22:41:34   oris
 * Reduced tffs head size for Millennium Plus and DOC2000 tsop devices.
 * Removed warnings.
 *
 *    Rev 1.9   Apr 12 2001 06:48:46   oris
 * Added call to download routine in order to load new IPL.
 *
 *    Rev 1.8   Apr 10 2001 16:40:22   oris
 * Removed warrnings.
 *
 *    Rev 1.7   Apr 09 2001 14:59:04   oris
 * Reduced exb size read by the SPL to minimum.
 *
 *    Rev 1.6   Apr 03 2001 18:08:42   oris
 * Bug fix - exb flags were not properly written.
 *
 *    Rev 1.5   Apr 03 2001 16:34:50   oris
 * Removed unsused variables.
 *
 *    Rev 1.4   Apr 03 2001 14:36:46   oris
 * Completly reviced in order to support alon devices.
 *
 *    Rev 1.3   Apr 02 2001 00:54:32   oris
 * Added doc2000 exb family.
 * Supply the exact length of the exb in the binary partition.
 * Removed the no_pnp_header from the media.
 * Bug fix for calculation Spl size.
 *
 *    Rev 1.2   Apr 01 2001 07:49:42   oris
 * Updated copywrite notice.
 * Added support for doc2300 firmware.
 * Bug fixes for mdoc plus.
 * Added support for 1k IPL.
 * Added consideration in media type in calculating tffs heap size.
 * Changed h\w to h/w
 * Changed 2400 family to doc plus family.
 *
 *    Rev 1.1   Feb 08 2001 10:37:54   oris
 * Bug fix for unaligned file signature
 *
 *    Rev 1.0   Feb 02 2001 12:59:48   oris
 * Initial revision.
 *
 */


/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Project : TrueFFS source code                                              *
*                                                                            *
* Name : doc2exb.c                                                           *
*                                                                            *
* Description : This file contains the code for analizing and writing        *
*               M-Systems EXB firmware files                                 *
*                                                                            *
*****************************************************************************/

#include "doc2exb.h"
#include "bddefs.h"

#ifdef WRITE_EXB_IMAGE

extern FLStatus absMountVolume(Volume vol);

#define BUFFER exb->buffer->flData

exbStruct exbs[SOCKETS];

#define roundedUpShift(a,bits) (((a - 1) >> bits)+1)

/*----------------------------------------------------------------------*/
/*                    g e t E x b I n f o                               */
/*                                                                      */
/* Analize M-systems firmware file                                      */
/* Analizes M-systems firmware (exb) file, calclating the media space   */
/* required for it.                                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      buf             : Pointer to EXB file buffer                    */
/*      bufLen          : Size of the buffer                            */
/*      bufFlags        : Flags for the EXB - specifing type of         */
/*                        firmware to extract from the EXB file.        */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus          : flOK on success.                            */
/*                          flBadLength if buffer size is too small     */
/*                          flBadParameter on any other failure         */
/*  vol.binaryLength      : Total size needed in the binary partition   */
/*  exbs[i].firmwareStart : offset of the firmware begining in the file */
/*  exbs[i].firmwareEnd   : offset of the firmware end in the file      */
/*  exbs[i]l.splOffset    : offset of the spl start in the file         */
/*  exbs[i]l.exbFileEnd   : Total exb file size.                        */
/*----------------------------------------------------------------------*/

FLStatus getExbInfo(Volume vol, void FAR1 * buf, dword bufLen, word exbFlags)
{

   byte              i;
   byte              mediaType;

   ExbGlobalHeader FAR1* globalHeader   = (ExbGlobalHeader FAR1*)buf;
   FirmwareHeader  FAR1* firmwareHeader = (FirmwareHeader FAR1*)
           flAddLongToFarPointer(buf,sizeof(ExbGlobalHeader));

   /* Make sure size given is big enough */

   if (bufLen < sizeof(FirmwareHeader) * LE4(globalHeader->noOfFirmwares) +
           sizeof(ExbGlobalHeader))
   {
      DFORMAT_PRINT(("ERROR - Buffer size not big enough.\r\n"));
      return flBadLength;
   }

   /* Make sure this is an M-systems EXB file */

   if (tffscmp(globalHeader->mSysSign,SIGN_MSYS,SIGN_MSYS_SIZE) != 0)
   {
      DFORMAT_PRINT(("ERROR - Given file is not M-systems EXB file.\r\n"));
      return flBadParameter;
   }

   i = (exbFlags & FIRMWARE_NO_MASK) >> FIRMWARE_NO_SHIFT;
   if(i == 0)
   {
      /* Make sure this is the correct version of TrueFFS */

      if (tffscmp(globalHeader->osakVer,TrueFFSVersion,SIGN_MSYS_SIZE) != 0)
      {
         DFORMAT_PRINT(("ERROR - Incorrect TrueFFS EXB file version.\r\n"));
         return flBadParameter;
      }

      /* Find the corrent firmware in the file */

      /* Automatic firmware detection - by DiskOnChip type */
      switch (vol.flash->mediaType)
      {
         case DOC_TYPE:
         case MDOC_TYPE:
            mediaType = DOC2000_FAMILY_FIRMWARE;
            break;
         case MDOCP_TYPE:
            mediaType = DOCPLUS_FAMILY_FIRMWARE;
            break;
         case MDOCP_16_TYPE:
            mediaType = DOCPLUS_INT1_FAMILY_FIRMWARE;
            break;
         case DOC2000TSOP_TYPE:
            mediaType = DOC2300_FAMILY_FIRMWARE;
            break;
         default:
            DFORMAT_PRINT(("Unknown H/W - Try specifing the firmware manualy.\r\n"));
            return flFeatureNotSupported;
      }

      for (i=0;i<LE4(globalHeader->noOfFirmwares);i++,firmwareHeader++)
      {
         if (LE4(firmwareHeader->type) == mediaType)
           break;
      }
   }
   else /* Use given firmware */
   {
      i--; /* 0 was used for automatic choose of firmware */
   }

   if (i >= LE4(globalHeader->noOfFirmwares))
   {
      DFORMAT_PRINT(("ERROR - The EXB file does not support the required firmware.\r\n"));
      return flBadParameter;
   }

   /* Initialize the volumes EXB fields */

   firmwareHeader = (FirmwareHeader FAR1*)flAddLongToFarPointer(buf,
                     (sizeof(ExbGlobalHeader) + (i * sizeof(FirmwareHeader))));
   i = (byte)(&vol - vols);

   /* Save firmware files statstics recieved from the files header */
   exbs[i].firmwareStart = LE4(firmwareHeader->startOffset);
   exbs[i].firmwareEnd   = LE4(firmwareHeader->endOffset);
   exbs[i].splStart      = LE4(firmwareHeader->splStartOffset);
   exbs[i].splEnd        = LE4(firmwareHeader->splEndOffset);
   exbs[i].exbFileEnd    = LE4(globalHeader->fileSize);

   /* Calculate the binary partition size (good bytes) used to
      hold the EXB file.                                       */

   exbs[i].iplMod512 = (word)((exbs[i].splStart - exbs[i].firmwareStart)
                              >> SECTOR_SIZE_BITS);

   switch (vol.flash->mediaType)
   {
      /* NFTL formated device - IPL is placed on the binary partition */

      case DOC_TYPE:

         /* Size of EXB minus IPL which is placed in ROM */
         vol.binaryLength = exbs[i].firmwareEnd - exbs[i].splStart + 0x4000;
         break;

     case MDOC_TYPE:        /* Millennium 8, write data as is */

         /* Size of entire EXB */
         vol.binaryLength = exbs[i].firmwareEnd - exbs[i].firmwareStart;
         break;

      /* INFTL formated device - IPL is not placed on the binary
         partition, but on a dedicated flash area */

     case DOC2000TSOP_TYPE: /* DOC2000 TSOP   */
     case MDOCP_TYPE:       /* MDOC PLUS 32MB */
     case MDOCP_16_TYPE:    /* MDOC PLUS 16MB */

        vol.binaryLength  = exbs[i].firmwareEnd - exbs[i].splStart;
        break;

     default :
        DFORMAT_PRINT(("ERROR - Firmware formater reports A None DiskOnChip media.\r\n"));
        return flBadParameter;
   }
   return flOK;
}

/*------------------------------------------------------------------------*/
/*                    w a i t F o r H a l f B u f f e r                   */
/*                                                                        */
/* Increament the EXB file pointers and store the files data unit a       */
/* full sector of data is read.                                           */
/*                                                                        */
/* Parameters:                                                            */
/*  exbs[i].bufferOffset  : size of the buffer already filled with data   */
/*  exbs[i].exbFileOffset : offset from the beginning of the file         */
/*  exbs[i].buffer.data   : internal volume buffer accumulation file data */
/*  buf                   : buffer containing the files data              */
/*  bufLen                : Length of the buffer containing the file data */
/*  length                : Length of the buffer not yet used             */
/*  half                  : Wait for full 512 bytes of only 256           */
/* Returns:                                                               */
/*      boolean         : TRUE on full buffer otherwise FALSE.            */
/*      length          : Updated length of unused buffer                 */
/*------------------------------------------------------------------------*/

FLBoolean waitForFullBuffer(Volume vol , byte FAR1 * buf ,
                dword bufLen , Sdword * length,FLBoolean half)
{
  word bufferEnd;
  word tmp;
  byte i = (byte)(&vol - vols);

  if (half == TRUE)
  {
     bufferEnd = (SECTOR_SIZE >> 1);
  }
  else
  {
     bufferEnd = SECTOR_SIZE;
  }

  tmp = (word)TFFSMIN(*length , bufferEnd - exbs[i].bufferOffset);

  tffscpy(exbs[i].buffer->flData + exbs[i].bufferOffset ,
          flAddLongToFarPointer(buf,(bufLen-(*length))), tmp);
  exbs[i].bufferOffset  += tmp;
  exbs[i].exbFileOffset += tmp;
  *length           -= tmp;
  if (*length+tmp < bufferEnd)
     return FALSE;

  exbs[i].bufferOffset = 0;
  return TRUE;
}

/*------------------------------------------------------------------------*/
/*                    f i r s t T i m e I n i t                           */
/*                                                                        */
/* Initialize data structures for placing exb file.                       */
/* full sector of data is read.                                           */
/*                                                                        */
/* Actions:                                                               */
/*   1) Analize exb file buffer.                                          */
/*   2) Calculate TFFS heap size.                                         */
/*   3) Check if binary area with SPL signature is big enough.            */
/*   4) Calculate SPL start media address                                 */
/*   5) Calculate binary area used for the firmware.                      */
/*   6) Initialize the volumes EXB record.                                */
/*                                                                        */
/* Parameters:                                                            */
/*    vol    : Pointer to volume record describing the volume.            */
/*    exb    : Pointer to exb record describing the volume.               */
/*    buf    : Exb file buffer.                                           */
/*    bufLen : Length of exb file buffer.                                 */
/*    ioreq  : Internal ioreq record for binary operaions.                */
/*    bdk    : Bdk record which is a part of the ioreq packet.            */
/*                                                                        */
/* Affected Variables.                                                    */
/*                                                                        */
/* Returns:                                                               */
/*      flOK              : On success.                                   */
/*      flNoSpaceInVolume : Not enough space on the binary area.          */
/*------------------------------------------------------------------------*/

FLStatus firstTimeInit(Volume vol , exbStruct* exb, byte FAR1 * buf ,
               dword bufLen , IOreq* ioreq , BDKStruct* bdk ,
               word exbFlags)
{
   if (vol.moduleNo == INVALID_MODULE_NO)
   {
      FLStatus status;
      TLInfo info;

      /* Use the sockets buffer */

      exb->buffer = flBufferOf((unsigned)(exbs-exb));

      /* Find the number of blocks used needed for the EXB file */

      checkStatus(getExbInfo(&vol,buf,bufLen,exbFlags));

      /* Find TFFS heap size */

      if (!(vol.flags & VOLUME_ABS_MOUNTED))
         checkStatus(absMountVolume(&vol));
      ioreq->irData     = &info;
      checkStatus(vol.tl.getTLInfo(vol.tl.rec,&info));
      exb->tffsHeapSize = (dword)(vol.flash->chipSize * vol.flash->noOfChips) >> info.tlUnitBits;

      /* Add heap for dynamic allocation not related to convertion tables */

      if((exbFlags & FIRMWARE_NO_MASK) >> FIRMWARE_NO_SHIFT == 0)
      {
         /* virutal TABLE + physical table */
         exb->tffsFarHeapSize = (word)(((exb->tffsHeapSize * 3) >> SECTOR_SIZE_BITS) + 1);
         exb->tffsHeapSize    = INFTL_NEAR_HEAP_SIZE;
      }
      else /* Old TrueFFS source */
      {
         exb->tffsFarHeapSize = 0;
         exb->tffsHeapSize = exb->tffsHeapSize * 3 + DEFAULT_DOC_STACK;
      }

      /* Check if binary partition is formated for EXB */

      bdk->startingBlock = 0;
      ioreq->irData      = bdk;
      status = bdkCall(FL_BINARY_PARTITION_INFO,ioreq,vol.flash);

      if ((bdk->startingBlock < vol.binaryLength) || (status != flOK))
      {
         DFORMAT_PRINT(("ERROR - Not enough binary area marked for EXB.\r\n"));
         return flNoSpaceInVolume;
      }

      /* initialize binary area for writting the EXB file */

      bdk->length        = ((vol.binaryLength-1) >> vol.flash->erasableBlockSizeBits) +1;
      bdk->startingBlock = 0;
      bdk->signOffset    = EXB_SIGN_OFFSET;

      checkStatus(bdkCall(FL_BINARY_ERASE,ioreq,vol.flash)); /* ERASE */
      if ((exbFlags & LEAVE_EMPTY) == 0)
      {
         /* If actualy need to place firmware initialize Binary write */
         bdk->length        = vol.binaryLength;
         bdk->flags         = BDK_COMPLETE_IMAGE_UPDATE | EDC;
         bdkVol->bdkGlobalStatus |= BDK_S_INFO_FOUND; /* do not research */
         checkStatus(bdkCall(FL_BINARY_WRITE_INIT,ioreq,vol.flash));
         tffsset(BUFFER,0xff,SECTOR_SIZE);
      }
      exb->exbFileOffset = 0;        /* start of exb file          */
      exb->bufferOffset  = 0;        /* start of internal buffer   */
      exb->moduleLength  = 0;        /* size of the current module */
      exb->exbFlags      = exbFlags; /* see list in doc2exb.h      */
      vol.moduleNo       = 0;        /* module IPL                 */
   }
   return flOK;
}

/*----------------------------------------------------------------------*/
/*                    p l a c e E x b B y B u f f e r                   */
/*                                                                      */
/* Place M-systems firmware file on the media.                          */
/* This routine analizes the exb file calclating the media space needed */
/* for it taking only the device specific code.                         */
/*                                                                      */
/* Note : The media must be already formated with enough binary area    */
/* already marked with the SPL signature. This routine is best used     */
/* with the format routine where the format routine is givven the first */
/* 512 bytes while the rest of the file is given with this routine      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol          : Pointer identifying drive                        */
/*      buf          : Buffer containing EXB file data                  */
/*      bufLen       : Size of the current buffer                       */
/*      windowBase   : Optional set window base address                 */
/*      exbFlags     : INSTALL_FIRST - Install device as drive C:        */
/*                     FLOPPY        - Install device as drive A:        */
/*                     QUIET          - Do not show TFFS titles         */
/*                     INT15_DISABLE - Do not hook int 15               */
/*                     SIS5598       - Support for SIS5598 platforms    */
/*                     NO_PNP_HEADER - Do not place the PNP bios header */
/*                     LEAVE_EMPTY   - Leave space for firmware         */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

FLStatus placeExbByBuffer(Volume vol, byte FAR1 * buf, dword bufLen,
              word docWinBase ,word exbFlags)
{
   IOreq       ioreq;
   BDKStruct   bdk;
   word        tmpWord;
   Sdword      length       = bufLen;
   byte        anandMark[2] = {0x55,0x55};
   exbStruct*  exb          = &exbs[(byte)(&vol-vols)];
   BIOSHeader* hdr;
   IplHeader   *ipl;
   SplHeader   *spl;
   TffsHeader  *tffs;

   /* Initialize binary partition call packet */

   tffscpy(bdk.oldSign,SIGN_SPL,BINARY_SIGNATURE_NAME);  /* firmware signature */
   ioreq.irData   = &bdk;
   bdk.signOffset = EXB_SIGN_OFFSET;
   ioreq.irHandle = 0;

   /* First time initialization */

   checkStatus(firstTimeInit(&vol,exb,buf,bufLen,&ioreq, &bdk, exbFlags));

   /* Initialize the rest of the binary partition call packet */

   bdk.bdkBuffer  = BUFFER;         /* internal bufer  */
   bdk.length     = sizeof(BUFFER); /* buffer size     */
   bdk.flags     |= ERASE_BEFORE_WRITE; /* Erase each unit before writing */

   /* Make sure this is a relevant part of the file */

   if (exb->exbFileOffset + length < exb->firmwareStart)
   {
      /* Before this specific device firmware */
      exb->exbFileOffset += length;
      return flOK;
   }

   if (exb->exbFileOffset >= exb->firmwareEnd)
   {
      /* After this specific device firmware */
      exb->exbFileOffset += length;
      if (exb->exbFileOffset >= exb->exbFileEnd)
      {
         vol.moduleNo = INVALID_MODULE_NO;
         if (vol.flash->download != NULL)
            return vol.flash->download(vol.flash); /* download IPL */
      }
      return flOK;
   }

   if (exb->exbFileOffset < exb->firmwareStart)
   {
      length -= exb->firmwareStart - exb->exbFileOffset;
      exb->exbFileOffset = exb->firmwareStart;
   }

   /* Start writting the file modules */

   while ((exb->firmwareEnd > exb->exbFileOffset) && (length >0))
   {
      /* Read next page into internal buffer */

      /* DOC2000 IPL is ROM and it assumed small pages therefore
         read only the first 256 bytes of each page.             */

      if ((vol.moduleNo == 1) && (vol.flash->mediaType == DOC_TYPE))
      {
         if (waitForFullBuffer(&vol , buf , bufLen , &length,
                               TRUE) == FALSE)  /* 256 BYTES */
         return flOK;
      }
      else
      {
         if ((waitForFullBuffer(&vol , buf , bufLen , &length,
                                FALSE) == FALSE) && /* 512 BYTES */
             (exb->exbFileOffset != exb->exbFileEnd)) /* Not last buffer */
            return flOK;
      }

      /* Update the module length according to its header */

      if (exb->moduleLength == 0)
      {
         /* All modules except for the SPL start with biosHdr record
            SPL has a 2 bytes opCode preciding the biosHdr and an
            incorrect module length */

         switch (vol.moduleNo) /* SPL */
         {
             case 1:
                hdr = &((SplHeader *)BUFFER)->biosHdr;
                /* calculate the number of buffers to use for the SPL */
                exb->moduleLength = (word)((exb->splEnd-exb->splStart) >> SECTOR_SIZE_BITS);
                /* Doc 2000 writes in chunks of 256 bytes therfore need to
                   double the amount of write operations */
                if (vol.flash->mediaType == DOC_TYPE)
                   exb->moduleLength = (word)(exb->moduleLength << 1);
                break;

             default : /* Get size from header */
                hdr = (BIOSHeader *) BUFFER;
                exb->moduleLength = hdr->lenMod512;
         }

         /* Check validy of bios header */

         if ((hdr->signature[0] != 0x55) || (hdr->signature[1] != 0xAA))
         {
            DFORMAT_PRINT(("ERROR - EXB file is missing one of the BIOS driver modules.\r\n"));
            return flBadLength;
         }

         /* Update neccesary fields in the modules headers */
         switch (vol.moduleNo)
         {
            case 0:   /* IPL */

               /* The IPL length is actualy the window size in order to */
               /* supply the BIOS the expantion range. The real size    */
               /* if calculated according to the exb file header.       */
               if (vol.moduleNo==0)
                  exb->moduleLength = exb->iplMod512;

               ipl = (IplHeader *)BUFFER;

               /* Set 0000 pointer of ISA P&P Header */

               if(exb->exbFlags & NO_PNP_HEADER)
               {
                  ipl->dummy    += ((byte)(ipl->pnpHeader >> 8) +
                                    (byte)ipl->pnpHeader);
                  ipl->pnpHeader = 0;
               }

               /* Set DOC Window base explicitely */

               if( docWinBase > 0 )
               {
                  toLE2(ipl->windowBase , docWinBase);
                  ipl->dummy     -= (byte)( docWinBase );
                  ipl->dummy     -= (byte)( docWinBase >> 8 );
               }
               break;

            case 1:   /* SPL */

               spl = (SplHeader *)BUFFER;

               /* calculate EXB module size */

               /* generate random run-time ID and write it into splHeader. */

               tmpWord = (word)flRandByte();
               toUNAL2(spl->runtimeID, tmpWord);
               spl->chksumFix -= (byte)(tmpWord);
               spl->chksumFix -= (byte)(tmpWord >> 8);

               /* Write TFFS heap size into splHeader. */

               toUNAL2(spl->tffsHeapSize, (word)exb->tffsHeapSize);
               spl->chksumFix -= (byte)(exb->tffsHeapSize);
               spl->chksumFix -= (byte)(exb->tffsHeapSize >> 8);

               /* set explicit DOC window base */

               if( docWinBase > 0 )
               {
                  toUNAL2(spl->windowBase, docWinBase);
                  spl->chksumFix -= (byte)(docWinBase);
                  spl->chksumFix -= (byte)(docWinBase >> 8);
               }

               break;

            case 2:   /* Socket Services OR interupt 13 driver */

               /* The doc2000 driver and or socket services start
                  at 0x4000 so we have to jump over there. */
               if (vol.flash->mediaType == DOC_TYPE)
               {
                  bdkVol->actualUpdateLen -= 0x4000 - bdkVol->curUpdateImageAddress;
                  bdkVol->curUpdateImageAddress = 0x4000;
               }
               tffs             = (TffsHeader *)BUFFER;
               tffs->chksumFix -= (byte)(exb->tffsFarHeapSize);
               tffs->chksumFix -= (byte)(exb->tffsFarHeapSize >> 8);
               toUNAL2(tffs->heapLen, exb->tffsFarHeapSize);
               exb->exbFlags   &= ~NO_PNP_HEADER;

            default:

               /* put "install as first drive" & QUIET mark
                  into the TFFS header */

               tffs = (TffsHeader *)BUFFER;
               tffs->exbFlags   = (byte)exb->exbFlags;
               tffs->chksumFix -= (byte)exb->exbFlags;

           break;
         } /* end - switch of module type */
      } /* end - first buffer of module */

      exb->moduleLength--;

      /* Write module and clean buffer */

      switch (vol.moduleNo)
      {
         case 0: /* IPL data */

            switch (vol.flash->mediaType)
            {
               case MDOC_TYPE: /* Millennium 8 - use bdk to write IPL * 2 */

                  if (exb->moduleLength == exb->iplMod512 - 1)
                  {
                    /* Milennium DiskOnChip is the only device that the IPL
                       is duplicated in the exb file. The dupplication was
                       needed in earlier versions but it is currently ignored.
                       The IPL is still written twice only that the second
                       copy is not taken from the file but the first copy is
                       simply written twice. */
                    if ((exbFlags & LEAVE_EMPTY) == 0)
                    {
                       checkStatus(bdkCall(FL_BINARY_WRITE_BLOCK,
                                           &ioreq,vol.flash));
                       checkStatus(bdkCall(FL_BINARY_WRITE_BLOCK,
                                           &ioreq,vol.flash));
                    }
                  }
                  /* Change byte #406 to non-0xFF value to force
                     Internal EEprom Mode */
                  checkStatus(vol.flash->write(vol.flash,
                  ANAND_MARK_ADDRESS,anandMark,ANAND_MARK_SIZE,EXTRA));
                  break;

               case DOC2000TSOP_TYPE: /* Doc 2000 tsop - write to block 0 */
               case MDOCP_TYPE:   /* Millennium Plus - use MTD specific routine */
               case MDOCP_16_TYPE:

                  if (vol.flash->writeIPL == NULL)
                     return flFeatureNotSupported;
                  if ((exbFlags & LEAVE_EMPTY) != 0)
                  {
                     /* Erase previous IPL if all we need is to leave
                        space for the firmware and not realy write it */
                     tffsset(BUFFER,0xff,SECTOR_SIZE);
                  }
                  checkStatus(vol.flash->writeIPL(vol.flash,
                              BUFFER,SECTOR_SIZE,
                              (byte)(exb->iplMod512 - exb->moduleLength-1),
                              FL_IPL_MODE_NORMAL));
               default: /* DiskOnChip 2000 */

                  break; /* IPL is burnt onto ROM */
            }
            break;

         default:

            if ((exbFlags & LEAVE_EMPTY) == 0)
            {
               checkStatus(bdkCall(FL_BINARY_WRITE_BLOCK,&ioreq,vol.flash));
            }
      }
      tffsset(BUFFER,0xff,sizeof(BUFFER));

      if (exb->moduleLength == 0)
         vol.moduleNo++;
   }

   if (exb->exbFileOffset >= exb->firmwareEnd)
   {
      exb->exbFileOffset += length;
   }
   if (exb->exbFileOffset >= exb->exbFileEnd)
   {
      vol.moduleNo = INVALID_MODULE_NO;
      if (vol.flash->download != NULL)
         return vol.flash->download(vol.flash); /* download IPL */
   }
   return(flOK);
}

#endif /* WRITE_EXB_IMAGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\blockdev.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/BLOCKDEV.C_V  $
 * 
 *    Rev 1.43   Apr 15 2002 20:14:20   oris
 * Prevent any change to the flPolicy environment variable. It must be set to FL_DEFAULT_POLICY.
 * 
 *    Rev 1.42   Apr 15 2002 07:33:56   oris
 * Moved doc2exb functions declaration to blockdev.c
 * Moved bdkCall function declaration to docbdk.h
 * Bug fix - Bad arguments sanity check for FL_MTD_BUS_ACCESS_TYPE.
 * Bug fix - Missing initialization of global variables:
 *  - bus access in flSetDocBusRoutine() and flGetDocBusRoutine() and when ENVIRONMENT_VARS compilation flag is not defined.
 *  - verify write when ENVIRONMENT_VARS  compilation flag is not defined.
 *  - All global (for all sockets and volumes) environment variables where not reinitialized after flExit call.
 *  - Renamed initEnvVarsDone to initGlobalVarsDone.
 *  - Renamed flInitEnvVars() to flInitGlobalVars().
 * Changed flBusConfig environment array to dword variables instead of single byte.
 * Added support for VERIFY_ERASED_SECTOR compilation flag.
 * Placed multi-doc environment variable under the MULTI_DOC compilation flag.
 * VolumeInfo routine - remove warning by placing eraseCyclesPerUnit variable under FL_LOW_LEVEL compilation flag.
 * 
 *    Rev 1.41   Feb 19 2002 20:58:08   oris
 * Moved include directives to blockdev.h file.
 * Bug fix - findFreeVolume routine did not initialize flfash records of the volume. It caused exception when formatting a DiskOnChip with more then 1 partition.
 * Compilation error missing ifdef EXIT.
 * Convert TL_LEAVE_BINARY_AREA to FL_LEAVE_BINARY_AREA before sending it to the TL.
 * Bug fix - volumeInfo routine might cause exception if osak version or driver version is larger the designated field.
 * use intermediate variable before sending irFlags to otpSize routine.
 * 
 *    Rev 1.40   Jan 29 2002 20:07:42   oris
 * Added NAMING_CONVENTION prefix and extern "C" for cpp files to all public routines:
 * flSetEnvVolume, flSetEnvSocket , flSetEnvAll , flSetDocBusRoutine , flGetDocBusRoutine, flBuildGeometry , bdCall and flExit
 * Changed LOW_LEVEL compilation flag with FL_LOW_LEVEL to prevent definition clashes.
 * Removed warnings.
 * Moved writeIPL sanity check to MTD level.
 * Removed download operation after writeIPL call (it is now one of the routines parameters).
 * Added sanity check (null pointer passed) to flSetEnvVolume, flSetDocBusRoutine and flGetDocBusRoutine.
 * 
 *    Rev 1.39   Jan 28 2002 21:23:32   oris
 * Bug fix - initialization of flPolicy variable caused a memory lick (set max unit chain to 0).
 * Changed FL_NFTL_CACHE_ENABLED to FL_TL_CACHE_ENABLED.
 * Changed flSetDocBusRoutine interface and added flGetDocBusRoutine. 
 * Added FL_IPL_DOWNLOAD flag to writeIPL routine in order to control whether the IPL will be reloaded after the update.
 * 
 *    Rev 1.38   Jan 23 2002 23:30:46   oris
 * Added a call to flExit() in case flSuspend was restored to FL_OFF.
 * Moved Alon based DiskOnChip write IPL routine from blockdev, to diskonc.
 * Added sanity check to flCheckVolume() - Make sure irData is NULL and irLength is set to 0.
 * 
 *    Rev 1.37   Jan 21 2002 20:43:36   oris
 * Bug fix - Missing\bad support for FL_SECTORS_VERIFIED_PER_FOLDING and FL_VERIFY_WRITE_BDTL environment variables.
 * 
 *    Rev 1.36   Jan 20 2002 20:40:20   oris
 * Improved documentation of bdFormatPhisycalDrive - Added TL_NORMAL_FORMAT flag was added.
 * Removed ifdef NO_PHYSICAL_IO from flGetBPB routine.
 * 
 *    Rev 1.35   Jan 17 2002 22:56:22   oris
 * Placed docbdk.h under BDK_ACCESS ifdef
 * Added include directive to docsys.h   
 * Removed function prototypes from header.
 * Changed FLFlash record in the volume structure into a pointer
 * Added flBusConfig variable and flSetDocBusRoutine() routine for runtime control over memory access routines - under the FL_NO_USE_FUNC definition.
 * Added flSectorsVerfiedPerFolding environment variable was added
 * Added   flSuspendMode environment variable was added.
 * Changed flVerifyWrite environment variable : 4 for Disk partitions 3 for Binary and 1 for the rest.
 * Changed flPolicy to be partition specific.
 * Changed flSetEnv() routine was changed into 3 different routines: flSetEnvVolume / flSetEnvSocket / flSetEnvAll
 * Variables types for environment variables were changed to the minimal size needed.
 * Added flInitEnvVars() routine for setting default values to environment variables.
 * Use single FLFlash record for each volume - (change vol.flash to a pointer instead of the record itself).
 * Added \r to all DEBUG_PRINT routines.
 * Removed SINGLE_BUFFER ifdef.
 * Added volume verification after format for faster write performance with FL_OFF.
 * Removed FLFlash parameter to all TL calls (flMount / flFormat / flPreMount )  
 * Added support for firmware other then the 3 defaults (getExbInfo additional parameter)
 * Added support for M+ 16MB
 * Added partition parameter to setBusy - Stores current partition in the socket record for the use of lower TrueFFS layers .
 * Changed tffsmin to TFFSMIN
 * Added FL_VERIFY_VOLUME functionNo.
 * Made sure flInit() initializes all sockets and flashes volumes
 * Added flClearQuickMountInfo() routine (FL_CLEAR_QUICK_MOUNT_INFO)
 * readIPL routine now supports all DiskOnChip 
 * 
 *    Rev 1.34   Nov 29 2001 20:53:44   oris
 * Bug fix - flInquireCapabilities() returned bad status for SUPPORT_WRITE_IPL_ROUTINE.
 * 
 *    Rev 1.33   Nov 21 2001 11:40:44   oris
 * Changed FL_MULTI_DOC_NOT_ACTIVE to FL_OFF, FL_VERIFY_WRITE_MODE to FL_MTD_VERIFY_WRITE , FL_WITHOUT_VERIFY_WRITE to FL_OFF , FL_MARK_DELETE to FL_ON.
 * 
 *    Rev 1.32   Nov 08 2001 10:44:04   oris
 * Added flVerifyWrite environment variable that controls the verify write mode at run-time. 
 * Added support for large DiskOnChip in flBuildGeometry.
 * Remove s/w protection from binary partition.
 * Placed flAbsMount under ABS_READ_WRITE compilation flag.
 *
 *    Rev 1.31   Sep 24 2001 18:23:04   oris
 * Removed warnings.
 * 
 *    Rev 1.30   Sep 15 2001 23:44:22   oris
 * Changed BIG_ENDIAN to FL_BIG_ENDIAN
 * 
 *    Rev 1.29   Aug 02 2001 20:04:04   oris
 * Added support for 1k IPL for DiskOnChip 2000 TSOP - writeIPL() 
 * 
 *    Rev 1.28   Jul 29 2001 19:14:24   oris
 * Bug fix for TrueFFS internal mutex when using multi-doc and environment variables (when no multi-doc feature is disbaled)
 * 
 *    Rev 1.27   Jul 13 2001 00:59:28   oris
 * Changed flash lifetime calculation according to specific flash.
 * 
 *    Rev 1.26   Jun 17 2001 08:16:50   oris
 * Added NO_PHISICAL_IO compilation flag to reduce code size.
 * Added NO_READ_BBT_CODE compilation flag to reduce code size.
 * Changed placeExbByBuffer exbflags argument to word instead of byte to  support /empty flag.
 * Deleted redundent #ifdef MULTI_DOC in flInit().
 * 
 *    Rev 1.25   May 31 2001 18:11:52   oris
 * Removed readBBT routine from under the #ifndef FL_READ_ONLY.
 * 
 *    Rev 1.24   May 16 2001 21:16:08   oris
 * Changed the Binary state (0,1) of the environment variables to meaningful definitions.
 * Added flMtlDefragMode environment variable.
 * Added the FL_ prefix to the following defines: ON, OFF
 * Bug fix - One of the "ifndef" statement of NO_IPL_CODE was coded as "ifdef"
 * Change "data" named variables to flData to avoid name clashes.
 * 
 *    Rev 1.23   May 09 2001 00:31:00   oris
 * Added NO_PHYSICAL_IO , NO_IPL_CODE and NO_INQUIRE_CAPABILITY compilation flags to reduce code size.
 *
 *    Rev 1.22   May 06 2001 22:41:04   oris
 * Bug fix - flInquireCapabilities routine did not return the correct value when capability was not supported.
 * Added SUPPORT_WRITE_IPL_ROUTIN capability.
 * Removed warnings.
 * 
 *    Rev 1.21   May 01 2001 17:05:10   oris
 * Bug fix - bad argument check in flSetEnv routine.
 * 
 *    Rev 1.20   Apr 30 2001 17:57:00   oris
 * Added new environment variable flMarkDeleteOnFlash.
 * 
 *    Rev 1.19   Apr 24 2001 17:05:38   oris
 * Bug fix flMoutVolume routine return the correct hidden sectors even if high level mount fails.
 * Bug fix Write IPL routine supports Doc2000 TSOP as well as Millennium Plus.
 * Support readBBT new interface.
 * 
 *    Rev 1.18   Apr 18 2001 20:43:00   oris
 * Added force download call after writing IPL.
 * 
 *    Rev 1.17   Apr 18 2001 19:14:24   oris
 * Bug fix - binary partition insert and remove key routine no longer stop the place exb proccess.
 * 
 *    Rev 1.16   Apr 18 2001 09:26:22   oris
 * noOfDrives variable was changed to unsigned. This is a bug fix for vxWorks boot code.
 * Make sure blockdev does not try to mount more volumes then the VOLUMES definition.
 * 
 *    Rev 1.15   Apr 16 2001 13:02:38   oris
 * Removed warrnings.
 * 
 *    Rev 1.14   Apr 12 2001 06:48:22   oris
 * Added call to download routine after physical format in order 
 * to load new IPL and to initialize new protection information.
 * Removed warnings.
 *
 *    Rev 1.13   Apr 03 2001 16:33:10   oris
 * Removed unused variables.
 * Added proper casting in otpSize call.
 * 
 *    Rev 1.12   Apr 03 2001 14:33:16   oris
 * Bug fix in absRead sectors when reading multiple sectors.
 *
 *    Rev 1.11   Apr 01 2001 14:57:58   oris
 * Bug fix in read multiple sectors.
 *
 *    Rev 1.10   Mar 28 2001 06:19:12   oris
 * Removed flChangeEnvVar prototype.
 * Left alligned all # directives.
 * Bug fix in flSetEnv ((value !=0)||(value!=1)) => ((value !=0)&&(value!=1)) + downcast for given argument + add return status code
 * Removed unused variables.
 * Remove casting warnnings.
 * Add arg check in bdFormatPhysicalDrive for BDTLPartitionInfo != NULL.
 * Bug fix for absWrite - multi-secotr write should be initialized with zeros to prevent sector found return code.
 * Replaced the numbers in writeProtect routine to defines (moved from ioctl.h to blockdev.h).
 * Add break for mdocp identification in getPhysicalInfo.
 * Added readIPL routine.
 * Added LOG_FILE compilation flag for EDC errors for mdocp.
 * Added initialization of tl table in flInit.
 * flExit mutex bug fix.
 *
 *    Rev 1.9   Mar 05 2001 21:00:34   oris
 * Bug fix - initialize exbLen argument in bdFormatVolume.
 * Bug fix - initialize bdtlFp flags fiels in bdFormatVolume.
 * Restored the flExit pragma under __BORLANDC__ compilation flag
 *
 *    Rev 1.8   Feb 22 2001 20:21:34   oris
 * Bug fix in flExit with multi-doc release uncreated mutxe.
 *
 *    Rev 1.7   Feb 20 2001 15:44:58   oris
 * Bug fix for mutex initialization in flInit.
 *
 *    Rev 1.6   Feb 18 2001 23:29:28   oris
 * Bug fix - Added findFreeVolume call in flFormatPhysicalDrive.
 * bug fix - Added partition sanity check in bdcall entrence.
 * bug fix - Increamented pVol before entering loop in flExit.
 *
 *    Rev 1.5   Feb 18 2001 14:13:22   oris
 * Restored FL_BACKGROUND.
 * Place bdkCall extern prototype under BDK_ACCESS compilation flag.
 * Changed multiple volume mechanism - Replaced removeVolumeHandles and
 * flConvertDriveHandle routines with flInit + findFreeVolume and changed
 * dismountPhysicalDrive + flEacit to comply.
 * Changed bdcall volume validity check.
 * Added new volume flag VOLUME_ACCUPIED.
 * Moved all the new environment variable (flPolicy,flUseMultiDoc and flMaxUnitChain)
 * from flcustom.c in order to allow backwards competability.
 * Removed globalMutex (for now).
 * Allocate only 1 mutex when multi-doc is registered therfore setBusy takes only 1 mutex .
 * Bug fix - absRead and absWrite add bootSectors to the given sectors.
 * Bug fix - INVALID_VOLUME_HANDLE changed to INVALID_VOLUME_NUMBER.
 * Bug fix - Added (byte FAR1 *) casting in readBBT call.
 * Bug fix - Added (FLCapability FAR2 *) casting in inquire capability call.
 *
 *    Rev 1.4   Feb 14 2001 01:51:32   oris
 * Completly revised flInquireCapabilities routine.
 * Added oldFormat flag to flBuildGeometry routine.
 * Remove FL_BACKGROUND compilation flag.
 * Added arg check for flSetEnv + new FL_SET_MAX_CHAIN.
 * Changed FL_COMPLETE_ASAP_POLICY to FL_SET_POLICY.
 * Moved argument check in flFormatPhysicalDrive to fltl.c.
 * Moved readBBT routine inside bdcall.
 * Placed volumeInfo C\H\S data under ABS_READ_WRITE.
 *
 *    Rev 1.3   Feb 13 2001 02:10:48   oris
 * Changed flChangeEnvVar routine name to flSetEnv
 *
 *    Rev 1.2   Feb 12 2001 11:51:12   oris
 * Added function prototype in begining of the file.
 * Change routine order in the file.
 * Added mutex support for TrueFFS 5.0 partitions while changing bdcall order.
 * flMountVolume returns the number of boot sectors.
 * Moved the writeBBT routine to FLTL.C.
 * Added static before changePassword.
 * Added static before writeProtect.
 * Added static before dismountLowLevel.
 * Added static before writeIPL.
 * Added static before inquireCapabilities.
 * window base is returned by getPhysicalInfo in irLength.
 * Added MULTI_DOC compliation flag.
 *
 *    Rev 1.1   Feb 07 2001 17:55:06   oris
 * Buf fix for writeBBT of no bad blocks
 * Moved readBBT routine from under the fl_read_only define
 * Added casting in calls to readBBT and writeBBT
 * Added checkStatus check for flAbsWrite and flAbsRead routines
 * Added initialization of noOfMTDs and noOfSockets in flInit
 *
 *    Rev 1.0   Feb 04 2001 18:53:04   oris
 * Initial revision.
 *
 */


/*************************************************************************/
/*                    M-Systems Confidential                             */
/*       Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001      */
/*                     All Rights Reserved                               */
/*************************************************************************/
/*                        NOTICE OF M-SYSTEMS OEM                        */
/*                      SOFTWARE LICENSE AGREEMENT                       */
/*                                                                       */
/*  THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE           */
/*  AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT     */
/*  FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                        */
/*  OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                         */
/*  E-MAIL = info@m-sys.com                                              */
/*************************************************************************/

#include "bddefs.h"
#include "blockdev.h"

#ifdef FL_BACKGROUND
#include "backgrnd.h"
#endif


/********************* Extern Function Prototype Start *******************/
#ifdef WRITE_EXB_IMAGE
extern FLStatus getExbInfo(Volume vol, void FAR1 * buf, dword bufLen, word exbFlags);
extern FLStatus placeExbByBuffer(Volume vol, byte FAR1 * buf, dword bufLen,
                 word windowBase,word exbFlags);
#endif /* WRITE_EXB_IMAGE */

#if (defined(FORMAT_VOLUME) && defined(COMPRESSION))
extern FLStatus flFormatZIP(unsigned volNo, TL *baseTL , FLFlash * flash);
#endif
#if defined(FILES) && FILES > 0
extern File     fileTable[FILES];       /* the file table */
extern FLStatus flushBuffer(Volume vol);
extern FLStatus openFile(Volume vol, IOreq FAR2 *ioreq);
extern FLStatus closeFile(File *file);
extern FLStatus joinFile (File *file, IOreq FAR2 *ioreq);
extern FLStatus splitFile (File *file, IOreq FAR2 *ioreq);
extern FLStatus readFile(File *file,IOreq FAR2 *ioreq);
extern FLStatus writeFile(File *file, IOreq FAR2 *ioreq);
extern FLStatus seekFile(File *file, IOreq FAR2 *ioreq);
extern FLStatus findFile(Volume vol, File *file, IOreq FAR2 *ioreq);
extern FLStatus findFirstFile(Volume vol, IOreq FAR2 *ioreq);
extern FLStatus findNextFile(File *file, IOreq FAR2 *ioreq);
extern FLStatus getDiskInfo(Volume vol, IOreq FAR2 *ioreq);
extern FLStatus deleteFile(Volume vol, IOreq FAR2 *ioreq, 
                           FLBoolean isDirectory);
extern FLStatus renameFile(Volume vol, IOreq FAR2 *ioreq);
extern FLStatus makeDir(Volume vol, IOreq FAR2 *ioreq);
#endif /* FILES > 0 */

/********************* Extern Function Prototype End *******************/

/********************* Internal Function Prototype Start ***************/

void flInitGlobalVars(void);

/********************* Internal Function Prototype End *****************/

/********************* Global variables Start **************************/

Volume    vols[VOLUMES];
FLMutex   flMutex[SOCKETS];
byte      handleConversionTable[SOCKETS][MAX_TL_PARTITIONS];
FLBoolean initDone = FALSE;           /* Initialization not done yet   */
FLBoolean initGlobalVarsDone = FALSE; /* Initialization of environment */
                                      /* and access type variables not */
                                      /* done yet.                     */
unsigned  noOfDrives;

dword flMsecCounter = 0;

/* bus configuration
 *
 * DiskOnChip minimal bus width
 */
#ifndef FL_NO_USE_FUNC
dword   flBusConfig[SOCKETS];
#endif /* FL_NO_USE_FUNC */

/* Verify write state
 *
 * BDTL   partitions : 0-(MAX_TL_PARTITIONS-1)
 * Binary partitions : MAX_TL_PARTITIONS - (2*MAX_TL_PARTITIONS-2)
 * Last              : 2*MAX_TL_PARTITIONS-1
 */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
byte   flVerifyWrite[SOCKETS][MAX_TL_PARTITIONS<<1];
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

#ifdef ENVIRONMENT_VARS
cpyBuffer tffscpy; /* Pointer to memory copy routine    */
cmpBuffer tffscmp; /* Pointer to memory compare routine */
setBuffer tffsset; /* Pointer to memory set routine     */

/********************************************/
/* default values for environment variables */
/********************************************/

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
/* Max sectors verified per write operation (must be even number) */
dword  flSectorsVerifiedPerFolding = 64;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
#ifdef MULTI_DOC
/* No multi-doc (MTL)                        */
byte   flUseMultiDoc;
/* MTL defragmentaion mode (0 - standard)    */
byte   flMTLdefragMode;
#endif /* MULTI_DOC */
/* Set the TL operation policy               */
byte   flPolicy[SOCKETS][MAX_TL_PARTITIONS];
/* Maximum chain length                      */
byte   flMaxUnitChain;
/* Mark the delete sector on the flash       */
byte   flMarkDeleteOnFlash;
/* Read Only mode                            */
byte   flSuspendMode;

/********************* Global variables End *****************************/

/*----------------------------------------------------------------------*/
/*                   f l S e t E n v V o l u m e                        */
/*                                                                      */
/* Change one of TrueFFS environment variables for a specific partition */
/*                                                                      */
/* Note : This routine is used by all other flSetEnv routines.          */
/*        In order to effect variables that are common to several       */
/*        sockets or volumes use INVALID_VOLUME_NUMBER                  */
/*                                                                      */
/* Parameters:                                                          */
/*      variableType    : variable type to cahnge                       */
/*      socket          : Associated socket                             */
/*      volume          : Associated volume (partition)                 */
/*      value           : varaible value                                */
/*                                                                      */
/* Note: Variables common to al sockets must be addressed using socket  */
/*       0 and volume 0.                                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      prevValue       : The previous value of the variable            */
/*----------------------------------------------------------------------*/

FLStatus NAMING_CONVENTION flSetEnvVolume(FLEnvVars variableType ,
                  byte socket,byte volume ,
                  dword value, dword FAR2 *prevValue)
{
   /* Arg sanity check */
   if(prevValue == NULL)
   {
      DEBUG_PRINT(("ERROR - prevValue argument is NULL.\r\n"));
      return flBadParameter;
   }
   switch (variableType) /* Check value argument is a valid mode */
   {
      case FL_SET_MAX_CHAIN:
         if ((value > 31) || (value < 1))
         {
            DEBUG_PRINT(("Debug: Error - Chains length must between 0 and 32.\r\n"));
            return flBadParameter;
         }
         break;
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
      case FL_SECTORS_VERIFIED_PER_FOLDING:
         if (value & 1) /* odd number */
         {
            DEBUG_PRINT(("Debug: Error - sector verification numbr must be even.\r\n"));
            return flBadParameter;
         }
         break;
      case FL_VERIFY_WRITE_BDTL:
         if ((value != FL_UPS) && (value != FL_OFF) && (value != FL_ON))
         {
            DEBUG_PRINT(("Debug: Error - verify write of BDTL can not accept this value.\r\n"));
            return flBadParameter;
         }
         break;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
      case FL_SUSPEND_MODE:
         if((value != FL_OFF)           && 
            (value != FL_SUSPEND_WRITE) && 
            (value != FL_SUSPEND_IO)      )
         {
            DEBUG_PRINT(("Debug: Error - verify write of BDTL can not accept this value.\r\n"));
            return flBadParameter;
         }
         break;
#ifndef FL_NO_USE_FUNC
      case FL_MTD_BUS_ACCESS_TYPE:
         break;
#endif /* FL_NO_USE_FUNC */
      default:
         if ((value != FL_ON)&&(value!=FL_OFF))
         {
            DEBUG_PRINT(("Debug: Error - Value must be either FL_ON (1) or FL_OFF(0).\r\n"));
            return flBadParameter;
         }
   }

   switch (variableType) /* Check volume and socket sanity */
   {
      /* Volume specfic variables */

      case FL_SET_POLICY:
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
      case FL_VERIFY_WRITE_BDTL:
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
#ifdef VERIFY_WRITE
      case FL_VERIFY_WRITE_BINARY:
#endif /* VERIFY_WRITE */
         if ((       volume >= MAX_TL_PARTITIONS          ) ||
             ((variableType == FL_VERIFY_WRITE_BINARY) &&
              (volume       == MAX_TL_PARTITIONS - 1 )    )   )
         {
            DEBUG_PRINT(("Debug: Error - No such volume, therefore can not change environment variable.\r\n"));
            return flBadParameter;
         }
         if (socket>=SOCKETS)
         {
            DEBUG_PRINT(("Debug: Error - No such socket, therefore can not change environment variable.\r\n"));
            return flBadParameter;
         }
         break;

      /* Socket specfic variables */

#ifdef VERIFY_WRITE
      case FL_VERIFY_WRITE_OTHER:
#endif /* VERIFY_WRITE */
      case FL_MTD_BUS_ACCESS_TYPE:
         if (socket>=SOCKETS)
         {
            DEBUG_PRINT(("Debug: Error - No such socket, therefore can not change environment variable.\r\n"));
            return flBadParameter;
         }
         if (volume!=INVALID_VOLUME_NUMBER)
         {
            DEBUG_PRINT(("Debug: Error - This global variable is common to all volumes.\r\n"));
            return flBadParameter;
         }
         break;

      /* Global variables for all sockets and volumes */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
      case FL_SECTORS_VERIFIED_PER_FOLDING:
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
      case FL_IS_RAM_CHECK_ENABLED:
      case FL_TL_CACHE_ENABLED:
      case FL_DOC_8BIT_ACCESS:
      case FL_MULTI_DOC_ENABLED:
      case FL_SET_MAX_CHAIN:
      case FL_MARK_DELETE_ON_FLASH:
      case FL_SUSPEND_MODE:
      case FL_MTL_POLICY:
         if ((socket!=INVALID_VOLUME_NUMBER) || (volume!=INVALID_VOLUME_NUMBER))
         {
            DEBUG_PRINT(("Debug: Error - This global variable is common to all sockets and volumes.\r\n"));
            return flBadParameter;
         }
         break;

      default:

         DEBUG_PRINT(("Debug: Unknown variable type.\r\n"));
         return flFeatureNotSupported;
   }

   /* Make sure environement variables are */
   /* initialized to their default values  */
   flInitGlobalVars();


   /***************************************************/
   /* Arguments have been checked now change variable */
   /* and report the previous value.                  */
   /***************************************************/

   switch (variableType)
   {
      case FL_IS_RAM_CHECK_ENABLED:
         *prevValue                  = (dword)flUseisRAM;
         flUseisRAM                  = (byte)value;
         break;
      case FL_TL_CACHE_ENABLED:
         *prevValue                  = (dword)flUseNFTLCache;
         flUseNFTLCache              = (byte)value;
         break;
      case FL_DOC_8BIT_ACCESS:
         *prevValue                  = (dword)flUse8Bit;
         flUse8Bit                   = (byte)value;
         break;
      case FL_SET_MAX_CHAIN:
         *prevValue                  = (dword)flMaxUnitChain;
         flMaxUnitChain              = (byte)value;
         break;
      case FL_MARK_DELETE_ON_FLASH:
         *prevValue                  = (dword)flMarkDeleteOnFlash;
         flMarkDeleteOnFlash         = (byte)value;
         break;
#ifdef MULTI_DOC
      case FL_MULTI_DOC_ENABLED:
         *prevValue                  = (dword)flUseMultiDoc;
         flUseMultiDoc               = (byte)value;
         break;
      case FL_MTL_POLICY:
         *prevValue                  = (dword)flMTLdefragMode;
         flMTLdefragMode             = (byte)value;
         break;
#endif /* MULTI_DOC */
      case FL_SUSPEND_MODE:
         if((value == FL_OFF) && (flSuspendMode != FL_OFF))
#ifdef EXIT
            flExit();
#endif /* EXIT */
         *prevValue                  = (dword)flSuspendMode;
         flSuspendMode               = (byte)value;
         break;
      case FL_SET_POLICY:
         *prevValue                  = (dword)flPolicy[socket][volume];
/*       flPolicy[socket][volume]    = (byte)value; */
         break;
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
      case FL_SECTORS_VERIFIED_PER_FOLDING:
         *prevValue                  = flSectorsVerifiedPerFolding;
         flSectorsVerifiedPerFolding = value;
         break;
      case FL_VERIFY_WRITE_BDTL:
         *prevValue                    = (dword)flVerifyWrite[socket][volume];
         flVerifyWrite[socket][volume] = (byte)value;
         break;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
#ifdef VERIFY_WRITE
      case FL_VERIFY_WRITE_BINARY:
         *prevValue      = (dword)flVerifyWrite[socket][volume+MAX_TL_PARTITIONS];
         flVerifyWrite[socket][volume+MAX_TL_PARTITIONS] = (byte)value;
         break;
      case FL_VERIFY_WRITE_OTHER:
         *prevValue      = (dword)flVerifyWrite[socket][(MAX_TL_PARTITIONS<<1)-1];
         flVerifyWrite[socket][(MAX_TL_PARTITIONS<<1)-1] = (byte)value;
         break;
#endif /* VERIFY_WRITE */

      default: /* FL_MTD_BUS_ACCESS_TYPE */
#ifndef FL_NO_USE_FUNC
         *prevValue          = flBusConfig[socket];
         flBusConfig[socket] = (dword)value;
#endif /* FL_NO_USE_FUNC */
         break;
   }
   return flOK;
}

/*----------------------------------------------------------------------*/
/*                       f l S e t E n v S o c k e t                    */
/*                                                                      */
/* Change one of TrueFFS environment variables for a specific sockets.  */
/*                                                                      */
/* Parameters:                                                          */
/*      variableType    : variable type to cahnge                       */
/*      socket          : socket number                                 */
/*      value           : varaible value                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      prevValue       : The previous value of the variable            */
/*                        if there are more then 1 partition in that    */
/*                        socket , the first partition value is returned*/
/*----------------------------------------------------------------------*/

FLStatus NAMING_CONVENTION flSetEnvSocket(FLEnvVars variableType , byte socket , dword value, dword FAR2 *prevValue)
{
   FLStatus status = flOK;
   byte     volume = 0;

   switch (variableType) /* Check volume and socket sanity */
   {
      /* Volume specific variables */

      case FL_SET_POLICY:
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
      case FL_VERIFY_WRITE_BDTL:
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
         status = flSetEnvVolume(variableType,socket,MAX_TL_PARTITIONS-1,value,prevValue);
#ifdef VERIFY_WRITE
      case FL_VERIFY_WRITE_BINARY:
#endif /* VERIFY_WRITE */
         for (;(volume<MAX_TL_PARTITIONS-1)&&(status == flOK);volume++)
            status = flSetEnvVolume(variableType,socket,volume,value,prevValue);
         break;

      /* Socket specific variables */

#ifdef VERIFY_WRITE
      case FL_VERIFY_WRITE_OTHER:
#endif /* VERIFY_WRITE */
#ifndef FL_NO_USE_FUNC
      case FL_MTD_BUS_ACCESS_TYPE:
#endif /* FL_NO_USE_FUNC */
#if (defined(VERIFY_WRITE) || !defined(FL_NO_USE_FUNC))
         status = flSetEnvVolume(variableType,socket,INVALID_VOLUME_NUMBER,value,prevValue);
         break; 
#endif /* not FL_NO_USE_FUNC || VERIFY_WRITE */

      /* Either global variables , or unknown */

      default:
         if(socket != INVALID_VOLUME_NUMBER) /* Was not called from flSetEnv */
         {
            DEBUG_PRINT(("Debug: Variable type is either unknown or not socket related.\r\n"));
            return flBadParameter;
         }
         status = flSetEnvVolume(variableType,INVALID_VOLUME_NUMBER,INVALID_VOLUME_NUMBER,value,prevValue);
         break; 
   }
   return status;
}

/*----------------------------------------------------------------------*/
/*                       f l S e t E n v All                            */
/*                                                                      */
/* Change one of TrueFFS environment variables for all systems, sockets */
/* and partitions.                                                      */
/*                                                                      */
/* Parameters:                                                          */
/*      variableType    : variable type to cahnge                       */
/*      value           : varaible value                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      prevValue       : The previous value of the variable            */
/*----------------------------------------------------------------------*/

FLStatus NAMING_CONVENTION flSetEnvAll(FLEnvVars variableType , dword value, dword FAR2 *prevValue)
{
   FLStatus status = flOK;
   byte     socket;

   switch (variableType) /* Check volume and socket sanity */
   {
      case FL_SET_POLICY:           /* Per volume */
      case FL_VERIFY_WRITE_BDTL:    /* Per volume */
      case FL_VERIFY_WRITE_BINARY:  /* Per volume */
      case FL_VERIFY_WRITE_OTHER:   /* Per socket */
      case FL_MTD_BUS_ACCESS_TYPE:  /* Per socket */
         for (socket=0;(socket<SOCKETS)&&(status == flOK);socket++)
            status = flSetEnvSocket(variableType,socket,value,prevValue);
         return status;
      default:
         return flSetEnvVolume(variableType,INVALID_VOLUME_NUMBER,INVALID_VOLUME_NUMBER,value,prevValue);
   }
}

#endif /* ENVIRONMENT_VARS */

#ifndef FL_NO_USE_FUNC
/*----------------------------------------------------------------------*/
/*                  f l S e t D o c B u s R o u t i n e                 */
/*                                                                      */
/* Set user defined memory acces routines for DiskOnChip.               */
/*                                                                      */
/* Parameters:                                                          */
/*      socket      : Socket number to install routine for.             */
/*      structPtr   : Pointer to function structure.                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus NAMING_CONVENTION flSetDocBusRoutine(byte socket, FLAccessStruct FAR1 * structPtr)
{
   FLFlash* flash;

   /* Arg sanity check */
   if (socket >= SOCKETS)
   {
      DEBUG_PRINT(("Error : change SOCKETS definition in flcustom.h to support that many sockets.\r\n"));
      return flFeatureNotSupported;
   }
   if(structPtr == NULL)
   {
      DEBUG_PRINT(("ERROR - structPtr argument is NULL.\r\n"));
      return flBadParameter;
   }

   /* Make sure global variables are initialized to their default values */
   flInitGlobalVars();

   flash = flFlashOf(socket);

   flash->memWindowSize = structPtr->memWindowSize;
   flash->memRead       = structPtr->memRead;
   flash->memWrite      = structPtr->memWrite;
   flash->memSet        = structPtr->memSet;
   flash->memRead8bit   = structPtr->memRead8bit;
   flash->memRead16bit  = structPtr->memRead16bit;
   flash->memWrite8bit  = structPtr->memWrite8bit;
   flash->memWrite16bit = structPtr->memWrite16bit;

   flBusConfig[socket]  = FL_ACCESS_USER_DEFINED;
   return flOK;
}

/*----------------------------------------------------------------------*/
/*                  f l G e t D o c B u s R o u t i n e                 */
/*                                                                      */
/* Get currently installed memory access routines for DiskOnChip.       */
/*                                                                      */
/* Parameters:                                                          */
/*      socket      : Socket number to install routine for.             */
/*      structPtr   : Pointer to function structure.                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus NAMING_CONVENTION flGetDocBusRoutine(byte socket, FLAccessStruct FAR1 * structPtr)
{
   FLFlash* flash;

   /* Arg sanity check */
   if (socket >= SOCKETS)
   {
      DEBUG_PRINT(("Error : change SOCKETS definition in flcustom.h to support that many sockets.\r\n"));
      return flFeatureNotSupported;
   }
   if(structPtr == NULL)
   {
      DEBUG_PRINT(("ERROR - structPtr argument is NULL.\r\n"));
      return flBadParameter;
   }

   /* Make sure global variables are initialized to their default values */
   flInitGlobalVars();

   flash = flFlashOf(socket);

   structPtr->memWindowSize = flash->memWindowSize;
   structPtr->memRead       = flash->memRead;
   structPtr->memWrite      = flash->memWrite;
   structPtr->memSet        = flash->memSet;
   structPtr->memRead8bit   = flash->memRead8bit;
   structPtr->memRead16bit  = flash->memRead16bit;
   structPtr->memWrite8bit  = flash->memWrite8bit;
   structPtr->memWrite16bit = flash->memWrite16bit;
   structPtr->access        = flBusConfig[socket];

   return flOK;
}

#endif /* FL_NO_USE_FUNC */

/*----------------------------------------------------------------------*/
/*                     f l I n i t G l o b a l V a r s                  */
/*                                                                      */
/* Initializes the FLite system, environment and access type variables. */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/* Returns:                                                             */
/*      None                                                            */
/*----------------------------------------------------------------------*/

void flInitGlobalVars(void)
{
   int i;
#ifdef ENVIRONMENT_VARS
   int j;
#endif /* ENVIRONMENT_VARS */

   if(initGlobalVarsDone == TRUE)
     return;

   /* Do not initialize variables on next call */
   initGlobalVarsDone     = TRUE;

   /*
    * Set default values to per socket/volume variables
    */

   for(i=0;i<SOCKETS;i++)
   {
#ifndef FL_NO_USE_FUNC
      flBusConfig[i] = FL_NO_ADDR_SHIFT        |
                       FL_BUS_HAS_8BIT_ACCESS  |
                       FL_BUS_HAS_16BIT_ACCESS |
                       FL_BUS_HAS_32BIT_ACCESS;
#endif /* FL_NO_USE_FUNC */
#ifdef ENVIRONMENT_VARS
      for (j=0;j<MAX_TL_PARTITIONS;j++)
      {
         flPolicy[i][j]   = FL_DEFAULT_POLICY; /* FL_COMPLETE_ASAP */
      }
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
      for (j=0;j<MAX_TL_PARTITIONS<<1;j++)
      {
         flVerifyWrite[i][j] = FL_OFF; /* FL_ON , FL_UPS */
      }
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
#endif /* ENVIRONMENT_VARS */
   }

   /*
    * Set default values to per platform variables
    */

#ifdef ENVIRONMENT_VARS
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
/* Max sectors verified per write operation (must be even number) */
   flSectorsVerifiedPerFolding = 64;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
#ifdef MULTI_DOC
/* No multi-doc (MTL)                        */
   flUseMultiDoc               = FL_OFF;
/* MTL defragmentaion mode (0 - standard)    */
   flMTLdefragMode             = FL_MTL_DEFRAGMENT_ALL_DEVICES;
#endif /* MULTI_DOC */
/* Maximum chain length                      */
   flMaxUnitChain              = 20;
/* Mark the delete sector on the flash       */
   flMarkDeleteOnFlash         = FL_ON;
/* Read Only mode                            */
   flSuspendMode               = FL_OFF;
#endif /* ENVIRONMENT_VARS */
}

/*----------------------------------------------------------------------*/
/*                           m o u n t L o w L e v e l                  */
/*                                                                      */
/* Mount a volume for low level operations. If a low level routine is   */
/* called and the volume is not mounted for low level operations, this  */
/* routine is called atomatically.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus mountLowLevel(Volume vol)
{
  checkStatus(flIdentifyFlash(vol.socket,vol.flash));
  vol.flash->setPowerOnCallback(vol.flash);
  vol.flags |= VOLUME_LOW_LVL_MOUNTED;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                           d i s m o u n t L o w L e v e l            */
/*                                                                      */
/* Dismount the volume for low level operations.                        */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void dismountLowLevel(Volume vol)
{
  /* mark the volume as unmounted for low level operations.
     And does not change any of the other flags */
  vol.flags &= ~VOLUME_LOW_LVL_MOUNTED;
}


#ifdef FORMAT_VOLUME

/*----------------------------------------------------------------------*/
/*                  f i n d F r e e V o l u m e                         */
/*                                                                      */
/* Search the vols array for an empty cell to hold the new volume  .    */
/*                                                                      */
/* Parameters:                                                          */
/*      socket        : Socket number for the new volume.               */
/*      partition     : Partition number of the new volume.             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus      : 0 on success, flGeneralFailure if no more       */
/*                      volumes left.                                   */
/*----------------------------------------------------------------------*/

static FLStatus findFreeVolume(byte socket, byte partition)
{
   byte volNo;

   for (volNo = noOfSockets;volNo < VOLUMES;volNo++)
   {
     if ((vols[volNo].flags & VOLUME_ACCUPIED) == 0)
       break;
   }
   if (volNo == VOLUMES)
     return flGeneralFailure;

   handleConversionTable[socket][partition] = volNo;
   vols[volNo].volExecInProgress = &flMutex[socket];
   vols[volNo].socket            = vols[socket].socket;
   vols[volNo].flash             = vols[socket].flash;
   vols[volNo].tl.socketNo       = socket;
   vols[volNo].tl.partitionNo    = partition;
   vols[volNo].flags             = VOLUME_ACCUPIED;
   return flOK;
}

/*----------------------------------------------------------------------*/
/*             d i s m o u n t P h y s i c a l D r i v e                */
/*                                                                      */
/* Dismounts all the volumes on a specfic socket, closing all files.    */
/* This call is not normally necessary, unless it is known the volume   */
/* will soon be removed. The routine also clears the volumes entries in */
/* the volume convertion table, except for partition 0                  */
/*                                                                      */
/* Parameters:                                                          */
/*      socketNo        : Socket number to dismount.                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus dismountPhysicalDrive(byte socketNo)
{
  byte volNo;
  byte partition;

  /* Dismount all physical drive volumes  */

  checkStatus(dismountVolume(&vols[socketNo]));
  for(partition = 1;partition < MAX_TL_PARTITIONS; partition++)
  {
      volNo = handleConversionTable[socketNo][partition];
      if (volNo != INVALID_VOLUME_NUMBER)
      {
         checkStatus(dismountVolume(&vols[volNo]));
         handleConversionTable[socketNo][partition]=INVALID_VOLUME_NUMBER;
         vols[volNo].flags = 0;
      }
  }
  return flOK;
}
#endif /* FORMAT_VOLUME */

/*----------------------------------------------------------------------*/
/*                    d i s m o u n t V o l u m e                       */
/*                                                                      */
/* Dismounts the volume, closing all files.                             */
/* This call is not normally necessary, unless it is known the volume   */
/* will soon be removed.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus dismountVolume(Volume vol)
{
  if (vol.flags & VOLUME_ABS_MOUNTED)
  {
    FLStatus status = flOK;
#ifndef FIXED_MEDIA
    status = flMediaCheck(vol.socket);
#endif
    if (status != flOK)
      vol.flags = 0;
#if FILES>0
    status = dismountFS(&vol,status);
#endif
    vol.tl.dismount(vol.tl.rec);
  }
  vol.flags = VOLUME_ACCUPIED;        /* mark volume unmounted */

  return flOK;
}

/*----------------------------------------------------------------------*/
/*                         s e t B u s y                                */
/*                                                                      */
/* Notifies the start and end of a file-system operation.               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      state           : FL_ON (1) = operation entry                   */
/*                        FL_OFF(0) = operation exit                    */
/*      partition       : Partition number of the drive                 */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus setBusy(Volume vol, FLBoolean state, byte partition)
{
  FLStatus status = flOK;

  if (state == FL_ON) {

    if (!flTakeMutex(execInProgress))
       return flDriveNotAvailable;
    
    /* Mark current partition for MTD verify write */
    vol.socket->curPartition = partition; 
    flSocketSetBusy(vol.socket,FL_ON);
    flNeedVcc(vol.socket);
    if (vol.flags & VOLUME_ABS_MOUNTED)
      status = vol.tl.tlSetBusy(vol.tl.rec,FL_ON);
  }
  else {
    if (vol.flags & VOLUME_ABS_MOUNTED)
      status = vol.tl.tlSetBusy(vol.tl.rec,FL_OFF);

    flDontNeedVcc(vol.socket);
    flSocketSetBusy(vol.socket,FL_OFF);
    flFreeMutex(execInProgress);
  }

  return status;
}

/*----------------------------------------------------------------------*/
/*                        f i n d S e c t o r                           */
/*                                                                      */
/* Locates a sector in the buffer or maps it                            */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Sector no. to locate                          */
/*                                                                      */
/*----------------------------------------------------------------------*/


const void FAR0 *findSector(Volume vol, SectorNo sectorNo)
{
  return
#if FILES > 0
  (sectorNo == vol.volBuffer.sectorNo && &vol == vol.volBuffer.owner) ?
    vol.volBuffer.flData :
#endif
    vol.tl.mapSector(vol.tl.rec,sectorNo,NULL);
}

/*----------------------------------------------------------------------*/
/*                a b s M o u n t V o l u m e                           */
/*                                                                      */
/* Mounts the Flash volume and assume that volume has no FAT            */
/*                                                                      */
/* In case the inserted volume has changed, or on the first access to   */
/* the file system, it should be mounted before file operations can be  */
/* done on it.                                                          */
/* Mounting a volume has the effect of discarding all open files (the   */
/* files cannot be properly closed since the original volume is gone),  */
/* and turning off the media-change indication to allow file processing */
/* calls.                                                               */
/*                                                                      */
/* The volume automatically becomes unmounted if it is removed or       */
/* changed.                                                             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus absMountVolume(Volume vol)
{
  unsigned volNo     = (unsigned)(&vol - vols);
#ifdef WRITE_PROTECTION
  PartitionTable FAR0 *partitionTable;
#endif

  checkStatus(dismountVolume(&vol));

  /* Try to mount translation layer */

  checkStatus(flMount(volNo,vol.tl.socketNo,&vol.tl,TRUE,vol.flash));

  vol.bootSectorNo = 0; /*  assume sector 0 is DOS boot block */
#ifdef WRITE_PROTECTION
  partitionTable = (PartitionTable FAR0 *) findSector(&vol,0);
  if((partitionTable == NULL)||
     (partitionTable==dataErrorToken)||
     (LE2(partitionTable->signature) != PARTITION_SIGNATURE))
      vol.password[0] = vol.password[1] = 0;
  else
  {
     vol.password[0] = vol.password[1] = 0;
     if (UNAL4(partitionTable->passwordInfo[0]) == 0 &&
        (UNAL4(partitionTable->passwordInfo[1]) != 0 ||
        UNAL4(partitionTable->passwordInfo[2]) != 0)) {
        vol.password[0] = UNAL4(partitionTable->passwordInfo[1]);
        vol.password[1] = UNAL4(partitionTable->passwordInfo[2]);
        vol.flags |= VOLUME_WRITE_PROTECTED;
     }
  }
#endif   /* WRITE_PROTECTION */
  /* Disable FAT monitoring */
  vol.firstFATSectorNo = vol.secondFATSectorNo = 0; 
  vol.flags |= VOLUME_ABS_MOUNTED;  /* Enough to do abs operations */

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                     m o u n t V o l u m e                            */
/*                                                                      */
/* Mounts the Flash volume.                                             */
/*                                                                      */
/* In case the inserted volume has changed, or on the first access to   */
/* the file system, it should be mounted before file operations can be  */
/* done on it.                                                          */
/* Mounting a volume has the effect of discarding all open files (the   */
/* files cannot be properly closed since the original volume is gone),  */
/* and turning off the media-change indication to allow file processing */
/* calls.                                                               */
/*                                                                      */
/* The volume automatically becomes unmounted if it is removed or       */
/* changed.                                                             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      bootSectors     : Returns the number of sectors, flMountVolume  */
/*                        skipps.                                       */
/*----------------------------------------------------------------------*/

static FLStatus mountVolume(Volume vol,unsigned FAR2* bootSectors)
{
  SectorNo noOfSectors;
  PartitionTable FAR0 *partitionTable;
  Partition ptEntry;
  DOSBootSector FAR0 *bootSector;
  unsigned ptCount,extended_depth,ptSector;
  FLBoolean primaryPtFound = FALSE, extendedPtFound = TRUE;

  *bootSectors=0;
  checkStatus(absMountVolume(&vol));

  for(extended_depth = 0,ptSector = 0;
      (extended_depth<MAX_PARTITION_DEPTH) &&
      (primaryPtFound==FALSE) &&
      (extendedPtFound==TRUE);
      extended_depth++) {

    extendedPtFound=FALSE;
    /* Read in paritition table */

    partitionTable = (PartitionTable FAR0 *) findSector(&vol,ptSector);

    if(partitionTable == NULL) {
      vol.tl.dismount(vol.tl.rec);
      return flSectorNotFound;
    }
    if(partitionTable==dataErrorToken) {
      vol.tl.dismount(vol.tl.rec);
      return flDataError;
    }

    if (LE2(partitionTable->signature) != PARTITION_SIGNATURE)
      break;
    for(ptCount=0;
    (ptCount<4) && (primaryPtFound==FALSE) && (extendedPtFound==FALSE);
    ptCount++) {

      ptEntry = partitionTable->ptEntry[ptCount];

      switch (ptEntry.type) {
    case FAT12_PARTIT:
    case FAT16_PARTIT:
    case DOS4_PARTIT:
      primaryPtFound = TRUE;
      vol.bootSectorNo =
          (unsigned) UNAL4(ptEntry.startingSectorOfPartition);
      *bootSectors=vol.bootSectorNo;
      break;
    case EX_PARTIT:
      extendedPtFound = TRUE;
      ptSector = (unsigned)UNAL4(ptEntry.startingSectorOfPartition);
      break;
    default:
      break;
      }
    }
  }

  bootSector = (DOSBootSector FAR0 *) findSector(&vol,vol.bootSectorNo);
  if(bootSector == NULL)
    return flSectorNotFound;

  if(bootSector==dataErrorToken)
    return flDataError;

  /* Do the customary sanity checks */
  if (!(bootSector->bpb.jumpInstruction[0] == 0xe9 ||
    (bootSector->bpb.jumpInstruction[0] == 0xeb &&
     bootSector->bpb.jumpInstruction[2] == 0x90))) {
    DEBUG_PRINT(("Debug: did not recognize format.\r\n"));
    return flNonFATformat;
  }

  /* See if we handle this sector size */
  if (UNAL2(bootSector->bpb.bytesPerSector) != SECTOR_SIZE)
    return flFormatNotSupported;

  vol.sectorsPerCluster = bootSector->bpb.sectorsPerCluster;
  vol.numberOfFATS = bootSector->bpb.noOfFATS;
  vol.sectorsPerFAT = LE2(bootSector->bpb.sectorsPerFAT);
  vol.firstFATSectorNo = vol.bootSectorNo +
                LE2(bootSector->bpb.reservedSectors);
  vol.secondFATSectorNo = vol.firstFATSectorNo +
                 LE2(bootSector->bpb.sectorsPerFAT);
  vol.rootDirectorySectorNo = vol.firstFATSectorNo +
           bootSector->bpb.noOfFATS * LE2(bootSector->bpb.sectorsPerFAT);
  vol.sectorsInRootDirectory =
    (UNAL2(bootSector->bpb.rootDirectoryEntries) * DIRECTORY_ENTRY_SIZE - 1) /
        SECTOR_SIZE + 1;
  vol.firstDataSectorNo = vol.rootDirectorySectorNo +
                 vol.sectorsInRootDirectory;

  noOfSectors = UNAL2(bootSector->bpb.totalSectorsInVolumeDOS3);
  if (noOfSectors == 0)
    noOfSectors = (SectorNo) LE4(bootSector->bpb.totalSectorsInVolume);


  vol.maxCluster = (unsigned) ((noOfSectors + vol.bootSectorNo - vol.firstDataSectorNo) /
                vol.sectorsPerCluster) + 1;

  if (vol.maxCluster < 4085) {
#ifdef FAT_12BIT
    vol.flags |= VOLUME_12BIT_FAT;      /* 12-bit FAT */
#else
    DEBUG_PRINT(("Debug: FAT_12BIT must be defined.\r\n"));
    return flFormatNotSupported;
#endif
  }
  vol.bytesPerCluster = vol.sectorsPerCluster * SECTOR_SIZE;
  vol.allocationRover = 2;      /* Set rover at first cluster */
  vol.flags |= VOLUME_MOUNTED;  /* That's it */
  return flOK;
}

#ifndef FL_READ_ONLY
#ifdef DEFRAGMENT_VOLUME

/*----------------------------------------------------------------------*/
/*                       d e f r a g m e n t V o l u m e                */
/*                                                                      */
/* Performs a general defragmentation and recycling of non-writable     */
/* Flash areas, to achieve optimal write speed.                         */
/*                                                                      */
/* NOTE: The required number of sectors (in irLength) may be changed    */
/* (from another execution thread) while defragmentation is active. In  */
/* particular, the defragmentation may be cut short after it began by   */
/* modifying the irLength field to 0.                                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      ioreq->irLength : Minimum number of sectors to make available   */
/*                        for writes.                                   */
/*                                                                      */
/* Returns:                                                             */
/*      ioreq->irLength : Actual number of sectors available for writes */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus defragmentVolume(Volume vol, IOreq FAR2 *ioreq)
{
  return vol.tl.defragment(vol.tl.rec,&ioreq->irLength);
}

#endif /* DEFRAGMENT_VOLUME */

#ifdef FORMAT_VOLUME

/*-----------------------------------------------------------------------*/
/*                    f l F o r m a t V o l u m e                        */
/*                                                                       */
/* Formats a volume, writing a new and empty file-system. All existing   */
/* data is destroyed. Optionally, a low-level FTL formatting is also     */
/* done.                                                                 */
/* Formatting leaves the volume in the dismounted state, so that a       */
/* flMountVolume call is necessary after it.                             */
/*                                                                       */
/* Note: This routine was left for backwards compatibility with OSAK 4.2 */
/*       and down therfore it is strongly recommended to use the         */
/*       flFormatPhysicalDrive routine instead.                          */
/*                                                                       */
/* Parameters:                                                           */
/*      vol             : Pointer identifying drive                      */
/*      irHandle        : Drive number (0, 1, ...)                       */
/*      irFlags         : FAT_ONLY_FORMAT : Do FAT formatting only       */
/*                        TL_FORMAT_ONLY  : Do TL format only            */
/*                        TL_FORMAT       : Translation layer + FAT      */
/*                        TL_FORMAT_IF_NEEDED: Do TL formatting only if  */
/*                                             current format is invalid */
/*                                             but perform FAT anyway    */
/*      irData          : Address of FormatParams structure to use       */
/*                        (defined in flformat.h)                        */
/*                                                                       */
/* Returns:                                                              */
/*      FLStatus        : 0 on success, otherwise failed                 */
/*-----------------------------------------------------------------------*/

static FLStatus bdFormatVolume(Volume vol, IOreq FAR2 *ioreq)
{
  FormatParams FAR2 *userFp = (FormatParams FAR2 *) ioreq->irData;
  BDTLPartitionFormatParams bdtlFp;
  TLFormatParams tlFp;
  FLBoolean mountOK = FALSE;
  FLStatus status;
  byte socket = FL_GET_SOCKET_FROM_HANDLE(ioreq);

  /* Convert argument to TLFormatParmas */

  tlFp.noOfBinaryPartitions = 0;
  tlFp.noOfBDTLPartitions   = 1;
  tlFp.BDTLPartitionInfo    = NULL;
  tlFp.binaryPartitionInfo  = NULL;
  tlFp.bootImageLen         = userFp->bootImageLen;
  tlFp.percentUse           = (byte)userFp->percentUse;
  tlFp.noOfSpareUnits       = (byte)userFp->noOfSpareUnits;
  tlFp.noOfCascadedDevices  = 0;
  tlFp.progressCallback     = userFp->progressCallback;
  tlFp.vmAddressingLimit    = userFp->vmAddressingLimit;
  tlFp.embeddedCISlength    = (word)userFp->embeddedCISlength;
  tlFp.embeddedCIS          = (byte FAR1 *)userFp->embeddedCIS;
  tlFp.flags                = FL_LEAVE_BINARY_AREA;
#ifdef WRITE_EXB_IMAGE
  tlFp.exbLen               = 0;
#endif /* WRITE_EXB_IMAGE */
#ifdef HW_PROTECTION
  /* protectionKey[8]; */
  tlFp.protectionType       = 0;
#endif /* HW_PROTECTION */

  /* Dismount all physical drive volumes and set handle to the first */

  checkStatus(dismountPhysicalDrive(socket));
  pVol = &vols[socket];

  /* Format according to the irFlags argument */

  if ((ioreq->irFlags & TL_FORMAT)||(ioreq->irFlags & TL_FORMAT_ONLY))
  {
     checkStatus(flFormat(socket,&tlFp,vol.flash));
  }
  else
  {
     status = flMount(socket,socket,&vol.tl,FALSE,vol.flash); /* Try to mount translation layer */
     mountOK = TRUE;
     if ((status == flUnknownMedia || status == flBadFormat) &&
     (ioreq->irFlags & TL_FORMAT_IF_NEEDED))
     {
        status = flFormat(socket,&tlFp,vol.flash);
        mountOK = FALSE;
     }
     else
     {
        /*  assume sector 0 is DOS boot block */
        vol.bootSectorNo     = 0;     
        /* Disable FAT monitoring */
        vol.firstFATSectorNo = vol.secondFATSectorNo = 0; 
        /* Enough to do abs operations */
        vol.flags |= VOLUME_ABS_MOUNTED; 
     }
     if (status != flOK)
        return status;
  }

  if (!mountOK)
    checkStatus(absMountVolume(&vol)); /* Mount the first partition */

#if (defined(VERIFY_WRITE) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  if(vol.tl.checkVolume != NULL)
    checkStatus(vol.tl.checkVolume(vol.tl.rec));
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */

  if(!(ioreq->irFlags & TL_FORMAT_ONLY))
  {
    /* build BDTL record for dos format routine */

    tffscpy(bdtlFp.volumeId,userFp->volumeId,4);
    bdtlFp.volumeLabel              = (byte FAR1 *)userFp->volumeLabel;
    bdtlFp.noOfFATcopies            = (byte)userFp->noOfFATcopies;
    bdtlFp.flags                    = TL_FORMAT_FAT;
    checkStatus(flDosFormat(&vol.tl,&bdtlFp));
  }
  return flOK;
}

/*----------------------------------------------------------------------*/
/*            f l F o r m a t P h y s i c a l D r i v e                 */
/*                                                                      */
/* Low Level formats the media while partitioning it.                   */
/* optionaly the followng additional formats are placed                 */
/* 1) writing a new and empty file-system                               */
/* 2) Compressed media format                                           */
/* 3) Quick Mount format                                                */
/*                                                                      */
/* 4) Place M-systems EXB file on the media                             */
/* All existing data is destroyed.                                      */
/* Formatting leaves the volume in the dismounted state, so that a      */
/* flMountVolume call is necessary after it.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      vol      : Pointer identifying drive                            */
/*      irHandle : Drive number (0, 1, ...)                             */
/*      irFlags  :                                                      */
/*       TL_NORMAL_FORMAT          : Normal format                      */
/*       TL_LEAVE_BINARY_AREA      : Leave binary area unchanged        */
/*                                                                      */
/*      irData   : Address of FormatParams2 structure to use            */
/*                            (defined in flformat.h)                   */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus bdFormatPhysicalDrive(Volume vol, IOreq FAR2 *ioreq)
{
  FormatParams2  FAR2* userFp = (FormatParams2 FAR2 *) ioreq->irData;
  BDTLPartitionFormatParams FAR2* bdtl;
  TLFormatParams                  tlFp;
  byte     socket = FL_GET_SOCKET_FROM_HANDLE(ioreq);
  byte     partition;
  byte     volNo;
#ifdef COMPRESSION
  FLStatus status;
#endif /* COMPRESSION */

  /***********************************************/
  /* Convert format parameters to TLFormatParams */
  /***********************************************/

  if (userFp->BDTLPartitionInfo == NULL)
     return flBadParameter;

/* Note that the the BDTL partition are shiftet so that the second
   becomes the first ... . This is for backwards compatibility with
   FTP \ NFTL where the first partition is not given as an array    */

  tlFp.bootImageLen         = -1; /* either all or nothing */
  tlFp.percentUse           = userFp->percentUse;
  tlFp.noOfBDTLPartitions   = userFp->noOfBDTLPartitions;
  tlFp.noOfBinaryPartitions = userFp->noOfBinaryPartitions;
  tlFp.BDTLPartitionInfo    = userFp->BDTLPartitionInfo;
  tlFp.binaryPartitionInfo  = userFp->binaryPartitionInfo;
  tlFp.progressCallback     = userFp->progressCallback;
  tlFp.vmAddressingLimit    = userFp->vmAddressingLimit;
  tlFp.embeddedCISlength    = userFp->embeddedCISlength;
  tlFp.embeddedCIS          = userFp->embeddedCIS;
  tlFp.cascadedDeviceNo     = userFp->cascadedDeviceNo;
  tlFp.noOfCascadedDevices  = userFp->noOfCascadedDevices;
  tlFp.flags                = (byte)ioreq->irFlags;

/* Convert last partition arguments from array to dedicated fields */

  bdtl                      = userFp->BDTLPartitionInfo;
  bdtl                     += (userFp->noOfBDTLPartitions - 1);
  tffscpy(tlFp.volumeId,bdtl->volumeId,4);
  tlFp.noOfSpareUnits       = (byte)bdtl->noOfSpareUnits;
  tlFp.volumeLabel          = bdtl->volumeLabel;
  tlFp.noOfFATcopies        = bdtl->noOfFATcopies;
#ifdef HW_PROTECTION
  tffscpy(tlFp.protectionKey,bdtl->protectionKey,PROTECTION_KEY_LENGTH);
  tlFp.protectionType   = bdtl->protectionType;
#endif /* HW_PROTECTION */

  /* Dismount all physical drive volumes  */

  checkStatus(dismountPhysicalDrive(socket));

  /**********************/
  /* Analize EXB buffer */
  /**********************/

  pVol = &vols[socket];
#ifdef WRITE_EXB_IMAGE
  if ((ioreq->irFlags & TL_LEAVE_BINARY_AREA) ||
      ((userFp->exbBufferLen <= 0) && (userFp->exbLen == 0)))
  {
     tlFp.exbLen = 0;
  }
  else
  {
     if (userFp->exbLen <= 0)
     {
        checkStatus(getExbInfo(&vol, userFp->exbBuffer, 
                               userFp->exbBufferLen,
                               userFp->exbFlags));
        tlFp.exbLen = vol.binaryLength;
     }
     else
     {
        tlFp.exbLen = userFp->exbLen;
     }
  }
#endif /* WRITE_EXB_IMAGE */

  /*************************************************/
  /* Perform low level format and write EXB buffer */
  /*************************************************/

  checkStatus(flFormat(socket,&tlFp,vol.flash));

  /****************************************/
  /* perform FAT and ZIP format if needed */
  /****************************************/

  for(partition=0, bdtl = userFp->BDTLPartitionInfo;
      partition<userFp->noOfBDTLPartitions;
      partition++,bdtl++)
  {
     if ( partition > 0)
        checkStatus(findFreeVolume(socket,partition));
     volNo = handleConversionTable[socket][partition];
     pVol = &vols[volNo];
#ifdef COMPRESSION
     if(bdtl->flags & TL_FORMAT_COMPRESSED)
     {
        checkStatus(flMount(volNo,socket,&(vol.tl),FALSE,vol.flash));
        status = flFormatZIP(volNo,&vol.tl);
        vol.tl.dismount(vol.tl.rec);
        if(status!=flOK)
           return status;
     }
#endif /* COMPRESSION */

     checkStatus(absMountVolume(&vol));
#if (defined(VERIFY_WRITE) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
     if(vol.tl.checkVolume != NULL)
        checkStatus(vol.tl.checkVolume(vol.tl.rec));
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
     if(bdtl->flags & TL_FORMAT_FAT) /* perform FAT format as well */
        checkStatus(flDosFormat(&vol.tl,bdtl));
     checkStatus(dismountVolume(&vol));
  }

#ifdef WRITE_EXB_IMAGE
  if (userFp->exbBufferLen > 0 )
  {
     pVol = &vols[socket];
     checkStatus(placeExbByBuffer(&vol,(byte FAR1 *)userFp->exbBuffer,
     userFp->exbBufferLen,userFp->exbWindow,userFp->exbFlags));
  }
#endif /* WRITE_EXB_IMAGE */

  checkStatus(mountLowLevel(&vol));
  if (vol.flash->download!=NULL)
  {
     return vol.flash->download(vol.flash); /* download IPL */
  }
  return flOK;
}

/*-----------------------------------------------------------------------*/
/*            f l F o r m a t L o g i c a l D r i v e                    */
/*                                                                       */
/* Formats a logical drive, optionaly writing a new and empty            */
/* file-system and or a compressed format. All existing                  */
/* data is destroyed.                                                    */
/* Formatting leaves the volume in the dismounted state, so that a       */
/* flMountVolume call is necessary after it.                             */
/*                                                                       */
/* Parameters:                                                           */
/*      vol             : Pointer identifying drive                      */
/*      irHandle        : Drive number (0, 1, ...)                       */
/*      irData          : Address of BDTLPartitionFormatParams to use    */
/*                        (defined in flformat.h)                        */
/*                                                                       */
/* Returns:                                                              */
/*      FLStatus        : 0 on success, otherwise failed                 */
/*-----------------------------------------------------------------------*/

static FLStatus bdFormatLogicalDrive(Volume vol, IOreq FAR2 *ioreq)
{
   BDTLPartitionFormatParams FAR2 *userFp =
        (BDTLPartitionFormatParams FAR2 *) ioreq->irData;
   byte       volNo = (byte)(&vol-vols);
#ifdef COMPRESSION
   FLStatus   status;
#endif /* COMPRESSION */

   checkStatus(flMount(volNo,vol.tl.socketNo,&(vol.tl),FALSE,vol.flash));
   /*  assume sector 0 is DOS boot block */
   vol.bootSectorNo     = 0;
   /* Disable FAT monitoring */
   vol.firstFATSectorNo = vol.secondFATSectorNo = 0; 
   /* Enough to do abs operations */
   vol.flags |= VOLUME_ABS_MOUNTED;  

#ifdef COMPRESSION
   if(userFp->flags & TL_FORMAT_COMPRESSED)
   {
      status = flFormatZIP(volNo,&vol.tl,vol.flash);
      vol.tl.dismount(vol.tl.rec);
      if(status!=flOK)
        return status;
   }
#endif /* COMPRESSION */

   if(userFp->flags & TL_FORMAT_FAT) /* perform FAT format as well */
   {
      checkStatus(absMountVolume(&vol));
      checkStatus(flDosFormat(&vol.tl,userFp));
      checkStatus(dismountVolume(&vol));
   }
   return flOK;
}
#endif /* FORMAT_VOLUME */

#endif  /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                  s e c t o r s I n V o l u m e                       */
/*                                                                      */
/* Defines actual number of virtual sectors according to the low-level  */
/* format of the media.                                                 */
/*                                                                      */
/* Returns:                                                             */
/*      vol             : Pointer identifying drive                     */
/*      ioreq->irLength : Actual number of virtual sectors in volume    */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/
static FLStatus sectorsInVolume(Volume vol, IOreq FAR2 *ioreq)
{
  dword sectorsInVol = vol.tl.sectorsInVolume(vol.tl.rec);
  if(sectorsInVol<=vol.bootSectorNo) {
    ioreq->irLength = 0;
    return flGeneralFailure;
  }

  ioreq->irLength = sectorsInVol-vol.bootSectorNo;
  return flOK;
}


#ifdef ABS_READ_WRITE

/*----------------------------------------------------------------------*/
/*                           a b s R e a d                              */
/*                                                                      */
/* Reads absolute sectors by sector no.                                 */
/*                                                                      */
/* Note that if readSecots is not implemented irSectoCount will not     */
/* return the actual number of sectors written in case the operation    */
/* failed in the middle.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irHandle        : Drive number (0, 1, ...)                      */
/*      irData          : Address of user buffer to read into           */
/*      irSectorNo      : First sector no. to read (sector 0 is the     */
/*                        DOS boot sector).                             */
/*      irSectorCount   : Number of consectutive sectors to read        */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      irSectorCount   : Number of sectors actually read               */
/*----------------------------------------------------------------------*/

static FLStatus absRead(Volume vol, IOreq FAR2 *ioreq)
{
  char FAR1 *userBuffer = (char FAR1 *) ioreq->irData;
  SectorNo  currSector   = vol.bootSectorNo + ioreq->irSectorNo;
  void FAR0 *mappedSector;
  FLStatus  status;

  if (vol.tl.readSectors != NULL)
  {
     status = vol.tl.readSectors(vol.tl.rec , currSector,
              (byte FAR1* )ioreq->irData , ioreq->irSectorCount);

     if (status == flSectorNotFound)
     {
        /* Do not report unassigned sectors. Simply report all 0's */
        if(vol.tl.sectorsInVolume(vol.tl.rec) >=
           (currSector+ioreq->irSectorCount))
           return flOK;
     }
     return status;
  }
  else
  {
     SectorNo sectorCount  = (SectorNo)ioreq->irSectorCount;
     for (ioreq->irSectorCount = 0;
         (SectorNo)(ioreq->irSectorCount) < sectorCount;
          ioreq->irSectorCount++, currSector++, userBuffer += SECTOR_SIZE)
     {
#ifdef SCATTER_GATHER
        userBuffer = *((char FAR1 **)(ioreq->irData) + 
                    (int)(ioreq->irSectorCount));
#endif
        mappedSector = (void FAR0 *)findSector(&vol,currSector);
        if (mappedSector)
        {
           if(mappedSector==dataErrorToken)
             return flDataError;

           tffscpy(userBuffer,mappedSector,SECTOR_SIZE);
        }
        else
        {
           if(vol.tl.sectorsInVolume(vol.tl.rec)<=(currSector))
              return flSectorNotFound;
           tffsset(userBuffer,0,SECTOR_SIZE);
        }
     }
  }
  return flOK;
}


#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                    r e p l a c e F A T s e c t o r                   */
/*                                                                      */
/* Monitors sector deletions in the FAT.                                */
/*                                                                      */
/* When a FAT block is about to be written by an absolute write, this   */
/* routine will first scan whether any sectors are being logically      */
/* deleted by this FAT update, and if so, it will delete-sector them    */
/* before the actual FAT update takes place.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : FAT Sector no. about to be written            */
/*      newFATsector    : Address of FAT sector about to be written     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus replaceFATsector(Volume vol,
            SectorNo sectorNo,
            const char FAR1 *newFATsector)
{
  const char FAR0 *oldFATsector = (const char FAR0 *)findSector(&vol,sectorNo);
  SectorNo firstSector;
  unsigned firstCluster;
#ifdef FAT_12BIT
  word FAThalfBytes;
  word halfByteOffset;
#else
  word byteOffset;
#endif

  if((oldFATsector==NULL) || oldFATsector==dataErrorToken)
    return flOK;

#ifdef FAT_12BIT
  FAThalfBytes = vol.flags & VOLUME_12BIT_FAT ? 3 : 4;

  firstCluster = (FAThalfBytes == 3) ?
    (((unsigned) (sectorNo - vol.firstFATSectorNo) * (2 * SECTOR_SIZE) + 2) / 3) :
    ((unsigned) (sectorNo - vol.firstFATSectorNo) * (SECTOR_SIZE>>1));
  firstSector    = ((SectorNo) firstCluster - 2) * 
                   vol.sectorsPerCluster + vol.firstDataSectorNo;
  halfByteOffset = (firstCluster * FAThalfBytes) & ((SECTOR_SIZE<<1) - 1);

  /* Find if any clusters were logically deleted, and if so, delete them */
  /* NOTE: We are skipping over 12-bit FAT entries which span more than  */
  /*       one sector. Nobody's perfect anyway.                          */
  for (; halfByteOffset < ((SECTOR_SIZE<<1) - 2);
       firstSector += vol.sectorsPerCluster, 
       halfByteOffset += FAThalfBytes)
  {
    unsigned short oldFATentry, newFATentry;

#ifdef FL_BIG_ENDIAN
    oldFATentry = LE2(*(LEushort FAR0 *)(oldFATsector + (halfByteOffset>>1)));
    newFATentry = LE2(*(LEushort FAR1 *)(newFATsector + (halfByteOffset>>1)));
#else
    oldFATentry = UNAL2(*(Unaligned FAR0 *)(oldFATsector + (halfByteOffset / 2)));
    newFATentry = UNAL2(*(Unaligned FAR1 *)(newFATsector + (halfByteOffset / 2)));
#endif
    if (halfByteOffset & 1) {
      oldFATentry >>= 4;
      newFATentry >>= 4;
    }
    else if (FAThalfBytes == 3) {
      oldFATentry &= 0xfff;
      newFATentry &= 0xfff;
    }
#else
  firstCluster = ((unsigned) (sectorNo - vol.firstFATSectorNo) << (SECTOR_SIZE_BITS-1));
  firstSector = ((SectorNo) firstCluster - 2) * vol.sectorsPerCluster + 
	            vol.firstDataSectorNo;

  /* Find if any clusters were logically deleted, and if so, delete them */
  for (byteOffset = 0; byteOffset < SECTOR_SIZE;
       firstSector += vol.sectorsPerCluster, byteOffset += 2) {
    unsigned short oldFATentry = LE2(*(LEushort FAR0 *)(oldFATsector + byteOffset));
    unsigned short newFATentry = LE2(*(LEushort FAR1 *)(newFATsector + byteOffset));
#endif

    if (oldFATentry != FAT_FREE && newFATentry == FAT_FREE)
      checkStatus(vol.tl.deleteSector(vol.tl.rec,firstSector,vol.sectorsPerCluster));

    /* make sure sector is still there */
    oldFATsector = (const char FAR0 *) findSector(&vol,sectorNo);
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                         a b s W r i t e                              */
/*                                                                      */
/* Writes absolute sectors by sector no.                                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irHandle        : Drive number (0, 1, ...)                      */
/*      irData          : Address of user buffer to write from          */
/*      irSectorNo      : First sector no. to write (sector 0 is the    */
/*                        DOS boot sector).                             */
/*      irSectorCount   : Number of consectutive sectors to write       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      irSectorCount   : Number of sectors actually written            */
/*----------------------------------------------------------------------*/

static FLStatus absWrite(Volume vol, IOreq FAR2 *ioreq)
{
  char FAR1 *userBuffer = (char FAR1 *) ioreq->irData;
  SectorNo currSector = vol.bootSectorNo + ioreq->irSectorNo;
  SectorNo sectorCount = (SectorNo)ioreq->irSectorCount;

  if (currSector < vol.secondFATSectorNo &&
      currSector + sectorCount > vol.firstFATSectorNo) {
    SectorNo iSector;

    for (iSector = 0; iSector < sectorCount;
    iSector++, currSector++, userBuffer += SECTOR_SIZE) {

      if (currSector >= vol.firstFATSectorNo &&
      currSector < vol.secondFATSectorNo)
    replaceFATsector(&vol,currSector,userBuffer);
    }

    userBuffer = (char FAR1 *) ioreq->irData;
    currSector = (SectorNo)vol.bootSectorNo + (SectorNo)ioreq->irSectorNo;
  }
  if (vol.tl.writeMultiSector != NULL)
  {
      checkStatus(vol.tl.writeMultiSector(vol.tl.rec, currSector,
                  ioreq->irData,ioreq->irSectorCount));
  }
  else
  {
     for (ioreq->irSectorCount = 0;
          (SectorNo)(ioreq->irSectorCount) < sectorCount;
          ioreq->irSectorCount++, currSector++, userBuffer += SECTOR_SIZE)
     {
#if FILES>0
        if ((currSector == vol.volBuffer.sectorNo) &&
            (&vol == vol.volBuffer.owner))
        {
           vol.volBuffer.sectorNo = UNASSIGNED_SECTOR; /* no longer valid */
           vol.volBuffer.dirty = vol.volBuffer.checkPoint = FALSE;
        }
#endif

#ifdef SCATTER_GATHER
        userBuffer = *((char FAR1 **)(ioreq->irData)+(int)(ioreq->irSectorCount));
#endif
        checkStatus(vol.tl.writeSector(vol.tl.rec,currSector,userBuffer));
     }
  }
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                        a b s D e l e t e                             */
/*                                                                      */
/* Marks absolute sectors by sector no. as deleted.                     */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irHandle        : Drive number (0, 1, ...)                      */
/*      irSectorNo      : First sector no. to write (sector 0 is the    */
/*                        DOS boot sector).                             */
/*      irSectorCount   : Number of consectutive sectors to delete      */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus absDelete(Volume vol, IOreq FAR2 *ioreq)
{
  SectorNo first;
  first = (SectorNo)(vol.bootSectorNo + ioreq->irSectorNo);
  return vol.tl.deleteSector(vol.tl.rec,first,(SectorNo)ioreq->irSectorCount);
}

#endif /* FL_READ_ONLY */

#ifndef NO_PHYSICAL_IO
/*----------------------------------------------------------------------*/
/*                       f l A b s A d d r e s s                        */
/*                                                                      */
/* Returns the current physical media offset of an absolute sector by   */
/* sector no.                                                           */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irHandle        : Drive number (0, 1, ...)                      */
/*      irSectorNo      : Sector no. to address (sector 0 is the DOS    */
/*                        boot sector)                                  */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      irCount         : Offset of the sector on the physical media    */
/*----------------------------------------------------------------------*/

static FLStatus absAddress(Volume vol, IOreq FAR2 *ioreq)
{
  CardAddress cardOffset;
  const void FAR0 * sectorData =
    vol.tl.mapSector(vol.tl.rec,vol.bootSectorNo + ioreq->irSectorNo,&cardOffset);

  if (sectorData) {
    if(sectorData==dataErrorToken)
    return flDataError;

    ioreq->irCount = cardOffset;
    return flOK;
  }
  else
    return flSectorNotFound;
}

#endif /* NO_PHYSICAL_IO */

/*----------------------------------------------------------------------*/
/*                           g e t B P B                                */
/*                                                                      */
/* Reads the BIOS Parameter Block from the boot sector                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irHandle        : Drive number (0, 1, ...)                      */
/*      irData          : Address of user buffer to read BPB into       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus getBPB(Volume vol, IOreq FAR2 *ioreq)
{
  BPB FAR1 *userBPB = (BPB FAR1 *) ioreq->irData;
  DOSBootSector FAR0 *bootSector;

  bootSector = (DOSBootSector FAR0 *) findSector(&vol,vol.bootSectorNo);
  if(bootSector == NULL)
    return flSectorNotFound;
  if(bootSector==dataErrorToken)
    return flDataError;

  *userBPB = bootSector->bpb;
  return flOK;
}

#ifndef FL_READ_ONLY
#ifdef WRITE_PROTECTION
/*----------------------------------------------------------------------*/
/*              c h a n g e P a s s w o r d                             */
/*                                                                      */
/* Change password for write protectipon.                               */
/*                                                                      */
/* Parameters:                                                          */
/*  vol         : Pointer identifying drive                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus changePassword(Volume vol)
  {
  PartitionTable partitionTable;
  IOreq ioreq;
  FLStatus status;
#ifdef SCATTER_GATHER
  void FAR1 *iovec[1];
#endif

  ioreq.irHandle=(unsigned)(&vol-vols);
  ioreq.irSectorNo=0-(int)vol.bootSectorNo;
  ioreq.irSectorCount=1;
#ifdef SCATTER_GATHER
  iovec[0]     = (void FAR1 *) &partitionTable;
  ioreq.irData = (void FAR1 *) iovec;
#else
  ioreq.irData=&partitionTable;
#endif
    if((status=absRead(&vol,&ioreq))!=flOK)
     return status;
  toUNAL4(partitionTable.passwordInfo[0], 0);
  toUNAL4(partitionTable.passwordInfo[1],vol.password[0]);
  toUNAL4(partitionTable.passwordInfo[2],vol.password[1]);

  vol.flags &= ~VOLUME_WRITE_PROTECTED;

  return absWrite(&vol,&ioreq);
}

/*----------------------------------------------------------------------*/
/*              w r i t e P r o t e c t                                 */
/*                                                                      */
/* Put and remove write protection from the volume                      */
/*                                                                      */
/* Parameters:                                                          */
/*  vol      : Pointer identifying drive                                */
/*  irHandle : Drive number ( 0,1,2...  )                               */
/*  irFlags  : FL_PROTECT   = place protection                          */
/*             FL_UNPROTECT = remove protection                         */
/*             FL_UNLOCK    = remove protection until next dismount     */
/*  irData   : password (8 bytes)                                       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus writeProtect(Volume vol,IOreq FAR2*ioreq)
{
  FLStatus status=flWriteProtect;
  dword *flData=(dword *)ioreq->irData;
  dword passCode1 = flData[0] ^ SCRAMBLE_KEY_1;
  dword passCode2 = flData[1] ^ SCRAMBLE_KEY_2;

    switch (ioreq->irFlags) {

      case FL_UNLOCK:     /* unlock volume */
     if((vol.password[0] == passCode1 && vol.password[1] == passCode2)||
        (vol.password[0] == 0 && vol.password[1] == 0))
     {
         vol.flags &= ~VOLUME_WRITE_PROTECTED;
         status=flOK;
     }
     else
        status=flWriteProtect;
     break;

      case FL_UNPROTECT:     /* remove password */
     if(vol.password[0] == passCode1 && vol.password[1] == passCode2)
     {
        vol.password[0] = vol.password[1] = 0;
        status = changePassword(&vol);
     }
     else
        status=flWriteProtect;
     break;

      case FL_PROTECT: /* set password */
    if(vol.password[0] == 0 && vol.password[1] == 0)
       {
       vol.password[0] = passCode1;
       vol.password[1] = passCode2;
       status = changePassword(&vol);
       vol.flags|=VOLUME_WRITE_PROTECTED;
       }
    else
       status=flWriteProtect;
          break;

       default:
    status = flGeneralFailure;
      }
return status;
}
#endif  /* WRITE_PROTECTION */

#endif /* FL_READ_ONLY   */

#endif /* ABS_READ_WRITE */

/*----------------------------------------------------------------------*/
/*                   s o c k e t I n f o                */
/*                                                                      */
/* Get socket Information (window base address)          */
/*                                                                      */
/* Parameters:                                                          */
/*  vol         : Pointer identifying drive         */
/*  baseAddress : pointer to receive window base address   */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus socketInfo(Volume vol, dword FAR2 *baseAddress)
{
  *baseAddress = (long)(vol.socket->window.baseAddress) << 12;
  return flOK;
}

#ifdef FL_LOW_LEVEL

/*----------------------------------------------------------------------*/
/*                           g e t P h y s i c a l I n f o              */
/*                                                                      */
/* Get physical information of the media. The information includes      */
/* JEDEC ID, unit size and media size.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irData          : Address of user buffer to read physical       */
/*                        information into.                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*      irLength        : Physical base address of device               */
/*----------------------------------------------------------------------*/

static FLStatus getPhysicalInfo(Volume vol, IOreq FAR2 *ioreq)
{
  PhysicalInfo FAR2 *physicalInfo = (PhysicalInfo FAR2 *)ioreq->irData;

  physicalInfo->type = vol.flash->type;
  physicalInfo->unitSize = vol.flash->erasableBlockSize;
  physicalInfo->mediaSize = vol.flash->chipSize * vol.flash->noOfChips;
  physicalInfo->chipSize = vol.flash->chipSize;
  physicalInfo->interleaving = vol.flash->interleaving;
  switch(vol.flash->mediaType) {
    case NOT_DOC_TYPE:
    physicalInfo->mediaType = FL_NOT_DOC;
    break;
    case DOC_TYPE :
    physicalInfo->mediaType = FL_DOC;
    break;
    case MDOC_TYPE :
    physicalInfo->mediaType = FL_MDOC;
    break;
    case MDOCP_TYPE :
    physicalInfo->mediaType = FL_MDOCP;
    break;
    case DOC2000TSOP_TYPE :
    physicalInfo->mediaType = FL_DOC2000TSOP;
    break;
    case MDOCP_16_TYPE :
    physicalInfo->mediaType = FL_MDOCP_16;
    break;
  }
  socketInfo(&vol,(dword FAR2 *) &(ioreq->irLength));
  return flOK;
}

#ifndef NO_PHYSICAL_IO

/*----------------------------------------------------------------------*/
/*                           p h y s i c a l R e a d                    */
/*                                                                      */
/* Read from a physical address.                                        */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irAddress       : Physical address to read from.                */
/*      irByteCount     : Number of bytes to read.                      */
/*      irData          : Address of user buffer to read into.          */
/*      irFlags         : Mode of the operation.                        */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus physicalRead(Volume vol, IOreq FAR2 *ioreq)
{
  /* check that we are reading whithin the media boundaries */
  if (ioreq->irAddress + (long)ioreq->irByteCount > (long)vol.flash->chipSize *
                vol.flash->noOfChips)
    return flBadParameter;

  /* We don't read accross a unit boundary */
  if ((long)ioreq->irByteCount > (long)(vol.flash->erasableBlockSize -
           (ioreq->irAddress % vol.flash->erasableBlockSize)))
    return flBadParameter;

  checkStatus(vol.flash->read(vol.flash, ioreq->irAddress, ioreq->irData,
     (word)ioreq->irByteCount, (word)ioreq->irFlags));
  return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                           p h y s i c a l W r i t e                  */
/*                                                                      */
/* Write to a physical address.                                         */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irAddress       : Physical address to write to.                 */
/*      irByteCount     : Number of bytes to write.                     */
/*      irData          : Address of user buffer to write from.         */
/*      irFlags         : Mode of the operation.                        */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus physicalWrite(Volume vol, IOreq FAR2 *ioreq)
{
  /* check that we are writing whithin the media boundaries */
  if (ioreq->irAddress + (long)ioreq->irByteCount > (long)(vol.flash->chipSize *
      vol.flash->noOfChips))
    return flBadParameter;

  /* We don't write accross a unit boundary */
  if (ioreq->irByteCount > (long)(vol.flash->erasableBlockSize -
      (ioreq->irAddress % vol.flash->erasableBlockSize)))
    return flBadParameter;

  checkStatus(vol.flash->write(vol.flash, ioreq->irAddress, ioreq->irData,
      (dword)ioreq->irByteCount, (word)ioreq->irFlags));
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                           p h y s i c a l E r a s e                  */
/*                                                                      */
/* Erase physical units.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      irUnitNo        : First unit to erase.                          */
/*      irUnitCount     : Number of units to erase.                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus physicalErase(Volume vol, IOreq FAR2 *ioreq)
{
  if (ioreq->irUnitNo + (long)ioreq->irUnitCount > (long)
      (vol.flash->chipSize * vol.flash->noOfChips / vol.flash->erasableBlockSize))
    return flBadParameter;

  checkStatus(vol.flash->erase(vol.flash, (word)ioreq->irUnitNo, (word)ioreq->irUnitCount));
  return flOK;
}
#endif /* NO_PHYSICAL_IO */
#endif /* FL_READ_ONLY */


#ifndef NO_IPL_CODE
/*----------------------------------------------------------------------*/
/*                           r e a d I P L                              */
/*                                                                      */
/* Read IPL to user buffer.                                             */
/*                                                                      */
/* Note : Read length must be a multiplication of 512 bytes             */
/* Note : Causes DiskOnChip Millennium Plus to download (i,e protection */
/*        key will be removed from all partitions.                      */
/*                                                                      */
/* Parameters:                                                          */
/*  flash            : Pointer identifying flash medium of the volume   */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*  buf              : User buffer to read into                         */
/*  bufLen           : Size of user buffer                              */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus readIPL(FLFlash* flash, byte FAR1 * buf , dword bufLen)
{
   FLStatus status;
   dword    secondCopyOffset = 1024;

   if(bufLen & 512)
   {
      DEBUG_PRINT(("ERROR - Must read a multiplication of 512 bytes.\r\n"));
      return flBadLength;
   }

   switch (flash->mediaType)
   {
      case MDOCP_TYPE:     /* have a special place for the IPL */
      case MDOCP_16_TYPE:  
         if (flash->readIPL != NULL)
         {
            checkStatus(flash->readIPL(flash,buf,(word)bufLen));
            return flOK;
         }
         break;
      case MDOC_TYPE:
         if(bufLen != 512)
         {
            DEBUG_PRINT(("ERROR - DiskOnChip Millennium 8M has only 512 Bytes of XIP.\r\n"));
            return flBadLength;
         }
         secondCopyOffset = 512;

      case DOC2000TSOP_TYPE: /* Have a special place for the IPL */
         if(bufLen > 1024)
         {
            DEBUG_PRINT(("ERROR - DiskOnChip 2000 TSOP has only 1024 Bytes of XIP.\r\n"));
            return flBadLength;
         }
         if(flash->read != NULL)
         {
            status = flash->read(flash,0,buf,bufLen,EDC);
            if(status != flOK)
               return flash->read(flash,secondCopyOffset,buf,bufLen,EDC);
            return status;
         }
         break;
      default :
         if(bufLen != 512)
         {
            DEBUG_PRINT(("ERROR - DiskOnChip 2000 has only 512 Bytes of XIP.\r\n"));
            return flBadLength;
         }
         if(flash->win != NULL)
         {
            tffscpy(buf,(const void FAR1*)flash->win,bufLen);
         }
         break;
   }
   return flGeneralFailure;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                           w r i t e I P L                            */
/*                                                                      */
/* Write IPL to the proper media location                               */
/*                                                                      */
/* Parameters:                                                          */
/*  flash            : Pointer identifying flash medium of the volume   */
/*  irHandle         : Socket number ( 0,1,2...  )                      */
/*  buf              : User buffer containin data to write to the IPL   */
/*  bufLen           : Size of user buffer                              */
/*  flags            : FL_IPL_MODE_NORMAL : None Strong Arm mode        */
/*                     FL_IPL_DOWNLOAD    : Download new IPL when done  */
/*                     FL_IPL_MODE_SA     : Strong Arm mode             */
/*                     FL_IPL_MODE_XSCALE : X-Scale mode                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus writeIPL(FLFlash* flash, byte FAR1 * buf , dword bufLen , unsigned flags)
{
   switch (flash->mediaType)
   {
      case DOC2000TSOP_TYPE: /* Have a special place for the IPL */
      case MDOCP_TYPE      :
      case MDOCP_16_TYPE   :
         if (flash->writeIPL != NULL)
            return (flash->writeIPL(flash,buf,(word)bufLen,0,flags));
         DFORMAT_PRINT(("ERROR - MTD does not support write IPL (Please reconfigure MTD).\r\n"));
         break;
      case MDOC_TYPE:
         DFORMAT_PRINT(("ERROR - DiskOnChip Millennium does not support write IPL, use the /BDFK flag.\r\n"));
         break;
      default :
         DFORMAT_PRINT(("ERROR - DiskOnChip 2000 does not support a writiable IPL.\r\n"));
         break;
   }
   return flFeatureNotSupported;
}
#endif /* FL_READ_ONLY */
#endif /* NO_IPL_CODE */

#ifndef NO_INQUIRE_CAPABILITIES

/*----------------------------------------------------------------------*/
/*                  i n q u i r e C a p a b i l i t i e s               */
/*                                                                      */
/* Get the specific device S/W and H/W capabilities                     */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Record discribing the media                   */
/*                        4 LSB - Socket number                         */
/*      capability      : Enumarator representing the capability        */
/* Returns:                                                             */
/*      capability      : CAPABILITY_SUPPORTED if the capability is     */
/*                        supported                                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void inquireCapabilities(FLFlash* flash , FLCapability FAR2* capability)
{
   FLCapability inquiredCapability = *capability;

   *capability = CAPABILITY_NOT_SUPPORTED;

   switch (inquiredCapability)
   {
#ifdef HW_OTP
      case SUPPORT_UNERASABLE_BBT:
      case SUPPORT_OTP_AREA:
        if(flash->otpSize != NULL)
           *capability = CAPABILITY_SUPPORTED;
        break;
      case SUPPORT_CUSTOMER_ID:
      case SUPPORT_UNIQUE_ID:
        if(flash->getUniqueId != NULL)
           *capability = CAPABILITY_SUPPORTED;
        break;
#endif /* HW_OTP */
      case SUPPORT_MULTIPLE_BDTL_PARTITIONS:
      case SUPPORT_MULTIPLE_BINARY_PARTITIONS:
        if(flash->flags & INFTL_ENABLED)
           *capability = CAPABILITY_SUPPORTED;
        break;

#ifdef HW_PROTECTION
      case SUPPORT_HW_PROTECTION:
      case SUPPORT_HW_LOCK_KEY:
        if(flash->protectionKeyInsert != NULL)
           *capability = CAPABILITY_SUPPORTED;
        break;
#endif /* HW_PROTECTION */
      case SUPPORT_DEEP_POWER_DOWN_MODE:
        if(flash->enterDeepPowerDownMode != NULL)
           *capability = CAPABILITY_SUPPORTED;
    break;
      case SUPPORT_WRITE_IPL_ROUTINE:
    if((flash->mediaType == DOC2000TSOP_TYPE) ||
       (flash->mediaType == MDOC_TYPE))
       *capability = CAPABILITY_SUPPORTED;
    break;
      default:
    break;
   }
}
#endif /* NO_INQUIRE_CAPABILITIES */
#endif /* FL_LOW_LEVEL */

/*----------------------------------------------------------------------*/
/*                   f l B u i l d G e o m e t r y                      */
/*                                                                      */
/* Get C/H/S information of the disk according to number of sectors.    */
/*                                                                      */
/* Parameters:                                                          */
/*  capacity    : Number of Sectors in Volume                           */
/*  cylinders   : Pointer to Number of Cylinders                        */
/*  heads       : Pointer to Number of Heads                            */
/*  sectors     : Pointer to Number of Sectors per Track                */
/*  oldFormat   : True for one sector per culoster                      */
/*                                                                      */
/*----------------------------------------------------------------------*/

void NAMING_CONVENTION flBuildGeometry(dword capacity, dword FAR2 *cylinders,
         dword FAR2 *heads,dword FAR2 *sectors, FLBoolean oldFormat)
{
  dword temp;

  *cylinders = 1024;                 /* Set number of cylinders to max value */

  if (oldFormat == TRUE)
  {
    *sectors = 62L;                     /* Max out number of sectors per track */
    temp = (*cylinders) * (*sectors);   /* Compute divisor for heads           */
    (*heads) = capacity / temp;         /* Compute value for number of heads   */
    if (capacity % temp) {              /* If no remainder, done!              */
      (*heads)++;                       /* Else, increment number of heads     */
      temp = (*cylinders) * (*heads);   /* Compute divisor for sectors         */
      (*sectors) = capacity / temp;     /* Compute value for sectors per track */
      if (capacity % temp) {            /* If no remainder, done!              */
        (*sectors)++;                   /* Else, increment number of sectors   */
        temp = (*heads) * (*sectors);   /* Compute divisor for cylinders       */
        (*cylinders) = capacity / temp; /* Compute number of cylinders         */
      }
    }
  }
  else
  {
     *heads = 16L;                              /* Max out number of heads             */
     temp = (*cylinders) * (*heads);            /* Compute divisor for heads           */
     *sectors = capacity / temp;                /* Compute value for sectors per track */
     while (*sectors > 0x3f ){                  /* While number of sectors too big     */
       *heads *= 2;                             /* use one more head                   */
       temp = (*cylinders) * (*heads);          /* Recompute divisor for heads         */
       *sectors = capacity / temp;              /* Recompute sectors per track         */
     }
     if (capacity % temp) {                     /* If no remainder, done!              */
       (*sectors)++;                            /* Else, increment number of sectors   */
       temp = (*cylinders) * (*sectors);        /* Compute divisor for heads           */
       *heads = capacity / temp;                /* Compute value for heads             */
       if (capacity % temp) {                   /* If no remainder, done!              */
         (*heads)++;                            /* Else, increment number of heads     */
         temp = (*heads) * (*sectors);          /* Compute divisor for cylinders       */
         *cylinders = (dword)(capacity / temp); /* Compute number of cylinders         */
       }
     }
  }
}

/*----------------------------------------------------------------------*/
/*                   v o l u m e I n f o                                */
/*                                                                      */
/* Get general volume Information.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*  vol         : Pointer identifying drive                             */
/*  irHandle    : Drive number (0, 1, ...)                              */
/*  irData      : pointer to VolumeInfoRecord                           */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus volumeInfo(Volume vol, IOreq FAR2 *ioreq)
{
  VolumeInfoRecord FAR2 *info = (VolumeInfoRecord FAR2 *)(ioreq->irData);
#ifdef FL_LOW_LEVEL
  IOreq ioreq2;
  PhysicalInfo physicalInfo;
  char wasLowLevelMounted = 1;
#endif
  TLInfo tlInfo;
#ifdef FL_LOW_LEVEL
  dword eraseCyclesPerUnit;
#endif /* FL_LOW_LEVEL */

#ifdef FL_LOW_LEVEL
  ioreq2.irHandle = ioreq->irHandle;
  if (!(vol.flags & VOLUME_LOW_LVL_MOUNTED)) {
    checkStatus(mountLowLevel(&vol));
    wasLowLevelMounted = 0;
  }
  ioreq2.irData = &physicalInfo;
  checkStatus(getPhysicalInfo(&vol, &ioreq2));
  info->flashType = physicalInfo.type;
  info->physicalUnitSize = (unsigned short)physicalInfo.unitSize;
  info->physicalSize = physicalInfo.mediaSize;
  info->DOCType = physicalInfo.mediaType;
#endif /* FL_LOW_LEVEL */
  tffsset(info->driverVer,0,sizeof(info->driverVer));
  tffsset(info->OSAKVer,0,sizeof(info->OSAKVer));
  tffscpy(info->driverVer,driverVersion,
          TFFSMIN(sizeof(info->driverVer),sizeof(driverVersion)));
  tffscpy(info->OSAKVer,OSAKVersion,
          TFFSMIN(sizeof(info->OSAKVer),sizeof(OSAKVersion)));
  checkStatus(socketInfo(&vol, &(info->baseAddress)));
  checkStatus(vol.tl.getTLInfo(vol.tl.rec,&tlInfo));
  info->logicalSectors = tlInfo.sectorsInVolume;
  info->bootAreaSize = tlInfo.bootAreaSize;

#ifdef ABS_READ_WRITE
  flBuildGeometry( tlInfo.sectorsInVolume,
       (dword FAR2 *)&(info->cylinders),
       (dword FAR2 *)&(info->heads),
       (dword FAR2 *)&(info->sectors),FALSE);
#endif /* ABS_READ_WRITE */

#ifdef FL_LOW_LEVEL

  eraseCyclesPerUnit = vol.flash->maxEraseCycles;
  info->lifeTime = (char)(((tlInfo.eraseCycles /
       (eraseCyclesPerUnit * (physicalInfo.mediaSize / physicalInfo.unitSize)))
       % 10) + 1);
  if(!wasLowLevelMounted)
    dismountLowLevel(&vol);
#endif /* FL_LOW_LEVEL */
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                         b d C a l l                                  */
/*                                                                      */
/* Common entry-point to all file-system functions. Macros are          */
/* to call individual function, which are separately described below.   */
/*                                                                      */
/* Parameters:                                                          */
/*      function        : file-system function code (listed below)      */
/*      ioreq           : IOreq structure                               */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus NAMING_CONVENTION bdCall(FLFunctionNo functionNo, IOreq FAR2 *ioreq)
{
  Volume vol = NULL;
  FLStatus status;
  byte volNo;
#if defined(FILES) && FILES>0
  File *file;
#endif
  byte socket    = FL_GET_SOCKET_FROM_HANDLE(ioreq);
  byte partition = FL_GET_PARTITION_FROM_HANDLE(ioreq);
  byte curPartitionForEnvVars;

/***********************************************/
/***                                         ***/
/***    find the volume record to work on    ***/
/***                                         ***/
/***********************************************/

  if (initDone == FALSE)
    checkStatus(flInit());

/** ori - We are not taking mutex befre cheking fileTable */

/**************************************/
/* working with open files operations */
/**************************************/

#if defined(FILES) && FILES>0
  /* Verify file handle if applicable */
  if ((functionNo <  INDEX_OPENFILES_END) &&
      ((functionNo != FL_FIND_FILE)||(ioreq->irFlags & FIND_BY_HANDLE)))
  {
     if ((ioreq->irHandle < FILES) &&
     (fileTable[ioreq->irHandle].flags & FILE_IS_OPEN))
     {
        file = fileTable + ioreq->irHandle;
        pVol = file->fileVol;
        socket = vol.tl.socketNo;
        partition = vol.tl.partitionNo;
     }
     else
     {
        return flBadFileHandle;
     }
  }

#endif  /* FILES>0 */

  /* Set environment variable current partition. */
  curPartitionForEnvVars = partition;


/****************************************************/
/* None files operations are divided into 3 groups: */
/*  1. Uses the specific partition volume record.   */
/*  2. Must be called with partition number 0.      */
/*  3. Must use partition number 0 and ignore       */
/*     the given partition (binary operations).     */
/****************************************************/

  if (pVol == NULL)     /* irHandle is drive no. */
  {

     /* Handle sanity check */

     if ((socket    >= noOfSockets) ||
         (partition >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

     volNo = handleConversionTable[socket][partition];

     /* Some operation must not be checked ONLY for socket sanity */

     if((functionNo < INDEX_BINARY_END) &&     /* Group 3 */
        (functionNo > INDEX_BINARY_START))
     {
        volNo = socket;

        /* Binary partitions are numbered after BDTL partitions */
        curPartitionForEnvVars = (byte)(MAX_TL_PARTITIONS+partition);
     }

     /* The rest must be checked for socket and volume sanity */

     else
     {
        if (volNo == INVALID_VOLUME_NUMBER)    /* Group 1 + 2 */
          return flBadDriveHandle;

        /* Some operation must be called with partition 0 */

        if ((functionNo > INDEX_NEED_PARTITION_0_START) &&   /* Group 2 */
            (functionNo < INDEX_NEED_PARTITION_0_END))
        {
            if(partition != 0)
            {
               return flBadDriveHandle;
            }
            else /* Use general verify write environement variable */
            {
               curPartitionForEnvVars = (MAX_TL_PARTITIONS<<1)-1;
            }
        }
     }
     pVol = &vols[volNo];
  }

/********************************************************************/
/***                                                              ***/
/***   Volume record has been found. Now verify that the volume   ***/
/***   record is ready for the specific operation.                ***/
/***                                                              ***/
/********************************************************************/

  status = setBusy(&vol,FL_ON,curPartitionForEnvVars); /* Let everyone know we are here */

/*******************************/
/* Verify S/W write protection */
/*******************************/

#if defined(WRITE_PROTECTION)&& !defined(FL_READ_ONLY)
  if(vol.flags&VOLUME_WRITE_PROTECTED)
     if(
#if defined(FILES) && FILES>0
    ((functionNo > INDEX_WRITE_FILE_START) &&
     (functionNo < FL_LAST_FAT_FUNCTION))  ||
#endif /* FILES > 0 */
#ifdef FORMAT_VOLUME
    (functionNo==BD_FORMAT_VOLUME)         ||
    (functionNo==BD_FORMAT_PHYSICAL_DRIVE) ||
    (functionNo==BD_FORMAT_LOGICAL_DRIVE)  ||
#endif /* FORMAT_VOLUME */
#ifdef WRITE_EXB_IMAGE
    (functionNo==FL_PLACE_EXB)             ||
#endif /* WRITE_EXB_IMAGE */
    (functionNo==FL_DEFRAGMENT_VOLUME)     ||
#ifdef ABS_READ_WRITE
    (functionNo==FL_ABS_WRITE)             ||
    (functionNo==FL_ABS_DELETE)            ||
#endif /* ABS_READ_WRITE */
#ifdef FL_LOW_LEVEL
    (functionNo==FL_PHYSICAL_WRITE)        ||
    (functionNo==FL_PHYSICAL_ERASE)        ||
#endif /* FL_LOW_LEVEL */
#ifdef VERIFY_VOLUME
    (functionNo==FL_VERIFY_VOLUME)         ||
#endif /* VERIFY_VOLUME */
    0)
  {
     status = flWriteProtect;
     goto flCallExit;
  }

#endif /* WRITE_PROTECTION  && !FL_READ_ONLY */

/***********************************************/
/* Binary partition operations                 */
/* Low level mount and direct call the routine */
/***********************************************/

#ifdef BDK_ACCESS
  if ((functionNo > INDEX_BINARY_START) &&
      (functionNo < INDEX_BINARY_END  )    )
  {
#ifdef WRITE_EXB_IMAGE
     if ((functionNo != FL_BINARY_PROTECTION_INSERT_KEY) &&
         (functionNo != FL_BINARY_PROTECTION_REMOVE_KEY))
        vol.moduleNo = INVALID_MODULE_NO; /* Stop place EXB operation */
#endif
     /* Mount flash and call binary module to proccess request */

     if (!(pVol->flags & VOLUME_LOW_LVL_MOUNTED))
        status = mountLowLevel(&vol);
     if (status == flOK)
        status = bdkCall(functionNo,ioreq,pVol->flash);
     goto flCallExit;
  }
#endif /* BDK_ACCESS */

/***********************************/
/* None binary routine             */
/* Nag about mounting if necessary */
/***********************************/

  switch (functionNo) {
#if FILES > 0
    case FL_LAST_FAT_FUNCTION:
      status = flBadFunction;
      goto flCallExit;
#endif

/* Pre mount routine - Make sure the volume is low level disMounted */

    case FL_ABS_MOUNT:
    case FL_MOUNT_VOLUME:
#ifndef FL_READ_ONLY
#ifdef FORMAT_VOLUME
    case BD_FORMAT_VOLUME:
    case BD_FORMAT_LOGICAL_DRIVE:
#endif /* FORMAT_VOLUME */
#endif /* FL_READ_ONLY */
#ifdef FL_LOW_LEVEL
      if (vol.flags & VOLUME_LOW_LVL_MOUNTED)
         dismountLowLevel(&vol);  /* mutual exclusive mounting */
#endif /* FL_LOW_LEVEL */
      break;

/* Physical operation must have the device low level (MTD) mounted */

/* Do not need any special operation */

    case FL_UPDATE_SOCKET_PARAMS:
    case FL_COUNT_VOLUMES:
#if (defined(FORMAT_VOLUME) && !defined(FL_READ_ONLY))
    case FL_WRITE_BBT:
#endif
#ifdef HW_PROTECTION
    case FL_PROTECTION_GET_TYPE:
    case FL_PROTECTION_REMOVE_KEY:
    case FL_PROTECTION_INSERT_KEY:
#ifndef FL_READ_ONLY
    case FL_PROTECTION_SET_LOCK:
    case FL_PROTECTION_CHANGE_KEY:
    case FL_PROTECTION_CHANGE_TYPE:
#endif /* FL_READ_ONLY */
#endif /* HW_PROTECTION */
#ifdef QUICK_MOUNT_FEATURE
    case FL_CLEAR_QUICK_MOUNT_INFO:
#endif /* QUICK_MOUNT_FEATURE */ 
       break;

/* MTD must be mounted first */

#ifdef FL_LOW_LEVEL

/* Some physical operation must not be done while abs mounted */
    case FL_GET_PHYSICAL_INFO:
    case FL_PHYSICAL_READ:
#ifndef FL_READ_ONLY
    case FL_PHYSICAL_WRITE:
    case FL_PHYSICAL_ERASE:
#endif /* FL_READ_ONLY */
#ifndef BDK_ACCESS
#ifdef MULTI_DOC
#ifdef ENVIRONMENT_VARS
      if (flUseMultiDoc == FL_ON)
#endif
      {
         volNo = handleConversionTable[0][0];
         if ((volNo != INVALID_VOLUME_NUMBER) &&
             (pVol[volNo].flags & VOLUME_ABS_MOUNTED))
#else
      {
         if(vol.flags & VOLUME_ABS_MOUNTED)
#endif
         {
            status = flGeneralFailure;  /* mutual exclusive mounting */
            goto flCallExit;
         }
      }
#endif /* BDK_ACCESS */
#ifndef NO_INQUIRE_CAPABILITIES
    case FL_INQUIRE_CAPABILITIES:
#endif /* NO_INQUIRE_CAPABILITIES */
    case FL_DEEP_POWER_DOWN_MODE:
#ifdef HW_OTP
    case FL_OTP_SIZE:
    case FL_OTP_READ:
#ifndef FL_READ_ONLY
    case FL_OTP_WRITE:
#endif /* FL_READ_ONLY */
    case FL_UNIQUE_ID:
    case FL_CUSTOMER_ID:
#endif /* HW_OTP */
#ifndef NO_IPL_CODE
    case FL_READ_IPL:
#ifndef FL_READ_ONLY
    case FL_WRITE_IPL:
#endif /* FL_READ_ONLY */
#endif /* NO_IPL_CODE */
#ifndef FL_READ_ONLY
#ifdef WRITE_EXB_IMAGE
    case FL_PLACE_EXB:
#endif /* WRITE_EXB_IMAGE */
#ifdef FORMAT_VOLUME
    case BD_FORMAT_PHYSICAL_DRIVE:
#endif /* FORMAT_VOLUME */
#endif /* FL_READ_ONLY */

      if (!(vol.flags & VOLUME_LOW_LVL_MOUNTED))
      {
         status = mountLowLevel(&vol);  /* automatic low level mounting */
      }
      else
      {
         status = flOK;
#ifndef FIXED_MEDIA
         status = flMediaCheck(vol.socket);
         if (status == flDiskChange)
            status = mountLowLevel(&vol); /* card was changed, remount */
#endif /* FIXED_MEDIA */
      }
      if (status != flOK)
      {
         dismountLowLevel(&vol);
         goto flCallExit;
      }
      break;
#endif /* FL_LOW_LEVEL */

/* Check for abs mount */


	

	
	default:
      if (vol.flags & VOLUME_ABS_MOUNTED)
      {
#ifndef NT5PORT
         FLStatus status = flOK;
#else /*NT5PORT*/
         FLStatus istatus = flOK;
#endif /*NT5PORT*/

#ifndef FIXED_MEDIA
#ifndef NT5PORT
         status = flMediaCheck(vol.socket);
#else /*NT5PORT*/
         istatus = flMediaCheck(vol.socket);
#endif /*NT5PORT*/
#endif /*FIXED_MEDIA*/

#ifndef NT5PORT
         if (status != flOK)
#else /*NT5PORT*/
         if (istatus != flOK)
#endif /*NT5PORT*/
            dismountVolume(&vol);
      }
      if (!(vol.flags & VOLUME_ABS_MOUNTED)
#if defined(FILES) && FILES>0
          && (functionNo > FL_LAST_FAT_FUNCTION)
#endif
      )
      {
         status = flNotMounted;
         goto flCallExit;
      }

/* We know that the tl is abs mounted (except for files )
   now check for high level mounted                       */

      if (!( vol.flags  & VOLUME_MOUNTED        ) &&
           ( functionNo != FL_DISMOUNT_VOLUME   ) &&
           ( functionNo != FL_CHECK_VOLUME      ) &&
#ifndef FL_READ_ONLY
           ( functionNo != FL_DEFRAGMENT_VOLUME ) &&
#endif  /* FL_READ_ONLY */
#ifdef ABS_READ_WRITE
           ( functionNo != FL_ABS_READ          ) &&
           ( functionNo != FL_ABS_ADDRESS       ) &&
#ifndef FL_READ_ONLY
           ( functionNo != FL_ABS_WRITE         ) &&
           ( functionNo != FL_ABS_DELETE        ) &&
#endif  /* FL_READ_ONLY */
#endif /* ABS_READ_WRITE */
#if (defined(WRITE_PROTECTION) && !defined(FL_READ_ONLY))
           ( functionNo != FL_WRITE_PROTECTION  ) &&
#endif /* WRITE_PROTECTION */
#ifdef VERIFY_VOLUME
           ( functionNo != FL_VERIFY_VOLUME     ) &&
#endif /* VERIFY_VOLUME */
           ( functionNo != FL_READ_BBT          ) &&
           ( functionNo != FL_SECTORS_IN_VOLUME ) &&
           ( functionNo != FL_VOLUME_INFO       ))
      {
         status = flNotMounted;
         goto flCallExit;
      }
  }

/*****************************************************/
/***                                               ***/
/***   The Volume record is already initialized.   ***/
/***   Exceute the proper function.                ***/
/***                                               ***/
/*****************************************************/

  switch (functionNo) {

#if defined(FILES) && FILES > 0
#ifndef FL_READ_ONLY
    case FL_FLUSH_BUFFER:
      status = flushBuffer(&vol);
      break;
#endif /* FL_READ_ONLY  */
    case FL_OPEN_FILE:
      status = openFile(&vol,ioreq);
      break;

    case FL_CLOSE_FILE:
      status = closeFile(file);
      break;
#ifndef FL_READ_ONLY
#ifdef SPLIT_JOIN_FILE
    case FL_JOIN_FILE:
      status = joinFile(file, ioreq);
      break;

    case FL_SPLIT_FILE:
      status = splitFile(file, ioreq);
      break;
#endif
#endif  /* FL_READ_ONLY */
    case FL_READ_FILE:
      status = readFile(file,ioreq);
      break;
#ifndef FL_READ_ONLY
    case FL_WRITE_FILE:
      status = writeFile(file,ioreq);
      break;
#endif
    case FL_SEEK_FILE:
      status = seekFile(file,ioreq);
      break;

    case FL_FIND_FILE:
      status = findFile(&vol,file,ioreq);
      break;

    case FL_FIND_FIRST_FILE:
      status = findFirstFile(&vol,ioreq);
      break;

    case FL_FIND_NEXT_FILE:
      status = findNextFile(file,ioreq);
      break;

    case FL_GET_DISK_INFO:
      status = getDiskInfo(&vol,ioreq);
      break;
#ifndef FL_READ_ONLY
    case FL_DELETE_FILE:
      status = deleteFile(&vol,ioreq,FALSE);
      break;

#ifdef RENAME_FILE
    case FL_RENAME_FILE:
      status = renameFile(&vol,ioreq);
      break;
#endif

#ifdef SUB_DIRECTORY
    case FL_MAKE_DIR:
      status = makeDir(&vol,ioreq);
      break;

    case FL_REMOVE_DIR:
      status = deleteFile(&vol,ioreq,TRUE);
      break;
#endif
#endif /* FL_READ_ONLY */
#endif /* FILES > 0 */

    case FL_MOUNT_VOLUME:
      status = mountVolume(&vol,&(ioreq->irFlags));
      break;

    case FL_DISMOUNT_VOLUME:
      status = dismountVolume(&vol);
      break;

    case FL_CHECK_VOLUME:
      status = flOK;            /* If we got this far */
      break;

    case FL_UPDATE_SOCKET_PARAMS:
      status = updateSocketParameters(flSocketOf(ioreq->irHandle), ioreq->irData);
      break;

#ifndef NO_READ_BBT_CODE
    case FL_READ_BBT:
      if(vol.tl.readBBT != NULL)
      {
         status = vol.tl.readBBT(vol.tl.rec,(CardAddress FAR1 *)ioreq->irData,
                 &(ioreq->irLength),&(ioreq->irFlags));
      }
      else
      {
         status = flFeatureNotSupported;
      }
      break;
#endif /* NO_READ_BBT_CODE */

#ifndef FL_READ_ONLY
#ifdef DEFRAGMENT_VOLUME
    case FL_DEFRAGMENT_VOLUME:
      status = defragmentVolume(&vol,ioreq);
      break;
#endif /* DEFRAGMENT_VOLUME */

#if defined (FORMAT_VOLUME) && !defined(FL_READ_ONLY)
    case BD_FORMAT_VOLUME:
      status = bdFormatVolume(&vol,ioreq);
      break;

    case BD_FORMAT_PHYSICAL_DRIVE:
      status = bdFormatPhysicalDrive(&vol,ioreq);
      break;

    case BD_FORMAT_LOGICAL_DRIVE:
      status = bdFormatLogicalDrive(&vol,ioreq);
      break;

#endif /* FORMAT_VOLUME AND NOT FL_READ_ONLY */
#ifdef WRITE_EXB_IMAGE
    case FL_PLACE_EXB:
      status = placeExbByBuffer(&vol,(byte FAR1*)ioreq->irData,
           ioreq->irLength,(word)ioreq->irWindowBase ,(word)ioreq->irFlags);
      break;

#endif /* WRITE_EXB_IMAGE */
#endif  /* FL_READ_ONLY */

    case FL_SECTORS_IN_VOLUME:
      status = sectorsInVolume(&vol,ioreq);
      break;

    case FL_ABS_MOUNT:
      status = absMountVolume(&vol);
      break;

#ifdef ABS_READ_WRITE
    case FL_ABS_READ:
      status = absRead(&vol,ioreq);
      break;

#ifndef NO_PHYSICAL_IO
    case FL_ABS_ADDRESS:
      status = absAddress(&vol,ioreq);
      break;
#endif /* NO_PHYSICAL_IO */

#ifndef FL_READ_ONLY
    case FL_ABS_DELETE:
      status = absDelete(&vol,ioreq);
      break;

    case FL_ABS_WRITE:
      status = absWrite(&vol,ioreq);
      break;

#endif  /* FL_READ_ONLY */

    case FL_GET_BPB:
      status = getBPB(&vol,ioreq);
      break;

#ifndef FL_READ_ONLY
#if (defined(WRITE_PROTECTION) && !defined(FL_READ_ONLY))
    case FL_WRITE_PROTECTION :
     status = writeProtect(&vol,ioreq);
     break;

#endif /* WRITE_PROTECTION */
#endif /* FL_READ_ONLY     */
#endif /* ABS_READ_WRITE   */

#ifdef VERIFY_VOLUME
    case FL_VERIFY_VOLUME :
     if ((vol.tl.checkVolume != NULL) &&
         (ioreq->irData      == NULL) &&
         (ioreq->irLength    == 0   )   )
     {
        status = vol.tl.checkVolume(vol.tl.rec);
     }
     else
     {
        status = flFeatureNotSupported;
     }
     break;
#endif /* VERIFY_VOLUME */

#ifdef FL_LOW_LEVEL
    case FL_GET_PHYSICAL_INFO:
      status = getPhysicalInfo(&vol, ioreq);
      break;

#ifndef NO_PHYSICAL_IO
    case FL_PHYSICAL_READ:
      status = physicalRead(&vol, ioreq);
      break;

#ifndef FL_READ_ONLY
    case FL_PHYSICAL_WRITE:
      status = physicalWrite(&vol, ioreq);
      break;

    case FL_PHYSICAL_ERASE:
      status = physicalErase(&vol, ioreq);
      break;
#endif /* FL_READ_ONLY */
#endif /* NO_PHYSICAL_IO */

      /* direct calls to the MTD */
#ifdef HW_OTP
    case FL_OTP_SIZE:
      if (vol.flash->otpSize != NULL)
      {
        word tmp = (word)ioreq->irFlags;
        status = vol.flash->otpSize(vol.flash, (dword FAR2 *)(&ioreq->irCount ),
                                               (dword FAR2 *)(&ioreq->irLength),
                                               &tmp);
        ioreq->irFlags = (unsigned)tmp;
      }
      else
      {
        status = flFeatureNotSupported;
      }
      break;

    case FL_OTP_READ:
      if (vol.flash->readOTP != NULL)
      {
        status = vol.flash->readOTP(vol.flash, (word)ioreq->irCount,
                       ioreq->irData, (word)ioreq->irLength);
      }
      else
      {
        status = flFeatureNotSupported;
      }
      break;

#ifndef FL_READ_ONLY
    case FL_OTP_WRITE:
      if (vol.flash->writeOTP != NULL)
      {
         status = vol.flash->writeOTP(vol.flash,ioreq->irData,
                         (word)ioreq->irLength);
      }
      else
      {
         status = flFeatureNotSupported;
      }
      break;

#endif /* FL_READ_ONLY */

    case FL_UNIQUE_ID:
      if (vol.flash->getUniqueId !=NULL)
      {
         status = vol.flash->getUniqueId(vol.flash, ioreq->irData);
      }
      else
      {
        status = flFeatureNotSupported;
      }
      break;

    case FL_CUSTOMER_ID:
      if (vol.flash->getUniqueId !=NULL)
      {
        byte buf[UNIQUE_ID_LEN];
        status = vol.flash->getUniqueId (vol.flash, buf);
        tffscpy (ioreq->irData,buf,CUSTOMER_ID_LEN);
      }
      else
      {
        status = flFeatureNotSupported;
      }
      break;
#endif /* HW_OTP */

#ifndef NO_IPL_CODE
#ifndef FL_READ_ONLY
    case FL_WRITE_IPL:
      status = writeIPL(vol.flash,(byte FAR1*)ioreq->irData,ioreq->irLength,ioreq->irFlags);
      break;
#endif /* FL_READ_ONLY */
    case FL_READ_IPL:
      status = readIPL(vol.flash,(byte FAR1*)ioreq->irData,ioreq->irLength);
      break;
#endif /* NO_IPL_CODE */

    case FL_DEEP_POWER_DOWN_MODE:
      if (vol.flash->enterDeepPowerDownMode !=NULL)
      {
        vol.flash->enterDeepPowerDownMode(vol.flash,(word)ioreq->irFlags);
        status = flOK;
      }
      else
      {
        status = flFeatureNotSupported;
      }
      break;

#ifndef NO_INQUIRE_CAPABILITIES
    case FL_INQUIRE_CAPABILITIES:
      inquireCapabilities(vol.flash,(FLCapability FAR2 *)&(ioreq->irLength));
      break;
#endif /* NO_INQUIRE_CAPABILITIES */

#endif /* FL_LOW_LEVEL */

    case FL_VOLUME_INFO:
      status = volumeInfo(&vol, ioreq);
      break;

     /* Pre mount routines */
#if (defined(FORMAT_VOLUME) && !defined(FL_READ_ONLY))
    case FL_WRITE_BBT:
#ifndef NT5PORT
		checkStatus(dismountPhysicalDrive(socket));
#else /*NT5PORT*/
		status = dismountPhysicalDrive(socket);
	    if (status != flOK)
		  goto flCallExit;
#endif /*NT5PORT*/
#endif
    case FL_COUNT_VOLUMES:
#ifdef QUICK_MOUNT_FEATURE
    case FL_CLEAR_QUICK_MOUNT_INFO:
#endif /* QUICK_MOUNT_FEATURE */ 
#ifdef HW_PROTECTION
    case FL_PROTECTION_GET_TYPE:
    case FL_PROTECTION_REMOVE_KEY:
    case FL_PROTECTION_INSERT_KEY:
#ifndef FL_READ_ONLY
    case FL_PROTECTION_SET_LOCK:
    case FL_PROTECTION_CHANGE_KEY:
    case FL_PROTECTION_CHANGE_TYPE:
#endif /* FL_READ_ONLY */
#endif  /* HW_PROTECTION */
      status = flPreMount(functionNo , ioreq , vol.flash);
      break;
    default:
      status = flBadFunction;
  }

#if ((defined(FILES)) && (FILES > 0) && (!defined(FL_READ_ONLY)))
  if (vol.volBuffer.checkPoint)
  {
     FLStatus st = flushBuffer(&vol);
     if (status == flOK)
        status = st;
  }
#endif

/*********************************************/
/* Exit nicely - Release mutex of the socket */
/*********************************************/

flCallExit:
  if(status==flOK)
    status = setBusy(&vol,FL_OFF,curPartitionForEnvVars);
  else
    setBusy(&vol,FL_OFF,curPartitionForEnvVars); /* We're leaving */

  return status;
}

#if POLLING_INTERVAL != 0

/*----------------------------------------------------------------------*/
/*                 s o c k e t I n t e r v a l R o u t i n e            */
/*                                                                      */
/* Routine called by the interval timer to perform periodic socket      */
/* actions and handle the watch-dog timer.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/*----------------------------------------------------------------------*/

/* Routine called at time intervals to poll sockets */
static void socketIntervalRoutine(void)
{
  unsigned volNo;
  Volume vol = vols;

  flMsecCounter += POLLING_INTERVAL;

  for (volNo = 0; volNo < noOfSockets; volNo++, pVol++)
    if (flTakeMutex(&flMutex[volNo])) {
#ifdef FL_BACKGROUND
      if (vol.flags & VOLUME_ABS_MOUNTED)
    /* Allow background operation to proceed */
    vol.tl.tlSetBusy(vol.tl.rec,FL_OFF);
#endif
      flIntervalRoutine(vol.socket);
      flFreeMutex(&flMutex[volNo]);
    }
}

#endif /* POLLING_INTERVAL != 0 */

/*----------------------------------------------------------------------*/
/*                          f l I n i t                                 */
/*                                                                      */
/* Initializes the FLite system, sockets and timers.                    */
/*                                                                      */
/* Calling this function is optional. If it is not called,              */
/* initialization will be done automatically on the first FLite call.   */
/* This function is provided for those applications who want to         */
/* explicitly initialize the system and get an initialization status.   */
/*                                                                      */
/* Calling flInit after initialization was done has no effect.          */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus flInit(void)
{
  if (!initDone) {
    FLStatus status;
    unsigned volNo;
    Volume vol = vols;
    IOreq req;
#ifdef LOG_FILE
    FILE *out;

    out=FL_FOPEN("EDCerr.txt","w");
    FL_FPRINTF(out,"EDC error LOG\n");
    FL_FCLOSE(out);
#endif /* LOG_FILE */

 flInitGlobalVars();

#ifdef ENVIRONMENT_VARS

 /* Call users initialization routine for :
  *  flUse8Bit,flUseNFTLCache,flUseisRAM
  */
 flSetEnvVar();

 if(flUse8Bit==1)
 {
    tffscpy = flmemcpy;
    tffscmp = flmemcmp;
    tffsset = flmemset;
 }
 else
 {
    tffscpy = flcpy;
    tffsset = flset;
    tffscmp = flcmp;
 }

#endif /* ENVIRONMENT_VARS */

   /*
    * 1) Mark all the volumes as not used and free to be allocated.
    * 2) Clear passowrd in order to make it invald.
    */
   
    tffsset(vols,0,sizeof(vols));

    for (volNo = 0,pVol = vols; volNo < VOLUMES; volNo++,pVol++)
    {     
      /* The actual number of sockets is not yet known and will be retreaved by
       * flRegisterComponents routine by the socket componenets. For now supply
       * each of the possible sockets with its buffer and socket number.
       */
       if ( volNo < SOCKETS)
       {
          vol.socket = flSocketOf(volNo);
          vol.flash  = flFlashOf(volNo);
          tffsset(vol.socket,0,sizeof(FLSocket));          
          tffsset(vol.flash,0,sizeof(FLFlash));
          vol.socket->volNo = volNo;         
#ifdef WRITE_EXB_IMAGE
          vol.moduleNo = INVALID_MODULE_NO; /* Ready for exb write operation */
#endif
       }
       else
       {
           vol.flash = NULL;
       }
       vol.volExecInProgress = NULL;
    }

#if FILES > 0
    initFS();
#endif

    flSysfunInit();

#ifdef FL_BACKGROUND
    flCreateBackground();
#endif
    /* Initialize variales */
    for (noOfTLs = 0 ;noOfTLs < TLS;noOfTLs++)
    {
       tlTable[noOfTLs].mountRoutine     = NULL;
       tlTable[noOfTLs].preMountRoutine  = NULL;
       tlTable[noOfTLs].formatRoutine    = NULL;
    }
    initDone    = TRUE;
    noOfTLs     = 0;
    noOfDrives  = 0;
    noOfSockets = 0;
    noOfMTDs    = 0;

    checkStatus(flRegisterComponents());

#ifdef COMPRESSION
    checkStatus(flRegisterZIP());
#endif

#ifdef MULTI_DOC
#ifdef ENVIRONMENT_VARS
    if(flUseMultiDoc==FL_ON)
    {
      checkStatus(flRegisterMTL());
    }
#else
    checkStatus(flRegisterMTL());
#endif /* ENVIRONMENT_VARS */
#endif /* MULT_DOC */

#ifdef BDK_ACCESS
    bdkInit();
#endif

    checkStatus(flInitSockets());

#if POLLING_INTERVAL > 0
    checkStatus(flInstallTimer(socketIntervalRoutine,POLLING_INTERVAL));
#endif

  /*
   * Now that the number of actual sockets is known, create a mutex for
   * each of the systems sockets. Multi-doc uses only 1 mutex.
   */

#ifdef MULTI_DOC
   if ((noOfSockets)
#ifdef ENVIRONMENT_VARS
       &&(flUseMultiDoc == FL_ON)
#endif /* ENVIRONMENT_VARS */
      )
   {   /* All sockets use the same mutex */

      if (flCreateMutex(&flMutex[0]) != flOK)
         return flGeneralFailure;

      for (volNo = 0; volNo < noOfSockets ; volNo++)
      {
         vols[volNo].volExecInProgress = &flMutex[0];
      }
   }
   else
#endif /* MULTI_DOC */
   {   /* Each socket uses a diffren mutex */

      for (volNo = 0; volNo < noOfSockets ; volNo++)
      {
         if (flCreateMutex(&flMutex[volNo]) != flOK)
            return flGeneralFailure;
         vols[volNo].volExecInProgress   = &flMutex[volNo];
      }
   }

    /* Count the number of volumes on all the systems sockets and
     * initialize conversion table. The table is used to convert a socket
     * and a partition numbers to the correct volume index in the vols record.
     * Partition 0 of each of the sockets will recieve the volume record
     * indexed with the socket number in the vols array. The rest of the
     * volumes will be serialy allocated. New volume records can be allocated
     * By the format routine. The format and the write BBT routines clear all
     * volume records taken by the sockets except for the first.
     *
     * The partition and socket are passed to the TL module using 2 dedicated
     * fields in the TL record. Both those values are also initiaized.
     * All volumes on a specific socket will share the same mutex.
     */

    tffsset(handleConversionTable,INVALID_VOLUME_NUMBER, /* Clear table */
      sizeof(handleConversionTable));

    for (pVol = vols , noOfDrives = (unsigned)noOfSockets , req.irHandle = 0;
     req.irHandle < noOfSockets; req.irHandle++, pVol++)
    {
       /* Initialize partition 0 */

       handleConversionTable[req.irHandle][0] = (byte)req.irHandle;
       vol.tl.socketNo         = (byte)req.irHandle;
       vol.tl.partitionNo      = 0;
       vol.flags = VOLUME_ACCUPIED;

       /* The rest of the partitions are initialzed only if multi-doc
    * is not active since Multi-doc supports only the first volume
    * of each socket.
    */

       status =  flPreMount(FL_COUNT_VOLUMES , &req , vol.flash);
       if (status == flOK)
       {
          vol.volExecInProgress = &flMutex[req.irHandle];
          for(volNo = 1;(volNo < req.irFlags) && (noOfDrives < VOLUMES); volNo++,noOfDrives++)
          {
             handleConversionTable[req.irHandle][volNo] = (byte)noOfDrives;
             vols[noOfDrives].socket         = vol.socket;
             vols[noOfDrives].flash          = vol.flash;
             vols[noOfDrives].tl.socketNo    = (byte)req.irHandle;
             vols[noOfDrives].tl.partitionNo = (byte)volNo;
             vols[noOfDrives].volExecInProgress =
             vol.volExecInProgress;
             vol.flags = VOLUME_ACCUPIED;
          }
       }
    }
  }
  return flOK;
}

#ifdef EXIT

/*----------------------------------------------------------------------*/
/*                          f l E x i t                                 */
/*                                                                      */
/* If the application ever exits, flExit should be called before exit.  */
/* flExit flushes all buffers, closes all open files, powers down the   */
/* sockets and removes the interval timer.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/* Returns:                                                             */
/*      Nothing                                                         */
/*----------------------------------------------------------------------*/

void NAMING_CONVENTION flExit(void)
{
  unsigned volNo;
  Volume vol = vols;
  FLBoolean mutexTaken = FALSE;

  if(flInit==FALSE)
      return;

  /* Dismount the TL and MTD */

  for (volNo = 0; (volNo < VOLUMES); volNo++,pVol++)
  {
     if ((vol.flags & VOLUME_ACCUPIED) && (setBusy(&vol,FL_ON,vol.tl.partitionNo) == flOK))
     {
        dismountVolume(&vol);

#ifdef FL_LOW_LEVEL
        dismountLowLevel(&vol);
#endif
        setBusy(&vol,FL_OFF,vol.tl.partitionNo);
     }
  }

  /* Dismount SOCKET  */

  pVol = vols;
  for (volNo = 0; volNo < noOfSockets ; volNo++,pVol++)
  {
#ifdef MULTI_DOC
#ifdef ENVIRONMENT_VARS
      if (flUseMultiDoc == FL_ON)     /* multi-doc not active */
#endif /* ENVIRONMENT_VARS */
     if (volNo == 0)
#endif /* MULTI_DOC */
        mutexTaken = (setBusy(&vol,FL_ON,vol.tl.partitionNo) == flOK) ? TRUE:FALSE;

     if (mutexTaken == TRUE)
     {
        flFreeMutex(execInProgress);  /* free the mutex that was taken in setBusy(FL_ON) */
        /* delete mutex protecting FLite volume access */
        flDeleteMutex(execInProgress);
        mutexTaken = FALSE;
     }
     flExitSocket(vol.socket);
  }

#if POLLING_INTERVAL != 0
  flRemoveTimer();
#endif

#ifdef ALLOCTST
  out_data_sz();
#endif
  initDone           = FALSE;
  initGlobalVarsDone = FALSE;
  pVol = NULL;
}

#ifdef __BORLANDC__
#ifdef EXIT
#pragma exit flExit
#endif /* EXIT */
#include <dos.h>

static int cdecl flBreakExit(void)
{
  flExit();

  return 0;
}

static void setCBreak(void)
{
  ctrlbrk(flBreakExit);
}

#pragma startup setCBreak

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\docsys.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOCSYS.C_V  $
 * 
 *    Rev 1.16   Apr 15 2002 08:30:30   oris
 * Added support for USE_TFFS_COPY compilation flag. This flag is used by bios driver a Boot SDK in order to improove performance.
 * 
 *    Rev 1.15   Apr 15 2002 07:35:56   oris
 * Reorganized for final release.
 * 
 *    Rev 1.14   Jan 28 2002 21:24:10   oris
 * Removed static prefix to all runtime configurable memory access routines.
 * Replaced FLFlash argument with DiskOnChip memory base pointer.
 * Changed interface of write and set routines (those that handle more then 8/16 bits) so that instead of FLFlash record they receive the DiskOnChip memory window base pointer and offset (2 separated arguments). The previous implementation did not support address shifting properly.
 * Changed tffscpy and tffsset to flcpy and flset when flUse8bit equals 0.
 * Changed memWinowSize to memWindowSize
 * 
 *    Rev 1.13   Jan 17 2002 22:59:30   oris
 * Completely revised, to support runtime customization and all M-Systems
 * DiskOnChip devices.
 * 
 *    Rev 1.12   Sep 25 2001 15:35:02   oris
 * Restored to OSAK 4.3 implementation.
 * 
 */

/************************************************************************/
/*                                                                      */
/*      FAT-FTL Lite Software Development Kit                           */
/*      Copyright (C) M-Systems Ltd. 1995-2001                          */
/*                                                                      */
/************************************************************************/

#include "docsys.h" 

/*                                                                   
 * Uncomment the FL_INIT_MMU_PAGES definition for:
 *                                                                        
 * Initializes the first and last byte of the given buffer.               
 * When the user buffer resides on separated memory pages the read        
 * operation may cause a page fault. Some CPU's return from a page        
 * fault (after loading the new page) and reread the bytes that caused    
 * the page fault from the new loaded page. In order to prevent such a    
 * case the first and last bytes of the buffer are written.
 *                                                                        
 */

#define FL_INIT_MMU_PAGES

#ifndef FL_NO_USE_FUNC

/*********************************************************/
/*     Report DiskOnChip Memory size                     */
/*********************************************************/

/*---------------------------------------------------------------------- 
   f l D o c M e m W i n S i z e N o S h i f t

   This routine is called from MTD to quary the size of the DiskOnChip
   memory window for none shifted DiskOnChip.
------------------------------------------------------------------------*/

dword flDocMemWinSizeNoShift(void)
{
  return 0x2000;
}

/*---------------------------------------------------------------------- 
   f l D o c M e m W i n S i z e S i n g l e S h i f t

   This routine is called from MTD to quary the size of the DiskOnChip
   memory window for DiskOnChip connected with a single addres shift.
------------------------------------------------------------------------*/

dword flDocMemWinSizeSingleShift(void)
{
  return 0x4000;
}

/*---------------------------------------------------------------------- 
   f l D o c M e m W i n S i z e D o u b l e S h i f t

   This routine is called from MTD to quary the size of the DiskOnChip
   memory window for DiskOnChip connected with a double addres shift.
------------------------------------------------------------------------*/

dword flDocMemWinSizeDoubleShift(void)
{
  return 0x8000;
}

/*********************************************************/
/*     Write 16 bits to DiskOnChip memory window         */
/*********************************************************/

/*---------------------------------------------------------------------- 
   f l W r i t e 1 6 b i t D u m m y
                                                                         
   Dummy routine - write 16-bits to memory (does nothing).              
------------------------------------------------------------------------*/

void flWrite16bitDummy(volatile  byte FAR0 * win, word offset,Reg16bitType val)
{
  DEBUG_PRINT(("Wrong customization - 16bit write was used with no implemented.\r\n"));
}

/*---------------------------------------------------------------------- 
   f l W r i t e 1 6 b i t U s i n g 1 6 b i t s N o S h i f t
                                                                       
   Note : offset must be 16-bits aligned.

   Write 16-bit Using 16-bits operands with no address shifted.       
------------------------------------------------------------------------*/

void flWrite16bitUsing16bitsNoShift(volatile  byte FAR0 * win, word offset,Reg16bitType val)
{
  ((volatile word FAR0*)win)[offset>>1] = val;
}

/*---------------------------------------------------------------------- 
   f l W r i t e 1 6 b i t U s i n g 3 2 b i t s S i n g l e S h i f t  

   Note : offset must be 16-bits aligned.
                                                                         
   Write 16-bit Using 16-bits operands with a single address shifted.   
------------------------------------------------------------------------*/

void flWrite16bitUsing32bitsSingleShift(volatile  byte FAR0 * win, word offset,Reg16bitType val)
{
#ifdef FL_BIG_ENDIAN  
  ((volatile dword FAR0*)win)[offset>>1] = ((dword)val)<<16; 
#else
  ((volatile dword FAR0*)win)[offset>>1] = (dword)val; 
#endif /* FL_BIG_ENDIAN */
}

/*********************************************************/
/*     Read 16 bits from DiskOnChip memory window        */
/*********************************************************/

/*----------------------------------------------------------------------
   f l R e a d 1 6 b i t D u m m y                     
                                                                         
   Dummy routine - read 16-bits from memory (does nothing).              
------------------------------------------------------------------------*/

Reg16bitType flRead16bitDummy(volatile  byte FAR0 * win,word offset)
{
  DEBUG_PRINT(("Wrong customization - 16bit read was issued with no implementation.\r\n"));
  return 0;
}

/*----------------------------------------------------------------------
   f l R e a d 1 6 b i t U s i n g 1 6 b i t s N o S h i f t    

   Note : offset must be 16-bits aligned.

   Read 16-bit Using 16-bits operands with no address shifted.       
------------------------------------------------------------------------*/

Reg16bitType flRead16bitUsing16bitsNoShift(volatile  byte FAR0 * win,word offset)
{
  return ((volatile word FAR0*)win)[offset>>1];
}

/*----------------------------------------------------------------------
   f l R e a d 1 6 b i t U s i n g 3 2 b i t s S i n g l e S h i f t    

   Note : offset must be 16-bits aligned.

   Read 16-bit Using 16-bits operands with single address shifted.
------------------------------------------------------------------------*/

Reg16bitType flRead16bitUsing32bitsSingleShift(volatile  byte FAR0 * win,word offset)
{
#ifdef FL_BIG_ENDIAN
  return  (Reg16bitType)(((volatile dword FAR0*)win)[offset>>1]<<16);
#else
  return  (Reg16bitType)((volatile dword FAR0*)win)[offset>>1];     
#endif /* FL_BIG_ENDIAN */
}

/*********************************************************/
/*     Write 8 bits to DiskOnChip memory window          */
/*********************************************************/

/*----------------------------------------------------------------------
   f l W r i t e 8 b i t U s i n g 8 b i t s N o S h i f t
                                                                       
   Write 8-bits Using 8-bits operands with no address shifted.       
------------------------------------------------------------------------*/

void flWrite8bitUsing8bitsNoShift(volatile byte FAR0 * win, word offset,Reg8bitType val)
{
  win[offset] = val;
}

/*----------------------------------------------------------------------
   f l W r i t e 8 b i t U s i n g 16 b i t s N o S h i f t

   Note : DiskOnChip is connected with 16-bit data bus.
   Note : Data is written only to lower memory addresses.
                                                                       
   Write 8-bits Using 16-bits operands with no address shifted.       
------------------------------------------------------------------------*/

void flWrite8bitUsing16bitsNoShift(volatile  byte FAR0 * win, word offset,Reg8bitType val)
{
#ifdef FL_BIG_ENDIAN
  ((volatile word FAR0 *)win)[offset>>1] = ((word)val)<<8;
#else
  ((volatile word FAR0 *)win)[offset>>1] = (word)val;
#endif /* FL_BIG_ENDIAN */
}

/*----------------------------------------------------------------------
   f l W r i t e 8 b i t U s i n g 16 b i t s S i n g l e S h i f t

   Note : Data is written only to 8-LSB.

   Write 8-bits Using 16-bits operands with Single address shifted.       
------------------------------------------------------------------------*/

void flWrite8bitUsing16bitsSingleShift(volatile  byte FAR0 * win, word offset,Reg8bitType val)
{
  ((volatile word FAR0 *)win)[offset] = (word)val;
}

/*----------------------------------------------------------------------
   f l W r i t e 8 b i t U s i n g 32 b i t s S i n g l e S h i f t

   Note : DiskOnChip is connected with 16-bit data bus.
   Note : Data is written to both data bus 8-bits
                                                                       
   Write 8-bits Using 32-bits operands with single address shifted.
------------------------------------------------------------------------*/

void flWrite8bitUsing32bitsSingleShift(volatile  byte FAR0 * win, word offset,Reg8bitType val)
{
#ifdef FL_BIG_ENDIAN
  ((volatile dword FAR0 *)win)[offset>>1] = (dword)val*0x01010101L;
#else
  ((volatile dword FAR0 *)win)[offset>>1] = (dword)val;
#endif /* FL_BIG_ENDIAN */
}

/*----------------------------------------------------------------------
   f l W r i t e 8 b i t U s i n g 32 b i t s D o u b l e S h i f t

   Note : Data is written only to 8-LSB.  

   Write 8-bits Using 32-bits operands with Double address shifted.
------------------------------------------------------------------------*/

void flWrite8bitUsing32bitsDoubleShift(volatile  byte FAR0 * win, word offset,Reg8bitType val)
{
  ((volatile dword FAR0 *)win)[offset] = (dword)val;
}

/*********************************************************/
/*     Read 8 bits to DiskOnChip memory window           */
/*********************************************************/

/*----------------------------------------------------------------------
   f l R e a d 8 b i t U s i n g 8 b i t s N o S h i f t
                                                                       
   Read 8-bits Using 8-bits operands with no address shifted.       
------------------------------------------------------------------------*/

Reg8bitType flRead8bitUsing8bitsNoShift(volatile  byte FAR0 * win,word offset)
{
  return win[offset];
}

/*----------------------------------------------------------------------
   f l R e a d 8 b i t U s i n g 16 b i t s N o S h i f t
  
   Note : DiskOnChip is connected with 16-bit data bus.

   Read 8-bits Using 16-bits operands with no address shifted.       
------------------------------------------------------------------------*/

Reg8bitType flRead8bitUsing16bitsNoShift(volatile  byte FAR0 * win,word offset)
{
#ifdef FL_BIG_ENDIAN
   return (((offset & 0x1) == 0) ?
#else
   return (( offset & 0x1      ) ?
#endif /* FL_BIG_ENDIAN */
           (Reg8bitType)(((volatile word FAR0 *)win)[offset>>1]>>8) :
           (Reg8bitType) ((volatile word FAR0 *)win)[offset>>1]    );
}

/*----------------------------------------------------------------------
   f l R e a d 8 b i t U s i n g 16 b i t s S i n g l e S h i f t

   Note : Assume data is found in 8-LSB of DiskOnChip

   Read 8-bits Using 16-bits operands with Single address shifted.       
------------------------------------------------------------------------*/

Reg8bitType flRead8bitUsing16bitsSingleShift(volatile  byte FAR0 * win,word offset)
{
   return (Reg8bitType)((volatile word FAR0 *)win)[offset];  
}

/*----------------------------------------------------------------------
   f l R e a d 8 b i t U s i n g 32 b i t s S i n g l e S h i f t

   Note : DiskOnChip is connected with 16-bit data bus.

   Read 8-bits Using 16-bits operands with Single address shifted.       
------------------------------------------------------------------------*/

Reg8bitType flRead8bitUsing32bitsSingleShift(volatile  byte FAR0 * win,word offset)
{
#ifdef FL_BIG_ENDIAN
   return (((offset & 0x1) == 0) ?
#else
   return (( offset & 0x1      ) ?
#endif /* FL_BIG_ENDIAN */
           (Reg8bitType)(((volatile dword FAR0 *)win)[offset>>1]>>24) :
           (Reg8bitType) ((volatile dword FAR0 *)win)[offset>>1]    );
}

/*----------------------------------------------------------------------
   f l R e a d 8 b i t U s i n g 32 b i t s D o u b l e S h i f t

   Note : Assume data is found in 8-LSB of DiskOnChip

   Read 8-bits Using 16-bits operands with Single address shifted.       
------------------------------------------------------------------------*/

Reg8bitType flRead8bitUsing32bitsDoubleShift(volatile  byte FAR0 * win,word offset)
{
   return (Reg8bitType)((volatile dword FAR0 *)win)[offset];  
}

/*********************************************************/
/*********************************************************/
/***    Operation on several bytes (read/write/set)    ***/
/*********************************************************/
/*********************************************************/

/*************************************************/
/*         8-Bit DiskOnChip - No Shift           */
/*************************************************/

/*----------------------------------------------------------------------
   f l 8 b i t D o c R e a d N o S h i f t

   Read 'count' bytes, from a none shifted address bus using tffscpy.
------------------------------------------------------------------------*/

void fl8bitDocReadNoShift(volatile  byte FAR0 * win,word offset,byte FAR1* dest,word count)
{
#ifdef FL_INIT_MMU_PAGES 
  if (count == 0)
     return;

  *dest = (byte)0;
  *((byte FAR1*)addToFarPointer(dest, (count - 1)) ) = (byte)0;
#endif /* FL_INIT_MMU_PAGES */

  tffscpy(dest,(void FAR0*)(win+offset),count);
}

/*----------------------------------------------------------------------
   f l 8 b i t D o c W r i t e N o S h i f t
 
   Write 'count' bytes, from a none shifted address bus using tffscpy.
------------------------------------------------------------------------*/

void fl8bitDocWriteNoShift(volatile  byte FAR0 * win,word offset,byte FAR1* src,word count)
{
  tffscpy((void FAR0*)( win+offset),src,count);
}

/*----------------------------------------------------------------------
   f l 8 b i t D o c S e t N o S h i f t
 
   Set 'count' bytes, from a none shifted address bus using tffsset.
------------------------------------------------------------------------*/

void fl8bitDocSetNoShift(volatile  byte FAR0 * win,word offset,word count, byte val)
{
  tffsset((void FAR0*)( win+offset),val,count);
}

/*************************************************/
/*        8-Bit DiskOnChip - Single Shift        */
/*************************************************/

/*----------------------------------------------------------------------
   f l 8 b i t D o c R e a d S i n g l e S h i f t
 
   Note : Assume data is found in 8-LSB of DiskOnChip

   Read 'count' bytes, from data bus's LSB lane with 1 address shifted
------------------------------------------------------------------------*/

void fl8bitDocReadSingleShift(volatile  byte FAR0 * win,word offset,byte FAR1* dest,word count)
{
  volatile word FAR0 * doc = (volatile word FAR0 *) win + offset;
  register int         i;

#ifdef FL_INIT_MMU_PAGES 
  if (count == 0)
     return;

  *dest = (byte)0;
  *((byte FAR1*)addToFarPointer(dest, (count - 1)) ) = (byte)0;
#endif /* FL_INIT_MMU_PAGES */

  for(i=0;( i < count );i++)
    dest[i] = (Reg8bitType)doc[i];
}

/*----------------------------------------------------------------------
   f l 8 b i t D o c W r i t e S i n g l e S h i f t
 
   Note : Assume data is found in 8-LSB of DiskOnChip

   Write 'count' bytes, to data bus's LSB lane with 1 address shifted.
------------------------------------------------------------------------*/

void fl8bitDocWriteSingleShift(volatile  byte FAR0 * win,word offset,byte FAR1* src,word count)
{
  volatile word FAR0 * doc = (volatile word FAR0 *) win + offset;
  register int  i;

  for(i=0;( i < count );i++)
    doc[i] = (word)src[i];    
}

/*----------------------------------------------------------------------
   f l 8 b i t D o c S e t S i n g l e S h i f t

   Note : Assume data is found in 8-LSB of DiskOnChip  

   Set 'count' bytes, of data bus's LSB lane with 1 address shifted.
------------------------------------------------------------------------*/

void fl8bitDocSetSingleShift(volatile  byte FAR0 * win,word offset,word count, byte val)
{
  volatile word FAR0 * doc = (volatile word FAR0 *) win + offset;
  register int  i;

  for(i=0;( i < count );i++)
    doc[i] = (word)val;
}

/*************************************************/
/*        8-Bit DiskOnChip - Double Shift        */
/*************************************************/

/*----------------------------------------------------------------------
   f l 8 b i t D o c R e a d D o u b l e S h i f t

   Note : Assume data is found in 8-LSB of DiskOnChip    

   Read 'count' bytes, from data bus's LSB lane with 2 address shifted.
------------------------------------------------------------------------*/

void fl8bitDocReadDoubleShift(volatile  byte FAR0 * win,word offset,byte FAR1* dest,word count)
{
  volatile dword FAR0 * doc = (volatile dword FAR0 *) win + offset;
  register int         i;

#ifdef FL_INIT_MMU_PAGES 
  if (count == 0)
     return;

  *dest = (byte)0;
  *((byte FAR1*)addToFarPointer(dest, (count - 1)) ) = (byte)0;
#endif /* FL_INIT_MMU_PAGES */

  for(i=0;( i < count );i++)
    dest[i] = (Reg8bitType)doc[i];
}

/*----------------------------------------------------------------------
   f l 8 b i t D o c W r i t e D o u b l e S h i f t
 
   Note : Assume data is found in 8-LSB of DiskOnChip    

   Write 'count' bytes, to data bus's LSB lane with 2 address shifted.
------------------------------------------------------------------------*/

void fl8bitDocWriteDoubleShift(volatile  byte FAR0 * win,word offset,byte FAR1* src,word count)
{
  volatile dword FAR0 * doc = (volatile dword FAR0 *) win + offset;
  register int         i;

  for(i=0;( i < count );i++)
    doc[i] = (dword)src[i];
}

/*----------------------------------------------------------------------
   f l 8 b i t D o c S e t D o u b l e S h i f t
 
   Note : Assume data is found in 8-LSB of DiskOnChip    

   Set 'count' bytes, of data bus's LSB lane with 2 address shifted.
------------------------------------------------------------------------*/

void fl8bitDocSetDoubleShift(volatile  byte FAR0 * win,word offset,word count, byte val)
{
  volatile dword FAR0 * doc = (volatile dword FAR0 *) win+offset;
  register int         i;

  for(i=0;( i < count );i++)
    doc[i] = (dword)val;
}

/*************************************************/
/*        16-Bit DiskOnChip - No Shift           */
/*************************************************/

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c R e a d N o S h i f t
 
   Read 'count' bytes from M+ DiskOnChip with none shifted address bus.
------------------------------------------------------------------------*/

void fl16bitDocReadNoShift (volatile  byte FAR0 * win, word offset, byte FAR1 * dest, word count )
{
   volatile word FAR0 * swin = (volatile word FAR0 *)( win + offset);
   register int         i;
   register word        tmp;

#ifdef FL_INIT_MMU_PAGES 
  if (count == 0)
     return;

  *dest = (byte)0;
  *((byte FAR1*)addToFarPointer(dest, (count - 1)) ) = (byte)0;
#endif /* FL_INIT_MMU_PAGES */

   if( pointerToPhysical(dest) & 0x1 )
   {
      /* rare case: unaligned target buffer */
      for (i = 0; i < (int)count; )
      {
         tmp = *swin;
#ifdef FL_BIG_ENDIAN
         dest[i++] = (byte)(tmp>>8);
         dest[i++] = (byte)tmp;
#else
         dest[i++] = (byte)tmp;
         dest[i++] = (byte)(tmp>>8);
#endif /* FL_BIG_ENDIAN */
      }
   }
   else
   {   /* mainstream case */
#ifdef USE_TFFS_COPY
      tffscpy( dest, (void FAR0 *)( win + offset), count );
#else
#ifdef ENVIRONMENT_VARS
      if (flUse8Bit == 0)
      {
         flcpy( dest, (void FAR0 *)( win + offset), count );
      }
      else
#endif /* ENVIRONMENT_VARS */
      {   /* read in short words */
         for (i = 0, count = count >> 1; i < (int)count; i++)
            ((word FAR1 *)dest)[i] = swin[i];
      }
#endif /* USE_TFFS_COPY */
   }
}

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c W r i t e N o S h i f t
 
   Write 'count' bytes to M+ DiskOnChip with none shifted address bus.
------------------------------------------------------------------------*/

void fl16bitDocWriteNoShift ( volatile  byte FAR0 * win , word offset ,
                             byte FAR1 * src, word count )
{
   volatile word FAR0 * swin = (volatile word FAR0 *)( win + offset);
   register int         i;
   register word        tmp;

   if( pointerToPhysical(src) & 0x1 ) /* rare case: unaligned source buffer */
   {       
       for (i = 0; i < (int)count; i+=2)
       {
          /* tmp variable is just a precation from compiler optimizations */
#ifdef FL_BIG_ENDAIN
          tmp = ((word)src[i]<<8) + (word)src[i+1];
#else
          tmp = (word)src[i] + ((word)src[i+1]<<8);
#endif /* FL_BIG_ENDAIN */
          *swin = tmp;
		 }
   }
   else /* mainstream case */
   {
#ifdef USE_TFFS_COPY
      tffscpy( (void FAR0 *)(win + offset), src, count );
#else
#ifdef ENVIRONMENT_VARS
      if (flUse8Bit == 0)
      {
         flcpy( (void FAR0 *)(win + offset), src, count );
      }
      else
#endif /* ENVIRONMENT_VARS */
      {   /* write in short words */
         for (i = 0, count = count >> 1; i < (int)count; i++)
           *swin = ((word FAR1 *)src)[i];
      }
#endif /* USE_TFFS_COPY */
   }
}

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c S e t N o S h i f t
 
   Set 'count' bytes of M+ DiskOnChip with none shifted address bus
------------------------------------------------------------------------*/

void fl16bitDocSetNoShift ( volatile  byte FAR0 * win , word offset ,
                                  word count , byte val)
{
   volatile word FAR0 * swin = (volatile word FAR0 *)( win + offset);
   register int         i;
   word                 tmpVal = (word)val * 0x0101;

#ifdef USE_TFFS_COPY
   tffsset( (void FAR0 *)(win + offset), val, count );
#else
#ifdef ENVIRONMENT_VARS
   if (flUse8Bit == 0)
   {
       flset( (void FAR0 *)(win + offset), val, count );
   }
   else
#endif /* ENVIRONMENT_VARS */
   {   /* write in short words */
      for (i = 0; i < (int)count; i+=2)
         *swin = tmpVal;
   }
#endif /* USE_TFFS_COPY */

}

/*************************************************************/
/*    16-Bit DiskOnChip - No Shift - Only 8 bits are valid   */
/*************************************************************/

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c R e a d N o S h i f t I g n o r e H i g h e r 8 B i t s

   Note : offset must be 16-bits aligned.
  
   Read 'count' bytes from M+ DiskOnChip connected with all 16 data bits, but
   in interleave-1 mode , therefore only one of the 8 bits contains actual data.
   The DiskOnChip is connected without an address shift.
------------------------------------------------------------------------*/

void fl16bitDocReadNoShiftIgnoreHigher8bits(volatile  byte FAR0 * win, word offset, byte FAR1 * dest, word count )
{
   volatile word FAR0 * swin = (volatile word FAR0 *)( win + offset);
   register int         i;

#ifdef FL_INIT_MMU_PAGES 
  if (count == 0)
     return;

  *dest = (byte)0;
  *((byte FAR1*)addToFarPointer(dest, (count - 1)) ) = (byte)0;
#endif /* FL_INIT_MMU_PAGES */

   for (i = 0; i < (int)count; i++)
   {
#ifdef FL_BIG_ENDIAN
      dest[i] = (byte)(swin[i]>>8);
#else
      dest[i] = (byte)swin[i];
#endif /* FL_BIG_ENDIAN */
   }
}

/*----------------------------------------------------------------------
   f l 1 6 D o c W r i t e N o S h i f t I g n o r e H i g h e r 8 b i t s

   Note : offset must be 16-bits aligned.

   Write 'count' bytes to M+ DiskOnChip connected with all 16 data bits, but
   in interleave-1 mode , therefore only one of the 8bits contains actual data.
   The DiskOnChip is connected without an address shift.
------------------------------------------------------------------------*/

void fl16bitDocWriteNoShiftIgnoreHigher8bits ( volatile  byte FAR0 * win , word offset ,
                             byte FAR1 * src, word count )
{
   volatile word FAR0 * swin = (volatile word FAR0 *)( win + offset);
   register int         i;

   for (i = 0; i < (int)count; i++)
   {
#ifdef FL_BIG_ENDIAN
      *swin  = ((word)src[i])<<8;
#else
      *swin  = (word)src[i];
#endif /* FL_BIG_ENDIAN */
   }
}

/*----------------------------------------------------------------------
   f l 1 6 D o c S e t N o S h i f t I g n o r e H i g h e r 8 b i t s

   Note : offset must be 16-bits aligned.

   Set 'count' bytes to M+ DiskOnChip connected with all 16 data bits, but
   in interleave-1 mode , therefore only one of the 8bits contains actual data.
   The DiskOnChip is connected without an address shift.
------------------------------------------------------------------------*/

void fl16bitDocSetNoShiftIgnoreHigher8bits ( volatile  byte FAR0 * win , word offset ,
                                  word count , byte val)
{
   volatile word FAR0 * swin = (volatile word FAR0 *)( win + offset);
   register int         i;
   word                 tmpVal = val * 0x0101;

   for (i = 0; i < (int)count; i++)
      *swin = tmpVal;
}

/****************************************/
/*   16-Bit DiskOnChip - Single Shift   */
/****************************************/

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c R e a d S i n g l e S h i f t
 
   Read 'count' bytes from M+ DiskOnChip with none shifted address bus.
------------------------------------------------------------------------*/

void fl16bitDocReadSingleShift (volatile  byte FAR0 * win, word offset, byte FAR1 * dest, word count )
{
   volatile dword FAR0 * swin = (volatile dword FAR0 *)win + (offset>>1);
   register int         i;
   register dword       tmp;

#ifdef FL_INIT_MMU_PAGES 
  if (count == 0)
     return;

  *dest = (byte)0;
  *((byte FAR1*)addToFarPointer(dest, (count - 1)) ) = (byte)0;
#endif /* FL_INIT_MMU_PAGES */

   if( pointerToPhysical(dest) & 0x1 )
   {
      /* rare case: unaligned target buffer */
      for (i = 0; i < (int)count; )
      {
         tmp = *swin;
#ifdef FL_BIG_ENDAIN
         dest[i++] = (byte)(tmp>>24);
         dest[i++] = (byte)(tmp>>16);
#else
         dest[i++] = (byte)tmp;
         dest[i++] = (byte)(tmp>>8);
#endif /* FL_BIG_ENDAIN */
      }
   }
   else
   {   /* mainstream case */
      for (i = 0, count = count >> 1; i < (int)count; i++)
      {
#ifdef FL_BIG_ENDAIN         
         ((word FAR1 *)dest)[i] = (word)(swin[i]>>16);
#else
         ((word FAR1 *)dest)[i] = (word)swin[i];
#endif /* FL_BIG_ENDAIN */
      }
   }
}

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c W r i t e S i n g l e S h i f t
 
   Write 'count' bytes to M+ DiskOnChip with none shifted address bus.
------------------------------------------------------------------------*/

void fl16bitDocWriteSingleShift ( volatile  byte FAR0 * win , word offset ,
                             byte FAR1 * src, word count )
{
   volatile dword FAR0 * swin = (volatile dword FAR0 *)win + (offset>>1);
   register int         i;
   register dword       tmp;

   if( pointerToPhysical(src) & 0x1 ) /* rare case: unaligned source buffer */
   {       
       for (i = 0; i < (int)count; i+=2)
       {
#ifdef FL_BIG_ENDAIN
           tmp = (((dword)src[i])<<24) + (((dword)src[i+1])<<16);
#else
           tmp = (dword)src[i] + (((dword)src[i+1])<<8);
#endif /* FL_BIG_ENDAIN */
           *swin  = tmp;
		 }
   }
   else /* mainstream case */
   {    
      for (i = 0, count = count >> 1; i < (int)count; i++)
#ifdef FL_BIG_ENDIAN
        *swin = ((dword)((word FAR1 *)src)[i])<<16;
#else
        *swin = (dword)((word FAR1 *)src)[i];
#endif /* FL_BIG_ENDIAN */
   }
}

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c S e t S i n g l e S h i f t
 
   Set 'count' bytes of M+ DiskOnChip with none shifted address bus
------------------------------------------------------------------------*/

void fl16bitDocSetSingleShift ( volatile  byte FAR0 * win , word offset ,
                                  word count , byte val)
{
   volatile dword FAR0 * swin = (volatile dword FAR0 *)win + (offset>>1);
   register int          i;
   register dword        tmpVal = (dword)val * 0x01010101L;

   for (i = 0; i < (int)count; i+=2)
      *swin = tmpVal;
}


/**************************************************************/
/*  16-Bit DiskOnChip - Single Shift - Only 8 bits are valid  */
/**************************************************************/

/*----------------------------------------------------------------------
   f l 1 6 b i t D o c R e a d S i n g l e S h i f t I g n o r e H i g h e r 8 B i t s

   Note : offset must be 16-bits aligned.
  
   Read 'count' bytes from M+ DiskOnChip connected with all 16 data bits, but
   in interleave-1 mode , therefore only one of the 8 bits contains actual data.
   The DiskOnChip is connected without an address shift.
------------------------------------------------------------------------*/

void fl16bitDocReadSingleShiftIgnoreHigher8bits(volatile  byte FAR0 * win, word offset, byte FAR1 * dest, word count )
{
   volatile dword FAR0 * swin = (volatile dword FAR0 *)win + (offset>>1);
   register int         i;

#ifdef FL_INIT_MMU_PAGES 
  if (count == 0)
     return;

  *dest = (byte)0;
  *((byte FAR1*)addToFarPointer(dest, (count - 1)) ) = (byte)0;
#endif /* FL_INIT_MMU_PAGES */

   for (i = 0; i < (int)count; i++)
   {
#ifdef FL_BIG_ENDAIN
      dest[i] = (byte)(swin[i]>>24);
#else
      dest[i] = (byte)swin[i];
#endif /* FL_BIG_ENDAIN */
   }
}

/*----------------------------------------------------------------------
   f l 1 6 D o c W r i t e S i n g l e S h i f t I g n o r e H i g h e r 8 b i t s

   Note : offset must be 16-bits aligned.

   Write 'count' bytes to M+ DiskOnChip connected with all 16 data bits, but
   in interleave-1 mode , therefore only one of the 8bits contains actual data.
   The DiskOnChip is connected without an address shift.
------------------------------------------------------------------------*/

void fl16bitDocWriteSingleShiftIgnoreHigher8bits ( volatile  byte FAR0 * win , word offset ,
                             byte FAR1 * src, word count )
{
   volatile dword FAR0 * swin = (volatile dword FAR0 *)win + (offset>>1);
   register int         i;

   for (i = 0; i < (int)count; i++)
   {
#ifdef FL_BIG_ENDAIN
      *swin = ((dword)src[i]<<24);
#else
      *swin = (dword)src[i];
#endif /* FL_BIG_ENDAIN */
   }
}

/*----------------------------------------------------------------------
   f l 1 6 D o c S e t S i n g l e S h i f t I g n o r e H i g h e r 8 b i t s

   Note : offset must be 16-bits aligned.

   Set 'count' bytes to M+ DiskOnChip connected with all 16 data bits, but
   in interleave-1 mode , therefore only one of the 8bits contains actual data.
   The DiskOnChip is connected without an address shift.
------------------------------------------------------------------------*/

void fl16bitDocSetSingleShiftIgnoreHigher8bits ( volatile  byte FAR0 * win , word offset ,
                                  word count , byte val)
{
   volatile dword FAR0 * swin = (volatile dword FAR0 *)win + (offset>>1);
   register int         i;
   dword                tmpVal = (dword)val * 0x01010101L;

   for (i = 0; i < (int)count; i++)
         *swin = tmpVal;
}


/**********************************************************/
/* Set proper access type routines into the proper record */
/**********************************************************/

/*----------------------------------------------------------------------*/
/*                 s e t B u s T y p e O f F l a s h                    */
/*                                                                      */
/* Set DiskOnChip socket / flash memory access routine.                 */
/* This routine must be called by the MTD prior to any access to the    */
/* DiskOnChip                                                           */
/*                                                                      */
/* Parameters:                                                          */
/*    flflash    : Pointer to sockets flash record.                     */
/*    access     : Type of memory access routines to install            */
/*                                                                      */
/* Note: The possible type of memory access routine are comprised of:   */
/*                                                                      */
/*    Address shift:                                                    */
/*         FL_NO_ADDR_SHIFT         - No address shift                  */
/*         FL_SINGLE_ADDR_SHIFT     - Single address shift              */
/*         FL_DOUBLE_ADDR_SHIFT     - Double address shift              */
/*                                                                      */
/*    Platform bus capabilities (access width):                         */
/*         FL_BUS_HAS_8BIT_ACCESS   -  Bus can access 8-bit             */
/*         FL_BUS_HAS_16BIT_ACCESS  -  Bus can access 16-bit            */
/*         FL_BUS_HAS_32BIT_ACCESS  -  Bus can access 32-bit            */
/*                                                                      */
/*    Number of data bits connected to the DiskOnChip (if_cfg):         */
/*         FL_8BIT_DOC_ACCESS       - DiskOnChip has 8 data bits        */
/*         FL_16BIT_DOC_ACCESS      - DiskOnChip has 16 data bits       */
/*                                                                      */
/*    Flash data bits that can be accessed in a bus cycle (interleave): */
/*         FL_8BIT_FLASH_ACCESS     - 8 bits of flash per cycle         */
/*         FL_16BIT_FLASH_ACCESS    - 16 bits of flash per cycle        */
/*                                                                      */
/*    Ignore all of the above and use user defined access routines:     */
/*         FL_ACCESS_USER_DEFINED - Do not install any routine since    */
/*                                  user already installed custome made */
/*                                  routines                            */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, otherwise failed              */
/*----------------------------------------------------------------------*/

FLStatus  setBusTypeOfFlash(FLFlash * flash,dword access)
{
   /* sanity checks here if needed */
   if(flash==NULL)
   {
      DEBUG_PRINT(("Flash record passed to setBusTypeOfFlash is NULL.\r\n"));
      return flBadParameter;
   }

   /* check if user already defined the memory access routines */
   if ((access & FL_ACCESS_USER_DEFINED) != 0)
      return flOK;

   /************************************/
   /* install requested access methods */
   /************************************/

   switch(access & FL_XX_ADDR_SHIFT_MASK)
   {
      case FL_NO_ADDR_SHIFT:

         flash->memWindowSize = &flDocMemWinSizeNoShift;
         switch(access & FL_XX_DATA_BITS_MASK)
         {
            case FL_8BIT_DOC_ACCESS:  /* if_cfg set to 8-bits */

               /* Make sure bus supports 8 bit access */
               if((access & FL_BUS_HAS_8BIT_ACCESS) == 0)
               {                   
                  DEBUG_PRINT(("ERROR: TrueFFS requires 8-bit access to DiskOnChip memory window\r\n"));
                  DEBUG_PRINT(("       for 8-bit DiskOnChip connected with no address shift.\r\n"));
                  return flBadParameter;
               }

               flash->memWrite8bit  = &flWrite8bitUsing8bitsNoShift;
               flash->memRead8bit   = &flRead8bitUsing8bitsNoShift;
               flash->memRead16bit  = &flRead16bitDummy;
               flash->memWrite16bit = &flWrite16bitDummy;
               flash->memRead       = &fl8bitDocReadNoShift;
               flash->memWrite      = &fl8bitDocWriteNoShift;
               flash->memSet        = &fl8bitDocSetNoShift;
               break;

            case FL_16BIT_DOC_ACCESS: /* if_cfg set to 16-bits (Plus family) */

               /* Make sure bus supports 16 bit access */
               if((access & FL_BUS_HAS_16BIT_ACCESS) == 0)
               {
                  DEBUG_PRINT(("ERROR: TrueFFS requires 16-bit access to DiskOnChip memory window\r\n"));
                  DEBUG_PRINT(("       for 16-bit DiskOnChip connected with no address shift.\r\n"));
                  return flBadParameter;
               }

               flash->memWrite8bit  = &flWrite8bitUsing16bitsNoShift;
               flash->memRead8bit   = &flRead8bitUsing16bitsNoShift;
               flash->memRead16bit  = &flRead16bitUsing16bitsNoShift;
               flash->memWrite16bit = &flWrite16bitUsing16bitsNoShift;

               switch(access & FL_XX_FLASH_ACCESS_MASK) /* Interleave */
               {
                  case FL_8BIT_FLASH_ACCESS:  /* Interleave - 1 */
                     flash->memRead       = &fl16bitDocReadNoShiftIgnoreHigher8bits;
                     flash->memWrite      = &fl16bitDocWriteNoShiftIgnoreHigher8bits;
                     flash->memSet        = &fl16bitDocSetNoShiftIgnoreHigher8bits;
                     break;
                  case FL_16BIT_FLASH_ACCESS: /* Interleave - 2 */
                     flash->memRead       = &fl16bitDocReadNoShift;
                     flash->memWrite      = &fl16bitDocWriteNoShift;
                     flash->memSet        = &fl16bitDocSetNoShift;
                     break;
                  default:
                     DEBUG_PRINT(("TrueFFS does not support this flash access type (setBusTypeOfFlash).\r\n"));
                     return flBadParameter;
               }
               break;

            default:
               DEBUG_PRINT(("TrueFFS does not support this number of DiskOnChip data bits (setBusTypeOfFlash).\r\n"));
               return flBadParameter;
         }
         break;

      case FL_SINGLE_ADDR_SHIFT:

         /* Install memory window size routine */
         flash->memWindowSize = &flDocMemWinSizeSingleShift;
         switch(access & FL_XX_DATA_BITS_MASK)
         {
            case FL_8BIT_DOC_ACCESS:  /* if_cfg set to 8bits (None plus family)*/

               /* Make sure bus supports 16 bit access */
               if((access & FL_BUS_HAS_16BIT_ACCESS) == 0)
               {
                  DEBUG_PRINT(("ERROR: TrueFFS requires 16-bit access to DiskOnChip memory window\r\n"));
                  DEBUG_PRINT(("       for 8-bit DiskOnChip connected with a single address shift.\r\n"));
                  return flBadParameter;
               }

               flash->memWrite8bit  = &flWrite8bitUsing16bitsSingleShift;
               flash->memRead8bit   = &flRead8bitUsing16bitsSingleShift;
               flash->memRead16bit  = &flRead16bitDummy;
               flash->memWrite16bit = &flWrite16bitDummy;
               flash->memRead       = &fl8bitDocReadSingleShift;
               flash->memWrite      = &fl8bitDocWriteSingleShift;
               flash->memSet        = &fl8bitDocSetSingleShift;
               break;

            case FL_16BIT_DOC_ACCESS: /* if_cfg set to 8bits (Plus family) */

               /* Make sure bus supports 32 bit access */
               if((access & FL_BUS_HAS_32BIT_ACCESS) == 0)
               {
                  DEBUG_PRINT(("ERROR: TrueFFS requires 32-bit access to DiskOnChip memory window\r\n"));
                  DEBUG_PRINT(("       for 16-bit DiskOnChip connected with a single address shift.\r\n"));
                  return flBadParameter;
               }
    
               flash->memWrite8bit  = &flWrite8bitUsing32bitsSingleShift;
               flash->memRead8bit   = &flRead8bitUsing32bitsSingleShift;
               flash->memRead16bit  = &flRead16bitUsing32bitsSingleShift;
               flash->memWrite16bit = &flWrite16bitUsing32bitsSingleShift;

               switch(access & FL_XX_FLASH_ACCESS_MASK) /* Interleave */
               {
                  case FL_8BIT_FLASH_ACCESS:  /* Interleave - 1 */
                     flash->memRead       = &fl16bitDocReadSingleShiftIgnoreHigher8bits;
                     flash->memWrite      = &fl16bitDocWriteSingleShiftIgnoreHigher8bits;
                     flash->memSet        = &fl16bitDocSetSingleShiftIgnoreHigher8bits;
                     break;
                  case FL_16BIT_FLASH_ACCESS: /* Interleave - 2 */
                     flash->memRead       = &fl16bitDocReadSingleShift;
                     flash->memWrite      = &fl16bitDocWriteSingleShift;
                     flash->memSet        = &fl16bitDocSetSingleShift;
                     break;
                  default:
                     DEBUG_PRINT(("TrueFFS does not support this flash access type (setBusTypeOfFlash).\r\n"));
                     return flBadParameter;
               }
               break;

            default:
               DEBUG_PRINT(("TrueFFS does not support this number of DiskOnChip data bits (setBusTypeOfFlash).\r\n"));
               return flBadParameter;
         }
         break;

      case FL_DOUBLE_ADDR_SHIFT:

         /* Install memory window size routine */
         flash->memWindowSize = &flDocMemWinSizeDoubleShift;
         switch(access & FL_XX_DATA_BITS_MASK)
         {
            case FL_8BIT_DOC_ACCESS:  /* if_cfg set to 8bits or none plus family */

               /* Make sure bus supports 32 bit access */
               if((access & FL_BUS_HAS_32BIT_ACCESS) == 0)
               {
                  DEBUG_PRINT(("ERROR: TrueFFS requires 32-bit access to DiskOnChip memory window\r\n"));
                  DEBUG_PRINT(("       for 8-bit DiskOnChip connected with a double address shift.\r\n"));
                  return flBadParameter;
               }

               flash->memWrite8bit  = &flWrite8bitUsing32bitsDoubleShift;
               flash->memRead8bit   = &flRead8bitUsing32bitsDoubleShift;
               flash->memRead16bit  = &flRead16bitDummy;
               flash->memWrite16bit = &flWrite16bitDummy;
               flash->memRead       = &fl8bitDocReadDoubleShift;
               flash->memWrite      = &fl8bitDocWriteDoubleShift;
               flash->memSet        = &fl8bitDocSetDoubleShift;
               break;

            default:
               DEBUG_PRINT(("TrueFFS does not support this number of DiskOnChip data bits\r\n"));
               DEBUG_PRINT(("when connected with a double address shift (setBusTypeOfFlash).\r\n"));
               return flBadParameter;
         }
         break;

      default:
         DEBUG_PRINT(("TrueFFS does not support this kind of address shifting (setBusTypeOfFlash).\r\n"));
         return flBadParameter;
   }

   /* Store access type in flash record */
   flash->busAccessType = access;
   return flOK;
}

#endif /* FL_NO_USE_FUNC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\docsysp.h ===
/*********************************************************************
 *                                                                   *
 *   FAT-FTL Lite Software Development Kit                           *
 *   Copyright (C) M-Systems Ltd. 1995-2001                          *
 *                                                                   *
 *********************************************************************
 *                                                                   *
 *   Notes for the future:                                           *
 *                                                                   *
 *   1. Get rid of both macros and routines flRead8bitRegPlus/       *
 *      flPreInitRead8bitRegPlus/flWrite8bitRegPlus/                 *
 *      flPreInitWrite8bitRegPlus by calling routines mplusReadReg8/ *
 *      mplusWriteReg8 directly from M+ MTD.                         *
 *                                                                   *
 *********************************************************************/

/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/docsysp.h_V  $
 * 
 *    Rev 1.2   Sep 25 2001 15:39:46   oris
 * Removed FL_MPLUS_FAST_ACCESS.
 *
 *        Rev 1.1     Sep 24 2001 18:23:34     oris
 * Completely revised to support runtime true 16-bit access.
 */




#ifndef DOCSYSP_H
#define DOCSYSP_H




/*
 * includes
 */

#include "flflash.h"
#include "nanddefs.h"




/*
 * macros
 */


#define DOC_WIN    mplusWinSize()

#define flRead8bitRegPlus(vol,offset)                       ((Reg8bitType)mplusReadReg8((void FAR0 *)NFDC21thisVars->win, (int)offset))

#define flPreInitRead8bitRegPlus(driveNo,win,offset)        ((Reg8bitType)mplusReadReg8((void FAR0 *)win, (int)offset))

#define flWrite8bitRegPlus(vol,offset,val)                  mplusWriteReg8((void FAR0 *)NFDC21thisVars->win, (int)offset, (unsigned char)val)

#define flPreInitWrite8bitRegPlus(driveNo,win,offset,val)   mplusWriteReg8((void FAR0 *)win, (int)offset, (unsigned char)val)




/*
 * routines
 */

extern unsigned char   mplusReadReg8 (void FAR0 *win, int offset);

extern void            mplusWriteReg8 (void FAR0 *win, int offset, unsigned char val);

extern Reg16bitType    flRead16bitRegPlus (FLFlash vol, unsigned offset);

extern void    flWrite16bitRegPlus (FLFlash vol, unsigned offset, Reg16bitType val);

extern void    docPlusRead (FLFlash vol, unsigned regOffset, void FAR1 *dest,
                                                                             unsigned int count);

extern void    docPlusWrite (FLFlash vol, void FAR1 *src, unsigned int count);

extern void    docPlusSet (FLFlash vol, unsigned int count, unsigned char val);

extern unsigned long mplusWinSize (void);




#endif /* DOCSYSP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\docbdk.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOCBDK.H_V  $
 * 
 *    Rev 1.13   Apr 15 2002 07:35:48   oris
 * Moved bdkCall to blockdev.h
 * Added include for flreq.h and flfuncno.h when BDK_ACCESS is defined.
 * 
 *    Rev 1.12   Feb 19 2002 20:58:56   oris
 * Removed flflash.h include directive.
 * Moved bdkCall prototype to blockdev.
 * 
 *    Rev 1.11   Nov 08 2001 10:45:10   oris
 * Moved BDK module ifdef statement in order to allow the use of basic definitions.
 * 
 *    Rev 1.10   Oct 18 2001 22:17:12   oris
 * Added number of blocks per floor in the bdkVol structure.
 * 
 *    Rev 1.9   Oct 10 2001 19:48:28   oris
 * More afficient way to store the Binary module internal structure (bdkVol).
 * 
 *    Rev 1.8   May 20 2001 14:35:00   oris
 * Removed mtdsa.h include file.
 * 
 *    Rev 1.7   May 17 2001 16:51:08   oris
 * Removed warnings.
 * 
 *    Rev 1.6   May 16 2001 21:17:12   oris
 * Added OTP routines declaration.
 * Removed redefinitions of SOCKETS and BINARY_PARTITIONS.
 * Changed variable types to TrueFFS standard types.
 * Added EXTRA_SIZE definition and removed SYNDROM_BYTES.
 * 
 *    Rev 1.5   May 09 2001 00:32:14   oris
 * Removed the DOC2000_FAMILY and DOCPLUS_FAMILY defintion and replaced it with NO_DOC2000_FAMILY_SUPPORT, NO_DOCPLUS_FAMILY_SUPPORT, NO_NFTL_SUPPORT and NO_INFTL_SUPPORT.
 * Added BINARY_PARTITIONS and SOCKETS defintions.
 * 
 *    Rev 1.4   Apr 30 2001 17:59:38   oris
 * Changed bdkSetBootPartitonNo, bdkGetProtectionType, bdkSetProtection prototypes
 * 
 *    Rev 1.3   Apr 16 2001 13:32:02   oris
 * Removed warrnings.
 * 
 *    Rev 1.2   Apr 09 2001 15:06:18   oris
 * End with an empty line.
 * 
 *    Rev 1.1   Apr 01 2001 07:50:38   oris
 * Updated copywrite notice.
 * Removed nested comments.
 * Changed #include "base2400.h" to "mdocplus.h"
 * Fix for Big endien compilation problems - changed LEmin to LEulong
 * Changed MULTIPLIER_OFFSET define.
 * Changed protectionType to word instead of unsigned.
 * Added extern prototype of bdkVol pointer.
 *
 *    Rev 1.0   Feb 02 2001 13:24:56   oris
 * Initial revision.
 */

/***************************************************************************/
/*                  M-Systems Confidential                                 */
/*       Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001        */
/*                     All Rights Reserved                                 */
/***************************************************************************/
/*                         NOTICE OF M-SYSTEMS OEM                         */
/*                        SOFTWARE LICENSE AGREEMENT                       */
/*                                                                         */
/*   THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE            */
/*   AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT      */
/*   FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                         */
/*   OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                          */
/*   E-MAIL = info@m-sys.com                                               */
/***************************************************************************/
/************************************************************************/
/* Caution: The BDK_ACCESS compilation flag is for M-SYSTEMS internal   */
/*          use ONLY. This flag is used by M-SYSTEMS drivers and        */
/*          therfore it is SHOULD NOT be used by this package           */
/************************************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Name : docbdk.h                                                            *
*                                                                            *
* Description : This file contains the binary partition defintions , data    *
*               structures and function prototypes.                          *
*                                                                            *
* Note : The file exports 2 interfaces each under its own compilation flag:  *
*                                                                            *
*        BDK package - Standalone package that exports routines for binary   *
*                      partitions handling(MTD_STANDALONE compilation flag). *
*        OSAK module - Separated module of the OSAK package that exports a   *
*                      common entry point to the same routines. (BDK_ACCESS  *
*                      compilation flag).                                    *
*                                                                            *
* Warning : Do not use this file with the BDK_ACCESS compilation flag unless *
*           you own the full OSAK package.                                   *
*****************************************************************************/

#ifndef _DOC_BDK_H_
#define _DOC_BDK_H_

/*---------------------------------------------------------------------*/
/* Include the proper header files.                                    */
/*---------------------------------------------------------------------*/

#include "nanddefs.h"  /* The MTD for the doc2000 and millennium DiskOnChips */

#ifdef BDK_ACCESS
#include "flfuncno.h"
#include "flreq.h"
#endif /* BDK_ACCESS */



/*---------------------------------------------------------------------
 *
 *       Binary Development Kit Stand Alone Customization Area
 *
 *---------------------------------------------------------------------*/

/*---------------------------------------------------------------------*/
/* Boundries of the memory location to look for the DiskOnChip         */
/*---------------------------------------------------------------------*/

#define DOC_LOW_ADDRESS                 0xC8000L
#define DOC_HIGH_ADDRESS                0xE0000L

/*----------------------- Mtd selection -------------------------------
 *
 * Uncomment the following uneeded MTD or TL to reduce code size.
 *
 *---------------------------------------------------------------------*/

/* DiskOnChip2000, DiskOnChip Millennium and DiskOnChip 2000 Tsop devices */
/* #define NO_DOC2000_FAMILY_SUPPORT */

/* DiskOnChip Millennium plus device */
/* #define NO_DOCPLUS_FAMILY_SUPPORT */

/* NFTL format - DiskOnChip2000 and DiskOnChip Millennium */
/* #define NO_NFTL_SUPPORT */

/* INFTL format - DiskOnChip2000 Tsop and DiskOnChip Millennium Plus */
/* #define NO_INFTL_SUPPORT */

/*---------------------------------------------------------------------
 *
 *     End of Binary Development Kit Stand Alone Customization Area
 *
 *---------------------------------------------------------------------*/

/*---------------------------------------------------------------------*/
/* general constant                                                    */
/*---------------------------------------------------------------------*/

#define MAX_BINARY_PARTITIONS_PER_DRIVE 3
#define SIGNATURE_LEN                   8
#define BDK_SIGNATURE_NAME              4
#define SIGNATURE_NUM                   4
#define MBYTE                           0x100000L
#define KBYTE                           0x400
#define BLOCK                           0x200
#define BDK_SIGN_OFFSET                 8
#define ANAND_LEN                       5
#define BDK_COMPLETE_IMAGE_UPDATE       16
#define BDK_PARTIAL_IMAGE_UPDATE        0
#define BDK_MIN(a,b)   ((a) < (b) ? (a) : (b))

#define MULTIPLIER_OFFSET               5
#define BDK_INVALID_VOLUME_HANDLE       0xff
#define BDK_HEADERS_SPACING             (SECTOR_SIZE * 4)
#define BDK_UNIT_BAD                    0
#define BDK_NO_OF_MEDIA_HEADERS         2
#define BDK_FIELDS_BEFORE_HEADER        9 /* number of LEmin fieldsr to skip
                                             to reach  the volume records */
#define BDK_HEADER_FIELDS              35 /* number of LEmin fields used for
                                             volumes infromation record */
#define BDK_BINARY_FLAG       0x20000000L /* flag representing a binary volume
                                             in the volume information record */
/*  BDK specific flag area */
#define ERASE_BEFORE_WRITE 8
#define EXTRA_SIZE         16
/*---------------------------------------------------------------------*/
/* The maximum number of binary partitions                             */
/*---------------------------------------------------------------------*/

#ifndef BINARY_PARTITIONS
#define BINARY_PARTITIONS  SOCKETS /* for backwards compatibility */
#endif /* BINARY_PARITITON */

/*-------------------------- BDK Global Status Values --------------------*/
#define BDK_S_INIT          0    /* uninitialized binary partition record */
#define BDK_S_DOC_FOUND     0x01 /* DiskOnChip device was found           */
#define BDK_S_HEADER_FOUND  0X04 /* Partition information was found       */
#define BDK_S_INFO_FOUND    0x08 /* Sub partition information was found   */
/*------------------------------------------------------------------------*/

#if defined(BDK_ACCESS) || defined(MTD_STANDALONE)

/*------------------------------------------------------------------------*/
/* Global binary partition data structures                                */
/*------------------------------------------------------------------------*/

typedef struct { 

   byte  bdkGlobalStatus;            /* BDK global status variable         */
   byte  bdkEDC;                     /* ECC mode flag                      */
   byte  bdkSignOffset;              /* BDK signature offset ( 0 or 8)     */
   byte  bdkSavedSignOffset;         /* signature offset of last access    */
   word  bdkSavedStartUnit;          /* starting unit of last access       */
   word  startPartitionBlock, endPartitionBlock;   /* partition boundries  */
   word  startImageBlock, endImageBlock;       /* sub partition boundries  */
   word  curReadImageBlock;          /* current block number to read from  */
   word  blockPerFloor;              /* Blocks per floor                   */
   byte  signBuffer[SIGNATURE_LEN];  /* signature of binary sub partition  */
   dword bootImageSize;            /* available sub binary partition size  */
   dword realBootImageSize;  /* size used by an image on the sub partition */
   dword actualReadLen;              /* length needed to be read           */
   dword bdkDocWindow;               /* DiskOnChip window start address    */
   CardAddress curReadImageAddress;  /* current address to read from       */
#ifdef UPDATE_BDK_IMAGE
   CardAddress curUpdateImageAddress; /* current address to write to       */
   dword actualUpdateLen;      /* length needed to be write                */
   word  curUpdateImageBlock;  /* current block number to write to         */
   byte  updateImageFlag;/* BDK_COMPLETE_IMAGE_UPDATE \ ERASE_BEFORE_WRITE */
#endif /* UPDATE_BDK_IMAGE */
#ifdef PROTECT_BDK_IMAGE
   byte  protectionArea;       /* protection area no protecting the volume */
   word  protectionType;       /* PROTECTABLE , CHANGEABLE_PROTECTION      */
#endif /* PROTECT_BDK_IMAGE */

   byte  erasableBlockBits;    /* number of bits used to represen a block  */
   FLFlash * flash;            /* flash record representing the media      */

} BDKVol;

/*------------------------------------------------------------------------*/
/* Extern variables for low level operations.                             */
/*------------------------------------------------------------------------*/

extern BDKVol*  bdkVol;

/*------------------------------------------------------------------------*/
/* OSAK Routines argument packet                                          */
/*------------------------------------------------------------------------*/

#ifdef BDK_ACCESS
typedef struct {
byte oldSign[BDK_SIGNATURE_NAME];
byte newSign[BDK_SIGNATURE_NAME];
byte signOffset;
dword startingBlock;
dword length;
byte flags;
byte FAR1 *bdkBuffer;
} BDKStruct;
#endif /* BDK_ACCESS */

/*------------------------------------------------------------------------*/
/* Diffrent records used by the media header                              */
/*------------------------------------------------------------------------*/

typedef struct {
  LEulong    virtualSize;  /* Virtual size exported by the trasnaltion layer */
  LEulong    firstUnit;    /* First erasable block of the partition */
  LEulong    lastUnit;     /* Last erasable block of the partition */
  LEulong    flags;        /* PROTECTABLE , BDK_BINARY_FLAG */
  LEulong    not_used1;
  LEulong    not_used2;
  LEulong    protectionArea; /* protection area no' */
} VolumeRecord;

/************************ Function Prototype Begin ************************/

#ifdef MTD_STANDALONE

/*************************/
/* BDK specific routines */
/*************************/

void     bdkExit                 (void);
void     bdkSetDocWindow         (CardAddress docWindow);
FLStatus bdkSetBootPartitionNo   (byte partitionNo);
FLStatus bdkFindDiskOnChip       (CardAddress FAR2 *docAddress,
                 dword FAR2 *docSize );
FLStatus bdkCheckSignOffset      (byte FAR2 *signature );
FLStatus bdkCopyBootArea         (byte FAR1 *startAddress,
                 word startUnit,
                 dword areaLen,
                 byte FAR2 *checkSum,
                 byte FAR2 *signature);

/**************************************************/
/* common functions which are exported by the BDK */
/**************************************************/

FLStatus bdkGetBootPartitionInfo (word startUnit,
                 dword FAR2 *partitionSize,
                 dword FAR2 *realPartitionSize,
                 dword FAR2 *unitSize,
                 byte FAR2 *signature);

FLStatus bdkCopyBootAreaInit     (word startUnit,
                 dword areaLen,
                 byte FAR2 *signature);
FLStatus bdkCopyBootAreaBlock    (byte FAR1 *buf ,
                 word bufferLen,
                 byte FAR2 *checkSum);

#ifdef BDK_IMAGE_TO_FILE

FLStatus bdkCopyBootAreaFile     ( char FAR2 *fname,
                   word startUnit,
                   dword areaLen,
                   byte FAR2 *checkSum,
                   byte FAR2 *signature );
#endif /* BDK_IMAGE_TO_FILE */

#ifdef UPDATE_BDK_IMAGE

FLStatus bdkUpdateBootAreaInit   (word  startUnit,
                 dword  areaLen,
                 byte updateFlag,
                 byte FAR2 *signature );
FLStatus bdkUpdateBootAreaBlock  (byte FAR1 *buf ,
                 word bufferLen );

#ifdef ERASE_BDK_IMAGE
FLStatus bdkEraseBootArea        (word startUnit,
                 word noOfBlocks,
                 byte FAR2 * signature);
#endif /* ERASE_BDK_IMAGE */
#ifdef CREATE_BDK_IMAGE
FLStatus bdkCreateBootArea       (word noOfBlocks,
                 byte FAR2 * oldSign,
                 byte FAR2 * newSign);
#endif /* CREATE_BDK_IMAGE */

#ifdef HW_OTP
FLStatus bdkGetUniqueID(byte FAR1* buf);
FLStatus bdkReadOtp(word offset,byte FAR1 * buffer,word length);
FLStatus bdkWriteAndLockOtp(const byte FAR1 * buffer,word length);
FLStatus bdkGetOtpSize(dword FAR2* sectionSize, dword FAR2* usedSize,
               word FAR2* locked);
#endif /* HW_OTP */

#ifdef BDK_IMAGE_TO_FILE

FLStatus bdkUpdateBootAreaFile(char FAR2 *fname, word startUnit,
                   dword areaLen, byte FAR2 *signature);
#endif /* BDK_IMAGE_TO_FILE */

#endif /* UPDATE_BDK_IMAGE */

#ifdef PROTECT_BDK_IMAGE

FLStatus bdkGetProtectionType    (word * protectionType);

FLStatus bdkSetProtectionType    (word newType);

FLStatus bdkInsertKey            (byte FAR1* key);

FLStatus bdkRemoveKey            (void);

FLStatus bdkLockEnable           (byte enable);

FLStatus bdkChangeKey            (byte FAR1* key);

#endif /* PROTECT_BDK_IMAGE */

#else /* MTD_STANDALONE */

extern FLStatus bdkCall(FLFunctionNo functionNo,
                        IOreq FAR2 *ioreq, FLFlash* flash);

#endif /* MTD_STANDALONE */

/********************/
/* common functions */
/********************/

void     bdkInit( void );

/************************ Function Prototype End **************************/

#endif /* BDK_ACCESS || MTD_STANDALONE */
#endif /* _DOC_BDK_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\docsys.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOCSYS.H_V  $
 * 
 *    Rev 1.12   Apr 15 2002 07:36:04   oris
 * Reorganized for final release.
 * 
 *    Rev 1.11   Feb 19 2002 20:59:04   oris
 * Removed flflash.h include directive.
 * 
 *    Rev 1.10   Jan 28 2002 21:24:20   oris
 * Removed the use of back-slashes in macro definitions.
 * Replaced FLFlash argument with DiskOnChip memory base pointer.
 * Changed interface of write and set routines (those that handle more then 8/16 bits) so that instead of FLFlash record they receive the DiskOnChip memory window base pointer and offset (2 separated arguments). The previous implementation did not support address
 * shifting properly.
 * Changed memWinowSize to memWindowSize
 * Removed FL_ACCESS_NO_STRING.
 * 
 *    Rev 1.9   Jan 17 2002 22:59:46   oris
 * Completely revised, to support runtime customization and all M-Systems
 * DiskOnChip devices
 * 
 *    Rev 1.8   Nov 16 2001 00:19:58   oris
 * Added new line in the end, to remove warning.
 * 
 *    Rev 1.7   Sep 25 2001 15:35:04   oris
 * Restored to OSAK 4.3 implementation.
 *
 */

/************************************************************************/
/*                                                                      */
/*        FAT-FTL Lite Software Development Kit                         */
/*        Copyright (C) M-Systems Ltd. 1995-2001                        */
/*                                                                      */
/************************************************************************/

/************************************************************************/
/*                          I M P O R T E N T                           */ 
/*                                                                      */
/* The file contains DiskOnChip memory access routines and macros       */
/* defintions.                                                          */
/*                                                                      */
/* In order to use the complete set of TrueFFS memory access routine    */
/* that allows runtime configuration of each socket access type make    */
/* sure the FL_NO_USE_FUNC is not defined in either:                    */
/* FLCUSTOME.H - when using TrueFFS SDK based application               */
/* MTDSA.H     - when using Boot SDK based application                  */
/*                                                                      */
/* If you know the exact configuration of your application you can      */
/* uncomment the FL_NO_USE_FUNC definition and set the proper access    */
/* type using the macroe defintion bellow.                              */
/************************************************************************/

#ifndef DOCSYS_H
#define DOCSYS_H

#include "nanddefs.h"

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/

#ifdef FL_NO_USE_FUNC 

#error "current version does not support the FL_NO_USE_FUNC compilation flag\r\n"

/* 
 * If you chose to customize the memory access routine using macroes, simply
 * add your implementation here.
 */
  
#define flWrite8bitReg(flash,offset,val)      
#define flRead8bitReg(flash,offset)           

#define docread     
#define docwrite    
#define docset      

/* DiskOnChip Plus memory access routines */

#define flWrite8bitRegPlus(flash,offset,val)  
#define flRead8bitRegPlus(flash,offset)         0x0
#define flWrite16bitRegPlus(flash,offset,val) 
#define flRead16bitRegPlus(flash,offset)        0x0

#define docPlusRead(win,offset,dest,count)    
#define docPlusWrite(win,offset,src,count)  
#define docPlusSet(win,offset,count,val)    

#define DOC_WIN                                 0x2000
#define setBusTypeOfFlash(flash,access)         flOK

#else

/* DiskOnChip memory access routines */

#define flWrite8bitReg(flash,offset,val)      flash->memWrite8bit(flash->win,offset,val)
#define flRead8bitReg(flash,offset)           flash->memRead8bit(flash->win,offset)

#define docread     flash->memRead
#define docwrite    flash->memWrite
#define docset      flash->memSet

/* DiskOnChip Plus memory access routines */

#define flWrite8bitRegPlus(flash,offset,val)  flash->memWrite8bit(flash->win,offset,val)
#define flRead8bitRegPlus(flash,offset)       flash->memRead8bit(flash->win,offset)
#define flWrite16bitRegPlus(flash,offset,val) flash->memWrite16bit(flash->win,offset,val)
#define flRead16bitRegPlus(flash,offset)      flash->memRead16bit(flash->win,offset)

#define docPlusRead(win,offset,dest,count)    flash->memRead(win,offset,dest,count)
#define docPlusWrite(win,offset,src,count)    flash->memWrite(win,offset,src,count)
#define docPlusSet(win,offset,count,val)      flash->memSet(win,offset,count,val)

#define DOC_WIN                               flash->memWindowSize()

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/

/*
 * DiskOnChip Access routines types
 */

/* (public) types of DiskOnChip access configurations */

#define FL_BUS_HAS_8BIT_ACCESS     0x00000001L /* Bus can access 8-bit  */
#define FL_BUS_HAS_16BIT_ACCESS    0x00000002L /* Bus can access 16-bit */
#define FL_BUS_HAS_32BIT_ACCESS    0x00000004L /* Bus can access 32-bit */
#define FL_BUS_HAS_XX_ACCESS_MASK  0x0000000FL /* Bus can access mask   */

#define FL_NO_ADDR_SHIFT           0x00000000L /* No address shift     */
#define FL_SINGLE_ADDR_SHIFT       0x00000010L /* Single address shift */
#define FL_DOUBLE_ADDR_SHIFT       0x00000020L /* Double address shift */
#define FL_XX_ADDR_SHIFT_MASK      0x000000F0L /* Address shift mask   */

/* (private) types of DiskOnChip access configurations */

#define FL_8BIT_DOC_ACCESS         0x00000000L /* Has 8 data bits            */
#define FL_16BIT_DOC_ACCESS        0x00000100L /* Has 16 data bits           */
#define FL_XX_DATA_BITS_MASK       0x00000300L /* Mask of the above          */
#define FL_8BIT_FLASH_ACCESS       0x00000400L /* 8 bits of flash per cycle  */
#define FL_16BIT_FLASH_ACCESS      0x00000800L /* 16 bits of flash per cycle */
#define FL_XX_FLASH_ACCESS_MASK    0x00000C00L /* Mask of the above          */

#define FL_ACCESS_USER_DEFINED     0x00001000L /* User defined routines */

/* DiskOnChip routines prototypes */

extern FLStatus  setBusTypeOfFlash(FLFlash * flash,dword access);

#endif /* FL_NO_USE_FUNC */
#endif /* DOCSYS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\docsysp.c ===
/*****************************************************************************
 *                                                                           *
 *    FAT-FTL Lite Software Development Kit                                  *
 *    Copyright (C) M-Systems Ltd. 1995-2001                                 *
 *                                                                           *
 *****************************************************************************
 *                                                                           *
 *  In order to make your code faster:                                       *
 *                                                                           *
 *  1. Get rid of routines flRead8bitRegPlus()/flPreInitRead8bitReg()Plus,   *
 *     and make M+ MTD calling routine mplusReadReg8() directly.             *
 *                                                                           *
 *  2. Get rid of routines flWrite8bitRegPlus()/flPreInitWrite8bitReg()Plus, *
 *     and make M+ MTD calling routine mplusWriteReg8() directly.            *
 *                                                                           *
 *  3. Eliminate overhead of calling routines tffscpy/tffsset() by           *
 *     adding these routines' code into docPlusRead/docPlusWrite/docPlusSet  *
 *     routines.                                                             *
 *                                                                           *
 *****************************************************************************/




/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/docsysp.c_V  $
 * 
 *    Rev 1.4   Nov 18 2001 20:26:50   oris
 * Bug fix- Bad implementation of 8-bit access when ENVIRNOMENT_VARS is not defined.
 * 
 *    Rev 1.3   Nov 16 2001 00:26:54   oris
 * When ENVIRONMENT_VARS is not defined use for loop of bytes instead of tffscpy.
 * 
 *    Rev 1.2   Sep 25 2001 15:39:38   oris
 * Bug fix - Add special support for flUse8Bit environement variable.
 *
 *          Rev 1.1      Sep 24 2001 18:23:32      oris
 * Completely revised to support runtime true 16-bit access.
 */




/*
 * configuration
 */

/* #define FL_INIT_MMU_PAGES */




/*
 * includes
 */

#include "docsysp.h"




/*
 * macros
 */

/* types of access to M+: 8 or 16-bit */

#define FL_MPLUS_ACCESS_8BIT      0x10
#define FL_MPLUS_ACCESS_16BIT     0x20
#define FL_MPLUS_ACCESS_MASK      0xf0  /* mask for the above */

/* in case of 16-bit access to M+ */

#define FL_MPLUS_ACCESS_BE        0x100




/*
 * routines
 */

#ifdef FL_INIT_MMU_PAGES

static void     flInitMMUpages (byte FAR1 *buf, int bufsize);

#endif




/*
 * vars
 */

/* run-time configuration of DiskOnChip access */

int     flMplusAccessType = FL_MPLUS_ACCESS_8BIT;
/*                          FL_MPLUS_ACCESS_8BIT
                            FL_MPLUS_ACCESS_16BIT
                            FL_MPLUS_ACCESS_BE */



/* ---------------------------------------------------------------------- *
 *                                                                        *
 *                    m p l u s R e a d R e g 8                           *
 *                                                                        *
 *     Read single byte from memory mapped 8-bit M+ register.             *
 *                                                                        *
 * ---------------------------------------------------------------------- */

unsigned char     mplusReadReg8 ( void FAR0 * win, int offset )
{
   if( flMplusAccessType & FL_MPLUS_ACCESS_16BIT ) {

      /* can't read byte, only short word */

      unsigned short     sval;

      sval = *((volatile unsigned short FAR0 *)win + (offset >> 1));

      return *(((unsigned char *) &sval) + (offset & 0x1));
   }

   /* FL_MPLUS_ACCESS_8BIT case */

   return *((volatile unsigned char FAR0 *)win + offset);
}




/* ---------------------------------------------------------------------- *
 *                                                                                                *
 *                          m p l u s W r i t e R e g 8                                 *
 *                                                                                                *
 *     Write single byte to memory mapped 8-bit M+ register.                    *
 *                                                                                                *
 * ---------------------------------------------------------------------- */

void     mplusWriteReg8 ( void FAR0 * win, int offset, unsigned char val )
{
   switch( flMplusAccessType & FL_MPLUS_ACCESS_MASK ) {

      case FL_MPLUS_ACCESS_16BIT:

         *((volatile unsigned short FAR0 *)win + (offset >> 1)) =
                                 (unsigned short)(val * 0x0101);
         break;

      default: /* FL_MPLUS_ACCESS_8BIT */

         *((volatile unsigned char FAR0 *)win + offset) = val;
         break;
   }
}




/* ---------------------------------------------------------------------- *
 *                                                                        *
 *               f l R e a d 1 6 b i t R e g P l u s                      *
 *                                                                        *
 *     Read single word from memory mapped 16-bit M+ register.            *
 *                                                                        *
 * ---------------------------------------------------------------------- */

Reg16bitType     flRead16bitRegPlus ( FLFlash vol, unsigned offset )
{
   return (Reg16bitType)
      (*((volatile unsigned short FAR0 *)((char FAR0 *)NFDC21thisVars->win + (int)offset)));
}




/* ---------------------------------------------------------------------- *
 *                                                                        *
 *               f l W r i t e 1 6 b i t R e g P l u s                    *
 *                                                                        *
 *     Write single word to memory mapped 16-bit M+ register.             *
 *                                                                        *
 * ---------------------------------------------------------------------- */

void     flWrite16bitRegPlus ( FLFlash vol, unsigned offset, Reg16bitType val )
{
   *((volatile unsigned short FAR0 *)((char FAR0 *)NFDC21thisVars->win + (int)offset)) =
      (unsigned short) val;
}




/* ---------------------------------------------------------------------- *
 *                                                                        *
 *                        d o c P l u s R e a d                           *
 *                                                                        *
 *     This routine is called from M+ MTD to read data block from M+.     *
 *                                                                        *
 * ---------------------------------------------------------------------- */

void docPlusRead ( FLFlash vol, unsigned offset, void FAR1 * dest, unsigned int count )
{
   volatile unsigned short FAR0 * swin;
   register int                   i;
   register unsigned short        tmp;

   if (count == 0)
      return;

#ifdef FL_INIT_MMU_PAGES

   flInitMMUpages( (byte FAR1 *)dest, (int)count );

#endif

   if ((vol.interleaving == 1) && (NFDC21thisVars->if_cfg == 16)) {

      /* rare case: 16-bit hardware interface AND interleave == 1 */

      for (i = 0; i < (int)count; i++) {

         *((unsigned char FAR1 *)dest + i) =
            mplusReadReg8 ((void FAR0 *)NFDC21thisVars->win, ((int)offset));
      }
   }
   else {

      switch( flMplusAccessType & FL_MPLUS_ACCESS_MASK ) {

         case FL_MPLUS_ACCESS_16BIT:

            swin = (volatile unsigned short FAR0 *)NFDC21thisVars->win + ((int)offset >> 1);

            if( pointerToPhysical(dest) & 0x1 ) {

               /* rare case: unaligned target buffer */

               if( flMplusAccessType & FL_MPLUS_ACCESS_BE ) {     /* big endian */

                  for (i = 0; i < (int)count; ) {

                     tmp = *(swin + (i >> 1));

                     *((unsigned char FAR1 *)dest + (i++)) = (unsigned char) (tmp >> 8);
                     *((unsigned char FAR1 *)dest + (i++)) = (unsigned char) tmp;
                  }
               }
               else {    /* little endian */

                  for (i = 0; i < (int)count; ) {

                     tmp = *(swin + (i >> 1));

                     *((unsigned char FAR1 *)dest + (i++)) = (unsigned char) tmp;
                     *((unsigned char FAR1 *)dest + (i++)) = (unsigned char) (tmp >> 8);
				  }
			   }
			}
			else {   /* mainstream case */
#ifdef ENVIRONMENT_VARS
			   if (flUse8Bit == 0) {

				  tffscpy( dest, (void FAR0 *)((NDOC2window)NFDC21thisWin + offset), count );
			   }
			   else
#endif /* ENVIRONMENT_VARS */
			   {   /* read in short words */ /* andrayk: do we need this ? */

				  for (i = 0; i < ((int)count >> 1); i++)
					 *((unsigned short FAR1 *)dest + i) = *(swin + i);
               }
            }
            break;

         default:     /* FL_MPLUS_ACCESS_8BIT */
#ifdef ENVIRONMENT_VARS
            tffscpy( dest, (void FAR0 *)((NDOC2window)NFDC21thisWin + offset), count );
#else
            for (i = 0; i < (int)count; i++)
               ((byte FAR1 *)dest)[i] = *((NDOC2window)NFDC21thisWin + offset);
#endif /* ENVIRONMENT_VARS */
            break;
      }
   }
}




/* ---------------------------------------------------------------------- *
 *                                                                        *
 *                      d o c P l u s W r i t e                           *
 *                                                                        *
 *    This routine is called from M+ MTD to write data block to M+.       *
 *                                                                        *
 * ---------------------------------------------------------------------- */

void     docPlusWrite ( FLFlash vol, void FAR1 * src, unsigned int count )
{
   volatile unsigned short FAR0 * swin;
   register int                   i;
   register unsigned short        tmp;

   if (count == 0)
      return;

   if ((vol.interleaving == 1) && (NFDC21thisVars->if_cfg == 16)) {

      /* rare case: 16-bit hardware interface AND interleave == 1 */

      for (i = 0; i < (int)count; i++) {

         mplusWriteReg8( (void FAR0 *)NFDC21thisVars->win, ((int)NFDC21thisIO),
                                                                                                 *((unsigned char FAR1 *)src + i) );
      }
   }
   else {

      switch( flMplusAccessType & FL_MPLUS_ACCESS_MASK ) {

          case FL_MPLUS_ACCESS_16BIT:

             swin = (volatile unsigned short FAR0 *)NFDC21thisVars->win + ((int)NFDC21thisIO >> 1);

             if( pointerToPhysical(src) & 0x1 ) {

                /* rare case: unaligned source buffer */

                if( flMplusAccessType & FL_MPLUS_ACCESS_BE ) {     /* big endian */

                   for (i = 0; i < (int)count; ) {

                      tmp  = ((unsigned short) (*((unsigned char FAR1 *)src + (i++)))) << 8;
                      tmp |= (*((unsigned char FAR1 *)src + (i++)));

                      *(swin + (i >> 1)) = tmp;
				   }
				}
				else {

				   for (i = 0; i < (int)count; ) {    /* little endian */

					  tmp  = (*((unsigned char FAR1 *)src + (i++)));
					  tmp |= ((unsigned short) (*((unsigned char FAR1 *)src + (i++)))) << 8;

					  *(swin + (i >> 1)) = tmp;
				   }
				}
			 }
			 else {    /* mainstream case */
#ifdef ENVIRONMENT_VARS 
				if (flUse8Bit == 0) {

				   tffscpy( (void FAR0 *)((NDOC2window)NFDC21thisWin + NFDC21thisIO), src, count );
				}
				else
#endif /* ENVIRONMENT_VARS */
				{   /* write in short words */ /* andrayk: do we need this ? */

                   for (i = 0; i < ((int)count >> 1); i++)
                      *(swin + i) = *((unsigned short FAR1 *)src + i);
                }
             }
             break;

          default:     /* FL_MPLUS_ACCESS_8BIT */
#ifdef ENVIRONMENT_VARS
             tffscpy( (void FAR0 *)((NDOC2window)NFDC21thisWin + NFDC21thisIO), src, count );
#else
             for (i = 0; i < (int)count; i++)
                *((NDOC2window)NFDC21thisWin + NFDC21thisIO) =
                ((byte FAR1 *)src)[i];
#endif /* ENVIRONMENT_VARS */
             break;
       }
    }
}




/* ---------------------------------------------------------------------- *
 *                                                                        *
 *                        d o c P l u s S e t                             *
 *                                                                        *
 *   This routine is called from M+ MTD to set data block on M+ to 'val'. *
 *                                                                        *
 * ---------------------------------------------------------------------- */

void     docPlusSet ( FLFlash vol, unsigned int count, unsigned char val )
{
   volatile unsigned short FAR0 * swin;
   register int                   i;
   register unsigned short        sval;

   if (count == 0)
      return;

   if ((vol.interleaving == 1) && (NFDC21thisVars->if_cfg == 16)) {

      /* rare case: 16-bit hardware interface AND interleave == 1 */

      for (i = 0; i < (int)count; i++)
         mplusWriteReg8( (void FAR0 *)NFDC21thisVars->win, (int)NFDC21thisIO, val );
   }
   else {    /* mainstream case */

      switch( flMplusAccessType & FL_MPLUS_ACCESS_MASK ) {

         case FL_MPLUS_ACCESS_16BIT:
#ifdef ENVIRONMENT_VARS
			if (flUse8Bit == 0) {

			   tffsset( (void FAR0 *)((NDOC2window)NFDC21thisWin + NFDC21thisIO), val, count );
			}
			else
#endif /* ENVIRONMENT_VARS */
			{  /* do short word access */ /* andrayk: do we need this ? */

               swin = (volatile unsigned short FAR0 *)NFDC21thisVars->win +
                      ((int)NFDC21thisIO >> 1);

               sval = ((unsigned short)val << 8) | val;

               for (i = 0; i < ((int)count >> 1); i++)
                  *(swin + i) = sval;
            }
            break;

         default:     /* FL_MPLUS_ACCESS_8BIT */
#ifdef ENVIRONMENT_VARS
            tffsset( (void FAR0 *)((NDOC2window)NFDC21thisWin + NFDC21thisIO), val, count );
#else
            for (i = 0; i < (int)count; i++)
               *((NDOC2window)NFDC21thisWin + NFDC21thisIO) = val;
#endif /* ENVIRONMENT_VARS */
            break;
      }
   }
}




/* ---------------------------------------------------------------------- *
 *                                                                        *
 *                      m p l u s W i n S i z e                           *
 *                                                                        *
 *    This routine is called from M+ MTD to find out size of M+ window in *
 *    bytes.                                                              *
 *                                                                        *
 * ---------------------------------------------------------------------- */

unsigned long     mplusWinSize ( void )
{
   return 0x2000L;
}




#ifdef FL_INIT_MMU_PAGES

/* ---------------------------------------------------------------------- *
 *                                                                        *
 *                      f l I n i t M M U p a g e s                       *
 *                                                                        *
 * Initializes the first and last byte of the given buffer.               *
 * When the user buffer resides on separated memory pages the read        *
 * operation may cause a page fault. Some CPU's return from a page        *
 * fault (after loading the new page) and reread the bytes that caused    *
 * the page fault from the new loaded page. In order to prevent such a    *
 * case the first and last bytes of the buffer are written                *
 *                                                                        *
 * ---------------------------------------------------------------------- */

static void     flInitMMUpages ( byte FAR1 *buf, int bufsize )
{
   *buf = (byte)0;

   *( addToFarPointer(buf, (bufsize - 1)) ) = (byte)0;
}

#endif /* FL_INIT_MMU_PAGES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\docsoc.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOCSOC.C_V  $
 *
 *    Rev 1.5   Jan 17 2002 22:59:06   oris
 * mtdVars for DiskOnChip MTD were moved from diskonc.c and  mdocplus.c to save RAM.
 * Added include for NANDDEFS.H
 *
 *    Rev 1.4   Jun 17 2001 16:39:10   oris
 * Improved documentation and remove warnings.
 *
 *    Rev 1.3   Apr 10 2001 16:41:46   oris
 * Restored all DiskOnChip socket routines from flsocket.c
 *
 *    Rev 1.2   Apr 09 2001 14:59:50   oris
 * Added an empty routine to avoid warnings.
 *
 *    Rev 1.1   Apr 01 2001 07:44:38   oris
 * Updated copywrite notice
 *
 *    Rev 1.0   Feb 02 2001 13:26:30   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#include "flsocket.h"
#include "nanddefs.h"

#ifdef NT5PORT
#include "scsi.h"
#include "tffsport.h"

extern NTsocketParams driveInfo[SOCKETS];
NTSTATUS updateDocSocketParams(PDEVICE_EXTENSION fdoExtension)
{
  NTSTATUS status;
  ULONG    device;

  device = (fdoExtension->UnitNumber &0x0f);
  driveInfo[device].windowSize = fdoExtension->pcmciaParams.windowSize;
  driveInfo[device].physWindow = fdoExtension->pcmciaParams.physWindow;
  driveInfo[device].winBase = fdoExtension->pcmciaParams.windowBase;
  driveInfo[device].fdoExtension = (PVOID) fdoExtension;
  driveInfo[device].interfAlive = 1;
  return STATUS_SUCCESS;
}
#endif /* NT5PORT */

NFDC21Vars docMtdVars[SOCKETS];

/************************************************************************/
/*                                                                        */
/* Beginning of controller-customizable code                                */
/*                                                                        */
/* The function prototypes and interfaces in this section are standard        */
/* and are used in this form by the non-customizable code. However, the */
/* function implementations are specific to the 82365SL controller.        */
/*                                                                        */
/* You should replace the function bodies here with the implementation        */
/* that is appropriate for your controller.                                */
/*                                                                        */
/* All the functions in this section have no parameters. This is        */
/* because the parameters needed for an operation may be themselves        */
/* dependent on the controller. Instead, you should use the value in         */
/* the 'vol' structure as parameters.                                   */
/* If you need socket-state variables specific to your implementation,        */
/* it is recommended to add them to the 'vol' structure rather than     */
/* define them as separate static variables.                                */
/*                                                                        */
/************************************************************************/


/************************************************************************/
/* c a r d D e t e c t e d                                                */
/*                                                                        */
/* Detect if a card is present (inserted)                                */
/*                                                                        */
/* Parameters:                                                                */
/*        vol : Pointer identifying drive                                        */
/*                                                                        */
/* Returns:                                                                */
/*        0 = card not present, other = card present                        */
/************************************************************************/

static FLBoolean cardDetected(FLSocket vol)
{
  return TRUE;
}


/************************************************************************/
/* V c c O n                                                                */
/*                                                                        */
/* Turns on Vcc (3.3/5 Volts). Vcc must be known to be good on exit.        */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/************************************************************************/

static void VccOn(FLSocket vol)
{
}


/************************************************************************/
/* V c c O f f                                                                */
/*                                                                        */
/* Turns off Vcc.                                                        */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/************************************************************************/

static void VccOff(FLSocket vol)
{
}


#ifdef SOCKET_12_VOLTS

/************************************************************************/
/* V p p O n                                                                */
/*                                                                        */
/* Turns on Vpp (12 Volts. Vpp must be known to be good on exit.)        */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/* Returns:                                                                */
/*        FLStatus        : 0 on success, failed otherwise                */
/************************************************************************/

static FLStatus VppOn(FLSocket vol)
{
  return flOK;
}

/************************************************************************/
/* V p p O f f                                                                */
/*                                                                        */
/* Turns off Vpp.                                                        */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/************************************************************************/

static void VppOff(FLSocket vol)
{
}

#endif        /* SOCKET_12_VOLTS */

/************************************************************************/
/* i n i t S o c k e t                                                        */
/*                                                                        */
/* Perform all necessary initializations of the socket or controller        */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/* Returns:                                                                */
/*        FLStatus                : 0 on success, failed otherwise        */
/************************************************************************/

static FLStatus initSocket(FLSocket vol)
{
  return flOK;
}


/************************************************************************/
/* s e t W i n d o w                                                        */
/*                                                                        */
/* Sets in hardware all current window parameters: Base address, size,        */
/* speed and bus width.                                                 */
/* The requested settings are given in the 'vol.window' structure.      */
/*                                                                        */
/* If it is not possible to set the window size requested in                */
/* 'vol.window.size', the window size should be set to a larger value,  */
/* if possible. In any case, 'vol.window.size' should contain the       */
/* actual window size (in 4 KB units) on exit.                                */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/************************************************************************/

static void setWindow(FLSocket vol)
{
#ifdef NT5PORT
    vol.window.size = driveInfo[vol.volNo].windowSize;
  vol.window.base = driveInfo[vol.volNo].winBase;
#endif/*NT5PORT*/

}


/************************************************************************/
/* s e t M a p p i n g C o n t e x t                                        */
/*                                                                        */
/* Sets the window mapping register to a card address.                        */
/*                                                                        */
/* The window should be set to the value of 'vol.window.currentPage',        */
/* which is the card address divided by 4 KB. An address over 128KB,        */
/* (page over 32K) specifies an attribute-space address.                */
/*                                                                        */
/* The page to map is guaranteed to be on a full window-size boundary.        */
/*                                                                        */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                        */
/*        page                : page to map                                        */
/*                                                                      */
/************************************************************************/

static void setMappingContext(FLSocket vol, unsigned page)
{
}


/************************************************************************/
/* g e t A n d C l e a r C a r d C h a n g e I n d i c a t o r                */
/*                                                                        */
/* Returns the hardware card-change indicator and clears it if set.        */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/* Returns:                                                                */
/*        0 = Card not changed, other = card changed                        */
/************************************************************************/

static FLBoolean getAndClearCardChangeIndicator(FLSocket vol)
{
  /* Note: On the 365, the indicator is turned off by the act of reading */
  return FALSE;
}



/************************************************************************/
/* w r i t e P r o t e c t e d                                                */
/*                                                                        */
/* Returns the write-protect state of the media                         */
/*                                                                        */
/* Parameters:                                                                */
/*        vol                : Pointer identifying drive                        */
/*                                                                        */
/* Returns:                                                                */
/*        0 = not write-protected, other = write-protected                */
/************************************************************************/

static FLBoolean writeProtected(FLSocket vol)
{
  return FALSE;
}

#ifdef EXIT
/************************************************************************/
/* f r e e S o c k e t                                                        */
/*                                                                        */
/* Free resources that were allocated for this socket.                        */
/* This function is called when TrueFFS exits.                                */
/*                                                                        */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                        */
/*                                                                      */
/************************************************************************/

static void freeSocket(FLSocket vol)
{
   freePointer(vol.window.base,vol.window.size);
}
#endif  /* EXIT */

void docSocketInit(FLSocket vol)
{
    vol.cardDetected = cardDetected;
    vol.VccOn        = VccOn;
    vol.VccOff       = VccOff;
#ifdef SOCKET_12_VOLTS
    vol.VppOn        = VppOn;
    vol.VppOff       = VppOff;
#endif
    vol.initSocket   = initSocket;
    vol.setWindow    = setWindow;
    vol.setMappingContext  = setMappingContext;
    vol.getAndClearCardChangeIndicator = getAndClearCardChangeIndicator;
    vol.writeProtected     = writeProtected;
    vol.updateSocketParams = NULL /* updateSocketParameters */;
#ifdef EXIT
    vol.freeSocket = freeSocket;
#endif
}


#ifdef NT5PORT
/*----------------------------------------------------------------------*/
/*                  f l R e g i s t e r D O C S O C         */
/*                                  */
/* Installs routines for DiskOnChip.                    */
/*                                  */
/* Parameters:                                                          */
/*  None                                                            */
/*                                                                      */
/* Returns:                             */
/*  FLStatus    : 0 on success, otherwise failure       */
/*----------------------------------------------------------------------*/
ULONG windowBaseAddress(ULONG driveNo)
{
  return (ULONG) (driveInfo[driveNo].physWindow >> 12);
}
FLStatus flRegisterDOCSOC(ULONG startAddr,ULONG stopAddr)
{
  if (noOfSockets >= DOC_DRIVES)
    return flTooManyComponents;

  for (; noOfSockets < DOC_DRIVES; noOfSockets++) {

        FLSocket vol = flSocketOf(noOfSockets);
        vol.volNo = noOfSockets;
        docSocketInit(&vol);
        flSetWindowSize(&vol, 2);   /* 4 KBytes */

             //vol.window.baseAddress = flDocWindowBaseAddress(vol.volNo, 0, 0, NULL);
        vol.window.baseAddress = windowBaseAddress(vol.volNo);
        vol.window.base = pdriveInfo[vol.volNo & 0x0f].winBase;
        // if(((void *)vol.window.baseAddress) == NULL){
        // }

        }
        if (noOfSockets == 0)
            return flAdapterNotFound;

  return flOK;
}
#endif /*NT5PORT*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\docbdk.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOCBDK.C_V  $
 * 
 *    Rev 1.32   Apr 15 2002 20:14:30   oris
 * Bug fix - No longer ignore the last binary block of high capacity (512MB and up) INFTL formatted device. This bug caused the placeExbByBuffer routine to fail.
 * Bug fix - Physical size of INFTL formatted binary partition was 1 unit smaller then the real size.
 * 
 *    Rev 1.31   Apr 15 2002 07:35:38   oris
 * Bug fix - bdkErase routine did not made sure not to erase OTP and DPS 
 *                units of floors > 0.
 * 
 *    Rev 1.30   Feb 19 2002 20:58:44   oris
 * Changed debug print.
 * Bug fix - binary partition physical length was not reported properly , due to bad casting.
 * 
 *    Rev 1.29   Jan 20 2002 11:09:42   oris
 * Added debug print. 
 * 
 *    Rev 1.28   Jan 17 2002 22:58:56   oris
 * Force calling bdkInit if not called.
 * Moved declaration of internal variables to mtdsa.c
 * Bug fix NO_INFTL_FAMILY_SUPPORT and NO_NFTL_FAMILY_SUPPORT where  changed to NO_INFTL_SUPPORT and NO_INFTL_SUPPORT to comply with header  file.
 * Prevent creating binary partition with signature 0xffff ffff
 * bdkInit uses tffsset instead of zeroing all the structure fields.
 * Bug fix - retrieveHeader routine used a word variable instead of dword.
 * freePointer call uses DOC_WIN_SIZE instead of DOC_WIN (part of new docsys ,mechanism).
 * BDK now take socket and flash records using flSocketOf() and flFlashOf(). The records themselves are defined in mtdsa.c
 * Use PROTECTABLE definition instead of 1 in calls to protectionSet.
 * Added support for flVerifyWrite runtime variable for binary partitions
 * 
 *    Rev 1.27   Nov 16 2001 00:19:48   oris
 * Bug fix - TrueFFS with verify write calling erase and then update block without erase flag, will fail.
 * 
 *    Rev 1.26   Nov 08 2001 10:45:04   oris
 * Removed warnings.
 * Bug fix - DiskOnChip with different number of blocks in the last floor.
 * 
 *    Rev 1.25   Oct 18 2001 22:17:02   oris
 * Bug fix - Missing support for binary partiiton on M+ that spans over a single floor.
 * 
 *    Rev 1.24   Oct 10 2001 19:48:14   oris
 * Bug fix - missing return statment caused the bdkGetProtectionType routine to call bdkSetProtectionType and therfore return a failing status.
 * 
 *    Rev 1.23   Sep 25 2001 17:37:00   oris
 * Bug fix - bdkIdentifyProtection routine did not update after change protection call.
 * 
 *    Rev 1.22   Sep 15 2001 23:45:04   oris
 * Bug fix - Changeable protection type was reported by the MTD even if user did not ask for it.
 * Bug fix - Big endian casting caused wrong protection type to be returned.
 * 
 *    Rev 1.21   Jul 13 2001 01:00:48   oris
 * Bug fix - when skipping bad blocks we no longer mark the bad block with the signature.
 * Send default key before any protection change operation.
 * 
 *    Rev 1.20   May 30 2001 21:10:22   oris
 * Bug fix - meida header was converted from little indien twice therefore suppling wrong data.
 * 
 *    Rev 1.19   May 17 2001 21:17:50   oris
 * Improoved documentation of error codes.
 * 
 *    Rev 1.18   May 17 2001 16:51:08   oris
 * Removed warnings.
 * 
 *    Rev 1.17   May 16 2001 21:17:04   oris
 * Bug fix - One of the "ifndef" statement of NO_DOCPLUS_FAMILY_SUPPORT was coded as "ifdef".
 * Bug fix - bdkEraseBootArea routine.
 * Changed bdkCopyBootAreaFile and bdkUpdateBootAreaFile interface. The signature is not an unsigned char pointer and not signed.
 * Removed warnings.
 * Added arguments check in bdkSetProtectionType routine and forced the presence of PROTECTABLE flag.
 * Compilation problems for MTD_STANDALONE were fixed.
 * Changed DATA definition to FL_DATA.
 * 
 *    Rev 1.16   May 09 2001 00:32:02   oris
 * Removed the DOC2000_FAMILY and DOCPLUS_FAMILY defintion and replaced it with NO_DOC2000_FAMILY_SUPPORT, NO_DOCPLUS_FAMILY_SUPPORT, NO_NFTL_SUPPORT and NO_INFTL_SUPPORT.
 * Bug fix - bdkEraseBootArea did not erase more then a single unit.
 * Bug fix - protection routine did not support floors properly.
 * Added OTP and unique ID routines for Millennium Plus .
 *
 *    Rev 1.15   May 06 2001 22:41:42   oris
 * Removed warnings.
 *
 *    Rev 1.14   May 02 2001 06:43:56   oris
 * Bug fix - bdkRetrieveHeader routine with cascaded floors.
 *
 *    Rev 1.13   May 01 2001 14:23:28   oris
 * Removed warrnings.
 *
 *    Rev 1.12   Apr 30 2001 17:59:04   oris
 * Removed misleading debug massage when calling bdkCheckSignOffset.
 * Reviced bdkRetrieveHeader routine not to use the MTD readBBT routine.
 * Added initialization of the erasbleBlockSizeBits variable in order to simplify multiplications.
 * Changed bdkSetBootPartitonNo, bdkGetProtectionType, bdkSetProtection prototypes.
 * Bug fix - bdkGetPartitionType routine. Missing case caused type to be 0 at all times.
 *
 *    Rev 1.11   Apr 16 2001 13:30:54   oris
 * Bug fix - bad comparison with bdk flag.
 * Bug fix - proection prevented read binary area since the dps were read protected.
 * Removed warrnings.
 *
 *    Rev 1.10   Apr 12 2001 06:49:50   oris
 * Added forceDownload routine
 * Changed checkWinForDoc routine to be under ifndef MTD_STANDALONE.
 *
 *    Rev 1.9   Apr 10 2001 16:40:56   oris
 * bug fixed for big_endien in bdkmount routine.
 *
 *    Rev 1.8   Apr 09 2001 14:59:24   oris
 * Bug fix in retreave header routine - header was searched on the first floor only.
 * End with an empty line.
 *
 *    Rev 1.7   Apr 01 2001 07:50:18   oris
 * Updated copywrite notice.
 * Removed nested comments.
 * Removed static type from bdkVol for placinf exb file and standlone applications.
 * Changed readBBT function call since prototype was changed.
 * Bug fix in bdkretreave header routine - added casting to bbt pointer and iUnit.
 * Fix for Big endien compilation problems.
 * Remove unneeded variables.
 * Bad spelling of "..changable..".
 * Changed h\w to h/w.
 * Changed 2400 family to doc plus family.
 * Adde casting in calls to protection routine.
 *
 *    Rev 1.6   Feb 20 2001 15:55:28   oris
 * Bug fix - global partiton and socket variables were redaclared in bdcall routine.
 *
 *    Rev 1.5   Feb 14 2001 02:36:44   oris
 * Changed FLFlash and FLScoket records (used for the BDK) from static to global for the putImage utility.
 *
 *    Rev 1.4   Feb 13 2001 01:41:50   oris
 * bdkPartitionInfo returns the number of binary partitions in flags field of the bdkStruct and not irFlags
 *
 *    Rev 1.3   Feb 07 2001 18:15:24   oris
 * Changed else in bdkRetreaveHeader routine otherwise would not compiling bdk with a single doc family.
 * Changed the socketTable and mtdTable so BDK package can compile.
 *
 *    Rev 1.2   Feb 05 2001 20:46:30   oris
 * Read the changable protection flag in protectionChangeInit routine
 * from the media header and not from the MTD.
 *
 *    Rev 1.1   Feb 05 2001 20:10:56   oris
 * Removed // comments and added missing ;
 *
 *    Rev 1.0   Feb 02 2001 13:19:44   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/************************************************/
/* B i n a r y   D e v e l o p m e n t   K i t  */
/* -------------------------------------------  */
/************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Name : docbdk.c                                                            *
*                                                                            *
* Description : This file contains the binary partition handling routines.   *
*                                                                            *
* Note : The file has 2 interfaces each under its own compilation flag:      *
*                                                                            *
*        BDK package - Standalone package that exports routines for binary   *
*                      partitions handling(MTD_STANDALONE compilation flag). *
*        OSAK module - Separated module of the OSAK package that exports a   *
*                      common entry point to the same routines. (BDK_ACCESS  *
*                      compilation flag).                                    *
*                                                                            *
* Warning : Do not use this file with the BDK_ACCESS compilation flag unless *
*           you own the full OSAK package.                                   *
*****************************************************************************/

#include "docbdk.h"
#ifndef MTD_STANDALONE
#include "doc2exb.h"
#include "blockdev.h"
#endif /* MTD_STANDALONE */

#if (defined(MTD_STANDALONE) && defined(ACCESS_BDK_IMAGE)) || defined(BDK_ACCESS)

/*********************** Global Variables Start******************************/

/* conversion table from OSAK handles to binary partition handles */
static byte handleTable[SOCKETS][MAX_BINARY_PARTITIONS_PER_DRIVE];
static byte noOfPartitions=0;           /* number of mounted binary partition  */
static byte globalPartitionNo=0;        /* The current partition number        */
static byte globalSocketNo = 0;
BDKVol  bdkVols[BINARY_PARTITIONS]; /* binary partitions records */
BDKVol* bdkVol=bdkVols;          /* pointer to current binary partition */
#ifdef MTD_STANDALONE
FLBoolean             globalInitStatus = FALSE;
#endif /* MTD_STANDALONE */
/*********************** Internal Function Protoype *************************/

static   FLStatus    bdkMount            (void);
static   FLStatus    getBootAreaInfo     (word startUnit , byte FAR2* signature);
static   CardAddress getPhysAddressOfUnit(word startUnit);

/*--------------------------------------------------------------------------*
 *                             b d k I n i t
 *
 *  Initialize all binary partition global variables
 *
 *  Note : This function is called automaticly by bdkFindDiskOnChip.
 *
 *  Parameters: None
 *
 *  global variable output:
 *               bdkVols    - initialized array of binary partitions records
 *               bdkVol     - current binary partition record set to the first
 *
 *  Return:     Nothing
 *
 * Routine for both OSAK and the BDK stand alone package.
 *--------------------------------------------------------------------------*/

void bdkInit(void)
{
   byte index;

   /* initialize binary partitions records with defaultive values */

   tffsset(bdkVols,0,sizeof(bdkVols));
   tffsset(handleTable,BDK_INVALID_VOLUME_HANDLE,sizeof(handleTable));

   for (bdkVol=bdkVols,index=0;index<BINARY_PARTITIONS;bdkVol++,index++)
   {
     bdkVol->bdkGlobalStatus       = BDK_S_INIT;
     bdkVol->bdkSignOffset         = BDK_SIGN_OFFSET;
#ifdef EDC_MODE
     bdkVol->bdkEDC                = EDC;
#endif /* EDC_MODE */
#ifdef UPDATE_BDK_IMAGE
     bdkVol->updateImageFlag       = BDK_COMPLETE_IMAGE_UPDATE;
#endif /* UPDATE_BDK_IMAGE */
   }

   /* Initialize binary handles conversion table with invalid values */
#ifdef MTD_STANDALONE
   noOfMTDs = 0;
   globalPartitionNo=0;
   globalSocketNo = 0;
   globalInitStatus = TRUE;
#endif /* MTD_STANDALONE */
   noOfPartitions=0;
   bdkVol=bdkVols;
}

/*--------------------------------------------------------------------------*
 *               g e t P h y s A d d r e s s O f U n i t
 *
 *  Return the physical address of a unit according to its number
 *  in the binary sub partition.
 *
 *  Note : The sub partition is assumed to be mounted (BDK_S_INFO_FOUND is on).
 *
 *  Parameters :
 *       startUnit : unit number in the binary sub partition.
 *
 *  global variable input:
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               signBuffer          - the sub partition signature
 *               bdkSignOffset       - current signature offset
 *               erasableBlockBits   - number of bits representing a unit
 *
 *  Return :
 *       Physical address of the unit in the BDK partition or 0 if failed
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/

static CardAddress getPhysAddressOfUnit(word startUnit)
{
  word iBlock;
  byte signRead[BDK_SIGNATURE_NAME];
  FLFlash * flash=bdkVol->flash;
  FLStatus status;

  for(iBlock=bdkVol->startImageBlock;
      ((startUnit > 0) && (iBlock <= bdkVol->endImageBlock));iBlock++)
  {
     if ((dword)(iBlock % bdkVol->blockPerFloor) < bdkVol->flash->firstUsableBlock)
     {
        iBlock = (word)(iBlock + bdkVol->flash->firstUsableBlock);
        if (iBlock > bdkVol->endImageBlock)
          break;
     }
     status = flash->read( flash , bdkVol->bdkSignOffset +
               ((CardAddress)iBlock << bdkVol->erasableBlockBits) ,
                signRead , BDK_SIGNATURE_NAME , EXTRA);
     if(status!=flOK)
     {
        DEBUG_PRINT(("(EXTRA)read failed.\r\n"));
        return 0L;
     }

     if(tffscmp((void FAR1*)signRead,(void FAR1*)(bdkVol->signBuffer),BDK_SIGNATURE_NAME)==0)
        startUnit--;
  }
  return( (CardAddress)iBlock << bdkVol->erasableBlockBits );
}

/*--------------------------------------------------------------------------*
 *                    g e t B o o t A r e a I n f o
 *
 *  Mount the binary sub partitions by reading the signature area of each
 *  unit of the entire partition.
 *
 *  Note : Assume that the DiskOnChip was already found (bdkFoundDiskOnChip).
 *
 *  Parameters :
 *       startUnit : unit number in the binary sub partition.
 *       signature : signature of the binary sub partition.
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *           bdkGlobalStatus     - partition predsent status.
 *               bdkSavedStartUnit   - start unit of previous access
 *               bdkSavedSignOffset  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *               bdkDocWindow        - explicitly sets the windows address
 *
 *  global variable output :
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedStartUnit   - save start unit for next access
 *               bdkSavedSignOffset  - save current signature for next access
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *     flFeatureNotSupported - Not a DiskOnChip device.
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/

static FLStatus getBootAreaInfo( word startUnit , byte FAR2* signature )
{
  FLFlash    *   flash;
  word           iBlock;
  word           numBlock;
#ifdef MTD_STANDALONE
  dword          temp;

  checkStatus(bdkFindDiskOnChip((dword FAR2 *)&temp,(dword FAR2 *)&temp));
  DEBUG_PRINT(("Debug: getBootAreaInfo() - DiskOnChip found.\r\n"));
#endif /* MTD_STANDALONE */

  /* set bdkVol pointer to the proper binary partition */

  checkStatus(bdkMount());
  DEBUG_PRINT(("Debug: getBootAreaInfo() - BDK mount succeed.\r\n"));
  /* Check if this sub-partition was already analized */

  if ((!(bdkVol->bdkGlobalStatus & BDK_S_INFO_FOUND))           ||
      (tffscmp((void FAR1 *)(bdkVol->signBuffer),
               (void FAR1 *)signature,BDK_SIGNATURE_NAME) != 0) ||
      (bdkVol->bdkSignOffset!=bdkVol->bdkSavedSignOffset)       ||
      (startUnit<bdkVol->bdkSavedStartUnit)                     ||
      (bdkVol->bdkSavedStartUnit + (bdkVol->realBootImageSize >>
       bdkVol->erasableBlockBits)<= startUnit))
  {

    /* The partition needs mounting */

     tffscpy((void FAR1 *)(bdkVol->signBuffer),(void FAR1 *)signature,
           BDK_SIGNATURE_NAME);
     bdkVol->bdkSavedSignOffset = bdkVol->bdkSignOffset;
     bdkVol->bdkSavedStartUnit  = startUnit;

     bdkVol->startImageBlock   = 0;
     bdkVol->bootImageSize     = 0L;
     bdkVol->realBootImageSize = 0L;

  /* Find the boundries and number of the units marked with the signature */

     DEBUG_PRINT(("Debug: searching for signtured blocks.\r\n"));

     flash = bdkVol->flash;

     numBlock = 0;
     

     for (numBlock = 0 , iBlock   = bdkVol->startPartitionBlock;
          iBlock<=bdkVol->endPartitionBlock;iBlock++)
     {
        if ((dword)(iBlock % bdkVol->blockPerFloor) < bdkVol->flash->firstUsableBlock)
        {
           iBlock = (word)(iBlock + bdkVol->flash->firstUsableBlock);
           if (iBlock > bdkVol->endPartitionBlock)
             break;
        }
        /* check for unit signature */
        DEBUG_PRINT(("Debug: getBootAreaInfo() - Reading unit signature...\r\n"));
        checkStatus(flash->read(flash,bdkVol->bdkSignOffset +
                 ((CardAddress)iBlock << bdkVol->erasableBlockBits),
                 bdkVol->signBuffer,SIGNATURE_LEN,EXTRA));
	DEBUG_PRINT(("Debug: getBootAreaInfo() - Signature read done.\r\n"));

        if(tffscmp( (void FAR1 *)signature , (void FAR1 *)bdkVol->signBuffer,
              BDK_SIGNATURE_NAME ) == 0 )
        {
           if( numBlock == 0 )
              bdkVol->startImageBlock = iBlock;

           numBlock++;
           bdkVol->endImageBlock = iBlock;
           if(( bdkVol->realBootImageSize == 0L ) && (numBlock>startUnit) &&
             (tffscmp((void FAR1 *)&bdkVol->signBuffer[BDK_SIGNATURE_NAME],
                  (void FAR1 *)"FFFF", SIGNATURE_NUM) == 0 ))
           {
              bdkVol->realBootImageSize =
              ((dword)(numBlock - startUnit) << bdkVol->erasableBlockBits);
           }
        }
     }
     if (numBlock<=startUnit)
     {
	DEBUG_PRINT(("Debug: getBootAreaInfo() - No space in volume.\r\n"));
        return( flNoSpaceInVolume );
     }

     bdkVol->bootImageSize = (dword)numBlock << bdkVol->erasableBlockBits;
     if( bdkVol->realBootImageSize == 0L ) /* In case the image without FFFF */
     bdkVol->realBootImageSize =
        ((dword)(numBlock - startUnit) << bdkVol->erasableBlockBits);

     tffscpy((void FAR1 *)(bdkVol->signBuffer),(void FAR1 *)signature,
           BDK_SIGNATURE_NAME);

     bdkVol->bdkGlobalStatus |= BDK_S_INFO_FOUND;
   }

  return( flOK );
}

#ifndef NO_INFTL_SUPPORT
/*----------------------------------------------------------------------*/
/*                   b d k R e t r i e v e H e a d e r                  */
/*                                                                      */
/* Retreave media header by oring the headers of each floor             */
/*                                                                      */
/* Note:  The header of each floor is read to the first half of the     */
/* buffer and then ORed to the second half therfore constructing the    */
/* real header in the upper half. The data is copied to the first half  */
/* while cast back from little endian                                   */
/*                                                                      */
/* Parameters:                                                          */
/*    headerBuffer - buffer returning the retieved header.              */
/*                                                                      */
/* Returns:                                                             */
/*        flOK on success any other value on error                      */
/*----------------------------------------------------------------------*/

FLStatus bdkRetrieveHeader (dword * headerBuffer)
{
  word  iUnit;
  dword endUnit; /* Might be larger then word */
  dword * bbt = (headerBuffer+BDK_HEADER_FIELDS);
  FLFlash * flash=bdkVol->flash;
  byte floorNo;
  FLBoolean flag;
  byte index;
  FLStatus status;

  tffsset(headerBuffer,0,BDK_HEADER_FIELDS * 2 * sizeof(LEmin));

  for (endUnit = 0,floorNo = 0 ; floorNo < flash->noOfFloors ; floorNo++)
  {
     iUnit = (word)(endUnit + flash->firstUsableBlock);

     endUnit += bdkVol->blockPerFloor;
     for (flag = FALSE;(iUnit<endUnit)&&(flag==FALSE);iUnit++)
     {
        for (index=0;index<BDK_NO_OF_MEDIA_HEADERS;index++) /* all copies */
        {
           status = flash->read(flash,((CardAddress)iUnit<<flash->erasableBlockSizeBits)
                                + index * BDK_HEADERS_SPACING,bbt,
                BDK_HEADER_FIELDS*sizeof(LEmin),FL_DATA);
           if (status != flOK)
           {
              DEBUG_PRINT(("Debug: ERROR reading original unit header.\r\n"));
              return flBadFormat;
           }
           if (tffscmp(bbt, "BNAND", sizeof("BNAND")) == 0)
           {
              flag=TRUE;
              break;
           }
        }
     }
     if (flag == FALSE) /* Header not found in all header copies */
     {
        DEBUG_PRINT(("Debug: binary partition data could not be found.\r\n"));
        return flBadFormat;
     }
     /* merge with previous headers */
     for (index = 0 ; index < BDK_HEADER_FIELDS; index++)
     {
        headerBuffer[index] |= bbt[index];
     }
  } /* loop of the floors */
  return flOK;
}

#endif /* NO_INFTL_SUPPORT */
/*--------------------------------------------------------------------------*
 *                         b d k M o u n t
 *
 *  Routine that finds the media header unit and initializes it. The header
 *  supplies the number of binary partition in the DiskOnChip and their
 *  boundries. If the header is valid the curent partition pointer is set to
 *  the required partition.
 *
 *  Note : 1) Drive argument is assumed to be O.K and DiskOnChip already found
 *         2) If there are no binary partitions O.K will be returned but the
 *            bdkVol pointer will not be changed.
 *
 *  Parameters : None
 *
 *  global variable input :
 *           globalSocketNo     : DiskOnChip drive number (always 0 for BDK)
 *           globalPartitionNo  : Binary partition number in the DiskOnChip
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *               noOfPartitions      - the current amount of partitions
 *               bdkVols             - array of the binary partitions records
 *
 *  global variable output :
 *           bdkVol              - new current binary partition record
 *           handleTable         - partition to record converion table
 *           bdkGlobalStatus     - set to BDK_S_HEADER_FOUND
 *           erasableBlockBits   - number of bits representing a unit
 *           startPartitionBlock - physical unit number of first unit
 *           endPartitionBlock   - and last units of the partition
 *           noOfPartitions      - increment with the new found partitions
 *
 * Return:
 *     flOK                  - success
 *     flBadFormat           - TL format does not exists
 *     flFeatureNotSupported - Not a DiskOnChip device.
 *     flNoSpaceInVolume     - No binary partition at all
 *     flBadDriveHandle      - No such binary partition on the media or number
 *                             binary partitions exceeds the cusomized limit.
 *     flDataError           - fail in buffer reading codes
 *     flHWProtect           - HW read protection was triggerd
 *
 * Routine for both OSAK and the BDK stand alone package.
 *--------------------------------------------------------------------------*/

static FLStatus bdkMount(void)
{
  FLFlash    *   flash        = bdkVol->flash;
  dword          iBlock;
  dword          noOfBlocks;
  byte           blockMultiplierBits;
  byte           maxPartition = 0;
  byte           buf1[TL_SIGNATURE];
  byte           buf2[TL_SIGNATURE];
#ifndef NO_INFTL_SUPPORT
  LEmin          headerBuffer[BDK_HEADER_FIELDS*2]; /* assume big enough */
  VolumeRecord * volume;
#endif /* NO_INFTL_SUPPORT */

  if ((bdkVol->bdkGlobalStatus & BDK_S_HEADER_FOUND)==0)/* header not found */
  {
     /* Find number of bits used to represent erasable block */

     bdkVol->erasableBlockBits = flash->erasableBlockSizeBits;
     noOfBlocks = (dword)(flash->chipSize * flash->noOfChips)
                                >> bdkVol->erasableBlockBits;
     bdkVol->blockPerFloor = (word)
       (flash->chipSize >> flash->erasableBlockSizeBits) *
       ((flash->noOfChips + (flash->noOfChips % flash->noOfFloors)) /
        flash->noOfFloors);

     DEBUG_PRINT(("Debug: searching for TL media header.\r\n"));

#ifndef NO_NFTL_SUPPORT
     if (flash->flags & NFTL_ENABLED)
     {
    tffscpy(buf1,"ANAND",TL_SIGNATURE);
     }
#endif /* NO_NFTL_SUPPORT */
#ifndef NO_INFTL_SUPPORT
     if (flash->flags & INFTL_ENABLED)
     {
    tffscpy(buf1,"BNAND",TL_SIGNATURE);
     }
#endif /* NO_INFTL_SUPPORT */
     if ((flash->flags & (NFTL_ENABLED | INFTL_ENABLED))==0)
     {
       DEBUG_PRINT(("Debug: Not a DiskOnChip device therfore Binary partitions are not supported.\r\n"));
    return( flFeatureNotSupported );
     }

     /* Find the medium boot record in order to get partition boundries */

     for(iBlock=flash->firstUsableBlock;( iBlock < noOfBlocks );iBlock++)
     {
    checkStatus(flash->read(flash,(CardAddress)iBlock << bdkVol->erasableBlockBits,
                buf2,TL_SIGNATURE,0));

    if(tffscmp((void FAR1 *)buf2,(void FAR1 *)buf1,TL_SIGNATURE) == 0 )
    {
       break;
    }
     }

     if (iBlock==noOfBlocks)
     {
       DEBUG_PRINT(("Debug: TL format does not exists.\r\n"));
       return( flBadFormat );
     }

     /* Analize The media header */

#ifndef NO_NFTL_SUPPORT
     if (flash->flags & NFTL_ENABLED)     /* NFTL - only a single partition */
     {
         DEBUG_PRINT(("NFTL media header encounterd.\r\n"));
         bdkVol->startPartitionBlock = 0;
         bdkVol->endPartitionBlock   = (word)((iBlock) ? iBlock-1 : 0);
         maxPartition                = 1;
     }
#endif /* NO_NFTL_SUPPORT */
#ifndef NO_INFTL_SUPPORT
     if (flash->flags & INFTL_ENABLED)    /* INFTL - parse media header */
     {
         DEBUG_PRINT(("INFTL media header encounterd.\r\n"));
         maxPartition = 0;
         checkStatus(bdkRetrieveHeader((dword *)headerBuffer));
         volume = (VolumeRecord *) (headerBuffer+BDK_FIELDS_BEFORE_HEADER);
         if (((LE4(volume->flags) & BDK_BINARY_FLAG)==0) && (globalPartitionNo == 0))
         {
            DEBUG_PRINT(("Device is not formated with a binary partition.\r\n"));
            return flNoSpaceInVolume;
         }
         blockMultiplierBits = (byte)LE4(headerBuffer[MULTIPLIER_OFFSET]);
         bdkVol = &bdkVols[noOfPartitions];
         for (;(BINARY_PARTITIONS >= maxPartition + noOfPartitions) &&
             (LE4(volume->flags) & BDK_BINARY_FLAG) ; bdkVol++,volume++)
        {
            maxPartition++;
            bdkVol->startPartitionBlock = (word)LE4(volume->firstUnit) << blockMultiplierBits;
            bdkVol->endPartitionBlock   = (word)((LE4(volume->lastUnit)+1) << blockMultiplierBits) - 1;
            bdkVol->flash = bdkVols[noOfPartitions].flash;
#ifdef PROTECT_BDK_IMAGE
            bdkVol->protectionArea = (byte)LE4(volume->protectionArea);
            bdkVol->protectionType = (word)LE4(volume->flags);
#endif /* PROTECT_BDK_IMAGE */
            bdkVol->blockPerFloor     = bdkVols[noOfPartitions].blockPerFloor;
            bdkVol->erasableBlockBits = bdkVols[noOfPartitions].erasableBlockBits;
        }
     }
#endif /* NO_INFTL_SUPPORT */

     /* Initialize the partitions that had been found */

     for (blockMultiplierBits=0;blockMultiplierBits<maxPartition;
          blockMultiplierBits++) /* reused blockMultiplierBits as counter */
     {
        bdkVol                              = &bdkVols[noOfPartitions];
        handleTable[globalSocketNo][blockMultiplierBits] = noOfPartitions++;
        bdkVol->bdkGlobalStatus             = BDK_S_DOC_FOUND |
                                              BDK_S_HEADER_FOUND;
     }
  }

  /* set the current partition by changing the bdkVol global pointer */

  if ((globalPartitionNo>MAX_BINARY_PARTITIONS_PER_DRIVE) ||
      (handleTable[globalSocketNo][globalPartitionNo] == BDK_INVALID_VOLUME_HANDLE))
  {
     DEBUG_PRINT(("Device is not formated the specified binary partition.\r\n"));
     return flBadDriveHandle;
  }
  else
  {
    bdkVol = &bdkVols[handleTable[globalSocketNo][globalPartitionNo]];
  }
  return flOK;
}

#ifdef MTD_STANDALONE

/*-------------------------------------------------------------------
 *                         b d k E x i t
 *
 * Reset BDK variables and Free 'bdkWin' memory.
 *
 * Parameters: None
 *
 * Return:     Nothing
 *-------------------------------------------------------------------*/

void bdkExit( void )
{
  if( bdkVol->bdkGlobalStatus & BDK_S_DOC_FOUND )  /* DiskOnChip was found */
  {
    freePointer(bdkWin,DOC_WIN);
  }
  bdkInit();
}

/*-------------------------------------------------------------------
 *                   b d k S e t D o c W i n d o w
 *
 *  Set DiskOnChip window explicitly
 *
 *  Note : This routine should not be used after a DiskOnChip was already
 *         found since it does not initialize the Global binary variables.
 *         In order to switch between DiskOnChip call bdkexists before
 *         calling this routine.
 *
 *  Parameters : 'docWindow' - DiskOnChip physical address
 *
 *  global variable input :
 *               bdkVol           - current binary partition record
 *
 *  global variable output :
 *           bdkDocWindow     - initialized with the given address
 *
 *  Return:     Nothing
 *
 * Routine for BDK stand alone package.
 *-------------------------------------------------------------------*/

void bdkSetDocWindow( dword docWindow )
{
   bdkVol->bdkDocWindow = docWindow;
}

/*--------------------------------------------------------------------------
 *                     b d k F i n d D i s k O n C h i p
 *
 *  Find DiskOnChip in the specified memory range and identify the flash
 *  media (initialize flash). Update 'docSize' and 'docAddress' according
 *  to the DiskOnChip size and address respectively.
 *
 *  Note : If the DiskOnChip location is known, specify the same address
 *         for DOC_LOW_ADDRESS and DOC_HIGH_ADDRESS.
 *
 *  Parameters : 'docAddress'      - pointer to the DiskOnChip address
 *               'docSize'         - pointer to the returned size
 *
 *  global variable input :
 *           bdkGlobalStatus  - was this device found before
 *               bdkVol           - current binary partition record
 *               bdkDocWindow     - if > 0 only this address will be checked
 *
 *  global variable output :
 *               flash            - flash record enabling media I\O
 *           bdkGlobalStatus  - set to BDK_S_DOC_FOUND
 *               bdkDocWindow     - save physical window address
 *
 *  Return:
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *
 * Routine for BDK stand alone package.
 *------------------------------------------------------------------------*/

FLStatus bdkFindDiskOnChip(dword FAR2 *docAddress, dword FAR2 *docSize )
{
  FLStatus status;
  byte     mtdIndex;
  dword    blockSize;
  FLSocket *socket = flSocketOf(0);
  FLFlash  *flash  = flFlashOf(0);

  if(globalInitStatus==FALSE)
      bdkInit();

  if ((bdkVol->bdkGlobalStatus & BDK_S_DOC_FOUND) == 0) /* initialize MTD */
  {

      bdkVol        = bdkVols;
      bdkVol->flash = flash;

#ifndef NO_DOC2000_FAMILY_SUPPORT
      flRegisterDOC2000();
#endif
#ifndef NO_DOCPLUS_FAMILY_SUPPORT
      flRegisterDOCPLUS();
#endif

      /* Search for ASIC in the given memory boundries */

      for(mtdIndex=0;mtdIndex < noOfMTDs;mtdIndex++)
      {
         if( bdkVol->bdkDocWindow > 0 )       /* Set range explicitely */
         {
            status = socketTable[mtdIndex](socket,
                     bdkVol->bdkDocWindow,bdkVol->bdkDocWindow);
         }
         else
         {
            status = socketTable[mtdIndex](socket,
                     DOC_LOW_ADDRESS,DOC_HIGH_ADDRESS);
         }
         if (status == flOK)
         {
              /* Identify flash connected to the ASIC */

            bdkVol->bdkDocWindow = pointerToPhysical(socket->base);

            flash->socket = socket;
            checkStatus(mtdTable[mtdIndex](flash));
            break;
         }
      }
      if (status != flOK)
         return status;

      bdkVol->bdkGlobalStatus |= BDK_S_DOC_FOUND;

      /* Calculate erasable Block Size Bits */
      for(blockSize = flash->erasableBlockSize>>1,flash->erasableBlockSizeBits = 0;
         blockSize>0; flash->erasableBlockSizeBits++,blockSize = blockSize >> 1);
  }

  *docAddress  = pointerToPhysical(socket->base);
  *docSize     = flash->chipSize * flash->noOfChips;

  return flOK;
}

/*--------------------------------------------------------------------------
 *               b d k S e t B o o t P a r t i t i o n N o
 *
 *  Set current binary partiton pointer to a specific binary partition
 *
 *  Note : This routine is neccesay only for partitions > 0 .
 *         This routine can replace the bdkFindDiskOnChip call.
 *
 *  Parameters : 'partitionNo'     - serial number of binary partition
 *
 *  global variable output :
 *           globalPartitionNo  - changed to the current partition number.
 *
 *  Return:
 *     flOK on success
 *     flBadParameter if BDK is not customized to support that many partitions.
 *
 * Routine for BDK stand alone package only.
 *------------------------------------------------------------------------*/

FLStatus bdkSetBootPartitionNo(byte partitionNo)
{
  if (partitionNo < TFFSMIN(BINARY_PARTITIONS,MAX_BINARY_PARTITIONS_PER_DRIVE))
  {
     globalPartitionNo = partitionNo;
     return flOK;
  }
  else
  {
     DEBUG_PRINT(("BDK is not customized to support the specified partition number.\r\n"));
     return flBadParameter;
  }
}

/*-------------------------------------------------------------------
 *                    b d k C h e c k S i g n O f f s e t
 *
 *  Set BDK signature offset
 *
 *  Note : Offset 0 does not support the use of EDC\ECC mechanizm and
 *         therfore it reconmended not to be used.
 *         The new found offset is stored in the bdkSignOffset field of the
 *         partitions global record.
 *
 *  Parameters : 'signature'       - 4-character signature of storage units
 *
 *  global variable input :
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkVol              - current binary partition record
 *               bdkDocWindow        - DiskOnChip window physical address
 *                                     (used to narrow search for DiskOnChip)
 *
 *  global variable output :
 *           bdkSignOffset - the offset of the signature (either 0 or 8)
 *
 *               bdkSavedStartUnit   - save start unit for next access
 *               bdkSavedSignOffset  - save current signatur for next access
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               signBuffer          - initialize with given signature
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW protection was triggerd
 *
 * Routine for BDK stand alone package only.
 *-------------------------------------------------------------------*/

FLStatus bdkCheckSignOffset( byte FAR2 *signature )
{
  FLStatus status;

  bdkVol->bdkSignOffset = 0;  /* Look for signature units with offset 0 */

  status = getBootAreaInfo( 0 , signature );

  if (status!=flOK)
  {
     bdkVol->bdkSignOffset = BDK_SIGN_OFFSET; /* Now try with offset 8 */
     checkStatus(getBootAreaInfo( 0 , signature ));
  }
  return( flOK );
}

 /*-------------------------------------------------------------------
 *                   b d k C o p y B o o t A r e a
 *
 * Copy the BDK Image from the DiskOnChip to a RAM area starting at
 * 'startAddress', with a size of 'areaLen' bytes.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-byteacter signature
 *         followed by a 4-digit hexadecimal number.
 *
 *        This routine simple calls bdkCopyBootAreaInit and loops over
 *        bdkCopyBootAreaBlock.
 *
 * Parameters: 'startAddress'  - pointer to the beginning of the RAM area
 *             'startUnit'     - start block in image for reading
 *             'areaLen'       - BDK image size
 *             'checkSum'      - pointer to the checksum modulo 0x100
 *             'signature'     - 4-byteacter signature of storage units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *           bdkGlobalStatus     - partition predsent status.
 *               bdkSavedStartUnit   - start unit of previous access
 *               bdkSavedSignOffset  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *               bdkDocWindow        - explicitly sets the windows address
 *
 *  global variable output :
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedStartUnit   - save start unit for next access
 *               bdkSavedSignOffset  - save current signature for next access
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD dependent.
 *      flHWProtect         - HW read protection was triggerd
 *
 * Routine for BDK stand alone package only.
 *-------------------------------------------------------------------*/

FLStatus bdkCopyBootArea( byte FAR1 *startAddress,word startUnit,dword  areaLen,
                          byte FAR2 *checkSum, byte FAR2 *signature )
{
  dword  curLen;
  word  copyLen;

  checkStatus(bdkCopyBootAreaInit( startUnit, areaLen, signature ));
  DEBUG_PRINT(("Debug: bdkCopyBootArea() - bdkCopyBootAreaInit was done succefully.\r\n"));

#ifdef BDK_CHECK_SUM
  if (checkSum!=NULL)
    *checkSum=0;
#endif /* BDK_CHECK_SUM */

  for(curLen=0L;( curLen < areaLen );curLen+=bdkVol->flash->erasableBlockSize)
  {
	copyLen = (word)BDK_MIN((areaLen - curLen), bdkVol->flash->erasableBlockSize);
    checkStatus(bdkCopyBootAreaBlock( (byte FAR1 *)startAddress, copyLen, checkSum ));
    startAddress = (byte FAR1 *)addToFarPointer( startAddress, copyLen);
  }
  return flOK;
}

#endif /* MTD_STANDALONE */

/*-------------------------------------------------------------------
 *             b d k G e t B o o t P a r t i t i o n I n f o
 *
 *  Get DiskOnChip binary sub partition Information.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-byteacter signature
 *         followed by a 4-digit hexadecimal number.
 *
 *  Parameters: 'startUnit'     - start Unit for Actual sub Partition Size
 *              'partitionSize' - pointer to return sub Partition Size parameter
 *              'realPartitionSize' - pointer to return Actual sub Partition Size
 *              'unitSize'      - pointer to return Unit Size parameter
 *              'signature'     - 4-byteacter signature of storage units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *           bdkGlobalStatus     - partition predsent status.
 *               bdkSavedStartUnit   - start unit of previous access
 *               bdkSavedSignOffset  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *               bdkDocWindow        - explicitly sets the windows address
 *
 *  global variable output :
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedStartUnit   - save start unit for next access
 *               bdkSavedSignOffset  - save current signature for next access
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD dependent.
 *      flHWProtect         - HW read protection was triggerd
 *
 * Routine for BDK stand alone package only.*
 *-------------------------------------------------------------------*/

FLStatus bdkGetBootPartitionInfo( word startUnit, dword  FAR2 *partitionSize,
                      dword  FAR2 *realPartitionSize,
                      dword  FAR2 *unitSize, byte FAR2 *signature)
{
  FLStatus st = flOK;
  *partitionSize = 0L;
  *unitSize = 0L;

  st = getBootAreaInfo( startUnit , signature );

  *partitionSize      = bdkVol->bootImageSize;
  *realPartitionSize  = bdkVol->realBootImageSize;
  *realPartitionSize -= ((startUnit - bdkVol->bdkSavedStartUnit) << bdkVol->erasableBlockBits);
  *unitSize           = bdkVol->flash->erasableBlockSize;

  return( st );
}


/*-------------------------------------------------------------------
 *                   b d k C o p y B o o t A r e a I n i t
 *
 * Initialize read operations on the DiskOnChip starting at 'startUnit', with
 * a size of 'areaLen' bytes and 'signature'.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-byteacter signature
 *         followed by a 4-digit hexadecimal number.
 *
 * Parameters: 'startUnit'     - start block in image for reading
 *             'areaLen'       - BDK image size
 *             'signature'     - 4-byteacter signature of storage units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkSavedSignBuffer  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *
 *  global variable output :
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedSignBuffer  - save current signatur for next access
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               curReadImageAddress - current address to read from
 *               actualReadLen       - length left to read
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/

FLStatus bdkCopyBootAreaInit(word startUnit ,
                    dword areaLen ,
                    byte FAR2 *signature)
{
  dword       realSize;  /* remaining real size from start unit */

  checkStatus(getBootAreaInfo( startUnit , signature ));

  realSize  = bdkVol->realBootImageSize;
  realSize -= (startUnit - bdkVol->bdkSavedStartUnit) << bdkVol->erasableBlockBits;
  if (areaLen>realSize)
  {
     DEBUG_PRINT(("got out of the partition.\r\n"));
     return( flNoSpaceInVolume );
  }

  bdkVol->curReadImageBlock   = startUnit;
  bdkVol->actualReadLen       = areaLen;
  bdkVol->curReadImageAddress = getPhysAddressOfUnit( startUnit );
  return( flOK );
}

/*-------------------------------------------------------------------
 * bdkCopyBootAreaBlock - Read to 'buffer' from the DiskOnChip BDK Image area.
 *
 *  Note : Before the first use of this function 'bdkCopyBootAreaInit'
 *         must be called
 *
 *  Parameters: 'buf'           - buffer to read into
 *              'bufferLen'     - buffer length in bytes
 *              'checkSum'      - pointer to the checksum modulo 0x100
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *               signBuffer          - sub partition signature
 *               bdkSignOffset       - current signature offset
 *               curReadImageAddress - current address to read from
 *               actualReadLen       - length left to read
 *               endImageBlock       - last signatured block in sub partition
 *               erasableBlockBits   - no' of bits used to represent a block
 *
 *  global variable output :
 *               curReadImageAddress - updated address to read from
 *               actualReadLen       - updated length left to read
 *
 *  Return :
 *      flOK                - success
 *      flBadLength         - required length will cause crossing unit boundry
 *      flNoSpaceInVolume   - no more signatured units found
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/

FLStatus bdkCopyBootAreaBlock( byte FAR1 *buf, word bufferLen, byte FAR2 *checkSum )
{
  word iBlock, readLen;
  byte modes;
  byte signRead[BDK_SIGNATURE_NAME];
  FLFlash * flash = bdkVol->flash;
  FLStatus status;

  if( (bufferLen > flash->erasableBlockSize ) ||
      (bufferLen > bdkVol->actualReadLen))
    return( flBadLength );

  /* find next good unit */

  if( (bdkVol->curReadImageAddress & (flash->erasableBlockSize-1)) == 0 )
  {
     iBlock = (word)( bdkVol->curReadImageAddress >> bdkVol->erasableBlockBits );
     for(;( iBlock <= bdkVol->endImageBlock ); iBlock++)
     {
        if ((dword)(iBlock % bdkVol->blockPerFloor) < bdkVol->flash->firstUsableBlock)
        {
           iBlock = (word)(iBlock + bdkVol->flash->firstUsableBlock);
           if (iBlock > bdkVol->endImageBlock)
             break;
        }

        status = flash->read (flash , bdkVol->bdkSignOffset +
                ((CardAddress)iBlock << bdkVol->erasableBlockBits) ,
                (byte FAR1 *)signRead, BDK_SIGNATURE_NAME,EXTRA);
        if(status!=flOK)
        {
           DEBUG_PRINT(("(EXTRA)read failed.\r\n"));
           return status;
        }
        if( tffscmp((void FAR1 *)signRead, (void FAR1 *)(bdkVol->signBuffer),
               BDK_SIGNATURE_NAME ) == 0 )
               break;
     }

     if( iBlock > bdkVol->endImageBlock )
       return( flNoSpaceInVolume );             /* Finish (last block) */

     bdkVol->curReadImageAddress = (CardAddress )iBlock << bdkVol->erasableBlockBits;
     bdkVol->curReadImageBlock++;
  }

  /* read data */

  readLen = (word)BDK_MIN(bdkVol->actualReadLen, (dword)bufferLen);
  if((bdkVol->bdkEDC)&&(bdkVol->bdkSignOffset!=0))
  {
     modes=EDC;
  }
  else
  {
     modes=0;
  }

  status = (flash->read(flash, bdkVol->curReadImageAddress, buf, readLen, modes));
  if(status!=flOK)
  {
     DEBUG_PRINT(("(EXTRA)read failed.\r\n"));
     return status;
  }

  bdkVol->curReadImageAddress += (CardAddress )readLen;
  bdkVol->actualReadLen  -= (dword)readLen;

#ifdef BDK_CHECK_SUM
  if (checkSum!=NULL)
  {
     while (readLen>0)
     {
        readLen--;
        *checkSum+=buf[readLen];
     }
  }
#endif /* BDK_CHECK_SUM */
  return( flOK );
}

#ifdef UPDATE_BDK_IMAGE
/*-------------------------------------------------------------------
 *              b d k U p d a t e B o o t A r e a I n i t
 *
 * Initialize update operations on the DiskOnChip starting at 'startUnit',
 * with a size of 'areaLen' bytes and 'signature'.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-byteacter signature
 *         followed by a 4-digit hexadecimal number.
 *
 *  Parameters: 'startUnit'     - start unit in image for updating
 *              'areaLen'       - BDK image size
 *              'updateFlag'    - update whole image or part of it
 *                                BDK_COMPLETE_IMAGE_UPDATE
 *              'signature'     - 4-byteacter signature of storage units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkSavedSignBuffer  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *
 *  global variable output :
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedSignBuffer  - save current signatur for next access
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               actualUpdateLen     - length left to write
 *               curUpadateImageAddress - current address to write to
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/

FLStatus bdkUpdateBootAreaInit( word startUnit, dword  areaLen,
                    byte updateFlag, byte FAR2 *signature )
{
  word imageBlockSize;

  checkStatus(getBootAreaInfo( startUnit , signature ));

  imageBlockSize = (word)( bdkVol->bootImageSize >> bdkVol->erasableBlockBits);

  if( ((dword)(imageBlockSize-startUnit) << bdkVol->erasableBlockBits) < areaLen )
    return( flNoSpaceInVolume );

  bdkVol->actualUpdateLen       = areaLen;
  bdkVol->curUpdateImageBlock   = startUnit;
  bdkVol->updateImageFlag       = updateFlag;
  bdkVol->curUpdateImageAddress = getPhysAddressOfUnit( startUnit );
  bdkVol->bdkGlobalStatus      &= ~BDK_S_INFO_FOUND;
  return( flOK );
}

/*-------------------------------------------------------------------
 *             b d k U p d a t e B o o t A r e a B l o c k
 *
 *  Write 'buffer' to the DiskOnChip BDK Image area.
 *
 *  Note : Before the first use of this function 'bdkUpdateBootAreaInit'
 *         must be called
 *
 *  Parameters: 'buf'             - BDK image buffer
 *              'bufferLen'       - buffer length in bytes
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *               signBuffer          - sub partition signature
 *               bdkSignOffset       - current signature offset
 *               curUpdateImageAddress - current address to read from
 *               actualUpdateLen     - length left to read
 *               endImageBlock       - last signatured block in sub partition
 *               erasableBlockBits   - no' of bits used to represent a block
 *
 *  global variable output :
 *               curUpdateImageAddress - updated address to read from
 *               actualUpdateLen       - updated length left to read
 *
 *  Return :
 *      flOK                - success
 *      flBadLength         - required length will cause crossing unit boundry
 *      flNoSpaceInVolume   - no more signatured units found
 *      flDataError         - MTD read fault
 *      flHWProtect         - HW protection was triggerd
 *      flWriteFault        - MTD write fault
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/

FLStatus bdkUpdateBootAreaBlock( byte FAR1 *buf, word bufferLen )
{
  word iBlock, writeLen, i0, j;
  FLStatus status;
  FLFlash* flash = bdkVol->flash;
  byte modes;
  byte signRead[SIGNATURE_LEN];

  if( (bufferLen > flash->erasableBlockSize) ||
      (bufferLen > bdkVol->actualUpdateLen))
    return( flBadLength );

  /* find next good unit and prepare it for work */

  if( (bdkVol->curUpdateImageAddress & (flash->erasableBlockSize-1)) == 0 )
  {
      /* find next signatured unit */

    iBlock = (word)( bdkVol->curUpdateImageAddress >> bdkVol->erasableBlockBits );
    for(;( iBlock <= bdkVol->endImageBlock ); iBlock++)
    {
      if ((dword)(iBlock % bdkVol->blockPerFloor) < bdkVol->flash->firstUsableBlock)
      {
        iBlock = (word)(iBlock + bdkVol->flash->firstUsableBlock);
        if (iBlock > bdkVol->endImageBlock)
          break;
      }
      status = flash->read(flash , bdkVol->bdkSignOffset +
                 ((CardAddress)iBlock << bdkVol->erasableBlockBits),
                 (byte FAR1 *)signRead, BDK_SIGNATURE_NAME ,EXTRA);
      if(status!=flOK)
      {
         DEBUG_PRINT(("(EXTRA)read failed.\r\n"));
         return status;
      }

      if( tffscmp( (void FAR1 *)signRead, (void FAR1 *)(bdkVol->signBuffer),
       BDK_SIGNATURE_NAME ) == 0 )
       break;
    }
    if( iBlock > bdkVol->endImageBlock )
      return( flNoSpaceInVolume );

      /* Erase the newly found unit */

#ifdef BDK_ACCESS
    if(bdkVol->updateImageFlag & ERASE_BEFORE_WRITE)
#endif
      checkStatus(flash->erase (flash, iBlock, 1 ));

       /* Update signature number */

    if( (bdkVol->actualUpdateLen <= flash->erasableBlockSize) &&
     (bdkVol->updateImageFlag & BDK_COMPLETE_IMAGE_UPDATE)     )
    {
       /* Last block FFFF */
       tffscpy( (void FAR1 *)&bdkVol->signBuffer[BDK_SIGNATURE_NAME],
          (void FAR1 *)"FFFF", SIGNATURE_NUM );
    }
    else
    {
      for(i0=bdkVol->curUpdateImageBlock,j=SIGNATURE_LEN;(j>BDK_SIGNATURE_NAME);j--)
      {
         bdkVol->signBuffer[j-1] = (i0 % 10) + '0';
         i0 /= 10;
      }
    }
    /* update internal pointers */

    bdkVol->curUpdateImageAddress = (CardAddress )iBlock << bdkVol->erasableBlockBits;
    bdkVol->curUpdateImageBlock++;

    /* Mark new block */
    status = flash->write(flash,
          (bdkVol->bdkSignOffset + bdkVol->curUpdateImageAddress),
          (byte FAR1 *)bdkVol->signBuffer, SIGNATURE_LEN, EXTRA);
#ifdef VERIFY_WRITE
    if (status == flWriteFault) /* Check if failed due to erase operation */
    {
       /* Check signature is written properly */
       flash->read(flash , (bdkVol->bdkSignOffset + bdkVol->curUpdateImageAddress),            
                  (byte FAR1 *)signRead, SIGNATURE_LEN ,EXTRA);
       if(tffscmp(signRead,bdkVol->signBuffer,BDK_SIGNATURE_NAME))
       {
         return flWriteFault;
       }
       /* Check unit number is not "FFFF" */
       if(tffscmp(signRead+BDK_SIGNATURE_NAME,"FFFF",BDK_SIGNATURE_NAME))
       {
          dword tmp=0;
          checkStatus(flash->write(flash,(bdkVol->bdkSignOffset + 
                      bdkVol->curUpdateImageAddress), &tmp, sizeof (dword), EXTRA));
       }   
    }
#endif /* VERIFY_WRITE */
  }

  /* Write the data to the flash and update internal pointers */

  writeLen = (word)BDK_MIN(bdkVol->actualUpdateLen, (dword)bufferLen);

  if((bdkVol->bdkEDC)&&(bdkVol->bdkSignOffset!=0))
  {
     modes=EDC;
  }
  else
  {
     modes=0;
  }
  checkStatus(flash->write(flash,bdkVol->curUpdateImageAddress,buf,writeLen,modes));

  bdkVol->curUpdateImageAddress += (CardAddress)writeLen;
  bdkVol->actualUpdateLen       -= (dword)writeLen;
  return( flOK );
}

#ifdef ERASE_BDK_IMAGE
/*-------------------------------------------------------------------
 *                   b d k E r a s e A r e a
 *
 *  Erase given number of blockds in the binary sub partition.
 *
 *  Parameters: 'startUnit'     - start unit in image for updating
 *              'noOfBlocks'    - number of blocks to erase
 *              'signature'     - 4-byteacter signature of storage units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkSavedSignBuffer  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *
 *  global variable output :
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedSignBuffer  - save current signatur for next access
 *               bootImageSize       - size of the entire sub partition in bytes
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               realBootImageSize   - number of units writen in the sub partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               actualUpdateLen     - 0
 *               curUpadateImageAddress - address of first block to erase.
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW protection was triggerd
 *      flWriteFault        - MTD write fault
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/

FLStatus bdkEraseBootArea(word startUnit, word noOfBlocks, byte FAR2 * signature)
{
  word iBlock,index;
  FLStatus status;
  FLFlash* flash;

  flash = bdkVol->flash;

  checkStatus(bdkUpdateBootAreaInit(startUnit,
         (dword)noOfBlocks << bdkVol->erasableBlockBits,0,signature));

  tffscpy( (void FAR1 *)&bdkVol->signBuffer, (void FAR1 *) signature, BDK_SIGNATURE_NAME);
  tffscpy( (void FAR1 *)&bdkVol->signBuffer[BDK_SIGNATURE_NAME],  /* Last block FFFF */
        (void FAR1 *)"FFFF", SIGNATURE_NUM );

  iBlock = (word)(bdkVol->curUpdateImageAddress >> bdkVol->erasableBlockBits);

  for (index=0;index<noOfBlocks;index++,iBlock++)

     /* find next good unit erase it and rewrite its signature */
  {
     do
     {
         if ((dword)(iBlock % bdkVol->blockPerFloor) < bdkVol->flash->firstUsableBlock)
         {
           /* Skip OTP and DPS if relevant */
           iBlock = (word)(iBlock + bdkVol->flash->firstUsableBlock);
           if (iBlock > bdkVol->endImageBlock)
             return flGeneralFailure;
         }

         status = flash->read(flash , bdkVol->bdkSignOffset +
         ((CardAddress)iBlock << bdkVol->erasableBlockBits),
          (byte FAR1 *)bdkVol->signBuffer, BDK_SIGNATURE_NAME ,EXTRA);
         if(status!=flOK)
         {
            DEBUG_PRINT(("(EXTRA)read failed.\r\n"));
            return status;
         }
         if (tffscmp((void FAR1 *)bdkVol->signBuffer,
                 (void FAR1 *)signature, BDK_SIGNATURE_NAME ) == 0)
         {
            break;
         }
         else
         {
            iBlock++;
         }
         if (iBlock > bdkVol->endImageBlock)
            return( flNoSpaceInVolume );
     }while(1);

     checkStatus(flash->erase(flash, iBlock, 1 ));
     checkStatus(flash->write(flash, bdkVol->bdkSignOffset +
         ((CardAddress)iBlock << bdkVol->erasableBlockBits),
         (byte FAR1 *)bdkVol->signBuffer, SIGNATURE_LEN, EXTRA));
  }

  bdkVol->actualUpdateLen = 0L;
  return( flOK );
}

#endif /* ERASE_BDK_IMAGE */

#ifdef CREATE_BDK_IMAGE

/*-------------------------------------------------------------------
 *                b d k C r e a t e B o o t A r e a
 *  Init create operations on the DiskOnChip starting at 'startUnit', with
 *  a # of 'units' and 'signature'.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-character signature
 *         followed by a 4-digit hexadecimal number.
 *
 *  Parameters: 'noOfBlocks'    - number of blocks to erase
 *              'oldSign'     - 4-byteacter signature of the source units
 *              'newSign'     - 4-byteacter signature of the new units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkSavedSignBuffer  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *
 *  global variable output :
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedSignBuffer  - save current signatur for next access
 *               bootImageSize       - size of the entire sub partition in bytes
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               realBootImageSize   - number of units writen in the sub partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               actualUpdateLen     - 0
 *               curUpadateImageAddress - address of first block to erase.
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW protection was triggerd
 *      flWriteFault        - MTD write fault
 *
 * Routine for both OSAK and the BDK stand alone package.
 *-------------------------------------------------------------------*/
FLStatus bdkCreateBootArea(word noOfBlocks, byte FAR2 * oldSign,
                  byte FAR2 * newSign)
{
  word iBlock, index;
  byte signRead[BDK_SIGNATURE_NAME];
  FLStatus status;
  FLFlash* flash;

  flash = bdkVol->flash;

  /* FFFF is not a valid signature */
  if(*((dword FAR2*)newSign)==0xffffffffL)
  {
     DEBUG_PRINT(("Debug: can not use 'FFFF' signature for Binary partition.\r\n"));
     return flBadParameter;
  }

  checkStatus(bdkUpdateBootAreaInit(0,(dword)noOfBlocks<<flash->erasableBlockSizeBits,
                        BDK_PARTIAL_IMAGE_UPDATE,oldSign));

  tffscpy( (void FAR1 *)&bdkVol->signBuffer, (void FAR1 *) newSign, BDK_SIGNATURE_NAME);
  tffscpy( (void FAR1 *)&bdkVol->signBuffer[BDK_SIGNATURE_NAME],  /* Last block FFFF */
        (void FAR1 *)"FFFF", SIGNATURE_NUM );

  iBlock = (word)(bdkVol->curUpdateImageAddress >> bdkVol->erasableBlockBits);

  for (index=0;index<noOfBlocks;index++)

     /* find next good unit erase it and write its new signature */
  {
    for(;( iBlock <= bdkVol->endImageBlock ); iBlock++)
    {
      if ((dword)(iBlock % bdkVol->blockPerFloor) < bdkVol->flash->firstUsableBlock)
      {
        iBlock = (word)(iBlock + bdkVol->flash->firstUsableBlock);
        if (iBlock > bdkVol->endImageBlock)
          break;
      }

      status = flash->read(flash , bdkVol->bdkSignOffset +
                 ((CardAddress)iBlock << bdkVol->erasableBlockBits),
                 (byte FAR1 *)signRead, BDK_SIGNATURE_NAME ,EXTRA);
      if(status!=flOK)
      {
        DEBUG_PRINT(("(EXTRA)read failed.\r\n"));
        return status;
      }

      if( tffscmp( (void FAR1 *)oldSign,
             (void FAR1 *)(signRead), BDK_SIGNATURE_NAME ) == 0 )
     break;
    }
    if( iBlock > bdkVol->endImageBlock )
       return( flNoSpaceInVolume );

    checkStatus(flash->erase(flash, iBlock, 1 ));
    checkStatus(flash->write(flash, bdkVol->bdkSignOffset +
          ((CardAddress)iBlock << bdkVol->erasableBlockBits),
          (byte FAR1 *)bdkVol->signBuffer, SIGNATURE_LEN, EXTRA));
  }

  bdkVol->actualUpdateLen = 0L;
  return( flOK );
}
#endif /* CREATE_BDK_IMAGE */
#endif /* UPDATE_BDK_IMAGE */

#ifdef BDK_IMAGE_TO_FILE
#include <stdio.h>

/*-------------------------------------------------------------------
 *               b d k C o p y B o o t A r e a F i l e
 *
 *  Copy the BDK Image from the DiskOnChip to file 'fname' starting at
 *  'startAddress', with a size of 'areaLen' bytes.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-character signature
 *         followed by a 4-digit hexadecimal number.
 *
 *  Parameters: 'fname'         - pointer to file name
 *              'startUnit'     - start block in image for reading
 *              'areaLen'       - BDK image size
 *              'checkSum'      - pointer to the checksum modulo 0x100
 *              'signature'     - 4-character signature of storage units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkSavedSignBuffer  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *
 *  global variable output :
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedSignBuffer  - save current signatur for next access
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               curReadImageAddress - address of last unit read
 *               actualReadLen       - 0
 *
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flGeneralFailure    - could not open file
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *
 * Routine for BDK stand alone package.
 *-------------------------------------------------------------------*/
FLStatus bdkCopyBootAreaFile( Sbyte FAR2 *fname, word startUnit, dword areaLen,
          byte FAR2 *checkSum, byte FAR2 *signature )
{
  dword curLen;
  word copyLen;
  FILE *fout;
  byte buf[BLOCK];

  checkStatus(bdkCopyBootAreaInit( startUnit, areaLen, signature ));

  if( (fout = fopen(fname,"wb")) == NULL )
    return( flGeneralFailure );

#ifdef BDK_CHECK_SUM
  *checkSum = 0;
#endif /* BDK_CHECK_SUM */
  for(curLen=0L;( curLen < areaLen );curLen+=BLOCK)
  {
    copyLen = (word)BDK_MIN((areaLen - curLen), BLOCK);
    checkStatus(bdkCopyBootAreaBlock( (byte FAR1 *)buf, copyLen, checkSum ));
    fwrite( buf, 1, copyLen, fout );
  }
  fclose(fout);
  return( flOK );
}

#ifdef UPDATE_BDK_IMAGE

/*-------------------------------------------------------------------
 *                 b d k U p d a t e B o o t A r e a F i l e
 *
 *  Copy the BDK Image to the DiskOnChip from the file 'fname' starting at
 *  'startUnit', with a size of 'areaLen' bytes and 'signature'.
 *
 *  Note : Blocks in the DiskOnChip are marked with a 4-character signature
 *         followed by a 4-digit hexadecimal number.
 *
 *  Parameters: 'fname'         - pointer to file name
 *              'startUnit'    - start block in image for reading
 *              'areaLen'       - BDK image size
 *              'signature'     - 4-character signature of storage units
 *
 *  global variable input :
 *               bdkVol              - current binary partition record
 *               flash               - flash record enabling media I\O
 *           bdkGlobalStatus     - was this partition accessed before
 *               bdkSavedSignBuffer  - signature offset of previous access
 *               bdkSignOffset       - current signature offset
 *
 *  global variable output :
 *           bdkGlobalStatus     - set to BDK_S_INFO_FOUND
 *               signBuffer          - initialize with given signature
 *               bdkSavedSignBuffer  - save current signatur for next access
 *               bootImageSize       - size of the entire sub partition in bytes
 *               realBootImageSize   - number of units writen in the sub partition
 *               startPartitionBlock - low physical boundry of the partition
 *               endPartitionBlock   - high physical boundry of the partition
 *               startImageBlock     - physical unit number of the first and
 *               endImageBlock            last units marked with the signature
 *               actualUpdateLen     - 0
 *               curUpadateImageAddress - address of last written unit
 *  Return :
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flGeneralFailure    - could not open file
 *      flUnknownMedia      - failed in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flNoSpaceInVolume   - there are 0 units marked with this signature
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW protection was triggerd
 *      flWriteFault        - MTD write fault
 *
 * Routine for BDK stand alone package.
 *-------------------------------------------------------------------*/
FLStatus bdkUpdateBootAreaFile( Sbyte FAR2 *fname, word startUnit,
            dword areaLen   , byte FAR2 *signature )
{
  dword curLen;
  word copyLen;
  FILE *fout;
  byte buf[BLOCK];

  checkStatus(bdkUpdateBootAreaInit( startUnit, areaLen,
                     BDK_COMPLETE_IMAGE_UPDATE, signature ));

  if( (fout = fopen(fname,"rb")) == NULL )
    return(flGeneralFailure);

  for(curLen=0L;( curLen < areaLen );curLen+=BLOCK)
  {
    copyLen = (word)BDK_MIN((areaLen - curLen), BLOCK);
    fread( buf, 1, copyLen, fout );
    checkStatus(bdkUpdateBootAreaBlock( (byte FAR1 *)buf, copyLen ));
  }
  fclose(fout);
  return( flOK );
}
#endif /* UPDATE_BDK_IMAGE  */
#endif /* BDK_IMAGE_TO_FILE */

#ifdef PROTECT_BDK_IMAGE

/*--------------------------------------------------------------------------
 *               p r o t e c t i o n I n i t
 *
 *  Makes suer the volume is mounted before calling protection calls.
 *
 *  Note this routine is called directly by each of the protection routines
 *
 *  return
 *    FLStatus flOK otherwise respective error code.
 *
 *--------------------------------------------------------------------------*/

static FLStatus protectionInit(void)
{
  /* Check that the partition is mounted */
#ifdef MTD_STANDALONE
  dword temp;

  checkStatus(bdkFindDiskOnChip((dword FAR2 *)&temp,(dword FAR2 *)&temp));
#endif /* MTD_STANDALONE */
  checkStatus(bdkMount());
  if (bdkVol->flash->flags & NFTL_ENABLED)
  {
     DEBUG_PRINT(("NFTL does not support protection.\r\n"));
     return flFeatureNotSupported;
  }

  if ((bdkVol->protectionType & PROTECTABLE) == 0)
  {
     DEBUG_PRINT(("Not a protectable partition.\r\n"));
     return flNotProtected;
  }
  return flOK;
}

/*--------------------------------------------------------------------------
 *               p r o t e c t i o n C h a n g e I n i t
 *
 *  Makes sure the volume is mounted before calling protection calls.
 *  Makes sure the protection can be updated and functions arae vailable
 *
 *  Note this routine is called directly by each of the protection routines
 *
 *  return
 *    FLStatus flOK on success non zero otherwise
 *
 *--------------------------------------------------------------------------*/

static FLStatus protectionChangeInit(word * type)
{
  checkStatus(protectionInit());

  if (!(bdkVol->protectionType & CHANGEABLE_PROTECTION))
  {
     DEBUG_PRINT(("Uncheangable protection.\r\n"));
     return flFeatureNotSupported;
  }

  if ((bdkVol->flash->protectionBoundries == NULL)  ||
      (bdkVol->flash->protectionSet       == NULL)  ||
      (bdkVol->flash->protectionKeyInsert == NULL)  ||
      (bdkVol->flash->protectionType      == NULL))
  {
     DEBUG_PRINT(("H/W does not support protection.\r\n"));
     return flFeatureNotSupported;
  }

  /* get the protection type */
  checkStatus(bdkVol->flash->protectionType(bdkVol->flash,
               bdkVol->protectionArea, (word *)type));
  return (bdkVol->flash->protectionKeyInsert(bdkVol->flash,
          bdkVol->protectionArea, (byte *)DEFAULT_KEY));
}

/*--------------------------------------------------------------------------
 *               b d k G e t P r o t e c t i o n T y p e
 *
 *  Return the current partition protection type.
 *
 *
 *  Parameters : 'protectionType' - return the protection type as a
 *                                combination of the following flags:
 *
 *    PROTECTABLE     - A protection area is allocated for this volume
 *    LOCK_ENABLED    - HW Lock signal is enabled.
 *    LOCK_ASSERTED   - HW Lock signal is asserted.
 *    KEY_INSERTED    - Key is currently inserted (protection is down).
 *    READ_PROTECTED  - Area is protected against read operations.
 *    WRITE_PROTECTED - Area is protected against write operations.
 *    CHANGEABLE_PROTECTION - The area is protected against write operations.
 *
 *  global variable input :
 *           bdkGlobalStatus  - was this device found before
 *               bdkVol           - current binary partition record
 *               bdkDocWindow     - if > 0 only this address will be checked
 *
 *  global variable output :
 *               bdkVol           - current binary partition record
 *                   bdkGlobalStatus  - both BDK_S_DOC_FOUND and BDK_S_HEADER_FOUND
 *               flash            - identify flash media and its socket
 *               bdkDocWindow     - DiskOnChip window physical address
 *
 *  Return:
 *     flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - fail in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *      flFeatureNotSupported - The HW protection feature is not supported
 *
 * Routine for both OSAK and the BDK stand alone package.
 *------------------------------------------------------------------------*/
FLStatus     bdkGetProtectionType    (word * protectionType)
{
  FLStatus status;
  status = protectionInit();

  switch (status)
  {
     case flOK:
        if (bdkVol->flash->protectionType==NULL)
           return flFeatureNotSupported;
        checkStatus (bdkVol->flash->protectionType(bdkVol->flash,
                    bdkVol->protectionArea, (word *)protectionType));

        *protectionType &= ~((word)(PROTECTABLE | CHANGEABLE_PROTECTION));
        *protectionType |=  (word)(bdkVol->protectionType & (word)(PROTECTABLE | CHANGEABLE_PROTECTION));
        return status;
     case flNotProtected:
        *protectionType  = 0;
     default:
        return status;
  }
}

/*--------------------------------------------------------------------------
 *                         b d k I n s e r t K e y
 *
 *  Insert the protection key to disable the HW protection.
 *
 *  Parameters : 'key' - The key to send
 *
 *  global variable input :
 *       bdkGlobalStatus  - was this device found before
 *       bdkVol           - current binary partition record
 *       bdkDocWindow     - if > 0 only this address will be checked
 *
 *  global variable output :
 *       bdkVol           - current binary partition record
 *       bdkGlobalStatus  - both BDK_S_DOC_FOUND and BDK_S_HEADER_FOUND
 *       flash            - identify flash media and its socket
 *       bdkDocWindow     - DiskOnChip window physical address
 *
 *  Return:
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - fail in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *      flFeatureNotSupported - The HW protection feature is not supported
 *
 * Routine for both OSAK and the BDK stand alone package.
 *------------------------------------------------------------------------*/
FLStatus bdkInsertKey            (byte FAR1* key)
{
  checkStatus(protectionInit());

  if (bdkVol->flash->protectionKeyInsert==NULL)
     return flFeatureNotSupported;
  return (bdkVol->flash->protectionKeyInsert(bdkVol->flash,
          bdkVol->protectionArea, key));
}

/*--------------------------------------------------------------------------
 *                           b d k R e m o v e K e y
 *
 *  Return the current partition protection type.
 *
 *  Parameters : None
 *
 *  global variable input :
 *       bdkGlobalStatus  - was this device found before
 *       bdkVol           - current binary partition record
 *       bdkDocWindow     - if > 0 only this address will be checked
 *
 *  global variable output :
 *       bdkVol           - current binary partition record
 *       bdkGlobalStatus  - both BDK_S_DOC_FOUND and BDK_S_HEADER_FOUND
 *       flash            - identify flash media and its socket
 *       bdkDocWindow     - DiskOnChip window physical address
 *
 *  Return:
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - fail in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW read protection was triggerd
 *      flFeatureNotSupported - The HW protection feature is not supported
 *
 * Routine for both OSAK and the BDK stand alone package.
 *------------------------------------------------------------------------*/
FLStatus bdkRemoveKey            (void)
{
  checkStatus(protectionInit());

  if ((bdkVol->flash->flags & NFTL_ENABLED) ||
      (bdkVol->flash->protectionKeyRemove==NULL))
     return flFeatureNotSupported;
  return (bdkVol->flash->protectionKeyRemove(bdkVol->flash,
          bdkVol->protectionArea));

}
/*--------------------------------------------------------------------------
 *                           b d k L o c k E n a b l e
 *
 *  Enable or disable the HW LOCK signal.
 *
 *  Note  : The protction key must be off before calling this routine.
 *          While asserted the HW LOCK signal can not be disabled.
 *
 *  Parameters : 'enabled' - LOCK_ENABLED - enables the HW LOCK
 *                           otherwise disabled
 *
 *  global variable input :
 *         bdkGlobalStatus  - was this device found before
 *         bdkVol           - current binary partition record
 *         bdkDocWindow     - if > 0 only this address will be checked
 *
 *  global variable output :
 *         bdkVol           - current binary partition record
 *         bdkGlobalStatus  - both BDK_S_DOC_FOUND and BDK_S_HEADER_FOUND
 *         flash            - identify flash media and its socket
 *         bdkDocWindow     - DiskOnChip window physical address
 *
 *  Return:
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - fail in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW protection was triggerd
 *      flWriteFault        - MTD write fault
 *      flFeatureNotSupported - The HW protection feature is not supported
 *
 * Routine for both OSAK and the BDK stand alone package.
 *------------------------------------------------------------------------*/
FLStatus bdkLockEnable           (byte enabled)
{
  CardAddress low,high;
  word type;
  byte floorNo;

  checkStatus(protectionChangeInit(&type));

  if (enabled == LOCK_ENABLED)
  {
     type |= LOCK_ENABLED;
  }
  else
  {
     type &= ~LOCK_ENABLED;
  }

  for (floorNo=0;floorNo<bdkVol->flash->noOfFloors;floorNo++)
  {
      /* Find boundries */
     checkStatus(bdkVol->flash->protectionBoundries(bdkVol->flash,
              bdkVol->protectionArea,&low,&high,floorNo));

     /* Set new protection values */
     checkStatus(bdkVol->flash->protectionSet(bdkVol->flash,
         bdkVol->protectionArea,(word)((high == 0) ? PROTECTABLE : type),low,high,
         NULL,(byte)((floorNo == bdkVol->flash->noOfFloors - 1) ?
         COMMIT_PROTECTION : DO_NOT_COMMIT_PROTECTION),floorNo));
  }
  return flOK;
}

/*--------------------------------------------------------------------------
 *                          b d k C h a n g e K e y
 *
 *  Change the protection key of a protected binary partition..
 *
 *  Note : The protction key must be off before calling this routine.
 *
 *  Parameters : 'key' - The new protection key.
 *
 *  global variable input :
 *           bdkGlobalStatus  - was this device found before
 *               bdkVol           - current binary partition record
 *               bdkDocWindow     - if > 0 only this address will be checked
 *
 *  global variable output :
 *               bdkVol           - current binary partition record
 *                   bdkGlobalStatus  - both BDK_S_DOC_FOUND and BDK_S_HEADER_FOUND
 *               flash            - identify flash media and its socket
 *               bdkDocWindow     - DiskOnChip window physical address
 *
 *  Return:
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - fail in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW protection was triggerd
 *      flWriteFault        - MTD write fault
 *      flFeatureNotSupported - The HW protection feature is not supported
 *
 * Routine for both OSAK and the BDK stand alone package.
 *------------------------------------------------------------------------*/

FLStatus bdkChangeKey(byte FAR1 * key)
{
  CardAddress low,high;
  word type;
  byte floorNo;

  checkStatus(protectionChangeInit(&type));

  for (floorNo=0;floorNo<bdkVol->flash->noOfFloors;floorNo++)
  {
      /* Find boundries */
     checkStatus(bdkVol->flash->protectionBoundries(bdkVol->flash,
                      bdkVol->protectionArea,&low,&high,floorNo));

     /* Set new protection values */
     checkStatus(bdkVol->flash->protectionSet(bdkVol->flash,
         bdkVol->protectionArea,(word)((high == 0) ? PROTECTABLE : type),
         low,high,key,(byte)((floorNo == bdkVol->flash->noOfFloors - 1)
         ? COMMIT_PROTECTION : DO_NOT_COMMIT_PROTECTION),floorNo));
  }
  return flOK;
}

/*--------------------------------------------------------------------------
 *               b d k S e t P r o t e c t i o n T y p e
 *
 *  Change the current partition protection type.
 *
 *
 *  Parameters : 'protectionType' - change the protection type as a
 *                                combination of the following flags:
 *
 *    PROTECTABLE     - Must be added for the routine to work.
 *    READ_PROTECTED  - Area is protected against read operations.
 *    WRITE_PROTECTED - Area is protected against write operations.
 *
 *  Note - To add extra protection only a combination of the above 3 flags is
 *         aceptable and the PROTECTABLE flag must be on.
 *
 *  global variable input :
 *           bdkGlobalStatus  - was this device found before
 *               bdkVol           - current binary partition record
 *               bdkDocWindow     - if > 0 only this address will be checked
 *
 *  global variable output :
 *               bdkVol           - current binary partition record
 *               bdkGlobalStatus  - both BDK_S_DOC_FOUND and BDK_S_HEADER_FOUND
 *               flash            - identify flash media and its socket
 *               bdkDocWindow     - DiskOnChip window physical address
 *
 *  Return:
 *      flOK                - success
 *      flDriveNotAvailable - DiskOnChip ASIC was not found
 *      flUnknownMedia      - fail in Flash chips recognition
 *      flBadDownload          - DiskOnChip Millennium Plus reported an uncorrectable
 *                            protection violation. This device is unusable.
 *      flBadFormat         - TL format does not exists
 *      flDataError         - MTD read fault.
 *      flHWProtect         - HW protection was triggerd
 *      flWriteFault        - MTD write fault
 *      flFeatureNotSupported - The HW protection feature is not supported
 *
 * Routine for both OSAK and the BDK stand alone package.
 *------------------------------------------------------------------------*/
FLStatus bdkSetProtectionType           (word newType)
{
  CardAddress low,high;
  word type;
  byte floorNo;

  checkStatus(protectionChangeInit(&type));

  if (((newType & (READ_PROTECTED | WRITE_PROTECTED | PROTECTABLE)) != newType) ||
      ((newType & PROTECTABLE) == 0))
     return flBadParameter;

  newType |= type & ~(READ_PROTECTED | WRITE_PROTECTED);

  for (floorNo=0;floorNo<bdkVol->flash->noOfFloors;floorNo++)
  {
     /* Find boundries */
     checkStatus(bdkVol->flash->protectionBoundries(bdkVol->flash,
              bdkVol->protectionArea,&low,&high,floorNo));

     /* Set new protection values */
     checkStatus(bdkVol->flash->protectionSet(bdkVol->flash,
         bdkVol->protectionArea,(word)((high == 0) ? PROTECTABLE : newType),
         low,high,NULL,(byte)((floorNo == bdkVol->flash->noOfFloors - 1)
         ? COMMIT_PROTECTION : DO_NOT_COMMIT_PROTECTION),floorNo));
  }
  return flOK;
}

#endif /* PROTECT_BDK_IMAGE */

#if (defined(HW_OTP) && defined (MTD_STANDALONE))
/*----------------------------------------------------------------------*/
/*                   b d k G e t U n i q u e I d                        */
/*                                                                      */
/* Retreave the device 16 bytes unique ID.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      buffer  : buffer to read into.                                  */
/*                                                                      */
/* Returns:                                                             */
/*      flOK                - success                                   */ 
/*      flDriveNotAvailable - DiskOnChip ASIC was not found             */
/*      flUnknownMedia      - Failed in Flash chips recognition         */
/*      flBadDownload       - MdocPlus device has unrecoverable         */  
/*                            protection violation.                     */
/*      flHWProtection      - HW read protection violation.             */ 
/*      flTimedOut          - Flash delay not long enough.              */
/*----------------------------------------------------------------------*/

FLStatus bdkGetUniqueID(byte FAR1* buf)
{
   dword temp;

   checkStatus(bdkFindDiskOnChip((dword FAR2 *)&temp,(dword FAR2 *)&temp));
   if (bdkVol->flash->getUniqueId == NULL)
      return flFeatureNotSupported;
   return(bdkVol->flash->getUniqueId(bdkVol->flash,buf));
}

/*----------------------------------------------------------------------*/
/*                       b d k R e a d O T P                            */
/*                                                                      */
/* Read data from the customer OTP.                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      offset  : Offset from the beginning of OTP area to read from.   */
/*      buffer  : buffer to read into.                                  */
/*      length  : number of bytes to read.                              */
/*                                                                      */
/* Returns:                                                             */
/*      flOK                - success                                   */ 
/*      flDriveNotAvailable - DiskOnChip ASIC was not found             */
/*      flUnknownMedia      - Failed in Flash chips recognition         */
/*      flBadDownload       - MdocPlus device has unrecoverable         */  
/*                            protection violation.                     */
/*      flHWProtection      - HW read protection violation.             */ 
/*      flTimedOut          - Flash delay not long enough.              */
/*----------------------------------------------------------------------*/

FLStatus bdkReadOtp(word offset,byte FAR1 * buffer,word length)
{
   dword temp;

   checkStatus(bdkFindDiskOnChip((dword FAR2 *)&temp,(dword FAR2 *)&temp));
   if (bdkVol->flash->readOTP == NULL)
      return flFeatureNotSupported;
   return(bdkVol->flash->readOTP(bdkVol->flash,offset,buffer,length));
}

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                 b d k W r i t e A n d L o c k O T P                  */
/*                                                                      */
/* Write and lock the customer OTP.                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      buffer  : buffer to write from.                                 */
/*      length  : number of bytes to write.                             */
/*                                                                      */
/* Note - Once writen (even a single byte) the entire section is        */
/*        locked forever. The data is written with EDC.                 */
/*                                                                      */
/* Returns:                                                             */
/*      flOK                - success                                   */ 
/*      flDriveNotAvailable - DiskOnChip ASIC was not found             */
/*      flUnknownMedia      - Failed in Flash chips recognition         */
/*      flBadDownload       - MdocPlus device has unrecoverable         */  
/*                            protection violation.                     */
/*      flHWProtection      - HW protection violation.                  */ 
/*      flTimedOut          - Flash delay not long enough.              */
/*----------------------------------------------------------------------*/

FLStatus bdkWriteAndLockOtp(const byte FAR1 * buffer,word length)
{
   dword temp;

   checkStatus(bdkFindDiskOnChip((dword FAR2 *)&temp,(dword FAR2 *)&temp));
   if (bdkVol->flash->writeOTP == NULL)
      return flFeatureNotSupported;
   return(bdkVol->flash->writeOTP(bdkVol->flash,buffer,length));
}
#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                        b d k G e t O t p S i z e                     */
/*                                                                      */
/* Returns the size and state of the OTP area.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      sectionSize : Total OTP size.                                   */
/*      usedSize    : Used OTP size.                                    */
/*      locked      : Lock state (LOCKED_OTP for locked).               */
/*                                                                      */
/* Returns:                                                             */
/*      flOK                - success                                   */ 
/*      flDriveNotAvailable - DiskOnChip ASIC was not found             */
/*      flUnknownMedia      - Failed in Flash chips recognition         */
/*      flBadDownload       - MdocPlus device has unrecoverable         */  
/*                            protection violation.                     */
/*      flHWProtection      - HW read protection violation.             */ 
/*      flTimedOut          - Flash delay not long enough.              */
/*----------------------------------------------------------------------*/

FLStatus bdkGetOtpSize(dword FAR2* sectionSize, dword FAR2* usedSize, word FAR2* locked)
{
   dword temp;

   checkStatus(bdkFindDiskOnChip((dword FAR2 *)&temp,(dword FAR2 *)&temp));
   if (bdkVol->flash->otpSize == NULL)
      return flFeatureNotSupported;
   return(bdkVol->flash->otpSize(bdkVol->flash,sectionSize,usedSize,locked));
}
#endif /* HW_OTP */
#ifdef BDK_ACCESS

/*----------------------------------------------------------------------*/
/*                     b d k C a l l                                    */
/*                                                                      */
/* Common entry-point to all binary partition functions.                */
/*                                                                      */
/* Note : the error codes and global variable changed by this routin    */
/* depened on the functionNo parameter and can be deduced from the      */
/* coresponding routine in the BDK package or from the OSAK manual      */
/*                                                                      */
/* Parameters:                                                          */
/*     functionNo : file-system function code (listed below)            */
/*     ioreq        : IOreq structure                                   */
/*      flash      : flash record supplied hardware information and     */
/*               flash access routines                                  */
/* Returns:                                                             */
/*     FLStatus     : 0 on success, otherwise failed                    */
/*                                                                      */
/* Routine for OSAK package.                                            */
/*----------------------------------------------------------------------*/

FLStatus bdkCall(FLFunctionNo functionNo, IOreq FAR2 *ioreq, FLFlash* flash)
{
  FLStatus     status;
  BDKStruct*     bdkParam = (BDKStruct*)ioreq->irData;
  byte volNo;

  globalSocketNo     = FL_GET_SOCKET_FROM_HANDLE(ioreq);
  globalPartitionNo  = FL_GET_PARTITION_FROM_HANDLE(ioreq);

     /* convert drive handle to the appropriate binary partition record */

  if (globalSocketNo>SOCKETS)
    return flBadDriveHandle;
  if (globalPartitionNo>MAX_BINARY_PARTITIONS_PER_DRIVE)
    return flBadDriveHandle;

  volNo = handleTable[globalSocketNo][globalPartitionNo];

  if (volNo!=BDK_INVALID_VOLUME_HANDLE) /* not first access to this device */
  {
     bdkVol = &bdkVols[volNo];
  }
  else       /* first access to this device */
  {
     bdkVol                  = &bdkVols[noOfPartitions];
     bdkVol->flash           = flash;
     bdkVol->bdkGlobalStatus = BDK_S_DOC_FOUND;
  }

#ifdef VERIFY_WRITE
  /* Set binary partition verify write state */
  flash->socket->verifyWrite = flVerifyWrite[globalSocketNo][globalPartitionNo+MAX_TL_PARTITIONS];
#endif /* VERIFY_WRITE */

  /* Call the proper binary partition function */

  switch (functionNo)
  {
     case FL_BINARY_READ_INIT:

        bdkVol->bdkEDC = bdkParam->flags & EDC;
        bdkVol->bdkSignOffset = bdkParam->signOffset;
        return bdkCopyBootAreaInit((word)bdkParam->startingBlock,
                                   bdkParam->length,bdkParam->oldSign);
     case FL_BINARY_READ_BLOCK:

        return bdkCopyBootAreaBlock(bdkParam->bdkBuffer,
                                    (word)bdkParam->length,NULL);

     case FL_BINARY_PARTITION_INFO:
     {
        dword unitSize;

#ifndef NT5PORT
		int volNo;
#else /*NT5PORT*/
        int nIndex;
#endif /*NT5PORT*/

        status = bdkGetBootPartitionInfo((word)bdkParam->startingBlock,
                 &(bdkParam->startingBlock), &(bdkParam->length),&unitSize,
                 bdkParam->oldSign);
        ioreq->irLength = (long)(bdkVol->endPartitionBlock -
                          bdkVol->startPartitionBlock + 1)<<(long)bdkVol->flash->erasableBlockSizeBits;
        bdkParam->flags = 0;

#ifndef NT5PORT
        for (volNo = 0;volNo < MAX_BINARY_PARTITIONS_PER_DRIVE;volNo++)
        {
           if (handleTable[globalSocketNo][volNo]!=
                          BDK_INVALID_VOLUME_HANDLE)
           bdkParam->flags++;
        }
#else /*NT5PORT*/
        for (nIndex = 0;nIndex < MAX_BINARY_PARTITIONS_PER_DRIVE; nIndex++)
        {
           if (handleTable[globalSocketNo][nIndex]!=
                          BDK_INVALID_VOLUME_HANDLE)
           bdkParam->flags++;
        }
#endif /*NT5PORT*/

        return status;
     }
#ifdef UPDATE_BDK_IMAGE

     case FL_BINARY_WRITE_INIT:
     bdkVol->bdkEDC        = bdkParam->flags & EDC;
     bdkVol->bdkSignOffset = bdkParam->signOffset;
     return bdkUpdateBootAreaInit((word)bdkParam->startingBlock, bdkParam->length,
                         bdkParam->flags , bdkParam->oldSign);
     case FL_BINARY_WRITE_BLOCK:
     if (bdkParam->flags & ERASE_BEFORE_WRITE)
     {
        bdkVol->updateImageFlag |= ERASE_BEFORE_WRITE;
     }
     else
     {
        bdkVol->updateImageFlag &= ~ ERASE_BEFORE_WRITE;
     }
     return bdkUpdateBootAreaBlock(bdkParam->bdkBuffer, (word)bdkParam->length);

#ifdef CREATE_BDK_IMAGE
     case FL_BINARY_CREATE:

       bdkVol->bdkSignOffset = bdkParam->signOffset;
       return bdkCreateBootArea((word)bdkParam->length,bdkParam->oldSign,
                    bdkParam->newSign);
#endif /* CREATE_BDK_IMAGE */
#ifdef ERASE_BDK_IMAGE

     case FL_BINARY_ERASE:

       bdkVol->bdkSignOffset = bdkParam->signOffset;
       return bdkEraseBootArea((word)bdkParam->startingBlock,(word)bdkParam->length,
                      bdkParam->oldSign);
#endif /* ERASE_BDK_IMAGE */
#endif /* UPDATE_BDK_IMAGE */
#ifdef PROTECT_BDK_IMAGE
     case FL_BINARY_PROTECTION_GET_TYPE:
        {
           word tmpFlags;
           checkStatus ( bdkGetProtectionType    (&tmpFlags));
           ioreq->irFlags = (unsigned) tmpFlags;
           return flOK;  
        }             

     case FL_BINARY_PROTECTION_SET_TYPE:
        return bdkSetProtectionType    ((word)ioreq->irFlags);

     case FL_BINARY_PROTECTION_INSERT_KEY:
        return bdkInsertKey            ((byte FAR1*)ioreq->irData);

     case FL_BINARY_PROTECTION_REMOVE_KEY:
        return bdkRemoveKey            ();

     case FL_BINARY_PROTECTION_CHANGE_KEY:
        return bdkChangeKey            ((byte FAR1*)ioreq->irData);

     case FL_BINARY_PROTECTION_CHANGE_LOCK:
        return bdkLockEnable           ((byte)ioreq->irFlags);
#endif /* PROTECT_BDK_IMAGE */
     default:     /* not a binary partition routine */
     return flBadFunction;
  }
}
#endif /* BDK_ACCESS */

#endif /* BDK_ACCESS || MTD_STANDALONE || ACCESS_BDK_IMAGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\dosformt.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOSFORMT.C_V  $
 * 
 *    Rev 1.7   Feb 19 2002 20:59:12   oris
 * Replaced dosformt.h with blockdev.h
 * 
 *    Rev 1.6   Jan 29 2002 20:07:56   oris
 * Removed prototype of flBuildGeometry (already found in blockdev.h).
 * 
 *    Rev 1.5   Jan 28 2002 21:24:58   oris
 * Removed the use of back-slashes in macro definitions.
 * 
 *    Rev 1.4   Apr 16 2001 13:33:44   oris
 * Removed warrnings.
 * 
 *    Rev 1.3   Apr 09 2001 15:06:42   oris
 * End with an empty line.
 * 
 *    Rev 1.2   Apr 01 2001 07:44:48   oris
 * Updated copywrite notice
 * 
 *    Rev 1.1   Feb 14 2001 02:00:26   oris
 * Added oldFormat.
 *
 *    Rev 1.0   Feb 02 2001 13:48:44   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#include "fltl.h"
#ifdef FORMAT_VOLUME

#include "blockdev.h"

#define FAT12bit  (LE4(bpb->totalSectorsInVolume) < 4086LU * bpb->sectorsPerCluster)

 /*----------------------------------------------------------------------*/
/*      	      g e t D r i v e G e o m e t r y			            */
/*									                                    */
/* Calculates the geometry parameters for BIOS/DOS media		        */
/*                                                                      */
/* Parameters:                                                          */
/*	vol		  : Pointer identifying drive			                    */
/*  oldFormat : Format media with coluster size of 1 sector             */
/*                                                                      */
/* Returns:                                                             */
/*	bpb		: volume BIOS parameter block			                    */
/*	cylinders	: Number of "cylinders" in volume		                */
/*	noOfFATs	: Number of FAT copies				                    */
/*----------------------------------------------------------------------*/

static void getDriveGeometry(TL vol,
			     BPB FAR2 *bpb,
			     dword FAR2 *cylinders,
			     unsigned noOfFATs,
				 FLBoolean oldFormat)
{
  dword heads, sectors;
  long int sizeInSectors, noOfClusters;
  int directorySectors, sectorsPerFAT;
  int minClusterSize;
  SectorNo sectorAlignment;

  SectorNo capacity = vol.sectorsInVolume(vol.rec); /* Volume size in sectors */

  minClusterSize = ((oldFormat == TRUE) ? 1: MIN_CLUSTER_SIZE);

  flBuildGeometry( (dword)capacity, (dword FAR2 *)cylinders,
                 (dword FAR2 *)&heads, (dword FAR2 *)&sectors,oldFormat);

  if (vol.recommendedClusterInfo)
    vol.recommendedClusterInfo(vol.rec,&minClusterSize,&sectorAlignment);

  toLE2(bpb->sectorsPerTrack,(word) sectors);
  toLE2(bpb->noOfHeads,(word) heads);
  toUNAL2(bpb->bytesPerSector,SECTOR_SIZE);
  bpb->noOfFATS = (byte)noOfFATs;
  bpb->mediaDescriptor = 0xf8;	/* hard disk */
  toLE4(bpb->noOfHiddenSectors,sectors);

  sizeInSectors = (long) (*cylinders) * heads * sectors - sectors;

  toLE4(bpb->totalSectorsInVolume,sizeInSectors);
  toUNAL2(bpb->totalSectorsInVolumeDOS3,
         (word)(sizeInSectors > 65535l ? 0 : sizeInSectors));

  noOfClusters = sizeInSectors / minClusterSize;
  for (bpb->sectorsPerCluster = (byte)minClusterSize;
       noOfClusters > (!oldFormat && bpb->sectorsPerCluster < 8 ? 32766l : 65534l);
       bpb->sectorsPerCluster <<= 1, noOfClusters >>= 1);

  if (FAT12bit)
    sectorsPerFAT =
      (word) ((((noOfClusters + 2L) * 3 + 1) / 2 - 1) / SECTOR_SIZE + 1);
  else
    sectorsPerFAT =
      (word) (((noOfClusters + 2L) * 2 - 1) / SECTOR_SIZE + 1);
  toLE2(bpb->sectorsPerFAT,(word)sectorsPerFAT);

  directorySectors = (int)(capacity / 200);
  if (directorySectors < 1) directorySectors = 1;
  if (directorySectors > 15) directorySectors = 15;
  toUNAL2(bpb->rootDirectoryEntries,
         (word)(directorySectors * (SECTOR_SIZE / sizeof(DirectoryEntry))));

  if (vol.recommendedClusterInfo) {
    int sectorPadding = (int)((sectorAlignment - (sectors + 1 + noOfFATs * sectorsPerFAT + directorySectors)) % bpb->sectorsPerCluster);

    if (sectorPadding < 0)
      sectorPadding += bpb->sectorsPerCluster;
    toLE2(bpb->reservedSectors,sectorPadding + 1);
  }
  else
    toLE2(bpb->reservedSectors,1);
}


/*----------------------------------------------------------------------*/
/*      	 c r e a t e M a s t e r B o o t R e c o r d		*/
/*									*/
/* Creates the Master Boot Record (Sector 0)				*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	bpb		: volume BIOS parameter block			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*	cylinders	: Number of "cylinders" in volume		*/
/*----------------------------------------------------------------------*/

static FLStatus createMasterBootRecord(TL vol,
				     BPB *bpb,
				     dword cylinders)
{
  static byte bootCode[] = {
    0xFA, 0x33, 0xC0, 0x8E, 0xD0, 0xBC, 0x00, 0x7C,
    0x8B, 0xF4, 0x50, 0x07, 0x50, 0x1F, 0xFB, 0xFC,
    0xBF, 0x00, 0x06, 0xB9, 0x00, 0x01, 0xF2, 0xA5,
    0xEA, 0x1D, 0x06, 0x00, 0x00, 0xBE, 0xBE, 0x07,
    0xB3, 0x04, 0x80, 0x3C, 0x80, 0x74, 0x0E, 0x80,
    0x3C, 0x00, 0x75, 0x1C, 0x83, 0xC6, 0x10, 0xFE,
    0xCB, 0x75, 0xEF, 0xCD, 0x18, 0x8B, 0x14, 0x8B,
    0x4C, 0x02, 0x8B, 0xEE, 0x83, 0xC6, 0x10, 0xFE,
    0xCB, 0x74, 0x1A, 0x80, 0x3C, 0x00, 0x74, 0xF4,
    0xBE, 0x8B, 0x06, 0xAC, 0x3C, 0x00, 0x74, 0x0B,
    0x56, 0xBB, 0x07, 0x00, 0xB4, 0x0E, 0xCD, 0x10,
    0x5E, 0xEB, 0xF0, 0xEB, 0xFE, 0xBF, 0x05, 0x00,
    0xBB, 0x00, 0x7C, 0xB8, 0x01, 0x02, 0x57, 0xCD,
    0x13, 0x5F, 0x73, 0x0C, 0x33, 0xC0, 0xCD, 0x13,
    0x4F, 0x75, 0xED, 0xBE, 0xA3, 0x06, 0xEB, 0xD3,
    0xBE, 0xC2, 0x06, 0xBF, 0xFE, 0x7D, 0x81, 0x3D,
    0x55, 0xAA, 0x75, 0xC7, 0x8B, 0xF5, 0xEA, 0x00,
    0x7C, 0x00, 0x00, 0x49, 0x6E, 0x76, 0x61, 0x6C,
    0x69, 0x64, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69,
    0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x61, 0x62,
    0x6C, 0x65, 0x00, 0x45, 0x72, 0x72, 0x6F, 0x72,
    0x20, 0x6C, 0x6F, 0x61, 0x64, 0x69, 0x6E, 0x67,
    0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
    0x6E, 0x67, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65,
    0x6D, 0x00, 0x4D, 0x69, 0x73, 0x73, 0x69, 0x6E,
    0x67, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74,
    0x69, 0x6E, 0x67, 0x20, 0x73, 0x79, 0x73, 0x74,
    0x65, 0x6D};

  /* create partition table */
  PartitionTable partitionTable;
  Partition* ptEntry;

  tffsset(&partitionTable,0,sizeof partitionTable);
  tffscpy(&partitionTable,bootCode,sizeof bootCode);

  ptEntry = partitionTable.ptEntry;
  ptEntry->activeFlag = 0x80;	/* bootable */
  if (LE2(bpb->noOfHeads) > 1) {
    ptEntry->startingHead = 1;
    toLE2(ptEntry->startingCylinderSector,CYLINDER_SECTOR(0,1));
  }
  else {
    ptEntry->startingHead = 0;
    toLE2(ptEntry->startingCylinderSector,CYLINDER_SECTOR(1,1));
  }
  ptEntry->type = FAT12bit ? 1 : 4;
  ptEntry->endingHead = LE2(bpb->noOfHeads) - 1;
  toLE2(ptEntry->endingCylinderSector,
    (word)CYLINDER_SECTOR((cylinders - 1),LE2(bpb->sectorsPerTrack)));
  toUNAL4(ptEntry->startingSectorOfPartition,LE2(bpb->sectorsPerTrack));
  toUNAL4(ptEntry->sectorsInPartition,LE4(bpb->totalSectorsInVolume));

  toLE2(partitionTable.signature,PARTITION_SIGNATURE);

  return vol.writeSector(vol.rec,0,&partitionTable);
}


/*----------------------------------------------------------------------*/
/*      	     c r e a t e D O S B o o t S e c t o r		*/
/*									*/
/* Creates the DOS boot sector						*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	bpb		: volume BIOS parameter block			*/
/*	volumeId	: 32-bit volume id				*/
/*	volumeLabel	: volume label					*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus createDOSbootSector(TL vol,
				  BPB *bpb,
				  const byte FAR1 *volumeId,
				  const byte FAR1 *volumeLabel)
{
  DOSBootSector bootSector;

  tffsset(&bootSector,0,sizeof bootSector);
  bootSector.physicalDriveNo = 0x80;
  bootSector.extendedBootSignature = 0x29;
  tffscpy(bootSector.volumeId,volumeId,sizeof bootSector.volumeId);
  tffsset(bootSector.volumeLabel,' ',sizeof bootSector.volumeLabel);
  if (volumeLabel)
    tffscpy(bootSector.volumeLabel,volumeLabel,sizeof bootSector.volumeLabel);
  tffscpy(bootSector.systemId,
	  FAT12bit ? "FAT12   " : "FAT16   ",
	  sizeof bootSector.systemId);

  bootSector.bpb = *bpb;
  bootSector.bpb.jumpInstruction[0] = 0xe9;
  tffscpy(bootSector.bpb.OEMname,"MSystems",sizeof bootSector.bpb.OEMname);
  toLE2(bootSector.signature,PARTITION_SIGNATURE);

  return vol.writeSector(vol.rec,(SectorNo) LE4(bpb->noOfHiddenSectors),&bootSector);
}


/*----------------------------------------------------------------------*/
/*      	          c r e a t e F A T s				*/
/*									*/
/* Creates the FAT's							*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	bpb		: volume BIOS parameter block			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus createFATs(TL vol, BPB *bpb)
{
  int iFAT;

  SectorNo sectorNo = (SectorNo) (LE4(bpb->noOfHiddenSectors) +
				  LE2(bpb->reservedSectors));

  /* create the FATs */
  for (iFAT = 0; iFAT < bpb->noOfFATS; iFAT++) {
    int iSector;
    byte FATEntry[SECTOR_SIZE];

    for (iSector = 0; iSector < LE2(bpb->sectorsPerFAT); iSector++) {
      tffsset(FATEntry,0,SECTOR_SIZE);
      if (iSector == 0) {		/* write the reserved FAT entries */
	FATEntry[0] = bpb->mediaDescriptor;
	FATEntry[1] = 0xff;
	FATEntry[2] = 0xff;
	if (!FAT12bit)
	  FATEntry[3] = 0xff;
      }
      checkStatus(vol.writeSector(vol.rec,sectorNo++,FATEntry));
    }
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	     c r e a t e R o o t D i r e c t o r y		*/
/*									*/
/* Creates the root directory						*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	bpb		: volume BIOS parameter block			*/
/*	volumeLabel	: volume label					*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus createRootDirectory(TL vol,
				  BPB *bpb,
				  const byte FAR1 *volumeLabel)
{
  int iEntry;

  SectorNo sectorNo = (SectorNo) (LE4(bpb->noOfHiddenSectors) +
				  LE2(bpb->reservedSectors) +
				  bpb->noOfFATS * LE2(bpb->sectorsPerFAT));

  /* create the root directory */
  for (iEntry = 0; iEntry < UNAL2(bpb->rootDirectoryEntries);
       iEntry += (SECTOR_SIZE / sizeof(DirectoryEntry))) {
    DirectoryEntry rootDirectorySector[SECTOR_SIZE / sizeof(DirectoryEntry)];

    tffsset(rootDirectorySector,0,SECTOR_SIZE);
    if (iEntry == 0 && volumeLabel) {
      tffsset(rootDirectorySector[0].name,' ',sizeof rootDirectorySector[0].name);
      tffscpy(rootDirectorySector[0].name,volumeLabel,sizeof rootDirectorySector[0].name);
      rootDirectorySector[0].attributes = 0x28;	/* VOL + ARC */
      toLE2(rootDirectorySector[0].updateTime,0);
      toLE2(rootDirectorySector[0].updateDate,0x21);	/* 1/1/80 */
    }
    checkStatus(vol.writeSector(vol.rec,sectorNo++,rootDirectorySector));
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	          f l D o s F o r m a t				                */
/*								                        	            */
/* Writes a DOS-FAT file system on the Flash volume			            */
/*									                                    */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			                        */
/*	formatParams	: Address of FormatParams structure to use	        */
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		                */
/*----------------------------------------------------------------------*/

FLStatus flDosFormat(TL vol, BDTLPartitionFormatParams FAR1 *formatParams)
{
  dword cylinders;
  BPB bpb;

  getDriveGeometry(&vol,&bpb,&cylinders,formatParams->noOfFATcopies,
	          (formatParams->flags & TL_OLD_FORMAT) ? TRUE : FALSE);

  checkStatus(createMasterBootRecord(&vol,&bpb,cylinders));

  checkStatus(createDOSbootSector(&vol,&bpb,formatParams->volumeId,formatParams->volumeLabel));

  checkStatus(createFATs(&vol,&bpb));

  checkStatus(createRootDirectory(&vol,&bpb,formatParams->volumeLabel));

  return flOK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flbase.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLBASE.C_V  $
 * 
 *    Rev 1.3   Sep 15 2001 23:45:32   oris
 * Changed BIG_ENDIAN to FL_BIG_ENDIAN
 * 
 *    Rev 1.2   Apr 09 2001 15:07:34   oris
 * End with an empty line.
 * 
 *    Rev 1.1   Apr 01 2001 07:45:30   oris
 * Updated copywrite notice
 * 
 *    Rev 1.0   Feb 04 2001 11:05:28   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#include "flbase.h"

#ifdef FL_BIG_ENDIAN

/*----------------------------------------------------------------------*/
/*         Little / Big - Endian Conversion Routines			*/
/*----------------------------------------------------------------------*/

void toLEushort(unsigned char FAR0 *le, unsigned short n)
{
  le[1] = (unsigned char)(n >> 8);
  le[0] = (unsigned char)n;
}


unsigned short fromLEushort(unsigned char const FAR0 *le)
{
  return ((unsigned short)le[1] << 8) + le[0];
}


void toLEulong(unsigned char FAR0 *le, unsigned long n)
{
  le[3] = (unsigned char)(n >> 24);
  le[2] = (unsigned char)(n >> 16);
  le[1] = (unsigned char)(n >> 8);
  le[0] = (unsigned char)n;
}

unsigned long fromLEulong(unsigned char const FAR0 *le)
{
  return ((unsigned long)le[3] << 24) +
	 ((unsigned long)le[2] << 16) +
	 ((unsigned long)le[1] << 8) +
	 le[0];
}

extern void copyShort(unsigned char FAR0 *to, unsigned char const FAR0 *from)
{
  to[0] = from[0];
  to[1] = from[1];
}

extern void copyLong(unsigned char FAR0 *to, unsigned char const FAR0 *from)
{
  to[0] = from[0];
  to[1] = from[1];
  to[2] = from[2];
  to[3] = from[3];
}


#else

void toUNAL(unsigned char FAR0 *unal, unsigned short n)
{
  unal[1] = (unsigned char)(n >> 8);
  unal[0] = (unsigned char)n;
}


unsigned short fromUNAL(unsigned char const FAR0 *unal)
{
  return ((unsigned short)unal[1] << 8) + unal[0];
}


void toUNALLONG(Unaligned FAR0 *unal, unsigned long n)
{
  toUNAL(unal[0],(unsigned short)n);
  toUNAL(unal[1],(unsigned short)(n >> 16));
}


unsigned long fromUNALLONG(Unaligned const FAR0 *unal)
{
  return fromUNAL(unal[0]) +
	 ((unsigned long)fromUNAL(unal[1]) << 16);
}

#endif /* FL_BIG_ENDIAN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\dosformt.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/DOSFORMT.H_V  $
 * 
 *    Rev 1.2   Feb 19 2002 20:59:22   oris
 * Moved fltl.h include directive to the head of the file.
 *
 *    Rev 1.1   Apr 01 2001 07:45:06   oris
 * Updated copywrite notice
 *
 *    Rev 1.0   Feb 02 2001 13:51:48   oris
 * Initial revision.
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef DOSFORMT_H
#define DOSFORMT_H

#include "flformat.h"
#include "fltl.h"

/* The BIOS parameter block (a part of the boot sector)		*/
/* Note that this is NOT the customary definition of the BPB    */
/* (customary is to start it on 'bytesPerSector'). To avoid the */
/* nuisance of a structure that starts at an odd offset, we add */
/* the first 11 bytes of the boot sector here.			*/
typedef struct {
  unsigned char	jumpInstruction[3];
  char		OEMname[8];
  Unaligned	bytesPerSector;
  unsigned char	sectorsPerCluster;
  LEushort	reservedSectors;
  unsigned char	noOfFATS;
  Unaligned	rootDirectoryEntries;
  Unaligned	totalSectorsInVolumeDOS3;
  unsigned char	mediaDescriptor;
  LEushort	sectorsPerFAT;
  LEushort	sectorsPerTrack;
  LEushort	noOfHeads;
  LEulong	noOfHiddenSectors;
  LEulong	totalSectorsInVolume;
} BPB;


typedef struct {
  BPB		bpb;
  unsigned char	physicalDriveNo;
  char		reserved0;
  char		extendedBootSignature;
  char		volumeId[4];
  char		volumeLabel[11];
  char		systemId[8];
  char		bootstrap[448];
  LEushort	signature;
} DOSBootSector;


typedef struct {
  char		name[11];
  unsigned char	attributes;		/* mapped below */
  unsigned char	reserved[10];
  LEushort	updateTime;
	/* The date field is encoded as follows:	      		*/
	/* 	bit 0-4:	Day of month (1-31)			*/
	/* 	bit 5-8:	Month (1-12)				*/
	/*	bit 9-15:	Year relative to 1980			*/
  LEushort	updateDate;
	/* The DOS time field is encoded as follows:			*/
	/*	bit 0-4:	seconds divided by 2 (0-29)		*/
	/*      bit 5-10:	minutes (0-59)				*/
	/*	bit 11-15:	hours (0-23)				*/
  LEushort	startingCluster;
  LEulong	fileSize;
} DirectoryEntry;


/* Directory entry attribute bits */

#define	ATTR_READ_ONLY	1
#define	ATTR_HIDDEN	2
#define	ATTR_SYSTEM	4
#define	ATTR_VOL_LABEL	8
#define	ATTR_DIRECTORY	0x10
#define	ATTR_ARCHIVE	0x20

#define DIRECTORY_ENTRY_SIZE	sizeof(DirectoryEntry)

#define DIRECTORY_ENTRIES_PER_SECTOR	(SECTOR_SIZE / DIRECTORY_ENTRY_SIZE)

#define	NEVER_USED_DIR_ENTRY	0
#define	DELETED_DIR_ENTRY	((char) 0xe5)

/* FAT definitions */

#define	FAT_FREE	 0
#define	FAT_BAD_CLUSTER	 0xfff7
#define	FAT_LAST_CLUSTER 0xffff		/* actually any of 0xfff8-0xffff */

/* Partition table definitions */

#define PARTITION_SIGNATURE	0xaa55

#define CYLINDER_SECTOR(cylinder,sector) ((sector) + ((cylinder & 0xff) << 8) + ((cylinder & 0x300) >> 2))

#define FAT12_PARTIT 0x01
#define FAT16_PARTIT 0x04
#define EX_PARTIT    0x05
#define DOS4_PARTIT  0x06
#define MAX_PARTITION_DEPTH 8

typedef struct {
  /* First partition entry starts here. We do not map it as a	*/
  /* separate structure because it is not longword aligned	*/
  unsigned char	activeFlag;	/* 80h = bootable */
  unsigned char startingHead;
  LEushort	startingCylinderSector;
  char		type;
  unsigned char	endingHead;
  LEushort	endingCylinderSector;
  Unaligned4	startingSectorOfPartition;
  Unaligned4	sectorsInPartition;
  /* Partition entries 2,3 and 4 are structured as the 1st partition */
} Partition;

typedef struct {
  char          reserved1[0x1A6];
  Unaligned4      passwordInfo[3];  /* M-Systems proprietary */
  char          reserved2[0xC];   /* NT4 or NT5 signature place */

  /* First partition entry starts here. We do not map it as a	*/
  /* separate structure because it is not longword aligned	*/
  Partition ptEntry[4];
  LEushort	signature;	/* = PARTITION_SIGNATURE */
} PartitionTable;

#ifdef FORMAT_VOLUME

extern FLStatus flDosFormat(TL *, BDTLPartitionFormatParams FAR1 *formatParams);

#endif /* FORMAT_VOLUME */

#endif /* DOSFORMT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\fatfilt.h ===
/******************************************************************************* 
 *                                                                             * 
 *                         M-Systems Confidential                              * 
 *           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001        * 
 *                         All Rights Reserved                                 * 
 *                                                                             * 
 ******************************************************************************* 
 *                                                                             * 
 *                         NOTICE OF M-SYSTEMS OEM                             * 
 *                         SOFTWARE LICENSE AGREEMENT                          * 
 *                                                                             * 
 *  THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE AGREEMENT       * 
 *  BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT FOR THE SPECIFIC    * 
 *  TERMS AND CONDITIONS OF USE, OR CONTACT M-SYSTEMS FOR LICENSE              * 
 *  ASSISTANCE:                                                                * 
 *  E-MAIL = info@m-sys.com                                                    * 
 *                                                                             * 
 *******************************************************************************
 *                                                                             * 
 *                         Module: FATFILT                                     * 
 *                                                                             * 
 *  This module implements installable FAT12/16 filters. It supports up to     *
 *  SOCKETS sockets, with up to FL_MAX_DISKS_PER_SOCKET disks per socket.      * 
 *  Each disk can contain up to FL_MAX_PARTS_PER_DISK partitions on it, with   * 
 *  maximum depth of partition nesting in extended partitions equal to         * 
 *  MAX_PARTITION_DEPTH.                                                       *
 *                                                                             * 
 *  In order for this module to work, disks must be abs.mounted rather then    * 
 *  mounted. In latter case, this module won't detect any of disk's            * 
 *  partitions, and won't install FAT filters.                                 * 
 *                                                                             * 
 *  This module uses more then 512 bytes of stack space in case if MALLOC is   * 
 *  not enabled.                                                               * 
 *                                                                             * 
 *******************************************************************************/

/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FATFILT.H_V  $
 * 
 *    Rev 1.3   Apr 10 2001 23:54:52   oris
 * Removed FL_MAX_DISKS_PER_SOCKET  definition.
 * 
 *    Rev 1.2   Apr 09 2001 15:01:00   oris
 * Change static allocation to dynamic allocations.
 * 
 *    Rev 1.1   Apr 01 2001 07:51:24   oris
 * New implementation of fat filter.
 * 
 *    Rev 1.0   19 Feb 2001 21:16:14   andreyk
 * Initial revision.
 */


#ifndef FLFF_H
#define FLFF_H



#include "dosformt.h"
#include "flreq.h"




/* number of entries in disk's partition table */

#define  FL_PART_TBL_ENTRIES  4

/* max number of partitions (filesystem volumes) per disk */
 
#define  FL_MAX_PARTS_PER_DISK  (FL_PART_TBL_ENTRIES + MAX_PARTITION_DEPTH)




/* 
 * Generic 'initialization status' type 
 */

typedef enum { 

    flStateNotInitialized = 0, 
    flStateInitInProgress = 1, 
    flStateInitialized    = 2 

    } FLState; 


/* 
 * Disk partition (filesystem volume). Multiple partitions are allowed
 * on the disk.
 */

typedef struct {

    int        handle;             /* disk's TFFS handle                  */
    int        type;               /* FAT16_PARTIT                        */
    int        flags;              /* VOLUME_12BIT_FAT etc.               */
    FLBoolean  ffEnabled;          /* FAT filter is enabled on that part. */
    SectorNo   startSecNo;         /* sectorNo where partition starts     */
    SectorNo   sectors;            /* (info) total sectors in partition   */
    SectorNo   firstFATsecNo;      /* sectorNo of 1st sector of 1st FAT   */
    SectorNo   lastFATsecNo;       /* sectorNo of last sector of 1st FAT  */
    SectorNo   firstDataSecNo;
    unsigned   clusterSize;        /* Cluster size in sectors             */

} FLffVol;


/*
 * Disk with multiple partitions. Multiple disks are allowed on socket. 
 */

typedef struct {

    int        handle;             /* disk's TFFS handle              */
    FLState    ffstate;            /* FAT filter init. state          */
    int        parts;              /* total FAT12/16 partitions found */
    FLffVol  * part[FL_MAX_PARTS_PER_DISK];
    SectorNo   secToWatch;         /* used to track disk partitioning */
    char     * buf;                /* scratch buffer                  */

} FLffDisk;


/* 
 * Master Boot Record/Extended Boot Record of the disk 
 */

typedef struct {

    char               reserved[0x1be];

    struct {
        unsigned char  activeFlag;    /* 80h = bootable */
        unsigned char  startingHead;
        LEushort       startingCylinderSector;
        char           type;
        unsigned char  endingHead;
        LEushort       endingCylinderSector;
        Unaligned4     startingSectorOfPartition;
        Unaligned4     sectorsInPartition;
    } parts [FL_PART_TBL_ENTRIES];

    LEushort           signature;    /* = PARTITION_SIGNATURE */

} flMBR;




/*
 * FAT Filter API 
 */

#if defined(ABS_READ_WRITE) && !defined(FL_READ_ONLY)

  extern FLStatus     ffCheckBeforeWrite (IOreq FAR2 *ioreq);
  extern FLStatus     flffControl (int devNo, int partNo, FLState state);
  extern FLffDisk*    flffInfo    (int devNo);

#endif

#endif /* FLFF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\fatlite.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FATLITE.H_V  $
 * 
 *    Rev 1.1   Apr 01 2001 08:03:02   oris
 * copywrite notice.
 * Alligned left all # directives.
 *
 *    Rev 1.0   Feb 04 2001 11:04:18   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#ifndef FATLITE_H
#define FATLITE_H

#include "blockdev.h"
#include "dosformt.h"
#include "fatfilt.h"
#include "flioctl.h"
#include "docbdk.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\fatfilt.c ===
/******************************************************************************* 
 *                                                                             * 
 *                         M-Systems Confidential                              * 
 *           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001        * 
 *                         All Rights Reserved                                 * 
 *                                                                             * 
 ******************************************************************************* 
 *                                                                             * 
 *                         NOTICE OF M-SYSTEMS OEM                             * 
 *                         SOFTWARE LICENSE AGREEMENT                          * 
 *                                                                             * 
 *  THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE AGREEMENT       * 
 *  BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT FOR THE SPECIFIC    * 
 *  TERMS AND CONDITIONS OF USE, OR CONTACT M-SYSTEMS FOR LICENSE              * 
 *  ASSISTANCE:                                                                * 
 *  E-MAIL = info@m-sys.com                                                    * 
 *                                                                             * 
 *******************************************************************************
 *                                                                             * 
 *                                                                             * 
 *                         Module: FATFILT                                     * 
 *                                                                             * 
 *  This module implements installable FAT12/16 filters. It supports up to     *
 *  SOCKETS sockets, with up to MAX_TL_PARTITIONS disks per socket.      * 
 *  Each disk can contain up to FL_MAX_PARTS_PER_DISK partitions on it, with   * 
 *  maximum depth of partition nesting in extended partitions equal to         * 
 *  MAX_PARTITION_DEPTH.                                                       *
 *                                                                             * 
 *  In order for this module to work, disks must be abs.mounted rather then    * 
 *  mounted. In latter case, this module won't detect any of disk's            * 
 *  partitions, and won't install FAT filters.                                 * 
 *                                                                             * 
 *  This module uses more then 512 bytes of stack space in case if MALLOC is   * 
 *  not enabled.                                                               * 
 *                                                                             * 
 *******************************************************************************/

/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FATFILT.C_V  $
 * 
 *    Rev 1.10   Jan 17 2002 23:00:14   oris
 * Changed debug print added \r.
 * 
 *    Rev 1.9   Sep 15 2001 23:45:50   oris
 * Changed BIG_ENDIAN to FL_BIG_ENDIAN
 * 
 *    Rev 1.8   Jun 17 2001 16:39:10   oris
 * Improved documentation and remove warnings.
 * 
 *    Rev 1.7   May 16 2001 21:17:18   oris
 * Added the FL_ prefix to the following defines: MALLOC and FREE.
 * 
 *    Rev 1.6   May 01 2001 14:21:02   oris
 * Remove warnings.
 * 
 *    Rev 1.5   Apr 30 2001 18:00:10   oris
 * Added casting to remove warrnings.
 * 
 *    Rev 1.4   Apr 24 2001 17:07:32   oris
 * Missing casting of MALLOC calls.
 * 
 *    Rev 1.3   Apr 10 2001 23:54:24   oris
 * FL_MAX_DISKS_PER_SOCKET changed to MAX_TL_PARTITIONS.
 * 
 *    Rev 1.2   Apr 09 2001 15:00:42   oris
 * Change static allocation to dynamic allocations.
 * Renamed flffCheck back to ffCheckBeforeWrite to be backwards compatible with OSAK 4.2.
 * 
 *    Rev 1.1   Apr 01 2001 07:51:16   oris
 * New implementation of fat filter.
 * 
 *    Rev 1.0   19 Feb 2001 21:14:14   andreyk
 * Initial revision.
 */




/* 
 * Includes
 */

#include "fatfilt.h"
#include "blockdev.h"
#include "flflash.h"
#include "bddefs.h"


#if defined(ABS_READ_WRITE) && !defined(FL_READ_ONLY)




/*
 * Module configuration
 */

#define  FL_INCLUDE_FAT_MONITOR     /* undefine it to remove FAT filter code */




/*
 * Defines
 */

/* extract pointer to user's buffer from IOreq */

#ifdef SCATTER_GATHER
#define  FLBUF(ioreq,i)  (*((char FAR1 **)((ioreq)->irData) + (int)(i)))
#else
#define  FLBUF(ioreq,i)  ((char FAR1 *)(ioreq->irData) + (SECTOR_SIZE * ((int)(i))))
#endif

/* extract socket# and disk# from TFFS handle */

#define  H2S(handle)     (((int)(handle)) & 0xf)
#define  H2D(handle)     ((((int)(handle)) >> 4) & 0xf)

/* construct TFFS handle from socket# and disk# */

#define  SD2H(socNo,diskNo)  ((int)((((diskNo) & 0xf) << 4) | ((socNo) & 0xf)))

/* unformatted ("raw") disk partition */

#define  FL_RAW_PART  (-1)




/*
 * Local routines 
 */

static FLStatus   reset (void);
static FLStatus   discardDisk (int handle);
static FLStatus   newDisk (int handle);
static FLStatus   parseDisk (int handle);
static FLStatus   discardDiskParts (FLffDisk *pd);
static FLStatus   addDiskPart (FLffDisk *pd, int partNo);
static FLStatus   addNewDiskPart (FLffDisk *pd);
static FLBoolean  isPartTableWrite (FLffDisk *pd, IOreq FAR2 *ioreq);
static FLStatus   isExtPartPresent (char FAR1 *buf, SectorNo *nextExtPartSec);


#ifdef FL_INCLUDE_FAT_MONITOR

static FLStatus   partEnableFF (FLffVol* pv);
static FLStatus   partFreeDelClusters (FLffVol *pv, SectorNo secNo, char FAR1 *newFAT);

#endif




/*
 * Local data
 */

/* module reset flag */

static FLBoolean  resetDone = FALSE; 

/* disks (BDTL partitions in OSAK terminology) */

static FLffDisk*  ffDisk[SOCKETS][MAX_TL_PARTITIONS] = { { NULL } };


#ifndef FL_MALLOC

/*          
 *        WARNING: Large static arrays ! 
 *
 *  sizeof(ffAllDisks[x][y])    is 64 bytes. 
 *  sizeof(ffAllParts[x][y][z]) is 40 bytes.
 *
 */

static FLffDisk ffAllDisks[SOCKETS][MAX_TL_PARTITIONS];
static FLffVol  ffAllParts[SOCKETS][MAX_TL_PARTITIONS][FL_MAX_PARTS_PER_DISK];

#endif /* FL_MALLOC */

static const char zeroes[SECTOR_SIZE] = {0};




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                    d i s c a r d D i s k P a r t s                          *
 *                                                                             * 
 *  Discard all the partition info (if any) associated with particular disk.   * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *      pd                 : disk (BDTL volume)                                   * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      Always flOK.                                                           * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  discardDiskParts ( FLffDisk * pd )
{
    register int  i;

    if (pd != NULL) {

        for (i = 0; i < FL_MAX_PARTS_PER_DISK; i++) {

#ifdef FL_MALLOC
        if (pd->part[i] != NULL)
            FL_FREE(pd->part[i]);
#endif

            pd->part[i] = NULL;
        }

        pd->parts = 0;
    }

    return flOK;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                      a d d D i s k P a r t                                  *
 *                                                                             * 
 *  If there is partition record #partNo associated with the disk, discard     * 
 *  this info. Attach new partition record #partNo.                            * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *      pd                 : disk (BDTL volume)                                   * 
 *      partNo             : partition (0 ... FL_MAX_PARTS_PER_DISK-1)            * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK if success, otherwise respective error code                       * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  addDiskPart ( FLffDisk * pd, 
                               int        partNo )
{
    FLffVol  * pv;    
    FLStatus   status;
    int        socNo, diskNo;

    /* arg. sanity check */

    if ((pd == NULL) || (partNo >= FL_MAX_PARTS_PER_DISK))
        return flBadDriveHandle;

    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(pd->handle);
    diskNo = H2D(pd->handle);
 
    if ((socNo >= SOCKETS) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    status = flNotEnoughMemory;

#ifdef FL_MALLOC
    pv = (FLffVol *)FL_MALLOC( sizeof(FLffVol) );
#else
    pv = &ffAllParts[socNo][diskNo][partNo];
#endif

    if (pv != NULL) {

        /* initialize fields in struct FLffDisk to safe values */
 
        pv->handle         = pd->handle; 
        pv->type           = FL_RAW_PART;
        pv->flags          = 0;          
        pv->ffEnabled      = FALSE;                  /* turn off FAT minitor */
        pv->sectors        = (SectorNo) 0;
        pv->firstFATsecNo  = (SectorNo) -1;          /* none */
        pv->lastFATsecNo   = pv->firstFATsecNo;      /* none */
        pv->firstDataSecNo = (SectorNo) 0;
        pv->clusterSize    = (unsigned) 0;

#ifdef FL_MALLOC
        if( pd->part[partNo] != NULL )
        FL_FREE(pd->part[partNo]);
#endif
        
        pd->part[partNo] = pv;

        status = flOK;
    }

    return status;    
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                    a d d N e w D i s k P a r t                              *
 *                                                                             * 
 *  Add one more partition record to the disk.                                 * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *      pd                 : disk (BDTL volume)                                   * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK if success, otherwise respective error code                       * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  addNewDiskPart ( FLffDisk * pd )
{
    if (pd->parts < FL_MAX_PARTS_PER_DISK) {

        checkStatus( addDiskPart (pd, pd->parts) );
    pd->parts++;
    }

    return flOK;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                       d i s c a r d D i s k                                 *
 *                                                                             * 
 *  Remove disk record (with all the associated partition records).            * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *      handle             : TFFS handle                                          * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK if success, otherwise respective error code                       * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  discardDisk ( int  handle )
{
    int  socNo, diskNo;

    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(handle);
    diskNo = H2D(handle);
 
    if ((socNo >= SOCKETS) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    if( ffDisk[socNo][diskNo] != NULL ) {

    /* discard associated partition info */

    (void) discardDiskParts( ffDisk[socNo][diskNo] );

#ifdef FL_MALLOC

        /* release disk's scratch buffer */
 
        if( (ffDisk[socNo][diskNo])->buf != NULL)
            FL_FREE( (ffDisk[socNo][diskNo])->buf );

        FL_FREE( ffDisk[socNo][diskNo] );

#endif

        ffDisk[socNo][diskNo] = NULL;
    }

    return flOK;    
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                           n e w D i s k                                     *
 *                                                                             * 
 *  Discard existing disk record (if any), and create new one.                 * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *      handle             : TFFS handle                                       * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK if success, otherwise respective error code                       * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  newDisk ( int  handle )
{
    int        socNo, diskNo;
    int        i;
    FLffDisk * pd;

    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(handle);
    diskNo = H2D(handle);
 
    if ((socNo >= SOCKETS) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    /* discard current disk and associated partition info (if any) */

    checkStatus( discardDisk(handle) );

#ifdef FL_MALLOC

    pd = (FLffDisk *) FL_MALLOC( sizeof(FLffDisk) );

    if (pd == NULL)
        return flNotEnoughMemory;

    /* allocate and attach disk's scratch buffer */

    pd->buf = (char *)FL_MALLOC( SECTOR_SIZE );

    if (pd->buf == NULL) {

        FL_FREE (pd);
        return flNotEnoughMemory;
    }

#else /* !FL_MALLOC */

    pd = &ffAllDisks[socNo][diskNo];

#endif /* FL_MALLOC */


    pd->handle  = handle;
    pd->ffstate = flStateNotInitialized;

    /* don't know partition layout yet */

    pd->parts   = 0;
    for (i = 0; i < FL_MAX_PARTS_PER_DISK; i++)
        pd->part[i] = NULL;

    /* watch Master Boot Record for update */

    pd->secToWatch = (SectorNo) 0;

    ffDisk[socNo][diskNo] = pd;

    return flOK;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                   i s P a r t T a b l e W r i t e                           *
 *                                                                             * 
 *  Check if any of the sectors specified by 'ioreq' points to Master Boot     * 
 *  Record or next extended partition in the extended partitions list.         * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *      pd                 : pointer to disk structure                         * 
 *      ioreq              : standard I/O request                              * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      TRUE if write to MBR or extended partition list is detected, otherwise * 
 *      FALSE                                                                  * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLBoolean isPartTableWrite ( FLffDisk   * pd, 
                                    IOreq FAR2 * ioreq )
{
    register long  i;

    if (pd != NULL) {

        for (i = (long)0; i < ioreq->irSectorCount; i++) {

            if( (ioreq->irSectorNo + i) == (long)pd->secToWatch )
                return TRUE;
        }
    }

    return FALSE;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                   i s E x t P a r t P r e s e n t                           *
 *                                                                             * 
 *  Check if extended partition persent in the partition table. If it is,      * 
 *  calculate the sector # where next partition table will be written to.      * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *      buf                : partition table                                   * 
 *      nextExtPartSec  : sector where next partition table will be written to * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK on success, otherwise error code                                  * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  isExtPartPresent ( char FAR1 * buf, 
                                    SectorNo  * nextExtPartSec )
{
    Partition FAR1 * p;
    register int     i;
  
    /* does it look like partition table ? */

    if (LE2(((PartitionTable FAR1 *) buf)->signature) != PARTITION_SIGNATURE)
        return flBadFormat;   

    /* if extended. part. present, get sector# that will contain next part. in list */

    p = &( ((PartitionTable FAR1 *) buf)->ptEntry[0] );

    for (i = 0;  i < FL_PART_TBL_ENTRIES;  i++, p++) {

        if (p->type == EX_PARTIT) {

            *nextExtPartSec = (SectorNo) UNAL4( (void *) p[i].startingSectorOfPartition );
            return flOK;
        }
    }

    /* no extended partition found */

    return flFileNotFound;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                           r e s e t                                         *
 *                                                                             * 
 *  Resets this software module to it's initial state upon boot.               * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *    none                                                                   * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK in case of success, otherwise respective error code               * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  reset (void)
{
    int iSoc, iDisk;

    for (iSoc = 0; iSoc < SOCKETS; iSoc++) {

        /* discard existing disk structures for that socket */

        for (iDisk = 0; iDisk < MAX_TL_PARTITIONS; iDisk++)
        (void) discardDisk( SD2H(iSoc, iDisk) );

        /* pre-allocate disk structure for first disk of every socket */

        checkStatus( newDisk(SD2H(iSoc, 0)) );
    }

    resetDone = TRUE;

    return flOK;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                          p a r s e D i s k                                  *
 *                                                                             * 
 *  Read partition table(s), install and enable FAT filters on all FAT12/16    * 
 *  partitions.                                                                * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *    handle         : TFFS handle                                          * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK on success, otherwise error code                                  * 
 *                                                                             * 
 *  NOTE:  This routine uses disk's scratch buffer.                            * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  parseDisk ( int handle )
{
    int          socNo, diskNo;
    SectorNo     extPartStartSec, sec;
    int          i, depth;
    int          type;
    FLffDisk   * pd;
    FLffVol    * pv;
    Partition  * pp;
    IOreq        ioreq;

#ifdef  FL_MALLOC
    char       * buf;
#else
    char         buf[SECTOR_SIZE];
#endif

    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(handle);
    diskNo = H2D(handle);
 
    if ((socNo >= ((int) noOfSockets)) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    /* if disk structure hasn't been allocated yet, do it now */

    if (ffDisk[socNo][diskNo] == NULL)
        checkStatus( newDisk(handle) );

    pd = ffDisk[socNo][diskNo];
    
#ifdef  FL_MALLOC

    /* make sure scratch buffer is available */

    if (pd->buf == NULL)
        return flBufferingError;

    buf = pd->buf;

#endif /* FL_MALLOC */ 
 
    /* discard obsolete disk's partition info */

    (void) discardDiskParts (pd);

    /* read Master Boot Record */

    ioreq.irHandle      = handle;
    ioreq.irSectorNo    = (SectorNo) 0;
    ioreq.irSectorCount = (SectorNo) 1;
    ioreq.irData        = (void FAR1 *) buf;
    checkStatus( flAbsRead(&ioreq) );

    /* is it MBR indeed ? */

    if (LE2(((PartitionTable *) buf)->signature) != PARTITION_SIGNATURE)
        return flPartitionNotFound;                         

    /* do primary partitions only (we will do extended partitions later) */

    pp = &( ((PartitionTable *) buf)->ptEntry[0] );

    for (i = 0; i < FL_PART_TBL_ENTRIES; i++, pp++) {

        if( pp->type == ((char)0) )          /* skip empty slot */
            continue;

        if( pp->type == ((char)EX_PARTIT) )  /* skip extended partition */
        continue;

    /* primary partition found (not necessarily FAT12/16) */

        if( addNewDiskPart(pd) != flOK )
        break;

        pv = pd->part[pd->parts - 1];

        /* remember partition's type, and where it starts */

        pv->type       = (int) pp->type;
        pv->startSecNo = (SectorNo) UNAL4( (void *) pp->startingSectorOfPartition );
    } 

    /* do extended partitions in depth */

    for (i = 0; i < FL_PART_TBL_ENTRIES; i++) {

        /* re-read Master Boot Record */

        ioreq.irHandle      = handle;
        ioreq.irSectorNo    = (SectorNo) 0;
        ioreq.irSectorCount = (SectorNo) 1;
        ioreq.irData        = (void FAR1 *) buf;
        checkStatus( flAbsRead(&ioreq) );

        /* is it MBR indeed ? */

        if (LE2(((PartitionTable *) buf)->signature) != PARTITION_SIGNATURE)
            return flOK;

        /* pick up next extended partition in MBR */

        pp = &( ((PartitionTable *) buf)->ptEntry[i] );

        if( pp->type == ((char)EX_PARTIT) ) {

            /* remember where extended partition starts */

            extPartStartSec = (SectorNo) UNAL4( (void *) pp->startingSectorOfPartition );   

            /* follow the list of partition tables */

            sec = extPartStartSec;

            for (depth = 0;  depth < MAX_PARTITION_DEPTH;  depth++) {

                /* read next partition table in the list */

                ioreq.irHandle      = handle;
                ioreq.irSectorNo    = sec;
                ioreq.irSectorCount = (SectorNo) 1;
                ioreq.irData        = (void FAR1 *) buf;
                checkStatus( flAbsRead(&ioreq) );

                /* is it valid partition table ? */

                if (LE2(((PartitionTable *) buf)->signature) != PARTITION_SIGNATURE)
                    break;

                /* if 1st entry is zero, it's the end of part. table list */

                pp = &( ((PartitionTable *) buf)->ptEntry[0] );
                if( pp->type == ((char)0) )
                    break;

                /* Take this partition. Remember it's type, and where it starts */

                if( addNewDiskPart(pd) != flOK )
                break;

                pv = pd->part[pd->parts - 1];

                pv->type       = (int) pp->type;
                pv->startSecNo = 
                    (SectorNo) UNAL4( (void *) pp->startingSectorOfPartition) + sec;

                /* 2nd entry must be extended partition */

                pp = &( ((PartitionTable *) buf)->ptEntry[1] );
                if( pp->type != ((char)EX_PARTIT) )
              break;

                /* sector where next part. table in the list resides */

                sec = extPartStartSec + 
                      (SectorNo) UNAL4( (void *) pp->startingSectorOfPartition );

        }   /* for(depth) */
        }
    }   /* for(i) */ 

#ifdef FL_INCLUDE_FAT_MONITOR

    /* turn on FAT filters on FAT12/16 partition(s) */

    if (pd->parts > 0) {

        for (i = 0;  i < pd->parts;  i++) {

            pv   = pd->part[i];
            type = pv->type;

            /*
             *  WARNING : Routine partEnableFF() uses disk's scratch buffer !
             */

        if((type == FAT12_PARTIT) || (type == FAT16_PARTIT) || (type == DOS4_PARTIT))
                partEnableFF (pv);
    }
    }

#endif /* FL_INCLUDE_FAT_MONITOR */

    /* watch for MBR (sector #0) update */

    pd->secToWatch = (SectorNo) 0;

    pd->ffstate    = flStateInitialized;

    return flOK;
}




#ifdef FL_INCLUDE_FAT_MONITOR

/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                     p a r t E n a b l e F F                                 *
 *                                                                             * 
 *  Installs and enables FAT filter on partition.                              * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *    pv            : disk partition (filesystem volume)                   * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK on success, otherwise error code                                  * 
 *                                                                             * 
 *  NOTE:  This routine uses disk's scratch buffer.                            * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  partEnableFF ( FLffVol * pv )
{
    int        socNo, diskNo;
    FLffDisk * pd;
    BPB      * bpb;
    SectorNo   sectors;
    SectorNo   rootDirSecNo;
    SectorNo   rootDirSectors;
    SectorNo   sectorsPerFAT;
    unsigned   maxCluster;
    int        partNo;
    IOreq      ioreq;

#ifdef  FL_MALLOC
    char     * buf;
#else
    char       buf[SECTOR_SIZE];
#endif

    /* arg. sanity check */

    if (pv == NULL)
        return flBadDriveHandle;
 
    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(pv->handle);
    diskNo = H2D(pv->handle);
 
    if ((socNo >= ((int) noOfSockets)) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    /* check if 'pv' belongs to this disk */

    pd = ffDisk[socNo][diskNo];

    if (pd == NULL)
        return flBadDriveHandle;

    for (partNo = 0; partNo < pd->parts; partNo++) {

        if (pd->part[partNo] == pv)
        break;
    }

    if (partNo >= pd->parts)
        return flBadDriveHandle;

#ifdef  FL_MALLOC

    /* make sure scratch buffer is available */

    if (pd->buf == NULL)
        return flBufferingError;

    buf = pd->buf;
 
#endif /* FL_MALLOC */ 

    /* make sure FAT filter is off on this partition */

    pv->ffEnabled       = FALSE;

    pv->firstFATsecNo   = (SectorNo) -1;
    pv->lastFATsecNo    = pv->firstFATsecNo;
    pv->clusterSize     = (unsigned) 0;

    /* read the BPB */

    ioreq.irHandle      = pv->handle;
    ioreq.irSectorNo    = pv->startSecNo;
    ioreq.irSectorCount = (SectorNo) 1;
    ioreq.irData        = (void FAR1 *) buf;
    checkStatus( flAbsRead(&ioreq) );

    /* Does it look like DOS bootsector ? */

    bpb = &( ((DOSBootSector *) buf)->bpb );

    if( !((bpb->jumpInstruction[0] == 0xe9) 
            || 
         ((bpb->jumpInstruction[0] == 0xeb) && (bpb->jumpInstruction[2] == 0x90)))) {

        return flNonFATformat;
    }

    /* Do we handle this sector size ? */

    if (UNAL2(bpb->bytesPerSector) != SECTOR_SIZE)
        return flFormatNotSupported;

    /* 
     * Is it a bogus BPB (leftover from previous disk partitioning) ? 
     * Check that there is no overlap with next partition (if one exists).
     */

    sectors = UNAL2(bpb->totalSectorsInVolumeDOS3);
    if (sectors == (SectorNo)0)
        sectors = (SectorNo) LE4(bpb->totalSectorsInVolume);

    if ((partNo+1 < pd->parts) && (pd->part[partNo+1] != NULL)) {

        if( sectors > (pd->part[partNo+1])->startSecNo - pv->startSecNo )
            return flNonFATformat;
    }

    /* number of sectors in partition as reported by BPB */

    pv->sectors        = sectors;

    /* valid BPB; get the rest of partition info from it */

    pv->firstFATsecNo  = pv->startSecNo + (SectorNo)( LE2(bpb->reservedSectors) );
    sectorsPerFAT      = (SectorNo) LE2(bpb->sectorsPerFAT);
    pv->lastFATsecNo   = pv->firstFATsecNo + sectorsPerFAT - (SectorNo)1;
    rootDirSecNo       = pv->firstFATsecNo + (sectorsPerFAT * bpb->noOfFATS);
    rootDirSectors     = (SectorNo)1 + (SectorNo)
        (((UNAL2(bpb->rootDirectoryEntries) * DIRECTORY_ENTRY_SIZE) - 1) / SECTOR_SIZE);
    pv->firstDataSecNo = rootDirSecNo + rootDirSectors;

    pv->clusterSize    = bpb->sectorsPerCluster;

    /* decide which type of FAT is it */

    maxCluster         = (unsigned)1 + (unsigned) 
        ((pv->sectors - (pv->firstDataSecNo - pv->startSecNo)) / pv->clusterSize);

    if (maxCluster < 4085) {
        pv->flags |= VOLUME_12BIT_FAT;    /* 12-bit FAT */

#ifndef FAT_12BIT
        DEBUG_PRINT(("Debug: FAT_12BIT must be defined.\r\n"));
        return flFormatNotSupported;
#endif
    }

    /* turn on FAT filter on this partition */

    pv->ffEnabled = TRUE;

    return flOK;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                   p a r t F r e e D e l C l u s t e r s                     *
 *                                                                             * 
 *  Compare the new contents of the specified FAT sector against the old       * 
 *  one on the disk. If any freed clusters are found, issue 'sector delete'    * 
 *  calls for all sectors that are occupied by these freed clusters.           * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *    pv            : disk partition (filesystem volume)                   * 
 *      secNo           : abs. sector # of the FAT sector                      * 
 *      newFAT          : new contents of this FAT sector                      * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK on success, otherwise error code                                  * 
 *                                                                             * 
 *  NOTE:  This routine uses disk's scratch buffer.                            * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

static FLStatus  partFreeDelClusters ( FLffVol   * pv,
                                       SectorNo    secNo,
                                       char FAR1 * newFAT)
{
    FLffDisk * pd;
    int        socNo, diskNo;
    unsigned   short oldFATentry, newFATentry;
    SectorNo   iSec;
    unsigned   firstCluster;
    IOreq      ioreq;
    int        offset;
    int        iPart;

#ifdef FAT_12BIT
    int        halfBytes;
#endif

#ifdef  FL_MALLOC
    char     * oldFAT;
#else
    char       oldFAT[SECTOR_SIZE];
#endif

    /* arg. sanity check */

    if (pv == NULL)
        return flBadDriveHandle;
 
    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(pv->handle);
    diskNo = H2D(pv->handle);
 
    if ((socNo >= ((int) noOfSockets)) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    /* check if 'pv' belongs to this disk */

    pd = ffDisk[socNo][diskNo];

    if (pd == NULL)
        return flBadDriveHandle;

    for (iPart = 0; iPart < pd->parts; iPart++) {

        if (pd->part[iPart] == pv)
        break;
    }

    if (iPart >= pd->parts)
        return flBadDriveHandle;

#ifdef  FL_MALLOC

    /* make sure scratch buffer is available */

    if (pd->buf == NULL)
        return flBufferingError;

    oldFAT = pd->buf;
 
#endif /* FL_MALLOC */

    /* read in the FAT sector from the disk */

    ioreq.irHandle      = pv->handle;
    ioreq.irSectorNo    = secNo;
    ioreq.irSectorCount = 1;
    ioreq.irData        = (void FAR1 *) oldFAT;
    checkStatus( flAbsRead(&ioreq) );

#ifdef FAT_12BIT

    /* size of FAT entry in half-bytes */

    halfBytes = ((pv->flags & VOLUME_12BIT_FAT) ? 3 : 4);

    /* starting cluster */

    if (halfBytes == 3) {

    firstCluster = 
            ((((unsigned)(secNo - pv->firstFATsecNo)) * (2 * SECTOR_SIZE)) + 2) / 3;
    }
    else {
        firstCluster = ((unsigned)(secNo - pv->firstFATsecNo)) * (SECTOR_SIZE / 2);
    }

    /* staring data sector */

    iSec = (((SectorNo)firstCluster - 2) * pv->clusterSize) + pv->firstDataSecNo;

    offset = (firstCluster * ((unsigned) halfBytes)) & ((2 * SECTOR_SIZE) - 1);

    /* 
     *  Find if any clusters were logically deleted, and if so, delete them.
     *
     *  NOTE: We are skipping over 12-bit FAT entries which span more than
     *        one sector.
     */

    for (; offset < ((2 * SECTOR_SIZE) - 2); 
               offset += halfBytes, iSec += pv->clusterSize) {

#ifdef FL_BIG_ENDIAN
        oldFATentry = LE2( *(LEushort FAR0 *)(oldFAT + (offset / 2)) );
        newFATentry = LE2( *(LEushort FAR1 *)(newFAT + (offset / 2)) );
#else
        oldFATentry = UNAL2( *(Unaligned FAR0 *)(oldFAT + (offset / 2)) );
        newFATentry = UNAL2( *(Unaligned FAR1 *)(newFAT + (offset / 2)) );
#endif /* FL_BIG_ENDIAN */

        if (offset & 1) {
            oldFATentry >>= 4;
            newFATentry >>= 4;
        }
        else { 
            if (halfBytes == 3) {
                oldFATentry &= 0xfff;
                newFATentry &= 0xfff;
        }
        }

#else /* !FAT_12BIT */

    firstCluster = ((unsigned) (secNo - pv->firstFATsecNo) * (SECTOR_SIZE / 2));
    iSec  = pv->firstDataSecNo + 
            (((SectorNo)(firstCluster - (unsigned)2)) * pv->clusterSize);

    /* Find if any clusters were logically deleted, and if so, delete them */

    for (offset = 0;  offset < SECTOR_SIZE;  offset += 2, iSec += pv->clusterSize) {

        oldFATentry = LE2( *(LEushort FAR0 *)(oldFAT + offset) );
        newFATentry = LE2( *(LEushort FAR1 *)(newFAT + offset) );

#endif /* FAT_12BIT */

        if ((oldFATentry != FAT_FREE) && (newFATentry == FAT_FREE)) {

            ioreq.irHandle      = pv->handle;
            ioreq.irSectorNo    = iSec;
            ioreq.irSectorCount = pv->clusterSize;
            checkStatus( flAbsDelete(&ioreq) );
        }
    }

    return flOK;
}

#endif /* FL_INCLUDE_FAT_MONITOR */




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                   f f C h e c k B e f o r e W r i t e                       *
 *                                                                             *
 *  Catch all the FAT updates. Detect disk partitioning operation, track it    *
 *  to completion, re-read partition tables, and re-install FAT filters on     *
 *  all FAT12/16 partitions.                                                   *
 *                                                                             *
 *  Parameters:                                                                *
 *      ioreq              : standard I/O request to be checked                   *
 *                                                                             *
 *  Returns:                                                                   *
 *      flOK on success, otherwise error code                                  *
 *                                                                             *
 * --------------------------------------------------------------------------- */

FLStatus  ffCheckBeforeWrite ( IOreq FAR2 * ioreq )
{
    int         socNo, diskNo;
    FLffDisk  * pd;
    FLffVol   * pv;
    long          iSec;
    int         iPart;
    IOreq       ioreq2;
    char FAR1 * usrBuf;

    /* if module hasn't been reset yet, do it now */

    if (resetDone == FALSE)
        (void) reset();

    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(ioreq->irHandle);
    diskNo = H2D(ioreq->irHandle);
 
    if ((socNo >= ((int) noOfSockets)) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    /* if disk structure hasn't been allocated yet, do it now */

    if (ffDisk[socNo][diskNo] == NULL)
        checkStatus( newDisk((int)ioreq->irHandle) );

    pd = ffDisk[socNo][diskNo];

    /* read partition table(s) and install FAT filters is needed */

    if (pd->ffstate == flStateNotInitialized)
        checkStatus( parseDisk((int)ioreq->irHandle) );

    /* catch writes to MBR, and track the whole disk partitioning operations */

    while( isPartTableWrite(pd, ioreq) == TRUE ) {

        /* disk re-partitioning is in progress */

        if( pd->secToWatch == (SectorNo)0 ) {

            /* it's write to MBR, so trash BPBs in all disk's partitions */

            if (pd->parts > 0) {

                for (iPart = 0;  iPart < pd->parts;  iPart++) {

                    ioreq2.irHandle      = ioreq->irHandle;
                    ioreq2.irSectorNo    = (pd->part[iPart])->startSecNo;
                    ioreq2.irSectorCount = (SectorNo) 1;
                    ioreq2.irData        = (void FAR1 *) zeroes;
                    (void) flAbsWrite(&ioreq2);
        }
        }
        }

        /* keep FAT filters disabled while disk partitioning is in progress */

        pd->ffstate = flStateInitInProgress;

        /* partition table which is about to be written to disk */

        usrBuf = FLBUF( ioreq, (pd->secToWatch - ioreq->irSectorNo) );

        switch( isExtPartPresent(usrBuf, &(pd->secToWatch)) ) {

            case flOK: 

                /* 
                 * Found valid partition table with extended partition.
                 * The pd->secToWatch has been updated to point to the
                 * sector where next partition table will be written to. 
                 */
                continue;

            case flFileNotFound:

                /* 
                 * Valid partition table, but no extended partition in it. 
                 * Partitioning has been completed. Set pd->ffstate to 
                 * 'flStateNotInitialized' to initiate parsing of partition
                 * table(s) and FAT filter installation next time this routine
                 * is called. 
                 */

                pd->ffstate = flStateNotInitialized;
                break;

            case flBadFormat:
        default:

                /* No valid partition table. */

                break;
        }

        return flOK;
    }

#ifdef FL_INCLUDE_FAT_MONITOR

    /* check for FAT update */

    if (pd->ffstate == flStateInitialized) {

        /* NOTE: We can handle 'write' request that spans disk partition boundaries */

        for (iSec = ioreq->irSectorNo; 
             iSec < (ioreq->irSectorNo + ioreq->irSectorCount); iSec++) {

            for (iPart = 0; iPart < pd->parts; iPart++) {

                pv = pd->part[iPart];

                /* we monitor only FAT12/16 partitions */

                if ((pv->type != FAT12_PARTIT) && (pv->type != FAT16_PARTIT) && 
                                                  (pv->type != DOS4_PARTIT))
            continue;

                /* FAT filters can be disabled on individual partitions */

                if (pv->ffEnabled != TRUE)
                    continue;

                if ((iSec >= (long)pv->firstFATsecNo) && (iSec <= (long)pv->lastFATsecNo)) {

                    /* compare new and old contents of FAT sectors(s) */

                    usrBuf = FLBUF( ioreq, (iSec - ioreq->irSectorNo) );

                    checkStatus( partFreeDelClusters(pv, iSec, usrBuf) ); 
            }
            }
        }
    }

#endif /* FL_INCLUDE_FAT_MONITOR */

    return flOK;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                   f l f f C o n t r o l                                     *
 *                                                                             * 
 *  Enable/disable/install FAT filters. See comments inside the routine for    * 
 *  the list of supported operations.                                          * 
 *                                                                             * 
 *  Parameters:                                                                * 
 *    handle         : TFFS handle                                          * 
 *      partNo             : partition # (0 .. FL_MAX_PARTS_PER_DISK)             * 
 *      state              : see list of supported operations below               * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      flOK on success, otherwise error code                                  * 
 *                                                                             * 
 * --------------------------------------------------------------------------- *
 *                                                                             *
 *  The following FAT monitor control requests are supported:                  *
 *                                                                             *
 *      state  : flStateNotInitialized                                         *
 *      partNo : [0 ... pd->parts-1]                                           *
 *      action : turn off FAT monitor on specified partition                   *
 *                                                                             *
 *      state  : flStateNotInitialized                                         *
 *      partNo : < 0                                                           *
 *      action : turn off FAT monitor on all partitions                        *
 *                                                                             *
 *      state  : flStateInitialized                                            *
 *      partNo : [0 ... pd->parts-1]                                           *
 *      action : if FAT monitor has been installed on specified partition,     *
 *               turn it on                                                    *
 *                                                                             *
 *      state  : flStateInitInProgress                                         *
 *      partNo : ignored                                                       *
 *      action : re-read partition table(s), and install FAT filters on all    *
 *               partitions                                                    *
 *                                                                             *
 * --------------------------------------------------------------------------- */

FLStatus  flffControl ( int      handle,
                        int      partNo, 
                        FLState  state )
{
    int        socNo, diskNo;
    FLffDisk * pd;
    int        i;
    FLStatus   status;

    /* if module hasn't been reset yet, do it now */

    if (resetDone == FALSE)
        (void) reset();

    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(handle);
    diskNo = H2D(handle);
 
    if ((socNo >= ((int) noOfSockets)) || (diskNo >= MAX_TL_PARTITIONS))
        return flBadDriveHandle;

    /* if disk structure hasn't been allocated yet, do it now */

    if (ffDisk[socNo][diskNo] == NULL)
        checkStatus( newDisk(handle) );

    pd = ffDisk[socNo][diskNo];

    /* abort if disk re-partitioning is in progress */

    if (pd->ffstate == flStateInitInProgress)
        return flDriveNotReady;

    /* read partition table(s) and install FAT filters is needed */

    if (pd->ffstate == flStateNotInitialized) {

        if (state == flStateNotInitialized)
          return flOK;

        checkStatus( parseDisk(handle) );
    }

    /* check 'partNo' arguement for sanity */
 
    if ((partNo >= pd->parts) || (partNo >= FL_MAX_PARTS_PER_DISK))
        return flBadDriveHandle;

    /* do requested operation */

    status = flBadParameter;

    switch (state) {

        case flStateInitInProgress: 

            /* read partition table(s), install FAT filters on all partitions */

        pd->ffstate = flStateNotInitialized; 
            status = parseDisk(handle);
            break;

        case flStateNotInitialized:         

            /* turn off FAT monitor */

        if (partNo < 0) {                      /* all partitions */

            for (i = 0; i < FL_MAX_PARTS_PER_DISK; i++) {

            if (pd->part[i] != NULL)
                    (pd->part[i])->ffEnabled = FALSE;
        }
        }
        else {                                 /* specified partition */

        if (pd->part[partNo] != NULL)
                (pd->part[partNo])->ffEnabled = FALSE;
        }
            status = flOK;
            break;

#ifdef FL_INCLUDE_FAT_MONITOR

        case flStateInitialized:            

            /* turn on FAT monitor */

        if ((pd->ffstate == flStateInitialized) && (partNo >= 0)) {

            if (pd->part[partNo] != NULL) {

                switch( (pd->part[partNo])->type ) {

                        case FAT12_PARTIT:
                    case FAT16_PARTIT:
                    case DOS4_PARTIT:
                        (pd->part[partNo])->ffEnabled = TRUE;
                            status = flOK;
                            break;

            case FL_RAW_PART:
                            DEBUG_PRINT(("Debug: can't ctrl non-existent partition.\r\n"));
                            break;

            default:
                            DEBUG_PRINT(("Debug: can't ctrl non-FAT12/16 partition.\r\n"));
                            break;
            }
        }
        }
            break;

#endif /* FL_INCLUDE_FAT_MONITOR */

    }  /* switch(state) */ 

    return status;
}




/* --------------------------------------------------------------------------- *
 *                                                                             *
 *                   f l f f I n f o                                           *
 *                                                                             * 
 *  Obtain complete partition info for specified disk.                         *
 *                                                                             * 
 *  Parameters:                                                                * 
 *    handle         : TFFS handle                                          * 
 *                                                                             * 
 *  Returns:                                                                   * 
 *      NULL if error, otherwise pointer to partitioning info                  * 
 *                                                                             * 
 * --------------------------------------------------------------------------- */

FLffDisk * flffInfo ( int  handle )
{
    int        socNo, diskNo;
    FLffDisk * pd;

    /* if module hasn't been reset yet, do it now */

    if (resetDone == FALSE)
        (void) reset();

    /* break TFFS handle into socket# and disk#, and do sanity check */

    socNo  = H2S(handle);
    diskNo = H2D(handle);
 
    if ((socNo >= ((int) noOfSockets)) || (diskNo >= MAX_TL_PARTITIONS))
        return NULL;

    /* if disk structure hasn't been allocated yet, do it now */

    if (ffDisk[socNo][diskNo] == NULL) {

        if( newDisk(handle) != flOK )
        return NULL;
    }

    pd = ffDisk[socNo][diskNo];

    /* read partition table(s) and install FAT filters is needed */

    if (pd->ffstate == flStateNotInitialized) {

        if( parseDisk(handle) != flOK )
            return NULL;
    }

    return pd;
}




#endif /* ABS_READ_WRITE && FL_READ_ONLY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\fatlite.c ===
/*!!*/
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FATLITE.C_V  $
 * 
 *    Rev 1.10   Jan 17 2002 23:00:28   oris
 * Removed SINGLE_BUFFER ifdef.
 * Changed debug print added \r.
 * Removed warnings.
 * 
 *    Rev 1.9   Nov 16 2001 00:26:46   oris
 * Removed warnings.
 * 
 *    Rev 1.8   Nov 08 2001 10:45:28   oris
 * Removed warnings.
 * 
 *    Rev 1.7   May 16 2001 21:17:30   oris
 * Added the FL_ prefix to the following defines: ON, OFF
 * Change "data" named variables to flData to avoid name clashes.
 * 
 *    Rev 1.6   Apr 18 2001 09:31:02   oris
 * added new line at the end of the file.
 * 
 *    Rev 1.5   Apr 16 2001 10:42:16   vadimk
 * Emty file bug was fixed ( we should not allocate cluster for an empty file )
 *
 *    Rev 1.4   Apr 09 2001 15:07:10   oris
 * End with an empty line.
 *
 *    Rev 1.3   Apr 03 2001 14:42:02   oris
 * Bug fix - 64 sectors in directory return flInvalidFatChain.
 *
 *    Rev 1.2   Apr 01 2001 08:02:46   oris
 * copywrite notice.
 *
 *    Rev 1.1   Feb 12 2001 12:16:42   oris
 * Changed mutexs for TrueFFS 5.0
 *
 *    Rev 1.0   Feb 04 2001 11:02:28   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#include "bddefs.h"
#include "blockdev.h"
#include "dosformt.h"

#if defined(FILES) && FILES>0

File        fileTable[FILES];       /* the file table */

#define directory ((DirectoryEntry *) vol.volBuffer.flData)

FLStatus closeFile(File *file);       /* forward */
FLStatus flushBuffer(Volume vol);       /* forward */

/*----------------------------------------------------------------------*/
/*                    d i s m o u n t V o l u m e                     */
/*                                                               */
/* Closing all files.                            */
/*                                                               */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus dismountFS(Volume vol,FLStatus status)
{
  int i;
#ifndef FL_READ_ONLY
  if (status == flOK)
    checkStatus(flushBuffer(&vol));
#endif
       /* Close or discard all files and make them available */
  for (i = 0; i < FILES; i++)
    if (fileTable[i].fileVol == &vol)
      if (vol.flags & VOLUME_MOUNTED)
       closeFile(&fileTable[i]);
      else
       fileTable[i].flags = 0;

  vol.volBuffer.sectorNo = UNASSIGNED_SECTOR;       /* Current sector no. (none) */
  vol.volBuffer.dirty = vol.volBuffer.checkPoint = FALSE;
  return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                       f l u s h B u f f e r                            */
/*                                                               */
/* Writes the buffer contents if it is dirty.                           */
/*                                                               */
/* If this is a FAT sector, all FAT copies are written.                     */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus flushBuffer(Volume vol)
{
  if (vol.volBuffer.dirty) {
    FLStatus status;
    unsigned i;
    Volume *bufferOwner = &vol;

    status = (*bufferOwner).tl.writeSector((*bufferOwner).tl.rec, vol.volBuffer.sectorNo,
                                      vol.volBuffer.flData);
    if (status == flOK) {
      if (vol.volBuffer.sectorNo >= (*bufferOwner).firstFATSectorNo &&
         vol.volBuffer.sectorNo < (*bufferOwner).secondFATSectorNo)
       for (i = 1; i < (*bufferOwner).numberOfFATS; i++)
         checkStatus((*bufferOwner).tl.writeSector((*bufferOwner).tl.rec,
                                              vol.volBuffer.sectorNo + i * (*bufferOwner).sectorsPerFAT,
                                              vol.volBuffer.flData));
    }
    else
      vol.volBuffer.sectorNo = UNASSIGNED_SECTOR;

    vol.volBuffer.dirty = vol.volBuffer.checkPoint = FALSE;

    return status;
  }
  else
    return flOK;
}


/*----------------------------------------------------------------------*/
/*                      u p d a t e S e c t o r                            */
/*                                                               */
/* Prepares a sector for update in the buffer                            */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       sectorNo       : Sector no. to read                            */
/*       read              : Whether to initialize buffer by reading, or       */
/*                        clearing                                   */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus updateSector(Volume vol, SectorNo sectorNo, FLBoolean read)
{
  if (sectorNo != vol.volBuffer.sectorNo || &vol != vol.volBuffer.owner) {
    const void FAR0 *mappedSector;

    checkStatus(flushBuffer(&vol));
    vol.volBuffer.sectorNo = sectorNo;
    vol.volBuffer.owner = &vol;
    if (read) {
      mappedSector = vol.tl.mapSector(vol.tl.rec,sectorNo,NULL);
      if (mappedSector) {
        if(mappedSector==dataErrorToken)
          return flDataError;
       tffscpy(vol.volBuffer.flData,mappedSector,SECTOR_SIZE);
      }
      else
       return flSectorNotFound;
    }
    else
      tffsset(vol.volBuffer.flData,0,SECTOR_SIZE);
  }

  vol.volBuffer.dirty = TRUE;

  return flOK;
}

#endif /* FL_READ_ONLY   */
/*----------------------------------------------------------------------*/
/*                 f i r s t S e c t o r O f C l u s t e r              */
/*                                                               */
/* Get sector no. corresponding to cluster no.                            */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       cluster              : Cluster no.                                   */
/*                                                                      */
/* Returns:                                                             */
/*       first sector no. of cluster                                   */
/*----------------------------------------------------------------------*/

static SectorNo firstSectorOfCluster(Volume vol, unsigned cluster)
{
  return (SectorNo) (cluster - 2) * vol.sectorsPerCluster +
        vol.firstDataSectorNo;
}


/*----------------------------------------------------------------------*/
/*                     g e t D i r E n t r y                         */
/*                                                               */
/* Get a read-only copy of a directory entry.                            */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       file              : File belonging to directory entry              */
/*                                                                      */
/* Returns:                                                             */
/*       dirEntry       : Pointer to directory entry                     */
/*----------------------------------------------------------------------*/

static const DirectoryEntry FAR0 *getDirEntry(File *file)
{
  return (DirectoryEntry FAR0 *) findSector(file->fileVol,file->directorySector) +
        file->directoryIndex;
}

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                g e t D i r E n t r y F o r U p d a t e              */
/*                                                               */
/* Read a directory sector into the sector buffer and point to an       */
/* entry, with the intention of modifying it.                            */
/* The buffer will be flushed on operation exit.                     */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       file              : File belonging to directory entry              */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*       dirEntry       : Pointer to directory entry in buffer              */
/*----------------------------------------------------------------------*/

static FLStatus getDirEntryForUpdate(File *file, DirectoryEntry * *dirEntry)
{
  Volume vol = file->fileVol;

  checkStatus(updateSector(file->fileVol,file->directorySector,TRUE));
  *dirEntry = directory + file->directoryIndex;
  vol.volBuffer.checkPoint = TRUE;

  return flOK;
}

#endif  /* FL_READ_ONLY */
/*----------------------------------------------------------------------*/
/*                s e t C u r r e n t D a t e T i m e                   */
/*                                                               */
/* Set current time/date in directory entry                             */
/*                                                                      */
/* Parameters:                                                          */
/*       dirEntry       : Pointer to directory entry                    */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void setCurrentDateTime(DirectoryEntry *dirEntry)
{
  toLE2(dirEntry->updateTime,flCurrentTime());
  toLE2(dirEntry->updateDate,flCurrentDate());
}


/*----------------------------------------------------------------------*/
/*                      g e t F A T e n t r y                            */
/*                                                               */
/* Get an entry from the FAT. The 1st FAT copy is used.                     */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       cluster              : Cluster no. of enrty.                            */
/*                                                                      */
/* Returns:                                                             */
/*       Value of FAT entry.                                          */
/*----------------------------------------------------------------------*/

static FLStatus getFATentry(Volume vol, unsigned* entry)
{
  unsigned cluster = *entry;
  LEushort FAR0 *fat16Sector;

  unsigned fatSectorNo = vol.firstFATSectorNo;
#ifdef FAT_12BIT
  if (vol.flags & VOLUME_12BIT_FAT)
    fatSectorNo += (cluster * 3) >> (SECTOR_SIZE_BITS + 1);
  else
#endif
    fatSectorNo += cluster >> (SECTOR_SIZE_BITS - 1);
#ifndef FL_READ_ONLY
  if (!vol.volBuffer.dirty) {
    /* If the buffer is free, use it to store this FAT sector */
    checkStatus(updateSector(&vol,fatSectorNo,TRUE));
    vol.volBuffer.dirty = FALSE;
  }

#endif /* FL_READ_ONLY */
  fat16Sector = (LEushort FAR0 *) findSector(&vol,fatSectorNo);

  if(fat16Sector==NULL)
    return flSectorNotFound;

  if(fat16Sector==dataErrorToken)
    return flDataError;

#ifdef FAT_12BIT
  if (vol.flags & VOLUME_12BIT_FAT) {
    unsigned char FAR0 *fat12Sector = (unsigned char FAR0 *) fat16Sector;
    unsigned halfByteOffset = (cluster * 3) & (SECTOR_SIZE * 2 - 1);
    unsigned char firstByte = fat12Sector[halfByteOffset / 2];
    halfByteOffset += 2;
    if (halfByteOffset >= SECTOR_SIZE * 2) {
      /* Entry continues on the next sector. What a mess */
      halfByteOffset -= SECTOR_SIZE * 2;
      fat12Sector = (unsigned char FAR0 *) findSector(&vol,fatSectorNo + 1);
      if(fat12Sector==NULL)
        return flSectorNotFound;

      if(fat12Sector==dataErrorToken)
        return flDataError;
    }
    if (halfByteOffset & 1)
      *entry = ((firstByte & 0xf0) >> 4) + (fat12Sector[halfByteOffset / 2] << 4);
    else
      *entry = firstByte + ((fat12Sector[halfByteOffset / 2] & 0xf) << 8);

    if (*entry == 0xfff)    /* in 12-bit fat, 0xfff marks the last cluster */
      *entry = FAT_LAST_CLUSTER; /* return 0xffff instead */
    return flOK;
  }
  else {
#endif
    *entry = LE2(fat16Sector[cluster & (SECTOR_SIZE / 2 - 1)]);
    return flOK;
#ifdef FAT_12BIT
  }
#endif
}

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                       s e t F A T e n t r y                            */
/*                                                               */
/* Writes a new value to a given FAT cluster entry.                     */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       cluster              : Cluster no. of enrty.                            */
/*       entry              : New value of FAT entry.                     */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus setFATentry(Volume vol, unsigned cluster, unsigned entry)
{
  LEushort *fat16Sector;

  unsigned fatSectorNo = vol.firstFATSectorNo;
#ifdef FAT_12BIT
  if (vol.flags & VOLUME_12BIT_FAT)
    fatSectorNo += (cluster * 3) >> (SECTOR_SIZE_BITS + 1);
  else
#endif
    fatSectorNo += cluster >> (SECTOR_SIZE_BITS - 1);

  checkStatus(updateSector(&vol,fatSectorNo,TRUE));
  fat16Sector = (LEushort *) vol.volBuffer.flData;

#ifdef FAT_12BIT
  if (vol.flags & VOLUME_12BIT_FAT) {
    unsigned char *fat12Sector = (unsigned char *) vol.volBuffer.flData;
    unsigned halfByteOffset = (cluster * 3) & (SECTOR_SIZE * 2 - 1);
    if (halfByteOffset & 1) {
      fat12Sector[halfByteOffset / 2] &= 0xf;
      fat12Sector[halfByteOffset / 2] |= (entry & 0xf) << 4;
    }
    else
      fat12Sector[halfByteOffset / 2] = entry;
    halfByteOffset += 2;
    if (halfByteOffset >= SECTOR_SIZE * 2) {
      /* Entry continues on the next sector. What a mess */
      halfByteOffset -= SECTOR_SIZE * 2;
      fatSectorNo++;
      checkStatus(updateSector(&vol,fatSectorNo,TRUE));
    }
    if (halfByteOffset & 1)
      fat12Sector[halfByteOffset / 2] = entry >> 4;
    else {
      fat12Sector[halfByteOffset / 2] &= 0xf0;
      fat12Sector[halfByteOffset / 2] |= (entry & 0x0f00) >> 8;
    }
  }
  else
#endif
    toLE2(fat16Sector[cluster & (SECTOR_SIZE / 2 - 1)],entry);

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                      a l l o c a t e C l u s t e r                     */
/*                                                               */
/* Allocates a new cluster for a file and adds it to a FAT chain or     */
/* marks it in a directory entry.                                   */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       file              : File to extend. It should be positioned at    */
/*                       end-of-file.                                   */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus allocateCluster(File *file)
{
  Volume vol = file->fileVol;
  unsigned originalRover;
  unsigned fatEntry;

  if (file->flags & FILE_READ_ONLY)
    return flNoWriteAccess;

  /* Look for a free cluster. Start at the allocation rover */
  originalRover = vol.allocationRover;

  do {
    vol.allocationRover++;
    if (vol.allocationRover > vol.maxCluster)
      vol.allocationRover = 2;       /* wraparound to start of volume */
    if (vol.allocationRover == originalRover)
      return flNoSpaceInVolume;
    fatEntry = vol.allocationRover;
    checkStatus(getFATentry(&vol,&fatEntry));
  } while ( fatEntry!= FAT_FREE);

  /* Found a free cluster. Mark it as an end of chain */
  checkStatus(setFATentry(&vol,vol.allocationRover,FAT_LAST_CLUSTER));

  /* Mark previous cluster or directory to point to it */
  if (file->currentCluster == 0) {
    DirectoryEntry *dirEntry;
    checkStatus(getDirEntryForUpdate(file,&dirEntry));

    toLE2(dirEntry->startingCluster,vol.allocationRover);
    setCurrentDateTime(dirEntry);
  }
  else
    checkStatus(setFATentry(&vol,file->currentCluster,vol.allocationRover));

  /* Set our new current cluster */
  file->currentCluster = vol.allocationRover;

  return flOK;
}

#endif /* FL_READ_ONLY  */
/*----------------------------------------------------------------------*/
/*                   g e t S e c t o r A n d O f f s e t              */
/*                                                               */
/* Based on the current position of a file, gets a sector number and    */
/* offset in the sector that marks the file's current position.              */
/* If the position is at the end-of-file, and the file is opened for    */
/* write, this routine will extend the file by allocating a new cluster.*/
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus getSectorAndOffset(File *file,
                             SectorNo *sectorNo,
                             unsigned *offsetInSector)
{
  Volume vol = file->fileVol;
  unsigned offsetInCluster =
             (unsigned) file->currentPosition & (vol.bytesPerCluster - 1);

  if (file->flags & FILE_IS_ROOT_DIR) {
    if (file->currentPosition >= file->fileSize)
      return flRootDirectoryFull;
  }

  if (offsetInCluster == 0) {       /* This cluster is finished. Get next */
    if (!(file->flags & FILE_IS_ROOT_DIR)) {
      if (((file->currentPosition >= file->fileSize) && (file->currentPosition>0))||((file->fileSize==0)&&!(file->flags & FILE_IS_DIRECTORY))) {
#ifndef FL_READ_ONLY
        checkStatus(allocateCluster(file));
#else
        return flSectorNotFound;
#endif
      }
      else {
        unsigned nextCluster;
        if (file->currentCluster == 0) {
          const DirectoryEntry FAR0 *dirEntry;
          dirEntry = getDirEntry(file);
          if(dirEntry==NULL)
            return flSectorNotFound;
          if(dirEntry==dataErrorToken)
            return flDataError;
          nextCluster = LE2(dirEntry->startingCluster);
        }
       else {
          nextCluster = file->currentCluster;
          checkStatus(getFATentry(&vol,&nextCluster));
        }
        if (nextCluster < 2 || nextCluster > vol.maxCluster)
          /* We have a bad file size, or the FAT is bad */
          return flInvalidFATchain;
        file->currentCluster = nextCluster;
      }
    }
  }

  *offsetInSector = offsetInCluster & (SECTOR_SIZE - 1);
  if (file->flags & FILE_IS_ROOT_DIR)
    *sectorNo = vol.rootDirectorySectorNo +
                  (SectorNo) (file->currentPosition >> SECTOR_SIZE_BITS);
  else
    *sectorNo = firstSectorOfCluster(&vol,file->currentCluster) +
                  (SectorNo) (offsetInCluster >> SECTOR_SIZE_BITS);

  return flOK;
}




/*----------------------------------------------------------------------*/
/*                      c l o s e F i l e                            */
/*                                                               */
/* Closes an open file, records file size and dates in directory and    */
/* releases file handle.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       file              : File to close.                              */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus closeFile(File *file)
{
#ifndef FL_READ_ONLY
  if ((file->flags & FILE_MODIFIED) && !(file->flags & FILE_IS_ROOT_DIR)) {
    DirectoryEntry *dirEntry;
    checkStatus(getDirEntryForUpdate(file,&dirEntry));

    dirEntry->attributes |= ATTR_ARCHIVE;
    if (!(file->flags & FILE_IS_DIRECTORY))
      toLE4(dirEntry->fileSize,file->fileSize);
    setCurrentDateTime(dirEntry);
  }
#endif
  file->flags = 0;              /* no longer open */

  return flOK;
}

#ifndef FL_READ_ONLY
#ifdef SUB_DIRECTORY

/*----------------------------------------------------------------------*/
/*                      e x t e n d D i r e c t o r y                     */
/*                                                               */
/* Extends a directory, writing empty entries and the mandatory '.' and */
/* '..' entries.                                                 */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       file              : Directory file to extend. On entry,               */
/*                       currentPosition == fileSize. On exit, fileSize*/
/*                       is updated.                                   */
/*       ownerDir       : Cluster no. of owner directory              */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

static FLStatus extendDirectory(File *file, unsigned ownerDir)
{
  Volume vol = file->fileVol;
  unsigned i;
  SectorNo sectorOfDir;
  unsigned offsetInSector;

  /* Assuming the current position is at the end-of-file, this will     */
  /* extend the directory.                                          */
  checkStatus(getSectorAndOffset(file,&sectorOfDir,&offsetInSector));

  for (i = 0; i < vol.sectorsPerCluster; i++) {
    /* Write binary zeroes to indicate never-used entries */
    checkStatus(updateSector(&vol,sectorOfDir + i,FALSE));
    vol.volBuffer.checkPoint = TRUE;
    if (file->currentPosition == 0 && i == 0) {
      /* Add the mandatory . and .. entries */
      tffscpy(directory[0].name,".          ",sizeof directory[0].name);
      directory[0].attributes = ATTR_ARCHIVE | ATTR_DIRECTORY;
      toLE2(directory[0].startingCluster,file->currentCluster);
      toLE4(directory[0].fileSize,0);
      setCurrentDateTime(&directory[0]);
      tffscpy(&directory[1],&directory[0],sizeof directory[0]);
      directory[1].name[1] = '.';       /* change . to .. */
      toLE2(directory[1].startingCluster,ownerDir);
    }
    file->fileSize += SECTOR_SIZE;
  }
  /* Update the parent directory by closing the file */
  file->flags |= FILE_MODIFIED;
  return closeFile(file);
}

#endif       /* SUB_DIRECTORY */
#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                      f i n d D i r E n t r y                            */
/*                                                               */
/* Finds a directory entry by path-name, or finds an available directory*/
/* entry if the file does not exist.                                   */
/* Most fields necessary for opening a file are set by this routine.       */
/*                                                                      */
/* Parameters:                                                          */
/*       vol              : Pointer identifying drive                     */
/*       path              : path to find                                   */
/*      file            : File in which to record directory information.*/
/*                        Specific fields on entry:                     */
/*                         flags: if FILE_MUST_OPEN = 1, directory        */
/*                               will be extended if necessary.       */
/*                       on exit:                                   */
/*                         flags: FILE_IS_DIRECTORY and                   */
/*                               FILE_IS_ROOT_DIR set if true.       */
/*                         fileSize: Set for non-directory files.         */
/*                          currentCluster: Set to 0 (unknown)              */
/*                         ownerDirCluster: Set to 1st cluster of      */
/*                                  owning directory.                     */
/*                         directorySector: Sector of directory. If 0  */
/*                                  entry not found and directory full*/
/*                         directoryEntry: Entry # in directory sector */
/*                         currentPosition: not set by this routine.   */
/*                                                               */
/* Returns:                                                             */
/*       FLStatus       : 0 on success and file found                     */
/*                       flFileNotFound on success and file not found       */
/*                       otherwise failed.                            */
/*----------------------------------------------------------------------*/

static FLStatus findDirEntry(Volume vol, FLSimplePath FAR1 *path, File *file)
{
  File scanFile;              /* Internal file of search */
  unsigned dirBackPointer = 0;       /* 1st cluster of previous directory */

  FLStatus status = flOK;              /* root directory exists */

  file->flags |= (FILE_IS_ROOT_DIR | FILE_IS_DIRECTORY);
  file->fileSize = (long) (vol.sectorsInRootDirectory) << SECTOR_SIZE_BITS;
  file->fileVol = &vol;

#ifdef SUB_DIRECTORY
  for (; path->name[0]; path++) /* while we have another path segment */
#else
  if (path->name[0])    /* search the root directory */
#endif
  {
    status = flFileNotFound;              /* not yet */
    if (!(file->flags & FILE_IS_DIRECTORY))
      return flPathNotFound;  /* if we don't have a directory,
                            we have no business here */

    scanFile = *file;           /* the previous file found becomes the scan file */
    scanFile.currentPosition = 0;

    file->directorySector = 0;       /* indicate no entry found yet */
    file->flags &= ~(FILE_IS_ROOT_DIR | FILE_IS_DIRECTORY | FILE_READ_ONLY);
    file->ownerDirCluster = dirBackPointer;
    file->fileSize = 0;
    file->currentCluster = 0;

    /* Scan directory */
    while (scanFile.currentPosition < scanFile.fileSize) {
      int i;
      DirectoryEntry FAR0 *dirEntry;
      SectorNo sectorOfDir;
      unsigned offsetInSector;
      FLStatus readStatus = getSectorAndOffset(&scanFile,&sectorOfDir,&offsetInSector);
      if (readStatus == flInvalidFATchain) {
       scanFile.fileSize = scanFile.currentPosition;       /* now we know */
       break;              /* we ran into the end of the directory file */
      }
      else if (readStatus != flOK)
       return readStatus;

      dirEntry = (DirectoryEntry FAR0 *) findSector(&vol,sectorOfDir);
      if (dirEntry == NULL)
       return flSectorNotFound;
      if(dirEntry==dataErrorToken)
        return flDataError;

      scanFile.currentPosition += SECTOR_SIZE;

      for (i = 0; i < DIRECTORY_ENTRIES_PER_SECTOR; i++, dirEntry++) {
       if (tffscmp(path,dirEntry->name,sizeof dirEntry->name) == 0 &&
           !(dirEntry->attributes & ATTR_VOL_LABEL)) {
         /* Found a match */
         file->directorySector = sectorOfDir;
         file->directoryIndex = i;
         file->fileSize = LE4(dirEntry->fileSize);
         if (dirEntry->attributes & ATTR_DIRECTORY) {
           file->flags |= FILE_IS_DIRECTORY;
           file->fileSize = 0x7fffffffl;
           /* Infinite. Directories don't have a recorded size */
         }
         if (dirEntry->attributes & ATTR_READ_ONLY)
           file->flags |= FILE_READ_ONLY;
         dirBackPointer = LE2(dirEntry->startingCluster);
         status = flOK;
         goto endOfPathSegment;
       }
       else if (dirEntry->name[0] == NEVER_USED_DIR_ENTRY ||
               dirEntry->name[0] == DELETED_DIR_ENTRY) {
         /* Found a free entry. Remember it in case we don't find a match */
         if (file->directorySector == 0) {
           file->directorySector = sectorOfDir;
           file->directoryIndex = i;
         }
         if (dirEntry->name[0] == NEVER_USED_DIR_ENTRY)       /* end of dir */
           goto endOfPathSegment;
       }
      }
    }

endOfPathSegment:
    ;
  }
#ifndef FL_READ_ONLY
  if (status == flFileNotFound && (file->flags & FILE_MUST_OPEN) &&
      file->directorySector == 0) {
    /* We did not find a place in the directory for this new entry. The */
    /* directory should be extended. 'scanFile' refers to the directory */
    /* to extend, and the current pointer is at its end                     */
#ifdef SUB_DIRECTORY
    checkStatus(extendDirectory(&scanFile,(unsigned) file->ownerDirCluster));
    file->directorySector = firstSectorOfCluster(&vol,scanFile.currentCluster);
    file->directoryIndex = 0;             /* Has to be. This is a new cluster */
#else
    status = flRootDirectoryFull;
#endif
  }
#endif /* FL_READ_ONLY */
  return status;
}


/*----------------------------------------------------------------------*/
/*                                                               */
/*                       r e a d M u l t i S e c t o r                       */
/*                                                               */
/* Checks if file was written on consequent sectors.                     */
/* Parameters:                                                          */
/*      file              : File to check                                   */
/*       stillToRead           : Number of bytes to read. If the read extends  */
/*                       beyond the end-of-file, the read is truncated */
/*                       at the end-of-file.                            */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*       sectors               : Number of consequent sectors                  */
/*                                                               */
/*----------------------------------------------------------------------*/

static FLStatus readMultiSector(Volume vol,File *file,
                                  unsigned long stillToRead,
                                  SectorNo* sectors)
{
  SectorNo sectorCount = 1;
  unsigned offsetInCluster = (unsigned)((file->currentPosition & (vol.bytesPerCluster - 1))+512);

  while(stillToRead>=((sectorCount+1)<<SECTOR_SIZE_BITS)){
    if(offsetInCluster>=vol.bytesPerCluster) {
      unsigned nextCluster;
      nextCluster = file->currentCluster;
      checkStatus(getFATentry(&vol,&nextCluster));
      if (nextCluster < 2 || nextCluster > vol.maxCluster)
        /* We have a bad file size, or the FAT is bad */
       return flInvalidFATchain;
      if(nextCluster!=file->currentCluster+1)
       break;
      file->currentCluster = nextCluster;
      offsetInCluster = 0;
    }
    offsetInCluster+=SECTOR_SIZE;
    sectorCount++;
  }
  *sectors = sectorCount;
  return flOK;
}


/*----------------------------------------------------------------------*/
/*                            r e a d F i l e                            */
/*                                                               */
/* Reads from the current position in the file to the user-buffer.       */
/* Parameters:                                                          */
/*      file              : File to read.                                   */
/*      ioreq->irData       : Address of user buffer                     */
/*       ioreq->irLength       : Number of bytes to read. If the read extends  */
/*                       beyond the end-of-file, the read is truncated */
/*                       at the end-of-file.                            */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*       ioreq->irLength       : Actual number of bytes read                     */
/*----------------------------------------------------------------------*/

FLStatus readFile(File *file,IOreq FAR2 *ioreq)
{
  Volume vol = file->fileVol;
  unsigned char FAR1 *userData = (unsigned char FAR1 *) ioreq->irData;   /* user buffer address */
  unsigned long stillToRead = ioreq->irLength;
  unsigned long remainingInFile = file->fileSize - file->currentPosition;
  ioreq->irLength = 0;              /* read so far */

  /* Should we return an end of file status ? */
  if (stillToRead > remainingInFile)
    stillToRead = (unsigned) remainingInFile;

  while (stillToRead > 0) {
    SectorNo sectorToRead;
    unsigned offsetInSector;
    unsigned long readThisTime;
    const char FAR0 *sector;

    checkStatus(getSectorAndOffset(file,&sectorToRead,&offsetInSector));

    if (stillToRead < SECTOR_SIZE || offsetInSector > 0 || vol.tl.readSectors==NULL) {
      sector = (const char FAR0 *) findSector(&vol,sectorToRead);
      if(sector==NULL)
       {
    DEBUG_PRINT(("readFile : sector was not found\r\n"));
       return flSectorNotFound;
       }
      if(sector==dataErrorToken)
        return flDataError;

      readThisTime = SECTOR_SIZE - offsetInSector;
      if (readThisTime > stillToRead)
        readThisTime = (unsigned) stillToRead;
      if (sector)
        tffscpy(userData,sector + offsetInSector,(unsigned short)readThisTime);
      else
        return flSectorNotFound;              /* Sector does not exist */
    }
    else {
      SectorNo sectorCount;
      checkStatus(readMultiSector(&vol,file,stillToRead,&sectorCount));
      checkStatus(vol.tl.readSectors(vol.tl.rec,sectorToRead,userData,sectorCount));
      readThisTime = (sectorCount<<SECTOR_SIZE_BITS);
    }
    stillToRead -= readThisTime;
    ioreq->irLength += readThisTime;
    userData = (unsigned char FAR1 *)flAddLongToFarPointer(userData,readThisTime);
    file->currentPosition += readThisTime;
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*               f l F i n d N e x t F i l e                            */
/*                                                                      */
/* See the description of 'flFindFirstFile'.                            */
/*                                                                      */
/* Parameters:                                                          */
/*       irHandle       : File handle returned by flFindFirstFile.       */
/*       irData              : Address of user buffer to receive a              */
/*                       DirectoryEntry structure                     */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus findNextFile(File *file, IOreq FAR2 *ioreq)
{
  DirectoryEntry FAR1 *irDirEntry = (DirectoryEntry FAR1 *) ioreq->irData;
  FLStatus status;
  /* Do we have a directory ? */
  if (!(file->flags & FILE_IS_DIRECTORY))
    return flNotADirectory;

  ioreq->irLength = DIRECTORY_ENTRY_SIZE;
  do {
    /*checkStatus(readFile(file,ioreq));*/
     /*Vadim: add treatment for a full cluster sub-directory */
    status=readFile(file,ioreq);
    if ((ioreq->irLength != DIRECTORY_ENTRY_SIZE) ||
        (irDirEntry->name[0] == NEVER_USED_DIR_ENTRY)||
        (!(file->flags&FILE_IS_ROOT_DIR)&&(status==flInvalidFATchain)))
         {
      checkStatus(closeFile(file));
      return flNoMoreFiles;
    }
    else
      {
       if(status!=flOK)
           return status;
      }
  } while (irDirEntry->name[0] == DELETED_DIR_ENTRY ||
          (irDirEntry->attributes & ATTR_VOL_LABEL));

  return flOK;
}
#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                       d e l e t e F i l e                            */
/*                                                               */
/* Deletes a file or directory.                                         */
/*                                                                      */
/* Parameters:                                                          */
/*       ioreq->irPath       : path of file to delete                     */
/*       isDirectory       : 0 = delete file, other = delete directory       */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus deleteFile(Volume vol, IOreq FAR2 *ioreq, FLBoolean isDirectory)
{
  File file;              /* Our private file */
  DirectoryEntry *dirEntry;

  file.flags = 0;
  checkStatus(findDirEntry(&vol,ioreq->irPath,&file));

  if (file.flags & FILE_READ_ONLY)
    return flNoWriteAccess;

  if (isDirectory) {
    DirectoryEntry fileFindInfo;
    ioreq->irData = &fileFindInfo;

    if (!(file.flags & FILE_IS_DIRECTORY))
      return flNotADirectory;
    /* Verify that directory is empty */
    file.currentPosition = 0;
    for (;;) {
      FLStatus status = findNextFile(&file,ioreq);
      if (status == flNoMoreFiles)
       break;
      if (status != flOK)
       return status;
      if (!((fileFindInfo.attributes & ATTR_DIRECTORY) &&
           (tffscmp(fileFindInfo.name,".          ",sizeof fileFindInfo.name) == 0 ||
            tffscmp(fileFindInfo.name,"..         ",sizeof fileFindInfo.name) == 0)))
       return flDirectoryNotEmpty;
    }
  }
  else {
    /* Did we find a directory ? */
    if (file.flags & FILE_IS_DIRECTORY)
      return flFileIsADirectory;
  }

  /* Mark directory entry deleted */
  checkStatus(getDirEntryForUpdate(&file,&dirEntry));
  dirEntry->name[0] = DELETED_DIR_ENTRY;

  /* Delete FAT entries */
  file.currentPosition = 0;
  file.currentCluster = LE2(dirEntry->startingCluster);
  while (file.currentPosition < file.fileSize) {
    unsigned nextCluster;

    if (file.currentCluster < 2 || file.currentCluster > vol.maxCluster)
      /* We have a bad file size, or the FAT is bad */
      return isDirectory ? flOK : flInvalidFATchain;
    nextCluster = file.currentCluster;
    checkStatus(getFATentry(&vol,&nextCluster));

    /* mark FAT free */
    checkStatus(setFATentry(&vol,file.currentCluster,FAT_FREE));
    vol.volBuffer.checkPoint = TRUE;

    /* mark sectors free */
    checkStatus(vol.tl.deleteSector(vol.tl.rec,
                                firstSectorOfCluster(&vol,file.currentCluster),
                                vol.sectorsPerCluster));

    file.currentPosition += vol.bytesPerCluster;
    file.currentCluster = nextCluster;
  }
  if (file.currentCluster > 1 && file.currentCluster <= vol.maxCluster) {
    checkStatus(setFATentry(&vol,file.currentCluster,FAT_FREE));
    vol.volBuffer.checkPoint = TRUE;

    /* mark sectors free */
    checkStatus(vol.tl.deleteSector(vol.tl.rec,
                                firstSectorOfCluster(&vol,file.currentCluster),
                                vol.sectorsPerCluster));
  }
  return flOK;
}


/*----------------------------------------------------------------------*/
/*                   s e t N a m e I n D i r E n t r y                     */
/*                                                               */
/* Sets the file name in a directory entry from a path name             */
/*                                                                      */
/* Parameters:                                                          */
/*       dirEntry       : directory entry                            */
/*       path              : path the last segment of which is the name       */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void setNameInDirEntry(DirectoryEntry *dirEntry, FLSimplePath FAR1 *path)
{
  FLSimplePath FAR1 *lastSegment;

  for (lastSegment = path;              /* Find null terminator */
       lastSegment->name[0];
       lastSegment++);

  tffscpy(dirEntry->name,--lastSegment,sizeof dirEntry->name);
}

#endif /* FL_READ_ONLY */
/*----------------------------------------------------------------------*/
/*                       o p e n F i l e                            */
/*                                                               */
/* Opens an existing file or creates a new file. Creates a file handle  */
/* for further file processing.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*       ioreq->irFlags       : Access and action options, defined below       */
/*       ioreq->irPath       : path of file to open                           */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*       ioreq->irHandle       : New file handle for open file                 */
/*                                                                      */
/*----------------------------------------------------------------------*/


FLStatus openFile(Volume vol, IOreq FAR2 *ioreq)
{
  int i;
  FLStatus status;

  /* Look for an available file */
  File *file = fileTable;
  for (i = 0; i < FILES && (file->flags & FILE_IS_OPEN); i++, file++);
  if (i >= FILES)
    return flTooManyOpenFiles;
  file->fileVol = &vol;
  ioreq->irHandle = i;              /* return file handle */
#ifndef FL_READ_ONLY
  /* Delete file if exists and required */
  if (ioreq->irFlags & ACCESS_CREATE) {
    FLStatus status = deleteFile(&vol,ioreq,FALSE);
    if (status != flOK && status != flFileNotFound)
      return status;
  }

  /* Find the path */
  if (ioreq->irFlags & ACCESS_CREATE)
    file->flags |= FILE_MUST_OPEN;
#endif /* FL_READ_ONLY */
  status =  findDirEntry(file->fileVol,ioreq->irPath,file);
  if (status != flOK &&
      (status != flFileNotFound || !(ioreq->irFlags & ACCESS_CREATE)))
    return status;

  /* Did we find a directory ? */
  if (file->flags & FILE_IS_DIRECTORY)
    return flFileIsADirectory;

#ifndef FL_READ_ONLY
  /* Create file if required */
  if (ioreq->irFlags & ACCESS_CREATE) {
    DirectoryEntry *dirEntry;
    /* Look for a free cluster. Start at the allocation rover */
    checkStatus(getDirEntryForUpdate(file,&dirEntry));
    setNameInDirEntry(dirEntry,ioreq->irPath);
    dirEntry->attributes = ATTR_ARCHIVE;
    toLE2(dirEntry->startingCluster,0);
    toLE4(dirEntry->fileSize,0);
    setCurrentDateTime(dirEntry);
  }
#endif /* FL_READ_ONLY  */
  if (!(ioreq->irFlags & ACCESS_READ_WRITE))
    file->flags |= FILE_READ_ONLY;

  file->currentPosition = 0;       /* located at file beginning     */
  file->flags |= FILE_IS_OPEN;     /* this file now officially open */

  return flOK;
}

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                                                                      */
/*                     w r i t e M u l t i S e c t o r                  */
/*                                                                      */
/* Checks the possibility of writing file on consequent sectors.        */
/* Parameters:                                                          */
/*      file           : File to check                                  */
/*      stillToWrite   : Number of bytes to read. If the read extends   */
/*                       beyond the end-of-file, the read is truncated  */
/*                       at the end-of-file.                            */
/* Returns:                                                             */
/*       FLStatu       : 0 on success, otherwise failed                 */
/*       sectors       : Number of consequent sectors                   */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus writeMultiSector(Volume vol,File *file,
                                  unsigned long stillToWrite,
                                  SectorNo* sectors)
{
  SectorNo sectorCount = 1;
  unsigned offsetInCluster = (unsigned)((file->currentPosition & (vol.bytesPerCluster - 1))+512);

  while(stillToWrite>=((sectorCount+1)<<SECTOR_SIZE_BITS)){
    if(offsetInCluster>=vol.bytesPerCluster) {
      if ((long)(file->currentPosition+(sectorCount<<SECTOR_SIZE_BITS))>= file->fileSize) {
        if(file->currentCluster <= vol.maxCluster) {
          unsigned fatEntry;
          if(file->currentCluster+1>vol.maxCluster)
            break;/*There is not free consequent cluster*/
          fatEntry = file->currentCluster+1;
         checkStatus(getFATentry(&vol,&fatEntry));
          if(fatEntry==FAT_FREE) {
            /* Found a free cluster. Mark it as an end of chain */
            checkStatus(setFATentry(&vol,file->currentCluster+1,FAT_LAST_CLUSTER));

            /* Mark previous cluster or directory to point to it */
            checkStatus(setFATentry(&vol,file->currentCluster,file->currentCluster+1));

            /* Set our new current cluster */
            file->currentCluster = file->currentCluster+1;
            offsetInCluster = 0;
          }
          else /*There is not free consequent cluster*/
            break;
        }
        else
          return flInvalidFATchain;
      }
      else { /* We did not passed end of file*/
        unsigned nextCluster = file->currentCluster;
        checkStatus(getFATentry(&vol,&nextCluster));
        if (nextCluster < 2 || nextCluster > vol.maxCluster)
         /* We have a bad file size, or the FAT is bad */
         return flInvalidFATchain;
       if(nextCluster!=file->currentCluster+1)
          break;
       file->currentCluster = nextCluster;
        offsetInCluster = 0;
      }
    }
    offsetInCluster+=SECTOR_SIZE;
    sectorCount++;
  }
  *sectors = sectorCount;
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                       w r i t e F i l e                              */
/*                                                                      */
/* Writes from the current position in the file from the user-buffer.   */
/*                                                                      */
/* Parameters:                                                          */
/*       file              : File to write.                             */
/*       ioreq->irData     : Address of user buffer                     */
/*       ioreq->irLength   : Number of bytes to write.                  */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus          : 0 on success, otherwise failed             */
/*       ioreq->irLength   : Actual number of bytes written             */
/*----------------------------------------------------------------------*/

FLStatus writeFile(File *file, IOreq FAR2 *ioreq)
{
  Volume vol = file->fileVol;
  char FAR1 *userData = (char FAR1 *) ioreq->irData;   /* user buffer address */
  unsigned long stillToWrite = ioreq->irLength;

  if (file->flags & FILE_READ_ONLY)
    return flNoWriteAccess;

  file->flags |= FILE_MODIFIED;

  ioreq->irLength = 0;              /* written so far */

  while (stillToWrite > 0) {
    SectorNo sectorToWrite;
    unsigned offsetInSector;
    unsigned long writeThisTime;

    checkStatus(getSectorAndOffset(file,&sectorToWrite,&offsetInSector));

    if (stillToWrite < SECTOR_SIZE || offsetInSector > 0) {
      unsigned short shortWrite;
      /* Not on full sector boundary */
      checkStatus(updateSector(&vol,sectorToWrite,
                  ((file->currentPosition < file->fileSize) || (offsetInSector > 0))));

#ifdef HIGH_SECURITY
      if ((file->flags & FILE_IS_DIRECTORY)||(file->currentPosition < file->fileSize))
#else
      if(file->flags & FILE_IS_DIRECTORY)
#endif
        vol.volBuffer.checkPoint = TRUE;
      writeThisTime = SECTOR_SIZE - offsetInSector;
      if (writeThisTime > stillToWrite)
                            writeThisTime = stillToWrite;

      shortWrite = (unsigned short)writeThisTime;
      tffscpy(vol.volBuffer.flData + offsetInSector,userData,shortWrite);
    }
    else {
      SectorNo sectorCount;
      if(vol.tl.writeMultiSector!=NULL) {
        checkStatus(writeMultiSector(&vol,file,stillToWrite,&sectorCount));
      }
      else
        sectorCount = 1;

      if (((sectorToWrite+sectorCount > vol.volBuffer.sectorNo) && (sectorToWrite <= vol.volBuffer.sectorNo)) &&
          (&vol == vol.volBuffer.owner)) {
       vol.volBuffer.sectorNo = UNASSIGNED_SECTOR;              /* no longer valid */
       vol.volBuffer.dirty = vol.volBuffer.checkPoint = FALSE;
      }

      if(vol.tl.writeMultiSector==NULL) {
        checkStatus(vol.tl.writeSector(vol.tl.rec,sectorToWrite,userData));
      }
      else {
        checkStatus(vol.tl.writeMultiSector(vol.tl.rec,sectorToWrite,userData,sectorCount));
      }
      writeThisTime = (sectorCount<<SECTOR_SIZE_BITS);
    }
    stillToWrite -= writeThisTime;
    ioreq->irLength += writeThisTime;
    userData = (char FAR1 *)flAddLongToFarPointer(userData,writeThisTime);
    file->currentPosition += writeThisTime;
    if (file->currentPosition > file->fileSize)
      file->fileSize = file->currentPosition;
  }

  return flOK;
}

#endif /*  FL_READ_ONLY  */
/*----------------------------------------------------------------------*/
/*                        s e e k F i l e                               */
/*                                                                      */
/* Sets the current position in the file, relative to file start, end   */
/* or current position.                                                 */
/* Note: This function will not move the file pointer beyond the        */
/* beginning or end of file, so the actual file position may be         */
/* different from the required. The actual position is indicated on     */
/* return.                                                              */
/*                                                                      */
/* Parameters:                                                          */
/*       file              : File to set position.                      */
/*       ioreq->irLength   : Offset to set position.                    */
/*       ioreq->irFlags    : Method code                                */
/*                     SEEK_START: absolute offset from start of file   */
/*                     SEEK_CURR:  signed offset from current position  */
/*                     SEEK_END:   signed offset from end of file       */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus        : 0 on success, otherwise failed               */
/*       ioreq->irLength : Actual absolute offset from start of file    */
/*----------------------------------------------------------------------*/

FLStatus seekFile(File *file, IOreq FAR2 *ioreq)
{
  Volume vol = file->fileVol;
  long int seekPosition = ioreq->irLength;

  switch (ioreq->irFlags) {

    case SEEK_START:
      break;

    case SEEK_CURR:
      seekPosition += file->currentPosition;
      break;

    case SEEK_END:
      seekPosition += file->fileSize;
      break;

    default:
      return flBadParameter;
  }

  if (seekPosition < 0)
    seekPosition = 0;
  if (seekPosition > file->fileSize)
    seekPosition = file->fileSize;

  /* now set the position ... */
  if (seekPosition < file->currentPosition) {
    file->currentCluster = 0;
    file->currentPosition = 0;
  }
  while (file->currentPosition < seekPosition) {
    SectorNo sectorNo;
    unsigned offsetInSector;
    checkStatus(getSectorAndOffset(file,&sectorNo,&offsetInSector));

    file->currentPosition += vol.bytesPerCluster;
    file->currentPosition &= - (long) (vol.bytesPerCluster);
  }
  ioreq->irLength = file->currentPosition = seekPosition;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                        f l F i n d F i l e                            */
/*                                                                      */
/* Finds a file entry in a directory, optionally modifying the file     */
/* time/date and/or attributes.                                         */
/* Files may be found by handle no. provided they are open, or by name. */
/* Only the Hidden, System or Read-only attributes may be modified.       */
/* Entries may be found for any existing file or directory other than   */
/* the root. A DirectoryEntry structure describing the file is copied   */
/* to a user buffer.                                                 */
/*                                                                      */
/* The DirectoryEntry structure is defined in dosformt.h              */
/*                                                                      */
/* Parameters:                                                          */
/*       irHandle       : If by name: Drive number (0, 1, ...)              */
/*                       else      : Handle of open file              */
/*       irPath              : If by name: Specifies a file or directory path*/
/*       irFlags              : Options flags                                   */
/*                       FIND_BY_HANDLE: Find open file by handle.        */
/*                                     Default is access by path.    */
/*                        SET_DATETIME:       Update time/date from buffer       */
/*                       SET_ATTRIBUTES: Update attributes from buffer       */
/*       irDirEntry       : Address of user buffer to receive a              */
/*                       DirectoryEntry structure                     */
/*                                                                      */
/* Returns:                                                             */
/*       irLength       : Modified                                   */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus findFile(Volume vol, File *file, IOreq FAR2 *ioreq)
{
  File tFile;                     /* temporary file for searches */

  if (ioreq->irFlags & FIND_BY_HANDLE)
    tFile = *file;
  else {
    tFile.flags = 0;
    checkStatus(findDirEntry(&vol,ioreq->irPath,&tFile));
  }

  if (tFile.flags & FILE_IS_ROOT_DIR)
    if (ioreq->irFlags & (SET_DATETIME | SET_ATTRIBUTES))
      return flPathIsRootDirectory;
    else {
      DirectoryEntry FAR1 *irDirEntry = (DirectoryEntry FAR1 *) ioreq->irData;

      tffsset(irDirEntry,0,sizeof(DirectoryEntry));
      irDirEntry->attributes = ATTR_DIRECTORY;
      return flOK;
    }

#ifndef FL_READ_ONLY
  if (ioreq->irFlags & (SET_DATETIME | SET_ATTRIBUTES)) {
    DirectoryEntry FAR1 *irDirEntry = (DirectoryEntry FAR1 *) ioreq->irData;
    DirectoryEntry *dirEntry;

    checkStatus(getDirEntryForUpdate(&tFile,&dirEntry));
    if (ioreq->irFlags & SET_DATETIME) {
      COPY2(dirEntry->updateDate,irDirEntry->updateDate);
      COPY2(dirEntry->updateTime,irDirEntry->updateTime);
    }
    if (ioreq->irFlags & SET_ATTRIBUTES) {
      unsigned char attr;
      attr = dirEntry->attributes & ATTR_DIRECTORY;
      attr |= irDirEntry->attributes &
            (ATTR_ARCHIVE | ATTR_HIDDEN | ATTR_READ_ONLY | ATTR_SYSTEM);
      dirEntry->attributes = attr;
    }
    tffscpy(irDirEntry, dirEntry, sizeof(DirectoryEntry));

  }
  else
#endif /* FL_READ_ONLY */
{
    const DirectoryEntry FAR0 *dirEntry;
    dirEntry = getDirEntry(&tFile);

    if(dirEntry==NULL)
      return flSectorNotFound;
    if(dirEntry==dataErrorToken)
      return flDataError;

    tffscpy(ioreq->irData,dirEntry,sizeof(DirectoryEntry));
    if (ioreq->irFlags & FIND_BY_HANDLE)
      toLE4(((DirectoryEntry FAR1 *) (ioreq->irData))->fileSize, tFile.fileSize);
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*               f l F i n d F i r s t F i l e                            */
/*                                                                      */
/* Finds the first file entry in a directory.                            */
/* This function is used in combination with the flFindNextFile call,   */
/* which returns the remaining file entries in a directory sequentially.*/
/* Entries are returned according to the unsorted directory order.       */
/* flFindFirstFile creates a file handle, which is returned by it. Calls*/
/* to flFindNextFile will provide this file handle. When flFindNextFile */
/* returns 'noMoreEntries', the file handle is automatically closed.    */
/* Alternatively the file handle can be closed by a 'closeFile' call    */
/* before actually reaching the end of directory.                     */
/* A DirectoryEntry structure is copied to the user buffer describing   */
/* each file found. This structure is defined in dosformt.h.              */
/*                                                                      */
/* Parameters:                                                          */
/*       irHandle       : Drive number (0, 1, ...)                     */
/*       irPath              : Specifies a directory path                     */
/*       irData              : Address of user buffer to receive a              */
/*                       DirectoryEntry structure                     */
/*                                                                      */
/* Returns:                                                             */
/*       irHandle       : File handle to use for subsequent operations. */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus findFirstFile(Volume vol, IOreq FAR2 *ioreq)
{
  int i;

  /* Look for an available file */
  File *file = fileTable;
  for (i = 0; i < FILES && (file->flags & FILE_IS_OPEN); i++, file++);
  if (i >= FILES)
    return flTooManyOpenFiles;
  file->fileVol = &vol;
  ioreq->irHandle = i;              /* return file handle */

  /* Find the path */
  checkStatus(findDirEntry(file->fileVol,ioreq->irPath,file));

  file->currentPosition = 0;              /* located at file beginning */
  file->flags |= FILE_IS_OPEN | FILE_READ_ONLY; /* this file now officially open */

  return findNextFile(file,ioreq);
}


/*----------------------------------------------------------------------*/
/*                       g e t D i s k I n f o                            */
/*                                                               */
/* Returns general allocation information.                            */
/*                                                               */
/* The bytes/sector, sector/cluster, total cluster and free cluster       */
/* information are returned into a DiskInfo structure.                     */
/*                                                                      */
/* Parameters:                                                          */
/*       ioreq->irData       : Address of DiskInfo structure                 */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus getDiskInfo(Volume vol, IOreq FAR2 *ioreq)
{
  unsigned i;
  unsigned fatEntry;

  DiskInfo FAR1 *diskInfo = (DiskInfo FAR1 *) ioreq->irData;

  diskInfo->bytesPerSector = SECTOR_SIZE;
  diskInfo->sectorsPerCluster = vol.sectorsPerCluster;
  diskInfo->totalClusters = vol.maxCluster - 1;
  diskInfo->freeClusters = 0;              /* let's count them */

  for (i = 2; i <= vol.maxCluster; i++) {
    fatEntry = i;
    checkStatus(getFATentry(&vol,&fatEntry));
    if ( fatEntry== 0)
      diskInfo->freeClusters++;
  }

  return flOK;
}

#ifndef FL_READ_ONLY
#ifdef RENAME_FILE

/*----------------------------------------------------------------------*/
/*                      r e n a m e F i l e                            */
/*                                                               */
/* Renames a file to another name.                                   */
/*                                                               */
/* Parameters:                                                          */
/*       ioreq->irPath       : path of existing file                            */
/*      ioreq->irData       : path of new name.                            */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus renameFile(Volume vol, IOreq FAR2 *ioreq)
{
  File file, file2;              /* temporary files for searches */
  DirectoryEntry *dirEntry, *dirEntry2;
  FLStatus status;
  FLSimplePath FAR1 *irPath2 = (FLSimplePath FAR1 *) ioreq->irData;

  file.flags = 0;
  checkStatus(findDirEntry(&vol,ioreq->irPath,&file));

  file2.flags = FILE_MUST_OPEN;
  status = findDirEntry(file.fileVol,irPath2,&file2);
  if (status != flFileNotFound)
    return status == flOK ? flFileAlreadyExists : status;

#ifndef VFAT_COMPATIBILITY
  if (file.ownerDirCluster == file2.ownerDirCluster) {       /* Same directory */
    /* Change name in directory entry */
    checkStatus(getDirEntryForUpdate(&file,&dirEntry));
    setNameInDirEntry(dirEntry,irPath2);
  }
  else
#endif
  {       /* not same directory */
    /* Write new directory entry */
    const DirectoryEntry FAR0 *dir;
    checkStatus(getDirEntryForUpdate(&file2,&dirEntry2));

    dir = getDirEntry(&file);
    if(dir==NULL)
      return flSectorNotFound;
    if(dir==dataErrorToken)
      return flDataError;
    *dirEntry2 = *dir;

     setNameInDirEntry(dirEntry2,irPath2);

    /* Delete original entry */
    checkStatus(getDirEntryForUpdate(&file,&dirEntry));
    dirEntry->name[0] = DELETED_DIR_ENTRY;
  }

  return flOK;
}

#endif /* RENAME_FILE */
#endif /* FL_READ_ONLY  */


#ifndef FL_READ_ONLY
#ifdef SUB_DIRECTORY

/*----------------------------------------------------------------------*/
/*                           m a k e D i r                            */
/*                                                               */
/* Creates a new directory.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*       ioreq->irPath       : path of new directory.                     */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus makeDir(Volume vol, IOreq FAR2 *ioreq)
{
  File file;                     /* temporary file for searches */
  unsigned dirBackPointer;
  DirectoryEntry *dirEntry;
  FLStatus status;
  unsigned originalRover;
  unsigned fatEntry;

  file.flags = FILE_MUST_OPEN;
  status = findDirEntry(&vol,ioreq->irPath,&file);
  if (status != flFileNotFound)
    return status == flOK ? flFileAlreadyExists : status;


  /* Look for a free cluster. Start at the allocation rover */
  originalRover = vol.allocationRover;
  do {
    vol.allocationRover++;
    if (vol.allocationRover > vol.maxCluster)
      vol.allocationRover = 2;       /* wraparound to start of volume */
    if (vol.allocationRover == originalRover)
      return flNoSpaceInVolume;

    fatEntry = vol.allocationRover;
    checkStatus(getFATentry(&vol,&fatEntry));
  } while ( fatEntry!= FAT_FREE);
    /* Found a free cluster. Mark it as an end of chain */
  checkStatus(setFATentry(&vol,vol.allocationRover,FAT_LAST_CLUSTER));

  /* Create the directory entry for the new dir */
  checkStatus(getDirEntryForUpdate(&file,&dirEntry));

  setNameInDirEntry(dirEntry,ioreq->irPath);
  dirEntry->attributes = ATTR_ARCHIVE | ATTR_DIRECTORY;
  toLE2(dirEntry->startingCluster,vol.allocationRover);
  toLE4(dirEntry->fileSize,0);
  setCurrentDateTime(dirEntry);

  /* Remember the back pointer to owning directory for the ".." entry */
  dirBackPointer = (unsigned) file.ownerDirCluster;

  file.flags |= FILE_IS_DIRECTORY;
  file.currentPosition = 0;
  file.fileSize = 0;
  return extendDirectory(&file,dirBackPointer);
}


#endif /* SUB_DIRECTORY */

#ifdef SPLIT_JOIN_FILE

/*------------------------------------------------------------------------*/
/*                        j o i n F i l e                                 */
/*                                                                        */
/* joins two files. If the end of the first file is on a cluster          */
/* boundary, the files will be joined there. Otherwise, the data in       */
/* the second file from the beginning until the offset that is equal to   */
/* the offset in cluster of the end of the first file will be lost. The   */
/* rest of the second file will be joined to the first file at the end of */
/* the first file. On exit, the first file is the expanded file and the   */
/* second file is deleted.                                                */
/* Note: The second file will be open by this function, it is advised to  */
/*        close it before calling this function in order to avoid          */
/*        inconsistencies.                                                 */
/*                                                                        */
/* Parameters:                                                            */
/*       file            : file to join to.                                */
/*       irPath          : Path name of the file to be joined.             */
/*                                                                        */
/* Returns:                                                               */
/*       FLStatus        : 0 on success, otherwise failed.                 */
/*                                                                        */
/*------------------------------------------------------------------------*/

FLStatus joinFile (File *file, IOreq FAR2 *ioreq)
{
  Volume vol = file->fileVol;
  File joinedFile;
  DirectoryEntry *joinedDirEntry;
  unsigned offsetInCluster = (unsigned)(file->fileSize % vol.bytesPerCluster);

  if (file->flags & FILE_READ_ONLY)
    return flNoWriteAccess;

  if (file->flags & FILE_IS_DIRECTORY)
    return flFileIsADirectory;

  /* open the joined file. */
  joinedFile.flags = 0;
  checkStatus(findDirEntry(file->fileVol,ioreq->irPath,&joinedFile));
  joinedFile.currentPosition = 0;

  /* Check if the two files are the same file. */
  if (file->directorySector == joinedFile.directorySector &&
      file->directoryIndex == joinedFile.directoryIndex)
    return flBadFileHandle;

  file->flags |= FILE_MODIFIED;

  if (joinedFile.fileSize > (long)offsetInCluster) { /* the joined file extends
                                             beyond file's end of file.*/
    unsigned lastCluster, nextCluster, firstCluster;
    const DirectoryEntry FAR0 *dir;
    dir = getDirEntry(&joinedFile);

    if(dir==NULL)
      return flSectorNotFound;
    if(dir==dataErrorToken)
      return flDataError;

    /* get the first cluster of the joined file. */
    firstCluster = LE2(dir->startingCluster);

    if (file->fileSize) {  /* the file is not empty.*/
      /* find the last cluster of file by following the FAT chain.*/
      if (file->currentCluster == 0) {    /* start from the first cluster.*/
        const DirectoryEntry FAR0 *dir;
        dir = getDirEntry(file);

        if(dir==NULL)
          return flSectorNotFound;
        if(dir==dataErrorToken)
          return flDataError;
        nextCluster = LE2(dir->startingCluster);
      }
      else                               /* start from the current cluster.*/
       nextCluster = file->currentCluster;
      /* follow the FAT chain.*/
      while (nextCluster != FAT_LAST_CLUSTER) {
       if (nextCluster < 2 || nextCluster > vol.maxCluster)
         return flInvalidFATchain;
       lastCluster = nextCluster;
        checkStatus(getFATentry(&vol,&nextCluster));
      }
    }
    else                   /* the file is empty. */
      lastCluster = 0;

    if (offsetInCluster) {      /* join in the middle of a cluster.*/
      SectorNo sectorNo, joinedSectorNo, tempSectorNo;
      unsigned offset, joinedOffset, numOfSectors = 1, i;
      const char FAR0 *startCopy;
      unsigned fatEntry;

      /* get the sector and offset of the end of the file.*/
      file->currentPosition = file->fileSize;
      file->currentCluster = lastCluster;
      checkStatus(getSectorAndOffset(file, &sectorNo, &offset));

      /* load the sector of the end of the file to the buffer.*/
      checkStatus(updateSector(&vol, sectorNo, TRUE));

      /*  copy the second part of the first cluster of the joined file
         to the end of the last cluster of the original file.*/
      /* first set the current position of the joined file.*/
      joinedFile.currentPosition = offsetInCluster;
      joinedFile.currentCluster = firstCluster;
      /* get the relevant sector in the joined file.*/
      checkStatus(getSectorAndOffset(&joinedFile, &joinedSectorNo, &joinedOffset));
      /* map sector and offset.*/
      startCopy = (const char FAR0 *) findSector(&vol,joinedSectorNo) + joinedOffset;
      if (startCopy == NULL)
       return flSectorNotFound;
      if(startCopy==dataErrorToken)
        return flDataError;

      /* copy.*/
      tffscpy(vol.volBuffer.flData + offset, startCopy, SECTOR_SIZE - offset);
      checkStatus(flushBuffer(&vol));

      /* find how many sectors should still be copied (the number of sectors
        until the end of the current cluster).*/
      tempSectorNo = firstSectorOfCluster(&vol,lastCluster);
      while(tempSectorNo != sectorNo) {
       tempSectorNo++;
       numOfSectors++;
      }

      /* copy the rest of the sectors in the current cluster.
        this is done by loading a sector from the joined file to the buffer,
        changing the sectoNo of the buffer to the relevant sector in file
        and then flushing the buffer.*/
      sectorNo++;
      joinedSectorNo++;
      for(i = 0; i < vol.sectorsPerCluster - numOfSectors; i++) {
       checkStatus(updateSector(&vol,joinedSectorNo, TRUE));
       vol.volBuffer.sectorNo = sectorNo;
       checkStatus(flushBuffer(&vol));
       sectorNo++;
       joinedSectorNo++;
      }
      fatEntry = firstCluster;
      checkStatus(getFATentry(&vol,&fatEntry));
      /* adjust the FAT chain.*/
      checkStatus(setFATentry(&vol,
                           lastCluster,
                           fatEntry));

      /* mark the first cluster of the joined file as free */
      checkStatus(setFATentry(&vol,firstCluster,FAT_FREE));
      vol.volBuffer.checkPoint = TRUE;

      /* mark sectors free */
      checkStatus(vol.tl.deleteSector(vol.tl.rec,firstSectorOfCluster(&vol,firstCluster),
                                  vol.sectorsPerCluster));
    }
    else {    /* join on a cluster boundary.*/
      if (lastCluster) {      /* file is not empty. */
       checkStatus(setFATentry(&vol,lastCluster, firstCluster));
      }
      else {                  /* file is empty.*/
       DirectoryEntry *dirEntry;

       checkStatus(getDirEntryForUpdate(file, &dirEntry));
       toLE2(dirEntry->startingCluster, firstCluster);
       setCurrentDateTime(dirEntry);
      }
    }
    /*adjust the size of the expanded file.*/
    file->fileSize += joinedFile.fileSize - offsetInCluster;

    /* mark the directory entry of the joined file as deleted.*/
    checkStatus(getDirEntryForUpdate(&joinedFile, &joinedDirEntry));
    joinedDirEntry->name[0] = DELETED_DIR_ENTRY;
  }
  else        /* the joined file is too small all is left to do is delete it */
    checkStatus(deleteFile (&vol, ioreq, FALSE));

  return flOK;
}


/*------------------------------------------------------------------------*/
/*                    s p l i t F i l e                                   */
/*                                                                        */
/* Splits the file into two files. The original file contains the first   */
/* part, and a new file (which is created for that purpose) contains      */
/* the second part. If the current position is on a cluster               */
/* boundary, the file will be split at the current position. Otherwise,   */
/* the cluster of the current position is duplicated, one copy is the     */
/* first cluster of the new file, and the other is the last cluster of the*/
/* original file, which now ends at the current position.                 */
/*                                                                        */
/* Parameters:                                                            */
/*       file            : file to split.                                  */
/*       irPath          : Path name of the new file.                      */
/*                                                                        */
/* Returns:                                                               */
/*       irHandle        : handle of the new file.                         */
/*       FLStatus        : 0 on success, otherwise failed.                 */
/*                                                                        */
/*------------------------------------------------------------------------*/

FLStatus splitFile (File *file, IOreq FAR2 *ioreq)
{
  Volume vol = file->fileVol;
  File *newFile, dummyFile;
  IOreq ioreq2;
  FLStatus status;
  unsigned fatEntry;

  if (file->flags & FILE_READ_ONLY)
    return flNoWriteAccess;

  if (file->flags & FILE_IS_DIRECTORY)
    return flFileIsADirectory;

  /* check if the path of the new file already exists.*/
  dummyFile.flags = 0;
  status = findDirEntry(&vol,ioreq->irPath,&dummyFile);
  if (status != flFileNotFound) {
    if (status == flOK)              /* there is a file with that path.*/
      return flFileAlreadyExists;
    else
      return status;
  }

  /* open the new file.*/
  ioreq2.irFlags = OPEN_FOR_WRITE;
  ioreq2.irPath = ioreq->irPath;
  checkStatus(openFile(&vol,&ioreq2));

  newFile = fileTable + ioreq2.irHandle;
  newFile->flags |= FILE_MODIFIED;
  file->flags |= FILE_MODIFIED;

  if (file->currentPosition % vol.bytesPerCluster) { /* not on a cluster boundary.*/
    SectorNo sectorNo, newSectorNo, lastSector;
    int i;
    if((status = allocateCluster(newFile)) != flOK) {
      newFile->flags = 0;                             /* close the new file */
      return status;
    }
    sectorNo = firstSectorOfCluster(&vol,file->currentCluster);
    newSectorNo = firstSectorOfCluster(&vol,newFile->currentCluster);
    /* deal with split in a last not full cluster */
    fatEntry = file->currentCluster;
    checkStatus(getFATentry(&vol,&fatEntry));
    if (fatEntry == FAT_LAST_CLUSTER)
      lastSector = ((file->fileSize - 1) % vol.bytesPerCluster)/SECTOR_SIZE +
                   sectorNo;
    else
      lastSector = sectorNo + vol.sectorsPerCluster; /* out of the cluster */

    /* copy the current cluster of the original file to the first cluster
       of the new file, sector after sector.*/
    for(i = 0; i < (int)vol.sectorsPerCluster; i++) {
      if((status = updateSector(&vol,sectorNo, TRUE)) != flOK) {
        newFile->flags = 0;                             /* close the new file */
       return status;
      }

      vol.volBuffer.sectorNo = newSectorNo;
      if((status = flushBuffer(&vol)) != flOK) {
        newFile->flags = 0;                             /* close the new file */
        return status;
      }

      sectorNo++;
      newSectorNo++;

      if(sectorNo > lastSector)
        break;
    }
    fatEntry = file->currentCluster;
    checkStatus(getFATentry(&vol,&fatEntry));

    /* adjust the FAT chain of the new file.*/
    if((status = setFATentry(&vol,newFile->currentCluster,
                             fatEntry)) != flOK) {
      newFile->flags = 0;                             /* close the new file */
      return status;
    }

    /* mark current cluster 0 (as current position).*/
    newFile->currentCluster = 0;
  }
  else {                                  /* on a cluster boundary.*/
    DirectoryEntry *newDirEntry;

    /* adjust the directory entry of the new file.*/
    if((status = getDirEntryForUpdate(newFile,&newDirEntry)) != flOK) {
      newFile->flags = 0;                             /* close the new file */
      return status;
    }

    if (file->currentPosition) { /* split at the middle of the file.*/
      fatEntry = file->currentCluster;
      checkStatus(getFATentry(&vol,&fatEntry));

      toLE2(newDirEntry->startingCluster, fatEntry);
      setCurrentDateTime(newDirEntry);
    }
    else {                     /* split at the beginning of the file.*/
      DirectoryEntry *dirEntry;

      const DirectoryEntry FAR0 *dir;
      dir = getDirEntry(file);
      if(dir==NULL)
       return flSectorNotFound;
      if(dir==dataErrorToken)
       return flDataError;

      /* first cluster of file becomes the first cluster of the new file.*/
      toLE2(newDirEntry->startingCluster,LE2(dir->startingCluster));
      setCurrentDateTime(newDirEntry);

      /* starting cluster of file becomes 0.*/
      if((status = getDirEntryForUpdate(file, &dirEntry)) != flOK) {
       newFile->flags = 0;                             /* close the new file */
       return status;
      }

      toLE2(dirEntry->startingCluster, 0);
      setCurrentDateTime(dirEntry);
    }
  }

  /* adjust the size of the new file.*/
  newFile->fileSize = file->fileSize - file->currentPosition +
                   (file->currentPosition % vol.bytesPerCluster);

  /* adjust the chain and size of the original file.*/
  if (file->currentPosition)    /* we didn't split at the beginning.*/
    if((status = setFATentry(&vol,file->currentCluster, FAT_LAST_CLUSTER)) != flOK) {
      newFile->flags = 0;                             /* close the new file */
      return status;
    }

  file->fileSize = file->currentPosition;

  /* return to the user the handle of the new file.*/
  ioreq->irHandle = ioreq2.irHandle;

  return flOK;
}

#endif /* SPLIT_JOIN_FILE */
#endif /*  FL_READ_ONLY  */


/*----------------------------------------------------------------------*/
/*                       I n i t F S                                */
/*                                                               */
/* Initializes the FLite file system.                                     */
/*                                                               */
/* Calling this function is optional. If it is not called,              */
/* initialization will be done automatically on the first FLite call.       */
/* This function is provided for those applications who want to              */
/* explicitly initialize the system and get an initialization status.       */
/*                                                               */
/* Calling flInit after initialization was done has no effect.              */
/*                                                               */
/* Parameters:                                                          */
/*       None                                                        */
/*                                                                      */
/* Returns:                                                             */
/*       FLStatus       : 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

void initFS()
{
  unsigned i;
  unsigned volNo;
  Volume vol = vols;

  for (volNo = 0; volNo < VOLUMES; volNo++, pVol++) {
    vol.volBuffer.dirty = FALSE;
    vol.volBuffer.owner = NULL;
    vol.volBuffer.sectorNo = UNASSIGNED_SECTOR;       /* Current sector no. (none) */
    vol.volBuffer.checkPoint = FALSE;
  }

  for (i = 0; i < FILES; i++)
    fileTable[i].flags = 0;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flbase.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLBASE.H_V  $
 * 
 *    Rev 1.19   Apr 15 2002 07:36:18   oris
 * Moved all include directive to head of file.
 * Moved OS names definitions to mtdsa.h
 * Changed flBusConfig environment array to dword variables instead of single byte.
 * Added support for VERIFY_ERASED_SECTOR compilation flag.
 * 
 *    Rev 1.18   Feb 19 2002 20:59:28   oris
 * Changed order of include directives.
 * 
 *    Rev 1.17   Jan 29 2002 20:08:08   oris
 * Added NAMING_CONVENTION prefix and extern "C" for cpp files to all public routines:
 * tffsset, tffscmp and tffsset.
 * 
 *    Rev 1.16   Jan 20 2002 20:26:42   oris
 * Added casting to byte to FL_GET_PARTITION_FROM_HANDLE and to FL_GET_SOCKET_FROM_HANDLE
 * 
 *    Rev 1.15   Jan 17 2002 23:00:42   oris
 * Removed MAX and MIN definitions and replaced them with TFFSMIN and  TFFSMAX.
 * Added extern for the following environment variables: 
 *    extern dword  flSectorsVerifiedPerFolding;
 *    extern byte    flSuspendMode;
 *    extern byte    flBusConfig[SOCKETS];
 * Changed the following environment variables
 *    extern byte    flVerifyWrite[SOCKETS][MAX_TL_PARTITIONS<<1] - 4 for  disk partition 3 for binary and one for the rest.
 *    extern byte    flPolicy[SOCKETS][MAX_TL_PARTITIONS] - 1 for each disk  partition.
 * Changed all environment variables to byte (except for flSectorsVerifiedPerFolding)
 * Added FL_UPS  for flVerifyWrite
 * Added FL_SUSPEND_WRITE and FL_SUSPEND_IO for flSuspendMode.
 * Added define CUR_OS_WINCE for boot SDK customization.
 * Exchanged CUR_OS_VX_WORKS and CUR_NO_OS
 * Added FL_GET_SOCKET_FROM_HANDLE and FL_GET_PARTITION_FROM_HANDLE instead of HANDLE_VOLUME_MASK and HANDLE_PARTITION_MASK.
 * 
 *    Rev 1.14   Nov 21 2001 11:38:52   oris
 * Removed FL_MULTI_DOC_NOT_ACTIVE , FL_MULTI_DOC_ACTIVE ,  FL_DO_NOT_MARK_DELETE , FL_MARK_DELETE , FL_WITHOUT_VERIFY_WRITE ,  FL_WITH_VERIFY_WRITE definition (unsing FL_ON and FL_OFF instead).
 * 
 *    Rev 1.13   Nov 08 2001 10:49:14   oris
 * Moved environment variable states definitions from blockdev.h
 * Added flVerifyWrite environment variable that controls the verify write mode at run-time. 
 * 
 *    Rev 1.12   Sep 15 2001 23:45:40   oris
 * Changed BIG_ENDIAN to FL_BIG_ENDIAN
 * Changed checkStatus definition in order not to get compilation warnings.
 * 
 *    Rev 1.11   Jul 29 2001 16:44:16   oris
 * Added CUR_OS_NO definition
 * 
 *    Rev 1.10   May 21 2001 16:09:52   oris
 * Removed flsleep prototype and moved tffscpy tffscmp and tffsset prototypes under USE_STD_FUNC copmpilation flag.
 * 
 *    Rev 1.9   May 21 2001 13:51:06   oris
 * Reorganized and added the CUS_OS_DOS, CUS_OS_PSOS and CUS_OS_VX_WORKS defintions.
 * 
 *    Rev 1.8   May 16 2001 21:17:38   oris
 * Added the FL_ prefix to the following defines: ON, OFF
 * Changed c variable name to cval (avoid name clashes). 
 * Added flMtlDefragMode environment variable forward definition.
 * 
 *    Rev 1.7   Apr 30 2001 18:00:32   oris
 * Added new environment variable flMarkDeleteOnFlash declaration.
 * 
 *    Rev 1.6   Apr 10 2001 23:53:54   oris
 * Added flAddLongToFarPointer declaration for the standalone version.
 * 
 *    Rev 1.5   Apr 09 2001 15:01:56   oris
 * UNAL4(arg) definition was changed.
 *
 *    Rev 1.4   Apr 01 2001 07:51:46   oris
 * copywrite notice.
 * Moved MIN,MAX,BYTE_ADD_FAR,WORD_ADD_FAR macroes from base2400.c.
 * Moved protection attributes definition to flflash.h.
 * Aliggned left all # directives.
 * Added FAR0 to cpyBuffer,setBuffer,cmpBuffer,flmemcpy,flmemset and flmemcmp
 *
 *    Rev 1.3   Feb 18 2001 14:18:02   oris
 * remove osak version redundent definition.
 *
 *    Rev 1.2   Feb 14 2001 02:12:08   oris
 * Added flMaxUnitChain environment variable.
 * Changed flUseMultiDoc and flPolicy variables type and names.
 *
 *    Rev 1.1   Feb 05 2001 18:45:20   oris
 * Removed flcustm.h include directive since it is already included in mtdsa.h
 * Added flchkdef.h include directive for sanity check on compilation flags.
 *
 *    Rev 1.0   Feb 04 2001 11:14:30   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef FLBASE_H
#define FLBASE_H

/***************************************************************************/
/*                                                                         */
/* Include customization files                                             */
/* Note the following files are used for :                                 */
/*   mtdsa.h    - Complete customization - standaloe applications          */
/*                                         like Binary SDK                 */
/*   flsystem.h - System customization - TrueFFS applications like drivers */
/*   flchkdef.h - Customized defintion check of TrueFFS applications.      */
/*                                                                         */
/***************************************************************************/

#include "mtdsa.h"
#ifndef    MTD_STANDALONE
#include "flcustom.h"
#include "flsystem.h"
#include "flchkdef.h"
#endif    /* MTD_STANDALONE */
#include "flstatus.h"

 /* Number of translation layer partitions
 *
 * Defines Maximum Number of Traslation layer partitons on a physical device
 *
 * The actual number of partitions depends on the format placed on each device.
 */

#define MAX_TL_PARTITIONS 4

/* Sector size
 *
 * Define the log2 of sector size for the FAT & translation layers. Note
 * that the default 512 bytes is the de-facto standard and practically
 * the only one that provides real PC interoperability.
 */

#define SECTOR_SIZE_BITS   9

/* standard type definitions */
typedef int         FLBoolean;

/* Boolean constants */

#ifndef FALSE
#define FALSE    0
#endif
#ifndef TRUE
#define    TRUE    1
#endif

#ifndef FL_ON
#define    FL_ON    1
#endif
#ifndef FL_OFF
#define    FL_OFF    0
#endif

/* Geral purpose macroes */

#define BYTE_ADD_FAR(x,y) ((byte FAR1 *)addToFarPointer(x,y))
#define WORD_ADD_FAR(x,y) ((word FAR1 *)addToFarPointer(x,y))

/* Drive handle masks */

#define FL_GET_SOCKET_FROM_HANDLE(ioreq)    (byte)(ioreq->irHandle & 0x0f)
#define FL_GET_PARTITION_FROM_HANDLE(ioreq) (byte)((ioreq->irHandle & 0xf0) >> 4)
#define INVALID_VOLUME_NUMBER 0xff
#define TL_SIGNATURE          6

/* General types definitions */

typedef unsigned char  byte;        /* 8  bit unsigned variable */
typedef unsigned short word;        /* 16 bit unsigned variable */
typedef unsigned long  dword;       /* 32 bit unsigned variable */

typedef signed char  Sbyte;         /* 8  bit signed variable */
typedef signed short Sword;         /* 16 bit signed variable */
typedef signed long  Sdword;        /* 32 bit signed variable */


#define SECTOR_SIZE        (1 << SECTOR_SIZE_BITS)
#define BITS_PER_BITE            8

/* General purpose Macroes adjusted according to the above customization files. */

/* define SectorNo range according to media maximum size */
#if (MAX_VOLUME_MBYTES * 0x100000l) / SECTOR_SIZE > 0x10000l
typedef unsigned long SectorNo;
#define    UNASSIGNED_SECTOR 0xffffffffl
#else
typedef unsigned short SectorNo;
#define UNASSIGNED_SECTOR 0xffff
#endif

/* x86 pointer far level dictated several of the TrueFFS pointers types. */
#if FAR_LEVEL > 0
#define FAR0    far
#else
#define FAR0
#endif

#if FAR_LEVEL > 1
#define FAR1    far
#else
#define FAR1
#endif

#if FAR_LEVEL > 2
#define FAR2    far
#else
#define FAR2
#endif

/* Call a procedure returning status and fail if it fails. This works only in */
/* routines that return Status: */
#define checkStatus(exp)      {    FLStatus fl__status = (exp);if (fl__status != flOK) return fl__status; }

#define vol (*pVol)
#define TFFSMIN(a,b) ((a>b) ? b:a)
#define TFFSMAX(a,b) ((a<b) ? b:a)

/***************************************************************************/
/* Big \ Little endien architecture conversion macroes.                    */
/***************************************************************************/

#ifndef FL_BIG_ENDIAN

typedef unsigned short LEushort;
typedef unsigned long LEulong;

#define LE2(arg)         arg
#define toLE2(to,arg)    (to) = (arg)
#define LE4(arg)         arg
#define toLE4(to,arg)    (to) = (arg)
#define COPY2(to,arg)    (to) = (arg)
#define COPY4(to,arg)    (to) = (arg)

typedef unsigned char Unaligned[2];
typedef Unaligned     Unaligned4[2];

#define UNAL2(arg)       fromUNAL(arg)
#define toUNAL2(to,arg)  toUNAL(to,arg)

#define UNAL4(arg)       fromUNALLONG((Unaligned const FAR0 *)(arg))
#define toUNAL4(to,arg)  toUNALLONG(to,arg)

extern void toUNAL(unsigned char FAR0 *unal, unsigned short n);

extern unsigned short fromUNAL(unsigned char const FAR0 *unal);

extern void toUNALLONG(Unaligned FAR0 *unal, unsigned long n);

extern unsigned long fromUNALLONG(Unaligned const FAR0 *unal);

#else

typedef unsigned char LEushort[2];
typedef unsigned char LEulong[4];

#define LE2(arg)      fromLEushort(arg)
#define toLE2(to,arg) toLEushort(to,arg)
#define LE4(arg)      fromLEulong(arg)
#define toLE4(to,arg) toLEulong(to,arg)
#define COPY2(to,arg) copyShort(to,arg)
#define COPY4(to,arg) copyLong(to,arg)

#define Unaligned     LEushort
#define Unaligned4    LEulong

extern void toLEushort(unsigned char FAR0 *le, unsigned short n);

extern unsigned short fromLEushort(unsigned char const FAR0 *le);

extern void toLEulong(unsigned char FAR0 *le, unsigned long n);

extern unsigned long fromLEulong(unsigned char const FAR0 *le);

extern void copyShort(unsigned char FAR0 *to,
              unsigned char const FAR0 *from);

extern void copyLong(unsigned char FAR0 *to,
             unsigned char const FAR0 *from);

#define UNAL2        LE2
#define toUNAL2      toLE2

#define UNAL4        LE4
#define toUNAL4      toLE4

#endif /* FL_BIG_ENDIAN */

typedef LEulong LEmin;

#ifndef MTD_STANDALONE
#include "flsysfun.h"
#endif /* MTD_STANDALONE */

/*************************************************/
/* Use routines instead of 'c' standard librarys */
/*************************************************/

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
extern byte  flVerifyWrite[SOCKETS][MAX_TL_PARTITIONS<<1];
/* Vefrify write */
#define FL_UPS 2
/* 
 * See also FL_ON and FL_OFF
 */
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

#ifdef ENVIRONMENT_VARS

typedef void FAR0 *  (NAMING_CONVENTION FAR0* cpyBuffer)(void FAR0 * ,const void FAR0 * ,size_t);
typedef void FAR0 *  (NAMING_CONVENTION FAR0* setBuffer)(void FAR0 * ,int ,size_t);
typedef int          (NAMING_CONVENTION FAR0* cmpBuffer)(const void FAR0 * ,const void FAR0 * ,size_t);

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
extern cpyBuffer tffscpy;
#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
extern cmpBuffer tffscmp;
#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */
extern setBuffer tffsset;
#ifdef __cplusplus
}
#endif /* __cplusplus */

extern void FAR0* NAMING_CONVENTION FAR0 flmemcpy(void FAR0* dest,const void FAR0 *src,size_t count);
extern void FAR0* NAMING_CONVENTION FAR0 flmemset(void FAR0* dest,int cval,size_t count);
extern int  NAMING_CONVENTION FAR0 flmemcmp(const void FAR0* dest,const void FAR0 *src,size_t count);

/**********************************************/
/* Declare the TrueFFS environment variables  */
/**********************************************/

extern byte   flUse8Bit;
extern byte   flUseNFTLCache;
extern byte   flUseisRAM;

extern byte   flUseMultiDoc;
extern byte   flMTLdefragMode;
extern byte   flMaxUnitChain;
extern byte   flMarkDeleteOnFlash;
extern byte   flPolicy[SOCKETS][MAX_TL_PARTITIONS];
extern byte   flSuspendMode;

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
extern dword  flSectorsVerifiedPerFolding;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

/* Policies definitions (FL_SET_POLICY) */
#define FL_DEFAULT_POLICY             0
#define FL_COMPLETE_ASAP              1
/* Mtl policies defintions (FL_MTL_POLICY) */
#define FL_MTL_DEFRAGMENT_ALL_DEVICES 0
#define FL_MTL_DEFRAGMENT_SEQUANTIAL  1
/* Suspend mode other then FL_OF */
#define FL_SUSPEND_WRITE 1
#define FL_SUSPEND_IO    3


extern void flSetEnvVar(void);

#endif /* ENVIRONMENT_VARS */

#ifndef FL_NO_USE_FUNC
extern dword  flBusConfig[SOCKETS];
#endif /* FL_NO_USE_FUNC */

#ifdef MTD_STANDALONE

/* When the using the application standalone mode (mtdsa.h), the following routines can be */
/* used provided they are implemented in mtdsa.c file.                                       */

extern void flDelayMsecs(unsigned long msec);

extern void FAR0* flAddLongToFarPointer(void FAR0 *ptr, unsigned long offset);

#ifndef USE_STD_FUNC
/**********************************************/
/* Declare tffscpy, tffsset, tffscmp routines */
/* Not using the standard 'c' libraries.      */
/**********************************************/

extern void tffscpy(void FAR1 *dst, void FAR1 *src, unsigned len);
extern int  tffscmp(void FAR1 *s1, void FAR1 *s2, unsigned len);
extern void tffsset(void FAR1 *dst, unsigned char value, unsigned len);
#endif /* USE_STD_FUNC */

#endif /* MTD_STANDALONE */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flbuffer.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLBUFFER.H_V  $
 * 
 *    Rev 1.3   Jul 13 2001 01:03:58   oris
 * Added read Back buffer size definition.
 * 
 *    Rev 1.2   May 16 2001 21:29:24   oris
 * Change "data" named variables to flData to avoid name clashes.
 * 
 *    Rev 1.2   May 16 2001 21:17:44   oris
 * Added backwards compatibility check for FL_MALLOC the new definition replacing MALLOC.
 * 
 *    Rev 1.1   Apr 01 2001 07:45:44   oris
 * Updated copywrite notice
 * 
 *    Rev 1.0   Feb 04 2001 11:17:06   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef FLBUFFER_H
#define FLBUFFER_H

#include "flbase.h"

#define READ_BACK_BUFFER_SIZE    1024 /* Size of read back buffer
                                         Must be multiplication of 512 */
typedef struct {
  unsigned char flData[SECTOR_SIZE];	/* sector buffer */
  SectorNo	sectorNo;		/* current sector in buffer */
  void		*owner;			/* owner of buffer */
  FLBoolean	dirty;			/* sector in buffer was changed */
  FLBoolean	checkPoint;		/* sector in buffer must be flushed */
} FLBuffer;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flchkdef.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/flchkdef.h_V  $
 * 
 *    Rev 1.12   Apr 15 2002 07:36:30   oris
 * Moved binary module definitions from mtdsa.h. 
 * Changed automatic definition of missing compilation flags to error massages.
 * 
 *    Rev 1.11   Feb 19 2002 20:59:36   oris
 * Added check for  TL_LEAVE_BINARY_AREA and FL_LEAVE_BINARY_AREA compatibility.
 * 
 *    Rev 1.10   Jan 29 2002 20:08:18   oris
 * Changed LOW_LEVEL compilation flag with FL_LOW_LEVEL to prevent definition clashes.
 * 
 *    Rev 1.9   Jan 23 2002 23:31:26   oris
 * Added prevention of multiple include directives.
 * 
 *    Rev 1.8   Jan 17 2002 23:00:56   oris
 * Changed TrueFFSVersion to "5100"
 * Made sure FL_FAR_MALLOC exists
 * Made sure MTD_RECONSTRUCT_BBT is defined if FORMAT_VOLUME is defined.
 * Made sure QUICK_MOUNT_FEATURE is defined
 * 
 *    Rev 1.7   Nov 20 2001 20:25:08   oris
 * Changed TrueFFS version to "5040". This version is written by the format routine on the media header.
 * 
 *    Rev 1.6   Jul 15 2001 20:44:56   oris
 * Changed default DFORMAT_PRINT from nothing to DEBUG_PRINT in order to remove warrnings.
 * 
 *    Rev 1.5   Jul 13 2001 01:04:20   oris
 * Added definition check for DFORMAT_PRINT,FL_FOPEN , FL_FCLOSE, FL_FPRINTF macros.
 * 
 *    Rev 1.4   May 16 2001 21:18:14   oris
 * Added backwards compatibility check for FL_MALLOC the new definition replacing MALLOC.
 * 
 *    Rev 1.3   Apr 01 2001 07:52:06   oris
 * copywrite notice.
 * Alligned left all # directives.
 * 
 *    Rev 1.2   Feb 13 2001 02:19:44   oris
 * Added TrueFFSVersion (internal version label) define.
 *
 *    Rev 1.1   Feb 07 2001 18:55:44   oris
 * Added check if LOW_LEVEL is not defined before defining it in Validity check for LOW_LEVEL
 *
 *    Rev 1.0   Feb 05 2001 18:41:14   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/************************/
/* TrueFFS source files */
/* -------------------- */
/************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Name : flchkdef.h                                                          *
*                                                                            *
* Description : Sanity check for flcustom.h files.                           *
*                                                                            *
*****************************************************************************/

#ifndef _FL_CHK_DEFS_H_
#define _FL_CHK_DEFS_H_


/* Osak version
 *
 * Number written on the flash by INFTL format specifing the OSAK version
 * The media was formated with. the number bellow specifies version
 * 5.1.0.0
 */

#define TrueFFSVersion "5100"           /* Internal TrueFFS version number */

/*******************************************/
/* Validity check and overlapping defines  */
/*******************************************/

/* The TL uses a diffrent defintion from the one the public interface uses 
 * but when format parameters are sent to the TL no convertion is made. 
 * the result is that both definitions must be the same.
 */

#if (defined(TL_LEAVE_BINARY_AREA) && defined(FL_LEAVE_BINARY_AREA))
#if TL_LEAVE_BINARY_AREA != FL_LEAVE_BINARY_AREA
#error "FL_LEAVE_BINARY_AREA and FL_LEAVE_BINARY_AREA must have the same value"
#endif
#endif /* TL_LEAVE_BINARY_AREA && FL_LEAVE_BINARY_AREA */

/* Validiy check for FL_LOW_LEVEL compilation flag.
 *
 * Starting from TrueFFS 5.1 the LOW_LEVEL was changed to FL_LOW_LEVEL
 * The reason was that it clashed with Windows NT LOW_LEVEL macro.
 */

#ifndef FL_LOW_LEVEL
#ifdef LOW_LEVEL
#define FL_LOW_LEVEL
#endif /* LOW_LEVEL */
#endif /* FL_LOW_LEVEL */


/* Validiy check for FL_MALLOC and FL_FREE macroes
 *
 * Starting from TrueFFS 5.0 the FREE and MALLOC macroes were
 * changed to FL_MALLOC and FL_FREE in order to avoid name clashes.
 * In order to keep backwards compatibility with previous flsystem.h
 * files the following new defintions checks were added.
 * if your system uses the FREE and MALLOC defintion simply comment
 * them out and customized the FL_MALLOC and FL_FREE macroes in your
 * flsystem.h file.
 */

#if (defined(MALLOC) && !defined(FL_MALLOC))
#define FL_MALLOC MALLOC
#endif /* MALLOC && ! FL_MALLOC */
#if (defined(FREE) && !defined(FL_FREE))
#define FL_FREE   FREE
#endif /* FREE && ! FL_FREE */

/* Validity check for FL_FAR_MALLOC and FL_FAR_FREE
 * Due to the BIOS driver memory limitations a dedicated routine 
 * is used for allocating the large ram arrays.
 */

#if (defined(FL_MALLOC) && !defined(FL_FAR_MALLOC))
#define FL_FAR_MALLOC FL_MALLOC 
#endif /* FL_MALLOC && ! FL_FAR_MALLOC */

#if (defined(FL_FREE) && !defined(FL_FAR_FREE))
#define FL_FAR_FREE FL_FREE 
#endif /* FL_MALLOC && ! FL_FAR_MALLOC */

/* Validity check for BDK_ACCESS */

#if (defined (WRITE_EXB_IMAGE) && !defined (BDK_ACCESS))
#error "Please make sure BDK_ACCESS is defined in your flcustom.h file\r\n"
#endif

/* The format option needs some internal defintions */

#ifdef FORMAT_VOLUME
#ifndef MTD_RECONSTRUCT_BBT
#define MTD_RECONSTRUCT_BBT /* Compile code to scan virgin cards for BBT */
#endif /* MTD_RECONSTRUCT_BBT */
#endif /* FORMAT_VOLUME */


/*
 * Make sure TrueFFS has all the neccesary definition for the
 * Binary partition module.
 */

#ifdef  BDK_ACCESS
#define ACCESS_BDK_IMAGE    /* Compile the Binary read routines          */
#ifndef FL_READ_ONLY
#define UPDATE_BDK_IMAGE    /* Compile the Binary write routines         */
#define ERASE_BDK_IMAGE     /* Compile the Binary erase routine          */
#define CREATE_BDK_IMAGE    /* Compile the Binary create routine         */
#endif /* FL_READ_ONLY */
#ifdef  HW_PROTECTION
#define PROTECT_BDK_IMAGE /* Compile the Binary protection routines  */
#endif /* HW_PROTECTION */
#endif /* BDK_ACCESS */

/* Validity check for system files MACROES */
#ifndef DFORMAT_PRINT
#define DFORMAT_PRINT DEBUG_PRINT
#endif /* DFORMAT_PRINT */
#ifndef FL_FOPEN
#define FL_FOPEN
#endif /* FL_FOPEN */
#ifndef FL_FCLOSE
#define FL_FCLOSE
#endif /* FL_FCLOSE */
#ifndef FL_FPRINTF
#define FL_FPRINTF
#endif /* FL_FPRINTF */

/* Validity check of DRIVES , VOLUMES and SOCKETS parameters.
 * Note that DRIVES definition was left for abckwards compatibility
 */

#if (defined(DRIVES) && (defined(SOCKETS) || defined(VOLUMES)))
#error "Drives is permited only as long as SOCKETS and VOLUMES are not defined"
#else
#ifdef DRIVES
#define SOCKETS DRIVES
#define VOLUMES DRIVES
#else
#if (!defined(VOLUMES) && !defined(SOCKETS))
#error "Neither DRIVER, VOLUMES and SOCKETS are defined"
#else
#if (!defined(VOLUMES) && defined(SOCKETS))
#define VOLUMES SOCKETS /* both VOLUMES and SOCKETS must be defined */
#else
#if !defined(SOCKETS) && defined(VOLUMES)
#define SOCKETS VOLUMES /* both VOLUMES and SOCKETS must be defined */
#else
#if (SOCKETS>VOLUMES)
#error "SOCKETS should not be bigger then VOLUMES"
#endif /*   SOCKETS >    VOLUMES */
#endif /* ! SOCKETS &&   VOLUMES */
#endif /*   SOCKETS && ! VOLUMES */
#endif /* ! SOCKETS && ! VOLUMES */
#endif /*         DRIVES         */
#endif /* DRIVES && (SOCKETS || VOLUMES) */

/*****************************/
/* M-Systems forced defaults */
/*****************************/

/* Since TrueFFS 5.1 Quick mount is a default for all INFTL formated devices */

#define QUICK_MOUNT_FEATURE

/* Some S/W modules like boot SDK  do not need the read bad blocks tables routine.
 * However for TrueFFS these defintion is vital
 */
#define MTD_READ_BBT        /* Compile the read BBT routine code         */

#endif /* _FL_CHK_DEFS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flformat.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLFORMAT.H_V  $
 * 
 *    Rev 1.9   Apr 15 2002 07:36:52   oris
 * Bug fix - Standard format was changed
 *  - includes only 1 Disk partitions and not 2.
 *  - leave 2 spare units in case power failure occurs while writing into the last unit.
 * 
 *    Rev 1.8   Feb 19 2002 20:59:52   oris
 * Changed default spare units to 2
 * 
 *    Rev 1.7   Jan 21 2002 20:44:44   oris
 * Changed comments.
 * 
 *    Rev 1.6   Sep 15 2001 23:46:24   oris
 * Changed progress callback routine to support up to 64K units.
 * 
 *    Rev 1.5   Jun 17 2001 08:18:54   oris
 * Changed exbFlag field to word
 * Added typedef FLStatus (*FLProgressCallback)(int totalUnitsToFormat, int totalUnitsFormattedSoFar);
 * 
 *    Rev 1.4   Apr 16 2001 13:42:22   oris
 * Removed warrnings by changing some of the fields types.
 * 
 *    Rev 1.3   Apr 01 2001 07:54:42   oris
 * copywrite notice.
 * Spelling mistake "changable".
 * Compression parameters were changed in order to prevent floating point math.
 * 
 *    Rev 1.2   Feb 18 2001 12:03:32   oris
 * Added TL_OLD_FORMAT defintion.
 *
 *    Rev 1.1   Feb 13 2001 01:44:40   oris
 * Moved the TL_FORMAT_COMPRESSION and TL_FORMAT_FAT defintion from blockdev.h
 *
 *    Rev 1.0   Feb 02 2001 13:57:58   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Name : flformat.h                                                          *
*                                                                            *
* Description : This file contains data strucutres passed to the format      *
*               routines.                                                    *
*                                                                            *
* Note : If dos format is also needed include dosformt.h instead             *
*                                                                            *
*****************************************************************************/

#ifndef FORMAT_H
#define FORMAT_H

#include "flbase.h"

/*********************************************/
/* Formatting parameter structure definition */
/*********************************************/

/*----------------------------------------------*/
/* User BDTL Partition Format Parameters record */
/*----------------------------------------------*/

typedef struct {
dword   length;
        /* The size of the usable storage space. The size will be
           rounded upwards to a multiplication of a block size.
           The size of the last partition will calculated automatically,
           but if the requested size is greater then the remaining space
           an error code will be returned,. Requesting zero size for any
	   partition but the last will generate an flBadParameters status. */

unsigned        noOfSpareUnits;
        /* BDTL needs at least one spare erase unit in order to function
           as a read/write media. It is possible to specify more than one
           spare unit, which takes more media space. The advantage of
           specifying more than one spare unit is that if one of the flash
           erase units becomes bad and inerasable in the future, then one
           of the spare units can replace it. In that case, a second spare
           unit enables TrueFFS to continue its read/write functionality,
           whereas if no second spare unit is available the media goes into
           read-only mode. The standard value used is 1 */

byte   flags;

#define TL_FORMAT_COMPRESSION  1  /* Add ZIP format on the media      */
#define TL_FORMAT_FAT          2  /* Add FAT format on the media      */
#define TL_OLD_FORMAT          4  /* Format with 1 sector per cluster */

byte            volumeId[4];  /* DOS partition identification number		  */

byte FAR1 *     volumeLabel;  /*DOS partition label string. If NULL, no label */

byte         noOfFATcopies;
        /* It is customary to format DOS media with two FAT copies. The
           first copy is always used, but more copies make it possible
           to recover if the FAT becomes corrupted (a rare occurrence).
           On the other hand, this slows down performance and uses media
           space. The standard value used is 2. */
#ifdef HW_PROTECTION
byte   protectionKey[8];   /* The key for the protection*/
byte   protectionType;
       /* PROTECTABLE          - Can recieve protection           */
       /* READ_PROTECTED       - Protect against read operations  */
       /* WRITE_PROTECTED      - Protect against write operations */
       /* LOCK_ENABLED         - Enables the hardware lock signal */
       /* PROTECTABLE          - This partition can be protected  */
       /* CHANGEABLE_PROTECTION - protection type can be changed */
#endif /* HW_PROTECTION */
#ifdef COMPRESSION
  word          ratioDenominator;
  word          ratioNominator;
#endif /* COMPRESSION */
       /* The ratio between the real media size and the virtual size
          reported to the file system when compression is active. */
} BDTLPartitionFormatParams;

/*------------------------------------------------*/
/* User binary Partition Format Parameters record */
/*------------------------------------------------*/

typedef struct {
dword length;	/* Required number of good blocks in the  partition.*/

byte sign[4];	/* signature of the binary  partition to format. 
                   The signature 0xFFFF FFFF is not a valid signature */

byte signOffset;
	/* offset of the signature. This value should  always be 8, but it
	   can also accept 0 for backwards compatibility reasons. Note that
	   if the offset is 0 EDC\ECC is neutralized */
#ifdef HW_PROTECTION
byte   protectionKey[8];   /* The key for the protection*/
byte   protectionType;
       /* PROTECTABLE          - Can recieve protection           */
       /* READ_PROTECTED       - Protect against read operations  */
       /* WRITE_PROTECTED      - Protect against write operations */
       /* LOCK_ENABLED         - Enables the hardware lock signal */
       /* PROTECTABLE          - This partition can be protected  */
       /* CHANGEABLE_PROTECTION - protection type can be changed */
#endif /* HW_PROTECTION */
} BinaryPartitionFormatParams;


/*-----------------------------------------------------------------*/
/* User Format Parameters record for flFormatPhysicalDrive routine */
/*-----------------------------------------------------------------*/

typedef FLStatus (*FLProgressCallback)(word totalUnitsToFormat, word totalUnitsFormattedSoFar);

typedef struct {

/*****************************/
/* Device formatting section */
/*****************************/

byte        percentUse;
     	/* BDTL performance depends on how full the flash media is,
		   becoming slower as the media becomes closer to 100% full.
		   It is possible to avoid the worst-case performance
		   (at 100% full) by formatting the media to less than 100%
		   capacity, thus guaranteeing free space at all times. This
		   of course sacrifices some capacity. The standard value
		   used is 98 */

byte             noOfBDTLPartitions;
		/* Indicates the number of BDTL partitions (1 to 4). 0 will
           cause a single STD_BDTL_PARAMS BDTL partition */

byte             noOfBinaryPartitions;
       /* Indicates the number of binary partitions (up to 3). 0 will
	      cause formatting with no binary partition. This value is ignored
	  unless the TL_BINARY_FORMAT flag is set in the irFlags f the ioreq */

BDTLPartitionFormatParams   FAR2* BDTLPartitionInfo;
       /* BDTL partition information array  */

BinaryPartitionFormatParams FAR2* binaryPartitionInfo;
       /* Binary partition information array*/

/***********************************/
/* Special format features section */
/***********************************/

#ifdef WRITE_EXB_IMAGE

void FAR1 *     exbBuffer;
	/* A buffer containing the EXB file. Optionaly this file can
	   contain only the first 512 bytes of the file while the rest
	   will be sent using consequitive calls to flPlaceExbByBuffer */

dword           exbBufferLen;     /* Size of the given EXB buffer */

dword           exbLen; /* The specific size to leave for the EXB */

word            exbWindow; /* Set explicit DiskOnChip window base */

word            exbFlags;  /* For the flags list see doc2exb.h */

#endif /* WRITE_EXB_IMAGE */

byte            cascadedDeviceNo;    /* Not used */

byte            noOfCascadedDevices; /* Not used */

FLProgressCallback progressCallback;
	/* Progress callback routine, will be called if not NULL.
	   The callback routine is called after erasing each unit,
	   and its parameters are the total number of erase units
	   to format and the number erased so far.
	   The callback routine returns a Status value. A value of
	   OK (0) allows formatting to continue. Any other value
	   will abort the formatting with the returned status code. */

/* Note the following section is not used by for DiskOnChips */
/*************************************************************/

dword        	vmAddressingLimit;
	    /* A part of the FTL Virtual Map always resides in RAM. The
	       RAM part is the one that is used to address the part of
	       the media below the VM addressing limit. Reading and
		   writing to this part is usually faster to some degree.
		   The downside is that the bigger the limit, the more RAM
		   size is required.
		   To get the extra RAM requirement in bytes, divide the
		   limit by 128 or by 256, depending on whether you
		   specified in #2.9 more than 32 or not, respectively.
		   The minimum VM limit is 0.
		   The standard value to use is 0x10000 (first 64 KBytes) */

word	    embeddedCISlength;
		/* Length in bytes of CIS to embed after the unit header */

byte FAR1 *	    embeddedCIS;
		/* The unit header is structured as a beginning of a PCMCIA
		   'tuple' chain (a CIS). The unit header contains a
		   data-organization tuple, which points past the end of the
		   unit header to a location which usually just contains
		   hex FF's which mark an 'end-of-tuple-chain'. Optionally,
		   it is possible to embed an entire CIS chain at this
		   location. If so, 'embeddedCISlength' marks the length in
		   bytes */
} FormatParams2;

/*----------------------------------------------------------*/
/* User Format Parameters record for flFormatVolume routine */
/*----------------------------------------------------------*/

typedef struct {
  /* FTL formatting section */
  long int	bootImageLen;
		/* Space to reserve for a boot-image at the start of the
		   medium. The FLite volume will begin at the next higher
		   erase unit boundary */

  unsigned	percentUse;
		/* FTL performance depends on how full the Flash media is,
		   getting slower when the media is close to 100%. It is
		   possible to avoid the worst consequences of this effect by
		   formatting the media to less than 100% capacity, so
		   guaranteeing some free space at all times. This of course
		   sacrifices some capcity.
		   The standard value to use is 98 */

  unsigned	noOfSpareUnits;
		/* BDTL partitions needs at least one spare erase unit to function as
           a read/write media. That unit is normally taken from the transfer
           units specified by the percentUsed field, but it is possible to 
           specify additional units (which takes more media space). This 
           ensures that if all the transfer units become bad and inerasable,
           the spare unit enables TrueFFS to continue its read/write
           functionality. Conversely, if no spare units are available the
           media may switch into read-only mode. The standard value used is 1 */


  dword	    vmAddressingLimit;
		/* A part of the FTL Virtual Map always resides in RAM. The
		   RAM part is the one that is used to address the part of
		   the media below the VM addressing limit. Reading and
		   writing to this part is usually faster to some degree.
		   The downside is that the bigger the limit, the more RAM
		   size is required.
		   To get the extra RAM requirement in bytes, divide the
		   limit by 128 or by 256, depending on whether you
		   specified in #2.9 more than 32 or not, respectively.
		   The minimum VM limit is 0.
		   The standard value to use is 0x10000 (first 64 KBytes) */


FLProgressCallback progressCallback;
		/* Progress callback routine, will be called if not NULL.
		   The callback routine is called after erasing each unit,
		   and its parameters are the total number of erase units
		   to format and the number erased so far.
		   The callback routine returns a Status value. A value of
		   OK (0) allows formatting to continue. Any other value
		   will abort the formatting with the returned status code. */

  /* DOS formatting section */
  char		volumeId[4];
		/* Volume identification number */

  char FAR1 *	volumeLabel;
		/* Volume label string. If NULL, no label */

  unsigned 	noOfFATcopies;
		/* It is customary to format DOS media with 2 FAT copies.
		   The first copy is always used, but more copies make it
		   possible to recover if the FAT becomes corrupted (a
		   rare occurrence). On the other hand, this slows down
		   performance and uses media space.
		   The standard value to use is 2 */

  unsigned	embeddedCISlength;
		/* Length in bytes of CIS to embed after the unit header */

  char FAR1 *	embeddedCIS;
		/* The unit header is structured as a beginning of a PCMCIA
		   'tuple' chain (a CIS). The unit header contains a
		   data-organization tuple, which points past the end of the
		   unit header to a location which usually just contains
		   hex FF's which mark an 'end-of-tuple-chain'. Optionally,
		   it is possible to embed an entire CIS chain at this
		   location. If so, 'embeddedCISlength' marks the length in
		   bytes */

} FormatParams;

/*----------------------------------------------------------*/
/* Format Parameters record passed to the translation layer */
/*----------------------------------------------------------*/

typedef struct {

  /* Global device info */

  Sdword	  bootImageLen;

  byte            percentUse;

  byte            noOfBDTLPartitions;

  byte            noOfBinaryPartitions;

  BDTLPartitionFormatParams   FAR2* BDTLPartitionInfo;

  BinaryPartitionFormatParams FAR2* binaryPartitionInfo;

  byte            flags;

  /* First volume info */

#ifdef HW_PROTECTION
  byte            protectionKey[8];

  byte            protectionType;
#endif /* HW_PROTECTION */
#ifdef COMPRESSION
  word            ratioDenominator;
  word            ratioNominator;
#endif /* COMPRESSION */

  byte            noOfSpareUnits;

  byte        	  volumeId[4];

  byte FAR1 *	  volumeLabel;

  byte            noOfFATcopies;

  /* Special features */

#ifdef WRITE_EXB_IMAGE

  Sdword          exbLen;

#endif /* WRITE_EXB_IMAGE */

  byte            cascadedDeviceNo;

  byte            noOfCascadedDevices;

  FLProgressCallback progressCallback;

  dword           osakVersion;

  /* None DiskOnChip parameters */

  dword           vmAddressingLimit;

  word            embeddedCISlength;

  byte FAR1 *	  embeddedCIS;

} TLFormatParams;

#define BINARY_SIGNATURE_NAME 4
#define BINARY_SIGNATURE_LEN  8
#define SIGN_SPL       ""

/* Standard initializer for BDTLPartitionFormatParams structure */

#ifdef HW_PROTECTION
#ifdef COMPRESSION
#define STD_BDTL_PARAMS {0,2,TL_FORMAT_FAT,{0,0,0,0},NULL,2,{0,0,0,0,0,0,0,0},0,0,2}
#else
#define STD_BDTL_PARAMS {0,2,TL_FORMAT_FAT,{0,0,0,0},NULL,2,{0,0,0,0,0,0,0,0},0}
#endif /* COMPRESSION */
#else
#ifdef COMPRESSION
#define STD_BDTL_PARAMS {0,2,TL_FORMAT_FAT,{0,0,0,0},NULL,2,0,2}
#else
#define STD_BDTL_PARAMS {0,2,TL_FORMAT_FAT,{0,0,0,0},NULL,2}
#endif /* COMPRESSION */
#endif /* HW_PROTECTION */

/* Standard initializer for BinaryPartitionFormatParams structure */

#ifdef HW_PROTECTION
#define STD_BINARY_PARAMS {0,{'B','I','P','O'},8,{0,0,0,0,0,0,0,0},0}
#else
#define STD_BINARY_PARAMS {0,{'B','I','P','O'},8}
#endif /* HW_PROTECTION */

/* Standard initializer for FormatParams2 structure */

#ifdef WRITE_EXB_IMAGE
#define STD_FORMAT_PARAMS2 {98,1,0,NULL,NULL,NULL,0,0,0,0,0,0,NULL,0x10000l,0,NULL}
#else
#define STD_FORMAT_PARAMS2 {98,1,0,NULL,NULL,0,0,NULL,0x10000l,0,NULL}
#endif /* WRITE_EXB_IMAGE */

/* Standard initializer for FormatParams structure */

#define STD_FORMAT_PARAMS	{-1, 98, 2, 0x10000l, NULL, {0,0,0,0}, NULL, 2, 0, NULL}

#endif /* FORMAT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flcustom.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Custom/FLCUSTOM.C_V  $
 *
 *    Rev 1.2   Feb 18 2001 23:42:04   oris
 * Moved flPolicy, flUseMultiDoc and flMaxUnitChain to blockdev.c.
 *
 *    Rev 1.1   Feb 14 2001 02:19:28   oris
 * Added flMaxUnitChain environment variable.
 * Changed flUseMultiDoc and flPolicy variables type and names.
 *
 *    Rev 1.0   Feb 04 2001 13:31:02   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*              FAT-FTL Lite Software Development Kit                   */
/*              Copyright (C) M-Systems Ltd. 1995-1998                  */
/*                                                                      */
/************************************************************************/

#include "flsystem.h"
#include "stdcomp.h"

/* environment variables */
#ifdef ENVIRONMENT_VARS

unsigned char flUse8Bit;
unsigned char flUseNFTLCache;
unsigned char flUseisRAM;

/*-----------------------------------------------------------------------*/
/*                 f l s e t E n v V a r                                 */
/*  Sets the value of all env variables                                  */
/*  Parameters : None                                                    */
/*-----------------------------------------------------------------------*/
void flSetEnvVar(void)
{
 flUse8Bit               = 0;
 flUseNFTLCache          = 1;
 flUseisRAM              = 0;
}

#endif /* ENVIRONMENT_VARS */

/*----------------------------------------------------------------------*/
/*            f l R e g i s t e r C o m p o n e n t s       */
/*                                  */
/* Register socket, MTD and translation layer components for use    */
/*                                  */
/* This function is called by FLite once only, at initialization of the */
/* FLite system.                            */
/*                                  */
/* Parameters:                                                          */
/*  None                                */
/*                                                                      */
/*----------------------------------------------------------------------*/

unsigned long window = 0L;

FLStatus
flRegisterComponents(void)
{
    flRegisterDOCSOC(window, window);

    #ifdef NT5PORT
    checkStatus(flRegisterNT5PCIC());
    #endif /*NT5PORT */

    flRegisterDOC2000();
    flRegisterDOCPLUS();

    checkStatus(flRegisterI28F008());   /* Register NOR-flash MTDs */
    checkStatus(flRegisterI28F016());

    checkStatus(flRegisterAMDMTD());
    checkStatus(flRegisterCFISCS());

    checkStatus(flRegisterINFTL());
    checkStatus(flRegisterNFTL());
    checkStatus(flRegisterFTL());

    return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flflash.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLFLASH.H_V  $
 * 
 *    Rev 1.17   Apr 15 2002 07:36:44   oris
 * Removed the use of NDOC2window  in access routine interface.
 * FL_NO_USE_FUNC now removes all of the access routines pointers.
 * 
 *    Rev 1.16   Feb 19 2002 20:59:44   oris
 * Bug fix changed definition of FL_IPL_MODE_XSCALE from 3 to 4.
 * 
 *    Rev 1.15   Jan 29 2002 20:08:26   oris
 * Changed FLAccessStruct definition to prevent compilation errors.
 * Added FL_IPL_MODE_XSCALE definition and change FL_IPL_XXX values.
 * 
 *    Rev 1.14   Jan 28 2002 21:24:48   oris
 * Added FL_IPL_DOWNLOAD flag to writeIPL routine in order to control whether the IPL will be reloaded after the update.
 * Added FLAccessStruct definition - used to get and set DiskOnChip memory access routines.
 * Removed win_io field from FLFlash record.
 * 
 *    Rev 1.13   Jan 23 2002 23:31:34   oris
 * Missing declaration of globalReadBack buffer, when MTD_RECONSTRUCT is defined.
 * 
 *    Rev 1.12   Jan 21 2002 20:44:32   oris
 * Bug fix - PARTIAL_EDC flag was support to incorporate EDC flag.
 * 
 *    Rev 1.11   Jan 20 2002 09:44:00   oris
 * Bug fix - changed include directive of flBuffer.h  to flbuffer.h
 * 
 *    Rev 1.10   Jan 17 2002 23:01:28   oris
 * Added flFlashOf() prototype.
 * New memory access routines mechanism :
 *  - Added memory access routines pointers in FLFlash.
 *  - Added win_io and win fields to FLFlash record pointing to DiskOnChip IO registers and window base.
 *  - Added busAccessType.
 * Moved CardAddress typedef and NDOC2window typedefs from flbase.h
 * Added DiskOnChip Millennium Plus 16MB type MDOCP_16_TYPE.
 * Added the following definitions FL_IPL_MODE_NORMAL / FL_IPL_MODE_SA /  MAX_PROTECTED_PARTITIONS /MAX_SECTORS_PER_BLOCK
 * Added Another flag to writeIPL for Strong Arm mode.
 * 
 *    Rev 1.9   Sep 15 2001 23:46:08   oris
 * Changed erase routine to support up to 64K erase blocks.
 * Added reconstruct flag to readBBT routine - stating whether to reconstruct BBT if it is not available.
 * 
 *    Rev 1.8   Jul 13 2001 01:04:48   oris
 * Added include directive to flBuffer and readBack buffer forward definition under the MTD_STANDALONE compilation flag.
 * Added volNo field to the socket record under the MTD_STANDALONE compilation flag.
 * Added definition for PARTIAL_EDC flash read mode.
 * Added protection default key.
 * Added bad block marking in the BBT (BBT_BAD_UNIT).
 * Moved syndrome length definition to reedsol files.
 * Added new field in FLFlash record - Max Erase Cycles of the flash.
 * Changed interleave field in FLFlash record to signed.
 *
 *    Rev 1.7   May 16 2001 21:18:30   oris
 * Moved SYNDROM_BYTES definition from diskonc.h and mdocplus.h.
 * Added forward definition for saveSyndromForDumping global EDC\ECC syndrome buffer.
 * Changed DATA definition to FL_DATA.
 *
 *    Rev 1.6   May 02 2001 06:40:58   oris
 * Removed the lastUsableBlock variable.
 * Added the BBT_UNAVAIL_UNIT defintion.
 *
 *    Rev 1.5   Apr 24 2001 17:08:12   oris
 * Added lastUsableBlock field and changed firstUsableBlock type to dword.
 *
 *    Rev 1.4   Apr 16 2001 13:40:48   oris
 * Added firstUsableBlock.
 * Removed warrnings by changing some of the fields types.
 *
 *    Rev 1.3   Apr 12 2001 06:51:12   oris
 * Changed protectionBounries and protectionSet routine to be floor specific.
 * Changed powerdown prototype.
 * Added download prototype.
 *
 *    Rev 1.2   Apr 01 2001 07:54:24   oris
 * copywrite notice.
 * Moved protection attributes definition from mdocplus.h
 * Changed prototype of routine pointers in flflash struct :read,write routines to dword length.
 * Other routine pointer prototypes have been changed as well.
 * Removed interface b routine pointers from flflash struct (experimental MTD interface for mdocp).
 * Changed prototype of :read,write routine to enabled dword length.
 * Changed unsigned char to byte.
 * Changed unsigned long to dword.
 * Changed long int to Sdword.
 * Spelling mistake "changable".
 *
 *    Rev 1.1   Feb 13 2001 01:37:38   oris
 * Changed ENTER_DEEP_POWER_DOWN_MODE to DEEP_POWER_DOWN
 * Changed LOCKED to LOCKED_OTP
 *
 *    Rev 1.0   Feb 04 2001 11:30:44   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#ifndef FLFLASH_H
#define FLFLASH_H

#include "flbase.h"
#ifndef MTD_STANDALONE
#include "flsocket.h"
#else
#include "flbuffer.h" /* defintion for READ_BACK_BUFFER_SIZE */

  typedef struct tSocket FLSocket;
  struct tSocket
  {
    unsigned      volNo;   /* Volume no. of socket */
    void FAR0 *   base;    /* Pointer to window base */
    Sdword        size;    /* Window size (must by power of 2) */
  };

#if (defined (VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT))
extern byte globalReadBack[SOCKETS][READ_BACK_BUFFER_SIZE];
#endif /* VERIFY_WRITE */

extern FLSocket *flSocketOf(unsigned volNo);
extern FLBuffer  globalMTDBuffer;
extern int       noOfMTDs;

/* Replacement for various TrueFFS typedefs */

typedef unsigned long CardAddress;        /* Physical offset on card */

#endif /* MTD_STANDALONE */

/* Some useful types for mapped Flash locations */

typedef volatile byte FAR0 * FlashPTR;
typedef volatile unsigned short int FAR0 * FlashWPTR;
typedef volatile dword FAR0 * FlashDPTR;
typedef unsigned short FlashType;        /* JEDEC id */
typedef volatile unsigned char FAR0* NDOC2window;

/* DiskOnChip memory access routines type defintions */

/* Doc memory read routine         */
typedef  void (FLMemRead)(volatile byte FAR1* win,word regOffset,byte FAR1* dest,word count);
/* Doc memory write routine        */
typedef  void (FLMemWrite)(volatile byte FAR1* win,word regOffset,byte FAR1* src,word count);
/* Doc memory set routine          */
typedef  void (FLMemSet)(volatile byte FAR1* win,word regOffset,word count, byte val);
/* Doc memory 8 bit read routine   */
typedef  byte (FLMemRead8bit)(volatile byte FAR1* win,word offset);
/* Doc memory 8 bit write routine  */
typedef  void (FLMemWrite8bit)(volatile byte FAR1* win,word offset,byte Data);
/* Doc memory 16 bit read routine  */
typedef  word (FLMemRead16bit)(volatile byte FAR1* win,word offset);
/* Doc memory 16 bit write routine */
typedef  void (FLMemWrite16bit)(volatile byte FAR1* win,word offset,word Data);
/* Doc memory window size */
typedef  dword (FLMemWindowSize)(void);

typedef struct {        /* DiskOnChip memory access routines */
  dword                 access; /* Output only */
  FLMemRead       FAR1* memRead;
  FLMemWrite      FAR1* memWrite;
  FLMemSet        FAR1* memSet;
  FLMemRead8bit   FAR1* memRead8bit;
  FLMemWrite8bit  FAR1* memWrite8bit;
  FLMemRead16bit  FAR1* memRead16bit;
  FLMemWrite16bit FAR1* memWrite16bit;
  FLMemWindowSize FAR1* memWindowSize;
}FLAccessStruct;

#define NOT_FLASH          0

/* Media types */
#define NOT_DOC_TYPE       0
#define DOC_TYPE           1
#define MDOC_TYPE          2
#define DOC2000TSOP_TYPE   3
#define MDOCP_TYPE         4
#define MDOCP_16_TYPE      5

/* page characteristics flags */
#define  BIG_PAGE    0x0100             /* page size > 100H*/
#define  FULL_PAGE   0x0200                  /* no partial page programming*/
#define  BIG_ADDR    0x0400             /* 4 byte address cycle */

/* MTD write routine mode flags */
#define FL_DATA       0      /* Read/Write data area                */
#define OVERWRITE     1      /* Overwriting non-erased area         */
#define EDC           2      /* Activate ECC/EDC                    */
#define EXTRA         4      /* Read/write spare area               */
#define PARTIAL_EDC   10     /* Read with EDC even for partial page */
#define NO_SECOND_TRY 0x8000 /* do not read again on EDC error      */

/* Protection attributes */

#define PROTECTABLE           1  /* partition can recieve protection */
#define READ_PROTECTED        2  /* partition is read protected      */
#define WRITE_PROTECTED       4  /* partition is write protected     */
#define LOCK_ENABLED          8  /* HW lock signal is enabled        */
#define LOCK_ASSERTED         16 /* HW lock signal is asserted       */
#define KEY_INSERTED          32 /* key is inserted (not currently   */
#define CHANGEABLE_PROTECTION 64 /* changeable protection area type   */

/* protection specific defintions */
#define DO_NOT_COMMIT_PROTECTION 0 /* The new values will take affect only after reset */
#define COMMIT_PROTECTION        1 /* The new values will take affect imidiatly        */
#define PROTECTION_KEY_LENGTH    8 /* Size of protection key in bytes    */  
#define MAX_PROTECTED_PARTITIONS 2 /* Max Number of protected partitiosn */
#define DEFAULT_KEY              "00000000"

/* IPL modes */
#define FL_IPL_MODE_NORMAL 0 /* IPL - Written as usual                     */
#define FL_IPL_DOWNLOAD    1 /* IPL - Force download of new IPL            */
#define FL_IPL_MODE_SA     2 /* IPL - Written with Strong Arm mode enabled */
#define FL_IPL_MODE_XSCALE 4 /* IPL - Written with X-Scale mode enabled    */

/* OTP specific defintions */
#define CUSTOMER_ID_LEN          4
#define UNIQUE_ID_LEN            16

/* BBT block types */
#define BBT_GOOD_UNIT            0xff
#define BBT_UNAVAIL_UNIT         0x1
#define BBT_BAD_UNIT             0x0

/* General purpose */
#define MAX_SECTORS_PER_BLOCK    64

/*----------------------------------------------------------------------*/
/*                 Flash array identification structure                 */
/*                                                                      */
/* This structure contains a description of the Flash array and         */
/* routine pointers for the map, read, write & erase functions.         */
/*                                                                      */
/* The structure is initialized by the MTD that identifies the Flash    */
/* array.                                                               */
/* On entry to an MTD, the Flash structure contains default routines    */
/* for all operations. This routines are sufficient forread-only access */
/* to NOR Flash on a memory-mapped socket. The MTD should override the  */
/* default routines with MTD specific ones when appropriate.            */
/*----------------------------------------------------------------------*/

/* Flash array identification structure */

typedef struct tFlash FLFlash;                /* Forward definition */

struct tFlash {
  FlashType type;                 /* Flash device type (JEDEC id)           */
  byte      mediaType;            /* see media types obove                  */
  byte      ppp;                  /* number of allowed PPP                  */
  dword busAccessType;            /* saves bus access type                  */
  dword maxEraseCycles;           /* erase cycles limit per erase block     */
  dword changeableProtectedAreas; /* areas capable of changing protection   */
                                  /* attribute with no danger of loosing    */
                                  /* the entire chip                        */
  byte   totalProtectedAreas;     /* total number of protection arweas      */
  dword  erasableBlockSize;       /* Smallest physically erasable size      */
                                  /* (with interleaving taken into account) */
  byte      erasableBlockSizeBits;/* Bits representing the erasable block   */
  dword     chipSize;          /* chip size                                 */
  byte      noOfFloors;        /* no of controllers in array                */
  word      pageSize;          /* size of flash page in bytes               */
  word      noOfChips;         /* no of chips in array                      */
  dword     firstUsableBlock;  /* Some devices may not use all of the media */
                               /* blocks. For example mdocplus can not use  */
                               /* the first 3 blocks.                       */
  Sword     interleaving;      /* chip interleaving (The interleaving is    */
                               /* defined as the address difference between */
                               /* two consecutive bytes on a chip)          */
  word      flags;             /* Special capabilities & options Bits 0-7   */
                               /* may be used by FLite. Bits 8-15 are not   */
                               /* used bt FLite and may beused by MTD's for */
                               /* MTD-specific purposes.                    */
  /* Flag bit values */

#define SUSPEND_FOR_WRITE        1        /* MTD provides suspend for write */
#define NFTL_ENABLED             2        /* Flash can run NFTL             */
#define INFTL_ENABLED            4        /* Flash can run INFTL            */
#define EXTERNAL_EPROM           8        /* Can support external eprom     */

  void *    mtdVars;           /* Points to MTD private area for this socket.*/
                               /* This field, if used by the MTD, is         */
                               /* initialized bythe MTD identification       */
                               /* routine.                                   */
  FLSocket * socket;           /* Socket of this drive. Note that 2 diffrent */
                               /* records are used. One for OSAK and the     */
                               /* other forstandalone applications.          */
  NDOC2window win;             /* DiskOnChip memory windows                  */


#ifdef NT5PORT
  ULONG readBufferSize;
  VOID * readBuffer;
#endif /*NT5PORT*/

  
/*----------------------------------------------------------------------*/
/*                        f l a s h . m a p                             */
/*                                                                      */
/* MTD specific map routine                                             */
/*                                                                      */
/* The default routine maps by socket mapping, and is suitable for all  */
/* NOR Flash.                                                           */
/* NAND or other type Flash should use map-through-copy emulation: Read */
/* a block of Flash to an internal buffer and return a pointer to that  */
/* buffer.                                                              */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      address            : Card address to map                        */
/*      length             : Length to map                              */
/*                                                                      */
/* Returns:                                                             */
/*        Pointer to required card address                              */
/*----------------------------------------------------------------------*/
  void FAR0 * (*map)(FLFlash *, CardAddress, int);

/*----------------------------------------------------------------------*/
/*                        f l a s h . r e a d                           */
/*                                                                      */
/* MTD specific Flash read routine                                      */
/*                                                                      */
/* The default routine reads by copying from a mapped window, and is    */
/* suitable for all NOR Flash.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      address            : Card address to read                       */
/*      buffer             : Area to read into                          */
/*      length             : Length to read                             */
/*      modes              : See write mode flags definition above      */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*read)(FLFlash *, CardAddress, void FAR1 *, dword, word);

/*----------------------------------------------------------------------*/
/*                       f l a s h . w r i t e                          */
/*                                                                      */
/* MTD specific Flash write routine                                     */
/*                                                                      */
/* The default routine returns a write-protect error.                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      address            : Card address to write to                   */
/*      buffer             : Address of data to write                   */
/*      length             : Number of bytes to write                   */
/*      modes              : See write mode flags definition above      */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, failed otherwise              */
/*----------------------------------------------------------------------*/
  FLStatus (*write)(FLFlash *, CardAddress, const void FAR1 *, dword, word);

/*----------------------------------------------------------------------*/
/*                       f l a s h . e r a s e                          */
/*                                                                      */
/* Erase one or more contiguous Flash erasable blocks                   */
/*                                                                      */
/* The default routine returns a write-protect error.                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                 : Pointer identifying drive                 */
/*      firstErasableBlock  : Number of first block to erase            */
/*      numOfErasableBlocks : Number of blocks to erase                 */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, failed otherwise              */
/*----------------------------------------------------------------------*/
  FLStatus (*erase)(FLFlash *, word, word);

/*----------------------------------------------------------------------*/
/*               f l a s h . s e t P o w e r O n C a l l b a c k        */
/*                                                                      */
/* Register power on callback routine. Default: no routine is           */
/* registered.                                                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*                                                                      */
/*----------------------------------------------------------------------*/
  void (*setPowerOnCallback)(FLFlash *);

/*----------------------------------------------------------------------*/
/*                        f l a s h . r e a d B B T                     */
/*                                                                      */
/* MTD specific Flash routine returning the media units status          */
/* Note that a unit can contain more then 1 erase block                 */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      unitNo             : Number of the first unit to check          */
/*      unitsToRead        : Number of units to check                   */
/*      blockMultiplier    : Number of blocks per erase unit            */
/*      buffer             : Buffer to return the units status          */
/*      reconstruct        : TRUE for reconstruct BBT from virgin card  */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*readBBT)(FLFlash *, dword unitNo, dword unitsToRead,
              byte blockMultiplier,byte FAR1 * buffer, FLBoolean reconstruct);

/*----------------------------------------------------------------------*/
/*                    f l a s h . w r i t e I P L                       */
/*                                                                      */
/* MTD specific Flash write IPL area routine                            */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      buffer             : Buffer containing the data to write        */
/*      length             : Length to write                            */
/*      flags              : Flags of write IPL operation (see obove)   */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*writeIPL)(FLFlash *, const void FAR1 * buffer, word length, 
                       byte offset , unsigned flags);
/*----------------------------------------------------------------------*/
/*                     f l a s h . r e a d I P L                        */
/*                                                                      */
/* MTD specific Flash read area IPL routine                             */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      buffer             : Area to read into                          */
/*      length             : Length to read                             */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*readIPL)(FLFlash *, void FAR1 * buffer, word length);

#ifdef HW_OTP

/*----------------------------------------------------------------------*/
/*                        f l a s h . w r i t e O T P                   */
/*                                                                      */
/* MTD specific Flash write and lock OTP area routine                   */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      buffer             : buffer containing the data to write        */
/*      length             : Length to write                            */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*writeOTP)(FLFlash *, const void FAR1 * buffer,word length);

/*----------------------------------------------------------------------*/
/*                        f l a s h . r e a d O T P                     */
/*                                                                      */
/* MTD specific Flash read OTP area routine                             */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      offset             : Offset from the begining of the OTP arae   */
/*      buffer             : Area to read into                          */
/*      length             : Length to read                             */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*readOTP)(FLFlash *, word offset, void FAR1 * buffer, word length);

/*----------------------------------------------------------------------*/
/*                        f l a s h . otpSize                           */
/*                                                                      */
/* MTD specific Flash get OTP area size and state                       */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      sectionSize        : total size of the OTP area                 */
/*      usedSize           : Used (and locked) size of the OTP area     */
/*      locked             : LOCKED_OTP flag stating the locked state   */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*otpSize)(FLFlash *,  dword FAR2* sectionSize,
             dword FAR2* usedSize, word FAR2* locked);
#define LOCKED_OTP 1
#endif /* HW_OTP */
/*----------------------------------------------------------------------*/
/*                  f l a s h . g e t U n i q u e I d                   */
/*                                                                      */
/* MTD specific Flash get the chip unique ID                            */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      buffer             : byte buffer to read unique ID into         */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*getUniqueId)(FLFlash *, void FAR1 * buffer);
#ifdef  HW_PROTECTION
/*----------------------------------------------------------------------*/
/*        f l a s h . p r o t e c t i o n B o u n d r i e s             */
/*                                                                      */
/* MTD specific Flash get protection boundries  routine                 */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      areaNo             : Protection area number to work on          */
/*      addressLow         : Low boundary Address of protected area     */
/*      addressHigh        : High boundary Address of protected area    */
/*      floorNo            : The floor to work on.                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*protectionBoundries)(FLFlash *, byte areaNo,
            CardAddress* addressLow ,CardAddress* addressHigh, byte floorNo);

/*----------------------------------------------------------------------*/
/*        f l a s h . p r o t e c t i o n K e y I n s e r t             */
/*                                                                      */
/* MTD specific Flash insert the protection key routine                 */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Note the key is inserted only to protected areas and to all floors   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      areaNo             : Protection area number to work on          */
/*      key                : protection key buffer                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*protectionKeyInsert)(FLFlash *, byte areaNo, byte FAR1* key);

/*----------------------------------------------------------------------*/
/*        f l a s h . p r o t e c t i o n K e y R e m o v e             */
/*                                                                      */
/* MTD specific Flash remove the protection key routine                 */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Note the key is removed from all floors.                             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      areaNo             : Protection area number to work on          */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*protectionKeyRemove)(FLFlash *,byte areaNo);

/*----------------------------------------------------------------------*/
/*        f l a s h . p r o t e c t i o n T y p e                       */
/*                                                                      */
/* MTD specific Flash get protection type routine                       */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Note the type is the combined attributes of all the floors.          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      areaNo             : Protection area number to work on          */
/*      areaType           : returnining the protection type            */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*protectionType)(FLFlash *,byte areaNo, word* areaType);

/*----------------------------------------------------------------------*/
/*              f l a s h . p r o t e c t i o n S e t                   */
/*                                                                      */
/* MTD specific Flash get protection type routine                       */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol           : Pointer identifying drive                       */
/*      areaNo        : Protection area number to work on               */
/*      areaType      : Protection area type                            */
/*      addressLow    : Low boundary Address of protected area          */
/*      addressHigh   : High boundary Address of protected area         */
/*      key           : protection key buffer                           */
/*      modes         : Either COMMIT_PROTECTION will cause the new     */
/*                      values to take affect immidiatly or             */
/*                      DO_NOT_COMMIT_PROTECTION for delaying the new   */
/*                      values to take affect only after the next reset.*/
/*      floorNo       : The floor to work on.                           */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*protectionSet )( FLFlash *,byte areaNo, word areaType ,
        CardAddress addressLow, CardAddress addressHigh,
            byte FAR1* key , byte modes , byte floorNo);

#endif /* HW_PROTECTION */

/*----------------------------------------------------------------------*/
/*      f l a s h . e n t e r D e e p P o w e r D o w n M o d e         */
/*                                                                      */
/* MTD specific Flash enter deep power down mode routine                */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*      state              : DEEP_POWER_DOWN                            */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*enterDeepPowerDownMode)(FLFlash *,word state);

#define DEEP_POWER_DOWN 1 /* must be the same as in blockdev.h */

/*----------------------------------------------------------------------*/
/*                    f l a s h . d o w n l o a d                       */
/*                                                                      */
/* MTD specific - Reset download mechanizm to download IPL and          */
/*                protection attributes.                                */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*                                                                      */
/*----------------------------------------------------------------------*/
  FLStatus (*download)(FLFlash *);

/*----------------------------------------------------------------------*/
/* DiskOnChip memory access routines type defintions                    */
/*----------------------------------------------------------------------*/

  FLMemWindowSize FAR1* memWindowSize; /* Doc memory window size          */
#ifndef FL_NO_USE_FUNC
  FLMemRead       FAR1* memRead;       /* Doc memory read routine         */
  FLMemWrite      FAR1* memWrite;      /* Doc memory write routine        */
  FLMemSet        FAR1* memSet;        /* Doc memory set routine          */
  FLMemRead8bit   FAR1* memRead8bit;   /* Doc memory 8 bit read routine   */
  FLMemWrite8bit  FAR1* memWrite8bit;  /* Doc memory 8 bit write routine  */
  FLMemRead16bit  FAR1* memRead16bit;  /* Doc memory 16 bit read routine  */
  FLMemWrite16bit FAR1* memWrite16bit; /* Doc memory 16 bit write routine */
#endif /* FL_NO_USE_FUNC */
};

/* MTD registration information */

extern int noOfMTDs;        /* No. of MTDs actually registered */

typedef FLStatus (*MTDidentifyRoutine) (FLFlash *);

extern MTDidentifyRoutine mtdTable[MTDS];

/* Returns specific flash structure of the socket */

extern FLFlash * flFlashOf(unsigned volNo);

#ifdef MTD_STANDALONE
typedef FLStatus (*SOCKETidentifyRoutine) (FLSocket * ,
          dword lowAddress, dword highAddress);
typedef void     (*FREEmtd) (FLSocket vol);

extern SOCKETidentifyRoutine socketTable[MTDS];
extern FREEmtd               freeTable[MTDS];

#else

/* The address of this, if returned from map, denotes a data error */

extern FLStatus dataErrorObject;

#define dataErrorToken ((void FAR0 *) &dataErrorObject)

/* See interface documentation of functions in flflash.c        */

extern void flIntelIdentify(FLFlash *,
                void (*)(FLFlash *, CardAddress, byte, FlashPTR),
                CardAddress);

extern FLStatus        flIntelSize(FLFlash *,
                void (*)(FLFlash *, CardAddress, byte, FlashPTR),
                CardAddress);

extern FLStatus        flIdentifyFlash(FLSocket *socket, FLFlash *flash);

#ifdef NT5PORT
extern VOID * mapThroughBuffer(FLFlash *flash, CardAddress address, LONG length);
#endif /*NT5PORT*/


#endif /* MTD_STANDALONE */
#endif
/*----------------------------------------------------------------------*/
/*              f l a s h . r e s e t I n t e r r u p t                 */
/*                                                                      */
/* MTD specific Flash reset the interrupt signal routine                */
/*                                                                      */
/* No default routine is implemented for this routine.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol                : Pointer identifying drive                  */
/*                                                                      */
/*----------------------------------------------------------------------*/
/*void (*resetInterrupt)(FLFlash vol); */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flcustom.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Custom/FLCUSTOM.H_V  $
 * 
 *    Rev 1.12   Jan 29 2002 20:11:56   oris
 * Changed LOW_LEVEL compilation flag with FL_LOW_LEVEL to prevent definition clashes.
 * 
 *    Rev 1.11   Jan 20 2002 20:42:34   oris
 * FL_NO_USE_FUNC  is now commented.
 * 
 *    Rev 1.10   Jan 20 2002 12:03:46   oris
 * Updated driverVersion and OSAKVersion to 5.1
 * Removed FAT- lite (FILES 0)
 * Changed VOLUMES to 4*SOCKETS
 * Commented WRITE_EXB_IMAGE / WRITE_PROTECTION.
 * Uncommneted VERIFY_WRITE (for protection against power failures).
 * Changed MAX_VOLUME_MBYTES to 1GB
 * Changed TLS to 2 (since multi-doc was removed)
 * Removed QUICK_MOUNT_FEATURE (since it is defained by default in flchkdfs)
 * Removed MULTI_DOC / SEPERATED_CASCADED / FL_BACKGROUND
 * Added FL_NO_USE_FUNC definition.
 * 
 *    Rev 1.9   Nov 16 2001 00:33:44   oris
 * Added NO_NFTL_2_INFTL compilation flag enabling 4.3 format converter.
 * 
 *    Rev 1.8   Jul 13 2001 00:56:58   oris
 * Added VERIFY_ERASE and VERIFY_WRITE.
 * 
 *    Rev 1.7   Jun 17 2001 16:43:46   oris
 * Improved documentation.
 * 
 *    Rev 1.6   Jun 17 2001 08:13:10   oris
 * Rearranged compilation flags orders.
 * 
 *    Rev 1.5   May 16 2001 23:07:02   oris
 * Increased number of Translation Layers to support Multi-DOC.
 * 
 *    Rev 1.4   May 09 2001 00:47:46   oris
 * Removed nested comments.
 * Added NO_PHYSICAL_IO, NO_IPL_CODE and NO_INQUIRE_CAPABILITIES compilation flag 
 * to reduce code.
 * 
 *    Rev 1.3   Feb 12 2001 12:19:50   oris
 * Added Multi-DOC compilation flag
 *
 *    Rev 1.2   Feb 08 2001 09:19:06   oris
 * Changed DRIVES to SOCKETS and VOLUMES
 * Moved SECTOR_SIZE_BITS to flbase.h
 * Added WRITE_EXB_IMAGE, QUICK_MOUNT_FEATURE, HW_OTP, HW_PROTECTION and BINARY_PARTITIONS
 * compilation flags. Added SEPERATED_CASCADED compilation flag.
 *
 *    Rev 1.1   Feb 05 2001 18:46:50   oris
 * Moved compilation flag sanity check to a different file in order to preserve backward
 * compatibility.
 *
 *    Rev 1.0   Feb 05 2001 12:21:36   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*              FAT-FTL Lite Software Development Kit                   */
/*              Copyright (C) M-Systems Ltd. 1995-2001                  */
/*                                                                      */
/************************************************************************/


#ifndef FLCUSTOM_H
#define FLCUSTOM_H


/* Driver & TrueFFS (OSAK) Version numbers */

#define driverVersion   "OS Less 5.1"
#define OSAKVersion     "5.1"

#define NT5PORT
#define D2000
#define DOC_DRIVES 4
/*
 *
 *              File System Customization
 *              -------------------------
 */

/* Number of sockets
 *
 * Defines the maximum number of physical drives supported.
 *
 * The actual number of sockets depends on which socket controllers are
 * actually registered and the number of sockets in the system.
 */

#define SOCKETS 8



/* Number of volumes
 *
 * Defines the maximum number of logical drives supported.
 *
 * The actual number of drives depends on which socket controllers are
 * actually registered, the amount of devices in the system and the
 * TL format of each device.
 */

#define VOLUMES		(DOC_DRIVES * 4 ) + SOCKETS - DOC_DRIVES



/* Number of open files
 *
 * Defines the maximum number of files that can be open at a time.
 */

#define FILES   0



/* Low level operations
 *
 * Uncomment the following line if you want to do low level operations
 * (i.e. read from a physical address, write to a physical address,
 * erase a unit according to its physical unit number, OTP and unique ID
 * operations.
 */

#define FL_LOW_LEVEL



/* Remove all write functions from the source. */

/* #define FL_READ_ONLY */



#ifndef FL_READ_ONLY

/* Placing EXB files
 *
 * Uncomment the following line if you need to place M-Systems firmware
 * (DOCxx.EXB file) on the media. The file will install itself as a
 * BIOS extension driver, hooking INT13h to emulate a HD.
 */

#define WRITE_EXB_IMAGE



/* Formatting
 *
 * Uncomment the following line if you need to format the media.
 */

#define FORMAT_VOLUME



/* Defragmentation
 *
 * Uncomment the following line if you need to defragment with
 * flDefragmentVolume.
 */

#define DEFRAGMENT_VOLUME

#endif /* FL_READ_ONLY */



/* Sub-directories
 *
 * Uncomment the following line if you need support for sub-directories
 * using the FAT-FLITE file system.
 */

/*#define SUB_DIRECTORY*/



/* Rename file
 *
 * Uncomment the following line if you need to rename files with
 * flRenameFile.
 */

/*#define RENAME_FILE**/



/* Split / join file
 *
 * Uncomment the following line if you need to split or join files with
 * flSplitFile and flJoinFile.
 */

/* #define SPLIT_JOIN_FILE */



/* 12-bit FAT support
 *
 * Comment the following line if you do not need support for DOS media with
 * 12-bit FAT (typically media of 8 MBytes or less).
 */

#define FAT_12BIT



/* Parse path function
 *
 * Uncomment the following line if you need to parse DOS-like path names
 * with flParsePath.
 */

/*#define PARSE_PATH*/



/* Maximum supported medium size.
 *
 * Define here the largest Flash medium size (in MBytes) you want supported.
 *
 * This define is used for the static memory allocation configuration
 * of the driver. If your TrueFFS based application or driver are using
 * dynamic allocation you should keep this define as large as possible (288L).
 *
 * Note: This define also dictates the size of the TrueFFS internal
 * "sectorNo" type forcing it to 2 bytes when MAX_VOLUME_MBYTES is less
 * then 64L. Using a smaller size than your actual device might cause
 * casting problems even when using dynamic allocation.
 */

#define MAX_VOLUME_MBYTES       1024L



/* Assumed card parameters.
 *
 * This issue is relevant only if you are not defining any dynamic allocation
 * routines in flsystem.h.
 *
 * The following are assumptions about parameters of the Flash media.
 * They affect the size of the heap buffer allocated for the translation
 * layer.
 */

/* NAND flash */
#define ASSUMED_NFTL_UNIT_SIZE  0x2000l         /* NAND */

/* NOR flash */
#define ASSUMED_FTL_UNIT_SIZE   0x20000l        /* Intel interleave-2 (NOR) */
#define ASSUMED_VM_LIMIT        0x10000l        /* limit at 64 KB */



/* Absolute read & write
 *
 * Uncomment the following line if you want to be able to read & write
 * sectors by absolute sector number (i.e. without regard to files and
 * directories).
 */

#define ABS_READ_WRITE



/* Application exit
 *
 * If the FLite application ever exits, it needs to call flEXit before
 * exiting. Uncomment the following line to enable this.
 */

#define EXIT


 
/* Number of sectors per FAT cluster
 *
 * Define the minimum cluster size in sectors.
 */

#define MIN_CLUSTER_SIZE   4



/*
 *
 * Socket Hardware Customization
 * -----------------------------
 */

/* Vpp voltage
 *
 * If your socket does not supply 12 volts, comment the following line. In
 * this case, you will be able to work only with Flash devices that do not
 * require external 12 Volt Vpp.
 *
 */

#define SOCKET_12_VOLTS



/* Fixed or removable media
 *
 * If your Flash media is fixed, uncomment the following line.
 */

/*#define FIXED_MEDIA*/



/* Interval timer
 *
 * The following defines a timer polling interval in milliseconds. If the
 * value is 0, an interval timer is not installed.
 *
 * If you select an interval timer, you should provide an implementation
 * for 'flInstallTimer' defined in flsysfun.h.
 *
 * An interval timer is not a must, but it is recommended. The following
 * will occur if an interval timer is absent:
 *
 * - Card changes can be recognized only if socket hardware detects them.
 * - The Vpp delayed turn-off procedure is not applied. This may downgrade
 *   write performance significantly if the Vpp switching time is slow.
 * - The watchdog timer that guards against certain operations being stuck
 *   indefinitely will not be active.
 */

/* Polling interval in millisec. If 0, no polling is done */

#define POLLING_INTERVAL 1500           



/* Maximum MTD's and Translation Layers
 *
 * Define here the maximum number of Memory Technology Drivers (MTD) and
 * Translation Layers (TL) that may be installed. Note that the actual
 * number installed is determined by which components are installed in
 * 'flRegisterComponents' (flcustom.c).
 */

#define MTDS	10	/* Up to 5 MTD's */

#define	TLS	3	/* Up to 3 Translation Layers */



/* BDTL cash
 *
 * Enable Block Device Translation Layer cache.
 *
 * Turning on this option improves performance but requires additional
 * RAM resources.
 *
 * The NAND Flash Translation Layer (NFTL) and (INFTL) are specifications
 * for storing data on the DiskOnChip in a way that enables accessing the
 * DiskOnChip as a Virtual Block Device. If this option is on, then the BDTL 
 * keeps in RAM a table that saves some of the flash accesses.
 * Whenever it is needed to change table entry, the BDTL updates it in the
 * RAM table and on the DiskOnChip. If NFTL has to read table entry, then you
 * can save time on reading sector from DiskOnChip.
 */

/* #define NFTL_CACHE */



/* Environment Variables
 *
 * Enable environment variables control of the TrueFFS features.
 *
 */
#define ENVIRONMENT_VARS



/* IO Controll Interface
 *
 * Support standard IOCTL interface.
 *
 */

#define IOCTL_INTERFACE



/* S/W Write protection
 *
 * Enable S/W write protection of the device.
 *
 */

#define WRITE_PROTECTION

/* Definitions required for write protection. */

#ifdef WRITE_PROTECTION
#define ABS_READ_WRITE
#define SCRAMBLE_KEY_1  647777603l
#define SCRAMBLE_KEY_2  232324057l
#endif



/* H/W OTP
 *
 * Enable H/W One Time Programing capability including unique ID/
 *
 */

#define HW_OTP



/* H/W Protection
 *
 * Enable H/W protection of the device.
 *
 */

#define HW_PROTECTION 



/* Read after write
 *
 * Add read after every write verifing data integrity. Make sure that
 * flVerifyWrite variable is also set to 1.
 *
 */

#define VERIFY_WRITE



/* Verify entire volume
 *
 * Scan the entire disk partition for power failures symptoms and correct them.
 *
 */

#define VERIFY_VOLUME 



/* Read after erase
 *
 * Add read after every erase operation verifing data integrity.
 *
 */

/* #define VERIFY_ERASE */



 /* Binary Partition
 *
 * Enables access to the Binary partition.
 *
 */

#define BDK_ACCESS



/* Definitions required for BDK operations. */

#ifdef BDK_ACCESS

 /* Number of Binary partitions on the DiskOnChip.
 *
 * Defines Maximum Number of Binary partitions on the DiskOnChip.
 *
 * The actual number of partitions depends on the format placed
 * on each device.
 */

#define BINARY_PARTITIONS 3

#endif /* BDK_ACCESS */



/* Remove runtime controll over memory access routines 
 *
 * If defined memory access routines will be set at compile time using 
 * dedicated defintions in flsystem.h
 * Note : when compile time customization is chosen, you must sepcify
 * the bus width even when working with DiskOnChip Millennium Plus.
 * Refer to Trueffs manual for more infromation.
 */

/* #define FL_NO_USE_FUNC */



/* Remove IPL code.
 *
 * Removes the IPL code (This applies only to DiskOnChip Millennium Plus 
 * and DiskOnChip 2000 TSOP).
 *
 */

/* #define NO_IPL_CODE */



/*
 * Removes Physical access code
 *
 */

/* #define NO_PHYSICAL_IO */



/*
 *  Removes the inquire capability code.
 *
 */

/* #define NO_INQUIRE_CAPABILITIES */



/*
 *  Removes read Bad Block Table code. 
 *
 */

/* #define NO_READ_BBT_CODE */



/*
 *  Removes read Bad Block Table code. 
 *
 */

/* #define NO_NFTL_2_INFTL */

#endif /* FLCUSTOM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flioctl.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLIOCTL.C_V  $
 * 
 *    Rev 1.7   May 09 2001 00:45:48   oris
 * Changed protection ioctl interface to prevent the use of input buffer as an output buffer.
 * 
 *    Rev 1.6   Apr 16 2001 13:43:28   oris
 * Removed warrnings.
 * 
 *    Rev 1.5   Apr 09 2001 15:09:20   oris
 * End with an empty line.
 * 
 *    Rev 1.4   Apr 01 2001 15:16:26   oris
 * Updated inquire capability ioctl - diffrent input and output records.
 *
 *    Rev 1.3   Apr 01 2001 07:58:30   oris
 * copywrite notice.
 * FL_IOCTL_FORMAT_PHYSICAL_DRIVE ioctl is not under the LOW_LEVEL compilation flag.
 * Bug fix - BDK_GET_INFO no longer calls bdkCreate().
 *
 *    Rev 1.2   Feb 14 2001 02:15:00   oris
 * Updated inquire capabilities ioctl.
 *
 *    Rev 1.1   Feb 13 2001 01:52:20   oris
 * Added the following new IO Controls:
 *   FL_IOCTL_FORMAT_VOLUME2,
 *   FL_IOCTL_FORMAT_PARTITION,
 *   FL_IOCTL_BDTL_HW_PROTECTION,
 *   FL_IOCTL_BINARY_HW_PROTECTION,
 *   FL_IOCTL_OTP,
 *   FL_IOCTL_CUSTOMER_ID,
 *   FL_IOCTL_UNIQUE_ID,
 *   FL_IOCTL_NUMBER_OF_PARTITIONS,
 *   FL_IOCTL_SUPPORTED_FEATURES,
 *   FL_IOCTL_SET_ENVIRONMENT_VARIABLES,
 *   FL_IOCTL_PLACE_EXB_BY_BUFFER,
 *   FL_IOCTL_WRITE_IPL,
 *   FL_IOCTL_DEEP_POWER_DOWN_MODE,
 * and BDK_GET_INFO type in FL_IOCTL_BDK_OPERATION
 * Those IOCTL were not qualed and the TrueFFS 5.0 should be release with revision 1.0 of this this file.
 *
 *    Rev 1.0   Feb 04 2001 11:37:36   oris
 * Initial revision.
 *
 */
/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#include "flioctl.h"
#include "blockdev.h"

#ifdef IOCTL_INTERFACE

FLStatus flIOctl(IOreq FAR2 *ioreq1)
{
  IOreq ioreq2;
  void FAR1 *inputRecord;
  void FAR1 *outputRecord;

  inputRecord = ((flIOctlRecord FAR1 *)(ioreq1->irData))->inputRecord;
  outputRecord = ((flIOctlRecord FAR1 *)(ioreq1->irData))->outputRecord;
  ioreq2.irHandle = ioreq1->irHandle;

  switch (ioreq1->irFlags) {
    case FL_IOCTL_GET_INFO:
    {
      flDiskInfoOutput FAR1 *outputRec = (flDiskInfoOutput FAR1 *)outputRecord;

      ioreq2.irData = &(outputRec->info);
      outputRec->status = flVolumeInfo(&ioreq2);
      return outputRec->status;
    }

#ifdef DEFRAGMENT_VOLUME
    case FL_IOCTL_DEFRAGMENT:
    {
      flDefragInput FAR1 *inputRec = (flDefragInput FAR1 *)inputRecord;
      flDefragOutput FAR1 *outputRec = (flDefragOutput FAR1 *)outputRecord;

      ioreq2.irLength = inputRec->requiredNoOfSectors;
      outputRec->status = flDefragmentVolume(&ioreq2);
      outputRec->actualNoOfSectors = ioreq2.irLength;
      return outputRec->status;
    }
#endif /* DEFRAGMENT_VOLUME */
#ifndef FL_READ_ONLY
#ifdef WRITE_PROTECTION
    case FL_IOCTL_WRITE_PROTECT:
    {
      flWriteProtectInput FAR1 *inputRec = (flWriteProtectInput FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      ioreq2.irData = inputRec->password;
      ioreq2.irFlags = inputRec->type;
      outputRec->status = flWriteProtection(&ioreq2);
      return outputRec->status;
    }
#endif /* WRITE_PROTECTION */
#endif /* FL_READ_ONLY */
    case FL_IOCTL_MOUNT_VOLUME:
    {
      flMountInput FAR1 *inputRec = (flMountInput FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      if (inputRec->type == FL_DISMOUNT)
        outputRec->status = flDismountVolume(&ioreq2);
      else
        outputRec->status = flAbsMountVolume(&ioreq2);
      return outputRec->status;
    }

#ifdef FORMAT_VOLUME
    case FL_IOCTL_FORMAT_VOLUME:
    {
      flFormatInput FAR1 *inputRec = (flFormatInput FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      ioreq2.irFlags = inputRec->formatType;
      ioreq2.irData = &(inputRec->fp);
      outputRec->status = flFormatVolume(&ioreq2);
      return outputRec->status;
    }

    case FL_IOCTL_FORMAT_LOGICAL_DRIVE:
    {
      flFormatLogicalInput FAR1 *inputRec = (flFormatLogicalInput FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      ioreq2.irData = &(inputRec->fp);
      outputRec->status = flFormatLogicalDrive(&ioreq2);
      return outputRec->status;
    }

    case FL_IOCTL_FORMAT_PHYSICAL_DRIVE:
    {
      flFormatPhysicalInput FAR1 *inputRec = (flFormatPhysicalInput FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      ioreq2.irFlags = inputRec->formatType;
      ioreq2.irData = &(inputRec->fp);
      outputRec->status = flFormatPhysicalDrive(&ioreq2);
      return outputRec->status;
    }
#endif /* FORMAT_VOLUME */

#ifdef BDK_ACCESS
    case FL_IOCTL_BDK_OPERATION:
    {
      flBDKOperationInput  FAR1 *inputRec  = (flBDKOperationInput  FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      ioreq2.irData = &(inputRec->bdkStruct);
      switch(inputRec->type) {
        case BDK_INIT_READ:
          outputRec->status = bdkReadInit(&ioreq2);
          break;
        case BDK_READ:
          outputRec->status = bdkReadBlock(&ioreq2);
          break;
        case BDK_GET_INFO:
          outputRec->status = bdkPartitionInfo(&ioreq2);
          break;
#ifndef FL_READ_ONLY
        case BDK_INIT_WRITE:
          outputRec->status = bdkWriteInit(&ioreq2);
          break;
        case BDK_WRITE:
          outputRec->status = bdkWriteBlock(&ioreq2);
          break;
        case BDK_ERASE:
          outputRec->status = bdkErase(&ioreq2);
          break;
        case BDK_CREATE:
          outputRec->status = bdkCreate(&ioreq2);
          break;
#endif   /* FL_READ_ONLY */
	default:
	  outputRec->status = flBadParameter;
          break;
      }
      return outputRec->status;
    }
#endif /* BDK_ACCESS */
#ifdef HW_PROTECTION
#ifdef BDK_ACCESS
    case FL_IOCTL_BINARY_HW_PROTECTION:
    {
      flProtectionInput    FAR1 *inputRec = (flProtectionInput FAR1 *)inputRecord;
      flProtectionOutput FAR1 *outputRec = (flProtectionOutput FAR1 *)outputRecord;

      switch(inputRec->type)
      {
	case PROTECTION_INSERT_KEY:
	  ioreq2.irData = inputRec->key;
	  outputRec->status = bdkInsertProtectionKey(&ioreq2);
	  break;
	case PROTECTION_REMOVE_KEY:
	  outputRec->status = bdkRemoveProtectionKey(&ioreq2);
	  break;
	case PROTECTION_GET_TYPE:
	  outputRec->status = bdkIdentifyProtection(&ioreq2);
	  outputRec->protectionType = (byte)ioreq2.irFlags;
	  break;
	case PROTECTION_DISABLE_LOCK:
	  ioreq2.irFlags = 0;
	  outputRec->status = bdkHardwareProtectionLock(&ioreq2);
	  break;
	case PROTECTION_ENABLE_LOCK:
	  ioreq2.irFlags = LOCK_ENABLED;
	  outputRec->status = bdkHardwareProtectionLock(&ioreq2);
	  break;
	case PROTECTION_CHANGE_KEY:
	  ioreq2.irData = inputRec->key;
	  outputRec->status = bdkChangeProtectionKey(&ioreq2);
	  break;
	case PROTECTION_CHANGE_TYPE:
	  ioreq2.irFlags = inputRec->protectionType;
	  outputRec->status = bdkChangeProtectionType(&ioreq2);
	  break;
        default:
          outputRec->status = flBadParameter;
          break;
      }
      return outputRec->status;
    }
#endif /* BDK_ACCESS */
    case FL_IOCTL_BDTL_HW_PROTECTION:
    {
      flProtectionInput  FAR1 *inputRec = (flProtectionInput FAR1 *)inputRecord;
      flProtectionOutput FAR1 *outputRec = (flProtectionOutput FAR1 *)outputRecord;

      switch(inputRec->type)
      {
	case PROTECTION_INSERT_KEY:
	  ioreq2.irData = inputRec->key;
	  outputRec->status = flInsertProtectionKey(&ioreq2);
	  break;
	case PROTECTION_REMOVE_KEY:
	  outputRec->status = flRemoveProtectionKey(&ioreq2);
	  break;
	case PROTECTION_GET_TYPE:
	  outputRec->status = flIdentifyProtection(&ioreq2);
	  outputRec->protectionType = (byte)ioreq2.irFlags;
	  break;
	case PROTECTION_DISABLE_LOCK:
	  ioreq2.irFlags = 0;
	  outputRec->status = flHardwareProtectionLock(&ioreq2);
	  break;
	case PROTECTION_ENABLE_LOCK:
	  ioreq2.irFlags = LOCK_ENABLED;
	  outputRec->status = flHardwareProtectionLock(&ioreq2);
	  break;
	case PROTECTION_CHANGE_KEY:
	  ioreq2.irData = inputRec->key;
	  outputRec->status = flChangeProtectionKey(&ioreq2);
	  break;
	case PROTECTION_CHANGE_TYPE:
	  ioreq2.irFlags = inputRec->protectionType;
	  outputRec->status = flChangeProtectionType(&ioreq2);
	  break;
	default:
	  outputRec->status = flBadParameter;
	  break;
      }
      return outputRec->status;
    }
#endif /* HW_PROTECTION */
#ifdef HW_OTP
    case FL_IOCTL_OTP:
    {
      flOtpInput           FAR1 *inputRec  = (flOtpInput FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      switch(inputRec->type)
      {
         case OTP_SIZE:
   	   outputRec->status = flOTPSize(&ioreq2);
	   inputRec->lockedFlag = (byte)ioreq2.irFlags;
           inputRec->length     = ioreq2.irCount ;
	   inputRec->usedSize   = ioreq2.irLength ;
           break;
         case OTP_READ:
           ioreq2.irData   = inputRec->buffer;    /* user buffer  */
	   ioreq2.irCount  = inputRec->usedSize;  /* offset       */
           ioreq2.irLength = inputRec->length;    /* size to read */
           outputRec->status = flOTPRead(&ioreq2);
	   break;
         case OTP_WRITE_LOCK:
           ioreq2.irData   = inputRec->buffer;    /* user buffer  */
           ioreq2.irLength = inputRec->length;    /* size to read */
           outputRec->status = flOTPWriteAndLock(&ioreq2);
	   break;
         default:
	   outputRec->status = flBadParameter;
           break;
      }
      return outputRec->status;
    }

    case FL_IOCTL_CUSTOMER_ID:
    {
      flCustomerIdOutput FAR1 *outputRec = (flCustomerIdOutput FAR1 *)outputRecord;

      ioreq2.irData = outputRec->id;
      outputRec->status = flGetCustomerID(&ioreq2);
      return outputRec->status;
    }

    case FL_IOCTL_UNIQUE_ID:
    {
      flUniqueIdOutput FAR1 *outputRec = (flUniqueIdOutput FAR1 *)outputRecord;

      ioreq2.irData = outputRec->id;
      outputRec->status = flGetUniqueID(&ioreq2);
      return outputRec->status;
    }
#endif /* HW_OTP */

    case FL_IOCTL_NUMBER_OF_PARTITIONS:
    {
      flCountPartitionsOutput FAR1 *outputRec = (flCountPartitionsOutput FAR1 *)outputRecord;

      outputRec->status = flCountVolumes(&ioreq2);
      outputRec->noOfPartitions = (byte) ioreq2.irFlags;
      return outputRec->status;
    }

#ifdef LOW_LEVEL

    case FL_IOCTL_INQUIRE_CAPABILITIES:
    {
      flCapabilityInput FAR1 *inputRec = (flCapabilityInput FAR1 *)inputRecord;
      flCapabilityOutput FAR1 *outputRec = (flCapabilityOutput FAR1 *)outputRecord;

      ioreq2.irLength       = inputRec->capability;
      outputRec->status     = flInquireCapabilities(&ioreq2);
      outputRec->capability = ioreq2.irLength;
      return outputRec->status;
    }

#endif /* LOW_LEVEL */
#ifdef ENVIRONMENT_VARS

		/*
    case FL_IOCTL_EXTENDED_ENVIRONMENT_VARIABLES:
    {
      flEnvVarsInput  FAR1 *inputRec  = (flEnvVarsInput  FAR1 *)inputRecord;
      flEnvVarsOutput FAR1 *outputRec = (flEnvVarsOutput FAR1 *)outputRecord;
      outputRec->status = flSetEnv(inputRec->varName , inputRec->varValue, &(outputRec->prevValue));
      return outputRec->status;
    }
		*/
#endif /* ENVIRONMENT_VARS */
#ifdef LOW_LEVEL
#ifdef WRITE_EXB_IMAGE

    case FL_IOCTL_PLACE_EXB_BY_BUFFER:
    {
      flPlaceExbInput      FAR1 *inputRec  = (flPlaceExbInput      FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;
      ioreq2.irData       = inputRec->buf;
      ioreq2.irLength     = inputRec->bufLen;
      ioreq2.irWindowBase = inputRec->exbWindow;
      ioreq2.irFlags      = inputRec->exbFlags;
      outputRec->status   = flPlaceExbByBuffer(&ioreq2);
      return outputRec->status;
    }

#endif /* WRITE_EXB_IMAGE */

    case FL_IOCTL_EXTENDED_WRITE_IPL:
    {
      flIplInput           FAR1 *inputRec  = (flIplInput           FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;
      ioreq2.irData       = inputRec->buf;
      ioreq2.irLength     = inputRec->bufLen;
      outputRec->status   = flWriteIPL(&ioreq2);
      return outputRec->status;
    }

    case FL_IOCTL_DEEP_POWER_DOWN_MODE:
    {
      flPowerDownInput      FAR1 *inputRec  = (flPowerDownInput      FAR1 *)inputRecord;
      flOutputStatusRecord  FAR1 *outputRec = (flOutputStatusRecord  FAR1 *)outputRecord;
      ioreq2.irFlags    = inputRec->state;
      outputRec->status = flDeepPowerDownMode(&ioreq2);
      return outputRec->status;
    }

#endif /* LOW_LEVEL */
#ifdef ABS_READ_WRITE
#ifndef FL_READ_ONLY
    case FL_IOCTL_DELETE_SECTORS:
    {
      flDeleteSectorsInput FAR1 *inputRec = (flDeleteSectorsInput FAR1 *)inputRecord;
      flOutputStatusRecord FAR1 *outputRec = (flOutputStatusRecord FAR1 *)outputRecord;

      ioreq2.irSectorNo = inputRec->firstSector;
      ioreq2.irSectorCount = inputRec->numberOfSectors;
      outputRec->status = flAbsDelete(&ioreq2);
      return outputRec->status;
    }
#endif  /* FL_READ_ONLY */
    case FL_IOCTL_READ_SECTORS:
    {
      flReadWriteInput FAR1 *inputRec = (flReadWriteInput FAR1 *)inputRecord;
      flReadWriteOutput FAR1 *outputRec = (flReadWriteOutput FAR1 *)outputRecord;

      ioreq2.irSectorNo = inputRec->firstSector;
      ioreq2.irSectorCount = inputRec->numberOfSectors;
      ioreq2.irData = inputRec->buf;
      outputRec->status = flAbsRead(&ioreq2);
      outputRec->numberOfSectors = ioreq2.irSectorCount;
      return outputRec->status;
    }
#ifndef FL_READ_ONLY
    case FL_IOCTL_WRITE_SECTORS:
    {
      flReadWriteInput FAR1 *inputRec = (flReadWriteInput FAR1 *)inputRecord;
      flReadWriteOutput FAR1 *outputRec = (flReadWriteOutput FAR1 *)outputRecord;

      ioreq2.irSectorNo = inputRec->firstSector;
      ioreq2.irSectorCount = inputRec->numberOfSectors;
      ioreq2.irData = inputRec->buf;
      outputRec->status = flAbsWrite(&ioreq2);
      outputRec->numberOfSectors = ioreq2.irSectorCount;
      return outputRec->status;
    }
#endif   /* FL_READ_ONLY */
#endif  /* ABS_READ_WRITE */

    default:
      return flBadParameter;
  }
}

#endif /* IOCTL_INTERFACE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flfuncno.h ===
/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef FLFUNCNO_H
#define FLFUNCNO_H

/*************************************************************************************/
/* SPECIAL NOTE                                                                      */
/* ------------                                                                      */
/* The order of the enum bellow should be strictly kept since the bdcall function    */
/* utilizes the index values to simplify the function search                         */
/*************************************************************************************/

typedef enum {

/* The following routines are files related routines */

        /*********/
        /* FILES */
        /*********/

  FL_READ_FILE                  = 0,
  FL_WRITE_FILE,
  FL_SPLIT_FILE,
  FL_JOIN_FILE,
  FL_SEEK_FILE,
  FL_FIND_NEXT_FILE,
  FL_FIND_FILE,
  INDEX_WRITE_FILE_START        = 100,
  FL_CLOSE_FILE,
  INDEX_OPENFILES_END           = 200,
  FL_OPEN_FILE,
  FL_DELETE_FILE,
  FL_FIND_FIRST_FILE,
  FL_GET_DISK_INFO,
  FL_RENAME_FILE,
  FL_MAKE_DIR,
  FL_REMOVE_DIR,
  FL_FLUSH_BUFFER,
  FL_LAST_FAT_FUNCTION          = 300,

/* The following routines will not perform valid partition check */

       /**********/
       /* BINARY */
       /**********/

  INDEX_BINARY_START            = 400,
  FL_BINARY_WRITE_INIT,
  FL_BINARY_WRITE_BLOCK,
  FL_BINARY_CREATE,
  FL_BINARY_ERASE,
  FL_BINARY_PROTECTION_CHANGE_KEY,
  FL_BINARY_PROTECTION_CHANGE_LOCK,
  FL_BINARY_PROTECTION_SET_TYPE,
  INDEX_BINARY_WRITE_END        = 500,
  FL_BINARY_READ_INIT,
  FL_BINARY_READ_BLOCK,
  FL_BINARY_PARTITION_INFO,
  FL_BINARY_PROTECTION_GET_TYPE,
  FL_BINARY_PROTECTION_INSERT_KEY,
  FL_BINARY_PROTECTION_REMOVE_KEY,
  INDEX_BINARY_END              = 600,

/* The following routines must be called with partition number 0 */

  INDEX_NEED_PARTITION_0_START  = 700,
      /* OTP */
  FL_OTP_SIZE,
  FL_OTP_READ,
  FL_OTP_WRITE,
  FL_WRITE_IPL,
  FL_READ_IPL,
      /* PHYSICAL */
  FL_DEEP_POWER_DOWN_MODE,
  FL_GET_PHYSICAL_INFO,
  FL_PHYSICAL_READ,
  FL_PHYSICAL_WRITE,
  FL_PHYSICAL_ERASE,
  FL_UPDATE_SOCKET_PARAMS,
  FL_UNIQUE_ID,
  FL_CUSTOMER_ID,
  BD_FORMAT_VOLUME,
  BD_FORMAT_PHYSICAL_DRIVE,
  FL_PLACE_EXB,
  FL_READ_BBT,
  FL_WRITE_BBT,

  INDEX_NEED_PARTITION_0_END    = 800,

/* The following routines will go through the volume validity check */

      /* PROTECTION */
  FL_PROTECTION_GET_TYPE,
  FL_PROTECTION_REMOVE_KEY,
  FL_PROTECTION_INSERT_KEY,
  FL_PROTECTION_SET_LOCK,
  FL_PROTECTION_CHANGE_KEY,
  FL_PROTECTION_CHANGE_TYPE,
  FL_COUNT_VOLUMES,
  FL_INQUIRE_CAPABILITIES,
     /* BDTL */
  FL_MOUNT_VOLUME,
  FL_ABS_MOUNT,
  BD_FORMAT_LOGICAL_DRIVE,
  FL_WRITE_PROTECTION,
  FL_DISMOUNT_VOLUME,
  FL_CHECK_VOLUME,
  FL_DEFRAGMENT_VOLUME,
  FL_ABS_WRITE,
  FL_ABS_DELETE,
  FL_ABS_READ,
  FL_ABS_ADDRESS,
  FL_GET_BPB,
  FL_SECTORS_IN_VOLUME,
  FL_VOLUME_INFO,
  FL_VERIFY_VOLUME,
  FL_CLEAR_QUICK_MOUNT_INFO
} FLFunctionNo;


#endif /* FLFUNCNO_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flflash.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLFLASH.C_V  $
 * 
 *    Rev 1.12   Apr 15 2002 07:36:38   oris
 * Bug fix - do not initialize access routines in case of user defined routines - as a result docsys must be included.
 * 
 *    Rev 1.11   Jan 28 2002 21:24:38   oris
 * Changed memWinowSize to memWindowSize.
 * 
 *    Rev 1.10   Jan 17 2002 23:09:30   oris
 * Added flFlashOf() routine to allow the use of a single FLFlash record  per socket .
 * Added memory access routines initialization for FLFlash.
 * Bug fix - if M+ device was registered after 8-bit DiskOnChip and the M+  had a bad download problem , the error would not be reported, but only  flUnknown media.
 * 
 *    Rev 1.9   Sep 15 2001 23:46:00   oris
 * Changed erase routine to support up to 64K erase blocks.
 * 
 *    Rev 1.8   Jul 13 2001 01:04:38   oris
 * Added new field initialization in FLFlash record - Max Erase Cycles of the flash.
 * 
 *    Rev 1.7   May 16 2001 21:18:24   oris
 * Removed warnings.
 * 
 *    Rev 1.6   May 02 2001 06:41:26   oris
 * Removed the lastUsableBlock variable.
 * 
 *    Rev 1.5   Apr 24 2001 17:07:52   oris
 * Bug fix - missing NULL initialization for several compilation flags.
 * Added lastUsableBlock field defualt initialization.
 * 
 *    Rev 1.4   Apr 16 2001 13:39:14   oris
 * Bug fix read and write default routines were not initialized.
 * Initialize the firstUsableBlock.
 * Removed warrnings.
 * 
 *    Rev 1.3   Apr 12 2001 06:50:22   oris
 * Added initialization of download routine pointer.
 * 
 *    Rev 1.2   Apr 09 2001 15:09:04   oris
 * End with an empty line.
 * 
 *    Rev 1.1   Apr 01 2001 07:54:08   oris
 * copywrite notice.
 * Changed prototype of :flashRead.
 * Removed interface b initialization (experimental MTD interface for mdocp).
 * Spelling mistake "changableProtectedAreas".
 * Added check for bad download in flash recognition.
 *
 *    Rev 1.0   Feb 04 2001 11:21:16   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#include "flflash.h"
#include "docsys.h"

#define    READ_ID            0x90
#define    INTEL_READ_ARRAY        0xff
#define    AMD_READ_ARRAY        0xf0

/* MTD registration information */

int noOfMTDs = 0;

MTDidentifyRoutine mtdTable[MTDS];
static FLFlash vols[SOCKETS];

FLStatus dataErrorObject;

/*----------------------------------------------------------------------*/
/*                    f l F l a s h O f                   */
/*                                    */
/* Gets the flash connected to a volume no.                */
/*                                    */
/* Parameters:                                                          */
/*    volNo        : Volume no. for which to get flash        */
/*                                                                      */
/* Returns:                                                             */
/*     flash of volume no.                        */
/*----------------------------------------------------------------------*/

FLFlash *flFlashOf(unsigned volNo)
{
  return &vols[volNo];
}


/*----------------------------------------------------------------------*/
/*                      f l a s h M a p                */
/*                                    */
/* Default flash map method: Map through socket window.            */
/* This method is applicable for all NOR Flash                */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*      address        : Card address to map                */
/*    length        : Length to map (irrelevant here)        */
/*                                                                      */
/* Returns:                                                             */
/*    Pointer to required card address                */
/*----------------------------------------------------------------------*/

static void FAR0 *flashMap(FLFlash vol, CardAddress address, int length)
{
  return flMap(vol.socket,address);
}


/*----------------------------------------------------------------------*/
/*                      f l a s h R e a d                */
/*                                    */
/* Default flash read method: Read by copying from mapped address    */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*      address        : Card address to read                */
/*    buffer        : Area to read into                */
/*    length        : Length to read                */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus flashRead(FLFlash vol,
            CardAddress address,
            void FAR1 *buffer,
            dword length,
            word mode)
{
  tffscpy(buffer,vol.map(&vol,address,(word)length),(word)length);

  return flOK;
}



/*----------------------------------------------------------------------*/
/*                   f l a s h N o W r i t e            */
/*                                    */
/* Default flash write method: Write not allowed (read-only mode)    */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*      address        : Card address to write                */
/*    buffer        : Area to write from                */
/*    length        : Length to write                */
/*                                                                      */
/* Returns:                                                             */
/*    Write-protect error                        */
/*----------------------------------------------------------------------*/

static FLStatus flashNoWrite(FLFlash vol,
               CardAddress address,
               const void FAR1 *from,
               dword length,
               word mode)
{
  return flWriteProtect;
}


/*----------------------------------------------------------------------*/
/*                   f l a s h N o E r a s e            */
/*                                    */
/* Default flash erase method: Erase not allowed (read-only mode)    */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*      firstBlock    : No. of first erase block            */
/*    noOfBlocks    : No. of contiguous blocks to erase        */
/*                                                                      */
/* Returns:                                                             */
/*    Write-protect error                        */
/*----------------------------------------------------------------------*/

static FLStatus flashNoErase(FLFlash vol,
               word firstBlock,
               word noOfBlocks)
{
  return flWriteProtect;
}

/*----------------------------------------------------------------------*/
/*                   s e t N o C a l l b a c k            */
/*                                    */
/* Register power on callback routine. Default: no routine is         */
/* registered.                                */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void setNoCallback(FLFlash vol)
{
  flSetPowerOnCallback(vol.socket,NULL,NULL);
}

/*----------------------------------------------------------------------*/
/*                   f l I n t e l I d e n t i f y            */
/*                                    */
/* Identify the Flash type and interleaving for Intel-style Flash.    */
/* Sets the value of vol.type (JEDEC id) & vol.interleaving.            */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*    amdCmdRoutine    : Routine to read-id AMD/Fujitsu style at    */
/*              a specific location. If null, Intel procedure    */
/*              is used.                                      */
/*      idOffset    : Chip offset to use for identification        */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 = OK, otherwise failed (invalid Flash array)*/
/*----------------------------------------------------------------------*/

void flIntelIdentify(FLFlash vol,
                     void (*amdCmdRoutine)(FLFlash vol, CardAddress,
                     unsigned char, FlashPTR),
                     CardAddress idOffset)
{
  int inlv;

  unsigned char vendorId = 0;
  FlashPTR flashPtr = (FlashPTR) flMap(vol.socket,idOffset);
  unsigned char firstByte = 0;
  unsigned char resetCmd = amdCmdRoutine ? AMD_READ_ARRAY : INTEL_READ_ARRAY;

  for (inlv = 0; inlv < 15; inlv++) {    /* Increase interleaving until failure */
    flashPtr[inlv] = resetCmd;    /* Reset the chip */
    flashPtr[inlv] = resetCmd;    /* Once again for luck */
    if (inlv == 0)
      firstByte = flashPtr[0];     /* Remember byte on 1st chip */
    if (amdCmdRoutine)    /* AMD: use unlock sequence */
      amdCmdRoutine(&vol,idOffset + inlv, READ_ID, flashPtr);
    else
      flashPtr[inlv] = READ_ID;    /* Read chip id */
    if (inlv == 0)
      vendorId = flashPtr[0];    /* Assume first chip responded */
    else if (flashPtr[inlv] != vendorId || firstByte != flashPtr[0]) {
      /* All chips should respond in the same way. We know interleaving = n */
      /* when writing to chip n affects chip 0.                    */

      /* Get full JEDEC id signature */
      vol.type = (FlashType) ((vendorId << 8) | flashPtr[inlv]);
      flashPtr[inlv] = resetCmd;
      break;
    }
    flashPtr[inlv] = resetCmd;
  }

  if (inlv & (inlv - 1))
    vol.type = NOT_FLASH;        /* not a power of 2, no way ! */
  else
#ifndef NT5PORT
    vol.interleaving = inlv;
#else
		vol.interleaving = (Sword)inlv;
#endif /*NT5PORT*/

}


/*----------------------------------------------------------------------*/
/*                      i n t e l S i z e                */
/*                                    */
/* Identify the card size for Intel-style Flash.            */
/* Sets the value of vol.noOfChips.                    */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*    amdCmdRoutine    : Routine to read-id AMD/Fujitsu style at    */
/*              a specific location. If null, Intel procedure    */
/*              is used.                                      */
/*      idOffset    : Chip offset to use for identification        */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 = OK, otherwise failed (invalid Flash array)*/
/*----------------------------------------------------------------------*/

FLStatus flIntelSize(FLFlash vol,
             void (*amdCmdRoutine)(FLFlash vol, CardAddress,
                       unsigned char, FlashPTR),
             CardAddress idOffset)
{
  unsigned char resetCmd = amdCmdRoutine ? AMD_READ_ARRAY : INTEL_READ_ARRAY;
  FlashPTR flashPtr = (FlashPTR) vol.map(&vol,idOffset,0);

  if (amdCmdRoutine)    /* AMD: use unlock sequence */
    amdCmdRoutine(&vol,0,READ_ID, flashPtr);
  else
    flashPtr[0] = READ_ID;
  /* We leave the first chip in Read ID mode, so that we can        */
  /* discover an address wraparound.                    */

  for (vol.noOfChips = 0;    /* Scan the chips */
       vol.noOfChips < 2000;  /* Big enough ? */
       vol.noOfChips += vol.interleaving) {
    int i;

    flashPtr = (FlashPTR) vol.map(&vol,vol.noOfChips * vol.chipSize + idOffset,0);

    /* Check for address wraparound to the first chip */
    if (vol.noOfChips > 0 &&
    (FlashType) ((flashPtr[0] << 8) | flashPtr[vol.interleaving]) == vol.type)
      goto noMoreChips;       /* wraparound */

    /* Check if chip displays the same JEDEC id and interleaving */
    for (i = (vol.noOfChips ? 0 : 1); i < vol.interleaving; i++) {
      if (amdCmdRoutine)    /* AMD: use unlock sequence */
    amdCmdRoutine(&vol,vol.noOfChips * vol.chipSize + idOffset + i,
              READ_ID, flashPtr);
      else
    flashPtr[i] = READ_ID;
      if ((FlashType) ((flashPtr[i] << 8) | flashPtr[i + vol.interleaving]) !=
      vol.type)
    goto noMoreChips;  /* This "chip" doesn't respond correctly, so we're done */

      flashPtr[i] = resetCmd;
    }
  }

noMoreChips:
  flashPtr = (FlashPTR) vol.map(&vol,idOffset,0);
  flashPtr[0] = resetCmd;        /* reset the original chip */

  return (vol.noOfChips == 0) ? flUnknownMedia : flOK;
}


/*----------------------------------------------------------------------*/
/*                           i s R A M                */
/*                                    */
/* Checks if the card memory behaves like RAM                */
/*                                    */
/* Parameters:                                                          */
/*    vol        : Pointer identifying drive            */
/*                                                                      */
/* Returns:                                                             */
/*    0 = not RAM-like, other = memory is apparently RAM        */
/*----------------------------------------------------------------------*/

static FLBoolean isRAM(FLFlash vol)
{
#ifndef NT5PORT
  FlashPTR flashPtr = (FlashPTR) flMap(vol.socket,0);
  unsigned char firstByte = flashPtr[0];
  char writeChar = (firstByte != 0) ? 0 : 0xff;
  volatile int zero=0;
#else
  FlashPTR flashPtr = (FlashPTR) flMap(vol.socket,0);
  unsigned char firstByte;
  char writeChar;
  volatile int zero=0;
  if(flashPtr == NULL){
	 DEBUG_PRINT(("Debug:isRAM(): NULL Pointer.\n"));
  }
  firstByte = flashPtr[0];
  writeChar = (firstByte != 0) ? 0 : 0xff;
#endif //NT5PORT
  flashPtr[zero] = writeChar;              /* Write something different */
  if (flashPtr[zero] == writeChar) {       /* Was it written ? */
    flashPtr[zero] = firstByte;            /* must be RAM, undo the damage */

    DEBUG_PRINT(("Debug: error, socket window looks like RAM.\r\n"));
    return TRUE;
  }
  return FALSE;
}


/*----------------------------------------------------------------------*/
/*                  f l I d e n t i f y F l a s h            */
/*                                    */
/* Identify the current Flash medium and select an MTD for it        */
/*                                    */
/* Parameters:                                                          */
/*    socket        : Socket of flash                */
/*    vol        : New volume pointer                */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 = Flash was identified            */
/*              other = identification failed                 */
/*----------------------------------------------------------------------*/

FLStatus flIdentifyFlash(FLSocket *socket, FLFlash vol)
{
  FLStatus status = flUnknownMedia;
  int iMTD;
  dword blockSize;

  vol.socket = socket;

#ifndef FIXED_MEDIA
  /* Check that we have a media */
  flResetCardChanged(vol.socket);        /* we're mounting anyway */
  checkStatus(flMediaCheck(vol.socket));
#endif

#ifdef ENVIRONMENT_VARS
   if(flUseisRAM==1)
   {
#endif
     if ( isRAM(&vol))
       return flUnknownMedia;    /* if it looks like RAM, leave immediately */
#ifdef ENVIRONMENT_VARS
   }
#endif

  /* Install default methods */
  vol.type                   = NOT_FLASH;
  vol.mediaType              = NOT_DOC_TYPE;
  vol.pageSize               = 0;
  vol.flags                  = 0;
  vol.map                    = flashMap;
  vol.read                   = flashRead;
  vol.setPowerOnCallback     = setNoCallback;
  vol.erase                  = flashNoErase;
  vol.write                  = flashNoWrite;
  vol.readBBT                = NULL;
  vol.writeIPL               = NULL;
  vol.readIPL                = NULL;
#ifdef HW_OTP
  vol.otpSize                = NULL;
  vol.readOTP                = NULL;
  vol.writeOTP               = NULL;
  vol.getUniqueId            = NULL;
#endif /* HW_OTP */
#ifdef  HW_PROTECTION
  vol.protectionBoundries    = NULL;
  vol.protectionKeyInsert    = NULL;
  vol.protectionKeyRemove    = NULL;
  vol.protectionType         = NULL;
  vol.protectionSet          = NULL;
#endif /* HW_PROTECTION */
  vol.download               = NULL;
  vol.enterDeepPowerDownMode = NULL;
#ifndef FL_NO_USE_FUNC
  if(flBusConfig[flSocketNoOf(socket)] != FL_ACCESS_USER_DEFINED);
  {
     vol.memRead                = NULL;
     vol.memWrite               = NULL;
     vol.memSet                 = NULL;
     vol.memRead8bit            = NULL;
     vol.memWrite8bit           = NULL;
     vol.memRead16bit           = NULL;
     vol.memWrite16bit          = NULL;
     vol.memWindowSize          = NULL;
  }
#endif /* FL_NO_USE_FUNC */
  /* Setup arbitrary parameters for read-only mount */
  vol.chipSize                 = 0x100000L;
  vol.erasableBlockSize        = 0x1000L;
  vol.noOfChips                = 1;
  vol.interleaving             = 1;
  vol.noOfFloors               = 1;
  vol.totalProtectedAreas      = 0;
  vol.changeableProtectedAreas = 0;
  vol.ppp                      = 5;
  vol.firstUsableBlock         = 0;
  vol.maxEraseCycles           = 100000L; /* Defaul for NOR */

#ifdef NT5PORT
  vol.readBufferSize = 0;
  vol.readBuffer = NULL;
#endif  /*NT5PORT*/


  /* Attempt all MTD's */
  for (iMTD = 0; (iMTD < noOfMTDs) && (status != flOK) &&
       (status != flBadDownload); iMTD++)
    status = mtdTable[iMTD](&vol);

  if (status == flBadDownload)
  {
    DEBUG_PRINT(("Debug: Flash media reported bad download error.\r\n"));
    return flBadDownload;
  }

  if (status != flOK) /* No MTD recognition */
  {
    DEBUG_PRINT(("Debug: did not identify flash media.\r\n"));
    return flUnknownMedia;
  }

  /* Calculate erasable Block Size Bits */
  for(blockSize = vol.erasableBlockSize>>1,vol.erasableBlockSizeBits = 0;
      blockSize>0; vol.erasableBlockSizeBits++,blockSize = blockSize >> 1);

  return flOK;


}


#ifdef NT5PORT
VOID * mapThroughBuffer(FLFlash vol, CardAddress address, LONG length)
{
  if ((ULONG) length > vol.readBufferSize) {
    vol.readBufferSize = 0;
    if (vol.readBuffer) {
	FREE(vol.readBuffer);
    }
    vol.readBuffer = MALLOC(length);
    if (vol.readBuffer == NULL) {
      return vol.readBuffer;
    }
    vol.readBufferSize = length;
  }
  vol.read(&vol,address,vol.readBuffer,length,0);
  return vol.readBuffer;
}
#endif /* NT5PORT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flioctl.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLIOCTL.H_V  $
 * 
 *    Rev 1.7   May 09 2001 00:45:48   oris
 * Changed protection ioctl interface to prevent the use of input buffer as an output buffer.
 * 
 *    Rev 1.6   Apr 16 2001 13:45:10   oris
 * Removed warrnings by changing some of the fields types to standart flite types.
 * 
 *    Rev 1.5   Apr 09 2001 15:02:22   oris
 * Added comment to ifdef statment.
 * End with an empty line.
 * 
 *    Rev 1.4   Apr 01 2001 15:16:38   oris
 * Updated inquire capability ioctl - diffrent input and output records.
 *
 *    Rev 1.3   Apr 01 2001 07:58:44   oris
 * Moved the following defines to blockdev.h:
 *   FL_PROTECT   0
 *   FL_UNPROTECT 1
 *   FL_UNLOCK    2
 *
 *    Rev 1.2   Feb 14 2001 02:16:16   oris
 * Updated inquire capabilities ioctl.
 *
 *    Rev 1.1   Feb 13 2001 01:49:06   oris
 * Added the following new IO Controls:
 *   FL_IOCTL_FORMAT_VOLUME2,
 *   FL_IOCTL_FORMAT_PARTITION,
 *   FL_IOCTL_BDTL_HW_PROTECTION,
 *   FL_IOCTL_BINARY_HW_PROTECTION,
 *   FL_IOCTL_OTP,
 *   FL_IOCTL_CUSTOMER_ID,
 *   FL_IOCTL_UNIQUE_ID,
 *   FL_IOCTL_NUMBER_OF_PARTITIONS,
 *   FL_IOCTL_SUPPORTED_FEATURES,
 *   FL_IOCTL_SET_ENVIRONMENT_VARIABLES,
 *   FL_IOCTL_PLACE_EXB_BY_BUFFER,
 *   FL_IOCTL_WRITE_IPL,
 *   FL_IOCTL_DEEP_POWER_DOWN_MODE,
 * and BDK_GET_INFO type in FL_IOCTL_BDK_OPERATION
 *
 *    Rev 1.0   Feb 04 2001 11:38:18   oris
 * Initial revision.
 *
 */
/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#include "flbase.h"
#include "dosformt.h"
#include "blockdev.h"
#ifdef BDK_ACCESS
#include "docbdk.h"
#endif

#ifndef FLIOCTL_H
#define FLIOCTL_H

#define NT5PORT
#ifdef IOCTL_INTERFACE

#ifdef NT5PORT
#ifdef  WRITE_EXB_IMAGE
#define EXB_BUFFER_SIZE		0x200
#endif /*WRITE_EXB_IMAGE*/
#endif  /*NT5PORT*/

/* In every call to flIOctl function, the irFlags field in the structure
   IOreq should hold one of the following: */
typedef enum{FL_IOCTL_GET_INFO = FL_IOCTL_START,
             FL_IOCTL_DEFRAGMENT,
             FL_IOCTL_WRITE_PROTECT,
             FL_IOCTL_MOUNT_VOLUME,
             FL_IOCTL_FORMAT_VOLUME,
             FL_IOCTL_BDK_OPERATION,
             FL_IOCTL_DELETE_SECTORS,
             FL_IOCTL_READ_SECTORS,
             FL_IOCTL_WRITE_SECTORS,
             FL_IOCTL_FORMAT_PHYSICAL_DRIVE,
             FL_IOCTL_FORMAT_LOGICAL_DRIVE,
             FL_IOCTL_BDTL_HW_PROTECTION,
             FL_IOCTL_BINARY_HW_PROTECTION,
             FL_IOCTL_OTP,
             FL_IOCTL_CUSTOMER_ID,
             FL_IOCTL_UNIQUE_ID,
             FL_IOCTL_NUMBER_OF_PARTITIONS,
             FL_IOCTL_INQUIRE_CAPABILITIES,
             FL_IOCTL_SET_ENVIRONMENT_VARIABLES,
             FL_IOCTL_PLACE_EXB_BY_BUFFER,
             FL_IOCTL_EXTENDED_WRITE_IPL,
						 FL_IOCTL_EXTENDED_ENVIRONMENT_VARIABLES,
						 FL_IOCTL_VERIFY_VOLUME,
             FL_IOCTL_DEEP_POWER_DOWN_MODE
} flIOctlFunctionNo;


FLStatus flIOctl(IOreq FAR2 *);


/* In every call to flIOctl function, the irData field in the structure
   IOreq should point to the structure defined below. The fields
   inputRecord and outputRecord should point to structures which are
   specific to each IOctl function as defined in this file. */
typedef struct {
  void FAR1 *inputRecord;
  void FAR1 *outputRecord;
} flIOctlRecord;


/* General output record that returns only status. */
typedef struct {
  FLStatus status;
} flOutputStatusRecord;



/* Input and output records for the different IOCTL functions: */
/* =========================================================== */

/* Get disk information (FL_IOCTL_GET_INFO) */
/* Input record: NULL */
/* Output record: */
typedef struct {
  VolumeInfoRecord info;  /* VolumeInfoRecord is defined in blockdev.h */
  FLStatus status;
} flDiskInfoOutput;
/* Output record: flOutputStatusRecord */

/******************************************************************************/
/* Check partition for power failures symptoms (FL_IOCTL_VERIFY_VOLUME) */
#ifdef VERIFY_VOLUME
/* Input record: NULL */
typedef struct {
  dword flags;   /* Must be set to 0 */    
} flVerifyVolumeInput;
/* Output record: */
typedef struct {
  void FAR1* callBack;   /* Must be set to null */  
  FLStatus status;
} flVerifyVolumeOutput;
#endif /* VERIFY_VOLUME */
/******************************************************************************/

/*************************************************************************/
#ifdef DEFRAGMENT_VOLUME
/* Defragment volume (FL_IOCTL_DEFRAGMENT) */
/* Input record: */
typedef struct {
  long requiredNoOfSectors;   /* Minimum number of sectors to make available.
                                  if -1 then a quick garbage collection operation
                                 is invoked. */
} flDefragInput;
/* Outout record: */
typedef struct {
  long actualNoOfSectors;     /* Actual number of sectors available */
  FLStatus status;
} flDefragOutput;
#endif
/*************************************************************************/
#ifdef WRITE_PROTECTION
/* Write protection (FL_IOCTL_WRITE_PROTECT) */

//type
//---------
#define FL_PROTECT   0
#define FL_UNPROTECT 1
#define FL_UNLOCK    2

/* Input record: */
typedef struct {
  byte type;        /*  type of operation: FL_PROTECT\FL_UNPROTECT */
  long password[2];          /*  password  */
} flWriteProtectInput;
/* Output record: flOutputStatusRecord */
#endif /* WRITE_PROTECTION */
/*************************************************************************/
/* Mount volume (FL_IOCTL_MOUNT_VOLUME) */
/* Input record: */
typedef struct {
  byte type;        /*  type of operation: FL_MOUNT\FL_DISMOUNT */
} flMountInput;
#define FL_MOUNT          0
#define FL_DISMOUNT        1
/* Output record: flOutputStatusRecord */
/*************************************************************************/

#ifdef FORMAT_VOLUME
/* Format volume (FL_IOCTL_FORMAT_VOLUME) */
/* Input record: */
typedef struct {
  byte formatType;   /* type of format as defined in blockdev.h */
  FormatParams fp;              /* Format parameters structure (defined in flformat.h) */
} flFormatInput;
/* Output record: flOutputStatusRecord */
/*************************************************************************/
/* Format volume (FL_IOCTL_FORMAT_LOGICAL_DRIVE) */
/* Input record: */
typedef struct {
  BDTLPartitionFormatParams fp;              /* Format parameters structure (defined in flformat.h) */
} flFormatLogicalInput;
/* Output record: flOutputStatusRecord */
/*************************************************************************/
#ifdef LOW_LEVEL
/* Format volume (FL_IOCTL_FORMAT_PHYSICAL_DRIVE) */
/* Input record: */
typedef struct {
  byte formatType;   /* type of format as defined in blockdev.h */
  FormatParams2 fp;              /* Format parameters structure (defined in flformat.h) */
} flFormatPhysicalInput;


#ifdef NT5PORT
typedef struct {

/*****************************/
/* Device formatting section */
/*****************************/

byte      percentUse;
     	/* BDTL performance depends on how full the flash media is,
		   becoming slower as the media becomes closer to 100% full.
		   It is possible to avoid the worst-case performance
		   (at 100% full) by formatting the media to less than 100%
		   capacity, thus guaranteeing free space at all times. This
		   of course sacrifices some capacity. The standard value
		   used is 98 */

byte             noOfBDTLPartitions;
		/* Indicates the number of BDTL partitions (1 to 4). 0 will
           cause a single STD_BDTL_PARAMS BDTL partition */

byte            noOfBinaryPartitions;
       /* Indicates the number of binary partitions (up to 3). 0 will
	      cause formatting with no binary partition. This value is ignored
	  unless the TL_BINARY_FORMAT flag is set in the irFlags f the ioreq */

BDTLPartitionFormatParams   BDTLPartitionInfo[4];
       /* BDTL partition information array  */

BinaryPartitionFormatParams binaryPartitionInfo[3];

       /* Binary partition information array*/

/***********************************/
/* Special format features section */
/***********************************/

#ifdef WRITE_EXB_IMAGE


byte            exbBuffer[EXB_BUFFER_SIZE];
	/* A buffer containing the EXB file. Optionaly this file can
	   contain only the first 512 bytes of the file while the rest
	   will be sent using consequitive calls to flPlaceExbByBuffer */

dword           exbBufferLen;     /* Size of the given EXB buffer */

dword           exbLen; /* The specific size to leave for the EXB */

word            exbWindow; /* Set explicit DiskOnChip window base */

byte            exbFlags; /* For the flags list see doc2exb.h */

#endif /* WRITE_EXB_IMAGE */

byte            cascadedDeviceNo;
	/* Reserved for individual cascaded device formatting 0..n. For
	   this value to have any affect the TL_SINGLE_CHIP_FORMATTING flag
	   should be set in the flags field.*/

byte            noOfCascadedDevices;
	/* This field must be supplied in order to perform a format of
	   a single chip that will be eventualy assembeled as a cascaded
	   device. The field should specify the number of DiskOnChips
	   that will be eventualy cascaded on the targe plaform */

FLStatus (*progressCallback)(int totalUnitsToFormat,
			     int totalUnitsFormattedSoFar);
	/* Progress callback routine, will be called if not NULL.
	   The callback routine is called after erasing each unit,
	   and its parameters are the total number of erase units
	   to format and the number erased so far.
	   The callback routine returns a Status value. A value of
	   OK (0) allows formatting to continue. Any other value
	   will abort the formatting with the returned status code. */

/* Note the following section is not used by for DiskOnChips */
/*************************************************************/

dword        	vmAddressingLimit;
	    /* A part of the FTL Virtual Map always resides in RAM. The
	       RAM part is the one that is used to address the part of
	       the media below the VM addressing limit. Reading and
		   writing to this part is usually faster to some degree.
		   The downside is that the bigger the limit, the more RAM
		   size is required.
		   To get the extra RAM requirement in bytes, divide the
		   limit by 128 or by 256, depending on whether you
		   specified in #2.9 more than 32 or not, respectively.
		   The minimum VM limit is 0.
		   The standard value to use is 0x10000 (first 64 KBytes) */

word	    embeddedCISlength;
		/* Length in bytes of CIS to embed after the unit header */

byte embeddedCIS[0x100];
		/* The unit header is structured as a beginning of a PCMCIA
		   'tuple' chain (a CIS). The unit header contains a
		   data-organization tuple, which points past the end of the
		   unit header to a location which usually just contains
		   hex FF's which mark an 'end-of-tuple-chain'. Optionally,
		   it is possible to embed an entire CIS chain at this
		   location. If so, 'embeddedCISlength' marks the length in
		   bytes */
} UserFormatParams2;


typedef struct {
  byte formatType;   /* type of format as defined in blockdev.h */
  UserFormatParams2 fp;              /* Format parameters structure (defined in flformat.h) */
} flUserFormatPhysicalInput;
#endif //NT5PORT

/* Output record: flOutputStatusRecord */
#endif /* LOW_LEVEL */
#endif /* FORMAT_VOLUME */
/*************************************************************************/
#ifdef BDK_ACCESS
/* BDK operations read\write\erase\create (FL_IOCTL_BDK_OPERATION) */
/* Input record: */
typedef struct {
  byte type;  /* type of operation: BDK_INIT_READ\BDK_READ\BDK_INIT_WRITE\ */
                       /* BDK_WRITE\BDK_ERASE\BDK_CREATE\BDK_GET_INFO               */
  BDKStruct bdkStruct; /* parameters for BDK operations (defined in docbdk.h)       */
} flBDKOperationInput;
#define BDK_INIT_READ   0
#define BDK_READ        1
#define BDK_INIT_WRITE  2
#define BDK_WRITE       3
#define BDK_ERASE       4
#define BDK_CREATE      5
#define BDK_GET_INFO    6

#ifdef NT5PORT
#define BDK_MAX_BUFFER									0x400
typedef struct {
byte oldSign[BDK_SIGNATURE_NAME];
byte newSign[BDK_SIGNATURE_NAME];
byte signOffset;
dword startingBlock;
dword length;
byte flags;
byte bdkBuffer[BDK_MAX_BUFFER];
} UserBDKStruct;

typedef struct {
  byte partitionNumber;
  byte type;  /* type of operation: BDK_INIT_READ\BDK_READ\BDK_INIT_WRITE\ */
                       /* BDK_WRITE\BDK_ERASE\BDK_CREATE\BDK_GET_INFO               */
  UserBDKStruct bdkStruct; /* parameters for BDK operations (defined in docbdk.h)       */
} flUserBDKOperationInput;

typedef struct {
  flOutputStatusRecord statusRec;					/* The status of the operation*/
  UserBDKStruct bdkStruct; /* parameters for BDK operations (defined in docbdk.h)       */
} flUserBDKOperationOutput;
#endif				/*NT5PORT*/

/* Output record: flOutputStatusRecord */
#endif                                  /* BDK_ACCESS  */
/*************************************************************************/
#ifdef HW_PROTECTION
/* BDK and BDTL protection operations: (FL_IOCTL_BINARY_HW_PROTECTION) */
/*                                     (FL_IOCTL_BDTL_HW_PROTECTION)   */
/*   insert key \ remove key \ identify \ change key \                 */
/*   change protection type \ change lock status                       */
/* Input record: */
typedef struct {
   byte protectionType;    /* see flflash.h for the protection attributes */
   byte key[8];            /* The new key to the change Key call          */
   byte type;              /* Operation type see list bellow              */
} flProtectionInput;

#ifdef	NT5PORT
typedef struct {
   byte partitionNumber;
   byte protectionType;    /* see flflash.h for the protection attributes */
   byte key[8];            /* The new key to the change Key call          */
   byte type;              /* Operation type see list bellow              */
} flBDKProtectionInput;
#endif				/*NT5PORT*/
/*Type*/
/*--------------*/
#define PROTECTION_INSERT_KEY   0
#define PROTECTION_REMOVE_KEY   1
#define PROTECTION_GET_TYPE     2
#define PROTECTION_DISABLE_LOCK 3
#define PROTECTION_ENABLE_LOCK  4
#define PROTECTION_CHANGE_KEY   5
#define PROTECTION_CHANGE_TYPE  6

#ifdef	NT5PORT
/*protectionType*/
/*--------------*/
#define PROTECTABLE           1  /* partition can recieve protection */
#define READ_PROTECTED        2  /* partition is read protected      */
#define WRITE_PROTECTED       4  /* partition is write protected     */
#define LOCK_ENABLED          8  /* HW lock signal is enabled        */
#define LOCK_ASSERTED         16 /* HW lock signal is asserted       */
#define KEY_INSERTED          32 /* key is inserted (not currently   */
#define CHANGEABLE_PROTECTION 64 /* changeable protection area type   */
#endif				/*NT5PORT*/


/* Output record: */
typedef struct {
   byte protectionType;    /* see flflash.h for the protection attributes */
   FLStatus status;
} flProtectionOutput;

#endif /* HW_PROTECTION */
/*************************************************************************/
#ifdef HW_OTP
/* One Time Programing operations: (FL_IOCTL_OTP */
/*   OTP size \ OTP read \ OTP write and lock    */
/* Input record: */
typedef struct {
dword       length;           /* Length to read\write\size                  */
dword       usedSize;         /* The written size of the area \ Area offset */
byte        lockedFlag;       /* The area condition LOCKED_OTP (flflash.h)  */
byte        FAR1* buffer;     /* pointer to user buffer                     */
word        type;             /* defined bellow                             */
} flOtpInput;
#define OTP_SIZE        1
#define OTP_READ        2
#define OTP_WRITE_LOCK  3

#ifdef NT5PORT
typedef struct {
unsigned long          length;                /* Length to read\write\size                                  */
unsigned long          usedSize;         /* The written size of the area \ Area offset */
byte lockedFlag;       /* The area condition LOCKED_OTP (flflash.h)  */
byte buffer[0x1800];                /* pointer to user buffer                                           */
word           type;                        /* defined bellow                             */
} UserOtpInput;

typedef struct {
long          length;                /* Length to read\write\size                                  */
long          usedSize;         /* The written size of the area \ Area offset */
byte					lockedFlag;       /* The area condition LOCKED_OTP (flflash.h)  */
byte					buffer[0x1800];                /* pointer to user buffer                                           */
flOutputStatusRecord      statusRec;                        /* defined bellow                             */
} UserOtpOutput;
#endif /*NT5PORT*/

/* Output record: flOutputStatusRecord */
/*************************************************************************/
/* Read customer ID (FL_IOCTL_CUSTOMER_ID) */
/* Input record: NULL */
/* Output record: */
typedef struct {
  byte id[4];
  FLStatus status;
} flCustomerIdOutput;
/*************************************************************************/
/* Read unique ID (FL_IOCTL_UNIQUE_ID) */
/* Input record: NULL */
/* Output record: */
typedef struct {
  byte id[16];
  FLStatus status;
} flUniqueIdOutput;
#endif /* HW_OTP */
/*************************************************************************/
/* Read unique ID (FL_IOCTL_NUMBER_OF_PARTITIONS) */
/* Input record: NULL */
/* Output record: */
typedef struct {
  byte noOfPartitions;
  FLStatus status;
} flCountPartitionsOutput;
/*************************************************************************/
/* Quary the device h/w and s/w capabilities (FL_IOCTL_INQUIRE_CAPABILITIES) */
#ifdef LOW_LEVEL
/* Input record:   */
typedef struct {
   FLCapability  capability;  /* defined in blockdev.h */
} flCapabilityInput;
/* Output record: */
typedef struct {
   FLCapability  capability;  /* defined in blockdev.h */
   FLStatus      status;
} flCapabilityOutput;
#endif /*LOW_LEVEL */


/******************************************************************************/
/* Set environment variables values (FL_IOCTL_EXTENDED_ENVIRONMENT_VARIABLES) */
#ifdef ENVIRONMENT_VARS
/* Input record:  */
typedef struct {
  FLEnvVars      varName;  /* Enum describing the variable */
  dword          varValue; /* New variable value           */
  dword          flags;    /* FL_APPLY_TO_ALL    - All socket and partitions */
                           /* FL_APPLY_TO_SOCKET - All socket and partitions */
                           /* FL_APPLY_TO_VOLUME - All socket and partitions */
} flExtendedEnvVarsInput;
#define FL_APPLY_TO_ALL    1
#define FL_APPLY_TO_SOCKET 2
#define FL_APPLY_TO_VOLUME 3
/* Output record: */
typedef struct {
  dword    prevValue;   /* The previous value of the variable */
  FLStatus status;
} flExtendedEnvVarsOutput;
#endif /* ENVIRONMENT_VARS */
/******************************************************************************/

/* Set environment variables values (FL_IOCTL_SET_ENVIRONMENT_VARIABLES) */
//#ifdef ENVIRONMENT_VARS
/* Input record:  */
//typedef struct {
//  FLEnvVars      varName;  /* Enum describing the variable */
//  int            varValue; /* New variable value           */
//} flEnvVarsInput;
/* Output record: */
//typedef struct {
//  int   prevValue;   /* The previous value of the variable */
//  FLStatus status;
//} flEnvVarsOutput;
//#endif /* ENVIRONMENT_VARS */


/*************************************************************************/
/* Place EXB file by buffers (FL_IOCTL_PLACE_EXB_BY_BUFFER) */
#ifdef LOW_LEVEL
#ifdef WRITE_EXB_IMAGE
/* Input record:  */
typedef struct {
  byte FAR1* buf;  /* buffer of EXB file */
  dword bufLen;     /* buffer length      */
  byte exbFlags;   /* a combination of EXB flags see flPlaceExbByBuffer routine  */
                            /* The list of flags is defined in doc2exb.h                  */
  word exbWindow; /* explicitly set device window. 0 will automatcly set window */
} flPlaceExbInput;

#ifdef NT5PORT
typedef struct {
  byte  buf[EXB_BUFFER_SIZE];  /* buffer of EXB file */
  dword bufLen;     /* buffer length      */
  byte exbFlags;   /* a combination of EXB flags see flPlaceExbByBuffer routine  */
                            /* The list of flags is defined in doc2exb.h                  */
  word exbWindow; /* explicitly set device window. 0 will automatcly set window */
} flUserPlaceExbInput;

#endif /* NT5PORT */

#endif /* WRITE_EXB_IMAGE */
/* Output record: flOutputStatusRecord */
/*************************************************************************/
/* Write IPL area for docPlus family (FL_IOCTL_WRITE_IPL) */
/* Input record:  */

#ifdef NT5PORT
#define IPL_MAX_SIZE			0x1000L
typedef struct {
	byte	buf[IPL_MAX_SIZE];  /* IPL data buffer        */
	word  flags;							/* IPL flags (see flflash.h) */
	word	bufLen;							/* IPL data buffer length */
} flUserIplInput;
#endif /*NT5PORT*/

typedef struct {
  byte FAR1* buf;      /* IPL data buffer           */
  word   flags;        /* IPL flags (see flflash.h) */
  word   bufLen;       /* IPL data buffer length    */
} flIplInput;
/* Output record: flOutputStatusRecord */
/*************************************************************************/
/* Place the device into and out of the power down mode (FL_IOCTL_DEEP_POWER_DOWN_MODE) */
typedef struct {
byte state; /* DEEP_POWER_DOWN - low power consumption      */
                     /* otherwise       - regular power consumption  */
} flPowerDownInput;
/* DEEP_POWER_DOWN is defined in flflash.h */
#endif /* LOW_LEVEL */
/* Output record: flOutputStatusRecord */
/*************************************************************************/
#ifdef ABS_READ_WRITE
/* Delete logical sectors (FL_IOCTL_DELETE_SECTORS) */
/* Input record: */
typedef struct {
  long firstSector;                /* First logical sector to delete */
  long numberOfSectors;                /* Number of sectors to delete */
} flDeleteSectorsInput;
/* Output record: flOutputStatusRecord */
/*************************************************************************/
/* read & write logical sectors (FL_IOCTL_READ_SECTORS & FL_IOCTL_WRITE_SECTORS) */
/* Input record: */
typedef struct {
  long firstSector;                  /* first logical sector */
  long numberOfSectors;         /* Number of sectors to read\write */
  byte FAR1 *buf;               /* Data to read\write */
} flReadWriteInput;
/* Output record: */
typedef struct {
  long numberOfSectors;         /* Actual Number of sectors read\written */
  FLStatus status;
} flReadWriteOutput;
#endif /* ABS_READ_WRITE */
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flreq.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLREQ.H_V  $
 * 
 *    Rev 1.3   Jan 29 2002 20:09:12   oris
 * Changed LOW_LEVEL compilation flag with FL_LOW_LEVEL to prevent definition clashes.
 * 
 *    Rev 1.2   Apr 01 2001 07:46:16   oris
 * Updated copywrite notice
 * 
 *    Rev 1.1   Feb 18 2001 12:07:24   oris
 * Added VOLUME_ACCUPIED volume flag.
 *
 *    Rev 1.0   Feb 04 2001 11:42:12   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef FLREQ_H
#define FLREQ_H

#include "flbase.h"

#define VOLUME_LOW_LVL_MOUNTED 1  /* Volume is mounted for low level operations */
#define	VOLUME_MOUNTED	       2  /* Volume is mounted */
#define VOLUME_12BIT_FAT       4  /* Volume uses 12-bit FAT */
#define	VOLUME_ABS_MOUNTED     8  /* Volume is mounted for abs calls */
#define VOLUME_WRITE_PROTECTED 16 /* Volume is write protected */
#define VOLUME_ACCUPIED        32 /* Volume record bellongs to a volume */

typedef unsigned FLHandle;	/* Handle of an open file or drive.	*/
				/* Actually an index to file table or	*/
				/* drive table.				*/

/*----------------------------------------------------------------------*/
/*			P a t h - N a m e s				                                      */
/*									                                                    */
/* A path-name is represented as an array of SimplePath records.	      */
/* Each SimplePath record holds a directory or file name segment, with  */
/* the full 8.3 (spaces not compressed) name.				                    */
/*									                                                    */
/* Path-names always start at the root directory. There is no current   */
/* directory. The directories pointers '.' and '..' can be specified	  */
/* as the 'name' part of the path-segment, except at the root-directory.*/
/*									                                                    */
/* Lower-case letters are different from upper-case. To be compatible   */
/* with DOS, file-names should be upper-case. File names may contain    */
/* any character, but files starting with hex E5 are considered deleted */
/* according to DOS convention.						                              */
/*									                                                    */
/* A null (hex 0) in the first byte of the name field denotes that the  */
/* path ends here.							                                        */
/*                                                                      */
/* Note that paths can be specified as strings: For example:     	      */
/*									                                                    */
/* "UTIL       FATLITE H  "    ===> "\UTIL\FATLITE.H".			            */
/* ""				 ===> "\" (root directory)		                              */
/* "AUTOEXECBAT"                ===> "\AUTOEXEC.BAT"			              */
/* "UTIL       ..         "	 ===> "\UTIL\.." (root directory)	          */
/*									                                                    */
/* The optional service flParsePath may be used to convert regular	    */
/* string paths to this format.						                              */
/*----------------------------------------------------------------------*/

typedef struct {
  char	name[8];	/* name part of path segment */
  /* A hex 0 in 1st character indicates end of path */
  char	ext[3];		/* extension part of path segment */
} FLSimplePath;

/*----------------------------------------------------------------------*/
/*			  I O r e q					                                            */
/*									                                                    */
/* IOreq is a common structure passed to all file-system functions.	    */
/* Refer to the description of individual functions for specific usage  */
/* of fields. Some fields have different names when used by different   */
/* functions, hence the use of unions.					                        */
/*									                                                    */
/*----------------------------------------------------------------------*/

typedef struct {
  FLHandle	irHandle;	/* Handle of file or drive for operation*/
  unsigned	irFlags;	/* function-specific flags 		*/
  FLSimplePath FAR1 * irPath;	/* path of file for operation 		*/
  void FAR1 *	irData;		/* Pointer to user-buffer for operation */
  long		irLength;	/* No. of bytes, size or position for   */
				/* operation			 	*/
#if defined(ABS_READ_WRITE) || defined(FL_LOW_LEVEL)
  long		irCount;	/* Count or offset for operaion		*/
#endif
} IOreq;

/* definiftions for absolute read & write */
#define irSectorCount	irCount
#define	irSectorNo	    irLength

/* definitions for physical read & write */
#define irByteCount	    irCount
#define irAddress       irLength

/* definitions for physical erase */
#define irUnitCount     irCount
#define irUnitNo	    irLength

/* definitions for writing exb file */
#define irWindowBase    irCount

/*----------------------------------------------------------------------*/
/*		            f l I n i t					                                  */
/*									                                                    */
/* Initializes the FLite system.                                        */
/*									                                                    */
/* Calling this function is optional. If it is not called,		          */
/* initialization will be done automatically on the first FLite call.	  */
/* This function is provided for those applications who want to		      */
/* explicitly initialize the system and get an initialization status.	  */
/*									                                                    */
/* Calling flInit after initialization was done has no effect.		      */
/*									                                                    */
/* Parameters:                                                          */
/*	None								                                                */
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                          */
/*----------------------------------------------------------------------*/

extern FLStatus flInit(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flparse.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLPARSE.C_V  $
 * 
 *    Rev 1.2   Jan 29 2002 20:09:04   oris
 * Added NAMING_CONVENTION prefix to flParsePath public routines.
 * 
 *    Rev 1.1   Apr 01 2001 07:59:42   oris
 * copywrite notice.
 * 
 *    Rev 1.0   Feb 04 2001 11:40:12   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#include "fatlite.h"

#ifdef PARSE_PATH


/*----------------------------------------------------------------------*/
/*		         f l P a r s e P a t h				*/
/*									*/
/* Converts a DOS-like path string to a simple-path array.		*/
/*                                                                      */
/* Note: Array length received in irPath must be greater than the 	*/
/* number of path components in the path to convert.			*/
/*									*/
/* Parameters:                                                          */
/*	ioreq->irData	: address of path string to convert		*/
/*	ioreq->irPath	: address of array to receive parsed-path	*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

FLStatus NAMING_CONVENTION flParsePath(IOreq FAR2 *ioreq)
{
  char FAR1 *dosPath;

  FLSimplePath FAR1 *sPath = ioreq->irPath;

  unsigned offset = 0, dots = 0, chars = 0;
  FLBoolean isExt = FALSE;
  for (dosPath = (char FAR1 *) ioreq->irData; ; dosPath++) {
    if (*dosPath == '\\' || *dosPath == 0) {
      if (offset != 0) {
	while (offset < sizeof(FLSimplePath))
	  sPath->name[offset++] = ' ';
	if (chars == 0) {
	  if (dots == 2)
	    sPath--;
	}
	else
	  sPath++;
	offset = dots = chars = 0;
	isExt = FALSE;
      }
      sPath->name[offset] = 0;
      if (*dosPath == 0)
	break;
    }
    else if (*dosPath == '.') {
      dots++;
      while (offset < sizeof sPath->name)
	sPath->name[offset++] = ' ';
      isExt = TRUE;
    }
    else if (offset < sizeof(FLSimplePath) &&
	     (isExt || offset < sizeof sPath->name)) {
      chars++;
      if (*dosPath == '*') {
	while (offset < (isExt ? sizeof(FLSimplePath) : sizeof sPath->name))
	  sPath->name[offset++] = '?';
      }
      else if (*dosPath >= 'a' && *dosPath <= 'z')
	sPath->name[offset++] = *dosPath - ('a' - 'A');
      else
	sPath->name[offset++] = *dosPath;
    }
  }

  return flOK;
}

#endif /* PARSE_PATH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flsocket.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLSOCKET.H_V  $
 * 
 *    Rev 1.5   Apr 15 2002 07:37:06   oris
 * Added support for VERIFY_ERASED_SECTOR compilation flag.
 * 
 *    Rev 1.4   Feb 19 2002 20:59:58   oris
 * Removed include directive to flbase.h
 * 
 *    Rev 1.3   Jan 17 2002 23:02:22   oris
 * Added flReadBackBufferOf  prototype
 * Added curPartition and verifyWrite variables in the socket record.
 * 
 *    Rev 1.2   Jul 13 2001 01:05:44   oris
 * Add forward definition for get read back buffer pointer.
 * 
 *    Rev 1.1   Apr 01 2001 07:46:04   oris
 * Updated copywrite notice
 * 
 *    Rev 1.0   Feb 04 2001 11:53:24   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#ifndef FLSOCKET_H
#define FLSOCKET_H

#include "flbuffer.h"

#define ATTRIBUTE_SPACE_MAPPED      0x8000

typedef enum {PowerOff, PowerGoingOff, PowerOn} PowerState;


/* Socket state variables */
typedef struct tSocket FLSocket;      /* Forward definition */

struct tSocket {
  unsigned        volNo;         /* Volume no. of socket */
  unsigned        serialNo;      /* Serial no. of socket on controller */

  FLBoolean       cardChanged;   /* need media change notification */

  int             VccUsers;      /* No. of current VCC users */
  int             VppUsers;      /* No. of current VPP users */

  PowerState      VccState;      /* Actual VCC state */
  PowerState      VppState;      /* Actual VPP state */
  byte            curPartition;  /* Current partition to use the socket (set busy) */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  byte            verifyWrite;   /* VerifyWrite mode                               */
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
  FLBoolean       remapped;      /* set to TRUE whenever the socket window is moved */

  void            (*powerOnCallback)(void *flash); /* Notification routine for Vcc on */
  void *          flash;         /* Flash object for callback */

  struct {                       /* Window state                     */
    unsigned int  baseAddress;   /* Physical base as a 4K page       */
    unsigned int  currentPage;   /* Our current window page mapping  */
    void FAR0 *   base;          /* Pointer to window base           */
    long int      size;          /* Window size (must by power of 2) */
    unsigned      speed;         /* in nsec.                         */
    unsigned      busWidth;      /* 8 or 16 bits                     */
  } window;

/*----------------------------------------------------------------------*/
/*                      c a r d D e t e c t e d                         */
/*                                                                      */
/* Detect if a card is present (inserted)                               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/* Returns:                                                             */
/*      0 = card not present, other = card present                      */
/*----------------------------------------------------------------------*/
  FLBoolean (*cardDetected)(FLSocket vol);

/*----------------------------------------------------------------------*/
/*                           V c c O n                                        */
/*                                                                      */
/* Turns on Vcc (3.3/5 Volts). Vcc must be known to be good on exit.      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                                  */
/*                                                                      */
/*----------------------------------------------------------------------*/
  void (*VccOn)(FLSocket vol);

/*----------------------------------------------------------------------*/
/*                         V c c O f f                                        */
/*                                                                      */
/* Turns off Vcc.                                                          */
/*                                                                          */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
  void (*VccOff)(FLSocket vol);

#ifdef SOCKET_12_VOLTS

/*----------------------------------------------------------------------*/
/*                           V p p O n                                        */
/*                                                                      */
/* Turns on Vpp (12 Volts. Vpp must be known to be good on exit.      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                                  */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus      : 0 on success, failed otherwise                            */
/*----------------------------------------------------------------------*/
  FLStatus (*VppOn)(FLSocket vol);


/*----------------------------------------------------------------------*/
/*                         V p p O f f                                  */
/*                                                                      */
/* Turns off Vpp.                                                       */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
  void (*VppOff)(FLSocket vol);

#endif      /* SOCKET_12_VOLTS */

/*----------------------------------------------------------------------*/
/*                      i n i t S o c k e t                             */
/*                                                                      */
/* Perform all necessary initializations of the socket or controller    */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus      : 0 on success, failed otherwise                  */
/*----------------------------------------------------------------------*/
  FLStatus (*initSocket)(FLSocket vol);

/*----------------------------------------------------------------------*/
/*                        s e t W i n d o w                             */
/*                                                                      */
/* Sets in hardware all current window parameters: Base address, size,  */
/* speed and bus width.                                                 */
/* The requested settings are given in the 'vol.window' structure.      */
/*                                                                      */
/* If it is not possible to set the window size requested in            */
/* 'vol.window.size', the window size should be set to a larger value,  */
/* if possible. In any case, 'vol.window.size' should contain the       */
/* actual window size (in 4 KB units) on exit.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
  void (*setWindow)(FLSocket vol);


/*----------------------------------------------------------------------*/
/*               s e t M a p p i n g C o n t e x t                      */
/*                                                                      */
/* Sets the window mapping register to a card address.                  */
/*                                                                      */
/* The window should be set to the value of 'vol.window.currentPage',   */
/* which is the card address divided by 4 KB. An address over 128KB,    */
/* (page over 32K) specifies an attribute-space address.                */
/*                                                                      */
/* The page to map is guaranteed to be on a full window-size boundary.  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
  void (*setMappingContext)(FLSocket vol, unsigned page);

/*----------------------------------------------------------------------*/
/*       g e t A n d C l e a r C a r d C h a n g e I n d i c a t o r    */
/*                                                                      */
/* Returns the hardware card-change indicator and clears it if set.     */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/* Returns:                                                             */
/*      0 = Card not changed, other = card changed                      */
/*----------------------------------------------------------------------*/
  FLBoolean (*getAndClearCardChangeIndicator)(FLSocket vol);

/*----------------------------------------------------------------------*/
/*                      w r i t e P r o t e c t e d                     */
/*                                                                      */
/* Returns the write-protect state of the media                         */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/* Returns:                                                             */
/*      0 = not write-protected, other = write-protected                */
/*----------------------------------------------------------------------*/
  FLBoolean (*writeProtected)(FLSocket vol);

/*----------------------------------------------------------------------*/
/*            u p d a t e S o c k e t P a r a m s                       */
/*                                                                      */
/* Pass socket parameters to the socket interface layer.                */
/* The structure passed in irData is specific for each socket interface.*/
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : pointer identifying drive                      */
/*      params             : pointer to structure that holds socket     */
/*                    parameters.                                       */
/*                                                                      */
/*----------------------------------------------------------------------*/
  void (*updateSocketParams)(FLSocket vol, void FAR1 *params);


/*----------------------------------------------------------------------*/
/*                      f r e e S o c k e t                             */
/*                                                                      */
/* Free resources that were allocated for this socket.                  */
/* This function is called when FLite exits.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*                                                                      */
/*----------------------------------------------------------------------*/
#ifdef EXIT
  void (*freeSocket)(FLSocket vol);
#endif
};


#define      UNDEFINED_MAPPING      0x7fff

typedef unsigned long CardAddress;      /* Physical offset on card */

/* See interface documentation of functions in socket.c */

extern FLStatus updateSocketParameters(FLSocket *, void FAR1 *);

extern FLStatus      flInitSockets(void);

#ifdef EXIT
extern void      flExitSocket(FLSocket *);
#endif

extern unsigned  flSocketNoOf(const FLSocket *);
extern FLSocket* flSocketOf(unsigned volNo);
extern FLBuffer* flBufferOf(unsigned volNo);
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
extern byte    * flReadBackBufferOf(unsigned volNo);
#endif /* VERIFY_WRITE || VERIFY_ERASE || MTD_RECONSTRUCT_BBT || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
extern void      flNeedVcc(FLSocket *);
extern void      flDontNeedVcc(FLSocket *);
#ifdef SOCKET_12_VOLTS
extern FLStatus  flNeedVpp(FLSocket *);
extern void      flDontNeedVpp(FLSocket *);
#endif
extern void      flSocketSetBusy(FLSocket *, FLBoolean);      /* entry/exit operations */
extern FLBoolean flWriteProtected(FLSocket *); /* write-protection status */
#ifndef FIXED_MEDIA
extern FLStatus  flMediaCheck(FLSocket *);      /* check for media status change */
extern void      flResetCardChanged(FLSocket *);
#endif
extern unsigned  flGetMappingContext(FLSocket *);  /* Currently mapped 4KB page */
extern void FAR0*flMap(FLSocket *, CardAddress);      /* map and point at card address */
extern void      flSetWindowBusWidth(FLSocket *, unsigned); /* set window data-path */
extern void      flSetWindowSpeed(FLSocket *, unsigned);      /* set window speed (nsec.) */
extern void      flSetWindowSize(FLSocket *, unsigned);      /* in 4KB units */

extern void      flSetPowerOnCallback(FLSocket *, void (*)(void *), void *);
                  /* Set MTD notification for socket power on */
extern void      flIntervalRoutine(FLSocket *);      /* socket interval routine */


extern byte noOfSockets;    /* No. of drives actually registered */

/* The milliseconds counter is active when socket polling is enabled. When
   the socket interval routine is called, the counter is incremented by
   the interval in milliseconds.
   The counter can be used to avoid getting in a loop that is not guaranteed
   to terminate (such as waiting for a flash status register). Save the counter
   at entry to the loop, and check in the loop the amount of time that
   was spent in the loop. */

extern dword flMsecCounter;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flstatus.h ===
/*
 * $Header:   V:/Flite/archives/TrueFFS5/Src/FLSTATUS.H_V   1.7   Feb 19 2002 21:00:06   oris  $
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLSTATUS.H_V  $
 * 
 *    Rev 1.7   Feb 19 2002 21:00:06   oris
 * Renamed flTimeOut status with flLeftForCompetability status.
 * 
 *    Rev 1.6   Jan 29 2002 20:06:34   oris
 * Changed spelling mistake - flMultiDocContrediction to flMultiDocContradiction.
 * 
 *    Rev 1.5   Jan 17 2002 23:02:32   oris
 * Added new states : flCanNotFold / flBadIPLBlock / flIOCommandBlocked.
 * 
 *    Rev 1.4   Sep 15 2001 23:46:32   oris
 * Added flCanNotFold status
 * 
 *    Rev 1.3   May 16 2001 21:19:34   oris
 * Added flMultiDocContrediction status code.
 * 
 *    Rev 1.2   May 02 2001 06:40:18   oris
 * flInterleaveError was misspelled.
 * 
 *    Rev 1.1   Apr 01 2001 07:58:04   oris
 * copywrite notice.
 * Added new status codes:
 *          flBadDownload             = 111,
 *          flBadBBT                  = 112,
 *          flInterlreavError         = 113,
 *          flWrongKey                = 114,
 *          flHWProtection            = 115,
 *          flTimeOut                 = 116
 * Changed flUnchangableProection to flUnchangeableProtection  = 110,
 * 
 *    Rev 1.0   Feb 04 2001 11:56:04   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef FLSTATUS_H
#define FLSTATUS_H

#ifndef IFLITE_ERROR_CODES
typedef enum {                          /* Status code for operation.
                       A zero value indicates success,
                       other codes are the extended
                       DOS codes. */
         flOK                      = 0,
         flBadFunction             = 1,
         flFileNotFound            = 2,
         flPathNotFound            = 3,
         flTooManyOpenFiles        = 4,
         flNoWriteAccess           = 5,
         flBadFileHandle           = 6,
         flDriveNotAvailable       = 9,
         flNonFATformat            = 10,
         flFormatNotSupported      = 11,
         flNoMoreFiles             = 18,
         flWriteProtect            = 19,
         flBadDriveHandle          = 20,
         flDriveNotReady           = 21,
         flUnknownCmd              = 22,
         flBadFormat               = 23,
         flBadLength               = 24,
         flDataError               = 25,
         flUnknownMedia            = 26,
         flSectorNotFound          = 27,
         flOutOfPaper              = 28,
         flWriteFault              = 29,
         flReadFault               = 30,
         flGeneralFailure          = 31,
         flDiskChange              = 34,
         flVppFailure              = 50,
         flBadParameter            = 51,
         flNoSpaceInVolume         = 52,
         flInvalidFATchain         = 53,
         flRootDirectoryFull       = 54,
         flNotMounted              = 55,
         flPathIsRootDirectory     = 56,
         flNotADirectory           = 57,
         flDirectoryNotEmpty       = 58,
         flFileIsADirectory        = 59,
         flAdapterNotFound         = 60,
         flFormattingError         = 62,
         flNotEnoughMemory         = 63,
         flVolumeTooSmall          = 64,
         flBufferingError          = 65,
         flFileAlreadyExists       = 80,
         flIncomplete              = 100,
         flTimedOut                = 101,
         flTooManyComponents       = 102,
         flTooManyDrives           = 103,
         flTooManyBinaryPartitions = 104,
         flPartitionNotFound       = 105,
         flFeatureNotSupported     = 106,
         flWrongVersion            = 107,
         flTooManyBadBlocks        = 108,
         flNotProtected            = 109,
         flUnchangeableProtection  = 110,
         flBadDownload             = 111,
         flBadBBT                  = 112,
         flInterleaveError         = 113,
         flWrongKey                = 114,
         flHWProtection            = 115,
         flLeftForCompetability    = 116,
         flMultiDocContradiction   = 117,
         flCanNotFold              = 118,
         flBadIPLBlock             = 119,
         flIOCommandBlocked        = 120
#else

#include "type.h"

typedef enum {                          /* Status code for operation.
                       A zero value indicates success,
                       other codes are the extended
                       DOS codes. */
             flOK                  = ERR_NONE,
             flBadFunction         = ERR_SW_HW,
             flFileNotFound        = ERR_NOTEXISTS,
             flPathNotFound        = ERR_NOTEXISTS,
             flTooManyOpenFiles    = ERR_MAX_FILES,
             flNoWriteAccess       = ERR_WRITE,
             flBadFileHandle       = ERR_NOTOPEN,
             flDriveNotAvailable   = ERR_SW_HW,
             flNonFATformat        = ERR_PARTITION,
             flFormatNotSupported  = ERR_PARTITION,
             flNoMoreFiles         = ERR_NOTEXISTS,
             flWriteProtect        = ERR_WRITE,
             flBadDriveHandle      = ERR_SW_HW,
             flDriveNotReady       = ERR_PARTITION,
             flUnknownCmd          = ERR_PARAM,
             flBadFormat           = ERR_PARTITION,
             flBadLength           = ERR_SW_HW,
             flDataError           = ERR_READ,
             flUnknownMedia        = ERR_PARTITION,
             flSectorNotFound      = ERR_READ,
             flOutOfPaper          = ERR_SW_HW,
             flWriteFault          = ERR_WRITE,
             flReadFault           = ERR_READ,
             flGeneralFailure      = ERR_SW_HW,
             flDiskChange          = ERR_PARTITION,
             flVppFailure          = ERR_WRITE,
             flBadParameter        = ERR_PARAM,
             flNoSpaceInVolume     = ERR_SPACE,
             flInvalidFATchain     = ERR_PARTITION,
             flRootDirectoryFull   = ERR_DIRECTORY,
             flNotMounted          = ERR_PARTITION,
             flPathIsRootDirectory = ERR_DIRECTORY,
             flNotADirectory       = ERR_DIRECTORY,
             flDirectoryNotEmpty   = ERR_NOT_EMPTY,
             flFileIsADirectory    = ERR_DIRECTORY,
             flAdapterNotFound     = ERR_DETECT,
             flFormattingError     = ERR_FORMAT,
             flNotEnoughMemory     = ERR_SW_HW,
             flVolumeTooSmall      = ERR_FORMAT,
             flBufferingError      = ERR_SW_HW,
             flFileAlreadyExists   = ERR_EXISTS,
             flIncomplete          = ERR_DETECT,
             flTimedOut            = ERR_SW_HW,
             flTooManyComponents   = ERR_PARAM
#endif
         } FLStatus;

#endif /* FLSTATUS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flsysfun.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLSYSFUN.H_V  $
 * 
 *    Rev 1.2   Jul 13 2001 01:06:40   oris
 * Changed copywrite date.
 * 
 *    Rev 1.1   Apr 18 2001 09:31:14   oris
 * added new line at the end of the file.
 * 
 *    Rev 1.0   Feb 04 2001 11:59:26   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#ifndef FLSYSFUN_H
#define FLSYSFUN_H

/*#include "flbase.h" */

/*----------------------------------------------------------------------*/
/*      	         f l S y s f u n I n i t			*/
/*									*/
/* Do any necessary initialization for routines in this module.		*/
/*									*/
/* Called from fatlite.c (flInit)					*/
/*									*/
/* Parameters:                                                          */
/*      None								*/
/*                                                                      */
/*----------------------------------------------------------------------*/

extern void flSysfunInit(void);


/*----------------------------------------------------------------------*/
/*      	           f l R a n d B y t e				*/
/*									*/
/* Returns a random number between 0 and 255				*/
/*									*/
/* Called from FTLLITE.C						*/
/*									*/
/* Parameters:                                                          */
/*      None								*/
/*                                                                      */
/* Returns:                                                             */
/*	A random number between 0 and 255				*/
/*----------------------------------------------------------------------*/

extern unsigned flRandByte(void);


/*----------------------------------------------------------------------*/
/*      	          f l D e l a y M s e c s			*/
/*									*/
/* Delays execution for a number of milliseconds.			*/
/* If there is no msec-accuracy to the clock, this routine should wait	*/
/* at least the time specified.						*/
/*									*/
/* This routine may be called from the socket interface or MTD's, and	*/
/* is not necessary for all implementations.				*/
/*									*/
/* Parameters:                                                          */
/*      milliseconds	: Milliseconds to wait				*/
/*                                                                      */
/*----------------------------------------------------------------------*/

extern void flDelayMsecs(unsigned milliseconds);

/*----------------------------------------------------------------------*/
/* 		          f l s l e e p	                                */
/*									*/
/* wait number of milliseconds with yield CPU.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      msec            : minimum number of milliseconds to wait        */
/*                                                                      */
/*----------------------------------------------------------------------*/

extern void flsleep(unsigned long msec);

/*----------------------------------------------------------------------*/
/*      	        f l I n s t a l l T i m e r			*/
/*									*/
/* Installs an interval timer.						*/
/* The implementation of this routine usually means hooking a clock	*/
/* interrupt. The polling interval is specified as a parameter. If the  */
/* clock frequency is faster, the interval timer should count several	*/
/* clock ticks before calling the interval routine.			*/
/*									*/
/* This routine is necessary if POLLING_INTERVAL (custom.h) is greater	*/
/* than 0. In this case this routine will be called from socket.c 	*/
/* (init). It will be called to install 'socketIntervalRoutine' with a	*/
/* period specified by POLLING_INTERVAL.				*/
/*									*/
/* Parameters:                                                          */
/*      routine		: Routine to call at each interval		*/
/*	interval	: Milliseconds per polling interval		*/
/*									*/
/* Returns:								*/
/* 	FLStatus	: 0 on success, otherwise failure		*/
/*----------------------------------------------------------------------*/

extern FLStatus flInstallTimer(void (*routine)(void), unsigned interval);


#ifdef EXIT

/*----------------------------------------------------------------------*/
/*      	        f l R e m o v e T i m e r 			*/
/*									*/
/* Removes the active interval timer.					*/
/* This routine removes the active interval timer set by 'removeTimer'. */
/*									*/
/* Parameters:                                                          */
/*      None								*/
/*                                                                      */
/*----------------------------------------------------------------------*/

extern void flRemoveTimer(void);

#endif


/*----------------------------------------------------------------------*/
/*      	         f l C u r r e n t D a t e			*/
/*									*/
/* Returns the current DOS-format date					*/
/*									*/
/* The DOS date format is documented in dosformt.h.			*/
/*                                                                      */
/* If a TOD clock is not available, return the value of 1/1/80.		*/
/*									*/
/* Parameters:                                                          */
/*      None								*/
/*                                                                      */
/* Returns:                                                             */
/*	Current date							*/
/*----------------------------------------------------------------------*/

extern unsigned flCurrentDate(void);


/*----------------------------------------------------------------------*/
/*      	        f l C u r r e n t T i m e			*/
/*									*/
/* Returns the current DOS-format time					*/
/*									*/
/* The DOS time format is documented in dosformt.h.			*/
/*                                                                      */
/* If a TOD clock is not available, return the value of 0:00 AM.	*/
/*									*/
/* Parameters:                                                          */
/*      None								*/
/*                                                                      */
/* Returns:                                                             */
/*	Current time							*/
/*----------------------------------------------------------------------*/

extern unsigned flCurrentTime(void);


/*----------------------------------------------------------------------*/
/*      	        f l C r e a t e M u t e x			*/
/*									*/
/* Creates and initializes a mutex object				*/
/*									*/
/* The mutex is initializes as not owned by anyone.			*/
/*									*/
/* Parameters:                                                          */
/*      mutex		: Pointer to mutex object			*/
/*                                                                      */
/* Returns:                                                             */
/* 	FLStatus	: 0 on success, otherwise failure		*/
/*----------------------------------------------------------------------*/

extern FLStatus flCreateMutex(FLMutex *mutex);


/*----------------------------------------------------------------------*/
/*      	        f l D e l e t e M u t e x			*/
/*									*/
/* Destroys a mutex object						*/
/*									*/
/* This function frees any resources taken by flCreateMutex.		*/
/*									*/
/* Parameters:                                                          */
/*      mutex		: Pointer to mutex object			*/
/*                                                                      */
/* Returns:                                                             */
/* 	None								*/
/*----------------------------------------------------------------------*/

extern void flDeleteMutex(FLMutex *mutex);


/*----------------------------------------------------------------------*/
/*      	          f l T a k e M u t e x				*/
/*									*/
/* Attempts to take ownership of a mutex. If the mutex is currently not */
/* owned, TRUE is returned and the mutex becomes owned. If the mutex is */
/* currently owned, FALSE is returned and ownership is not taken.	*/
/*									*/
/* Parameters:                                                          */
/*      mutex		: Pointer to mutex object			*/
/*                                                                      */
/* Returns:                                                             */
/* 	FLBoolean	: TRUE if ownership taken, FALSE otherwise	*/
/*----------------------------------------------------------------------*/

extern FLBoolean flTakeMutex(FLMutex *mutex);


/*----------------------------------------------------------------------*/
/*      	          f l F r e e M u t e x				*/
/*									*/
/* Frees ownership of a mutex						*/
/*									*/
/* Parameters:                                                          */
/*      mutex		: Pointer to mutex object			*/
/*                                                                      */
/* Returns:                                                             */
/* 	None								*/
/*----------------------------------------------------------------------*/

extern void flFreeMutex(FLMutex *mutex);


/*----------------------------------------------------------------------*/
/*      	          f l I n p o r t b				*/
/*									*/
/* Reads a byte from an I/O port.					*/
/*									*/
/* Parameters:                                                          */
/*      portId		: Id or address of port				*/
/*                                                                      */
/* Returns:                                                             */
/* 	unsigned char	: Value of I/O port								*/
/*----------------------------------------------------------------------*/

extern unsigned char flInportb(unsigned portId);


/*----------------------------------------------------------------------*/
/*      	          f l O u t p o r t b				*/
/*									*/
/* Writes a byte to an I/O port.					*/
/*									*/
/* Parameters:                                                          */
/*      portId		: Id or address of port				*/
/*      value		: Value to write				*/
/*                                                                      */
/* Returns:                                                             */
/* 	None								*/
/*----------------------------------------------------------------------*/

extern void flOutportb(unsigned portId, unsigned char value);


/*----------------------------------------------------------------------*/
/*      	          f l S w a p B y t e s				*/
/*									*/
/* Swap bytes in a given buffer.					*/
/*									*/
/* Parameters:                                                          */
/*      buf		: buffer that holds bytes to swap		*/
/*      len		: number of bytes to swap			*/
/*                                                                      */
/* Returns:                                                             */
/* 	None								*/
/*----------------------------------------------------------------------*/

extern void flSwapBytes(char FAR1 *buf, int len);


/*----------------------------------------------------------------------*/
/*                 f l A d d L o n g T o F a r P o i n t e r            */
/*									*/
/* Add unsigned long offset to the far pointer                          */
/*									*/
/* Parameters:                                                          */
/*      ptr             : far pointer                                   */
/*      offset          : offset in bytes                               */
/*                                                                      */
/*----------------------------------------------------------------------*/

extern void FAR0* flAddLongToFarPointer(void FAR0 *ptr, unsigned long offset);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flmtl.c ===
/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/flmtl.c_V  $
 * 
 *    Rev 1.11   Nov 08 2001 10:49:20   oris
 * Added support for up to 1GB DiskOnChips.
 * 
 *    Rev 1.10   Sep 24 2001 18:23:40   oris
 * Removed warnings.
 * 
 *    Rev 1.9   Sep 15 2001 23:46:16   oris
 * Changed progress callback routine to support up to 64K units.
 *
 *    Rev 1.8   Jul 13 2001 01:05:16   oris
 * Removed warnings.
 * Bug fix - exception when format routine is called with null progress call back routine.
 * Report noOfDrives as 1.
 *
 *    Rev 1.7   Jun 17 2001 08:18:40   oris
 * Add improoved the format progress call back routine.
 * Removed fack number of TLS in mtlPreMount routine.
 *
 *    Rev 1.6   May 21 2001 16:13:08   oris
 * Replaced memcpy with tffscpy Macro.
 *
 *    Rev 1.5   May 17 2001 18:54:26   oris
 * Removed warnings.
 *
 *    Rev 1.4   May 16 2001 21:19:02   oris
 * Changed the fl_MTLdefragMode variable to a global environment variable.
 * MTL now changes the noOfDriver variable after the first mount and restores it after uninstall.
 * Added missing ifdef directives.
 * Removed warnings.
 * Removed readBBT and writeBBT routines.
 * Improved MTL protection routine.
 *
 *    Rev 1.3   Apr 01 2001 08:01:18   oris
 * copywrite notice.
 * Alligned left all # directives.
 *
 *    Rev 1.2   Feb 18 2001 12:06:54   oris
 * Install mtl will now fake the noOfTLs in order to be the only TL.
 * Placed mtlFormat under FORMAT_VOLUME compilation flag.
 * Place mtlProtection under HW_PROTECTION compilation flag.
 * Changed mtlPreMount arg sanity check to include partition number.
 * Changed tmpflash to tmpFlash.
 *
 *    Rev 1.1   Feb 14 2001 02:09:38   oris
 * Changed readBBT to return media size.
 * Added boundry argument to writeBBT.
 *
 *    Rev 1.0   Feb 12 2001 12:07:02   oris
 * Initial revision.
 *
 *    Rev 1.3   Jan 24 2001 18:10:48   oris
 * Bug fix: MTL failed to register because noOfTLs wan't updated
 *
 *    Rev 1.2   Jan 24 2001 16:34:06   oris
 * MTL defragmentation changed, alt. defragmentation added.
 *
 *    Rev 1.1   Jan 22 2001 22:10:50   amirm
 * #define FL_MTL_HIDDEN_SECTORS added
 *
 *    Rev 1.0   Jan 22 2001 18:27:54   amirm
 * Initial revision.
 *
 */


/*
 * Include
 */

#include "fltl.h"


/*
 * Configuration
 */

/* This defined sets the number of sectors to ignore starting from the
 * first device. The default value should be 1 therfore ignoring sector
 * 0 of the first device. Ignioring sector 0 gurentees that the combined
 * device does not use the BPB of the first device, which does not report
 * the C/H/S of the new combined media. The next format operation would
 * write a new BPB that would fit the new combined media size.
 */

#define FL_MTL_HIDDEN_SECTORS   1

/*
 * Extern
 */

/*
 * Globals
 */

FLStatus  flRegisterMTL  (void);    /* see also stdcomp.h */
FLStatus  flmtlInstall   (void);
FLStatus  flmtlUninstall (void);

/*
 * Local types
 */

/* I/O vector for splitting I/O among physical devices */

typedef struct {
    SectorNo  startSector;
    SectorNo  sectors;
} tMTLiov;


/* Physical flash device. Part of MTL volume. */

typedef struct {
    SectorNo     virtualSectors;
    TL           tl;
    dword        physicalSize;
} tMTLPhysDev;


/* MTL volume */

struct tTLrec {
    int          noOfTLs;
    int          noOfDrives;
    SectorNo     virtualSectors;
    tMTLPhysDev  devs[SOCKETS];
};

typedef TLrec MTL;

/*
 * Local data
 */

/* only one MTL volume is supported */

static MTL mvol;

/* progress callBack routine */

FLProgressCallback globalProgressCallback = NULL;

/* access macros for MTL volume */

#define  mT(dev)            (mvol.devs[dev].tl)
#define  mS(dev)            (mvol.devs[dev].virtualSectors)
#define  mP(dev)            (mvol.devs[dev].physicalSize)

#define  mpT(pvol,dev)   ((pvol)->devs[dev].tl)
#define  mpF(pvol,dev)   ((pvol)->devs[dev].flash)
#define  mpS(pvol,dev)   ((pvol)->devs[dev].virtualSectors)

/*
 * Local routines
 */

static FLStatus  mtlSplitIO (MTL *pvol, SectorNo startSector,
                	SectorNo sectors, tMTLiov *iov);
static FLStatus  mtlWrite (MTL *pvol, SectorNo startSector,
                      SectorNo *pSectorsToWrite, void FAR1 *buf);
static FLStatus  mtlMount (unsigned volNo, TL *tl, FLFlash *flash,
                           FLFlash **notUsed);
#if defined(DEFRAGMENT_VOLUME) || defined(SINGLE_BUFFER)
static FLStatus  mtlDefragment (MTL *pvol, long FAR2 *sectorsNeeded);
#ifdef ENVIRONMENT_VARS
static FLStatus  mtlDefragmentAlt (MTL *pvol, long FAR2 *sectorsNeeded);
#endif /* ENVIRNOMETN_VARS */
#endif /* DEFRAGMENT_VOLUME || SINGLE_BUFFER */
static void      mtlUnmount (MTL *pvol);
#ifdef FORMAT_VOLUME
static FLStatus  mtlFormat (unsigned volNo, TLFormatParams* formatParams,
                                            FLFlash *flash);
#endif /* FORMAT_VOLUME */
static FLStatus  mtlWriteSector (MTL *pvol, SectorNo sectorNo,
                                            void FAR1 *fromAddress);
static FLStatus  mtlDeleteSector (MTL *pvol, SectorNo sectorNo,
                                             SectorNo noOfSectors);
static FLStatus  mtlInfo (MTL *pvol, TLInfo *tlInfo);
static FLStatus  mtlSetBusy (MTL *pvol, FLBoolean state);
static SectorNo  mtlSectorsInVolume (MTL *pvol);
static const void FAR0  *mtlMapSector (MTL *pvol, SectorNo sectorNo,
                          CardAddress *physAddress);
#ifdef HW_PROTECTION
static FLStatus  mtlProtection(FLFunctionNo callType,
                   IOreq FAR2* ioreq, FLFlash* flash);
#endif /* HW_PROTECTION */
static FLStatus  mtlPreMount(FLFunctionNo callType, IOreq FAR2* ioreq ,
                 FLFlash* flash,FLStatus* status);

/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l S p l i t I O                              *
 *                                                                            *
 *  Setup I/O vector for splitting I/O request among physical devices.        *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      startSector          : starting sector # (zero-based)                 *
 *      sectors              : total number of sectors                        *
 *      iov                  : I/O vector to setup                            *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlSplitIO (MTL *pvol, SectorNo startSector, SectorNo sectors,
                                                              tMTLiov *iov)
{
    SectorNo  devFirstSectNo;
    SectorNo  devLastSectNo;
    int       iDev;

    /* check 'pvol' for sanity */

    if (pvol != &mvol)
        return flBadDriveHandle;

    /* clear I/O vector */

    for (iDev = 0;  iDev < SOCKETS;  iDev++) {
      iov[iDev].sectors     = (SectorNo) 0;
      iov[iDev].startSector = (SectorNo)(-1);
    }

    /* split I/O operation among physical devices */

    devFirstSectNo = (SectorNo) 0;

    for (iDev = 0;  (iDev < noOfSockets) && (sectors > ((SectorNo) 0));  iDev++) {

        devLastSectNo = devFirstSectNo + (mpS(pvol,iDev) - ((SectorNo) 1));

        if ((startSector >= devFirstSectNo) && (startSector <= devLastSectNo)) {

          iov[iDev].startSector = startSector - devFirstSectNo + FL_MTL_HIDDEN_SECTORS;
          iov[iDev].sectors     = devLastSectNo - startSector + ((SectorNo) 1);

            startSector = devLastSectNo + ((SectorNo) 1);

            if (sectors <= iov[iDev].sectors) {
                iov[iDev].sectors = sectors;
                startSector = (SectorNo) 0;
                sectors     = (SectorNo) 0;
            }
        	  else {
               sectors -= iov[iDev].sectors;
            }
        }

        devFirstSectNo = devLastSectNo + ((SectorNo) 1);
    }

    if (sectors > ((SectorNo) 0)) {
        DEBUG_PRINT(("Debug: can't split I/O request among physical devices.\n"));
        return flNoSpaceInVolume;
    }

    return flOK;
}




/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l M a p S e c t o r                          *
 *                                                                            *
 *  TL's standard 'map one sector' routine.                                   *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      sectorNo             : sector # to map (zero-based)                   *
 *      physAddress          : optional pointer to receive sector's physical  *
 *                             address on the media                           *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static const void FAR0  *mtlMapSector (MTL *pvol, SectorNo sectorNo,
                                                  CardAddress *physAddress)
{
    SectorNo  sectorsToMap;
    tMTLiov   iov[SOCKETS];
    int       iDev;

    /* pass call to the TL of the respective underlaying physical device */

    sectorsToMap = (SectorNo) 1;
    if (mtlSplitIO(pvol, sectorNo, sectorsToMap, iov) != flOK)
        return NULL;

    for (iDev = 0;  iDev < noOfSockets;  iDev++) {
        if (iov[iDev].sectors != ((SectorNo) 0)) {
           return mpT(pvol,iDev).mapSector (mpT(pvol,iDev).rec,
						      iov[iDev].startSector, physAddress);
        }
    }

    return NULL;
}




/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l W r i t e                                  *
 *                                                                            *
 *  Split call to write multiple consequitive sectors among TLs of the        *
 *  underlaying physical devices.                                             *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      startSector          : starting sector # (zero-based)                 *
 *      pSectorsToWrite      : on entry - total number of sectors to write    *
 *                             on exit  - total number of sectors written     *
 *      buf                  : buffer containing data to write to the media   *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlWrite (MTL *pvol, SectorNo startSector,
               SectorNo *pSectorsToWrite, void FAR1 *buf)
{
    tMTLiov  iov[SOCKETS];
    int      iDev;

    /* split call among TLs of the underlaying physical devices */

    checkStatus( mtlSplitIO(pvol, startSector, *pSectorsToWrite, iov) );

    for (iDev = 0;  iDev < noOfSockets;  iDev++) {

	      if (iov[iDev].sectors != ((SectorNo) 0)) {
           checkStatus( mpT(pvol,iDev).writeSector(mpT(pvol,iDev).rec,
                            iov[iDev].startSector,buf) );
           *pSectorsToWrite -= iov[iDev].sectors;
           buf = BYTE_ADD_FAR(buf,(CardAddress)iov[iDev].sectors << SECTOR_SIZE_BITS);
        }

    }

    if (*pSectorsToWrite != ((SectorNo) 0))
        return flIncomplete;

    return flOK;
}




/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                          m t l W r i t e S e c t o r                       *
 *                                                                            *
 *  TL's standard 'write one sector' routine.                                 *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      sectorNo             : sector # to write to (zero-based)              *
 *      fromAddress          : buffer containing data to write to the media   *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlWriteSector (MTL *pvol, SectorNo sectorNo, void FAR1 *fromAddress)
{
    SectorNo  sectorsToWrite = (SectorNo) 1;

    /* pass call to the TL of the respective underlaying physical device */

    checkStatus( mtlWrite(pvol, sectorNo, &sectorsToWrite, (char FAR1 *)fromAddress) );

    if (sectorsToWrite != ((SectorNo) 0))
        return flIncomplete;

    return flOK;
}




/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                        m t l D e l e t e S e c t o r                       *
 *                                                                            *
 *  TL's standard 'delete range of sectors' routine.                          *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      startSector          : starting sector # (zero-based)                 *
 *      sectors              : total number of sectors to delete              *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlDeleteSector (MTL *pvol, SectorNo startSector,
                                             SectorNo sectors)
{
    tMTLiov  iov[SOCKETS];
    int      iDev;

    /* split call among TLs of the underlaying physical devices */

    checkStatus( mtlSplitIO(pvol, startSector, sectors, iov) );

    for (iDev = 0;  iDev < noOfSockets;  iDev++) {

        if (iov[iDev].sectors != ((SectorNo) 0)) {
           checkStatus( mpT(pvol,iDev).deleteSector(mpT(pvol,iDev).rec,
                                                     iov[iDev].startSector,
                                                     iov[iDev].sectors) );
        }

        sectors -= iov[iDev].sectors;
    }

    if (sectors != ((SectorNo) 0))
        return flIncomplete;

    return flOK;
}




/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l I n f o                                    *
 *                                                                            *
 *  TL's standard 'get info' routine.                                         *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      pTLinfo              : pointer to the TLInfo structure to fill in     *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlInfo (MTL *pvol, TLInfo *pTLinfo)
{
    TLInfo  tmp;
    int     iDev;

    /* check 'pvol' for sanity */

    if (pvol != &mvol)
        return flBadDriveHandle;

    pTLinfo->sectorsInVolume = pvol->virtualSectors;

    /*
     * The 'eraseCycles' is reported as a sum of that of all the underlaying
     * physical devices. The 'bootAreaSize' is set to the one of the 1st
     * underlaying physical device.
     */

    pTLinfo->bootAreaSize = (dword) 0;
    pTLinfo->eraseCycles  = (dword) 0;

    for (iDev = 0;  iDev < noOfSockets;  iDev++) {
	     if (mpT(pvol,iDev).getTLInfo != NULL) {
          checkStatus( mpT(pvol,iDev).getTLInfo(mpT(pvol,iDev).rec, &tmp) );

          pTLinfo->eraseCycles += tmp.eraseCycles;

          if (iDev == 0)
    	        pTLinfo->bootAreaSize = tmp.bootAreaSize;
			 }
    }

    return flOK;
}

/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l S e t B u s y                              *
 *                                                                            *
 *  TL's standard routine which is called at the beginning and and the end of *
 *  the block device operation.                                               *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      state                : FL_ON  - start of block device operation          *
 *                             FL_OFF - end of block device operation            *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus mtlSetBusy (MTL *pvol, FLBoolean state)
{
    int iDev;

    /* check 'pvol' for sanity */

    if (pvol != &mvol)
       return flBadDriveHandle;

    /* broadcast this call to TLs of all the underlaying physical devices */

    for (iDev = 0;  iDev < noOfSockets;  iDev++) {
       if (mpT(pvol,iDev).tlSetBusy != NULL) {
          checkStatus( mpT(pvol,iDev).tlSetBusy(mpT(pvol,iDev).rec, state) );
       }
    }

    return flOK;
}




/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                  m t l S e c t o r s I n V o l u m e                       *
 *                                                                            *
 *  Report the total number of sectors in the volume.                         *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      Total number of sectors in the volume, or zero in case of error.      *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static SectorNo mtlSectorsInVolume (MTL *pvol)
{
    /* check 'pvol' for sanity */

    if (pvol != &mvol)
	return ((SectorNo) 0);

    return pvol->virtualSectors;
}




#if defined(DEFRAGMENT_VOLUME) || defined(SINGLE_BUFFER)

/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l D e f r a g m e n t                        *
 *                                                                            *
 *  TL's standard garbage collection / volume defragmentaion routine.         *
 *                                                                            *
 *  Note : The garbage collection algorithm will try and free the required    *
 *         number of sectors on each of the combined devices.                 *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      sectorsNeeded        : On entry - minimum number of free sectors that *
 *                             are requested to be on the media upon call     *
 *                             completion. Two special cases: zero for        *
 *                             complete defragmentation of all the physical   *
 *                             devices, and '-1' for minimal defragmentation  *
 *                             of each physical device.                       *
 *                             On exit  - actual number of free sectors on    *
 *                             the media.                                     *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlDefragment (MTL *pvol, long FAR2 *sectorsNeeded)
{
    long      freeSectors;
    FLStatus  status;
    int       iDev;
    long      tmp;
    FLStatus  tmpStatus;

    /* check args for sanity */

    if (pvol != &mvol)
        return flBadDriveHandle;

    /*
     * Pass call to the TL of the respective underlaying physical device.
     * Count total number of free sectors on all devices.
     */

    status = flOK;

    freeSectors = (long) 0;

    for (iDev = 0;  iDev < noOfSockets;  iDev++) {

      	if (mpT(pvol,iDev).defragment != NULL) {

           switch (*sectorsNeeded) {

    	        case ((long)(-1)):               /* minimal defragmenation */
                 tmp = (long)(-1);
                 break;

    	        case ((long) 0):                 /* complete defragmenation */
                 tmp = mpS(pvol,iDev);
                 break;

    	        default:                         /* partial defragmentation */
                 if (*sectorsNeeded < (long) mpS(pvol,iDev))
								 {
        	          tmp = *sectorsNeeded;
								 }
                 else
								 {
        	          tmp = mpS(pvol,iDev);    /* complete defragmentation */
								 }
                 break;
					 }

           tmpStatus = mpT(pvol,iDev).defragment (mpT(pvol,iDev).rec, ((long FAR2 *) &tmp));
           if (tmpStatus != flBadFormat)
					 {
    	        freeSectors += tmp;
					 }
           else
					 {
    	        status = tmpStatus;
					 }
				}
    }

    *sectorsNeeded = freeSectors;

    if (*sectorsNeeded == ((long) 0))
	      return flNoSpaceInVolume;

    return status;
}

#ifdef ENVIRONMENT_VARS

/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                        m t l D e f r a g m e n t A l t                     *
 *                                                                            *
 *  TL's alternative garbage collection / volume defragmentaion routine.      *
 *                                                                            *
 *  Note : The garbage collection algorithm Perform quick gurbage collections *
 *         from drive 0 until there is no more "garbage" to collect or until  *
 *         there is enough clean space. If the specified clean spage was not  *
 *         achieved try the next device.                                      *
 *         While this method is faster then the standard defragment, it does  *
 *         not gurantee that when the clean sectors are needed they will be   *
 *         available. This is becuase write operation on MTL will directed    *
 *         the write operation to a specific device according to the specifed *
 *         virtual sector number (not necceseraly starting from device #0).   *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *      sectorsNeeded        : On entry - minimum number of free sectors that *
 *                             are requested to be on the media upon call     *
 *                             completion. Two special cases: zero for        *
 *                             complete defragmentation of all the physical   *
 *                             devices, and '-1' for minimal defragmentation  *
 *                             of each physical device.                       *
 *                             On exit  - actual number of free sectors on    *
 *                             the media.                                     *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlDefragmentAlt (MTL *pvol, long FAR2 *sectorsNeeded)
{
    long       freeSectors;
    FLBoolean  keepWorking;
    FLBoolean  driveDone[SOCKETS];
    long       freeSectorsOnDrive[SOCKETS];
    FLStatus   status;
    int        iDev;
    FLStatus   tmpStatus;
    long       tmp;

    /* check args for sanity */

    if (pvol != &mvol)
        return flBadDriveHandle;

    /*
     * Pass call to the TL of the respective underlaying physical device.
     * Count total number of free sectors on all devices.
     */

    status = flOK;

    freeSectors = (long) 0;

    if ((*sectorsNeeded == ((long) -1))  ||  (*sectorsNeeded == (long)0)) {

        /* Either total or minimal defragmentation of all physical devices. */

        for (iDev = 0;  iDev < noOfSockets;  iDev++) {

            if (mpT(pvol,iDev).defragment != NULL) {

                if (*sectorsNeeded == ((long) -1))
                   tmp = (long)(-1);            /* minimal defragmenation */
                else
                    tmp = mpS(pvol,iDev);        /* complete defragmenation */

                tmpStatus = mpT(pvol,iDev).defragment (mpT(pvol,iDev).rec, ((long FAR2 *) &tmp));

            if (tmpStatus != flBadFormat) {
            freeSectors += tmp;
        }
                else {
                    DEBUG_PRINT(("Debug: Error defragmenting physical device.\n"));
                status = tmpStatus;
        }

        }
        }
    }
    else {  /* Partial defragmentaion of the MTL volume */

        for (iDev = 0;  iDev < SOCKETS;  iDev++) {
      freeSectorsOnDrive[iDev] = (long) 0;
      if ((iDev < noOfSockets)  &&  (mpT(pvol,iDev).defragment != NULL))
          driveDone[iDev] = FALSE;
      else
          driveDone[iDev] = TRUE;
    }

        keepWorking = TRUE;

        while (keepWorking == TRUE) {

            keepWorking = FALSE;

            for (iDev = 0;  iDev < noOfSockets;  iDev++) {

               /*
                * Do minimal defragmentation of this physical device. If we
                * have got error, or haven't gained any more free sectors,
                * this physical device is done. If that is the case for all
                * physical devices, the MTL defragmentation is done. If the
                * required number of free sectors has been reached, MTL
                * defragmentation is done.
                */

            if (driveDone[iDev] != TRUE) {

            tmp = (long) -1;
                    tmpStatus = mpT(pvol,iDev).defragment (mpT(pvol,iDev).rec, ((long FAR2 *) &tmp));

                if (tmpStatus != flBadFormat) {

                if (freeSectorsOnDrive[iDev] < tmp) {

                            /* got few more free sectors on that physical device */

                            keepWorking = TRUE;

                            freeSectors += (tmp - freeSectorsOnDrive[iDev]);
                freeSectorsOnDrive[iDev] = tmp;

                if (freeSectors >= *sectorsNeeded) {

                                /* required number of free sectors reached */

                    keepWorking = FALSE;
                    break;
                }
            }
                else {  /* didn't gain any free sectors */
                            driveDone[iDev] = TRUE;
                }
            }
                    else {
                        DEBUG_PRINT(("Debug: Error defragmenting physical device.\n"));
                        driveDone[iDev] = TRUE;
                status = tmpStatus;
            }
        }

        }   /* for (iDev) */
    }   /* while (keepWorking */
    }

    *sectorsNeeded = freeSectors;

    if (*sectorsNeeded == ((long) 0))
        return flNoSpaceInVolume;

    return status;
}
#endif /* ENVIRONEMENT_VARS */
#endif /* DEFRAGMENT_VOLUME || SINGLE_BUFFER */
#ifdef HW_PROTECTION
/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l P r o t e c t i o n                        *
 *                                                                            *
 *  TL's protection routine.                                                  *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      callType             : pre mount protection operation type.           *
 *      ioreq                : pointer to the structure containing i\o fields *
 *      flash                : pointer to the flash record of device #0
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlProtection(FLFunctionNo callType, IOreq FAR2* ioreq,
                   FLFlash* flash)

{
    FLSocket  *socket;
    FLStatus  status;
    FLStatus  callStatus;
    FLFlash   tmpFlash;
    int       iTL;
    int       iDev = 0;
    unsigned  flags = 0;

    /*
     * Do flash recognition and identify protection attributes for devices
     * #0 .. (mvol.noOfSockets - 1) verifing that the operation can be
     * preformed and that the protection attributes of all the devieces
     * match.
     */

    tffscpy(&tmpFlash,flash,sizeof (tmpFlash)); /* Use the given flash */

    while(1)
    {
    /* The tmpFlash record is already intialized Try all the TLs */

	status = flUnknownMedia;
	for (iTL = 1;(iTL < mvol.noOfTLs) && (status == flUnknownMedia); iTL++)
    {
       if ((tlTable[iTL].formatRoutine   == NULL) || /* TL filter */
           (tlTable[iTL].preMountRoutine == NULL))
          continue;
       status = tlTable[iTL].preMountRoutine(FL_PROTECTION_GET_TYPE,
                         ioreq,&tmpFlash,&callStatus);
    }
	if (status != flOK)
    {
        DEBUG_PRINT(("Debug: no TL recognized the device, MTL protection aborted.\n"));
        return flFeatureNotSupported;
    }
	if (callStatus != flOK)
    {
       return callStatus;
    }

    /* Check protection attributes */

	if ((ioreq->irFlags & PROTECTABLE) == 0)
      return flNotProtected;

	if (iDev == 0) /* First device */
    {
       flags = ioreq->irFlags;
    }
	else
    {
       /* Diffrent protection attributes on diffrent devices */
       if (ioreq->irFlags != flags)
          return flMultiDocContrediction;
    }

    /* Validity check for the proper function call */

	switch(callType)
    {
        case FL_PROTECTION_GET_TYPE:       /* Identify protection */
           if (iDev == noOfSockets-1)
               return flOK;
         break;
        case FL_PROTECTION_SET_LOCK:       /* Change protection */
        case FL_PROTECTION_CHANGE_KEY:
        case FL_PROTECTION_CHANGE_TYPE:
           if (!(flags & CHANGEABLE_PROTECTION        ) ||
                (tmpFlash.protectionBoundries == NULL ) ||
                (tmpFlash.protectionSet       == NULL ))
                 {
                return flUnchangeableProtection;
                 }
        default:                           /* Insert and remove Key */
           break;
    }

    /* Identify flash for next device */

	if (iDev < noOfSockets - 1)
    {
       iDev++;
       socket = flSocketOf (iDev);

       /* Identify */

       status = flIdentifyFlash (socket, &tmpFlash);
       if ((status != flOK) && (status != flUnknownMedia))
       {
          DEBUG_PRINT(("Debug: no MTD recognized the device, MTL protection aborted.\n"));
          return status;
       }
    }
	else
      break;

    }  /* for(iDev) */

    /*
     * Pass call to the TL of the respective underlaying physical device.
     * Do flash recognition try all TLs registered in tlTable[]. Assume MTL
     * is in tlTable[0], so skip it. Skip all the TL filters as well.
     */

    for (iDev = 0, callStatus = flOK;
     (iDev < noOfSockets) && (callStatus == flOK);  iDev++)
    {
       socket = flSocketOf (iDev);

       /* Identify */

       status = flIdentifyFlash (socket, &tmpFlash);
       if ((status != flOK) && (status != flUnknownMedia))
       {
      DEBUG_PRINT(("Debug: no MTD recognized the device, MTL protection aborted.\n"));
      return status;
       }

       /* Try all the TLs */

       status = flUnknownMedia;
       for (iTL = 1;  (iTL < mvol.noOfTLs) && (status == flUnknownMedia);  iTL++)
       {
       if ((tlTable[iTL].formatRoutine   == NULL) || /* TL filter */
           (tlTable[iTL].preMountRoutine == NULL))
          continue;
       status = tlTable[iTL].preMountRoutine(callType,ioreq,
                         &tmpFlash,&callStatus);
       }
       if (status != flOK)
       {
       DEBUG_PRINT(("Debug: no TL recognized the device, MTL protection aborted.\n"));
       return flFeatureNotSupported;
       }
    }
    return callStatus;
}
#endif /* HW_PROTECTION */
/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l P r e M o u n t                            *
 *                                                                            *
 *  TL's standard volume pre mount routine.                                       *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      callType             : pre mount operation type.                      *
 *      ioreq                : pointer to the structure containing i\o fields *
 *      flash                : MTD attached to the 1st underlaying physical   *
 *                             device                                         *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      The routine always return flOK in order to stop other TLs from trying *
 *      to perform the operation. The true status code is returned in the     *
 *      'status' parameter. flOK on success, otherwise respective error code. *                    *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlPreMount(FLFunctionNo callType, IOreq FAR2* ioreq ,
                 FLFlash* flash,FLStatus* status)
{
    /* arg sanity check */

    if (ioreq->irHandle != 0)
    {
        DEBUG_PRINT(("Debug: can't execute, MTL must address first volume of socket 0.\n"));
        *status = flBadParameter;
        return flOK;
    }

    switch (callType)
    {
       case FL_COUNT_VOLUMES:

    /* Count VOLUMES routine. We assume that while MTL is mounted only
     * one device of each socket can be mounted.
     */

          ioreq->irFlags = 1;
          *status = flOK;
          break;

    /* Protection rouines. Call each of the underlaying physical devices. */

#ifdef HW_PROTECTION
       case FL_PROTECTION_GET_TYPE:
       case FL_PROTECTION_SET_LOCK:
       case FL_PROTECTION_CHANGE_KEY:
       case FL_PROTECTION_CHANGE_TYPE:
       case FL_PROTECTION_REMOVE_KEY:
       case FL_PROTECTION_INSERT_KEY:
      *status = mtlProtection(callType,ioreq,flash);
      break;
#endif /* HW_PROTECTION */

    /* Write Bad Block Table. Call each of the underlaying physical device. */

       case FL_WRITE_BBT:
      *status = flFeatureNotSupported/*mtlWriteBBT(ioreq)*/;
      return flFeatureNotSupported;

       default:
           return flBadParameter;
    }

    DEBUG_PRINT(("Debug: MTL premount succeeded.\n"));

    return flOK;
}

/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l U n m o u n t                              *
 *                                                                            *
 *  TL's standard volume unmount routine.                                     *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                 : Pointer identifying drive                      *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      none                                                                  *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static void  mtlUnmount (MTL *pvol)
{
    int  iDev;

    /* check 'pvol' for sanity */

    if (pvol != &mvol)
        return;

    /* broadcast this call to TLs of all the underlaying physical devices */

    for (iDev = 0;  iDev < noOfSockets;  iDev++) {
        if (mpT(pvol,iDev).dismount != NULL) {
        mpT(pvol,iDev).dismount (mpT(pvol,iDev).rec);
        }
    }

    /* Return the real number of drives */
    noOfDrives = mvol.noOfDrives;

    DEBUG_PRINT(("Debug: MTL dismounted succeeded.\n"));

}


/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l M o u n t                                  *
 *                                                                            *
 *  TL's standard volume mount routine.                                       *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      volNo                : volume #, must be zero                         *
 *      tl                   : pointer to TL structure to fill in             *
 *      flash                : MTD attached to the 1st underlaying physical   *
 *                             device                                         *
 *      forCallback          : MTD for power on callback (not used).          *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlMount (unsigned volNo, TL *tl, FLFlash *flash,
                                                   FLFlash **forCallback)
{
    FLFlash    tmpFlash;
	FLFlash    *volForCallback;
	FLSocket   *socket;
	FLStatus   status = flUnknownMedia;
	int        iTL;
	int        iDev = 0;

    /* Arg sanity check */

	if (volNo != ((unsigned) 0)) {
       DEBUG_PRINT(("Debug: can't mount, MTL volume # is not zero.\n"));
       return flBadParameter;
    }

    /*
     * Do TL mount for device #0. Routine flIdentifyFlash() has already been
     * called for this device (see arguement 'flash')
     */

	volForCallback = NULL;

/*    mT(0).recommendedClusterInfo = NULL;
	mT(0).writeMultiSector       = NULL;
	mT(0).readSectors            = NULL; */

    /*
     * Try all TLs registered in tlTable[]. Assume MTL is in tlTable[0], so
     * skip it. Skip all the TL filters as well.
     */

	for (iTL = 1;  (iTL < mvol.noOfTLs) && (status != flOK);  iTL++) {
    	if (tlTable[iTL].formatRoutine == NULL)   /* TL filter */
    	continue;
    	status = tlTable[iTL].mountRoutine (0, &mT(0), flash, &volForCallback);
    }
	if (status != flOK) {
	DEBUG_PRINT(("Debug: no TL recognized device #0, MTL mount aborted.\n"));
	return status;
    }

	mP(iDev) = (dword)(flash->chipSize * flash->noOfChips); /* Physical size */

	if (volForCallback)
    	volForCallback->setPowerOnCallback (volForCallback);

    /*
     * Do flash recognition and TL mount for devices #1 .. (mvol.noOfSockets - 1).
     * First call flIdentifyFlash() to find MTD, then try all TLs registered
     * in tlTable[]. Assume MTL is in tlTable[0], so skip it. Skip all the
     * TL filters as well.
     */

	for (iDev = 1;  iDev < noOfSockets;  iDev++) {

    	socket = flSocketOf (iDev);

    	status = flIdentifyFlash (socket, &tmpFlash);
    	if ((status != flOK) && (status != flUnknownMedia)) {
    	DEBUG_PRINT(("Debug: no MTD recognized the device, MTL mount aborted.\n"));
    	goto exitMount;
    }

	volForCallback = NULL;
	mP(iDev) = (dword)(tmpFlash.chipSize * tmpFlash.noOfChips); /* Physical size */
    mT(iDev).partitionNo = 0;
    mT(iDev).socketNo    = (byte)iDev;


/*        mT(iDev).recommendedClusterInfo = NULL;
	mT(iDev).writeMultiSector       = NULL;
	mT(iDev).readSectors            = NULL;*/

	status = flUnknownMedia;
	for (iTL = 1;  (iTL < mvol.noOfTLs) && (status != flOK);  iTL++) {
    	if (tlTable[iTL].formatRoutine == NULL)  /* TL filter */
    	continue;
    	status = tlTable[iTL].mountRoutine (iDev, &mT(iDev), &tmpFlash, &volForCallback);
    }
	if (status != flOK) {
    	DEBUG_PRINT(("Debug: no TL recognized the device, MTL mount aborted.\n"));
    	goto exitMount;
    }

	if (volForCallback)
    	volForCallback->setPowerOnCallback (volForCallback);
    }   /* for (iDev) */

    /* Count the total of virtual sectors across all devices */

	mvol.virtualSectors = (SectorNo) 0;
	for (iDev = 0;  iDev < SOCKETS;  iDev++) {
	mS(iDev) = (SectorNo) 0;
	if (iDev >= noOfSockets)
    	continue;

	mS(iDev) = mT(iDev).sectorsInVolume (mT(iDev).rec) - FL_MTL_HIDDEN_SECTORS;
	mvol.virtualSectors += mS(iDev);
    }

exitMount:
	if (status != flOK)
    {
       /* If one of the devices failed mount dismount all devices */
       for (;iDev >=0;iDev--)
       {
          if (mT(iDev).dismount != NULL)
          mT(iDev).dismount(mT(iDev).rec);
       }
       DEBUG_PRINT(("Debug: MTL mount failed.\n"));
       return status;
    }

    /*
     * Attach MTL-specific record to 'tl'. This record will be passed
     * as the first arguement to all TL calls.
     */

    tl->rec = &mvol;

    /* Fill in the TL access methods */

    tl->mapSector              = mtlMapSector;
    tl->writeSector            = mtlWriteSector;
    tl->deleteSector           = mtlDeleteSector;

#if defined(DEFRAGMENT_VOLUME) || defined(SINGLE_BUFFER)
#ifdef ENVIRONMENT_VARS
    if (flMTLdefragMode == FL_MTL_DEFRAGMENT_SEQUANTIAL)
    {
       tl->defragment         = mtlDefragmentAlt;
    }
    else
#endif /* ENVIRONMENT_VARS */
    {
       tl->defragment         = mtlDefragment;
    }
#endif

    tl->sectorsInVolume        = mtlSectorsInVolume;
    tl->getTLInfo              = mtlInfo;
    tl->tlSetBusy              = mtlSetBusy;
    tl->dismount               = mtlUnmount;
    tl->readBBT                = NULL /*mtlReadBBT*/;

    /*
     * The following methods are not supported by NFTL, and have already
     *  been set to NULL by flMount(). We just confirm this here.
     */

    tl->writeMultiSector       = NULL;
    tl->readSectors            = NULL;
	tl->recommendedClusterInfo = NULL;

    /* Fake the no of volume exported by TrueFFS */
	mvol.noOfDrives = noOfDrives;
	noOfDrives      = 1;


	DEBUG_PRINT(("Debug: MTL mount succeeded.\n"));

	return status;
}

#ifdef FORMAT_VOLUME

/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                   m t l P r o g r e s s C a l l B a c k                    *
 *                                                                            *
 *  Extends the given format routine to report the full media size.           *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      totalUnitsToFormat	     : total units needed to format               *
 *      totalUnitsFormattedSoFar : unit formated so far.                      *
 *                                                                            *
 *  Notes                                                                     *
 *                                                                            *
 *  1) arguments 0 and 0 initializes the total unit counter to 0.             *
 *  2) arguments -1 and -1 indicates the ending of the last device.           *
 *                                                                            *                                                                           *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 * -------------------------------------------------------------------------- */

static FLStatus mtlProgressCallback(word totalUnitsToFormat,
                                	word totalUnitsFormattedSoFar)
{
   static int lastTotal;
   static int lastDevice;

   /* Initialize lastTotal counter */
   if ((totalUnitsToFormat == 0) && (totalUnitsFormattedSoFar == 0))
   {
      lastTotal  = 0;
      lastDevice = 0;
      return flOK;
   }

   /* Indicate a new device is being formated */
   if ((totalUnitsToFormat == 0) && (totalUnitsFormattedSoFar == 0xffff))
   {
      lastTotal += lastDevice;
      return flOK;
   }

   /* Call original call back routine */
   lastDevice = totalUnitsToFormat;
   if (globalProgressCallback == NULL)
   {
      return flOK;
   }
   else
   {
      return globalProgressCallback((word)(lastTotal + totalUnitsToFormat),
                                    (word)(lastTotal + totalUnitsFormattedSoFar));
   }
}


/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l F o r m a t                                *
 *                                                                            *
 *  TL's standard volume mount routine.                                       *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      volNo                : volume #, must be zero                         *
 *      formatParams         : pointer to the structure containing format     *
 *                             parameters                                     *
 *      flash                : MTD attached to the 1st underlaying physical   *
 *                             device                                         *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- *
 *                                                                            *
 *  NOTE.  Binary area has 2 possible options:                                *
 *                                                                            *
 *       - TL_LEAVE_BINARY_AREA is set - binary area is left for all devices  *
 *       - TL_LEAVE_BINARY_AREA is off - binary area is placed only on the    *
 *                                       device #0                            *
 *                                                                            *
 *         Handling of 'formatParams.progressCallback' should be improved.    *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlFormat (unsigned volNo, TLFormatParams* formatParams,
                                        	FLFlash *flash)
{
	FLFlash    tmpFlash;
	FLSocket   *socket;
	FLStatus   status = flUnknownMedia;
	int        iTL, iDev;

    /* arg sanity check */

	if (volNo != ((unsigned) 0)) {
    	DEBUG_PRINT(("Debug: can't format, MTL socket # is not zero.\n"));
    	return flBadParameter;
    }
	if (formatParams->noOfBDTLPartitions > 1){
    	DEBUG_PRINT(("Debug: can't format, MTL with more then 1 BDTL volume.\n"));
    	return flBadParameter;
    }

	if (formatParams->flags & TL_SINGLE_FLOOR_FORMATTING){
    	DEBUG_PRINT(("Debug: can't format, MTL does not support single floor formatting.\n"));
    	return flBadParameter;
    }

    /* Initialize the progress call back routine to indicate the agregated
     * size. The actual routine is saved and mtl routine is used.
     */

     globalProgressCallback = formatParams->progressCallback;
     formatParams->progressCallback = mtlProgressCallback; /* Set new routine */
     mtlProgressCallback(0,0); /* Initialize new format operation */


    /*
     * Format device #0. Routine flIdentifyFlash() has already been called
     * for this device (see arguement 'flash'). Try all TLs registered
     * in tlTable[]. Assume MTL is in tlTable[0], so skip it. Skip all the
     * TL filters as well.
     */

	for (iTL = 1;  (iTL < mvol.noOfTLs) && (status == flUnknownMedia);  iTL++) {
    	if (tlTable[iTL].formatRoutine == NULL)   /* TL filter */
    	continue;
    	status = tlTable[iTL].formatRoutine(0, formatParams, flash);
    }
	if (status != flOK) {
    	DEBUG_PRINT(("Debug: no TL recognized device #0, MTL format aborted.\n"));
    	return status;
    }

    /*
     * Put all 'bootImageLen' and 'exbLen' to the 1st physical device unless
     * TL_LEAVE_BINARY_AREA is specified (which means to keep bootimage area
     * size as is.
     */

	if (!(formatParams->flags & TL_LEAVE_BINARY_AREA))
    {
       formatParams->bootImageLen = (long) 0;
#ifdef WRITE_EXB_IMAGE
       formatParams->exbLen = 0;
#endif /* WRITE_EXB_IMAGE */
       formatParams->noOfBinaryPartitions = 0;
    }

    /*
     * Do flash recognition and format for devices #1 .. (mvol.noOfSockets - 1).
     * First call flIdentifyFlash() to find MTD, then try all TLs registered
     * in tlTable[]. Assume MTL is in tlTable[0], so skip it. Skip all the
     * TL filters as well.
     */

	for (iDev = 1;  iDev < noOfSockets;  iDev++) {

    	socket = flSocketOf (iDev);

    	status = flIdentifyFlash (socket, &tmpFlash);
    	if ((status != flOK) && (status != flUnknownMedia)) {
        	DEBUG_PRINT(("Debug: no MTD recognized the device, MTL format aborted.\n"));
        	return status;
        }
    	mtlProgressCallback(0,0xffff); /* Initialize new device is being formated */
    	status = flUnknownMedia;
    	for (iTL = 1;  (iTL < mvol.noOfTLs) && (status == flUnknownMedia);  iTL++)
        {
        	if (tlTable[iTL].formatRoutine == NULL)  /* TL filter */
               continue;
        	status = tlTable[iTL].formatRoutine (iDev, formatParams, &tmpFlash);
        }
    	if (status != flOK)
        {
        	DEBUG_PRINT(("Debug: no TL recognized the device, MTL format aborted.\n"));
        	return status;
        }
    }   /* for(iDev) */

    DEBUG_PRINT(("Debug: MTL format succeeded.\n"));

    return flOK;
}

#endif /* FORMAT_VOLUME */


/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                        f l m t l U n i n s t a l l                         *
 *                                                                            *
 *  Removes MTL from the TL table.                                            *
 *                                                                            *
 *  Note: Must be called after the medium was dismounted.                     *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      none                                                                  *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

FLStatus  flmtlUninstall (void)
{
    int iTL;

	if (noOfTLs > 0)
    {
        /* search for MTL in tlTable[] */

    	for (iTL = 0;  iTL < mvol.noOfTLs;  iTL++)
        {
        	if (tlTable[iTL].mountRoutine == mtlMount)
            	break;
        }

    	if (iTL < mvol.noOfTLs)
        {

           /* MTL is found in tlTable[iTL], so remove it */

           for (;  iTL < (mvol.noOfTLs - 1);  iTL ++)
           {
            	tlTable[iTL].mountRoutine  = tlTable[iTL + 1].mountRoutine;
            	tlTable[iTL].formatRoutine = tlTable[iTL + 1].formatRoutine;
           }

           tlTable[mvol.noOfTLs - 1].mountRoutine    = NULL;
           tlTable[mvol.noOfTLs - 1].formatRoutine   = NULL;
           tlTable[mvol.noOfTLs - 1].preMountRoutine = NULL;

           noOfTLs    = mvol.noOfTLs - 1;
           noOfDrives = mvol.noOfDrives;
        }
    }

	return flOK;
}


/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                         f l m t l I n s t a l l                            *
 *                                                                            *
 *  If MTL is found in TL table, it is moved into 1st slot (i.e. effectively  *
 *  enabled). If MTL isn't found in TL table, it is installed into 1st slot.  *
 *  The TL does not increament the number of TL (noOfTLs) global variable,    *
 *  but changes it to 1, therfore reporting it as the only registered TL.     *
 *                                                                            *
 *  Note : The install routine should be the last TL to be regitered.         *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      none                                                                  *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

FLStatus  flmtlInstall (void)
{
    int iTL;

	if (noOfTLs > 0)
    {
       checkStatus( flmtlUninstall() ); /* Dismount previous MTL if exists */

       /* Save number of registered TLs and number of volumes */

       mvol.noOfTLs    = noOfTLs;
       mvol.noOfDrives = noOfDrives;

       /* search for MTL in tlTable[] */

       for (iTL = 0;  iTL < noOfTLs;  iTL++)
       {
           if (tlTable[iTL].mountRoutine == mtlMount)
           break;
       }

       if (iTL >= noOfTLs) /* MTL is not found in tlTable[iTL] */
       {
          /* MTL isn't in tlTable[], we will be adding it */

          if (noOfTLs >= TLS)
          {
             DEBUG_PRINT(("Debug: can't install MTL, too many TLs.\n"));
             return flTooManyComponents;
          }
          iTL = noOfTLs;
          mvol.noOfTLs++;
       }
       else
       {
          /* MTL is found in tlTable[iTL] */
       }

       /* free the 1st slot in tlTable[] for MTL */

       while (iTL >= 1)
       {
          tlTable[iTL].mountRoutine  = tlTable[iTL - 1].mountRoutine;
          tlTable[iTL].formatRoutine = tlTable[iTL - 1].formatRoutine;
          iTL--;
       }
    }
    else
    {
       /* No other TL registered so return error code */

       return flMultiDocContrediction;
    }

    /* Make system believe that only MTL is registered */

	noOfTLs    = 1;
    noOfDrives = 1;

    /* put MTL in the 1st slot in tlTable[] */

	tlTable[0].mountRoutine     = mtlMount;
	tlTable[0].preMountRoutine  = mtlPreMount;
#ifdef FORMAT_VOLUME
	tlTable[0].formatRoutine = mtlFormat;
#else
	tlTable[0].formatRoutine = noFormat;
#endif

	return flOK;
}


/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                        f l R e g i s t e r M T L                           *
 *                                                                            *
 *  Standard TL's component registration routine.                             *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      none                                                                  *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

FLStatus  flRegisterMTL (void)
{
    checkStatus( flmtlInstall() );

    return flOK;
}

/* Physical routines are not a part of TrueFFS code */

#if 0
/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                        m t l R e a d B B T                                 *
 *                                                                            *
 *  TL's standard 'read bad blocks table' routine.                            *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      pvol                : Pointer identifying drive                       *
 *      buf                 : Pointer to user buffer to read BB info to       *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *      mediaSize           : Size of the formated media                      *
 *      noOfBB              : Total number of bad blocks read                 *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlReadBBT (MTL *pvol, byte FAR1 * buf,
                 long FAR2 * mediaSize, unsigned FAR2 * noOfBB)

{
    CardAddress addressShift=0;
    long bufOffset = 0;
    unsigned tmpCounter;
    long tmpMediaSize;
    byte iDev;

    /* check 'pvol' for sanity */

    if (pvol != &mvol)
        return flBadDriveHandle;

    /* Read bbt of each device while incrementing the address simulating a
     * big physical device */

    *mediaSize = 0;
    *noOfBB    = 0;
    for (iDev = 0;  iDev < noOfSockets;  iDev++)
    {
       checkStatus(mpT(pvol,iDev).readBBT(mpT(pvol,iDev).rec,
                  (byte FAR1 *)flAddLongToFarPointer(buf,bufOffset),
          &tmpMediaSize,&tmpCounter));
       *noOfBB += tmpCounter; /* Global BB counter */
       for (;tmpCounter>0;tmpCounter--,bufOffset+=sizeof(CardAddress))
       {
      *((CardAddress *)(buf + bufOffset)) += addressShift;
       }
       addressShift += mP(iDev);
       *mediaSize   += tmpMediaSize;
    }
    return flOK;
}

/* -------------------------------------------------------------------------- *
 *                                                                            *
 *                           m t l W r i t e B B T                            *
 *                                                                            *
 *  TL's write Bad Blocks Table routine.                                      *
 *                                                                            *
 *  Parameters :                                                              *
 *                                                                            *
 *      ioreq                : pointer to the structure containing i\o fields *
 *                                                                            *
 *  Returns :                                                                 *
 *                                                                            *
 *      flOK on success, otherwise respective error code.                     *
 *                                                                            *
 * -------------------------------------------------------------------------- */

static FLStatus  mtlWriteBBT(IOreq FAR2* ioreq)
{
    FLSocket    *socket;
    FLStatus    status;
    FLFlash     tmpFlash;
    CardAddress endUnit;
    CardAddress lastDriveAddress;
    CardAddress nextDriveAddress = 0;
    CardAddress iUnit;
    CardAddress bUnit;
	CardAddress endAddress;
    byte        iDev;
    word        badBlockNo=0;
    byte        zeroes[2] = {0,0};

    /* Initlize last erase address according to argument */

    tffsset(&endAddress,0xff,sizeof(CardAddress));
    if (ioreq->irLength == 0)
    {
        tffsset(&endAddress,0xff,sizeof(CardAddress));
    }
    else
    {
        endAddress = ioreq->irLength;
    }

    /*
     * Do flash recognition while storing physical size of devices
     * #0 .. (mvol.noOfSockets - 1). First call flIdentifyFlash() to find
     * MTD, then erase the media while marking bad blocks. Note that the
     * addresses are physical addresses of the virtual multi-doc. The address
     * should be subtructed by the physical size of the previous devices.
     */

    for (iDev = 0;  iDev < noOfSockets;  iDev++)
    {
        socket = flSocketOf (iDev);

        /* Identify */
        status = flIdentifyFlash (socket, &tmpFlash);
        if ((status != flOK) && (status != flUnknownMedia))
        {
           DEBUG_PRINT(("Debug: no MTD recognized the device, MTL writeBBT aborted.\n"));
           return status;
        }

        /* Initialize new drive boundry variables */

        mP(iDev) = (dword)(tmpFlash.chipSize * tmpFlash.noOfChips);
        lastDriveAddress = nextDriveAddress;
        nextDriveAddress += mP(iDev);
        endUnit = mP(iDev) >> tmpFlash.erasableBlockSizeBits;
        bUnit = ((*((CardAddress FAR1 *)flAddLongToFarPointer
                 (ioreq->irData,badBlockNo*sizeof(CardAddress)))) -
                 lastDriveAddress) >> tmpFlash.erasableBlockSizeBits;

        /* Erase entire media */

        for (iUnit = 0 ,badBlockNo = 0; iUnit < endUnit ; iUnit++)
        {
           if ((iUnit << tmpFlash.erasableBlockSizeBits) + lastDriveAddress >= endAddress)
               return flOK;
           tmpFlash.erase(&tmpFlash,iUnit,1);

           if (ioreq->irFlags > badBlockNo)
           {
              if (bUnit == iUnit)
              {
                 tmpFlash.write(&tmpFlash,bUnit <<
                               tmpFlash.erasableBlockSizeBits,zeroes,2,0);
                 badBlockNo++;
         bUnit = ((*((CardAddress FAR1 *)flAddLongToFarPointer
             (ioreq->irData,badBlockNo*sizeof(CardAddress)))) -
             lastDriveAddress) >> tmpFlash.erasableBlockSizeBits;
          }
       }
    }
    }
    return flOK;
}
#endif /* 0 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flsocket.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLSOCKET.C_V  $
 * 
 *    Rev 1.11   Apr 15 2002 07:37:04   oris
 * Added support for VERIFY_ERASED_SECTOR compilation flag.
 * 
 *    Rev 1.10   Jan 17 2002 23:02:12   oris
 * Removed SINGLE_BUFFER compilation flag
 * Made sure buffers are allocated when VERIFY_VOLUME and  MTD_RECONSTRUCT_BBT are defined
 * Set socket verify write mode according to environment variable
 * Verify write buffers are allocated according to define and not runtime  variable.
 * Added flReadBackBufferOf returning pointer to the readback buffer.
 * 
 *    Rev 1.9   Nov 21 2001 11:38:42   oris
 * Changed FL_WITH_VERIFY_WRITE and FL_WITHOUT_VERIFY_WRITE to FL_ON and  FL_OFF.
 * 
 *    Rev 1.8   Nov 08 2001 10:49:30   oris
 * Added run-time contorll over verify write mode buffers.
 * 
 *    Rev 1.7   Jul 13 2001 01:05:36   oris
 * Add allocation for read back buffer.
 * 
 *    Rev 1.6   May 16 2001 21:19:16   oris
 * Added the FL_ prefix to the following defines: ON , OFF, MALLOC and FREE.
 * 
 *    Rev 1.5   Apr 10 2001 16:42:16   oris
 * Bug fix - DiskOnChip socket routines clashed with pccards socket 
 * routines. Moved all DiskOnChip socket routines to docsoc.c.
 * 
 *    Rev 1.4   Apr 09 2001 15:09:38   oris
 * End with an empty line.
 * 
 *    Rev 1.3   Apr 01 2001 07:55:04   oris
 * copywrite notice.
 * Removed defaultSocketParams routine due to a conflict in windows CE.
 * Aliggned left all # directives.
 * 
 *    Rev 1.2   Feb 14 2001 01:58:46   oris
 * Changed defaultUpdateSocketParameters prototype.
 *
 *    Rev 1.1   Feb 12 2001 12:14:06   oris
 * Added support for updateSocketParams (retreave FLSocket record)
 *
 *    Rev 1.0   Feb 04 2001 14:17:16   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#include "flsocket.h"

byte noOfSockets = 0;        /* No. of drives actually registered */

static FLSocket vols[SOCKETS];

#ifdef FL_MALLOC
static FLBuffer *volBuffers[SOCKETS];
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
static byte* readBackBuffer[SOCKETS];
#endif /* VERIFY_WRITE || VERIFY_ERASE || VERIFY_VOLUME || MTD_RECONSTRUCT_BBT || VERIFY_ERASED_SECTOR */

#else
static FLBuffer volBuffers[SOCKETS];
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
static byte readBackBuffer[SOCKETS][READ_BACK_BUFFER_SIZE];
#endif /* VERIFY_WRITE || VERIFY_ERASE || VERIFY_VOLUME || MTD_RECONSTRUCT_BBT || VERIFY_ERASED_SECTOR */
#endif /* FL_MALLOC */

/*----------------------------------------------------------------------*/
/*                        f l S o c k e t N o O f                       */
/*                                                                      */
/* Gets the volume no. connected to a socket                            */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/* Returns:                                                             */
/*         volume no. of socket                                         */
/*----------------------------------------------------------------------*/

unsigned flSocketNoOf(const FLSocket vol)
{
  return vol.volNo;
}


/*----------------------------------------------------------------------*/
/*                        f l S o c k e t O f                           */
/*                                                                      */
/* Gets the socket connected to a volume no.                            */
/*                                                                      */
/* Parameters:                                                          */
/*        volNo                : Volume no. for which to get socket     */
/*                                                                      */
/* Returns:                                                             */
/*         socket of volume no.                                         */
/*----------------------------------------------------------------------*/

FLSocket *flSocketOf(unsigned volNo)
{
  return &vols[volNo];
}


/*----------------------------------------------------------------------*/
/*                        f l B u f f e r O f                           */
/*                                                                      */
/* Gets the buffer connected to a volume no.                            */
/*                                                                      */
/* Parameters:                                                          */
/*        volNo                : Volume no. for which to get socket     */
/*                                                                      */
/* Returns:                                                             */
/*         buffer of volume no.                                         */
/*----------------------------------------------------------------------*/

FLBuffer *flBufferOf(unsigned volNo)
{
#ifdef FL_MALLOC
  return volBuffers[volNo];
#else
  return &volBuffers[volNo];
#endif
}

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT) || defined(VERIFY_VOLUME) || defined (VERIFY_ERASED_SECTOR))
/*----------------------------------------------------------------------*/
/*                        f l R e a d B a c k B u f f e r O f           */
/*                                                                      */
/* Gets the read back buffer connected to a volume no.                  */
/*                                                                      */
/* Parameters:                                                          */
/*        volNo                : Volume no. for which to get socket     */
/*                                                                      */
/* Returns:                                                             */
/*         buffer of volume no.                                         */
/*----------------------------------------------------------------------*/

byte * flReadBackBufferOf(unsigned volNo)
{
#ifdef FL_MALLOC
  return readBackBuffer[volNo];
#else
  return &(readBackBuffer[volNo][0]);
#endif
}
#endif /* VERIFY_WRITE || VERIFY_ERASE || VERIFY_VOLUME || MTD_RECONSTRUCT_BBT || VERIFY_ERASED_SECTOR */

/*----------------------------------------------------------------------*/
/*                      f l W r i t e P r o t e c t e d                 */
/*                                                                      */
/* Returns the write-protect state of the media                         */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/* Returns:                                                             */
/*        0 = not write-protected, other = write-protected              */
/*----------------------------------------------------------------------*/

FLBoolean flWriteProtected(FLSocket vol)
{
  return vol.writeProtected(&vol);
}


#ifndef FIXED_MEDIA

/*----------------------------------------------------------------------*/
/*                    f l R e s e t C a r d C h a n g e d               */
/*                                                                      */
/* Acknowledges a media-change condition and turns off the condition.   */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flResetCardChanged(FLSocket vol)
{
  if (vol.getAndClearCardChangeIndicator)
      vol.getAndClearCardChangeIndicator(&vol);  /* turn off the indicator */

  vol.cardChanged = FALSE;
}


/*----------------------------------------------------------------------*/
/*                        f l M e d i a C h e c k                       */
/*                                                                      */
/* Checks the presence and change status of the media                   */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/* Returns:                                                             */
/*         flOK                ->        Media present and not changed  */
/*        driveNotReady   ->        Media not present                   */
/*        diskChange        ->        Media present but changed         */
/*----------------------------------------------------------------------*/

FLStatus flMediaCheck(FLSocket vol)
{
  if (!vol.cardDetected(&vol)) {
    vol.cardChanged = TRUE;
    return flDriveNotReady;
  }

  if (vol.getAndClearCardChangeIndicator &&
      vol.getAndClearCardChangeIndicator(&vol))
    vol.cardChanged = TRUE;

  return vol.cardChanged ? flDiskChange : flOK;
}

#endif

/*----------------------------------------------------------------------*/
/*                   f l G e t M a p p i n g C o n t e x t              */
/*                                                                      */
/* Returns the currently mapped window page (in 4KB units)              */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/* Returns:                                                             */
/*        unsigned int        : Current mapped page no.                 */
/*----------------------------------------------------------------------*/

unsigned flGetMappingContext(FLSocket vol)
{
  return vol.window.currentPage;
}


/*----------------------------------------------------------------------*/
/*                              f l M a p                               */
/*                                                                      */
/* Maps the window to a specified card address and returns a pointer to */
/* that location (some offset within the window).                       */
/*                                                                      */
/* NOTE: Addresses over 128M are attribute memory. On PCMCIA adapters,  */
/* subtract 128M from the address and map to attribute memory.          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol         : Pointer identifying drive                         */
/*      address     : Byte-address on card. NOT necessarily on a        */
/*                    full-window boundary.                             */
/*                    If above 128MB, address is in attribute space.    */
/*                                                                      */
/* Returns:                                                             */
/*        Pointer to a location within the window mapping the address.  */
/*----------------------------------------------------------------------*/

void FAR0 *flMap(FLSocket vol, CardAddress address)
{
  unsigned pageToMap;

  if (vol.window.currentPage == UNDEFINED_MAPPING)
    vol.setWindow(&vol);
  pageToMap = (unsigned) ((address & -vol.window.size) >> 12);

  if (vol.window.currentPage != pageToMap) {
    vol.setMappingContext(&vol, pageToMap);
    vol.window.currentPage = pageToMap;
    vol.remapped = TRUE;        /* indicate remapping done */
  }

  return addToFarPointer(vol.window.base,address & (vol.window.size - 1));
}


/*----------------------------------------------------------------------*/
/*                    f l S e t W i n d o w B u s W i d t h             */
/*                                                                      */
/* Requests to set the window bus width to 8 or 16 bits.                */
/* Whether the request is filled depends on hardware capabilities.      */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*      width                : Requested bus width                      */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flSetWindowBusWidth(FLSocket vol, unsigned width)
{
  vol.window.busWidth = width;
  vol.window.currentPage = UNDEFINED_MAPPING;        /* force remapping */
}


/*----------------------------------------------------------------------*/
/*                   f l S e t W i n d o w S p e e d                    */
/*                                                                      */
/* Requests to set the window speed to a specified value.               */
/* The window speed is set to a speed equal or slower than requested,   */
/* if possible in hardware.                                             */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*      nsec                : Requested window speed in nanosec.        */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flSetWindowSpeed(FLSocket vol, unsigned nsec)
{
  vol.window.speed = nsec;
  vol.window.currentPage = UNDEFINED_MAPPING;        /* force remapping */
}


/*----------------------------------------------------------------------*/
/*                    f l S e t W i n d o w S i z e                     */
/*                                                                      */
/* Requests to set the window size to a specified value (power of 2).   */
/* The window size is set to a size equal or greater than requested,    */
/* if possible in hardware.                                             */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*      sizeIn4KBUnits : Requested window size in 4 KByte units.        */
/*                         MUST be a power of 2.                        */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flSetWindowSize(FLSocket vol, unsigned sizeIn4KBunits)
{
  vol.window.size = (long) (sizeIn4KBunits) * 0x1000L;
        /* Size may not be possible. Actual size will be set by 'setWindow' */
  vol.window.base = physicalToPointer((long) vol.window.baseAddress << 12,
                                      vol.window.size,vol.volNo);
  vol.window.currentPage = UNDEFINED_MAPPING;        /* force remapping */
}


/*----------------------------------------------------------------------*/
/*                   f l S o c k e t S e t B u s y                      */
/*                                                                      */
/* Notifies the start and end of a file-system operation.               */
/*                                                                      */
/* Parameters:                                                          */
/*        vol      : Pointer identifying drive                          */
/*      state      : FL_ON (1) = operation entry                        */
/*                   FL_OFF(0) = operation exit                         */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flSocketSetBusy(FLSocket vol, FLBoolean state)
{
  if (state == FL_OFF) 
  {
#if POLLING_INTERVAL == 0
    /* If we are not polling, activate the interval routine before exit */
    flIntervalRoutine(&vol);
#endif
  }
  else 
  {
    /* Set verify write operation to this socket */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
    if(flVerifyWrite[vol.volNo][vol.curPartition] == FL_ON)
    {
       vol.verifyWrite = FL_ON;
    }
    else
    {
       vol.verifyWrite = FL_OFF;
    }
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
    vol.window.currentPage = UNDEFINED_MAPPING;        /* don't assume mapping still valid */
#ifdef FIXED_MEDIA
    vol.remapped = TRUE;
#endif /* FIXED_MEDIA */
  }
}


/*----------------------------------------------------------------------*/
/*                          f l N e e d V c c                           */
/*                                                                      */
/* Turns on Vcc, if not on already                                      */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, failed otherwise              */
/*----------------------------------------------------------------------*/

void flNeedVcc(FLSocket vol)
{
  vol.VccUsers++;
  if (vol.VccState == PowerOff) {
    vol.VccOn(&vol);
    if (vol.powerOnCallback)
      vol.powerOnCallback(vol.flash);
  }
  vol.VccState = PowerOn;
}


/*----------------------------------------------------------------------*/
/*                       f l D o n t N e e d V c c                      */
/*                                                                      */
/* Notifies that Vcc is no longer needed, allowing it to be turned off. */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flDontNeedVcc(FLSocket vol)
{
  if (vol.VccUsers > 0)
    vol.VccUsers--;
}

#ifdef SOCKET_12_VOLTS

/*----------------------------------------------------------------------*/
/*                          f l N e e d V p p                           */
/*                                                                      */
/* Turns on Vpp, if not on already                                      */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus        : 0 on success, failed otherwise              */
/*----------------------------------------------------------------------*/

FLStatus flNeedVpp(FLSocket vol)
{
  vol.VppUsers++;
  if (vol.VppState == PowerOff)
    checkStatus(vol.VppOn(&vol));
  vol.VppState = PowerOn;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                       f l D o n t N e e d V p p                      */
/*                                                                      */
/* Notifies that Vpp is no longer needed, allowing it to be turned off. */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flDontNeedVpp(FLSocket vol)
{
  if (vol.VppUsers > 0)
    vol.VppUsers--;
}

#endif        /* SOCKET_12_VOLTS */


/*----------------------------------------------------------------------*/
/*                  f l S e t P o w e r O n C a l l b a c k             */
/*                                                                      */
/* Sets a routine address to call when powering on the socket.          */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*      routine                : Routine to call when turning on power  */
/*        flash                : Flash object of routine                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flSetPowerOnCallback(FLSocket vol, void (*routine)(void *flash), void *flash)
{
  vol.powerOnCallback = routine;
  vol.flash = flash;
}



/*----------------------------------------------------------------------*/
/*                    f l I n t e r v a l R o u t i n e                 */
/*                                                                      */
/* Performs periodic socket actions: Checks card presence, and handles  */
/* the Vcc & Vpp turn off mechanisms.                                   */
/*                                                                      */
/* The routine may be called from the interval timer or sunchronously.  */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flIntervalRoutine(FLSocket vol)
{
#ifndef FIXED_MEDIA
  if (vol.getAndClearCardChangeIndicator == NULL &&
      !vol.cardChanged)
    if (!vol.cardDetected(&vol))        /* Check that the card is still there */
      vol.cardChanged = TRUE;
#endif

  if (vol.VppUsers == 0) {
    if (vol.VppState == PowerOn)
      vol.VppState = PowerGoingOff;
    else if (vol.VppState == PowerGoingOff) {
      vol.VppState = PowerOff;
#ifdef SOCKET_12_VOLTS
      vol.VppOff(&vol);
#endif
    }
    if (vol.VccUsers == 0) {
      if (vol.VccState == PowerOn)
        vol.VccState = PowerGoingOff;
      else if (vol.VccState == PowerGoingOff) {
        vol.VccState = PowerOff;
        vol.VccOff(&vol);
      }
    }
  }
}

/*----------------------------------------------------------------------*/
/*                       u d a t e S o c k e t P a r a m e t e r s      */
/*                                                                      */
/* Pass socket parameters to the socket interface layer.                */
/* This function should be called after the socket parameters (like     */
/* size and base) are known. If these parameters are known at           */
/* registration time then there is no need to use this function, and    */
/* the parameters can be passed to the registration routine.            */
/* The structure passed in irData is specific for each socket interface.*/
/*                                                                      */
/* Note : When using DiskOnChip this routine returns the socekt         */
/*        parameters instead of initialiaing them.                      */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*  params  : Record returning (or sending) the flsocket record         */
/*                                                                      */
/* Returns:                                                             */
/*        FLStatus         : 0 on success                               */
/*----------------------------------------------------------------------*/
FLStatus updateSocketParameters(FLSocket vol, void FAR1 *params)
{
  if (vol.updateSocketParams)
    vol.updateSocketParams(&vol, params);

  return flOK;
}


#ifdef EXIT
/*----------------------------------------------------------------------*/
/*                    f l E x i t S o c k e t                           */
/*                                                                      */
/* Reset the socket and free resources that were allocated for this     */
/* socket.                                                              */
/* This function is called when FLite exits.                            */
/*                                                                      */
/* Parameters:                                                          */
/*        vol                : Pointer identifying drive                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void flExitSocket(FLSocket vol)
{
  flMap(&vol, 0);                           /* reset the mapping register */
  flDontNeedVcc(&vol);
  flSocketSetBusy(&vol,FL_OFF);
  vol.freeSocket(&vol);                     /* free allocated resources */
#ifdef FL_MALLOC
  FL_FREE(volBuffers[vol.volNo]);
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  FL_FREE(readBackBuffer[vol.volNo]);
#endif /* VERIFY_WRITE || VERIFY_ERASE || VERIFY_VOLUME || MTD_RECONSTRUCT_BBT || VERIFY_ERASED_SECTOR */
#endif /* FL_MALLOC */
}
#endif /* EXIT */

/*-----------------------------------------------------------------------*/
/*                       f l I n i t S o c k e t s                       */
/*                                                                       */
/* First call to this module: Initializes the controller and all sockets */
/*                                                                       */
/* Parameters:                                                           */
/*        vol                : Pointer identifying drive                 */
/*                                                                       */
/* Returns:                                                              */
/*        FLStatus        : 0 on success, failed otherwise               */
/*---_-------------------------------------------------------------------*/

FLStatus flInitSockets(void)
{
  unsigned volNo;
  FLSocket vol = vols;

  for (volNo = 0; volNo < noOfSockets; volNo++, pVol++) {
    flSetWindowSpeed(&vol, 250);
    flSetWindowBusWidth(&vol, 16);
    flSetWindowSize(&vol, 2);                /* make it 8 KBytes */

    vol.cardChanged = FALSE;

#ifdef FL_MALLOC
    /* allocate buffer for this socket */
    volBuffers[volNo] = (FLBuffer *)FL_MALLOC(sizeof(FLBuffer));
    if (volBuffers[volNo] == NULL) {
      DEBUG_PRINT(("Debug: failed allocating sector buffer.\r\n"));
      return flNotEnoughMemory;
    }
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
    /* allocate read back buffer for this socket */
    readBackBuffer[volNo] = (byte *)FL_MALLOC(READ_BACK_BUFFER_SIZE);
    if (readBackBuffer[volNo] == NULL) {
       DEBUG_PRINT(("Debug: failed allocating readBack buffer.\r\n"));
       return flNotEnoughMemory;
    }
#endif /* VERIFY_WRITE || VERIFY_ERASE || MTD_READ_BBT || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
#endif /* FL_MALLOC */

    checkStatus(vol.initSocket(&vol));

#ifdef SOCKET_12_VOLTS
    vol.VppOff(&vol);
    vol.VppState = PowerOff;
    vol.VppUsers = 0;
#endif
    vol.VccOff(&vol);
    vol.VccState = PowerOff;
    vol.VccUsers = 0;
  }

  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\i28f016.c ===
/*
 * $Log:   P:/user/amir/lite/vcs/i28f016.c_v  $
 *
 *    Rev 1.10	 06 Oct 1997  9:45:48	danig
 * VPP functions under #ifdef
 *
 *    Rev 1.9	10 Sep 1997 16:48:24   danig
 * Debug messages & got rid of generic names
 *
 *    Rev 1.8	31 Aug 1997 15:09:20   danig
 * Registration routine return status
 *
 *    Rev 1.7	24 Jul 1997 17:52:58   amirban
 * FAR to FAR0
 *
 *    Rev 1.6	20 Jul 1997 17:17:06   amirban
 * No watchDogTimer
 *
 *    Rev 1.5	07 Jul 1997 15:22:08   amirban
 * Ver 2.0
 *
 *    Rev 1.4	04 Mar 1997 16:44:22   amirban
 * Page buffer bug fix
 *
 *    Rev 1.3	18 Aug 1996 13:48:24   amirban
 * Comments
 *
 *    Rev 1.2	12 Aug 1996 15:49:04   amirban
 * Added suspend/resume
 *
 *    Rev 1.1	31 Jul 1996 14:30:50   amirban
 * Background stuff
 *
 *    Rev 1.0	18 Jun 1996 16:34:30   amirban
 * Initial revision.
 */

/************************************************************************/
/*									*/
/*		FAT-FTL Lite Software Development Kit			*/
/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
/*									*/
/************************************************************************/

/*----------------------------------------------------------------------*/
/*									*/
/* This MTD supports the following Flash technologies:			*/
/*									*/
/* - Intel 28F016SA/28016SV/Cobra 16-mbit devices			*/
/*									*/
/* And (among else), the following Flash media and cards:		*/
/*									*/
/* - Intel Series-2+ PCMCIA cards					*/
/*									*/
/*----------------------------------------------------------------------*/

#include "flflash.h"
#ifdef FL_BACKGROUND
#include "backgrnd.h"
#endif

/* JEDEC ids for this MTD */
#define I28F016_FLASH	0x89a0
#define LH28F016SU_FLASH 0xB088

#define SETUP_ERASE	0x2020
#define SETUP_WRITE	0x4040
#define CLEAR_STATUS	0x5050
#define READ_STATUS	0x7070
#define READ_ID 	0x9090
#define SUSPEND_ERASE	0xb0b0
#define CONFIRM_ERASE	0xd0d0
#define RESUME_ERASE	0xd0d0
#define READ_ARRAY	0xffff

#define LOAD_PAGE_BUFFER 0xe0e0
#define WRITE_PAGE_BUFFER 0x0c0c
#define READ_EXTENDED_REGS 0x7171

#define WSM_VPP_ERROR	0x08
#define WSM_ERROR	0x38
#define WSM_SUSPENDED	0x40
#define WSM_READY	0x80

#define GSR_ERROR	0x20

#define both(word)	(vol.interleaving == 1 ? tffsReadWordFlash(word) : tffsReadWordFlash(word) & (tffsReadWordFlash(word) >> 8))
#define any(word)	(tffsReadWordFlash(word) | (tffsReadWordFlash(word) >> 8))

/*----------------------------------------------------------------------*/
/*		      i 2 8 f 0 1 6 W o r d S i z e			*/
/*									*/
/* Identify the card size for an Intel 28F016 word-mode Flash array.	*/
/* Sets the value of vol.noOfChips.					*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 = OK, otherwise failed (invalid Flash array)*/
/*----------------------------------------------------------------------*/

FLStatus i28f016WordSize(FLFlash vol)
{
  FlashWPTR flashPtr = (FlashWPTR) flMap(vol.socket,0);
  unsigned short id0, id1;

  tffsWriteWordFlash(flashPtr, CLEAR_STATUS);
  tffsWriteWordFlash(flashPtr, READ_ID);
  /* We leave the first chip in Read ID mode, so that we can		*/
  /* discover an address wraparound.					*/
  if( vol.type == I28F016_FLASH ) {
    id0 = 0x0089;
    id1 = 0x66a0;
  }
  else if( vol.type == LH28F016SU_FLASH ) {
    id0 = 0x00B0;
    id1 = 0x6688;
  }

  for (vol.noOfChips = 1;	/* Scan the chips */
       vol.noOfChips < 2000;  /* Big enough ? */
       vol.noOfChips++) {
    flashPtr = (FlashWPTR) flMap(vol.socket,vol.noOfChips * vol.chipSize);

    if (tffsReadWordFlash(flashPtr) == id0 && tffsReadWordFlash(flashPtr + 1) == id1)
      break;	  /* We've wrapped around to the first chip ! */

    tffsWriteWordFlash(flashPtr, READ_ID);
    if (!(tffsReadWordFlash(flashPtr) == id0 && tffsReadWordFlash(flashPtr + 1) == id1))
      break;
    tffsWriteWordFlash(flashPtr, CLEAR_STATUS);
    tffsWriteWordFlash(flashPtr, READ_ARRAY);
  }

  flashPtr = (FlashWPTR) flMap(vol.socket,0);
  tffsWriteWordFlash(flashPtr, READ_ARRAY);

  return flOK;
}


/*----------------------------------------------------------------------*/
/*			i 2 8 f 0 1 6 W r i t e 			*/
/*									*/
/* Write a block of bytes to Flash					*/
/*									*/
/* This routine will be registered as the MTD flash.write routine	*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	address 	: Card address to write to			*/
/*	buffer		: Address of data to write			*/
/*	length		: Number of bytes to write			*/
/*	overwrite	: TRUE if overwriting old Flash contents	*/
/*			  FALSE if old contents are known to be erased	*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

FLStatus i28f016Write(FLFlash vol,
			   CardAddress address,
			   const VOID FAR1 *buffer,
			   dword length,
			   word overwrite)
{
  /* Set timeout of 5 seconds from now */
  ULONG writeTimeout = flMsecCounter + 5000;

  FLStatus status = flOK;
  FlashWPTR flashPtr;
  ULONG maxLength, i, from;
  UCHAR * bBuffer = (UCHAR *) buffer;
  FlashPTR bFlashPtr;
  ULONG * dBuffer = (ULONG *) buffer;
  FlashDPTR dFlashPtr;

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

  if ((length & 1) || (address & 1))	/* Only write words on word-boundary */
    return flBadParameter;

#ifdef SOCKET_12_VOLTS
  checkStatus(flNeedVpp(vol.socket));
#endif

  maxLength = 256 * vol.interleaving;
  for (from = 0; from < length && status == flOK; from += maxLength) {
    FlashWPTR currPtr;
    ULONG lengthWord;
    ULONG tailBytes;
    ULONG thisLength = length - from;

    if (thisLength > maxLength)
      thisLength = maxLength;
    lengthWord = (thisLength + vol.interleaving - 1) /
		 (vol.interleaving == 1 ? 2 : vol.interleaving) - 1;
    if (vol.interleaving != 1)
      lengthWord |= (lengthWord << 8);
    flashPtr = (FlashWPTR) flMap(vol.socket,address + from);

    tailBytes = ((thisLength - 1) & (vol.interleaving - 1)) + 1;
    for (i = 0, currPtr = flashPtr;
	 i < (ULONG)vol.interleaving && i < thisLength;
	 i += 2, currPtr++) {
      tffsWriteWordFlash(currPtr, LOAD_PAGE_BUFFER);
      if (i < tailBytes) {
	tffsWriteWordFlash(currPtr, (USHORT) lengthWord);
      }
      else {
	tffsWriteWordFlash(currPtr, (USHORT) (lengthWord - 1));
      }
      tffsWriteWordFlash(currPtr, 0);
    }

    dFlashPtr = (FlashDPTR) flashPtr;
    bFlashPtr = (FlashPTR) flashPtr;
    for (i = 0; i < thisLength - 4; i += 4) {
	tffsWriteDwordFlash(dFlashPtr + i, *(dBuffer + from + i));
    }
    for(; i < thisLength; i++) {
	tffsWriteByteFlash(bFlashPtr + i, *(bBuffer + from + i));
    }

    for (i = 0, currPtr = flashPtr;
	 i < (ULONG)vol.interleaving && i < thisLength;
	 i += 2, currPtr++) {
      tffsWriteWordFlash(currPtr, WRITE_PAGE_BUFFER);
      if (!((address + from + i) & vol.interleaving)) {
	/* Even address */
	tffsWriteWordFlash(currPtr, (USHORT) lengthWord);
	tffsWriteWordFlash(currPtr, 0);
      }
      else {
	/* Odd address */
	tffsWriteWordFlash(currPtr, 0);
	tffsWriteWordFlash(currPtr, (USHORT) lengthWord);
      }

    }

    /* map to the GSR & BSR */
    flashPtr = (FlashWPTR) flMap(vol.socket,
			       (CardAddress)( (address + from & -(int)vol.erasableBlockSize) +
			       4 * vol.interleaving));

    for (i = 0, currPtr = flashPtr;
	 i < (ULONG)vol.interleaving && i < thisLength;
	 i += 2, currPtr++) {
      tffsWriteWordFlash(currPtr, READ_EXTENDED_REGS);
      while (!(both(currPtr) & WSM_READY) && flMsecCounter < writeTimeout)
	    ;
      if ((any(currPtr) & GSR_ERROR) || !(both(currPtr) & WSM_READY)) {
	DEBUG_PRINT(("Debug: write failed for 16-bit Intel media.\n"));
	status = flWriteFault;
	tffsWriteWordFlash(currPtr, CLEAR_STATUS);
      }
      tffsWriteWordFlash(currPtr, READ_ARRAY);
    }
  }

#ifdef SOCKET_12_VOLTS
  flDontNeedVpp(vol.socket);
#endif

  /* verify the data */
  dFlashPtr = (FlashDPTR) flMap(vol.socket, address);
  dBuffer = (ULONG *) buffer;

  if (status == flOK) {
    /* compare double words */
    for (;length >= 4; length -= 4, dFlashPtr++, dBuffer++) {
	if (tffsReadDwordFlash(dFlashPtr) != *dBuffer) {
	    DEBUG_PRINT(("Debug: write failed for 16-bit Intel media in verification.\n"));
	return flWriteFault;
	}
    }

    /* compare the last bytes */
    bFlashPtr = (FlashPTR) dFlashPtr;
    bBuffer = (UCHAR *)dBuffer;
    for (; length; length--, bFlashPtr++, bBuffer++) {
	if (tffsReadByteFlash(bFlashPtr) != *bBuffer) {
	    DEBUG_PRINT(("Debug: write failed for 16-bit Intel media in verification.\n"));
	return flWriteFault;
	}
    }
  }

  return status;
}


/*----------------------------------------------------------------------*/
/*			i 2 8 f 0 1 6 E r a s e 			*/
/*									*/
/* Erase one or more contiguous Flash erasable blocks			*/
/*									*/
/* This routine will be registered as the MTD vol.erase routine */
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	firstErasableBlock : Number of first block to erase		*/
/*	numOfErasableBlocks: Number of blocks to erase			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

FLStatus i28f016Erase(FLFlash vol,
			   word firstErasableBlock,
			   word numOfErasableBlocks)
{
  FLStatus status = flOK;	/* unless proven otherwise */
  LONG iBlock;

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

#ifdef SOCKET_12_VOLTS
  checkStatus(flNeedVpp(vol.socket));
#endif

  for (iBlock = 0; iBlock < numOfErasableBlocks && status == flOK; iBlock++) {
    FlashWPTR currPtr;
    LONG i;
    FLBoolean finished;

    FlashWPTR flashPtr = (FlashWPTR)
	   flMap(vol.socket,(firstErasableBlock + iBlock) * vol.erasableBlockSize);

    for (i = 0, currPtr = flashPtr;
	 i < vol.interleaving;
	 i += 2, currPtr++) {
      tffsWriteWordFlash(currPtr, SETUP_ERASE);
      tffsWriteWordFlash(currPtr, CONFIRM_ERASE);
    }

    do {
#ifdef FL_BACKGROUND
      while (flForeground(1) == BG_SUSPEND) {		/* suspend */
	for (i = 0, currPtr = flashPtr;
	     i < vol.interleaving;
	     i += 2, currPtr++) {
	  tffsWriteWordFlash(currPtr, READ_STATUS);
	  if (!(both(currPtr) & WSM_READY)) {
	    tffsWriteWordFlash(currPtr, SUSPEND_ERASE);
	    tffsWriteWordFlash(currPtr, READ_STATUS);
	    while (!(both(currPtr) & WSM_READY))
	      ;
	  }
	  tffsWriteWordFlash(currPtr, READ_ARRAY);
	}
      }
#endif
      finished = TRUE;
      for (i = 0, currPtr = flashPtr;
	   i < vol.interleaving;
	   i += 2, currPtr++) {
	tffsWriteWordFlash(currPtr, READ_STATUS);

	if (any(currPtr) & WSM_SUSPENDED) {
	  tffsWriteWordFlash(currPtr, RESUME_ERASE);
	  finished = FALSE;
	}
	else if (!(both(currPtr) & WSM_READY))
	  finished = FALSE;
	else {
	  if (any(currPtr) & WSM_ERROR) {
	    DEBUG_PRINT(("Debug: erase failed for 16-bit Intel media.\n"));
	    status = (any(currPtr) & WSM_VPP_ERROR) ? flVppFailure : flWriteFault;
	    tffsWriteWordFlash(currPtr, CLEAR_STATUS);
	  }
	  tffsWriteWordFlash(currPtr, READ_ARRAY);
	}
      }
      flDelayMsecs(10);
    } while (!finished);

  }

#ifdef SOCKET_12_VOLTS
  flDontNeedVpp(vol.socket);
#endif

  return status;
}

/*----------------------------------------------------------------------*/
/*			  i 2 8 f 0 1 6 M a p				*/
/*									*/
/* Map through buffer. This routine will be registered as the map	*/
/* routine for this MTD.						*/
/*									*/
/* Parameters:								*/
/*	vol	: Pointer identifying drive				*/
/*	address : Flash address to be mapped.				*/
/*	length	: number of bytes to map.				*/
/*									*/
/* Returns:								*/
/*	Pointer to the buffer data was mapped to.			*/
/*									*/
/*----------------------------------------------------------------------*/

VOID FAR0 *i28f016Map (FLFlash vol, CardAddress address, int length)
{
  vol.socket->remapped = TRUE;
  return mapThroughBuffer(&vol,address,length);
}

/*----------------------------------------------------------------------*/
/*			  i 2 8 f 0 1 6 R e a d 			*/
/*									*/
/* Read some data from the flash. This routine will be registered as	*/
/* the read routine for this MTD.					*/
/*									*/
/* Parameters:								*/
/*	vol	: Pointer identifying drive				*/
/*	address : Address to read from. 				*/
/*	buffer	: buffer to read to.					*/
/*	length	: number of bytes to read (up to sector size).		*/
/*	modes	: EDC flag etc. 					*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failed.		*/
/*									*/
/*----------------------------------------------------------------------*/

FLStatus i28f016Read(FLFlash vol,
			 CardAddress address,
			 VOID FAR1 *buffer,
			 dword length,
			 word modes)
{
  ULONG i;
  UCHAR * bBuffer;
  FlashPTR bFlashPtr;
  ULONG * dBuffer = (ULONG *)buffer;
  FlashDPTR dFlashPtr = (FlashDPTR)flMap(vol.socket, address);

  for (i = 0; i < length - 4; i += 4, dBuffer++, dFlashPtr++) {
    *dBuffer = tffsReadDwordFlash(dFlashPtr);
  }
  bBuffer = (UCHAR *)dBuffer;
  bFlashPtr = (FlashPTR)dFlashPtr;
  for(; i < length; i++, bBuffer++, bFlashPtr++) {
    *bBuffer = tffsReadByteFlash(bFlashPtr);
  }
  return flOK ;
}

/*----------------------------------------------------------------------*/
/*		       i 2 8 f 0 1 6 I d e n t i f y			*/
/*									*/
/* Identifies media based on Intel 28F016 and registers as an MTD for	*/
/* such.								*/
/*									*/
/* This routine will be placed on the MTD list in custom.h. It must be	*/
/* an extern routine.							*/
/*									*/
/* On successful identification, the Flash structure is filled out and	*/
/* the write and erase routines registered.				*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on positive identificaion, failed otherwise */
/*----------------------------------------------------------------------*/

FLStatus i28f016Identify(FLFlash vol)
{
  FlashWPTR flashPtr;

  DEBUG_PRINT(("Debug: entering 16-bit Intel media identification routine.\n"));

  flSetWindowBusWidth(vol.socket,16);/* use 16-bits */
  flSetWindowSpeed(vol.socket,150);  /* 120 nsec. */
  flSetWindowSize(vol.socket,2);	/* 8 KBytes */

  flashPtr = (FlashWPTR) flMap(vol.socket,0);

  vol.noOfChips = 0;
  tffsWriteWordFlash(flashPtr, READ_ID);
  if (tffsReadWordFlash(flashPtr) == 0x0089 && tffsReadWordFlash(flashPtr + 1) == 0x66a0) {
    /* Word mode */
    vol.type = I28F016_FLASH;
    vol.interleaving = 1;
    tffsWriteWordFlash(flashPtr, READ_ARRAY);
  }
  else if (tffsReadWordFlash(flashPtr) == 0x00B0 && tffsReadWordFlash(flashPtr + 1) == 0x6688) {
    /* Word mode */
    vol.type = LH28F016SU_FLASH;
    vol.interleaving = 1;
    tffsWriteWordFlash(flashPtr, READ_ARRAY);
  }
  else {
    /* Use standard identification routine to detect byte-mode */
    flIntelIdentify(&vol, NULL,0);
    if (vol.interleaving == 1)
      vol.type = NOT_FLASH;	/* We cannot handle byte-mode interleaving-1 */
  }

  if( (vol.type == I28F016_FLASH) || (vol.type == LH28F016SU_FLASH) ) {
    vol.chipSize = 0x200000L;
    vol.erasableBlockSize = 0x10000L * vol.interleaving;
    checkStatus(vol.interleaving == 1 ?
		i28f016WordSize(&vol) :
		flIntelSize(&vol, NULL,0));

    /* Register our flash handlers */
    vol.write = i28f016Write;
    vol.erase = i28f016Erase;
    vol.read = i28f016Read;
    vol.map = i28f016Map;

    DEBUG_PRINT(("Debug: identified 16-bit Intel media.\n"));
    return flOK;
  }
  else {
    DEBUG_PRINT(("Debug: failed to identify 16-bit Intel media.\n"));
    return flUnknownMedia;	/* not ours */
  }
}


/*----------------------------------------------------------------------*/
/*		     f l R e g i s t e r I 2 8 F 0 1 6			*/
/*									*/
/* Registers this MTD for use						*/
/*									*/
/* Parameters:								*/
/*	None								*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failure		*/
/*----------------------------------------------------------------------*/

FLStatus flRegisterI28F016(VOID)
{
  if (noOfMTDs >= MTDS)
    return flTooManyComponents;

  mtdTable[noOfMTDs++] = i28f016Identify;

  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\ftllite.c ===
/*
 * $Log:   V:/Flite/archives/FLite/src/FTLLITE.C_V  $
 * 
 *    Rev 1.50   12 Mar 2000 14:06:22   dimitrys
 * Change #define FL_BACKGROUND,  get rid of 
 *   warnings
 * 
 *    Rev 1.49   05 Mar 2000 18:58:08   dimitrys
 * Fix possible memory faults because of out-of-range
 *   memory access in next functions:
 *   - setupMapCache(), setVirtualMap(), writeSector()
 * 
 *    Rev 1.48   05 Mar 2000 17:41:08   dimitrys
 * Memory leaks in mountFTL  were fixed,  add setting
 *   pointers to Tables to NULL in dismountFTL() call,
 *   fix possible memory faults because of out-of-range
 *   memory access in next functions:
 *   - logical2Physical(), mapLogical(), setupMapCache(),
 *     virtual2Logical(), findFreeSector(), markAllocMap(),
 *     AllocateAndWriteSector(), closeReplacementPage(),
 *     setVirtualMap(), mapSector(), writeSector()
 *
 *    Rev 1.47   Jul 26 1999 17:54:42   marinak
 * Fix memory leaks
 *
 *    Rev 1.46   24 Feb 1999 14:17:44   marina
 * put TLrec back
 *
 *    Rev 1.45   23 Feb 1999 20:24:16   marina
 * memory leaks in formatFTL and mountFTL  were fixed; void in place of TLrec
 *
 *    Rev 1.44   31 Jan 1999 19:54:08   marina
 * WriteMultiSector
 *
 *    Rev 1.43   17 Jan 1999 17:07:16   marina
 * fix dismount bug
 *
 *    Rev 1.42   13 Jan 1999 18:55:24   marina
 * Always define sectorsInVolume
 *
 *    Rev 1.41   29 Dec 1998 11:03:02   marina
 * Get rid of warnings, prepare for unconditional dismount
 *
 *    Rev 1.40   26 Oct 1998 17:29:36   marina
 * In function flRegisterFTL formatRoutine initialization
 *    is called if not defined FORMAT_VOLUME
 *
 *    Rev 1.39   03 Sep 1998 13:59:02   ANDRY
 * better DEBUG_PRINT
 *
 *    Rev 1.38   16 Aug 1998 20:29:50   amirban
 * TL definition changes for ATA & ZIP
 *
 *    Rev 1.37   24 Mar 1998 10:48:14   Yair
 * Added casts
 *
 *    Rev 1.36   01 Mar 1998 12:59:36   amirban
 * Add parameter to mapSector
 *
 *    Rev 1.35   23 Feb 1998 17:08:32   Yair
 * Added casts
 *
 *    Rev 1.34   19 Feb 1998 19:05:46   amirban
 * Shortened FORMAT_PATTERN, and changed repl. page handling
 *
 *    Rev 1.33   23 Nov 1997 17:19:36   Yair
 * Get rid of warnings (With Danny)
 *
 *    Rev 1.32   11 Nov 1997 15:26:46   ANDRY
 * () in complex expressions to get rid of compiler warnings
 *
 *    Rev 1.31   06 Oct 1997 18:37:24   ANDRY
 * no COBUX
 *
 *    Rev 1.30   05 Oct 1997 15:31:40   ANDRY
 * for COBUX: checkForWriteInPlace() always skips even number of bytes
` *
 *    Rev 1.29   28 Sep 1997 18:22:08   danig
 * Free socket buffer in flsocket.c
 *
 *    Rev 1.28   23 Sep 1997 18:09:44   danig
 * Initialize buffer.sectorNo in initTables
 *
 *    Rev 1.27   10 Sep 1997 16:17:16   danig
 * Got rid of generic names
 *
 *    Rev 1.26   31 Aug 1997 14:28:30   danig
 * Registration routine return status
 *
 *    Rev 1.25   28 Aug 1997 19:01:28   danig
 * buffer per socket
 *
 *    Rev 1.24   28 Jul 1997 14:52:30   danig
 * volForCallback
 *
 *    Rev 1.23   24 Jul 1997 18:02:44   amirban
 * FAR to FAR0
 *
 *    Rev 1.22   21 Jul 1997 19:18:36   danig
 * Compile with SINGLE_BUFFER
 *
 *    Rev 1.21   20 Jul 1997 17:17:12   amirban
 * Get rid of warnings
 *
 *    Rev 1.20   07 Jul 1997 15:22:00   amirban
 * Ver 2.0
 *
 *    Rev 1.19   03 Jun 1997 17:08:10   amirban
 * setBusy change
 *
 *    Rev 1.18   18 May 1997 17:56:04   amirban
 * Add flash read/write flag parameter
 *
 *    Rev 1.17   01 May 1997 12:15:52   amirban
 * Initialize vol.garbageCollectStatus
 *
 *    Rev 1.16   02 Apr 1997 16:56:06   amirban
 * More Big-Endian: Virtual map
 *
 *    Rev 1.15   18 Mar 1997 15:04:06   danig
 * More Big-Endian corrections for BAM
 *
 *    Rev 1.14   10 Mar 1997 18:52:38   amirban
 * Big-Endian corrections for BAM
 *
 *    Rev 1.13   21 Oct 1996 18:03:18   amirban
 * Defragment i/f change
 *
 *    Rev 1.12   09 Oct 1996 11:55:30   amirban
 * Assign Big-Endian unit numbers
 *
 *    Rev 1.11   08 Oct 1996 12:17:46   amirban
 * Use remapped
 *
 *    Rev 1.10   03 Oct 1996 11:56:42   amirban
 * New Big-Endian
 *
 *    Rev 1.9   09 Sep 1996 11:39:12   amirban
 * Background and mapSector bugs
 *
 *    Rev 1.8   29 Aug 1996 14:19:04   amirban
 * Fix boot-image bug, warnings
 *
 *    Rev 1.7   15 Aug 1996 14:04:38   amirban
 *
 *    Rev 1.6   12 Aug 1996 15:49:54   amirban
 * Advanced background transfer, and defined setBusy
 *
 *    Rev 1.5   31 Jul 1996 14:30:28   amirban
 * Background stuff
 *
 *    Rev 1.3   08 Jul 1996 17:21:16   amirban
 * Better page scan in mount unit
 *
 *    Rev 1.2   16 Jun 1996 14:03:42   amirban
 * Added badFormat return code for mount
 *
 *    Rev 1.1   09 Jun 1996 18:16:02   amirban
 * Corrected definition of LogicalAddress
 *
 *    Rev 1.0   20 Mar 1996 13:33:06   amirban
 * Initial revision.
 */

/************************************************************************/
/*                                                                      */
/*		FAT-FTL Lite Software Development Kit			*/
/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
/*									*/
/************************************************************************/

#include "flflash.h"
#include "flbuffer.h"
#include "fltl.h"

#ifdef FL_BACKGROUND
#include "backgrnd.h"
#endif

/*  Implementation constants and type definitions */

#define SECTOR_OFFSET_MASK (SECTOR_SIZE - 1)

typedef long int LogicalAddress;	/* Byte address of media in logical
					   unit no. order. */
typedef long int VirtualAddress;	/* Byte address of media as specified
					   by Virtual Map. */
typedef SectorNo LogicalSectorNo;	/* A logical sector no. is given
					   by dividing its logical address by
					   the sector size */
typedef SectorNo VirtualSectorNo;	/* A virtual sector no. is such that
					   the first page is no. 0, the 2nd
					   is 1 etc.
					   The virtual sector no. is given
					   by dividing its virtual address by
					   the sector size and adding the
					   number of pages (result always
					   positive). */
typedef unsigned short UnitNo;

#define ADDRESSES_PER_SECTOR (SECTOR_SIZE / sizeof(LogicalAddress))
#define UNASSIGNED_ADDRESS (ULONG_PTR)-1
#define DELETED_ADDRESS    0
#define DELETED_SECTOR     0

#define PAGE_SIZE_BITS (SECTOR_SIZE_BITS + (SECTOR_SIZE_BITS - 2))

/* Unit descriptor record */

#define UNASSIGNED_UNIT_NO 0xffff
#define MARKED_FOR_ERASE   0x7fff

typedef struct {
  short		noOfFreeSectors;
  short         noOfGarbageSectors;
} Unit;

typedef Unit *UnitPtr;


/* Structure of data on a unit */

#define FREE_SECTOR      0xffffffffl
#define GARBAGE_SECTOR   0
#define ALLOCATED_SECTOR 0xfffffffel
#define	FORMAT_SECTOR    0x30
#define DATA_SECTOR      0x40
#define	REPLACEMENT_PAGE 0x60
#define BAD_SECTOR       0x70


static char FORMAT_PATTERN[15] = { 0x13, 3, 'C', 'I', 'S',
                             0x46, 57, 0, 'F', 'T', 'L', '1', '0', '0', 0 };

typedef struct {
  char		formatPattern[15];
  unsigned char	noOfTransferUnits;	/* no. of transfer units */
  LEulong	wearLevelingInfo;
  LEushort	logicalUnitNo;
  unsigned char	log2SectorSize;
  unsigned char	log2UnitSize;
  LEushort	firstPhysicalEUN;	/* units reserved for boot image */
  LEushort	noOfUnits;		/* no. of formatted units */
  LEulong	virtualMediumSize;	/* virtual size of volume */
  LEulong	directAddressingMemory;	/* directly addressable memory */
  LEushort	noOfPages;		/* no. of virtual pages */
  unsigned char	flags;
  unsigned char	eccCode;
  LEulong	serialNumber;
  LEulong	altEUHoffset;
  LEulong	BAMoffset;
  char		reserved[12];
  char		embeddedCIS[4];		/* Actual length may be larger. By
					   default, this contains FF's */
} UnitHeader;

/* flags assignments */

#define	HIDDEN_AREA_FLAG	1
#define	REVERSE_POLARITY_FLASH	2
#define	DOUBLE_BAI		4


#define dummyUnit ((const UnitHeader *) 0)  /* for offset calculations */

#define logicalUnitNoOffset ((char *) &dummyUnit->logicalUnitNo -	\
			     (char *) dummyUnit)

#ifndef MALLOC

#define HEAP_SIZE						\
		((0x100000l >> PAGE_SIZE_BITS) *                \
			sizeof(LogicalSectorNo) +               \
		 (0x100000l / ASSUMED_FTL_UNIT_SIZE) *          \
			(sizeof(Unit) + sizeof(UnitPtr))) *     \
		MAX_VOLUME_MBYTES +                             \
		(ASSUMED_VM_LIMIT / SECTOR_SIZE) *              \
			sizeof(LogicalSectorNo)

#endif

#define cannotWriteOver(newContents, oldContents)		\
		((newContents) & ~(oldContents))


struct tTLrec {
  FLBoolean		badFormat;		/* true if FTL format is bad */

  VirtualSectorNo	totalFreeSectors;	/* Free sectors on volume */
  SectorNo		virtualSectors;		/* size of virtual volume */
  unsigned int		unitSizeBits;		/* log2 of unit size */
  unsigned int		erasableBlockSizeBits;	/* log2 of erasable block size */
  UnitNo		noOfUnits;
  UnitNo		noOfTransferUnits;
  UnitNo		firstPhysicalEUN;
  int			noOfPages;
  unsigned	directAddressingSectors;/* no. of directly addressable sectors */
  VirtualAddress 	directAddressingMemory;	/* end of directly addressable memory */
  CardAddress		unitOffsetMask;		/* = 1 << unitSizeBits - 1 */
  CardAddress		bamOffset;
  unsigned int		sectorsPerUnit;
  unsigned int		unitHeaderSectors;	/* sectors used by unit header */

  Unit *		physicalUnits;		/* unit table by physical no. */
  Unit **		logicalUnits;		/* unit table by logical no. */
  Unit *		transferUnit;		/* The active transfer unit */
  LogicalSectorNo *	pageTable;		/* page translation table */
						/* directly addressable sectors */
  LogicalSectorNo	replacementPageAddress;
  VirtualSectorNo	replacementPageNo;

  SectorNo 		mappedSectorNo;
  const void FAR0 *	mappedSector;
  CardAddress		mappedSectorAddress;

  unsigned long		currWearLevelingInfo;

#ifdef FL_BACKGROUND
  Unit *		unitEraseInProgress;	/* Unit currently being formatted */
  FLStatus		garbageCollectStatus;	/* Status of garbage collection */

  /* When unit transfer is in the background, and is currently in progress,
     all write operations done on the 'from' unit moust be mirrored on the
     transfer unit. If so, 'mirrorOffset' will be non-zero and will be the
     offset of the alternate address from the original. 'mirrorFrom' and
     'mirrorTo' will be the limits of the original addresses to mirror. */
  long int		mirrorOffset;
  CardAddress		mirrorFrom,
			mirrorTo;
#endif

#ifndef SINGLE_BUFFER
  FLBuffer *		volBuffer;		/* Define a sector buffer */
#endif

  FLFlash		flash;

#ifndef MALLOC
  char			heap[HEAP_SIZE];
#endif
};


typedef TLrec Flare;

static Flare vols[SOCKETS];


#ifdef SINGLE_BUFFER

extern FLBuffer buffer;

#else

#define buffer (*vol.volBuffer)

/* Virtual map cache (shares memory with buffer) */
#define mapCache	((LEulong *) buffer.flData)

#endif


/* Unit header buffer (shares memory with buffer) */
#define uh		((UnitHeader *) buffer.flData)

/* Transfer sector buffer (shares memory with buffer) */
#define sectorCopy 	((LEulong *) buffer.flData)

#define FREE_UNIT	-0x400	/* Indicates a transfer unit */

/* Function definition */
void dismountFTL(Flare vol);

/*----------------------------------------------------------------------*/
/*		         p h y s i c a l B a s e			*/
/*									*/
/* Returns the physical address of a unit.				*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	unit		: unit pointer					*/
/*                                                                      */
/* Returns:                                                             */
/*	physical address of unit					*/
/*----------------------------------------------------------------------*/

static CardAddress physicalBase(Flare vol,  const Unit *unit)
{
  return (CardAddress) (unit - vol.physicalUnits) << vol.unitSizeBits;
}


/*----------------------------------------------------------------------*/
/*		      l o g i c a l 2 P h y s i c a l			*/
/*									*/
/* Returns the physical address of a logical sector no.			*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	address		: logical sector no.				*/
/*                                                                      */
/* Returns:                                                             */
/*	CardAddress	: physical address of sector			*/
/*----------------------------------------------------------------------*/

static CardAddress logical2Physical(Flare vol,  LogicalSectorNo address)
{
  UnitNo index;
  CardAddress physAddr;

  index = (UnitNo)(address >> (vol.unitSizeBits - SECTOR_SIZE_BITS));
  if( index >= vol.noOfUnits )
    return UNASSIGNED_ADDRESS;
  physAddr = physicalBase(&vol,vol.logicalUnits[index]);
  physAddr |= (((CardAddress) address << SECTOR_SIZE_BITS) & vol.unitOffsetMask);
  return physAddr;
}


/*----------------------------------------------------------------------*/
/*		            m a p L o g i c a l				*/
/*									*/
/* Maps a logical sector and returns pointer to physical Flash location.*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	address		: logical sector no.				*/
/*                                                                      */
/* Returns:                                                             */
/*	Pointer to sector on Flash 					*/
/*----------------------------------------------------------------------*/

static void FAR0 *mapLogical(Flare vol, LogicalSectorNo address)
{
  CardAddress physAddress = logical2Physical(&vol,address);
  if( physAddress == UNASSIGNED_ADDRESS )
    return (void FAR0 *) ULongToPtr(UNASSIGNED_ADDRESS);
  return vol.flash.map(&vol.flash,physAddress,SECTOR_SIZE);
}


/*----------------------------------------------------------------------*/
/*		        a l l o c E n t r y O f f s e t			*/
/*									*/
/* Returns unit offset of given BAM entry				*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo	: BAM entry no.					*/
/*                                                                      */
/* Returns:                                                             */
/*	Offset of BAM entry in unit					*/
/*----------------------------------------------------------------------*/

static int allocEntryOffset(Flare vol, int sectorNo)
{
  return (int) (vol.bamOffset + sizeof(VirtualAddress) * sectorNo);
}


/*----------------------------------------------------------------------*/
/*		         m a p U n i t H e a d e r 			*/
/*									*/
/* Map a unit header and return pointer to it.				*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	unit		: Unit to map header				*/
/*                                                                      */
/* Returns:                                                             */
/*	Pointer to mapped unit header					*/
/*	blockAllocMap	: (optional) Pointer to mapped BAM		*/
/*----------------------------------------------------------------------*/

static UnitHeader FAR0 *mapUnitHeader(Flare vol,
				     const Unit *unit,
				     LEulong FAR0 **blockAllocMap)
{
  UnitHeader FAR0 *unitHeader;

  int length = sizeof(UnitHeader);
  if (blockAllocMap)
    length = allocEntryOffset(&vol,vol.sectorsPerUnit);
  unitHeader = (UnitHeader FAR0 *) vol.flash.map(&vol.flash,physicalBase(&vol,unit),length);
  if (blockAllocMap)
    *blockAllocMap = (LEulong FAR0 *) ((char FAR0 *) unitHeader + allocEntryOffset(&vol,0));

  return unitHeader;
}


#ifndef SINGLE_BUFFER

/*----------------------------------------------------------------------*/
/*		          s e t u p M a p C a c h e			*/
/*									*/
/* Sets up map cache sector to contents of specified Virtual Map page	*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	pageNo		: Page no. to copy to map cache			*/
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus setupMapCache(Flare vol, int pageNo)
{
  CardAddress physAddress = logical2Physical(&vol,vol.pageTable[pageNo]);
  if( physAddress == UNASSIGNED_ADDRESS )
    return flGeneralFailure;

  vol.flash.read(&vol.flash,physAddress,mapCache,SECTOR_SIZE,0);
  if ((VirtualSectorNo)pageNo == vol.replacementPageNo) {
    int i;
    LEulong FAR0 *replacementPage;
    void FAR0 *logicalAddr = mapLogical(&vol,vol.replacementPageAddress);

    if( logicalAddr == (void FAR0 *) ULongToPtr(UNASSIGNED_ADDRESS) )
      return flGeneralFailure;
    replacementPage = (LEulong FAR0 *)logicalAddr;

    for (i = 0; i < ADDRESSES_PER_SECTOR; i++) {
      if (LE4(mapCache[i]) == DELETED_ADDRESS)
	toLE4(mapCache[i],LE4(replacementPage[i]));
    }
  }
  buffer.sectorNo = pageNo;
  buffer.owner = &vol;
  return flOK;
}

#endif


/*----------------------------------------------------------------------*/
/*		        v i r t u a l 2 L o g i c a l			*/
/*									*/
/* Translates virtual sector no. to logical sector no.			*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo	: Virtual sector no.				*/
/*                                                                      */
/* Returns:                                                             */
/*	Logical sector no. corresponding to virtual sector no.		*/
/*----------------------------------------------------------------------*/

static LogicalSectorNo virtual2Logical(Flare vol,  VirtualSectorNo sectorNo)
{
  LogicalAddress virtualMapEntry;
  FLStatus status = flOK;

  if (sectorNo < (VirtualSectorNo)vol.directAddressingSectors)
    return vol.pageTable[((unsigned)sectorNo)];
  else {
    int pageNo;
    int sectorInPage;

    sectorNo -= vol.noOfPages;
    pageNo = (int) (sectorNo >> (PAGE_SIZE_BITS - SECTOR_SIZE_BITS));
    sectorInPage = (int) (sectorNo) % ADDRESSES_PER_SECTOR;
    {
#ifdef SINGLE_BUFFER
      LogicalAddress FAR0 *virtualMapPage;

      virtualMapPage = (LogicalAddress FAR0 *) mapLogical(&vol, vol.pageTable[pageNo]);
      if( virtualMapPage == (LogicalAddress FAR0 *) UNASSIGNED_ADDRESS )
        return (LogicalSectorNo) UNASSIGNED_SECTOR;

      if( pageNo == vol.replacementPageNo &&
          virtualMapPage[sectorInPage] == DELETED_ADDRESS ) {
        virtualMapPage = (LogicalAddress FAR0 *) mapLogical(&vol, vol.replacementPageAddress);
        if( virtualMapPage == (LogicalAddress FAR0 *) UNASSIGNED_ADDRESS )
          return (LogicalSectorNo) UNASSIGNED_SECTOR;
      }
      virtualMapEntry = LE4(virtualMapPage[sectorInPage]);
#else
      if( buffer.sectorNo != (SectorNo)pageNo || buffer.owner != &vol )
        status = setupMapCache(&vol,pageNo);
        if( status != flOK )
          return (LogicalSectorNo) UNASSIGNED_SECTOR;
      virtualMapEntry = LE4(mapCache[sectorInPage]);
#endif
      if( (virtualMapEntry >> vol.unitSizeBits) < vol.noOfUnits )
        return (LogicalSectorNo) (virtualMapEntry >> SECTOR_SIZE_BITS);
      else
        return (LogicalSectorNo) UNASSIGNED_SECTOR;
    }
  }
}


/*----------------------------------------------------------------------*/
/*		          v e r i f y F o r m a t 			*/
/*									*/
/* Verify an FTL unit header.						*/
/*                                                                      */
/* Parameters:                                                          */
/*	unitHeader	: Pointer to unit header			*/
/*                                                                      */
/* Returns:                                                             */
/*	TRUE if header is correct. FALSE if not.			*/
/*----------------------------------------------------------------------*/

static FLBoolean verifyFormat(UnitHeader FAR0 *unitHeader)
{
  FORMAT_PATTERN[6] = unitHeader->formatPattern[6];	/* TPL_LINK */
  return tffscmp(unitHeader->formatPattern + 2,
		 FORMAT_PATTERN + 2,
		 sizeof unitHeader->formatPattern - 2) == 0;
}


/*----------------------------------------------------------------------*/
/*		          f o r m a t U n i t				*/
/*									*/
/* Formats a unit by erasing it and writing a unit header.		*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	unit		: Unit to format				*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus formatUnit(Flare vol,  Unit *unit)
{
  unsigned unitHeaderLength = allocEntryOffset(&vol,vol.unitHeaderSectors);

  unit->noOfFreeSectors = FREE_UNIT;
  unit->noOfGarbageSectors = 0;

#ifdef FL_BACKGROUND
  {
    FLStatus status;

    vol.unitEraseInProgress = unit;
    status = vol.flash.erase(&vol.flash,
			 (int) (physicalBase(&vol,unit) >> vol.erasableBlockSizeBits),
			 1 << (vol.unitSizeBits - vol.erasableBlockSizeBits));
    vol.unitEraseInProgress = NULL;
    if (status != flOK)
      return status;

    /* Note: This suspend to the foreground is not only nice to have, it is
       necessary ! The reason is that we may have a write from the buffer
       waiting for the erase to complete. We are next going to overwrite the
       buffer, so this break enables the write to complete before the data is
       clobbered (what a relief). */
    while (flForeground(1) == BG_SUSPEND)
      ;
  }
#else
  checkStatus(vol.flash.erase(&vol.flash,
			  (word) (physicalBase(&vol,unit) >> vol.erasableBlockSizeBits),
			  (word)(1 << (vol.unitSizeBits - vol.erasableBlockSizeBits))));
#endif

  /* We will copy the unit header as far as the format entries of the BAM
     from another unit (logical unit 0) */
#ifdef SINGLE_BUFFER
  if (buffer.dirty)
    return flBufferingError;
#endif
  buffer.sectorNo = UNASSIGNED_SECTOR;    /* Invalidate map cache so we can
					     use it as a buffer */
  if (vol.logicalUnits[vol.firstPhysicalEUN]) {
    vol.flash.read(&vol.flash,
	       physicalBase(&vol,vol.logicalUnits[vol.firstPhysicalEUN]),
	       uh,
	       unitHeaderLength,
	       0);
  }

  toLE4(uh->wearLevelingInfo,++vol.currWearLevelingInfo);
  toLE2(uh->logicalUnitNo,UNASSIGNED_UNIT_NO);

  checkStatus(vol.flash.write(&vol.flash,
			  physicalBase(&vol,unit),
			  uh,
			  unitHeaderLength,
			  0));

  return flOK;
}


#ifdef FL_BACKGROUND

/*----------------------------------------------------------------------*/
/*		          f l a s h W r i t e				*/
/*									*/
/* Writes to flash through flash.write, but, if possible, allows a	*/
/* background erase to continue while writing.				*/
/*                                                                      */
/* Parameters:                                                          */
/*	Same as flash.write						*/
/*          								*/
/* Returns:                                                             */
/*	Same as flash.write						*/
/*----------------------------------------------------------------------*/

static FLStatus flashWrite(Flare vol,
			 CardAddress address,
			 const void FAR1 *from,
			 int length,
			 FLBoolean overwrite)
{
  if (vol.mirrorOffset != 0 &&
      address >= vol.mirrorFrom && address < vol.mirrorTo) {
    checkStatus(flashWrite(&vol,
			   address + vol.mirrorOffset,
			   from,
			   length,
			   overwrite));
  }

  if (vol.unitEraseInProgress) {
    CardAddress startChip = physicalBase(&vol,vol.unitEraseInProgress) &
				(-vol.flash.interleaving * vol.flash.chipSize);
    CardAddress endChip = startChip + vol.flash.interleaving * vol.flash.chipSize;

    if (address < startChip || address >= endChip) {
      flBackground(BG_RESUME);
      checkStatus(vol.flash.write(&vol.flash,address,from,length,overwrite));
      flBackground(BG_SUSPEND);

      return flOK;
    }
    else if (!(vol.flash.flags & SUSPEND_FOR_WRITE)) {
      do {
	flBackground(BG_RESUME);
      } while (vol.unitEraseInProgress);
    }
  }

  return vol.flash.write(&vol.flash,address,from,length,overwrite);
}

#else

#define flashWrite(v,address,from,length,overwrite)	\
		(v)->flash.write(&(v)->flash,address,from,length,overwrite)

#endif	/* FL_BACKGROUND */


/*----------------------------------------------------------------------*/
/*		           m o u n t U n i t				*/
/*									*/
/* Performs mount scan for a single unit				*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	unit		: Unit to mount					*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus mountUnit(Flare vol,  Unit *unit)
{
  unsigned i;
  LogicalSectorNo sectorAddress;
  LEulong FAR0 *blockAllocMap;

  UnitHeader FAR0 *unitHeader = mapUnitHeader(&vol,unit,&blockAllocMap);

  UnitNo logicalUnitNo = LE2(unitHeader->logicalUnitNo);

  unit->noOfGarbageSectors = 0;
  unit->noOfFreeSectors = FREE_UNIT;

  if (!verifyFormat(unitHeader) ||
      ((logicalUnitNo != UNASSIGNED_UNIT_NO) &&
       ((logicalUnitNo >= vol.noOfUnits) ||
        (logicalUnitNo < vol.firstPhysicalEUN) ||
        vol.logicalUnits[logicalUnitNo]))) {
    if (vol.transferUnit == NULL)
      vol.transferUnit = unit;
    return flBadFormat;
  }

  if (logicalUnitNo == UNASSIGNED_UNIT_NO) {
    vol.transferUnit = unit;
    return flOK;		/* this is a transfer unit */
  }

  if (LE4(unitHeader->wearLevelingInfo) > vol.currWearLevelingInfo &&
      LE4(unitHeader->wearLevelingInfo) != 0xffffffffl)
    vol.currWearLevelingInfo = LE4(unitHeader->wearLevelingInfo);

  /* count sectors and setup virtual map */
  sectorAddress =
     ((LogicalSectorNo) logicalUnitNo << (vol.unitSizeBits - SECTOR_SIZE_BITS));
  unit->noOfFreeSectors = 0;
  for (i = 0; i < vol.sectorsPerUnit; i++, sectorAddress++) {
    VirtualAddress allocMapEntry = LE4(blockAllocMap[i]);

    if (allocMapEntry == GARBAGE_SECTOR || allocMapEntry == ALLOCATED_SECTOR)
      unit->noOfGarbageSectors++;
    else if (allocMapEntry == FREE_SECTOR) {
      unit->noOfFreeSectors++;
      vol.totalFreeSectors++;
    }
    else if (allocMapEntry < vol.directAddressingMemory) {
      char signature = (char)((short)(allocMapEntry) & SECTOR_OFFSET_MASK);
      if (signature == DATA_SECTOR || signature == REPLACEMENT_PAGE) {
        int pageNo = (int) (allocMapEntry >> SECTOR_SIZE_BITS) + vol.noOfPages;
        if (pageNo >= 0)
          if (signature == DATA_SECTOR)
            vol.pageTable[pageNo] = sectorAddress;
          else {
            vol.replacementPageAddress = sectorAddress;
            vol.replacementPageNo = pageNo;
          }
      }
    }
  }

  /* Place the logical mapping of the unit */
  vol.mappedSectorNo = UNASSIGNED_SECTOR;
  vol.logicalUnits[logicalUnitNo] = unit;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*		           a s s i g n U n i t				*/
/*									*/
/* Assigns a logical unit no. to a unit					*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	unit		: Unit to assign				*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus assignUnit(Flare vol,  Unit *unit, UnitNo logicalUnitNo)
{
  LEushort unitNoToWrite;

  toLE2(unitNoToWrite,logicalUnitNo);

  return flashWrite(&vol,
                (CardAddress)(physicalBase(&vol,unit) + logicalUnitNoOffset),
                &unitNoToWrite,
                sizeof unitNoToWrite,
                OVERWRITE);
}


/*----------------------------------------------------------------------*/
/*		    b e s t U n i t T o T r a n s f e r			*/
/*									*/
/* Find best candidate for unit transfer, usually on the basis of which	*/
/* unit has the most garbage space. A lower wear-leveling info serves	*/
/* as a tie-breaker. If 'leastUsed' is NOT specified, then the least	*/
/* wear-leveling info is the only criterion.				*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	leastUsed	: Whether most garbage space is the criterion	*/
/*                                                                      */
/* Returns:                                                             */
/*	Best unit to transfer						*/
/*----------------------------------------------------------------------*/

static UnitNo bestUnitToTransfer(Flare vol,  FLBoolean leastUsed)
{
  UnitNo i;

  int mostGarbageSectors = 1;
  unsigned long int leastWearLevelingInfo = 0xffffffffl;
  UnitNo bestUnitSoFar = UNASSIGNED_UNIT_NO;

  for (i = 0; i < vol.noOfUnits; i++) {
    Unit *unit = vol.logicalUnits[i];
    if (unit && (!leastUsed || (unit->noOfGarbageSectors >= mostGarbageSectors))) {
      UnitHeader FAR0 *unitHeader = mapUnitHeader(&vol,unit,NULL);
      if ((leastUsed && (unit->noOfGarbageSectors > mostGarbageSectors)) ||
	  (LE4(unitHeader->wearLevelingInfo) < leastWearLevelingInfo)) {
	mostGarbageSectors = unit->noOfGarbageSectors;
	leastWearLevelingInfo = LE4(unitHeader->wearLevelingInfo);
	bestUnitSoFar = i;
      }
    }
  }

  return bestUnitSoFar;
}


/*----------------------------------------------------------------------*/
/*		           u n i t T r a n s f e r			*/
/*									*/
/* Performs a unit transfer from a selected unit to a tranfer unit.	*/
/*                                                                      */
/* A side effect is to invalidate the map cache (reused as buffer).	*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	toUnit          : Target transfer unit				*/
/*	fromUnitNo:	: Source logical unit no.			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus unitTransfer(Flare vol,  Unit *toUnit, UnitNo fromUnitNo)
{
  unsigned i;
  Unit *fromUnit = vol.logicalUnits[fromUnitNo];

  UnitHeader FAR0 *transferUnitHeader = mapUnitHeader(&vol,toUnit,NULL);
  if (!verifyFormat(transferUnitHeader) ||
      LE2(transferUnitHeader->logicalUnitNo) != UNASSIGNED_UNIT_NO)
    /* previous formatting failed or did not complete. 		*/
    checkStatus(formatUnit(&vol,toUnit));

  /* Should the transfer not complete, the unit is marked to be erased */
  checkStatus(assignUnit(&vol,toUnit,MARKED_FOR_ERASE));

#ifdef FL_BACKGROUND
  vol.mirrorFrom = vol.mirrorTo = physicalBase(&vol,fromUnit);
  vol.mirrorOffset = physicalBase(&vol,toUnit) - vol.mirrorFrom;
#endif

  /* copy the block allocation table and the good sectors */
  for (i = 0; i < vol.sectorsPerUnit;) {
    int j;

    FLBoolean needToWrite = FALSE;
    int firstOffset = allocEntryOffset(&vol,i);

    /* Up to 128 bytes of the BAM are processed per loop */
    int nEntries = (128 - (firstOffset & 127)) / sizeof(VirtualAddress);

    /* We are going to use the Virtual Map cache as our sector buffer in the */
    /* transfer, so let's better invalidate the cache first.		   */
#ifdef SINGLE_BUFFER
    if (buffer.dirty)
      return flBufferingError;
#endif
    buffer.sectorNo = UNASSIGNED_SECTOR;

    /* Read some of the BAM */
    vol.flash.read(&vol.flash,
	       physicalBase(&vol,fromUnit) + firstOffset,
	       sectorCopy,
	       nEntries * sizeof(VirtualAddress),
	       0);

    /* Convert garbage entries to free entries */
    for (j = 0; j < nEntries && i+j < vol.sectorsPerUnit; j++) {
      unsigned bamSignature = (unsigned) LE4(sectorCopy[j]) & SECTOR_OFFSET_MASK;
      if (bamSignature == DATA_SECTOR ||
	  bamSignature == REPLACEMENT_PAGE)
	needToWrite = TRUE;
      else if (bamSignature != FORMAT_SECTOR)
	toLE4(sectorCopy[j],FREE_SECTOR);
    }

    if (needToWrite) {
      FLStatus status;

      /* Write new BAM, and copy sectors that need to be copied */
      status = flashWrite(&vol,
			  physicalBase(&vol,toUnit) + firstOffset,
			  sectorCopy,
			  nEntries * sizeof(VirtualAddress),
			  0);
      if (status != flOK) {
#ifdef FL_BACKGROUND
	vol.mirrorOffset = 0;	/* no more mirroring */
#endif
	return status;
      }

      for (j = 0; j < nEntries && i+j < vol.sectorsPerUnit; j++) {
	unsigned bamSignature = (unsigned) LE4(sectorCopy[j]) & SECTOR_OFFSET_MASK;
	if (bamSignature == DATA_SECTOR ||
	    bamSignature == REPLACEMENT_PAGE) { /* a good sector */
	  CardAddress sectorOffset = (CardAddress) (i+j) << SECTOR_SIZE_BITS;

	  vol.flash.read(&vol.flash,
		     physicalBase(&vol,fromUnit) + sectorOffset,
		     sectorCopy,SECTOR_SIZE,0);
	  status = flashWrite(&vol,
			      physicalBase(&vol,toUnit) + sectorOffset,
			      sectorCopy,
			      SECTOR_SIZE,
			      0);
	  if (status != flOK) {
#ifdef FL_BACKGROUND
	    vol.mirrorOffset = 0;	/* no more mirroring */
#endif
	    return status;
	  }
	  vol.flash.read(&vol.flash,
		     physicalBase(&vol,fromUnit) + firstOffset,
		     sectorCopy,
		     nEntries * sizeof(VirtualAddress),0);
	}
      }

#ifdef FL_BACKGROUND
      vol.mirrorTo = vol.mirrorFrom +
		     ((CardAddress) (i + nEntries) << SECTOR_SIZE_BITS);
      while (flForeground(1) == BG_SUSPEND)
	;
#endif
    }

    i += nEntries;
  }

#ifdef FL_BACKGROUND
  vol.mirrorOffset = 0;	/* no more mirroring */
#endif

  /* Write the new logical unit no. */
  checkStatus(assignUnit(&vol,toUnit,fromUnitNo));

  /* Mount the new unit in place of old one */
  vol.logicalUnits[fromUnitNo] = NULL;
  if (mountUnit(&vol,toUnit) == flOK) {
    vol.totalFreeSectors -= fromUnit->noOfFreeSectors;

    /* Finally, format the source unit (the new transfer unit) */
    vol.transferUnit = fromUnit;
    formatUnit(&vol,fromUnit);	/* nothing we can or should do if this fails */
  }
  else {		/* Something went wrong */
    vol.logicalUnits[fromUnitNo] = fromUnit;	/* reinstate original unit */
    return flGeneralFailure;
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*		         g a r b a g e C o l l e c t			*/
/*									*/
/* Performs a unit transfer, selecting a unit to transfer and a		*/
/* transfer unit.                                                       */
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus garbageCollect(Flare vol)
{
  FLStatus status;
  UnitNo fromUnitNo;

  if (vol.transferUnit == NULL)
    return flWriteProtect;	/* Cannot recover space without a spare unit */

  fromUnitNo = bestUnitToTransfer(&vol,flRandByte() >= 4);
  if (fromUnitNo == UNASSIGNED_UNIT_NO)
    return flGeneralFailure;	/* nothing to collect */

  /* Find a unit we can transfer to.				*/
  status = unitTransfer(&vol,vol.transferUnit,fromUnitNo);
  if (status == flWriteFault) {
    int i;
    Unit *unit = vol.physicalUnits;

    for (i = 0; i < vol.noOfUnits; i++, unit++) {
      if (unit->noOfGarbageSectors == 0 && unit->noOfFreeSectors < 0) {
	if (unitTransfer(&vol,unit,fromUnitNo) == flOK)
	  return flOK;	/* found a good one */
      }
    }
  }

  return status;
}


#ifdef FL_BACKGROUND

/*----------------------------------------------------------------------*/
/*		        b g G a r b a g e C o l l e c t			*/
/*									*/
/* Entry point for garbage collection in the background.		*/
/*                                                                      */
/* Status is returned in vol.garbageCollectStatus			*/
/*                                                                      */
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*          								*/
/* Returns:                                                             */
/*	None								*/
/*----------------------------------------------------------------------*/

static void bgGarbageCollect(void * object)
{
  Flare vol = (Flare *)object;

  vol.garbageCollectStatus = flIncomplete;
  vol.garbageCollectStatus = garbageCollect(&vol);
}

#endif


/*----------------------------------------------------------------------*/
/*      	            d e f r a g m e n t				*/
/*									*/
/* Performs unit transfers to arrange a minimum number of writable	*/
/* sectors.                                                             */
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorsNeeded	: Minimum required sectors			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

#define GARBAGE_COLLECT_THRESHOLD	20

static FLStatus defragment(Flare vol, long FAR2 *sectorsNeeded)
{
  while ((long)(vol.totalFreeSectors) < *sectorsNeeded
#ifdef FL_BACKGROUND
	 || vol.totalFreeSectors < GARBAGE_COLLECT_THRESHOLD
#endif
	 ) {
    if (vol.badFormat)
      return flBadFormat;

#ifdef FL_BACKGROUND
    if (vol.garbageCollectStatus == flIncomplete)
      flBackground(BG_RESUME);
    else
      flStartBackground(&vol - vols,bgGarbageCollect,&vol);
    if (vol.garbageCollectStatus != flOK &&
	vol.garbageCollectStatus != flIncomplete)
      return vol.garbageCollectStatus;

    if (vol.totalFreeSectors >= *sectorsNeeded)
      break;
  }

  if (vol.unitEraseInProgress)
    flBackground(BG_SUSPEND);
#else
    checkStatus(garbageCollect(&vol));
  }
#endif

  *sectorsNeeded = vol.totalFreeSectors;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*		    b e s t U n i t T o A l l o c a t e			*/
/*									*/
/* Finds the best unit from which to allocate a sector. The unit	*/
/* selected is the one with most free space.				*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*                                                                      */
/* Returns:                                                             */
/*	Best unit to allocate						*/
/*----------------------------------------------------------------------*/

static Unit *bestUnitToAllocate(Flare vol)
{
  int i;

  int mostFreeSectors = 0;
  Unit *bestUnitSoFar = NULL;

  for (i = 0; i < vol.noOfUnits; i++) {
    Unit *unit = vol.logicalUnits[i];

    if (unit && unit->noOfFreeSectors > mostFreeSectors) {
      mostFreeSectors = unit->noOfFreeSectors;
      bestUnitSoFar = unit;
    }
  }

  return bestUnitSoFar;
}


/*----------------------------------------------------------------------*/
/*		       f i n d F r e e S e c t o r			*/
/*									*/
/* The allocation strategy goes this way:                               */
/*                                                                      */
/* We try to make consecutive virtual sectors physically consecutive if */
/* possible. If not, we prefer to have consecutive sectors on the same  */
/* unit at least. If all else fails, a sector is allocated on the unit  */
/* with most space available.                                           */
/*                                                                      */
/* The object of this strategy is to cluster related data (e.g. a file  */
/* data) in one unit, and to distribute unrelated data evenly among all */
/* units.								*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo        : virtual sector no. that we want to allocate.	*/
/*									*/
/* Returns:                                                             */
/*	newAddress	: Allocated logical sector no.			*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus findFreeSector(Flare vol,
			     VirtualSectorNo sectorNo,
			     LogicalSectorNo *newAddress)
{
  unsigned iSector;
  LEulong FAR0 *blockAllocMap;
  UnitHeader FAR0 *unitHeader;

  Unit *allocationUnit = NULL;

  LogicalSectorNo previousSectorAddress =
	 (sectorNo > 0 ? virtual2Logical(&vol,(VirtualSectorNo)(sectorNo - 1)) : UNASSIGNED_SECTOR);
  if( ((previousSectorAddress != UNASSIGNED_SECTOR) &&
      (previousSectorAddress != DELETED_SECTOR))    &&
      ((previousSectorAddress >> (vol.unitSizeBits - SECTOR_SIZE_BITS)) < vol.noOfUnits) ) {
    allocationUnit =
	vol.logicalUnits[(UnitNo)(previousSectorAddress >> (vol.unitSizeBits - SECTOR_SIZE_BITS))];
    if (allocationUnit->noOfFreeSectors > 0) {
      unsigned int sectorIndex = ((unsigned) previousSectorAddress & (vol.sectorsPerUnit - 1)) + 1;
      LEulong FAR0 *nextSectorAddress =
	   (LEulong FAR0 *) vol.flash.map(&vol.flash,
                                     physicalBase(&vol,allocationUnit) +
                                     allocEntryOffset(&vol, sectorIndex),
                                     sizeof(VirtualAddress));
      if (sectorIndex < vol.sectorsPerUnit && LE4(*nextSectorAddress) == FREE_SECTOR) {
	/* can write sequentially */
	*newAddress = previousSectorAddress + 1;
	return flOK;
      }
    }
    else
      allocationUnit = NULL;	/* no space here, try elsewhere */
  }

  if (allocationUnit == NULL)
    allocationUnit = bestUnitToAllocate(&vol);
  if (allocationUnit == NULL)	/* No ? then all is lost */
    return flGeneralFailure;

  unitHeader = mapUnitHeader(&vol,allocationUnit,&blockAllocMap);
  for (iSector = vol.unitHeaderSectors; iSector < vol.sectorsPerUnit; iSector++) {
    if (LE4(blockAllocMap[iSector]) == FREE_SECTOR) {
      *newAddress = ((LogicalSectorNo) (LE2(unitHeader->logicalUnitNo)) << (vol.unitSizeBits - SECTOR_SIZE_BITS)) +
		    iSector;
      return flOK;
    }
  }

  return flGeneralFailure;	/* what are we doing here ? */
}


/*----------------------------------------------------------------------*/
/*		           m a r k A l l o c M a p			*/
/*									*/
/* Writes a new value to a BAM entry.					*/
/*                                                                      */
/* This routine also updates the free & garbage sector counts.		*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorAddress	: Logical sector no. whose BAM entry to mark	*/
/*	allocMapEntry	: New BAM entry value				*/
/*	overwrite	: Whether we are overwriting some old value	*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus markAllocMap(Flare vol,
			   LogicalSectorNo sectorAddress,
			   VirtualAddress allocMapEntry,
			   FLBoolean overwrite)
{
  UnitNo unitNo = (UnitNo) (sectorAddress >> (vol.unitSizeBits - SECTOR_SIZE_BITS));
  Unit *unit;
  int sectorInUnit = (unsigned) sectorAddress & (vol.sectorsPerUnit - 1);
  LEulong bamEntry;

  if (unitNo >= vol.noOfUnits - vol.noOfTransferUnits)
    return flGeneralFailure;

  unit = vol.logicalUnits[unitNo];

  if (allocMapEntry == GARBAGE_SECTOR)
    unit->noOfGarbageSectors++;
  else if (!overwrite) {
    unit->noOfFreeSectors--;
    vol.totalFreeSectors--;
  }

  toLE4(bamEntry,allocMapEntry);

  return flashWrite(&vol,
		    physicalBase(&vol,unit) + allocEntryOffset(&vol,sectorInUnit),
		    &bamEntry,
		    sizeof bamEntry,
		    (word)overwrite);
}


/*----------------------------------------------------------------------*/
/*      	      d e l e t e L o g i c a l S e c t o r		*/
/*									*/
/* Marks a logical sector as deleted.					*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorAddress	: Logical sector no. to delete			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus deleteLogicalSector(Flare vol,  LogicalSectorNo sectorAddress)
{
  if (sectorAddress == UNASSIGNED_SECTOR ||
      sectorAddress == DELETED_SECTOR)
    return flOK;

  return markAllocMap(&vol,sectorAddress,GARBAGE_SECTOR,TRUE);
}


/* forward definition */
static FLStatus setVirtualMap(Flare vol,
			    VirtualSectorNo sectorNo,
			    LogicalSectorNo newAddress);


/*----------------------------------------------------------------------*/
/*      	     a l l o c a t e A n d W r i t e S e c t o r	*/
/*									*/
/* Allocates a sector or replacement page and (optionally) writes it.	*/
/*                                                                      */
/* An allocated replacement page also becomes the active replacement 	*/
/* page.								*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo	: Virtual sector no. to write			*/
/*	fromAddress	: Address of sector data. If NULL, sector is	*/
/*			  not written.					*/
/*	replacementPage	: This is a replacement page sector.		*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus allocateAndWriteSector(Flare vol,
				     VirtualSectorNo sectorNo,
				     void FAR1 *fromAddress,
				     FLBoolean replacementPage)
{
  FLStatus status;
  LogicalSectorNo sectorAddress;
  VirtualAddress bamEntry =
	((VirtualAddress) sectorNo - vol.noOfPages) << SECTOR_SIZE_BITS;
  long sectorsNeeded = 1;

  checkStatus(defragment(&vol,&sectorsNeeded));  /* Organize a free sector */

  checkStatus(findFreeSector(&vol,sectorNo,&sectorAddress));

  if (replacementPage)
    bamEntry |= REPLACEMENT_PAGE;
  else
    bamEntry |= DATA_SECTOR;

  status = markAllocMap(&vol,
			sectorAddress,
			sectorNo < (VirtualSectorNo)vol.directAddressingSectors ?
			  ALLOCATED_SECTOR : bamEntry,
			FALSE);

  if( status == flOK && fromAddress) {
    CardAddress physAddress = logical2Physical(&vol,sectorAddress);
    if( physAddress == UNASSIGNED_ADDRESS )
      return flGeneralFailure;

    status = flashWrite(&vol,
                        physAddress,
			fromAddress,
			SECTOR_SIZE,
			0);
  }

  if (sectorNo < (VirtualSectorNo)vol.directAddressingSectors && status == flOK)
    status = markAllocMap(&vol,
			  sectorAddress,
			  bamEntry,
			  TRUE);

  if (status == flOK)
    if (replacementPage) {
      vol.replacementPageAddress = sectorAddress;
      vol.replacementPageNo = sectorNo;
    }
    else
      status = setVirtualMap(&vol,sectorNo,sectorAddress);

  if (status != flOK)
    markAllocMap(&vol,sectorAddress,GARBAGE_SECTOR,TRUE);

  return status;
}


/*----------------------------------------------------------------------*/
/*      	     c l o s e R e p l a c e m e n t P a g e		*/
/*									*/
/* Closes the replacement page by merging it with the primary page.	*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus closeReplacementPage(Flare vol)
{
  FLStatus status;
  CardAddress physAddress;

#ifdef SINGLE_BUFFER
  int i;
  LogicalSectorNo nextReplacementPageAddress = vol.replacementPageAddress;
  VirtualSectorNo firstSectorNo =
	((VirtualSectorNo) vol.replacementPageNo << (PAGE_SIZE_BITS - SECTOR_SIZE_BITS)) +
    vol.noOfPages;
pageRetry:
  for (i = 0; i < ADDRESSES_PER_SECTOR; i++) {
    LogicalSectorNo logicalSectorNo = virtual2Logical(&vol,firstSectorNo + i);
    LEulong entryToWrite;
    toLE4(entryToWrite,logicalSectorNo == UNASSIGNED_SECTOR ?
		       UNASSIGNED_ADDRESS :
		       (LogicalAddress) logicalSectorNo << SECTOR_SIZE_BITS);
    physAddress = logical2Physical(&vol,nextReplacementPageAddress);
    if( physAddress == UNASSIGNED_ADDRESS )
      return flGeneralFailure;

    if (flashWrite(&vol,
                   physAddress + i * sizeof(LogicalAddress),
		   &entryToWrite,
		   sizeof entryToWrite,
		   OVERWRITE) != flOK)
      break;
  }

  if (i < ADDRESSES_PER_SECTOR &&
      nextReplacementPageAddress == vol.replacementPageAddress) {
    /* Uh oh. Trouble. Let's replace this replacement page. */
    LogicalSectorNo prevReplacementPageAddress = vol.replacementPageAddress;

    checkStatus(allocateAndWriteSector(&vol,vol.replacementPageNo,NULL,TRUE));
    nextReplacementPageAddress = vol.replacementPageAddress;
    vol.replacementPageAddress = prevReplacementPageAddress;
    goto pageRetry;
  }

  if (nextReplacementPageAddress != vol.replacementPageAddress) {
    LogicalSectorNo prevReplacementPageAddress = vol.replacementPageAddress;
    vol.replacementPageAddress = nextReplacementPageAddress;
    checkStatus(deleteLogicalSector(&vol,prevReplacementPageAddress));
  }
#else
  status = setupMapCache(&vol,(unsigned)vol.replacementPageNo);  /* read replacement page into map cache */
  if( status != flOK )
    return flGeneralFailure;
  physAddress = logical2Physical(&vol,vol.replacementPageAddress);
  if( physAddress == UNASSIGNED_ADDRESS )
    return flGeneralFailure;

  status = flashWrite(&vol,
                      physAddress,
                      mapCache, SECTOR_SIZE, OVERWRITE);
  if (status != flOK) {
    /* Uh oh. Trouble. Let's replace this replacement page. */
    LogicalSectorNo prevReplacementPageAddress = vol.replacementPageAddress;

    checkStatus(allocateAndWriteSector(&vol,vol.replacementPageNo,mapCache,TRUE));
    checkStatus(deleteLogicalSector(&vol,prevReplacementPageAddress));
  }
#endif
  checkStatus(setVirtualMap(&vol,vol.replacementPageNo,vol.replacementPageAddress));
  checkStatus(markAllocMap(&vol,
			   vol.replacementPageAddress,
			   (((VirtualAddress) vol.replacementPageNo - vol.noOfPages)
				<< SECTOR_SIZE_BITS) | DATA_SECTOR,
			   TRUE));

  vol.replacementPageNo = UNASSIGNED_SECTOR;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	          s e t V i r t u a l M a p			*/
/*									*/
/* Changes an entry in the virtual map					*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo	: Virtual sector no. whose entry is changed.	*/
/*	newAddress	: Logical sector no. to assign in Virtual Map.	*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus setVirtualMap(Flare vol,
			    VirtualSectorNo sectorNo,
			    LogicalSectorNo newAddress)
{
  unsigned pageNo;
  int sectorInPage;
  CardAddress virtualMapEntryAddress;
  LEulong addressToWrite;
  LogicalAddress oldAddress;
  LogicalSectorNo updatedPage;
  CardAddress physAddress;

  vol.mappedSectorNo = UNASSIGNED_SECTOR;

  if (sectorNo < (VirtualSectorNo)vol.directAddressingSectors) {
    checkStatus(deleteLogicalSector(&vol,vol.pageTable[(unsigned)sectorNo]));
    vol.pageTable[(unsigned)sectorNo] = newAddress;
    return flOK;
  }
  sectorNo -= vol.noOfPages;

  pageNo = (unsigned)(sectorNo >> (PAGE_SIZE_BITS - SECTOR_SIZE_BITS));
  sectorInPage = (int) (sectorNo % ADDRESSES_PER_SECTOR);
  updatedPage = vol.pageTable[pageNo];
  physAddress = logical2Physical(&vol,updatedPage);
  if( physAddress == UNASSIGNED_ADDRESS )
    return flGeneralFailure;
  virtualMapEntryAddress = physAddress +
                         sectorInPage * sizeof(LogicalAddress);
  oldAddress = LE4(*(LEulong FAR0 *)
	vol.flash.map(&vol.flash,virtualMapEntryAddress,sizeof(LogicalAddress)));

  if (oldAddress == DELETED_ADDRESS && vol.replacementPageNo == pageNo) {
    updatedPage = vol.replacementPageAddress;
    physAddress = logical2Physical(&vol,updatedPage);
    if( physAddress == UNASSIGNED_ADDRESS )
      return flGeneralFailure;
    virtualMapEntryAddress = physAddress +
                         sectorInPage * sizeof(LogicalAddress);
    oldAddress = LE4(*(LEulong FAR0 *)
	  vol.flash.map(&vol.flash,virtualMapEntryAddress,sizeof(LogicalAddress)));
  }

  if (newAddress == DELETED_ADDRESS && oldAddress == UNASSIGNED_ADDRESS)
    return flOK;

  toLE4(addressToWrite,(LogicalAddress) newAddress << SECTOR_SIZE_BITS);
  if (cannotWriteOver(LE4(addressToWrite),oldAddress)) {
    FLStatus status;

    if (pageNo != vol.replacementPageNo ||
        updatedPage == vol.replacementPageAddress) {
      if (vol.replacementPageNo != UNASSIGNED_SECTOR)
        checkStatus(closeReplacementPage(&vol));
      checkStatus(allocateAndWriteSector(&vol,(VirtualSectorNo)pageNo,NULL,TRUE));
    }

    physAddress = logical2Physical(&vol,vol.replacementPageAddress);
    if( physAddress == UNASSIGNED_ADDRESS )
      return flGeneralFailure;

    status = flashWrite(&vol,
                        physAddress + sectorInPage * sizeof(LogicalAddress),
			&addressToWrite,
			sizeof addressToWrite,
			0);
    if (status != flOK) {
      closeReplacementPage(&vol);
				/* we may get a write-error because a
				   previous cache update did not complete. */
      return status;
    }
    toLE4(addressToWrite,DELETED_ADDRESS);
    updatedPage = vol.pageTable[pageNo];
  }

  physAddress = logical2Physical(&vol,updatedPage);
  if( physAddress == UNASSIGNED_ADDRESS )
    return flGeneralFailure;
  checkStatus( flashWrite(&vol,
                         physAddress + sectorInPage * sizeof(LogicalAddress),
			 &addressToWrite,
			 (dword)sizeof addressToWrite,
			 (word)oldAddress |= UNASSIGNED_ADDRESS));

#ifndef SINGLE_BUFFER
  if (buffer.sectorNo == pageNo && buffer.owner == &vol)
    toLE4(mapCache[sectorInPage],(LogicalAddress) newAddress << SECTOR_SIZE_BITS);
#endif

  return deleteLogicalSector(&vol,(LogicalSectorNo) (oldAddress >> SECTOR_SIZE_BITS));
}


/*----------------------------------------------------------------------*/
/*      	     c h e c k F o r W r i t e I n p l a c e		*/
/*									*/
/* Checks possibility for writing Flash data inplace.			*/
/*									*/
/* Parameters:                                                          */
/*	newData		: New data to write.				*/
/*	oldData		: Old data at this location.			*/
/*                                                                      */
/* Returns:                                                             */
/*	< 0	=>	Writing inplace not possible			*/
/*	>= 0	=>	Writing inplace is possible. Value indicates    */
/*			how many bytes at the start of data are		*/
/*			identical and may be skipped.			*/
/*----------------------------------------------------------------------*/

static int checkForWriteInplace(long FAR1 *newData,
				long FAR0 *oldData)
{
  int i;

  int skipBytes = 0;
  FLBoolean stillSame = TRUE;

  for (i = SECTOR_SIZE / sizeof *newData; i > 0; i--, newData++, oldData++) {
    if (cannotWriteOver(*newData,*oldData))
      return -1;
    if (stillSame && *newData == *oldData)
      skipBytes += sizeof *newData;
    else
      stillSame = FALSE;
  }

  return skipBytes;
}


/*----------------------------------------------------------------------*/
/*      	              i n i t F T L				*/
/*									*/
/* Initializes essential volume data as a preparation for mount or	*/
/* format.								*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	flash		: Flash media mounted on this socket		*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus initFTL(Flare vol, FLFlash *flash)
{
  long int size = 1;

  if (flash == NULL) {
    DEBUG_PRINT(("Debug: media is not fit for FTL format.\n"));
    return flUnknownMedia;
  }

  vol.flash = *flash;
  for (vol.erasableBlockSizeBits = 0; ((unsigned int)size )< vol.flash.erasableBlockSize;
       vol.erasableBlockSizeBits++, size <<= 1);
  vol.unitSizeBits = vol.erasableBlockSizeBits;
  if (vol.unitSizeBits < 16)
    vol.unitSizeBits = 16;		/* At least 64 KB */
  vol.noOfUnits = (unsigned) ((vol.flash.noOfChips * vol.flash.chipSize) >> vol.unitSizeBits);
  vol.unitOffsetMask = (1L << vol.unitSizeBits) - 1;
  vol.sectorsPerUnit = 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS);
  vol.bamOffset = sizeof(UnitHeader);
  vol.unitHeaderSectors = ((allocEntryOffset(&vol,vol.sectorsPerUnit) - 1) >>
				    SECTOR_SIZE_BITS) + 1;

  vol.transferUnit = NULL;
  vol.replacementPageNo = UNASSIGNED_SECTOR;
  vol.badFormat = TRUE;	/* until mount completes */
  vol.mappedSectorNo = UNASSIGNED_SECTOR;

  vol.currWearLevelingInfo = 0;

#ifdef FL_BACKGROUND
  vol.unitEraseInProgress = NULL;
  vol.garbageCollectStatus = flOK;
  vol.mirrorOffset = 0;
#endif

  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	            i n i t T a b l e s				*/
/*									*/
/* Allocates and initializes the dynamic volume table, including the	*/
/* unit tables and secondary virtual map.				*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus initTables(Flare vol)
{
  unsigned iSector;
  UnitNo iUnit;

  /* Allocate the conversion tables */
#ifdef MALLOC
  vol.physicalUnits = (Unit *) MALLOC(vol.noOfUnits * sizeof(Unit));
  vol.logicalUnits = (UnitPtr *) MALLOC(vol.noOfUnits * sizeof(UnitPtr));
  vol.pageTable = (LogicalSectorNo *)
	     MALLOC(vol.directAddressingSectors * sizeof(LogicalSectorNo));
  if (vol.physicalUnits == NULL ||
      vol.logicalUnits == NULL ||
      vol.pageTable == NULL) {
    dismountFTL(&vol);
    return flNotEnoughMemory;
  }
#else
  char *heapPtr;

  heapPtr = vol.heap;
  vol.physicalUnits = (Unit *) heapPtr;
  heapPtr += vol.noOfUnits * sizeof(Unit);
  vol.logicalUnits = (UnitPtr *) heapPtr;
  heapPtr += vol.noOfUnits * sizeof(UnitPtr);
  vol.pageTable = (LogicalSectorNo *) heapPtr;
  heapPtr += vol.directAddressingSectors * sizeof(LogicalSectorNo);
  if (heapPtr > vol.heap + sizeof vol.heap)
    return flNotEnoughMemory;
#endif

#ifndef SINGLE_BUFFER
  vol.volBuffer = flBufferOf(flSocketNoOf(vol.flash.socket));
#endif

  buffer.sectorNo = UNASSIGNED_SECTOR;

  for (iSector = 0; iSector < vol.directAddressingSectors; iSector++)
    vol.pageTable[iSector] = UNASSIGNED_SECTOR;

  for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++)
    vol.logicalUnits[iUnit] = NULL;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	             m a p S e c t o r				*/
/*									*/
/* Maps and returns location of a given sector no.			*/
/* NOTE: This function is used in place of a read-sector operation.	*/
/*									*/
/* A one-sector cache is maintained to save on map operations.		*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo	: Sector no. to read				*/
/*	physAddress	: Optional pointer to receive sector address	*/
/*                                                                      */
/* Returns:                                                             */
/*	Pointer to physical sector location. NULL returned if sector	*/
/*	does not exist.							*/
/*----------------------------------------------------------------------*/

static const void FAR0 *mapSector(Flare vol, SectorNo sectorNo, CardAddress *physAddress)
{
  if (sectorNo != vol.mappedSectorNo || vol.flash.socket->remapped) {
    LogicalSectorNo sectorAddress;

    if (sectorNo >= vol.virtualSectors)
      vol.mappedSector = NULL;
    else {
      sectorAddress = virtual2Logical(&vol,((VirtualSectorNo)(sectorNo + vol.noOfPages)));

      if (sectorAddress == UNASSIGNED_SECTOR || sectorAddress == DELETED_SECTOR)
        vol.mappedSector = NULL;          /* no such sector */
      else {
	vol.mappedSectorAddress = logical2Physical(&vol,sectorAddress);
        if( vol.mappedSectorAddress == UNASSIGNED_ADDRESS )
          vol.mappedSector = NULL;        /* no such sector */
        else
          vol.mappedSector = vol.flash.map(&vol.flash,
					 vol.mappedSectorAddress,
					 SECTOR_SIZE);
      }
    }
    vol.mappedSectorNo = sectorNo;
    vol.flash.socket->remapped = FALSE;
  }

  if (physAddress)
    *physAddress = vol.mappedSectorAddress;

  return vol.mappedSector;
}


/*----------------------------------------------------------------------*/
/*      	          w r i t e S e c t o r				*/
/*									*/
/* Writes a sector.							*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo	: Sector no. to write				*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus writeSector(Flare vol,  SectorNo sectorNo, void FAR1 *fromAddress)
{
  LogicalSectorNo oldSectorAddress;
  int skipBytes;
  FLStatus status;
  void FAR0 *logicalAddr;

  if (vol.badFormat)
    return flBadFormat;
  if (sectorNo >= vol.virtualSectors)
    return flSectorNotFound;

  sectorNo += vol.noOfPages;
  oldSectorAddress = virtual2Logical(&vol,sectorNo);

  if( oldSectorAddress != UNASSIGNED_SECTOR && oldSectorAddress != DELETED_SECTOR ) {
    logicalAddr = mapLogical(&vol,oldSectorAddress);
    if( logicalAddr == (void FAR0 *) ULongToPtr(UNASSIGNED_ADDRESS) )
      return flGeneralFailure;
  }

  if( ((oldSectorAddress != UNASSIGNED_SECTOR) &&
       (oldSectorAddress != DELETED_SECTOR)) &&
       ((skipBytes = checkForWriteInplace((long FAR1 *) fromAddress,
           (long FAR0 *) logicalAddr)) >= 0) ) {
    if( skipBytes < SECTOR_SIZE ) {
      CardAddress physAddress = logical2Physical(&vol,oldSectorAddress);
      if( physAddress == UNASSIGNED_ADDRESS )
        return flGeneralFailure;

      status = flashWrite(&vol,
                          physAddress + skipBytes,
			  (char FAR1 *) fromAddress + skipBytes,
			  SECTOR_SIZE - skipBytes,
			  OVERWRITE);
    }
    else
      status = flOK;		/* nothing to write */
  }
  else
    status = allocateAndWriteSector(&vol,sectorNo,fromAddress,FALSE);

  if (status == flWriteFault)		/* Automatic retry */
    status = allocateAndWriteSector(&vol,sectorNo,fromAddress,FALSE);

  return status;
}


/*----------------------------------------------------------------------*/
/*      	          t l S e t B u s y				*/
/*									*/
/* Notifies the start and end of a file-system operation.		*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*      state		: ON (1) = operation entry			*/
/*			  OFF(0) = operation exit			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus tlSetBusy(Flare vol, FLBoolean state)
{
#ifdef FL_BACKGROUND
  if (vol.unitEraseInProgress)
    flBackground(state == ON ? BG_SUSPEND : BG_RESUME);
#endif

  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	         d e l e t e S e c t o r			*/
/*									*/
/* Marks contiguous sectors as deleted					*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*	sectorNo	: First sector no. to delete			*/
/*	noOfSectors	: No. of sectors to delete			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus deleteSector(Flare vol,  SectorNo sectorNo, SectorNo noOfSectors)
{
  SectorNo iSector;

  if (vol.badFormat)
    return flBadFormat;
  if (sectorNo + noOfSectors > vol.virtualSectors)
    return flSectorNotFound;

  sectorNo += vol.noOfPages;
  for (iSector = 0; iSector < noOfSectors; iSector++, sectorNo++)
    checkStatus(setVirtualMap(&vol,sectorNo,DELETED_SECTOR));

  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	        s e c t o r s I n V o l u m e			*/
/*									*/
/* Gets the total number of sectors in the volume			*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*                                                                      */
/* Returns:                                                             */
/*	Number of sectors in the volume					*/
/*----------------------------------------------------------------------*/

static SectorNo sectorsInVolume(Flare vol)
{
  return vol.virtualSectors;
}


/*----------------------------------------------------------------------*/
/*      	         d i s m o u n t F T L				*/
/*									*/
/* Dismount FTL volume							*/
/*									*/
/* Parameters:                                                          */
/*	vol		: Pointer identifying drive			*/
/*									*/
/*----------------------------------------------------------------------*/

static void dismountFTL(Flare vol)
{
#ifdef MALLOC
  if( vol.physicalUnits != NULL )
    FREE(vol.physicalUnits);
  if( vol.logicalUnits != NULL )
    FREE(vol.logicalUnits);
  if( vol.pageTable != NULL )
    FREE(vol.pageTable);
  vol.physicalUnits = NULL;
  vol.logicalUnits = NULL;
  vol.pageTable = NULL;
#ifdef NT5PORT
  if( vol.flash.readBuffer != NULL ) {
    FREE(vol.flash.readBuffer);
    vol.flash.readBuffer = NULL;
  }
#endif /* NT5PORT */
#endif /* MALLOC */
}


#ifdef FORMAT_VOLUME
/*----------------------------------------------------------------------*/
/*      	           f o r m a t F T L				*/
/*									*/
/* Formats the Flash volume for FTL					*/
/*									*/
/* Parameters:                                                          */
/*	volNo		: Volume no.					*/
/*	formatParams	: Address of FormatParams structure to use	*/
/*	flash		: Flash media mounted on this socket		*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus formatFTL(unsigned volNo, TLFormatParams FAR1 *formatParams, FLFlash *flash)
{
  Flare vol = &vols[volNo];
  UnitNo iUnit;
  int iPage;
  unsigned iSector, noOfBadUnits = 0;
  LEulong *formatEntries;
  FLStatus status;


	DEBUG_PRINT(("Debug: formatFTL(): Start ... .\n"));
  checkStatus(initFTL(&vol,flash));

  if(formatParams->bootImageLen<0)
    formatParams->bootImageLen = 0;
  vol.firstPhysicalEUN =
      (UnitNo) ((formatParams->bootImageLen - 1) >> vol.unitSizeBits) + 1;
  vol.noOfTransferUnits = (UnitNo)formatParams->noOfSpareUnits;
  if (vol.noOfUnits <= vol.firstPhysicalEUN + formatParams->noOfSpareUnits)
    return flVolumeTooSmall;

  vol.virtualSectors = (SectorNo)((unsigned long) (vol.noOfUnits - vol.firstPhysicalEUN - formatParams->noOfSpareUnits) *
		   (vol.sectorsPerUnit - vol.unitHeaderSectors) *
		   formatParams->percentUse / 100);
  vol.noOfPages = (int)(((long) vol.virtualSectors * SECTOR_SIZE - 1) >> PAGE_SIZE_BITS) + 1;
  /* take off size of virtual table, and one extra sector for sector writes */
  vol.virtualSectors -= (vol.noOfPages + 1);

  vol.directAddressingMemory = formatParams->vmAddressingLimit;
  vol.directAddressingSectors = (unsigned) (formatParams->vmAddressingLimit / SECTOR_SIZE) +
				vol.noOfPages;

  checkStatus(initTables(&vol));

  tffsset(uh,0xff,SECTOR_SIZE);
  toLE2(uh->noOfUnits,vol.noOfUnits - vol.firstPhysicalEUN);
  toLE2(uh->firstPhysicalEUN,vol.firstPhysicalEUN);
  uh->noOfTransferUnits = (unsigned char) vol.noOfTransferUnits;
  tffscpy(uh->formatPattern,FORMAT_PATTERN,sizeof uh->formatPattern);
  uh->log2SectorSize = SECTOR_SIZE_BITS;
  uh->log2UnitSize = (unsigned char)vol.unitSizeBits;
  toLE4(uh->directAddressingMemory,vol.directAddressingMemory);
  uh->flags = 0;
  uh->eccCode = 0xff;
  toLE4(uh->serialNumber,0);
  toLE4(uh->altEUHoffset,0);
  toLE4(uh->virtualMediumSize,(long)vol.virtualSectors * SECTOR_SIZE);
  toLE2(uh->noOfPages,(unsigned short)vol.noOfPages);

  if (formatParams->embeddedCISlength > 0) {
    tffscpy(uh->embeddedCIS,formatParams->embeddedCIS,formatParams->embeddedCISlength);
    vol.bamOffset = sizeof(UnitHeader) - sizeof uh->embeddedCIS +
		    (formatParams->embeddedCISlength + 3) / 4 * 4;
  }
  toLE4(uh->BAMoffset,vol.bamOffset);

  formatEntries = (LEulong *) ((char *) uh + allocEntryOffset(&vol,0));
  for (iSector = 0; iSector < vol.unitHeaderSectors; iSector++)
    toLE4(formatEntries[iSector], FORMAT_SECTOR);

  for (iUnit = vol.firstPhysicalEUN; iUnit < vol.noOfUnits; iUnit++) {
    status = formatUnit(&vol,&vol.physicalUnits[iUnit]);
    if (status != flOK)
      status = formatUnit(&vol,&vol.physicalUnits[iUnit]);	/* Do it again */
    if (status == flWriteFault) {
      noOfBadUnits++;
      if (noOfBadUnits >= formatParams->noOfSpareUnits) {
        dismountFTL(&vol);  /*Free memory allocated in initTables*/
        return status;
      }
      else
        vol.transferUnit = &vol.physicalUnits[iUnit];
    }
    else if (status == flOK) {
      if (iUnit - noOfBadUnits < (unsigned)(vol.noOfUnits - formatParams->noOfSpareUnits)) {
        status = assignUnit(&vol,
                     &vol.physicalUnits[iUnit],
                     (UnitNo)(iUnit - noOfBadUnits));
        if( status != flOK ) {
          dismountFTL(&vol);  /*Free memory allocated in initTables*/
          return status;
        }
        vol.physicalUnits[iUnit].noOfFreeSectors = vol.sectorsPerUnit - vol.unitHeaderSectors;
        vol.logicalUnits[iUnit - noOfBadUnits] = &vol.physicalUnits[iUnit];
      }
      else
        vol.transferUnit = &vol.physicalUnits[iUnit];
    }
    else {
      dismountFTL(&vol);  /*Free memory allocated in initTables*/
      return status;
    }
    if (formatParams->progressCallback) {
      status = (*formatParams->progressCallback)
                  ((word)(vol.noOfUnits - vol.firstPhysicalEUN),
                  (word)((iUnit + 1) - vol.firstPhysicalEUN));
      if( status != flOK ) {
        dismountFTL(&vol);  /*Free memory allocated in initTables*/
        return status;
      }
    }
  }

  /* Allocate and write all page sectors */
  vol.totalFreeSectors = 1000;	/* Avoid any nuisance garbage collections */

  for (iPage = 0; iPage < vol.noOfPages; iPage++) {
    status = allocateAndWriteSector(&vol,(VirtualSectorNo)iPage,NULL,FALSE);
    if( status != flOK ) {
      dismountFTL(&vol);  /*Free memory allocated in initTables*/
      return status;
    }
  }
  dismountFTL(&vol);  /*Free memory allocated in initTables*/
	DEBUG_PRINT(("Debug: formatFTL(): Finished :)\n"));
  return flOK;
}

#endif


/*----------------------------------------------------------------------*/
/*      	           m o u n t F T L				*/
/*									*/
/* Mount FTL volume							*/
/*									*/
/* Parameters:                                                          */
/*	volNo		: Volume no.					*/
/*	tl		: Where to store translation layer methods	*/
/*	flash		: Flash media mounted on this socket		*/
/*      volForCallback	: Pointer to FLFlash structure for power on	*/
/*			  callback routine.				*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

static FLStatus mountFTL(unsigned volNo, TL *tl, FLFlash *flash, FLFlash **volForCallback)
{
  Flare vol = &vols[volNo];
  UnitHeader unitHeader;
  UnitNo iUnit;
  int iPage;


  DEBUG_PRINT(("Debug: mountFTL(): Start ...\n"));
  tffsset(&unitHeader,0,sizeof(UnitHeader));

  checkStatus(initFTL(&vol,flash));
  *volForCallback = &vol.flash;

  /* Find the first properly formatted unit */
  for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++) {
    vol.flash.read(&vol.flash,
	       (CardAddress) iUnit << vol.unitSizeBits,
	       &unitHeader,
	       sizeof(UnitHeader),
	       0);
    if (verifyFormat(&unitHeader)) {
      if (unitHeader.flags || unitHeader.log2SectorSize != SECTOR_SIZE_BITS ||
          (unitHeader.eccCode != 0xff && unitHeader.eccCode != 0)) {
        dismountFTL(&vol);
	return flBadFormat;
      }
      break;
    }
  }
  if (iUnit >= vol.noOfUnits) {
    dismountFTL(&vol);
		DEBUG_PRINT(("Debug: mountFTL(): failed for unit Header\n"));
    return flUnknownMedia;
  }

  

  /* Get volume information from unit header */
  vol.noOfUnits = LE2(unitHeader.noOfUnits);
  vol.noOfTransferUnits = unitHeader.noOfTransferUnits;
  vol.firstPhysicalEUN = LE2(unitHeader.firstPhysicalEUN);
  vol.bamOffset = LE4(unitHeader.BAMoffset);
  vol.virtualSectors = (SectorNo) (LE4(unitHeader.virtualMediumSize) >> SECTOR_SIZE_BITS);
  vol.noOfPages = LE2(unitHeader.noOfPages);
  vol.noOfUnits += vol.firstPhysicalEUN;
  vol.unitSizeBits = unitHeader.log2UnitSize;
  vol.directAddressingMemory = LE4(unitHeader.directAddressingMemory);
  vol.directAddressingSectors = vol.noOfPages +
		  (unsigned) (vol.directAddressingMemory >> SECTOR_SIZE_BITS);

  vol.unitOffsetMask = (1L << vol.unitSizeBits) - 1;
  vol.sectorsPerUnit = 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS);
  vol.unitHeaderSectors = ((allocEntryOffset(&vol,vol.sectorsPerUnit) - 1) >>
				    SECTOR_SIZE_BITS) + 1;

  if (vol.noOfUnits <= vol.firstPhysicalEUN ||
      LE4(unitHeader.virtualMediumSize) > MAX_VOLUME_MBYTES * 0x100000l ||
      allocEntryOffset(&vol,vol.unitHeaderSectors) > SECTOR_SIZE ||
      (int)(vol.virtualSectors >> (PAGE_SIZE_BITS - SECTOR_SIZE_BITS)) > vol.noOfPages ||
      (int)(vol.virtualSectors >> (vol.unitSizeBits - SECTOR_SIZE_BITS)) > (vol.noOfUnits - vol.firstPhysicalEUN)) {
    dismountFTL(&vol);
    return flBadFormat;
  }

  checkStatus(initTables(&vol));
  
  vol.totalFreeSectors = 0;

  /* Mount all units */
  for (iUnit = vol.firstPhysicalEUN; iUnit < vol.noOfUnits; iUnit++)
    mountUnit(&vol,&vol.physicalUnits[iUnit]);

  /* Verify the conversion tables */
  vol.badFormat = FALSE;

  for (iUnit = vol.firstPhysicalEUN; iUnit < vol.noOfUnits - vol.noOfTransferUnits; iUnit++)
    if (vol.logicalUnits[iUnit] == NULL)
      vol.badFormat = TRUE;

  if (vol.replacementPageNo != UNASSIGNED_SECTOR &&
      vol.pageTable[(unsigned)vol.replacementPageNo] == UNASSIGNED_SECTOR) {
    /* A lonely replacement page. Mark it as a regular page (may fail   */
    /* because of write protection) and use it.				*/
    markAllocMap(&vol,
		  vol.replacementPageAddress,
		  (((VirtualAddress) vol.replacementPageNo - vol.noOfPages)
		      << SECTOR_SIZE_BITS) | DATA_SECTOR,
		  TRUE);
    vol.pageTable[(unsigned)vol.replacementPageNo] = vol.replacementPageAddress;
    vol.replacementPageNo = UNASSIGNED_SECTOR;
  }

  for (iPage = 0; iPage < vol.noOfPages; iPage++)
    if (vol.pageTable[iPage] == UNASSIGNED_SECTOR)
      vol.badFormat = TRUE;

  tl->rec = &vol;
  tl->mapSector = mapSector;
  tl->writeSector = writeSector;
  tl->deleteSector = deleteSector;
#if defined(DEFRAGMENT_VOLUME) || defined(SINGLE_BUFFER)
  tl->defragment = defragment;
#endif
  tl->sectorsInVolume = sectorsInVolume;
  tl->tlSetBusy = tlSetBusy;
  tl->dismount = dismountFTL;

  tl->writeMultiSector = NULL;
  tl->readSectors = NULL;

  if( vol.badFormat ) {
    dismountFTL(&vol);
    return flBadFormat;
  }
	DEBUG_PRINT(("Debug: mountFTL(): Finished OK! :)\n"));
  return flOK;
}


/*----------------------------------------------------------------------*/
/*      	        f l R e g i s t e r F T L			*/
/*									*/
/* Register this translation layer					*/
/*									*/
/* Parameters:                                                          */
/*	None								*/
/*                                                                      */
/* Returns:								*/
/* 	FLStatus 	: 0 on succes, otherwise failure		*/
/*----------------------------------------------------------------------*/

FLStatus flRegisterFTL(void)
{
#ifdef MALLOC
  unsigned i,j;
#endif
  j = 0x11223344;
  PRINTF("flRegisterFTL():Started ... \n");
  if (noOfTLs >= TLS)
    return flTooManyComponents;
  PRINTF("flRegisterFTL():SUSU TEST @@@@@@@@@@@@@@@ = %x \n",j);	
  tlTable[noOfTLs].mountRoutine = mountFTL;
  PRINTF("flRegisterFTL():tlTable[noOfTLs].mountRoutine = %x \n",tlTable[noOfTLs].mountRoutine);
#ifdef FORMAT_VOLUME
  tlTable[noOfTLs].formatRoutine = formatFTL;
#else
  tlTable[noOfTLs].formatRoutine = noFormat;
  tlTable[noOfTLs].preMountRoutine  = NULL;
#endif
  noOfTLs++;

#ifdef MALLOC
  for(i=0;( i < SOCKETS );i++) {
    vols[i].physicalUnits = NULL;
    vols[i].logicalUnits = NULL;
    vols[i].pageTable = NULL;
  }
#endif

  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\i28f008.c ===
/*
 * $Log:   V:/i28f008.c_v  $
 *
 *    Rev 1.16	 06 Oct 1997 18:37:30	ANDRY
 * no COBUX
 *
 *    Rev 1.15	 05 Oct 1997 19:11:08	ANDRY
 * COBUX (Motorola M68360 16-bit only board)
 *
 *    Rev 1.14	 05 Oct 1997 14:35:36	ANDRY
 * flNeedVpp() and flDontNeedVpp() are under #ifdef SOCKET_12_VOLTS
 *
 *    Rev 1.13	 10 Sep 1997 16:18:10	danig
 * Got rid of generic names
 *
 *    Rev 1.12	 04 Sep 1997 18:47:20	danig
 * Debug messages
 *
 *    Rev 1.11	 31 Aug 1997 15:06:40	danig
 * Registration routine return status
 *
 *    Rev 1.10	 24 Jul 1997 17:52:30	amirban
 * FAR to FAR0
 *
 *    Rev 1.9	21 Jul 1997 14:44:06   danig
 * No parallelLimit
 *
 *    Rev 1.8	20 Jul 1997 17:17:00   amirban
 * No watchDogTimer
 *
 *    Rev 1.7	07 Jul 1997 15:22:06   amirban
 * Ver 2.0
 *
 *    Rev 1.6	15 Apr 1997 19:16:40   danig
 * Pointer conversions.
 *
 *    Rev 1.5	29 Aug 1996 14:17:48   amirban
 * Warnings
 *
 *    Rev 1.4	18 Aug 1996 13:48:44   amirban
 * Comments
 *
 *    Rev 1.3	31 Jul 1996 14:31:10   amirban
 * Background stuff
 *
 *    Rev 1.2	04 Jul 1996 18:20:06   amirban
 * New flag field
 *
 *    Rev 1.1	03 Jun 1996 16:28:58   amirban
 * Cobra additions
 *
 *    Rev 1.0	20 Mar 1996 13:33:06   amirban
 * Initial revision.
 */

/************************************************************************/
/*									*/
/*		FAT-FTL Lite Software Development Kit			*/
/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
/*									*/
/************************************************************************/

/*----------------------------------------------------------------------*/
/*									*/
/* This MTD supports the following Flash technologies:			*/
/*									*/
/* - Intel 28F008/Cobra 8-mbit devices					*/
/* - Intel 28F016SA/28016SV/Cobra 16-mbit devices (byte-mode operation) */
/*									*/
/* And (among else), the following Flash media and cards:		*/
/*									*/
/* - Intel Series-2 PCMCIA cards					*/
/* - Intel Series-2+ PCMCIA cards					*/
/* - M-Systems ISA/Tiny/PC-104 Flash Disks				*/
/* - M-Systems NOR PCMCIA cards 					*/
/* - Intel Value-100 cards						*/
/*									*/
/*----------------------------------------------------------------------*/

#include "flflash.h"
#ifdef FL_BACKGROUND
#include "backgrnd.h"
#endif

#define flash (*pFlash)

#define SETUP_ERASE	0x20
#define SETUP_WRITE	0x40
#define CLEAR_STATUS	0x50
#define READ_STATUS	0x70
#define READ_ID 	0x90
#define SUSPEND_ERASE	0xb0
#define CONFIRM_ERASE	0xd0
#define RESUME_ERASE	0xd0
#define READ_ARRAY	0xff

#define WSM_ERROR	0x38
#define WSM_VPP_ERROR	0x08
#define WSM_SUSPENDED	0x40
#define WSM_READY	0x80

/* JEDEC ids for this MTD */
#define I28F008_FLASH	0x89a2
#define I28F016_FLASH	0x89a0
#define COBRA004_FLASH	0x89a7
#define COBRA008_FLASH	0x89a6
#define COBRA016_FLASH	0x89aa

#define MOBILE_MAX_INLV_4 0x8989
#define LDP_1MB_IN_16BIT_MODE 0x89ff

/* Definition of MTD specific vol.flags bits: */

#define NO_12VOLTS		0x100	/* Card does not need 12 Volts Vpp */

/*----------------------------------------------------------------------*/
/*			i 2 8 f 0 0 8 W r i t e 			*/
/*									*/
/* Write a block of bytes to Flash					*/
/*									*/
/* This routine will be registered as the MTD vol.write routine */
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	address 	: Card address to write to			*/
/*	buffer		: Address of data to write			*/
/*	length		: Number of bytes to write			*/
/*	overwrite	: TRUE if overwriting old Flash contents	*/
/*			  FALSE if old contents are known to be erased	*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

FLStatus i28f008Write(FLFlash vol,
			   CardAddress address,
			   const VOID FAR1 *buffer,
			   dword length,
			   word overwrite)
{
  /* Set timeout ot 5 seconds from now */
  ULONG writeTimeout = flMsecCounter + 5000;

  FLStatus status;
  ULONG i, cLength;
  FlashPTR flashPtr;


  if (flWriteProtected(vol.socket))
    return flWriteProtect;

#ifdef SOCKET_12_VOLTS
  if (!(vol.flags & NO_12VOLTS))
    checkStatus(flNeedVpp(vol.socket));
#endif

  flashPtr = (FlashPTR) flMap(vol.socket,address);
  cLength = length;

  if (vol.interleaving == 1) {
lastByte:
#ifdef __cplusplus
    #define bFlashPtr  flashPtr
    #define bBuffer ((const UCHAR FAR1 * &) buffer)
#else
    #define bFlashPtr  flashPtr
    #define bBuffer ((const UCHAR FAR1 *) buffer)
#endif
    while (cLength >= 1) {
      tffsWriteByteFlash(bFlashPtr, SETUP_WRITE);
      tffsWriteByteFlash(bFlashPtr, *bBuffer);
      cLength--;
      bBuffer++;
      bFlashPtr++;
      while (!(tffsReadByteFlash(bFlashPtr-1) & WSM_READY) && flMsecCounter < writeTimeout)
	    ;
    }
  }
  else if (vol.interleaving == 2) {
lastWord:
#ifdef __cplusplus
    #define wFlashPtr ((FlashWPTR &) flashPtr)
    #define wBuffer ((const USHORT FAR1 * &) buffer)
#else
    #define wFlashPtr ((FlashWPTR) flashPtr)
    #define wBuffer ((const USHORT FAR1 *) buffer)
#endif
    while (cLength >= 2) {
      tffsWriteWordFlash(wFlashPtr, SETUP_WRITE * 0x101);
      tffsWriteWordFlash(wFlashPtr, *wBuffer);
      cLength -= 2;
      wBuffer++;
      wFlashPtr++;
      while ((~(tffsReadWordFlash(wFlashPtr-1)) & (WSM_READY * 0x101)) && flMsecCounter < writeTimeout)
	    ;
    }
    if (cLength > 0)
      goto lastByte;
  }
  else /* if (vol.interleaving >= 4) */ {
#ifdef __cplusplus
    #define dFlashPtr ((FlashDPTR &) flashPtr)
    #define dBuffer ((const ULONG FAR1 * &) buffer)
#else
    #define dFlashPtr ((FlashDPTR) flashPtr)
    #define dBuffer ((const ULONG FAR1 *) buffer)
#endif
    while (cLength >= 4) {
      tffsWriteDwordFlash(dFlashPtr, SETUP_WRITE * 0x1010101l);
      tffsWriteDwordFlash(dFlashPtr, *dBuffer);
      cLength -= 4;
      dBuffer++;
      dFlashPtr++;
      while ((~(tffsReadDwordFlash(dFlashPtr-1)) & (WSM_READY * 0x1010101lu)) && flMsecCounter < writeTimeout)
	    ;
    }
    if (cLength > 0)
      goto lastWord;
  }

  flashPtr -= length;
  bBuffer -= length;

  status = flOK;
  for (i = 0; i < (ULONG)vol.interleaving && i < length; i++) {
    if (tffsReadByteFlash(flashPtr + i) & WSM_ERROR) {
      DEBUG_PRINT(("Debug: write failed for 8-bit Intel media.\n"));
      status = (tffsReadByteFlash(flashPtr + i) & WSM_VPP_ERROR) ? flVppFailure : flWriteFault;
      tffsWriteByteFlash(flashPtr + i, CLEAR_STATUS);
    }
    tffsWriteByteFlash(flashPtr + i, READ_ARRAY);
  }

#ifdef SOCKET_12_VOLTS
  if (!(vol.flags & NO_12VOLTS))
    flDontNeedVpp(vol.socket);
#endif

  /* verify the data */
  if (status == flOK) {
    /* compare double words */
    for (;length >= 4; length -= 4, dFlashPtr++, dBuffer++) {
	if (tffsReadDwordFlash(dFlashPtr) != *dBuffer) {
	    DEBUG_PRINT(("Debug: write failed for 8-bit Intel media in verification.\n"));
	return flWriteFault;
	}
    }

    /* compare the last bytes */
    for (; length; length--, bFlashPtr++, bBuffer++) {
	if (tffsReadByteFlash(bFlashPtr) != *bBuffer) {
	    DEBUG_PRINT(("Debug: write failed for 8-bit Intel media in verification.\n"));
	return flWriteFault;
	}
    }
  }

  return status;
}


/*----------------------------------------------------------------------*/
/*			i 2 8 f 0 0 8 E r a s e 			*/
/*									*/
/* Erase one or more contiguous Flash erasable blocks			*/
/*									*/
/* This routine will be registered as the MTD vol.erase routine */
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*	firstErasableBlock : Number of first block to erase		*/
/*	numOfErasableBlocks: Number of blocks to erase			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, failed otherwise		*/
/*----------------------------------------------------------------------*/

FLStatus i28f008Erase(FLFlash vol,
			   word firstErasableBlock,
			   word numOfErasableBlocks)
{
  LONG iBlock;

  FLStatus status = flOK;	/* unless proven otherwise */

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

#ifdef SOCKET_12_VOLTS
  if (!(vol.flags & NO_12VOLTS))
    checkStatus(flNeedVpp(vol.socket));
#endif

  for (iBlock = 0; iBlock < numOfErasableBlocks && status == flOK; iBlock++) {
    LONG j;
    FLBoolean finished;

    FlashPTR flashPtr = (FlashPTR)
	  flMap(vol.socket,
		    (firstErasableBlock + iBlock) * vol.erasableBlockSize);

    for (j = 0; j < vol.interleaving; j++) {
      tffsWriteByteFlash(flashPtr + j, SETUP_ERASE);
      tffsWriteByteFlash(flashPtr + j, CONFIRM_ERASE);
    }

    do {
#ifdef FL_BACKGROUND
      while (flForeground(1) == BG_SUSPEND) {		/* suspend */
	for (j = 0; j < vol.interleaving; j++) {
	  tffsWriteByteFlash(flashPtr + j, READ_STATUS);
	  if (!(tffsReadByteFlash(flashPtr + j) & WSM_READY)) {
	    tffsWriteByteFlash(flashPtr + j, SUSPEND_ERASE);
	    tffsWriteByteFlash(flashPtr + j, READ_STATUS);
	    while (!(tffsReadByteFlash(flashPtr + j) & WSM_READY))
	      ;
	  }
	  tffsWriteByteFlash(flashPtr + j, READ_ARRAY);
	}
      }
#endif
      finished = TRUE;
      for (j = 0; j < vol.interleaving; j++) {
	tffsWriteByteFlash(flashPtr + j, READ_STATUS);
	if (tffsReadByteFlash(flashPtr + j) & WSM_SUSPENDED) {
	  tffsWriteByteFlash(flashPtr + j, RESUME_ERASE);
	  finished = FALSE;
	}
	else if (!(tffsReadByteFlash(flashPtr + j) & WSM_READY))
	  finished = FALSE;
	else {
	  if (tffsReadByteFlash(flashPtr + j) & WSM_ERROR) {
	    DEBUG_PRINT(("Debug: erase failed for 8-bit Intel media.\n"));
	    status = (tffsReadByteFlash(flashPtr + j) & WSM_VPP_ERROR) ? flVppFailure : flWriteFault;
	    tffsWriteByteFlash(flashPtr + j, CLEAR_STATUS);
	  }
	  tffsWriteByteFlash(flashPtr + j, READ_ARRAY);
	}
    flDelayMsecs(10);
      }
    } while (!finished);
  } /* block loop */

#ifdef SOCKET_12_VOLTS
  if (!(vol.flags & NO_12VOLTS))
    flDontNeedVpp(vol.socket);
#endif

  return status;
}

/*----------------------------------------------------------------------*/
/*			  i 2 8 f 0 0 8 M a p				*/
/*									*/
/* Map through buffer. This routine will be registered as the map	*/
/* routine for this MTD.						*/
/*									*/
/* Parameters:								*/
/*	vol	: Pointer identifying drive				*/
/*	address : Flash address to be mapped.				*/
/*	length	: number of bytes to map.				*/
/*									*/
/* Returns:								*/
/*	Pointer to the buffer data was mapped to.			*/
/*									*/
/*----------------------------------------------------------------------*/

VOID FAR0 *i28f008Map (FLFlash vol, CardAddress address, int length)
{
  vol.socket->remapped = TRUE;
  return mapThroughBuffer(&vol,address,length);
}

/*----------------------------------------------------------------------*/
/*			  i 2 8 f 0 0 8 R e a d 			*/
/*									*/
/* Read some data from the flash. This routine will be registered as	*/
/* the read routine for this MTD.					*/
/*									*/
/* Parameters:								*/
/*	vol	: Pointer identifying drive				*/
/*	address : Address to read from. 				*/
/*	buffer	: buffer to read to.					*/
/*	length	: number of bytes to read (up to sector size).		*/
/*	modes	: EDC flag etc. 					*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failed.		*/
/*									*/
/*----------------------------------------------------------------------*/

FLStatus i28f008Read(FLFlash vol,
			 CardAddress address,
			 VOID FAR1 *buffer,
			 dword length,
			 word modes)
{
  ULONG i;
  UCHAR * byteBuffer;
  FlashPTR byteFlashPtr;
  ULONG * dwordBuffer = (ULONG *)buffer;
  FlashDPTR dwordFlashPtr = (FlashDPTR)flMap(vol.socket, address);

  for (i = 0; i < length - 4; i += 4, dwordBuffer++, dwordFlashPtr++) {
    *dwordBuffer = tffsReadDwordFlash(dwordFlashPtr);
  }
  byteBuffer = (UCHAR *)dwordBuffer;
  byteFlashPtr = (FlashPTR)dwordFlashPtr;
  for(; i < length; i++, byteBuffer++, byteFlashPtr++) {
    *byteBuffer = tffsReadByteFlash(byteFlashPtr);
  }
  return flOK ;
}

/*----------------------------------------------------------------------*/
/*		       i 2 8 f 0 0 8 I d e n t i f y			*/
/*									*/
/* Identifies media based on Intel 28F008 and Intel 28F016 and		*/
/* registers as an MTD for such 					*/
/*									*/
/* This routine will be placed on the MTD list in custom.h. It must be	*/
/* an extern routine.							*/
/*									*/
/* On successful identification, the Flash structure is filled out and	*/
/* the write and erase routines registered.				*/
/*									*/
/* Parameters:								*/
/*	vol		: Pointer identifying drive			*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on positive identificaion, failed otherwise */
/*----------------------------------------------------------------------*/

FLStatus i28f008Identify(FLFlash vol)
{
  LONG iChip;

  CardAddress idOffset = 0;

  DEBUG_PRINT(("Debug: i28f008Identify :entering 8-bit Intel media identification routine.\n"));

  flSetWindowBusWidth(vol.socket, 16);/* use 16-bits */
  flSetWindowSpeed(vol.socket, 150);  /* 120 nsec. */
  flSetWindowSize(vol.socket, 2);	/* 8 KBytes */

  flIntelIdentify(&vol, NULL,0);

  if (vol.type == NOT_FLASH) {
    /* The flash may be write-protected at offset 0. Try another offset */
    idOffset = 0x80000l;
    flIntelIdentify(&vol, NULL,idOffset);
  }

   if (vol.type == LDP_1MB_IN_16BIT_MODE) {
    flSetWindowBusWidth(vol.socket, 8); 	/* use 8-bits */
    flIntelIdentify(&vol, NULL,idOffset);	/* and try to get a valid id */
  }

  switch (vol.type) {
    case COBRA004_FLASH:
      vol.chipSize = 0x80000l;
      vol.flags |= SUSPEND_FOR_WRITE | NO_12VOLTS;
      break;

    case COBRA008_FLASH:
      vol.flags |= SUSPEND_FOR_WRITE | NO_12VOLTS;
      /* no break */

    case MOBILE_MAX_INLV_4:
    case I28F008_FLASH:
      vol.chipSize = 0x100000l;
      break;

    case COBRA016_FLASH:
      vol.flags |= SUSPEND_FOR_WRITE | NO_12VOLTS;
      /* no break */

    case I28F016_FLASH:
      vol.chipSize = 0x200000l;
      break;

    default:
      DEBUG_PRINT(("Debug: failed to identify 8-bit Intel media.\n"));
      return flUnknownMedia;	/* not ours */
  }

  vol.erasableBlockSize = 0x10000l * vol.interleaving;

  checkStatus(flIntelSize(&vol, NULL,idOffset));

  if (vol.type == MOBILE_MAX_INLV_4)
    vol.type = I28F008_FLASH;

  for (iChip = 0; iChip < vol.noOfChips; iChip += vol.interleaving) {
    LONG i;

    FlashPTR flashPtr = (FlashPTR)
	    flMap(vol.socket,iChip * vol.chipSize);

    for (i = 0; i < vol.interleaving; i++)
      tffsWriteByteFlash(flashPtr + i, CLEAR_STATUS);
  }

  /* Register our flash handlers */
  vol.write = i28f008Write;
  vol.erase = i28f008Erase;
  vol.read = i28f008Read;
  vol.map = i28f008Map;

  DEBUG_PRINT(("Debug: i28f008Identify  :identified 8-bit Intel media.\n"));

  return flOK;
}


/*----------------------------------------------------------------------*/
/*		     f l R e g i s t e r I 2 8 F 0 0 8			*/
/*									*/
/* Registers this MTD for use						*/
/*									*/
/* Parameters:								*/
/*	None								*/
/*									*/
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failure		*/
/*----------------------------------------------------------------------*/

FLStatus flRegisterI28F008(VOID)
{
  if (noOfMTDs >= MTDS)
    return flTooManyComponents;

  mtdTable[noOfMTDs++] = i28f008Identify;

  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\fsapi.h ===
/*
 * $Log:   V:/Flite/archives/FLite/src/FSAPI.H_V  $
   
      Rev 1.4   Jan 20 2000 17:54:24   vadimk
   add FL_READ_ONLY define

      Rev 1.3   Jan 17 2000 13:43:06   vadimk
   remove fl_format_volume

      Rev 1.2   Jan 13 2000 18:28:12   vadimk
   TrueFFS OSAK 4.1

      Rev 1.1   Jul 12 1999 16:53:34   marinak
   dosFormat call is passed from blockdev.c to fatlite.c

      Rev 1.0   22 Dec 1998 14:04:34   marina
   Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-99              */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef FSAPI_H
#define FSAPI_H

#include "flreq.h"

/*----------------------------------------------------------------------*/
/*		           f l C a l l   				*/
/*									*/
/* Common entry-point to all file-system functions. Macros are          */
/* to call individual function, which are separately described below.	*/
/*                                                                      */
/* Parameters:                                                          */
/*	function	: file-system function code (listed below)	*/
/*	ioreq		: IOreq structure				*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

typedef enum {
  FL_OPEN_FILE,
  FL_CLOSE_FILE,
  FL_READ_FILE,
  FL_WRITE_FILE,
  FL_SEEK_FILE,
  FL_FIND_FILE,
  FL_FIND_FIRST_FILE,
  FL_FIND_NEXT_FILE,
  FL_GET_DISK_INFO,
  FL_DELETE_FILE,
  FL_RENAME_FILE,
  FL_MAKE_DIR,
  FL_REMOVE_DIR,
  FL_SPLIT_FILE,
  FL_JOIN_FILE,
  FL_FLUSH_BUFFER
} FLFunctionNo;


FLStatus flCall(FLFunctionNo functionNo, IOreq FAR2 *ioreq);



#if FILES > 0
#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*		     f l F l u s h B u f f e r                                    */
/*									                                                    */
/* If there is relevant data in the RAM buffer then writes it on        */
/*   the flash memory.                                                  */
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)                                */
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                          */
/*----------------------------------------------------------------------*/

#define flFlushBuffer(ioreq)	flCall(FL_FLUSH_BUFFER,ioreq)

#endif                                  /* READ_ONLY */
/*----------------------------------------------------------------------*/
/*		      f l O p e n F i l e				*/
/*									*/
/* Opens an existing file or creates a new file. Creates a file handle  */
/* for further file processing.						*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irFlags		: Access and action options, defined below	*/
/*	irPath		: path of file to open             		*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*	irHandle	: New file handle for open file                 */
/*                                                                      */
/*----------------------------------------------------------------------*/

/** Values of irFlags for flOpenFile: */

#define ACCESS_MODE_MASK	3	/* Mask for access mode bits */

/* Individual flags */

#define	ACCESS_READ_WRITE	1	/* Allow read and write */
#define ACCESS_CREATE		2	/* Create new file */

/* Access mode combinations */
#define OPEN_FOR_READ		0	/* open existing file for read-only */
#define	OPEN_FOR_UPDATE		1	/* open existing file for read/write access */
#define OPEN_FOR_WRITE		3	/* create a new file, even if it exists */


#define flOpenFile(ioreq)	flCall(FL_OPEN_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*		      f l C l o s e F i l e				*/
/*									*/
/* Closes an open file, records file size and dates in directory and    */
/* releases file handle.						*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Handle of file to close.                      */
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define flCloseFile(ioreq)      flCall(FL_CLOSE_FILE,ioreq)

#ifndef FL_READ_ONLY
#ifdef SPLIT_JOIN_FILE

/*------------------------------------------------------------------------*/
/*		      f l S p l i t F i l e                               */
/*                                                                        */
/* Splits the file into two files. The original file contains the first   */
/* part, and a new file (which is created for that purpose) contains      */
/* the second part. If the current position is on a cluster               */
/* boundary, the file will be split at the current position. Otherwise,   */
/* the cluster of the current position is duplicated, one copy is the     */
/* first cluster of the new file, and the other is the last cluster of the*/
/* original file, which now ends at the current position.                 */
/*                                                                        */
/* Parameters:                                                            */
/*	file            : file to split.                                  */
/*      irPath          : Path name of the new file.                      */
/*                                                                        */
/* Returns:                                                               */
/*	irHandle        : handle of the new file.                         */
/*	FLStatus        : 0 on success, otherwise failed.                 */
/*                                                                        */
/*------------------------------------------------------------------------*/

#define flSplitFile(ioreq)     flCall(FL_SPLIT_FILE,ioreq)


/*------------------------------------------------------------------------*/
/*		      f l J o i n F i l e                                 */
/*                                                                        */
/* joins two files. If the end of the first file is on a cluster          */
/* boundary, the files will be joined there. Otherwise, the data in       */
/* the second file from the beginning until the offset that is equal to   */
/* the offset in cluster of the end of the first file will be lost. The   */
/* rest of the second file will be joined to the first file at the end of */
/* the first file. On exit, the first file is the expanded file and the   */
/* second file is deleted.                                                */
/* Note: The second file will be open by this function, it is advised to  */
/*	 close it before calling this function in order to avoid          */
/*	 inconsistencies.                                                 */
/*                                                                        */
/* Parameters:                                                            */
/*	file            : file to join to.                                */
/*	irPath          : Path name of the file to be joined.             */
/*                                                                        */
/* Return:                                                                */
/*	FLStatus        : 0 on success, otherwise failed.                 */
/*                                                                        */
/*------------------------------------------------------------------------*/

#define flJoinFile(ioreq)     flCall(FL_JOIN_FILE,ioreq)

#endif /* SPLIT_JOIN_FILE */
#endif /* FL_READ_ONLY */
/*----------------------------------------------------------------------*/
/*		      f l R e a d F i l e				*/
/*									*/
/* Reads from the current position in the file to the user-buffer.	*/
/* Parameters:                                                          */
/*	irHandle	: Handle of file to read.                       */
/*      irData		: Address of user buffer			*/
/*	irLength	: Number of bytes to read. If the read extends  */
/*			  beyond the end-of-file, the read is truncated */
/*			  at the end-of-file.				*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*	irLength	: Actual number of bytes read			*/
/*----------------------------------------------------------------------*/

#define flReadFile(ioreq)	flCall(FL_READ_FILE,ioreq)

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*		      f l W r i t e F i l e				*/
/*									*/
/* Writes from the current position in the file from the user-buffer.   */
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Handle of file to write.			*/
/*      irData		: Address of user buffer			*/
/*	irLength	: Number of bytes to write.			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*	irLength	: Actual number of bytes written		*/
/*----------------------------------------------------------------------*/

#define flWriteFile(ioreq)	flCall(FL_WRITE_FILE,ioreq)

#endif  /* FL_READ_ONLY */
/*----------------------------------------------------------------------*/
/*		      f l S e e k F i l e				*/
/*									*/
/* Sets the current position in the file, relative to file start, end or*/
/* current position.							*/
/* Note: This function will not move the file pointer beyond the	*/
/* beginning or end of file, so the actual file position may be		*/
/* different from the required. The actual position is indicated on     */
/* return.								*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: File handle to close.                         */
/*      irLength	: Offset to set position.			*/
/*	irFlags		: Method code					*/
/*			  SEEK_START: absolute offset from start of file  */
/*			  SEEK_CURR:  signed offset from current position */
/*			  SEEK_END:   signed offset from end of file    */
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*	irLength	: Actual absolute offset from start of file	*/
/*----------------------------------------------------------------------*/

/** Values of irFlags for flSeekFile: */

#define	SEEK_START	0	/* offset from start of file */
#define	SEEK_CURR	1	/* offset from current position */
#define	SEEK_END	2	/* offset from end of file */


#define flSeekFile(ioreq)	flCall(FL_SEEK_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*		          f l F i n d F i l e				*/
/*                                                                      */
/* Finds a file entry in a directory, optionally modifying the file     */
/* time/date and/or attributes.                                         */
/* Files may be found by handle no. provided they are open, or by name. */
/* Only the Hidden, System or Read-only attributes may be modified.	*/
/* Entries may be found for any existing file or directory other than   */
/* the root. A DirectoryEntry structure describing the file is copied   */
/* to a user buffer.							*/
/*                                                                      */
/* The DirectoryEntry structure is defined in dosformt.h		*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: If by name: Drive number (0, 1, ...)		*/
/*			  else      : Handle of open file		*/
/*	irPath		: If by name: Specifies a file or directory path*/
/*	irFlags		: Options flags					*/
/*			  FIND_BY_HANDLE: Find open file by handle. 	*/
/*					  Default is access by path.    */
/*                        SET_DATETIME:	Update time/date from buffer	*/
/*			  SET_ATTRIBUTES: Update attributes from buffer	*/
/*	irDirEntry	: Address of user buffer to receive a		*/
/*			  DirectoryEntry structure			*/
/*                                                                      */
/* Returns:                                                             */
/*	irLength	: Modified					*/
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

/** Bit assignment of irFlags for flFindFile: */

#define SET_DATETIME	1	/* Change date/time */
#define	SET_ATTRIBUTES	2	/* Change attributes */
#define	FIND_BY_HANDLE	4	/* Find file by handle rather than by name */

#define	flFindFile(ioreq)	flCall(FL_FIND_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*		 f l F i n d F i r s t F i l e				*/
/*                                                                      */
/* Finds the first file entry in a directory.				*/
/* This function is used in combination with the flFindNextFile call,   */
/* which returns the remaining file entries in a directory sequentially.*/
/* Entries are returned according to the unsorted directory order.	*/
/* flFindFirstFile creates a file handle, which is returned by it. Calls*/
/* to flFindNextFile will provide this file handle. When flFindNextFile */
/* returns 'noMoreEntries', the file handle is automatically closed.    */
/* Alternatively the file handle can be closed by a 'closeFile' call    */
/* before actually reaching the end of directory.			*/
/* A DirectoryEntry structure is copied to the user buffer describing   */
/* each file found. This structure is defined in dosformt.h.		*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irPath		: Specifies a directory path			*/
/*	irData		: Address of user buffer to receive a		*/
/*			  DirectoryEntry structure			*/
/*                                                                      */
/* Returns:                                                             */
/*	irHandle	: File handle to use for subsequent operations. */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define	flFindFirstFile(ioreq)	flCall(FL_FIND_FIRST_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*		 f l F i n d N e x t F i l e				*/
/*                                                                      */
/* See the description of 'flFindFirstFile'.				*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: File handle returned by flFindFirstFile.	*/
/*	irData		: Address of user buffer to receive a		*/
/*			  DirectoryEntry structure			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define	flFindNextFile(ioreq)	flCall(FL_FIND_NEXT_FILE,ioreq)


/*----------------------------------------------------------------------*/
/*		      f l G e t D i s k I n f o				*/
/*									*/
/* Returns general allocation information.				*/
/*									*/
/* The bytes/sector, sector/cluster, total cluster and free cluster	*/
/* information are returned into a DiskInfo structure.			*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irData		: Address of DiskInfo structure                 */
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

typedef struct {
  unsigned	bytesPerSector;
  unsigned	sectorsPerCluster;
  unsigned	totalClusters;
  unsigned	freeClusters;
} DiskInfo;


#define flGetDiskInfo(ioreq)	flCall(FL_GET_DISK_INFO,ioreq)

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*		      f l D e l e t e F i l e				*/
/*									*/
/* Deletes a file.                                                      */
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irPath		: path of file to delete			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define flDeleteFile(ioreq)	flCall(FL_DELETE_FILE,ioreq)


#ifdef RENAME_FILE

/*----------------------------------------------------------------------*/
/*		      f l R e n a m e F i l e				*/
/*									*/
/* Renames a file to another name.					*/
/*									*/
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irPath		: path of existing file				*/
/*      irData		: path of new name.				*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define flRenameFile(ioreq)	flCall(FL_RENAME_FILE,ioreq)

#endif /* RENAME_FILE */


#ifdef SUB_DIRECTORY

/*----------------------------------------------------------------------*/
/*		      f l M a k e D i r					*/
/*									*/
/* Creates a new directory.						*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irPath		: path of new directory.			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define flMakeDir(ioreq)	flCall(FL_MAKE_DIR,ioreq)


/*----------------------------------------------------------------------*/
/*		      f l R e m o v e D i r				*/
/*									*/
/* Removes an empty directory.						*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irPath		: path of directory to remove.			*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

#define flRemoveDir(ioreq)	flCall(FL_REMOVE_DIR,ioreq)

#endif /* SUB_DIRECTORY */
#endif /* FL_READ_ONLY */

#endif /* FILES > 0 */

#ifdef PARSE_PATH

/*----------------------------------------------------------------------*/
/*		      f l P a r s e P a t h				*/
/*									*/
/* Converts a DOS-like path string to a simple-path array.		*/
/*									*/
/* Note: Array length received in irPath must be greater than the 	*/
/* number of path components in the path to convert.			*/
/*                                                                      */
/* Parameters:                                                          */
/*	irHandle	: Drive number (0, 1, ...)			*/
/*	irData		: address of path string to convert		*/
/*	irPath		: address of array to receive parsed-path. 	*/
/*                                                                      */
/* Returns:                                                             */
/*	FLStatus	: 0 on success, otherwise failed                */
/*----------------------------------------------------------------------*/

extern FLStatus flParsePath(IOreq FAR2 *ioreq);

#endif /* PARSE_PATH */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\fltl.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLTL.C_V  $
 * 
 *    Rev 1.19   Jan 23 2002 23:33:08   oris
 * Bug fix - converting NFTL format to INFTL, with bad EDC in BBT.
 * Changed DFORMAT_PRINT syntax.
 * 
 *    Rev 1.18   Jan 20 2002 20:28:32   oris
 * Removed quick mount flag check for NFTL (no longer relevant).
 * Removed warnings (DFORMAT_PRINT).
 * 
 *    Rev 1.17   Jan 17 2002 23:02:44   oris
 * Added check for NULL pointers for readBBT and socket record.
 * Added checkVolume and defragment routine initialization.
 * Placed readBBT under NO_READ_BBT_CODE compilation flag.
 * Added include for docbdk.h
 * Added flash record as a parameter to flMount / flFormat / flPremount routine.
 * Removed check of TL_SINGLE_FLOOR_FORMATTING flag in the flFormat routine.
 * Added check for 0xFFFF FFFF binary signature.
 * 
 *    Rev 1.16   Nov 20 2001 20:25:24   oris
 * Changed debug print to dformat debug print.
 * 
 *    Rev 1.15   Nov 16 2001 00:22:06   oris
 * Fix check43to50 routine.
 * 
 *    Rev 1.14   Nov 08 2001 10:49:38   oris
 * Added format converter from NFTL to INFTL for ALON controllers (mobile DiskOnChip) NO_NFTL_2_INFTL compilation flag
 * Bug fix - support for DiskOnChip with different number of blocks in the last floor.
 * Added erase operation of bad blocks in write BBT routine (helps plant bad blocks).
 * 
 *    Rev 1.13   Sep 15 2001 23:46:40   oris
 * Removed some debug printing.
 * 
 *    Rev 1.12   Jul 15 2001 20:45:04   oris
 * Changed DFORMAT_PRINT syntax to be similar to DEBUG_PRINT.
 * 
 *    Rev 1.11   Jul 13 2001 01:06:54   oris
 * Rewritten writeBBT portion of the preMount routine - several bugs were found.
 * Millennium Plus does not support write BBT routine.
 * 
 *    Rev 1.10   Jun 17 2001 08:18:26   oris
 * Place write bbt under FORMAT_VOLUME compilation flag.
 * 
 *    Rev 1.9   May 16 2001 21:35:04   oris
 * Bug fix - write BBT did not cover the entire media.
 * 
 *    Rev 1.8   May 02 2001 06:39:46   oris
 * Removed the lastUsableBlock variable.
 * 
 *    Rev 1.7   Apr 24 2001 17:08:38   oris
 * Rebuilt writeBBT routine.
 * Added check for uninitialized socket in the premount routine (releveant to windows OS).
 * 
 *    Rev 1.6   Apr 16 2001 13:47:44   oris
 * Removed warrnings.
 * 
 *    Rev 1.5   Apr 09 2001 15:09:56   oris
 * End with an empty line.
 * 
 *    Rev 1.4   Apr 01 2001 07:57:34   oris
 * copywrite notice.
 * Removed debug massage when calling a premount routine from a TL that does not support it.
 * 
 *    Rev 1.3   Feb 18 2001 12:07:58   oris
 * Bug fix in writeBBT irLength argument is accepted if it is diffrent then 0 and not equal.
 * Bug fix in format sanity check must be sure a BDTLPartitionInfo exits before checking it for protection.
 *
 *    Rev 1.2   Feb 14 2001 01:55:12   oris
 * CountVolumes returns no of volumes in irFlags instead of irLength.
 * Added boundry argument to writeBBT.
 * Moved format varification from blockdev.c.
 *
 *    Rev 1.1   Feb 12 2001 11:57:42   oris
 * WriteBBT was moved from blockdev.c.
 *
 *    Rev 1.0   Feb 04 2001 12:07:30   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/* #include "flflash.h" */
#include "fltl.h"
#include "docbdk.h" /* Only for bdk signature size */

int noOfTLs;    /* No. of translation layers actually registered */

TLentry tlTable[TLS];

/*----------------------------------------------------------------------*/
/*                        m a r k U n i t B a d                         */
/*                                                                      */
/* Erase a unit and mark it as bad                                      */
/*                                                                      */
/* Parameters:                                                          */
/*    flash     : Pointer to MTD record                                 */
/*    badUnit   : Bad unit number to mark as bad                        */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : flOK                                                */
/*----------------------------------------------------------------------*/

FLStatus markUnitBad(FLFlash * flash, CardAddress badUnit)
{
   static byte   zeroes[2] = {0,0};
   dword         offset;

   /* Mark the first page with 00. If the write operation
      fails try marking the following pages of the block */
   for (offset = 0 ; (offset < flash->erasableBlockSize) &&
       (flash->write(flash,(badUnit << flash->erasableBlockSizeBits)+offset,
        zeroes,sizeof(zeroes),0) != flOK);
        offset += flash->pageSize);
   /* Entire block can not be written to */
   if (offset == flash->erasableBlockSize)
		#ifndef NT5PORT
			DEBUG_PRINT(("Debug: Error failed marking unit as bad (address %ld).\n",badUnit));
		#else /*NT5PORT*/
			DEBUG_PRINT(("Debug: Error failed marking unit as bad (address).\n"));
		#endif /*NT5PORT*/

   return flOK;
}


#ifndef NO_NFTL_2_INFTL

/*----------------------------------------------------------------------*/
/*                        c h e c k 4 3 F o r m a t                     */
/*                                                                      */
/* Checks DiskOnChip 2000 tsop was formated using TrueFFS 4.3. If so it */
/* unformats the media.                                                 */
/*                                                                      */
/* Note - The routine will not help DiskOnChip larger then DiskOnChip   */
/*        2000 tsop formated with TrueFFS 4.3.                          */
/*                                                                      */
/* Note - How about erasing the media header last.                      */
/*                                                                      */
/* Parameters:                                                          */
/*    flash     : Pointer to MTD record                                 */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : flOK                                                */
/*                  flDataError - DiskOnChip ALON was formated with 4.3 */
/*                  but is not DiskOnChip 2000 tsop.                    */
/*----------------------------------------------------------------------*/

FLStatus check43Format(FLFlash *flash)
{
   FLStatus status;
   byte FAR1* buf;

   /* If this is an alon */
   if (flash->mediaType != DOC2000TSOP_TYPE)
      return flOK;
   buf = (flBufferOf(flSocketNoOf(flash->socket))->flData);
   if(flash->readBBT == NULL)
   {
      DFORMAT_PRINT(("ERROR : MTD read BBT routine was not initialized\r\n"));
      return flFeatureNotSupported;
   }
   status = flash->readBBT(flash,0,1,0,buf,FALSE);

   if (status == flBadBBT)
   {
      dword mediaSize = ((dword)flash->noOfChips*flash->chipSize);
      dword blockSize = 1<<flash->erasableBlockSizeBits;
      dword addr      = 0;
      dword offset;
      word  mediaHeaderBlock; /* ANAND unit number                */
      byte  blocksPerUnit;    /* Blocks per virtual unit          */
      byte  blockShift;       /* Bits to shift from block to unit */

CHECK_UNIT_WITH_ANAND:

      /* Either virgin or formated wih TrueFFS 4.3 */

      for( ; addr < mediaSize ; addr += blockSize)
      {
         checkStatus(flash->read(flash,addr,buf,5,0));
         if(tffscmp(buf,"ANAND",5) == 0)
            break;
      }

      if (addr == mediaSize) /* virgin card */
         return flOK;

      DFORMAT_PRINT(("This DiskOnChip was formated with an NFTL format.\r\n"));

      /* Calculate block multiplier bits */

      for (offset = addr + SECTOR_SIZE , status = flOK;
           (offset < addr + blockSize) && (status == flOK) ;
           offset += SECTOR_SIZE)
      {
         status = flash->read(flash,addr+offset,buf,512,EDC);
      }
      
      if(offset == addr + (SECTOR_SIZE<<1)) /* Bad EDC for NFTL unit header */
      {
         DFORMAT_PRINT(("ERROR - Unit with ANAND was found, but the BBT has bad EDC.\r\n"));
         goto CHECK_UNIT_WITH_ANAND; /* Keep searching */
      }

      offset = (offset - addr - (SECTOR_SIZE<<1)) << flash->erasableBlockSizeBits;

      for(blockShift = 0 ; offset < mediaSize ; blockShift++)
      {
         offset <<= 1;
      }
      blocksPerUnit = 1 << blockShift;

      mediaHeaderBlock = (word)(addr >> (flash->erasableBlockSizeBits + blockShift));

      DFORMAT_PRINT(("Please wait while unformating is in progress...\r\n"));

      /* Read and write 512 blocks of the BBT (start from the end) */

      for (offset = 0;
           offset < mediaSize>>(flash->erasableBlockSizeBits + blockShift);
           offset += SECTOR_SIZE)
      {
         word i;

         checkStatus(flash->read(flash,addr+offset+SECTOR_SIZE,buf,SECTOR_SIZE,EDC));
         for(i=0;i<SECTOR_SIZE;i++)
         {
            if (i+offset == mediaHeaderBlock)
               continue;

            if (buf[i]==BBT_BAD_UNIT) /* A bad block */
            {
               markUnitBad(flash , i+offset);
            }
            else                      /* A good block */
            {
               status = flash->erase(flash,(word)(i+offset),blocksPerUnit);
               if (status != flOK)
                  markUnitBad(flash , i+offset);
            }
         }
      }
      status = flash->erase(flash,mediaHeaderBlock,blocksPerUnit);
      if (status != flOK)
         markUnitBad(flash , mediaHeaderBlock);

      DFORMAT_PRINT(("Unformating of DiskOnChip 2000 tsop complete.\r\n"));
   }
   return flOK;
}
#endif /* NO_NFTL_2_INFTL */


/*----------------------------------------------------------------------*/
/*                              f l P r e M o u n t                     */
/*                                                                      */
/* Perform TL operation before the TL is mounted                        */
/*                                                                      */
/* Notes for FL_COUNT_VOLUMES routine                                   */
/* ----------------------------------                                   */
/* Note : The number of partitions returned is not neccarily the number */
/*        That can be accesses. protected partitions will need a key.   */
/* Note : TL that do not support several partitions will return 1       */
/*        unless the socket can not be mounted in which case 0 will be  */
/*        returned.                                                     */
/*                                                                      */
/* Parameters:                                                          */
/*    callType     : The type of the operation (see blockdev.h)         */
/*    ioreq        : Input Output packet                                */
/*    ioreq.irHandle : handle discribing the socket and the partition   */
/*    flash        : Location where the flash media record can be       */
/*                   stored. Note that it is not yet initialized        */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/
FLStatus flPreMount(FLFunctionNo callType, IOreq FAR2* ioreq , FLFlash * flash)
{
  FLStatus layerStatus = flUnknownMedia;
  FLStatus callStatus;
  FLSocket *socket     = flSocketOf(FL_GET_SOCKET_FROM_HANDLE(ioreq));
    int iTL;

#ifdef NT5PORT
	if(socket->window.base == NULL){
		ioreq->irFlags = 1;
		return flOK;
	}
#endif /*NT5PORT*/

  /* Patch for OS drivers that call flInit before socket is initialized */
  if (callType == FL_COUNT_VOLUMES)
  {
     if((socket == NULL) || (socket->window.base==NULL))
     {
        ioreq->irFlags = 1;
        return flOK;
     }
  }

  /* Identify flash medium and initlize flash record */
  callStatus =  flIdentifyFlash(socket,flash);
  if (callStatus != flOK && callStatus != flUnknownMedia)
    return callStatus;

  /* Try sending call to the diffrent TLs */
  for (iTL = 0; (iTL < noOfTLs) && (layerStatus != flOK); iTL++)
    if (tlTable[iTL].preMountRoutine != NULL)
      layerStatus = tlTable[iTL].preMountRoutine(callType,ioreq, flash,&callStatus);

  if (layerStatus != flOK)
  {
     switch (callType)
     {
        case FL_COUNT_VOLUMES:
           ioreq->irFlags = 1;
           return flOK;

#ifdef FORMAT_VOLUME
        case FL_WRITE_BBT:
        {
           CardAddress endUnit = ((dword)(flash->chipSize * flash->noOfChips) >> flash->erasableBlockSizeBits); /* Media size */
           CardAddress unitsPerFloor = endUnit/flash->noOfFloors;
           CardAddress iUnit;
           CardAddress bUnit = *((unsigned long FAR1 *) ioreq->irData)
                               >> flash->erasableBlockSizeBits;
           word        badBlockNo;

           /* In case the user has given a specific length use it
           instead of the entire media */
           if ((ioreq->irLength != 0) && ( endUnit >
            ((dword)ioreq->irLength >> flash->erasableBlockSizeBits)))
           {
              endUnit = ioreq->irLength >> flash->erasableBlockSizeBits;
           }

           /* Millennium Plus DiskOnChip Family do not need a write bbt call */

           if ((flash->mediaType == MDOCP_TYPE   ) ||
               (flash->mediaType == MDOCP_16_TYPE)   )
           {
              DEBUG_PRINT(("DiskOnChip Millennium Plus has a H/W protected BBT.\r\n"));
              DEBUG_PRINT(("No need to erase the DiskOnChip. Simply reformat.\r\n"));
              return flFeatureNotSupported;
           }

           /* Erase entire media */

           for (iUnit = flash->firstUsableBlock ,badBlockNo = 0;
                iUnit < endUnit ;iUnit += ((iUnit+1) / unitsPerFloor) ?
                1 : flash->firstUsableBlock + 1)
           {
			#ifndef NT5PORT
              DFORMAT_PRINT(("Erasing unit number %ld\r",iUnit));
			#endif /*NT5PORT*/
              if (ioreq->irFlags > badBlockNo) /* There are additional bad blocks */
              {
                 if (bUnit == iUnit)
                 {
                    badBlockNo++;
                    bUnit = (*((CardAddress FAR1 *)flAddLongToFarPointer
                            (ioreq->irData,badBlockNo*sizeof(CardAddress))))
                             >> flash->erasableBlockSizeBits;
                    flash->erase(flash,(word)iUnit,1);
                    markUnitBad(flash,iUnit);
                    continue;
                 }
              }
              callStatus = flash->erase(flash,(word)iUnit,1);
              if (callStatus != flOK) /* Additional bad block was found */
              {
			#ifndef NT5PORT
                 DFORMAT_PRINT(("Failed erasing unit in write BBT (unit no %lu).\r\n",iUnit));
			#endif/*NT5PORT*/
                  markUnitBad(flash,iUnit);
              }
           }
           DEBUG_PRINT(("\nUnformat Complete        \r\n"));
           return flOK;
        }
#endif /* FORMAT_VOLUME */

        default : /* Protection routines */
        return flFeatureNotSupported;
     }
  }
  return callStatus;
}

/*----------------------------------------------------------------------*/
/*                       f l M o u n t                                  */
/*                                                                      */
/* Mount a translation layer                                            */
/*                                                                      */
/* Parameters:                                                          */
/*    volNo        : Volume no.                                         */
/*    socketNo     : The socket no                                      */
/*    tl           : Where to store translation layer methods           */
/*    useFilters   : Whether to use filter translation-layers           */
/*    flash        : Location where the flash media record can be       */
/*                   stored. Note that it is not yet initialized        */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

FLStatus flMount(unsigned volNo, unsigned socketNo,TL *tl,
                 FLBoolean useFilters , FLFlash * flash)
{
  FLFlash *volForCallback = NULL;
  FLSocket *socket = flSocketOf(socketNo);
  FLStatus status = flUnknownMedia;
  int iTL;

  FLStatus flashStatus = flIdentifyFlash(socket,flash);
  if (flashStatus != flOK && flashStatus != flUnknownMedia)
    return flashStatus;

  tl->recommendedClusterInfo = NULL;
  tl->writeMultiSector       = NULL;
  tl->readSectors            = NULL;
#ifndef NO_READ_BBT_CODE
  tl->readBBT                = NULL;
#endif 
#if (defined(VERIFY_VOLUME) || defined(VERIFY_WRITE))
  tl->checkVolume            = NULL;
#endif /* VERIFY_VOLUME || VERIFY_WRITE */
#ifdef DEFRAGMENT_VOLUME
  tl->defragment             = NULL;
#endif /* DEFRAGMENT */

  for (iTL = 0; (iTL < noOfTLs) && (status != flOK) && (status != flHWProtection); iTL++)
    if (tlTable[iTL].formatRoutine != NULL)    /* not a block-device filter */
      status = tlTable[iTL].mountRoutine(volNo,tl,flashStatus == flOK ? flash : NULL,&volForCallback);

  if (status == flOK) {
    if (volForCallback)
      volForCallback->setPowerOnCallback(volForCallback);

    if (useFilters)
      for (iTL = 0; iTL < noOfTLs; iTL++)
    if (tlTable[iTL].formatRoutine ==  NULL)    /* block-device filter */
      if (tlTable[iTL].mountRoutine(volNo,tl,NULL,NULL) == flOK)
        break;
  }
  return status;
}


#ifdef FORMAT_VOLUME

/*----------------------------------------------------------------------*/
/*                       f l F o r m a t                                */
/*                                                                      */
/* Formats the Flash volume                                             */
/*                                                                      */
/* Parameters:                                                          */
/*    volNo            : Physical drive no.                             */
/*    formatParams    : Address of FormatParams structure to use        */
/*    flash        : Location where the flash media record can be       */
/*                   stored. Note that it is not yet initialized        */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, failed otherwise                      */
/*----------------------------------------------------------------------*/

FLStatus flFormat(unsigned volNo, TLFormatParams * formatParams,
                  FLFlash * flash)
{
  BinaryPartitionFormatParams FAR1* partitionPtr;
  FLSocket                        * socket = flSocketOf(volNo);
  FLStatus                          status = flUnknownMedia;
  int                               iTL,partitionNo;

  FLStatus flashStatus = flIdentifyFlash(socket,flash);
  if (flashStatus != flOK && flashStatus != flUnknownMedia)
    return flashStatus;

  /* Validity check for formatParams */

  if (!(flash->flags & INFTL_ENABLED)) /* Flash does not support INFTL */
  {
     if ((formatParams->noOfBDTLPartitions   > 1)           ||
#ifdef HW_PROTECTION
         ((formatParams->BDTLPartitionInfo != NULL) &&
          (formatParams->BDTLPartitionInfo->protectionType & PROTECTABLE))   ||
         ((formatParams->noOfBinaryPartitions > 0)&&
          (formatParams->binaryPartitionInfo->protectionType & PROTECTABLE)) ||
#endif /* HW_PROTECTION */
         (formatParams->noOfBinaryPartitions > 1))
     {
        DEBUG_PRINT(("Debug: feature not supported by the TL.\r\n"));
        return flFeatureNotSupported;
     }
  }

  for(partitionNo = 0 , partitionPtr = formatParams->binaryPartitionInfo;
      partitionNo < formatParams->noOfBinaryPartitions;
      partitionNo++,partitionPtr++)
  {

     if(*((dword FAR1*)(partitionPtr->sign)) == 0xffffffffL)
     {
        DEBUG_PRINT(("Debug: can not use 'FFFF' signature for Binary partition\r\n"));
        return flBadParameter;
     }
  }

  /* Try each of the registered TL */

#ifndef NO_NFTL_2_INFTL
  checkStatus(check43Format(flash));
#endif /* NO_NFTL_2_INFTL */

  for (iTL = 0; iTL < noOfTLs && status == flUnknownMedia; iTL++)
    if (tlTable[iTL].formatRoutine != NULL)    /* not a block-device filter */
      status = tlTable[iTL].formatRoutine(volNo,formatParams,flashStatus == flOK ? flash : NULL);

  return status;
}

#endif

FLStatus noFormat (unsigned volNo, TLFormatParams * formatParams, FLFlash *flash)
{
  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\fltl.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/FLTL.H_V  $
 * 
 *    Rev 1.7   Apr 15 2002 07:39:04   oris
 * Added support for VERIFY_ERASED_SECTOR compilation flag.
 * 
 *    Rev 1.6   Feb 19 2002 21:00:10   oris
 * Replaced blockev.h include directive with fltl.h and flreq.h
 * Added FL_LEAVE_BINARY_AREA definition.
 * 
 *    Rev 1.5   Jan 17 2002 23:02:54   oris
 * Added flash record as a parameter to flMount / flFormat / flPremount  prototypes
 * Added checkVolume routine pointer in the TL record.
 * Placed readBBT under NO_READ_BBT_CODE compilation flag.
 * Removed SINGLE_BUFFER compilation flag.
 * Added flash record as a parameter to flMount / flFormat / flPremount prototype.
 * 
 *    Rev 1.4   May 16 2001 21:19:56   oris
 * Made noOfDriver public.
 * 
 *    Rev 1.3   Apr 24 2001 17:09:02   oris
 * change readBBT routine interface.
 * 
 *    Rev 1.2   Apr 01 2001 07:57:48   oris
 * copywrite notice.
 * Changed readSectors prototype.
 * Aliggned left all # directives.
 * 
 *    Rev 1.1   Feb 14 2001 01:56:46   oris
 * Changed readBBT prototype.
 *
 *    Rev 1.0   Feb 04 2001 12:13:32   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef FLTL_H
#define FLTL_H

#include "flflash.h"
#include "flfuncno.h"
#include "flreq.h"

typedef struct {
  SectorNo sectorsInVolume;
  unsigned long bootAreaSize;
  unsigned long eraseCycles;
  unsigned long tlUnitBits;
} TLInfo;

/* See interface documentation of functions in ftllite.c    */

typedef struct tTL TL;        /* Forward definition */
typedef struct tTLrec TLrec;     /* Defined by translation layer */

struct tTL {
  TLrec        *rec;
  byte      partitionNo;
  byte      socketNo;

  const void FAR0 *(*mapSector)(TLrec *, SectorNo sectorNo, CardAddress *physAddr);
  FLStatus       (*writeSector)(TLrec *, SectorNo sectorNo, void FAR1 *fromAddress);

  FLStatus       (*writeMultiSector)(TLrec *, SectorNo sectorNo, void FAR1 *fromAddress,SectorNo sectorCount);
  FLStatus       (*readSectors)(TLrec *, SectorNo sectorNo, void FAR1 *dest,SectorNo sectorCount);

  FLStatus       (*deleteSector)(TLrec *, SectorNo sectorNo, SectorNo noOfSectors);
  FLStatus       (*tlSetBusy)(TLrec *, FLBoolean);
  void           (*dismount)(TLrec *);

#ifdef DEFRAGMENT_VOLUME
  FLStatus       (*defragment)(TLrec *, long FAR2 *bytesNeeded);
#endif
#if (defined(VERIFY_VOLUME) || defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR)) 
  FLStatus       (*checkVolume)(TLrec *);
#endif /* VERIFY_VOLUME || VERIFY_WRITE || VERIFY_ERASED_SECTOR */
  SectorNo       (*sectorsInVolume)(TLrec *);
  FLStatus       (*getTLInfo)(TLrec *, TLInfo *tlInfo);
  void           (*recommendedClusterInfo)(TLrec *, int *sectorsPerCluster, SectorNo *clusterAlignment);
#ifndef NO_READ_BBT_CODE
  FLStatus       (*readBBT)(TLrec *, CardAddress FAR1 * buf, long FAR2 * mediaSize, unsigned FAR2 * noOfBB);
#endif
};


#include "dosformt.h"

/* Translation layer registration information */

extern int noOfTLs;    /* No. of translation layers actually registered */

typedef struct {
  FLStatus (*mountRoutine)   (unsigned volNo, TL *tl, FLFlash *flash, FLFlash **volForCallback);
  FLStatus (*formatRoutine)  (unsigned volNo, TLFormatParams *deviceFormatParams, FLFlash *flash);
  FLStatus (*preMountRoutine)(FLFunctionNo callType, IOreq FAR2* ioreq ,FLFlash* flash,FLStatus* status);
} TLentry;

extern TLentry tlTable[TLS];
extern FLStatus noFormat (unsigned volNo, TLFormatParams *formatParams, FLFlash *flash);
extern FLStatus flMount(unsigned volNo, unsigned socketNo,TL *, FLBoolean useFilters , FLFlash *flash);
extern FLStatus flPreMount(FLFunctionNo callType, IOreq FAR2* ioreq , FLFlash *flash);
extern unsigned noOfDrives;

#ifdef FORMAT_VOLUME
extern FLStatus flFormat(unsigned volNo, TLFormatParams *formatParams, FLFlash * flash);

#define FL_LEAVE_BINARY_AREA 8
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flsystem.h ===
/*
 * $Log:   P:/user/amir/lite/vcs/flsystem.h_v  $

      Rev 1.4   11 Sep 1997 14:14:22   danig
   physicalToPointer receives drive no. when FAR == 0

      Rev 1.3   04 Sep 1997 13:58:30   danig
   DEBUG_PRINT

      Rev 1.2   28 Aug 1997 16:39:32   danig
   include stdlib.h instead of malloc.h

      Rev 1.1   19 Aug 1997 20:05:06   danig
   Andray's changes

      Rev 1.0   24 Jul 1997 18:13:06   amirban
   Initial revision.
 */

/************************************************************************/
/*                                  */
/*      FAT-FTL Lite Software Development Kit           */
/*      Copyright (C) M-Systems Ltd. 1995-1996          */
/*                                  */
/************************************************************************/


#ifndef FLSYSTEM_H
#define FLSYSTEM_H
#include <ntddk.h>
#include "flcustom.h"


/* DiskOnChip bus configuration
 *
 * When FL_NO_USE_FUNC is defined use the defintion bellow to set DiskOnChip
 * bus width access (either 8/16/32).
 * Please check the manula before deciding to use the FL_NO_USE_FUNC mode.
 */

#define DOC_ACCESS_TYPE 8

/*moti
 *                      delay With Yeald CPU disable
 *
 * Osak utiliezes the flSleep customized routine to yeald the CPU while
 * waiting for time consumming operations like flash erase. If the routine
 * is not implemented the uncomment the define bellow
 */

#define DO_NOT_YEAL_CPU

/*
 *          signed/unsigned char
 *
 * It is assumed that 'char' is signed. If this is not your compiler
 * default, use compiler switches, or insert a #pragma here to define this.
 *
 */

/*#pragma option -K-*/  /* default char is signed */


/*          CPU target
 *
 * Use compiler switches or insert a #pragma here to select the CPU type
 * you are targeting.
 *
 * If the target is an Intel 80386 or above, also uncomment the CPU_i386
 * definition.
 */

/*#pragma option -3*/   /* Select 80386 CPU */
#define CPU_i386


/*          NULL constant
 *
 * Some compilers require a different definition for the NULL pointer
 */

/*#include <_null.h>*/


/*          Little-endian/big-endian
 *
 * FAT and translation layers structures use the little-endian (Intel)
 * format for integers.
 * If your machine uses the big-endian (Motorola) format, uncomment the
 * following line.
 * Note that even on big-endian machines you may omit the BIG_ENDIAN
 * definition for smaller code size and better performance, but your media
 * will not be compatible with standard FAT and FTL.
 */

/* #define BIG_ENDIAN */


/*          Far pointers
 *
 * Specify here which pointers may be far, if any.
 * Far pointers are usually relevant only to 80x86 architectures.
 *
 * Specify FAR_LEVEL:
 *   0 -    if using a flat memory model or having no far pointers.
 *   1 -    if only the socket window may be far
 *   2 -    if only the socket window and caller's read/write buffers
 *      may be far.
 *   3 -    if socket window, caller's read/write buffers and the
 *      caller's I/O request packet may be far
 */

#define FAR_LEVEL   0


/*          Memory routines
 *
 * You need to supply library routines to copy, set and compare blocks of
 * memory, internally and to/from callers. The code uses the names 'tffscpy',
 * 'tffsset' and 'tffscmp' with parameters as in the standard 'memcpy',
 * 'memset' and 'memcmp' C library routines.
 */

#include <string.h>

#ifndef ENVIRONMENT_VARS
    #if FAR_LEVEL > 0
        #define tffscpy _fmemcpy
        #define tffscmp _fmemcmp
        #define tffsset _fmemset
    #else
        #define tffscpy memcpy
        #define tffscmp memcmp
        #define tffsset memset
    #endif
#else
    #if FAR_LEVEL > 0
        #define flcpy _fmemcpy
        #define flcmp _fmemcmp
        #define flset _fmemset
    #else
        #define flcmp flmemcmp
        #define flset flmemset
        #define flcpy flmemcpy
    #endif
#endif


/*          Pointer arithmetic
 *
 * The following macros define machine- and compiler-dependent macros for
 * handling pointers to physical window addresses. The definitions below are
 * for PC real-mode Borland-C.
 *
 * 'physicalToPointer' translates a physical flat address to a (far) pointer.
 * Note that if when your processor uses virtual memory, the code should
 * map the physical address to virtual memory, and return a pointer to that
 * memory (the size parameter tells how much memory should be mapped).
 *
 * 'addToFarPointer' adds an increment to a pointer and returns a new
 * pointer. The increment may be as large as your window size. The code
 * below assumes that the increment may be larger than 64 KB and so performs
 * huge pointer arithmetic.
 */

#if FAR_LEVEL > 0
#include <dos.h>

#define physicalToPointer(physical,size,drive)      \
    MK_FP((LONG) ((physical) >> 4),(LONG) (physical) & 0xF)

#define addToFarPointer(base,increment)     \
    MK_FP(FP_SEG(base) +            \
    ((USHORT) ((FP_OFF(base) + (increment)) >> 16) << 12), \
        FP_OFF(base) + (LONG) (increment))
#else

#include <ntddk.h>
#define freePointer(ptr,size) 1
typedef struct {
    ULONG   windowSize;
    ULONGLONG   physWindow;
    PVOID   winBase;
    ULONG   interfAlive;
    PVOID   fdoExtension;
    UCHAR   nextPartitionNumber;
} NTsocketParams;

//moti extern NTsocketParams *pdriveInfo;
extern NTsocketParams *pdriveInfo;

#define physicalToPointer(physical,size,drive)  pdriveInfo[drive & 0x0f].winBase

#define pointerToPhysical(ptr)  ((ULONG_PTR)(ptr))

#define addToFarPointer(base,increment)     \
    ((VOID *) ((UCHAR *) (base) + (increment)))
#endif


/*          Default calling convention
 *
 * C compilers usually use the C calling convention to routines (cdecl), but
 * often can also use the pascal calling convention, which is somewhat more
 * economical in code size. Some compilers also have specialized calling
 * conventions which may be suitable. Use compiler switches or insert a
 * #pragma here to select your favorite calling convention.
 */

/*#pragma option -p*/   /* Default pascal calling convention */
/* Naming convention for functions that uses non-default convention. */
#define NAMING_CONVENTION /*cdecl*/

#define FL_IOCTL_START   0


/*          Mutex type
 *
 * If you intend to access the FLite API in a multi-tasking environment,
 * you may need to implement some resource management and mutual-exclusion
 * of FLite with mutex & semaphore services that are available to you. In
 * this case, define here the Mutex type you will use, and provide your own
 * implementation of the Mutex functions incustom.c
 *
 * By default, a Mutex is defined as a simple counter, and the Mutex
 * functions in custom.c implement locking and unlocking by incrementing
 * and decrementing the counter. This will work well on all single-tasking
 * environment, as well as on many multi-tasking environments.
 */

//typedef LONG FLMutex;
typedef struct _SpinLockMutex{
    KSPIN_LOCK Mutex;
    KIRQL       cIrql;
}SpinLockMutex;

typedef SpinLockMutex FLMutex;
/*#include <dos.h>

#define flStartCriticalSection(FLMutex)     disable()
#define flEndCriticalSection(FLMutex)       enable()*/

/*          Memory allocation
 *
 * The translation layers (e.g. FTL) need to allocate memory to handle
 * Flash media. The size needed depends on the media being handled.
 *
 * You may choose to use the standard 'malloc' and 'free' to handle such
 * memory allocations, provide your own equivalent routines, or you may
 * choose not to define any memory allocation routine. In this case, the
 * memory will be allocated statically at compile-time on the assumption of
 * the largest media configuration you need to support. This is the simplest
 * choice, but may cause your RAM requirements to be larger than you
 * actually need.
 *
 * If you define routines other than malloc & free, they should have the
 * same parameters and return types as malloc & free. You should either code
 * these routines in flcustom.c or include them when you link your application.
 */

#ifdef NT5PORT



VOID * myMalloc(ULONG numberOfBytes);

#define MALLOC myMalloc
#define FREE ExFreePool


/*          Debug mode
 *
 * Uncomment the following lines if you want debug messages to be printed
 * out. Messages will be printed at initialization key points, and when
 * low-level errors occure.
 * You may choose to use 'printf' or provide your own routine.
 */

#if DBG
#define DEBUG_PRINT(str)  DbgPrint(str)
#else
#define DEBUG_PRINT(str)
#endif

VOID startIntervalTimer(VOID);

#define tffsReadByteFlash(r)     READ_REGISTER_UCHAR((PUCHAR)r)
#define tffsWriteByteFlash(r,b)  WRITE_REGISTER_UCHAR((PUCHAR)r,(UCHAR)b)
#define tffsReadWordFlash(r)     READ_REGISTER_USHORT((PUSHORT)r)
#define tffsWriteWordFlash(r,b)  WRITE_REGISTER_USHORT((PUSHORT)r,(USHORT)b)
#define tffsReadDwordFlash(r)     READ_REGISTER_ULONG((PULONG)r)
#define tffsWriteDwordFlash(r,b)  WRITE_REGISTER_ULONG((PULONG)r,(ULONG)b)

#define tffsReadByte(r)     READ_REGISTER_UCHAR((PUCHAR)&(r))
#define tffsWriteByte(r,b)  WRITE_REGISTER_UCHAR((PUCHAR)&(r),b)
#define tffsReadBuf(d,s,c)  READ_REGISTER_BUFFER_UCHAR((PUCHAR)s,d,c)
#define tffsWriteBuf(d,s,c) WRITE_REGISTER_BUFFER_UCHAR((PUCHAR)d,s,c)

extern void PRINTF(
                char * Message,
                ...
                );
#endif /* NT5PORT */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\flsystem.c ===
/*
 * $Log:   P:/user/amir/lite/vcs/flsystem.c_v  $
 * 
 *    Rev 1.8   19 Aug 1997 20:04:16   danig
 * Andray's changes
 * 
 *    Rev 1.7   24 Jul 1997 18:11:48   amirban
 * Changed to flsystem.c
 * 
 *    Rev 1.6   07 Jul 1997 15:21:48   amirban
 * Ver 2.0
 * 
 *    Rev 1.5   29 Aug 1996 14:18:04   amirban
 * Less assembler
 * 
 *    Rev 1.4   18 Aug 1996 13:48:08   amirban
 * Comments
 * 
 *    Rev 1.3   09 Jul 1996 14:37:02   amirban
 * CPU_i386 define
 * 
 *    Rev 1.2   16 Jun 1996 14:02:38   amirban
 * Use int 1C instead of int 8
 * 
 *    Rev 1.1   09 Jun 1996 18:16:20   amirban
 * Added removeTimer
 * 
 *    Rev 1.0   20 Mar 1996 13:33:06   amirban
 * Initial revision.
 */

/************************************************************************/
/*                                                                      */
/*		FAT-FTL Lite Software Development Kit			*/
/*		Copyright (C) M-Systems Ltd. 1995-1996			*/
/*									*/
/************************************************************************/

#include "flbase.h"

#ifdef NT5PORT

#include <ntddk.h>
NTsocketParams driveInfo[SOCKETS];
NTsocketParams * pdriveInfo = driveInfo;
VOID *myMalloc(ULONG numberOfBytes)
{
  return ExAllocatePool(NonPagedPool, numberOfBytes);
}

VOID timerInit(VOID) {};

/* Wait for specified number of milliseconds */
void flDelayMsecs(unsigned   milliseconds)
{
	unsigned innerLoop = 0xffffL;
	unsigned i,j;
	for(i = 0;i < milliseconds; i++){
		for(j = 0;j < innerLoop; j++){
		}
	}
}

#if POLLING_INTERVAL > 0

VOID   (*intervalRoutine_flsystem)(VOID);
ULONG  timerInterval_flsystem;
extern KTIMER   timerObject;
extern KDPC     timerDpc;
extern BOOLEAN  timerWasStarted;

VOID timerRoutine(    
		  IN PKDPC Dpc,
		  IN PVOID DeferredContext,
		  IN PVOID SystemArgument1,
		  IN PVOID SystemArgument2
		  )
{
  (*intervalRoutine_flsystem)();
}

/* Install an interval timer */
FLStatus flInstallTimer(VOID (*routine)(VOID), unsigned  intervalMsec)
{ 
  intervalRoutine_flsystem = routine;
  timerInterval_flsystem = intervalMsec;
  KeInitializeDpc(&timerDpc, timerRoutine, NULL);    
  KeInitializeTimer(&timerObject);
  startIntervalTimer();
  return flOK;
}

VOID startIntervalTimer(VOID)
{
  LARGE_INTEGER dueTime;
  dueTime.QuadPart = -((LONG)timerInterval_flsystem * 10);    
  KeSetTimerEx(&timerObject, dueTime, (LONG) timerInterval_flsystem, &timerDpc);
  timerWasStarted = TRUE;
}

#ifdef EXIT

/* Remove an interval timer */
VOID flRemoveTimer(VOID)
{
  if (timerWasStarted) {	
    KeCancelTimer(&timerObject);
    timerWasStarted = FALSE;
  }
  if (intervalRoutine_flsystem != NULL) {
    (*intervalRoutine_flsystem)();       /* Call it twice to shut down everything */
    (*intervalRoutine_flsystem)();
    intervalRoutine_flsystem = NULL;
  }
}

#endif	/* EXIT */

#endif	/* POLLING_INTERVAL */


/* Return current DOS time */
unsigned  flCurrentTime(VOID)
{
  return 0;	// not used
}


/* Return current DOS date */
unsigned  flCurrentDate(VOID)
{
  return 0;	// not used
}


VOID flSysfunInit(VOID)
{
  timerInit();
}


/* Return a random number from 0 to 255 */
unsigned  flRandByte(VOID)
{
  LARGE_INTEGER tickCount;
  KeQueryTickCount(&tickCount);
  return tickCount.LowPart & 0xff;
}


/*----------------------------------------------------------------------*/
/*      	       f l C r e a t e M u t e x			*/
/*									*/
/* Creates or initializes a mutex					*/
/*									*/
/* Parameters:                                                          */
/*	mutex		: Pointer to mutex				*/
/*                                                                      */
/* Returns:								*/
/*	FLStatus	: 0 on success, otherwise failure		*/
/*----------------------------------------------------------------------*/

FLStatus flCreateMutex(FLMutex *mutex)
{
	if(mutex){
		KeInitializeSpinLock(&mutex->Mutex);
		return flOK;
	}
	DEBUG_PRINT("Failed flCreateMutex()\n");
	return flGeneralFailure;

}

/*----------------------------------------------------------------------*/
/*      	       f l D e l e t e M u t e x			*/
/*									*/
/* Deletes a mutex.							*/
/*									*/
/* Parameters:                                                          */
/*	mutex		: Pointer to mutex				*/
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID flDeleteMutex(FLMutex *mutex)
{
}

/*----------------------------------------------------------------------*/
/*      	        f l T a k e M u t e x				*/
/*									*/
/* Try to take mutex, if free.						*/
/*									*/
/* Parameters:                                                          */
/*	mutex		: Pointer to mutex				*/
/*                                                                      */
/* Returns:                                                             */
/*	int		: TRUE = Mutex taken, FALSE = Mutex not free	*/
/*----------------------------------------------------------------------*/

FLBoolean flTakeMutex(FLMutex *mutex)
{
	if(mutex){		
		KeAcquireSpinLock(&mutex->Mutex, &mutex->cIrql );
		return TRUE;
	}
	DEBUG_PRINT("Failed flTakeMutex() on mutex\n");
	return FALSE;
}


/*----------------------------------------------------------------------*/
/*      	          f l F r e e M u t e x				*/
/*									*/
/* Free mutex.								*/
/*									*/
/* Parameters:                                                          */
/*	mutex		: Pointer to mutex				*/
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID flFreeMutex(FLMutex *mutex)
{
	if(mutex){
		KeReleaseSpinLock(&mutex->Mutex, mutex->cIrql);
	}
	else{
		DEBUG_PRINT("Failed flFreeMutex() on mutex\n");
	}
	
}


UCHAR flInportb(unsigned  portId)
{
  return 0;	// not used
}


VOID flOutportb(unsigned  portId, UCHAR value)
{
	// not used
}

/*----------------------------------------------------------------------*/
/*                 f l A d d L o n g T o F a r P o i n t e r            */
/*									*/
/* Add unsigned long offset to the far pointer                          */
/*									*/
/* Parameters:                                                          */
/*      ptr             : far pointer                                   */
/*      offset          : offset in bytes                               */
/*                                                                      */
/*----------------------------------------------------------------------*/
VOID FAR0*  flAddLongToFarPointer(VOID FAR0 *ptr, ULONG offset)
{
  return ((VOID FAR0 *)((UCHAR FAR0*)ptr+offset));
}

#ifdef ENVIRONMENT_VARS

void FAR0 * NAMING_CONVENTION flmemcpy(void FAR0* dest,const void FAR0 *src,size_t count)
{
  size_t i;
  unsigned char FAR0 *ldest = (unsigned char FAR0 *)dest;
  const unsigned char FAR0 *lsrc = (unsigned char FAR0 *)src;

  for(i=0;( i < count );i++,ldest++,lsrc++)
    *(ldest) = *(lsrc);
  return dest;
}


void FAR0 * NAMING_CONVENTION flmemset(void FAR0* dest,int c,size_t count)
{
  size_t i;
  unsigned char FAR0 *ldest = (unsigned char FAR0 *)dest;

  for(i=0;( i < count );i++,ldest++)
    *(ldest) = (unsigned char)c;
  return dest;
}

int NAMING_CONVENTION flmemcmp(const void FAR0* dest,const void FAR0 *src,size_t count)
{
  size_t i;
  const unsigned char FAR0 *ldest = (unsigned char FAR0 *)dest;
  const unsigned char FAR0 *lsrc = (unsigned char FAR0 *)src;

  for(i=0;( i < count );i++,ldest++,lsrc++)
    if( *(ldest) != *(lsrc) )
      return (*(ldest)-*(lsrc));
  return 0;
}

#endif

#endif /* NT5PORT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\makefile.inc ===
clean: cleanup

cleanup:
    del $(O)\trueffs.bmf
    del obj\$(TARGET_DIRECTORY)\trueffs.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\mtdsa.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/MTDSA.H_V  $
 *
 *    Rev 1.22   Apr 15 2002 08:31:12   oris
 * Added USE_TFFS_COPY compilation flag.
 * This flag is used by bios driver a Boot SDK in order to improove performance.
 *
 *    Rev 1.21   Apr 15 2002 07:38:02   oris
 * Moved system types from flBase.h
 * Moved compilation flag validations for TrueFFS to flchkdfs.h
 *
 *    Rev 1.20   Feb 19 2002 21:00:48   oris
 * Added include of "flchkfds.h"
 *
 *    Rev 1.19   Jan 28 2002 21:26:14   oris
 * Removed the use of back-slashes in macro definitions.
 *
 *    Rev 1.18   Jan 17 2002 23:03:38   oris
 * Commented out all compilation flags.
 * Replaced USE_FUNC with FL_NO_USE_FUNC so that memory access routines  uses routines by default.
 * MTD_NO_READ_BBT_CODE was separated to MTD_READ_BBT and  MTD_RECONSTRUCT_BBT
 * Added windows CE predefined system customization.
 * Changed FAR_LEVEL default - always 0 unless DOS
 * Join delay routine with matching OS definition.
 * If NULL pointers are not defined (or DOS OS) defined NULL as ((void  FAR0*)0)
 *
 *    Rev 1.17   Nov 29 2001 20:54:12   oris
 * CURRECT_OS was changed to CURRENT_OS
 * Added default FAR_LEVEL for VxWorks
 *
 *    Rev 1.16   Sep 15 2001 23:47:42   oris
 * Changed BIG_ENDIAN to FL_BIG_ENDIAN
 *
 *    Rev 1.15   Jul 29 2001 16:41:18   oris
 * Added CUR_NO_OS definition
 * Remove USE_STD_FUNC defintion when using big_endian. since memcpy function can cause memory access problems (buffers are copied from the end).
 *
 *    Rev 1.14   Jul 15 2001 21:08:02   oris
 * Changed DFORMAT_PRINT syntax to be similar to DEBUG_PRINT.
 *
 *    Rev 1.13   Jul 13 2001 01:07:28   oris
 * Bug fix - Use different memory H file include for vxWorks and DOS for memory handling (memcpy, memset and memcmp)/.
 * Added DFORMAT_PRINT macro.
 * Changed default configuration.
 *
 *    Rev 1.12   Jun 17 2001 22:30:12   oris
 * Comment NO_??? defintions.
 *
 *    Rev 1.11   Jun 17 2001 18:57:04   oris
 * Improved documentation and remove warnings.
 *
 *    Rev 1.10   Jun 17 2001 08:17:42   oris
 * Removed warnings.
 *
 *    Rev 1.9   May 21 2001 18:24:14   oris
 * Removed BDK_IMAGE_TO_FILE as a default definition.
 * Change physicalToPointer macro when FAR_LEVEL = 0.
 *
 *    Rev 1.8   May 21 2001 16:11:14   oris
 * Added  USE_STD_FUNC defintion.
 * Added memcpy memset and memcmp as defaults for tffscpy tffsset and tffscmp.
 * Removed naming conventions.
 * Removed DRIVES definition.
 *
 *    Rev 1.7   May 20 2001 14:36:14   oris
 * Reorganized header file.
 *
 *    Rev 1.6   May 16 2001 21:21:00   oris
 * Restored the SOCKETS and BINARY_PARTITIONS definitions.
 *
 *    Rev 1.5   May 09 2001 00:32:56   oris
 * Changed IPL_CODE to NO_IPL_CODE , READ_BBT_CODE to NO_READ_BBT_CODE.
 * Moved BINARY_PARTITIONS and SOCKETS to docbdk.h.
 * Removed the DOC2000_FAMILY and DOCPLUS_FAMILY.
 * Uncommented the HW_OTP compilation flag as a default for the BDK.
 *
 *    Rev 1.4   Apr 30 2001 18:03:06   oris
 * Added READ_BBT_CODE definition and IPL_CODE defintion.
 *
 *    Rev 1.3   Apr 09 2001 15:03:26   oris
 * Changed default settings to no verify write and no checksum calculation.
 *
 *    Rev 1.2   Apr 01 2001 07:53:44   oris
 * copywrite notice.
 * Alligned left all # directives.
 * Added the following compilation flag:
 *   HW_OTP
 *   MTD_FOR_EXB
 *
 *    Rev 1.1   Feb 07 2001 17:32:48   oris
 * Added SOCKETS defintion for standalone mode
 *
 *    Rev 1.0   Feb 04 2001 12:25:00   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE, OR CONTACT M-SYSTEMS         */
/*      FOR LICENSE ASSISTANCE: E-MAIL = info@m-sys.com                            */
/***********************************************************************************/


/************************************************************************/
/* TrueFFS and Standalone MTD                                           */
/************************************************************************/

/************************************************************************/
/* File Header                                                          */
/* -----------                                                          */
/* Name : mtdsa.h                                                       */
/*                                                                      */
/* Description : This file contains neccesary definition and            */
/*                 customization                                        */
/*               for the MTD standalone mode. It also contains the      */
/*               compilation flag determining the mode of operation     */
/*                 either                                               */
/*               TrueFFS or MTD standalone                              */
/*                                                                      */
/* Warning :     TrueFFS application must keep the MTD_STANDALONE       */
/*                 definition                                           */
/*               commented.                                             */
/*                                                                      */
/************************************************************************/


#ifndef MTD_SA_H
#define MTD_SA_H

/************************************************************************/
/* Uncomment the following line when using the MTD in standalone mode   */
/************************************************************************/

/* #define        MTD_STANDALONE */


/************************************************************************/
/* The rest of the file is for the BDK standalone package only          */
/************************************************************************/

#ifdef        MTD_STANDALONE

/************************************************************************/
/*                                                                      */
/*       Binary Development Kit Stand Alone Customization Area          */
/*                                                                      */
/************************************************************************/

/************************************************************************/
/* Section 1.                                                           */
/*                                                                      */
/* Customize the features to be compiled in your standalone             */
/* application. Each required feature will add to your final executable */
/* code.                                                                */
/*                                                                      */
/* Simply uncomment the required feature directive.                     */
/*                                                                      */
/************************************************************************/

/* #define ACCESS_BDK_IMAGE  */ /* Compile the binary read  routines       */
/* #define UPDATE_BDK_IMAGE  */ /* Compile the binary write routines       */
/* #define ERASE_BDK_IMAGE   */ /* Compile the binary erase routine        */
/* #define CREATE_BDK_IMAGE  */ /* Compile the binary create routine       */
/* #define PROTECT_BDK_IMAGE */ /* Compile the binary protection routines  */
/* #define HW_OTP            */ /* Compile the binary OTP routines         */
/* #define EDC_MODE          */ /* Use the EDC\ECC mechanizm               */
/* #define BDK_IMAGE_TO_FILE */ /* Compile the files related routines         */
/* #define BDK_CHECK_SUM     */ /* Calculate checksum on read operation       */
/* #define BDK_VERIFY_WRITE  */ /* Read and compare after every write         */
/* #define FL_NO_USE_FUNC    */ /* Do not use function for register access    */
/* #define D2TST             */ /* Exports the EDC syndrome with the global   */
                                /* variable saveSyndromForDumping             */
/* #define FL_BIG_ENDIAN     */ /* Used for big endian architectures          */
/* #define NO_IPL_CODE       */ /* Do not compile code for IPL read and write */
/* #define MTD_READ_BBT      */ /* Compile the read BBT routine code          */
/* #define MTD_RECONSTRUCT_BBT *//* Compile code to scan virgin cards for BBT */
/* #define DEBUG             */ /* Include debug messages                     */
/* #define USE_STD_FUNC      */ /* Use standard 'C' memcpy\memset and memcmp  */
                                /* This define must be commented out when     */
                                /* working with big endian archtechtures. The */
                                /* problem is that some implementations of    */
                                /* memcpy, copy the data from the end of the  */
                                /* buffer, therefore bad implementation for   */
                                /* DiskOnChip memory windows access routines  */
/* #define USE_TFFS_COPY     */ /* Use tffscpy/tffsset for DiskOnChip access  */

/************************************************************************/
/* General Customized constants                                         */
/* The total number of Binary partitions on the DiskOnChip              */
/************************************************************************/

#define BINARY_PARTITIONS 3
#define SOCKETS           1   /* Currently the only option */


/************************************************************************/
/*   Section 2.                                                         */
/*                                                                      */
/*   Includes OS/CPU-specific resources and customization               */
/*                                                                      */
/*   1) Uncomment relevant CURRENT_OS directive below for predefined    */
/*      customization for majore OS'es.                                 */
/*   2) Define the far level of your application's pointers.            */
/*   3) Customize pointer arithmetic routines.                          */
/*   4) Customize debug messages routine.                               */
/*   5) Default calling convention.                                     */
/*   6) NULL constant.                                                  */
/*   7) Signed/unsigned char.                                           */
/*   8) CPU target.                                                     */
/*                                                                      */
/************************************************************************/

#define CUR_NO_OS        0  /* Do not include any OS resources */
#define CUR_OS_PSOS      1  /* Include PSOS          resources */
#define CUR_OS_DOS       2  /* Include DOS           resources */
#define CUR_OS_VX_WORKS  3  /* Include VX_WORKS      resources */
#define CUR_OS_WINCE     4  /* Include Windows CE    resources */

/* #define CURRENT_OS  CUR_OS_PSOS     */  /* uncomment for pSOS    */
/* #define CURRENT_OS  CUR_OS_VX_WORKS */  /* uncomment for VxWorks */
/* #define CURRENT_OS  CUR_OS_DOS      */  /* uncomment for DOS     */
/* #define CURRENT_OS  CUR_OS_WINCE    */  /* uncomment for WINCE   */
/* #define CURRENT_OS  CUR_NO_OS       */  /* uncomment for NO OS   */

/************************************************************************/
/* Far pointers                                                         */
/*                                                                      */
/* Specify here which pointers can be far, if any.                      */
/* Far pointers are usually relevant only to 80x86 architectures.       */
/*                                                                      */
/* Specify FAR_LEVEL:                                                   */
/*   0 - If using a flat memory model or having no far pointers.        */
/*   1 - If only the DiskOnChip window may be far                       */
/*   2 - If only the DiskOnChip window and RAM window may be far.       */
/*   3 - If DiskOnChip window, RAM window and pointer(s)                */
/*       transferred to the entry-point function may be far             */
/************************************************************************/

#if (CURRENT_OS==CUR_OS_DOS)
#define FAR_LEVEL  2
#else
#define FAR_LEVEL  0
#endif /* CURRENT_OS == CUR_OS_DOS */

/************************************************************************/
/* Pointer arithmetic                                                   */
/*                                                                      */
/* The following macros define machine- and compiler-dependent macros   */
/* for handling pointers to physical bdkWindow addresses. The           */
/* definitions below are for PC real-mode Borland-C.                    */
/*                                                                      */
/* 'physicalToPointer' translates a physical flat address to a (far)    */
/* pointer. Note that if when your processor uses virtual memory, the   */
/* code should map the physical address to virtual memory, and return a */
/* pointer to that memory (the size parameter tells how much memory     */
/* should be mapped).                                                   */
/*                                                                      */
/* 'addToFarPointer' adds an increment to a pointer and returns a new   */
/* pointer. The increment may be as large as your window size. The code */
/* below assumes that the increment is larger than 64 KB and so         */
/* performs huge pointer arithmetic.                                    */
/*                                                                      */
/* 'freePointer' frees an allocated pointer. This is useful in          */
/* architectures using virtual memory.                                  */
/*                                                                      */
/* The example bellow is relevant for DOS OS                            */
/************************************************************************/

#if FAR_LEVEL > 0

#define physicalToPointer(physical,size,driveNo)          \
        MK_FP((int) ((physical) >> 4),(int) (physical) & 0xF)

#define pointerToPhysical(ptr)                  \
        (((unsigned long) FP_SEG(ptr) << 4) + FP_OFF(ptr))

#define freePointer(ptr,size) 1

#define addToFarPointer(base,increment)                \
        MK_FP(FP_SEG(base) +                        \
        ((unsigned short) ((FP_OFF(base) + (unsigned long)(increment)) >> 16) << 12), \
        FP_OFF(base) + (int) (increment))
#else

#define physicalToPointer(physical,size,driveNo) ((void *) (physical))

#define pointerToPhysical(ptr)  ((unsigned long)(ptr))

#define addToFarPointer(base,increment) ((void *) ((unsigned char *) (base) + (increment)))

#define freePointer(ptr,size) 1
#endif

/************************************************************************/
/* Debug mode                                                           */
/*                                                                      */
/* Uncomment the following lines if you want debug messages to be       */
/* printed out. Messages will be printed at initialization key points,  */
/* and when low-level errors occur.                                     */
/* You may choose to use 'printf' or provide your own routine.          */
/************************************************************************/

#if DBG
#include <stdio.h>
#define DEBUG_PRINT(p) printf p
#define DFORMAT_PRINT(p) printf p
#else
#define DEBUG_PRINT(str)
#define DFORMAT_PRINT(str)
#endif

/************************************************************************/
/* Default calling convention                                           */
/*                                                                      */
/* C compilers usually use the C calling convention to routines (cdecl),*/
/* but often can also use the pascal calling convention, which is       */
/* somewhat more economical in code size. Some compilers also have      */
/* specialized calling conventions which may be suitable. Use compiler  */
/* switches or insert a  #pragma here to select your favorite calling   */
/* convention.                                                          */
/************************************************************************/

#if (CURRENT_OS == CUR_OS_DOS)
#pragma option -p        /* Default pascal calling convention */
#endif /* CURRENT_OS == CUR_OS_DOS */

/************************************************************************/
/* NULL constant                                                        */
/*                                                                      */
/* Some compilers require a different definition for the NULL pointer   */
/************************************************************************/

#if (CURRENT_OS == CUR_OS_DOS)
#include <_null.h>
#else
#ifndef NULL
#define NULL ((void FAR0*)0)
#endif /* NULL */
#endif /* CURRENT_OS == CUR_OS_DOS */

/************************************************************************/
/* signed/unsigned char                                                 */
/*                                                                      */
/* It is assumed that 'char' is signed. If this is not your compiler    */
/* default, use compiler switches, or insert a #pragma here to define   */
/* this.                                                                */
/************************************************************************/

#if (CURRENT_OS == CUR_OS_DOS)
#pragma option -K-        /* default char is signed */
#endif /* CURRENT_OS == CUR_OS_DOS */

/************************************************************************/
/* CPU target                                                           */
/*                                                                      */
/* Use compiler switches or insert a #pragma here to select the CPU     */
/* type you are targeting.                                              */
/*                                                                      */
/* If the target is an Intel 80386 or above, also uncomment the         */
/* CPU_i386 definition.                                                 */
/************************************************************************/

#if (CURRENT_OS == CUR_OS_DOS)
#pragma option -3        /* Select 80386 CPU */
#endif /* CURRENT_OS == CUR_OS_DOS */

/***********************************************************************/
/*                    End of Customization Area                        */
/***********************************************************************/

/* Replacement for various TrueFFS definitions */

#define SECTOR_SIZE_BITS 9  /* defines the log2 of a sector size (512) */
#define        MTDS      2  /* Maximum number of registred MTDS        */

/***********************************************************************/
/* Check for missing defines dependencies Do not customized            */
/***********************************************************************/
/* 1) Update routines require the functionalities of the read routine. */
/* 2) Removal of the binary read or write routines does not remove the */
/*    flash read and write routines. In order to save on the TEXT code */
/***********************************************************************/

#ifdef UPDATE_BDK_IMAGE
#ifndef ACCESS_BDK_IMAGE
#define ACCESS_BDK_IMAGE
#endif /* !ACCESS_BDK_IMAGE */
#endif /* UPDATE_BDK_IMAGE */


/***********************************************************************/
/* Custom the MTD definitions to meet the above definitions            */
/***********************************************************************/
/* 1) EDC_MODE             -> ~ NO_EDC_MODE                            */
/* 2) BDK_VERIFY_WRITE     -> VERIFY_WRITE                             */
/* 3) USE_FUNC_FOR_ACCESS  -> ~ FL_NO_USE_FUNC                         */
/* 4) UPDATE_BDK_IMAGE     -> ~ FL_READ_ONLY                           */
/* 5) ~DOCPLUS_FAMILY      -> ~ PROTECT_BDK_IMAGE                      */
/* 6) PROTECT_BDK_IMAGE    -> HW_PROTECTION                            */
/* 7) DOS                  -> CUR_OS                                   */
/* 8) FL_BIG_ENDIAN        -> ~ USE_STD_FUNC                           */
/* 9) MTD_NO_READ_BBT_CODE -> ~ MTD_READ_BBT + ~ MTD_RECONSTRUCT_BBT   */
/***********************************************************************/

#ifdef        EDC_MODE
#ifdef        NO_EDC_MODE
#undef        NO_EDC_MODE
#endif        /* NO_EDC_MODE */
#else         /* EDC_MODE */
#define       NO_EDC_MODE
#endif        /* EDC_MODE */

#ifdef        BDK_VERIFY_WRITE
#define       VERIFY_WRITE
#endif        /* BDK_VERIFY_WRITE */

#ifdef        USE_FUNC_FOR_ACCESS
#undef        FL_NO_USE_FUNC
#endif        /* USE_FUNC_FOR_ACCESS */

#ifndef       UPDATE_BDK_IMAGE
#define       FL_READ_ONLY
#endif        /* UPDATE_BDK_IMAGE */

#if (defined(PROTECT_BDK_IMAGE) && !defined(HW_PROTECTION))
#define HW_PROTECTION
#endif  /* PRTOECTION_BDK_IMAGE */

#if (defined(FL_BIG_ENDIAN) && defined(USE_STD_FUNC))
#undef USE_STD_FUNC
#endif /* FL_BIG_ENDIAN */

#ifdef MTD_NO_READ_BBT_CODE
#undef MTD_READ_BBT
#undef MTD_RECONSTRUCT_BBT
#endif /* MTD_NO_READ_BBT_CODE */

/*********************************/
/* Include specific OS resources */
/*********************************/

#if (CURRECT_OS == CUR_OS_WINCE)
#include <windows.h>
#include "pkfuncs.h"
#include <memory.h>
#include <stdio.h>
#endif /*CUR_OS_WINCE*/


#if (CURRENT_OS == CUR_OS_VX_WORKS)
/* OS-specific includes */
#include <vxWorks.h>
#include <tickLib.h>
#include <sysLib.h>

#ifdef USE_STD_FUNC
#include "memLib.h"
#endif /* USE_STD_FUNC */
#define VXW_DELAY  /* uncomment for VxWorks delay */
#endif /* CURRENT_OS == CUR_OS_VX_WORKS */

#if (CURRENT_OS == CUR_OS_PSOS)
/* OS-specific includes */
#include <psos.h>
#include <bspfuncs.h>
#include "sys_conf.h"

#ifdef USE_STD_FUNC
#include "memLib.h"
#endif /* USE_STD_FUNC */
#define PSS_DELAY   /* uncomment for pSOS    delay */
#endif /* CURRENT_OS == CUR_PSOS */

#if (CURRENT_OS == CUR_OS_DOS)
/* OS-specific includes */
#include <dos.h>

#ifdef USE_STD_FUNC
#include "mem.h"
#endif /* USE_STD_FUNC */
#define DOS_DELAY        /* uncomment for DOS     delay */
#endif /* CURRENT_OS == CUR_OS_DOS */

/*******************************************/
/* Declare memcpy, memset, memcmp routines */
/*******************************************/

#ifdef USE_STD_FUNC
#if FAR_LEVEL > 0
#define tffscpy _fmemcpy
#define tffscmp _fmemcmp
#define tffsset _fmemset
#else
#define tffscpy memcpy
#define tffscmp memcmp
#define tffsset memset
#endif /* FAR_LEVEL */
#endif /* USE_STD_FUNC */
#endif /* MTD_STANDALONE */
#endif /* MTD_SA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\inftldbg.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/INFTLDBG.C_V  $
 * 
 *    Rev 1.0   Nov 16 2001 00:44:12   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/*************************************************/
/* T r u e F F S   5.0   S o u r c e   F i l e s */
/* --------------------------------------------- */
/*************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Name : inftldbg.c                                                          *
*                                                                            *
* Description : Implementation of INFTL debug routine.                       *
*                                                                            *
*****************************************************************************/

/*********************************************************/
/*  The following routine are for debuging INFTL chains. */
/*  They should not be compiled as part of TrueFFS based */
/*  drivers and application.                             */
/*********************************************************/

/* function prototype */

static FLStatus getUnitData(Bnand vol, ANANDUnitNo unitNo,
        ANANDUnitNo *virtualUnitNo, ANANDUnitNo *prevUnitNo,
        byte *ANAC, byte *NAC, byte *validFields);

static byte getSectorFlags(Bnand vol, CardAddress sectorAddress);


#ifdef CHECK_MOUNT
extern FILE* tl_out;

/* Macroes */

#define TL_DEBUG_PRINT     fprintf
#define STATUS_DEBUG_PRINT printf
#define SET_EXIT(x)        vol.debugState |= x   /* Add INFTL debug warnnings */
#define DID_MOUNT_FAIL     vol.debugState & INFTL_FAILED_MOUNT

#endif /* CHECK_MOUNT */

#ifdef CHAINS_DEBUG

byte * fileNameBuf1 = "Chains00.txt";
byte * fileNameBuf2 = "report.txt";

/*------------------------------------------------------------------------*/
/*                  g e t F i l e H a n d l e                             */
/*                                                                        */
/* Get file handle for debug print output file.                           */
/*                                                                        */
/* Parameters:                                                            */
/*      vol             : Pointer identifying drive                       */
/*      type            : File name identifier                            */
/*                                                                        */
/* Returns:                                                               */
/*      File handle to ourput file.                                       */
/*------------------------------------------------------------------------*/

#include <string.h>

FILE* getFileHandle(Bnand vol,byte type)
{
  char *fileName;
  char *logFileExt;

  switch (type)
  {
     case 0:
        fileName = fileNameBuf1;
        break;
     case 1:
        fileName = fileNameBuf2;
        break;
     default:
        return NULL;
  }

  logFileExt = strchr(fileName,'.');

  if (logFileExt == NULL)
  {
     return NULL;
  }
  else
  {
     (*(logFileExt-1))++;
  }

  if (DID_MOUNT_FAIL)
  {
     return (FILE *)FL_FOPEN(fileName,"a");
  }
  else
  {
    return NULL;
  }
}

/*------------------------------------------------------------------------*/
/*                  g o A l o n g V i r t u a l U n i t                   */
/*                                                                        */
/* Print the following info for a specified virtual chain:                */
/*                                                                        */
/*  Virtual  unit number : "Chain #XX :"                                  */
/*  Physical unit number : "#XX "                                         */
/*  Physical unit ANAC   : "(%XX)"                                        */
/*  Physical unit NAC    : "[%XX]"                                        */
/*  Previous unit        : "==>:" or "endofchain"                         */
/*                                                                        */
/*  The virtual unit state can have several comments:                     */
/*                                                                        */
/*  "FREE"                           - Legal state where irtual unit has  */
/*                                     no physical unit assigned          */
/*  "Chain XX is too long"           - The chains has 2 times the maxium  */
/*                                     legal chains length                */
/*  "Something wrong with chain #XX" - There is a problem with the chain: */
/*     a) "this unit should be the last in chain "                        */
/*        The ram convertin table does not have the first in chain mark   */
/*        for this unit although we know it is the last of its chain.     */
/*     b) "this unit points to the unit with the different vu no %XX"     */
/*        The virtual unit field of the current physical unit does not    */
/*        match the virtual unit number of the chain being inspected. The */
/*        new virtual unit is XX                                          */
/*                                                                        */
/* Parameters:                                                            */
/*      vol             : Pointer identifying drive                       */
/*      virtualUnit     : Number of the virtual unit to scan              */
/*      physUnits       : Physical unit table indicating the number of    */
/*                        virtual units each physical unit bellongs to.   */
/*      out             : File pointer for ouput                          */
/*                                                                        */
/* Returns:                                                               */
/*      None                                                              */
/*------------------------------------------------------------------------*/

void  goAlongVirtualUnit(Bnand vol,word virtualUnit,byte *physUnits,FILE* out)
{
  int i;
  ANANDUnitNo virtualUnitNo, prevUnitNo,unitNo;
  byte ANAC,NAC,parityPerField;
  unitNo=vol.virtualUnits[virtualUnit];

  FL_FPRINTF(out,"Chain #%d :", virtualUnit);
  if(unitNo==ANAND_NO_UNIT)
  {
     FL_FPRINTF(out,"FREE\n");
     return;
  }
  for(i=0;i<2*MAX_UNIT_CHAIN;i++)
  {
     if (physUnits != NULL)
        physUnits[unitNo]++;
     getUnitData(&vol,unitNo,&virtualUnitNo, &prevUnitNo,&ANAC,&NAC,&parityPerField);
     FL_FPRINTF(out,"#%d (%d)[%d]==>:",unitNo,ANAC,NAC);
     if(vol.physicalUnits[unitNo]&FIRST_IN_CHAIN)
     {
        FL_FPRINTF(out,"endofchain\n");
        return;
     }

     unitNo=prevUnitNo;
     if((prevUnitNo==ANAND_NO_UNIT)||(virtualUnitNo!=virtualUnit))
     {
         FL_FPRINTF(out,"\nSomething wrong with chain #%d\n",virtualUnit);
         TL_DEBUG_PRINT(tl_out,"\nSomething wrong with chain #%d\n",virtualUnit);
         SET_EXIT(INFTL_FAILED_MOUNT);
         if(prevUnitNo==ANAND_NO_UNIT)
         {
            FL_FPRINTF(out,"this unit should be the last in chain\n");
            TL_DEBUG_PRINT(tl_out,"this unit should be the last in chain (length %d)\n",i);
         }
         else
         {
            FL_FPRINTF(out,"this unit points to the unit with the different vu no %d\n",virtualUnitNo);
            TL_DEBUG_PRINT(tl_out,"this unit points to the unit with the different vu no %d\n",virtualUnitNo);
         }
         return;
     }
 }
 FL_FPRINTF(out,"Chain %d is too long \n",virtualUnit);
 TL_DEBUG_PRINT(tl_out,"Chain %d is too long \n",virtualUnit);
 SET_EXIT(INFTL_FAILED_MOUNT);
}

/*------------------------------------------------------------------------*/
/*                  c h e c k V i r t u a l C h a i n s                   */
/*                                                                        */
/* Print the physical units in each virtual unit of the media             */
/*                                                                        */
/* Parameters:                                                            */
/*      vol             : Pointer identifying drive                       */
/*      out             : File pointer to print the result                */
/*                                                                        */
/* Returns:                                                               */
/*      None                                                              */
/*------------------------------------------------------------------------*/

void checkVirtualChains(Bnand vol, FILE* out)
{
  word i;
#ifdef FL_MALLOC
  byte* physUnits;
#else
  byte physUnits[MAX_SUPPORTED_UNITS];
#endif /* FL_MALLOC */

  if (vol.noOfVirtualUnits == 0) /* Not format */
  {
     FL_FPRINTF(out,"\nThis is a format routine since no virtual unit are reported\n");
     return;
  }

#ifdef FL_MALLOC
  physUnits = (byte *)FL_MALLOC(vol.noOfUnits);
  if (physUnits == NULL)
#else
  if (MAX_SUPPORTED_UNITS < vol.noOfUnits)
#endif /* FL_MALLOC */
  {
    FL_FPRINTF(out,"\nCheck virtual chains will not check cross links due to lack of memory\n");
    TL_DEBUG_PRINT(tl_out,"\nCheck virtual chains will not check cross links due to lack of memory (no of units %d\n",vol.noOfUnits);
    SET_EXIT(INFTL_FAILED_MOUNT);
    return;
  }
  if (physUnits != NULL)
    tffsset(physUnits,0,vol.noOfUnits);

  /* Go along each of the virtual units */

  FL_FPRINTF(out,"Chains are :\n");

  for(i=0;i<vol.noOfVirtualUnits;i++)
      goAlongVirtualUnit(&vol,i,physUnits,out);

  FL_FPRINTF(out,"\nChecking if physicl units were used more then once\n");
  if (physUnits != NULL)
  {
     for(i=0;i<vol.noOfUnits;i++)
       if(physUnits[i]>1)
       {
          FL_FPRINTF(out,"Phys unit #%d were used more than once %d\n",i,physUnits[i]);
          TL_DEBUG_PRINT(tl_out,"Phys unit #%d were used more than once.\n",i);
          TL_DEBUG_PRINT(tl_out,"It was used %d times.\n",physUnits[i]);
          SET_EXIT(INFTL_FAILED_MOUNT);
       }
  }
  else
  {
     FL_FPRINTF(out,"\nCould not check due to lack of memory\n");
  }
  /* Free memory */

#ifdef FL_MALLOC
  FL_FREE(physUnits);
#endif /* FL_MALLOC */
}

/*------------------------------------------------------------------------*/
/*                c h e c k V o l u m e S t a t i s t i c s               */
/*                                                                        */
/* Print the volume statistics.                                           */
/*                                                                        */
/* Parameters:                                                            */
/*      vol             : Pointer identifying drive                       */
/*      out             : File pointer to print the result                */
/*                                                                        */
/* Returns:                                                               */
/*      None                                                              */
/*------------------------------------------------------------------------*/


void checkVolumeStatistics(Bnand vol , FILE* out)
{
  FL_FPRINTF(out,"\nThe volume statistics are:\n");
  FL_FPRINTF(out,"Socket nomber ----------------------------------- %d\n",vol.socketNo);
  FL_FPRINTF(out,"The volume internal flags ----------------------- %d\n",vol.flags);
  FL_FPRINTF(out,"Number of free units ---------------------------- %d\n",vol.freeUnits);
  TL_DEBUG_PRINT(tl_out,"Number of free units ---------------------------- %d\n",vol.freeUnits);
  FL_FPRINTF(out,"Number of boot unit ----------------------------- %d\n",vol.bootUnits);
  FL_FPRINTF(out,"Number of media units --------------------------- %d\n",vol.noOfUnits);
  FL_FPRINTF(out,"Number of virtual units ------------------------- %d\n",vol.noOfVirtualUnits);
  FL_FPRINTF(out,"Number of virtual sector on the volume ---------- %ld\n",vol.virtualSectors);
  FL_FPRINTF(out,"The media rover unit ---------------------------- %d\n",vol.roverUnit);
  FL_FPRINTF(out,"Physical first unit number of the volume -------- %d\n",vol.firstUnit);
#ifdef NFTL_CACHE
  FL_FPRINTF(out,"Physical first unit address --------------------- %d\n",vol.firstUnitAddress);
#endif /* NFTL_CACHE */
#ifdef QUICK_MOUNT_FEATURE
  FL_FPRINTF(out,"First quick mount unit -------------------------- %d\n",vol.firstQuickMountUnit);
#endif /* QUICK_MOUNT_FEATURE */
  FL_FPRINTF(out,"Number of unit with a valid sector count -------- %d\n",vol.countsValid);
  FL_FPRINTF(out,"The currently mapped sector number -------------- %ld\n",vol.mappedSectorNo);
  FL_FPRINTF(out,"The currently mapped sector address ------------- %ld\n",vol.mappedSectorAddress);

  FL_FPRINTF(out,"Number of sectors per unit ---------------------- %d\n",vol.sectorsPerUnit);
  FL_FPRINTF(out,"Number of bits needed to shift from block to unit %d\n",vol.blockMultiplierBits);
  FL_FPRINTF(out,"Number of bits used to represent a flash block -- %d\n",vol.erasableBlockSizeBits);
  FL_FPRINTF(out,"Number of bits used to represent a media unit --- %d\n",vol.unitSizeBits);

  FL_FPRINTF(out,"Number of sectors read -------------------------- %ld\n",vol.sectorsRead);
  FL_FPRINTF(out,"Number of sectors written ----------------------- %ld\n",vol.sectorsWritten);
  FL_FPRINTF(out,"Number of sectors deleted ----------------------- %ld\n",vol.sectorsDeleted);
  FL_FPRINTF(out,"Number of parasite write ------------------------ %ld\n",vol.parasiteWrites);
  FL_FPRINTF(out,"Number of units folded -------------------------- %ld\n",vol.unitsFolded);
  FL_FPRINTF(out,"The total erase counter ------------------------- %ld\n",vol.eraseSum);
  FL_FPRINTF(out,"Wear leveling counter limit---------------------- %ld\n",vol.wearLevel.alarm);
  FL_FPRINTF(out,"Wear leveling current unit ---------------------- %d\n",vol.wearLevel.currUnit);
  FL_FCLOSE(out);
}
#endif /* CHAINS_DEBUG */

#ifdef CHECK_MOUNT

/*------------------------------------------------------------------------*/
/*                c h e c k M o u n t I N F T L                           */
/*                                                                        */
/* Print Low level errors in INFTL format.                                */
/*                                                                        */
/* Parameters:                                                            */
/*      vol             : Pointer identifying drive                       */
/*                                                                        */
/* Returns:                                                               */
/*      flOK on success                                                   */
/*------------------------------------------------------------------------*/

FLStatus checkMountINFTL(Bnand vol)
{
   ANANDUnitNo erCount=0,freeUnits=0,iUnit;
   ANANDUnitNo virtualUnitNo,prevUnitNo;
   FLStatus status;
   byte pattern[SECTOR_SIZE],tempbuf[SECTOR_SIZE];
   byte sectorFlags,ANAC, NAC, prevANAC, parityPerField;
   word *erasePatt1;
   word *erasePatt2;
   word i,temp;
   dword sectorAddress;

   tffsset(pattern,0xff,SECTOR_SIZE);
   for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++)
   {
       STATUS_DEBUG_PRINT("Checking unit %d\r",iUnit);
       if (vol.physicalUnits[iUnit] != UNIT_BAD)
       {
          /*Read unit header*/
          status=getUnitData(&vol,iUnit,&virtualUnitNo, &prevUnitNo,&ANAC,&NAC,&parityPerField);
          if((status!=flOK)||(!isValidParityResult(parityPerField)))
          {
             TL_DEBUG_PRINT(tl_out,"Error going along INFTL chains - could not get unit data of %d.\n",iUnit);
             TL_DEBUG_PRINT(tl_out,"Status = %d and parityPerField is %d.\n",status,parityPerField);
             SET_EXIT(INFTL_FAILED_MOUNT);
             continue;
          }

          /* FREE unit test that it's all erased and it has erase mark */
          if((virtualUnitNo==ANAND_NO_UNIT)&&
             (prevUnitNo==ANAND_NO_UNIT)   &&
             (ANAC==ANAND_UNIT_FREE)       &&
             (NAC==ANAND_UNIT_FREE))
          {
             freeUnits++;
             for(i=0;i<(1<<(vol.unitSizeBits - SECTOR_SIZE_BITS));i++)
             {
                /* Extra area */

                if(i!=2)  /* skip erase mark at - UNIT_TAILER_OFFSET */
                {
                   checkStatus(vol.flash.read(&vol.flash,
                   unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,
                   tempbuf,16,EXTRA));
                   if(tffscmp(tempbuf,pattern,16)!=0)
                   {
                      TL_DEBUG_PRINT(tl_out,"Extra area of FREE unit is not FF's in %d unit %d sector, it is\n",iUnit,i);
                      for(temp=0;temp<16;temp++)
                        TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                      TL_DEBUG_PRINT(tl_out,"\n\n");
                      SET_EXIT(INFTL_FAILED_MOUNT);
                   }
                }
                else /* Erase mark sector offset */
                {
                   checkStatus(vol.flash.read(&vol.flash,
                   unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,
                   tempbuf,16,EXTRA));
                   if(tffscmp(tempbuf,pattern,8)!=0)
                   {
                      TL_DEBUG_PRINT(tl_out,"Extra area of FREE unit is not FF's in %d unit %d sector, it is\n",iUnit,i);
                      for(temp=0;temp<16;temp++)
                        TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                      TL_DEBUG_PRINT(tl_out,"\n\n");
                      SET_EXIT(INFTL_FAILED_MOUNT);
                   }
                   erasePatt1=(unsigned short*)(&(tempbuf[12]));
                   erasePatt2=(unsigned short*)(&(tempbuf[14]));
                   if(*erasePatt1!=ERASE_MARK)
                   {
                      TL_DEBUG_PRINT(tl_out,"First Erase mark of FREE unit is not written well in Unit %d it is %x\n",iUnit,*erasePatt1);
                   }
                   if(*erasePatt2!=ERASE_MARK)
                   {
                      TL_DEBUG_PRINT(tl_out,"Second Erase mark of FREE unit is not written well in Unit %d it is %x\n",iUnit,*erasePatt2);
                   }
                   if ((*erasePatt1!=ERASE_MARK)||(*erasePatt2!=ERASE_MARK))
                      erCount++;
                }

                /* Data area */

                checkStatus(vol.flash.read(&vol.flash,
                unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,
		        tempbuf,SECTOR_SIZE,0));
                if(tffscmp(tempbuf,pattern,SECTOR_SIZE)!=0)
                {
                   TL_DEBUG_PRINT(tl_out,"Data area of FREE unit is not FF's in %d unit %d sector it is.\n",iUnit,i);
                   for(temp=0;temp<SECTOR_SIZE;temp++)
                   {
                     if (temp%0x10==0)
                        TL_DEBUG_PRINT(tl_out,"\n");
                     TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                   }
                   TL_DEBUG_PRINT(tl_out,"\n\n");
                   SET_EXIT(INFTL_FAILED_MOUNT);
                }
             }
          }
          else /* Not a FREE unit */
          {
             /* If it's not erased test each valid sector for ecc/edc error */
             for(i=0;i<(1<<(vol.unitSizeBits - SECTOR_SIZE_BITS));i++)
             {
                sectorFlags  = getSectorFlags(&vol,unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE);
                if(sectorFlags==SECTOR_FREE)
                {
                   /* Extra area */

                   switch(i)
                   {
                      case 0: /* Do not check extra area */
                      case 4:
                         break;
                      case 2: /* Check only erase mark */
                         checkStatus(vol.flash.read(&vol.flash,
                         unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,
                         tempbuf,16,EXTRA));
                         if(tffscmp(tempbuf,pattern,8)!=0)
                         {
                            TL_DEBUG_PRINT(tl_out,"Extra area of USED unit is not FF's in %d unit %d sector, it is\n",iUnit,i);
                            for(temp=0;temp<16;temp++)
                               TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                            TL_DEBUG_PRINT(tl_out,"\n\n");
                            SET_EXIT(INFTL_FAILED_MOUNT);
                         }
                         else
                         {
                            erasePatt1=(unsigned short*)(&(tempbuf[12]));
                            erasePatt2=(unsigned short*)(&(tempbuf[14]));
                            if(*erasePatt1!=ERASE_MARK)
                            {
                               TL_DEBUG_PRINT(tl_out,"USED unit First Erase mark is not written well in Unit %d it is %x\n",iUnit,*erasePatt1);
                            }
                            if(*erasePatt2!=ERASE_MARK)
                            {
                               TL_DEBUG_PRINT(tl_out,"USED unit Second Erase mark is not written well in Unit %d it is %x\n",iUnit,*erasePatt2);
                            }
                            if ((*erasePatt1!=ERASE_MARK)||(*erasePatt2!=ERASE_MARK))
                            {
                               SET_EXIT(INFTL_FAILED_MOUNT);
                               erCount++;
                            }
                         }
                         break;

                      default: /* Make sure it is free (0xff) */
                         checkStatus(vol.flash.read(&vol.flash,
                         unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,
                         tempbuf,16,EXTRA));
                         if(tffscmp(tempbuf,pattern,16)!=0)
                         {
                            TL_DEBUG_PRINT(tl_out,"Extra area of USED unit is not FF's in %d unit %d sector, it is\n",iUnit,i);
                            for(temp=0;temp<16;temp++)
                               TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                            TL_DEBUG_PRINT(tl_out,"\n\n");
                            SET_EXIT(INFTL_FAILED_MOUNT);
                         }
                   } /* End sector number case */

                   /* Data area */

                   checkStatus(vol.flash.read(&vol.flash,
                   unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,
	    	       tempbuf,SECTOR_SIZE,0));
                   if(tffscmp(tempbuf,pattern,SECTOR_SIZE)!=0)
                   {
                      TL_DEBUG_PRINT(tl_out,"Data area of USED unit FREE sector is not FF's in %d unit %d sector it is\n",iUnit,i);
                      for(temp=0;temp<SECTOR_SIZE;temp++)
                      {
                        if (temp%0x10==0)
                           TL_DEBUG_PRINT(tl_out,"\n");
                        TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                      }
                      TL_DEBUG_PRINT(tl_out,"\n\n");
                      SET_EXIT(INFTL_FAILED_MOUNT);
                   }
                }
                else /* not a FREE sector - Used / Deleted / ignored */
                {
                   /* Extra area */

                   switch(i)
                   {
                      case 0: /* Do not check extra area */
                      case 4:
                         break;
                      case 2: /* Check only erase mark */
                         checkStatus(vol.flash.read(&vol.flash,
                         unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE+8,
                         tempbuf,8,EXTRA));
                         erasePatt1=(unsigned short*)(&(tempbuf[4]));
                         erasePatt2=(unsigned short*)(&(tempbuf[6]));
                         if(*erasePatt1!=ERASE_MARK)
                         {
                            TL_DEBUG_PRINT(tl_out,"USED unit not a free sector First Erase mark is not written well in Unit %d it is %x\n",iUnit,*erasePatt1);
                         }
                         if(*erasePatt2!=ERASE_MARK)
                         {
                            TL_DEBUG_PRINT(tl_out,"USED unit not a free sector Second Erase mark is not written well in Unit %d it is %x\n",iUnit,*erasePatt2);
                         }
                         if ((*erasePatt1!=ERASE_MARK)||(*erasePatt2!=ERASE_MARK))
                         {
                            SET_EXIT(INFTL_FAILED_MOUNT);
                            erCount++;
                         }
                         break;

                      default: /* Make sure it is free (0xff) */
                         checkStatus(vol.flash.read(&vol.flash,
                         unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE+8,
                         tempbuf,8,EXTRA));
                         if(tffscmp(tempbuf,pattern,8)!=0)
                         {
                            TL_DEBUG_PRINT(tl_out,"USED unit not a free sector is not FF's in %d unit %d sector, it is\n",iUnit,i);
                            for(temp=0;temp<8;temp++)
                               TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                            TL_DEBUG_PRINT(tl_out,"\n\n");
                            SET_EXIT(INFTL_FAILED_MOUNT);
                         }
                   } /* End sector number case */

                   /* Data area */

                   status=vol.flash.read(&vol.flash,unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,tempbuf,SECTOR_SIZE,EDC);

                   if((sectorFlags==SECTOR_DELETED)||
                      (sectorFlags==SECTOR_USED))
             	   {
         		      if(status!=flOK)
          			  {
              			 if(sectorFlags==SECTOR_USED)
                         {
			                TL_DEBUG_PRINT(tl_out,"Used sector with ");
                         }
                         else
                         {
			                TL_DEBUG_PRINT(tl_out,"Deleted sector with ");
                         }
                		 TL_DEBUG_PRINT(tl_out,"ECC/EDC error in %d unit %d sector, the data is\n",iUnit,i);
                         for(temp=0;temp<SECTOR_SIZE;temp++)
                         {
                           if (temp%0x10==0)
                              TL_DEBUG_PRINT(tl_out,"\n");
                           TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                         }
                         TL_DEBUG_PRINT(tl_out,"\n\n");
                         SET_EXIT(INFTL_FAILED_MOUNT);
           			  }
             	   }
           		   else /* sectorFlags == SECTOR_IGNORED */
                   {
                      vol.flash.read(&vol.flash,unitBaseAddress(vol,iUnit)+i*SECTOR_SIZE,tempbuf,SECTOR_SIZE,0);
           		      TL_DEBUG_PRINT(tl_out,"There is an ignored sector in %d unit %d sector the data is\n",iUnit,i);
                      for(temp=0;temp<SECTOR_SIZE;temp++)
                      {
                        if (temp%0x10==0)
                           TL_DEBUG_PRINT(tl_out,"\n");
                        TL_DEBUG_PRINT(tl_out,"%x ",tempbuf[temp]);
                      }
                      if (status == flOK)
                      {
                         TL_DEBUG_PRINT(tl_out,"\nThe EDC is fine, how about checking bit failures\n\n");
                      }
                      else
                      {
                         TL_DEBUG_PRINT(tl_out,"\nThe EDC is wrong\n\n");
                      }
                   }
                }
             } /* sector loop */
          } /* Used unit */
       } /* Good block */
    } /* unit loop */
    if (vol.debugState & INFTL_FAILED_MOUNT)
    {
       TL_DEBUG_PRINT(tl_out,"\nNote that all unit numbers are relative to first unit = %d\n",vol.firstUnit);
    }
    else
    {
       TL_DEBUG_PRINT(tl_out,"\n");
    }
    return flOK;
}
#endif /* CHECK_MOUNT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\mdocplus.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/MDOCPLUS.C_V  $
 *
 *    Rev 1.45   Apr 15 2002 07:37:38   oris
 * Changed usage and logic of checkToggle to be more intuitive.
 * Added support for new access layer (docsys). MTD now initializes the access layer accessing the DiskOnChip registers.
 * Added macro's for several special DiskOnChip registers.
 * Remove interleave if statement since new access layer simply uses different routine for int-1 and int-2.
 * Bug fix - setAsicMode routine should first exit power down before checking for access error.
 * Bug fix - forceDownload routine did not issue the download command to all DiskOnChip floors.
 * Bug fix - added verify write support for uneven address and length.
 * Bug fix - doc2write routine might not report flHWProtection when in FL_OFF mode.
 * Bug fix - readBBT when reading less then 8 bytes.
 * Bug fix - writeIPL routine did not write all copies of IPL
 * Bug fix - readIPL routine did not set Max Id properly.
 *
 *    Rev 1.44   Feb 19 2002 21:00:40   oris
 * Replaced flTimeOut status with flTimedOut.
 * Bug fix - missing initialization of returned status in otpSize routine.
 * Bug fix - read OTP routine when offset != 0
 * Bug fix - unique ID is now read with EDC.
 *
 *    Rev 1.43   Jan 29 2002 20:09:40   oris
 * Switched arguments sent to docPlusSet.
 * Added support for FL_IPL_MODE_XSCALE and changed support for FL_IPL_MODE_SA in writeIPL routine acording to new spec.
 * Added sanity check for write IPL modes.
 *
 *    Rev 1.42   Jan 28 2002 21:26:06   oris
 * Removed the use of back-slashes in macro definitions.
 * Changed docwrite and docset calls to separate DiskOnChip base window pointer and IO registers offset (for address shifting).
 * Replaced FLFlash argument with DiskOnChip memory base pointer in calls to docwrite , docset , docread, wrBuf and wrSet.
 * Removed win_io initialization (one of FLFlash record fields).
 * Improved check for flSuspend.
 * Added FL_IPL_DOWNLOAD flag to writeIPL routine in order to control whether the IPL will be reloaded after the update.
 * Removed wrBuf and wrSet macros.
 *
 *    Rev 1.41   Jan 23 2002 23:33:38   oris
 * Bug fix - checkErase routine was unreasonably slow.
 * Changed DFORMAT_PRINT syntax
 * Bug fix - bad offset of writeIPL routine caused only first 512 bytes to be written.
 * Changed readOTP not to use PARTIAL_EDC code.
 *
 *    Rev 1.40   Jan 21 2002 20:45:12   oris
 * Compilation errors for MTD_STANDALONE with BDK_VERIFY_WRITE.
 * Missing casting causes compilation error in readIPL.
 *
 *    Rev 1.39   Jan 20 2002 20:57:02   oris
 * physicalToPointer was called with wrong size argument.
 *
 *    Rev 1.38   Jan 20 2002 20:28:58   oris
 * Removed warnings.
 * Restored readIPL function initialization.
 *
 *    Rev 1.37   Jan 20 2002 12:12:26   oris
 * Removed warnings.
 *
 *    Rev 1.36   Jan 20 2002 10:10:52   oris
 * Moved mtdVars to docsoc.c (common with diskonc.c)
 * Removed warnings.
 * Replaced vol with *flash.
 * Removed flPreInitXXXX  memory access routines.
 * Added new memory access routine implementation.
 * Simplified docsys interleave-1 operations (interleave-1 operations use only 1 byte per operation. The if was made in docsys and is now a part of the MTD)
 * Bug in implementation of VERIFY_ERASE  extra area was fixed.
 * Added support for flSuspendMode environment variable.
 * Added support for 16MB Plus DiskOnChip :
 *  - Revised write IPL code
 *  - Revised read IPL code - now reads from SRAM and not flash causes download of protection logic.
 *  - OTP / Unique ID offsets were updated to be interleave dependent.
 *  - readBBT routine was changed to support DiskOnChip Millennium Plus.
 *  - Identification routine was changed.
 * Changed checkStatus with if != flOK
 * Added interrupt support under ifdef (ENABLE_EDGE__INTERRUPT /  ENABLE_LEVEL__INTERRUPT)
 * Changed NO_READ_BBT_CODE ifdef to MTD_READ_BBT.
 * Big fix in erasable Block Size Bits field of the flash record when changing interleave.
 * Added force remmapping of internal sector buffer.
 *
 *    Rev 1.35   Nov 22 2001 19:48:46   oris
 * Power consumption bug fix - chip select to the flash was remained open causing the power down mode to be ignored and the ideal current consumption to be twice the normal current.
 * Made sure that when preventing the BUSY# signal to be asserted by the download operation all other bits of the output controll register remain as they were.
 *
 *    Rev 1.34   Nov 21 2001 11:38:14   oris
 * Changed FL_WITH_VERIFY_WRITE and FL_WITHOUT_VERIFY_WRITE to FL_ON and  FL_OFF.
 *
 *    Rev 1.33   Nov 20 2001 20:25:36   oris
 * Bug fix - deep power down mode was released after access due to check of access error.
 * Bug fix - download operation did assert the BUSY#.
 *
 *    Rev 1.32   Nov 16 2001 00:23:04   oris
 * Restored byte (if_cfg=8) access for reading syndrome registers.
 *
 *    Rev 1.31   Nov 08 2001 10:49:48   oris
 * Removed warnings.
 * Added run-time control over verify write mode buffers.
 *
 *    Rev 1.30   Oct 18 2001 22:17:22   oris
 * Bug fix - incorrect read and write when performed from the middle of the page, incomplete pages , more then 1k when EDC is not requested.
 *
 *    Rev 1.29   Oct 11 2001 23:55:10   oris
 * Bug fix - Read operation to the MTD from 2 different pages (for example read operation to BDK with length > 1K) the logic that determined whether to read the last data from the pipeline is incorrect.
 *
 * 1) When reading with EDC data will be read from the I/O registers and not from the pipeline - This is not a problem, since the pipeline is not necessary.
 * 2) When reading without EDC data will be read both from the I/O registers and from the pipeline casing overwriting the last 2 bytes with 0xff.
 *
 *    Rev 1.28   Oct 10 2001 19:48:02   oris
 * Bug fix - WORD_ADD_FAR macro was misused using casing bad casting to unaligned buffers. Replaced it with read operation to an intermidiate variable and then copy byte after byte.
 *
 *    Rev 1.27   Sep 24 2001 18:24:08   oris
 * Removed warnings.
 * Added support for readBBT call for less then 8 bytes.
 * Removed DOC_PLUS_ACCESS_TYPE ifdef.
 *
 *    Rev 1.26   Sep 15 2001 23:47:20   oris
 * Placed YIELD_CPU definition under ifdef to prevent redeclaration.
 * Changed doc2erase to support up to 64K erase blocks.
 * Added reconstruct flag to readBBT routine - stating whether to reconstruct BBT if it is not available.
 * Changed all memory access routine to DiskOnChip Millennium Plus dedicated routines.
 * Changed recoverFromAccessError and setAsicMode routine to use standard memory access routines and not preInit routines.
 * Bug fix - read\write from uneven address.
 * Bug fix - read full 1k with no EDC.
 * Bug fix - first 4 blocks are not reported correctly by the readBBT()
 * Added debug print when BBT is not read well.
 *
 *    Rev 1.25   Jul 29 2001 19:15:30   oris
 * Changed file calls to macros.
 *
 *    Rev 1.24   Jul 13 2001 01:08:08   oris
 * Bug fix - rewritten VERIFY_WRITE compilation option.
 * Prevent calls to docPlusRead with 0 length.
 * Bug fix - added support for platforms that can not access single bytes.
 * Added PARTIAL_EDC read flag to the read routine.
 * Revised checkErase routine to include extra area.
 * Bug fix - missing check of write protection in doc2erase.
 * Bug fix - read bbt .
 * Insert key before writing IPL since it might be protected with the default protection.
 * Bug fix - set floor to 0 in all OTP calls.
 * Use PARTIAL_EDC in read OTP routine.
 * Added initialization of max erase cycles FLFlash field.
 *
 *    Rev 1.23   Jun 17 2001 16:39:10   oris
 * Improved documentation and remove warnings.
 *
 *    Rev 1.22   Jun 17 2001 08:17:52   oris
 * Bug fix - caused changing to interleave 1 even if already in this mode.
 * Changed NO_READ_BBT_CODE  to MTD_NO_READ_BBT_CODE.
 *
 *    Rev 1.21   May 30 2001 21:16:06   oris
 * Bug fix - pages per blocks might be used uninitialized.
 *
 *    Rev 1.20   May 17 2001 19:21:10   oris
 * Removed warnings.
 *
 *    Rev 1.19   May 16 2001 21:20:34   oris
 * Added failsafe mechanism for the download operation.
 * Changed code variable name to flCode (avoid name clashes).
 * Bug fix - read operation from extra area of second sector of page starting from offset 6 reading more then 2 bytes.
 * Bug fix - write OTP and read OTP routines  - Wrong usage of buffers.
 * Removed warnings.
 * Bug fix - enable power down routine while in MTD_STANDALONE mode.
 *
 *    Rev 1.18   May 09 2001 00:33:12   oris
 * Changed IPL_CODE to NO_IPL_CODE , READ_BBT_CODE to NO_READ_BBT_CODE.
 * Made sure that forceddownload is active when HW_OTP compilation flag is defined.
 * Removed 2 redundant ALE down calls.
 * Change all 2 consequative read operation to for in order to prevent compiler optimizations.
 *
 *    Rev 1.17   May 06 2001 22:41:52   oris
 * Bug fix - checking for access error was moved. After every set address operation and after erase confirm.
 * Bug fix - readBBT for unaligned units.
 * Removed warnings.
 * redundant was misspelled.
 *
 *    Rev 1.16   May 02 2001 07:29:50   oris
 * flInterleaveError was misspelled.
 * Added the BBT_UNAVAIL_UNIT defintion.
 *
 *    Rev 1.15   May 01 2001 14:22:56   oris
 * Bug fix - reading BBT of cascaded device.
 *
 *    Rev 1.14   Apr 30 2001 18:01:54   oris
 * Bug fix - Several ifdef caused exception since MTD buffer was not allocated.
 * Use erasableBlockSizeBits instead of erasableBlockSize when posible.
 * Added EDC check when reading the BBT.
 * Removed warrnings.
 *
 *    Rev 1.13   Apr 24 2001 17:11:14   oris
 * Bug fix - Wrong data when reading 2 bytes from data area.
 * Removed compilation problems when USE_FUNC is defined.
 * Bug fix - read\write operation with the EDC flags ignored the EXTRA flag.
 * Bug fix - ipl and otp routines causes exception in MTD_STANDALONE mode.
 * Rebuild OTP routine.
 *
 *    Rev 1.12   Apr 18 2001 21:24:54   oris
 * Bug fix - bad status code when writting in interleave - 1 fails, because changeInterleave routine is called while in access error.
 * Bug fix - removed download operation after write IPL.
 * Bug fix - Fixed casting problem in flash type identification.
 * Bug fix - Bad status code in doc2erase.
 * Bug fix - OTP area written\ read in interleave - 1
 * Bug fix - bad endian handling in OTP routines.
 * Moved forced download routine from under the MTD_STANDALONE compilation flag.
 * Removed warrnings.
 *
 *    Rev 1.11   Apr 18 2001 11:17:30   oris
 * Bug fix in getUniqueId routine.
 *
 *    Rev 1.10   Apr 18 2001 09:27:38   oris
 * Removed warrnings.
 *
 *    Rev 1.9   Apr 16 2001 21:46:58   oris
 * Bug fix - aliasing mechanism fixed.
 *
 *    Rev 1.8   Apr 16 2001 13:54:34   oris
 * Removed warrnings.
 * Bug fix - uninitialized buffer in read operation from uneven address.
 * Bug fix - report hw protection fault on write and erase operations.
 *
 *    Rev 1.7   Apr 12 2001 06:52:06   oris
 * Added setFloor in chkAsicMode in order to make sure floor does not change.
 * Added powerDown routine and registration.
 * Added download routine registration.
 * Added support for reading and writing uneven address or length.
 * Removed warrnings.
 * Bug fix for memory lick in readBBT.
 * Changed several routines to static.
 *
 *    Rev 1.6   Apr 10 2001 23:55:30   oris
 * Bug fix - in readbbt routine buffer was not incremented correctly.
 *
 *    Rev 1.5   Apr 10 2001 16:43:14   oris
 * Added multiple floor support for readbbt routine.
 * Added call for docSocketInit which initializes the socket routines.
 * Added validity check after flMap call in order to support pccard premoutn routine.
 *
 *    Rev 1.4   Apr 09 2001 19:02:34   oris
 * Removed unused variables.
 * Bug fix on erase operation to more then 1 unit.
 * Comment forced download in device identification routine.
 *
 */

/*********************************************************************/
/*                                                                   */
/*            FAT-FTL Lite Software Development Kit                  */
/*            Copyright (C) M-Systems Ltd. 1995-2001                 */
/*                                                                   */
/*********************************************************************/

/*********************************************************************
 *                                                                   *
 *    DESCRIPTION: basic mtd functions for MDOC32                    *
 *     interleave 1                                                  *
 *    page organization :                                            *
 *      512 bytes data sector 0,                                     *
 *       6 bytes ecc sector 0,                                       *
 *       2 bytes sector 0 flag,                                      *
 *       8 bytes unit data sector 0,                                 *
 *     interleave 2                                                  *
 *    page organization :                                            *
 *      512 bytes data sector 0,                                     *
 *       6 bytes ecc sector 0,                                       *
 *       2 bytes sector 0 flag,                                      *
 *       2 bytes sector 1 flags,                                     *
 *       512 bytes data sector 1 ,                                   *
 *       6 bytes ecc sector 1,                                       *
 *       8 bytes unit data sector 0,                                 *
 *       8 bytes unit data sector 1                                  *
 *                                                                   *
 *    AUTHOR: arie tamam                                             *
 *                                                                   *
 *    HISTORY: created november 14 2000                              *
 *                                                                   *
 *********************************************************************/

/*********************************************************************/
/*              | Physical address of interleave - 2 page            */
/*   Area       -----------------------------------------------------*/
/*              | First Sector       | Second Sector                 */
/*-------------------------------------------------------------------*/
/* Extra:       | 512-519, 1040-1047 | 1034-1039, 520-521, 1048-1055 */
/* Sector data  | 0-511              | 522-1033                      */
/* Sector flags | 518-519            | 520-521                       */
/* Unit data    | 1040-1047          | 1048-1055                     */
/* Edc          | 512-517            | 1034-1039                     */
/*********************************************************************/
/* Note: The address is given as a page offset 0-n where n is the    */
/* number of bytes the area has fo a sector (16 for extra , 2 for    */
/* sector flags, 8 for unit data and 512 for sector data). The       */
/* second sector address is given in a simmilar fation + 512.        */
/* Note: Extra area is exported in the floowing order:               */
/*       sector data , edc , sector flags , unit data.               */
/*********************************************************************/
/* Area A : 0 - 511  |  Area B : 512 - 1023  |  Area C : 1024 - 1055 */
/*********************************************************************/

/*********************************************************************/
/*   Area       | Physical address of interleave - 1 page            */
/*-------------------------------------------------------------------*/
/* Extra:       | 512 - 517 , 518 - 519 , 520 - 527                  */
/* Sector data  | 0   - 511                                          */
/* Edc          | 512 - 517                                          */
/* Sector flags | 518 - 519                                          */
/* Unit data    | 520 - 527                                          */
/*********************************************************************/
/* Note: The address is given as a page offset 0-n where n is the    */
/* number of bytes the area has for a sector (16 for extra , 2 for   */
/* sector flags, 8 for unit data and 512 for sector data).           */
/* Note: Extra area is exported in the floowing order:               */
/*       sector data , edc , sector flags , unit data.               */
/*********************************************************************/
/* Area A : 0 - 255  |  Area B : 256 - 511  |  Area C : 512 - 528    */
/*********************************************************************/

/** include files **/
#include "mdocplus.h"
#include "reedsol.h"
#ifdef HW_PROTECTION
#include "protectp.h"
#endif /* HW_PROTECTION */

/* Yield CPU time in msecs */
#ifndef YIELD_CPU
#define YIELD_CPU 10
#endif /* YIELD_CPU */

/* maximum waiting time in msecs */
#define MAX_WAIT  30

extern NFDC21Vars docMtdVars[SOCKETS];

/* When the MTD is used as a standalone package some of the routine     */
/* are replaced with the following macroes                              */

#ifdef MTD_STANDALONE

#define flReadBackBufferOf(a) &(globalReadBack[a][0])

#define flSocketNoOf(socket) 0 /* currently we support only a single device */

#define flMap(socket,address) addToFarPointer(socket->base, address & (socket->size - 1));
#endif /* MTD_STANDALONE */

#ifndef FL_NO_USE_FUNC

/*----------------------------------------------------------------------*/
/*              c h o o s e D e f a u l t I F _ C F G                   */
/*                                                                      */
/* Choose the default IF_CFG to use before is can actually be detected  */
/*                                                                      */
/* Parameters:                                                          */
/*     busConfig           : Socket access discriptor                   */
/*                                                                      */
/* Returns:                                                             */
/*     Suspected IF_CFG configuration (either 8 or 16).                 */
/*----------------------------------------------------------------------*/
static byte chooseDefaultIF_CFG(dword busConfig)
{
   if(( busConfig & FL_BUS_HAS_8BIT_ACCESS                    )&&
      ((busConfig & FL_XX_ADDR_SHIFT_MASK) == FL_NO_ADDR_SHIFT)  )
   {
      /* Assume if_cfg was set to 0. Interleave is irelevant */
      return 8;
   }
   /* Assume if_cfg was set to 1. Interleave is irelevant */
   return 16;
}

/*----------------------------------------------------------------------*/
/*                  s e t D O C P l u s B u s T y p e                   */
/*                                                                      */
/* Check validity and set the proper memory access routines for MTD.    */
/*                                                                      */
/* Parameters:                                                          */
/*     flash               : Pointer identifying drive                  */
/*     busConfig           : Socket access discriptor                   */
/*     interleave          : Interleave factor (1,2)                    */
/*     if_cfg              : if_cfg state:                              */
/*                              8  - 8 bit                              */
/*                              16 - 16 bit                             */
/*                                                                      */
/* Returns:                                                             */
/*      TRUE if routines are available and fit the DiskOnChip           */
/*      configuration otherwise FALSE.                                  */
/*                                                                      */
/*      The variable pointer to by busConfig is added TrueFFS private   */
/*      MTD descriptors.                                                */
/*----------------------------------------------------------------------*/

static FLBoolean setDOCPlusBusType(FLFlash * flash,
                   dword busConfig,
                   byte interleave,
                   byte if_cfg)
{
   switch(interleave)
   {
      case 1: /* No interleave */
         busConfig |= FL_8BIT_FLASH_ACCESS;
         break;
      case 2: /* 2 flashes are interleaved */
     busConfig |= FL_16BIT_FLASH_ACCESS;
     break;
      default:
         DEBUG_PRINT(("ERROR: No such interleave factor (setDOCPlusBusType).\r\n"));
          return FALSE;
   }

   switch(if_cfg)
   {
      case 8:  /* No interleave */
          busConfig |= FL_8BIT_DOC_ACCESS;
      break;
      case 16: /* 2 flashes are interleaved */
      busConfig |= FL_16BIT_DOC_ACCESS;
      break;
      default:
          DEBUG_PRINT(("ERROR: Invalid if_cfg value (setDOCPlusBusType).\r\n"));
          return FALSE;
   }

   if(setBusTypeOfFlash(flash, busConfig) != flOK)
       return FALSE;
    return TRUE;
}
#endif /* FL_NO_USE_FUNC */

#ifndef NO_EDC_MODE

      /*.*/
      /*            EDC control     */
      /*.*/

/*----------------------------------------------------------------------*/
/*                        e c c E r r o r                               */
/*                                                                      */
/* Check for EDC error.                                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*                                                                      */
/* Returns TRUE if an EDC detected an error, otherwise FALSE.           */
/*----------------------------------------------------------------------*/

static FLBoolean  eccError (FLFlash * flash)
{
  register int i;

  for(i=0;( i < 2 ); i++)
    flWrite8bitRegPlus(flash,NNOPreg, 0);

  return ((FLBoolean)flRead8bitRegPlus(flash,NECCcontrol) & ECC_CNTRL_ERROR_MASK);
}

/*----------------------------------------------------------------------*/
/*                        e c c O F F                                   */
/*                                                                      */
/* Disable ECC.                                                         */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

#define eccOFF(vol) flWrite8bitRegPlus(vol,NECCcontrol,ECC_CNTRL_IGNORE_MASK)

/*----------------------------------------------------------------------*/
/*                        e c c O N r e a d                             */
/*                                                                      */
/* Enable ECC in read mode and reset it.                                */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

#define eccONread(flash) flWrite8bitRegPlus(flash,NECCcontrol,ECC_RESET); flWrite8bitRegPlus(flash,NECCcontrol,ECC_CNTRL_ECC_EN_MASK)

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                        e c c O n w r i t e                           */
/*                                                                      */
/* Enable ECC in write mode and reset it.                               */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

#define eccONwrite(flash) flWrite8bitRegPlus(flash,NECCcontrol,ECC_RESET); flWrite8bitRegPlus(flash,NECCcontrol,ECC_CNTRL_ECC_RW_MASK | ECC_CNTRL_ECC_EN_MASK);
#endif  /* FL_READ_ONLY */
#endif  /* NO_EDC_MODE */


        /**/
        /*    Auxiliary methods   */
        /**/

/*----------------------------------------------------------------------*/
/*                        s e l e c t C h i p                           */
/*                                                                      */
/* Write to deviceSelector register.                                    */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      wp      : FLS_SEL_WP_MASK to write protect the flashes 0 to     */
/*                remove write protection.                              */
/*      dev     : Chip to select.(not used in mdocp).                   */
/*                                                                      */
/* NOTE: write protection signal is common for all of the flash devices.*/
/*----------------------------------------------------------------------*/

#define selectChip(flash, writeProtect) flWrite8bitRegPlus(flash,NflashSelect, writeProtect)

/*----------------------------------------------------------------------*/
/*                        c h k I n t e r l e v e                       */
/*                                                                      */
/* Check the current intelreave mode.                                   */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Returns: Returns 1 for interleave-1 or 2 interleave-2.               */
/*----------------------------------------------------------------------*/

#define chkInterleave(flash) (byte)(((flRead8bitRegPlus(flash,NconfigInput) & CONFIG_INTLV_MASK) == CONFIG_INTLV_MASK) ? 2 : 1)

/*----------------------------------------------------------------------*/
/*                        c h k I F _ C F G                             */
/*                                                                      */
/* Check the current if_cfg mode (number of active DiskOnChip data bits */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Returns: Either 8 or 16.                                             */
/*----------------------------------------------------------------------*/

#define chkIF_CFG(flash) (byte)((flRead8bitRegPlus(flash,NconfigInput) & CONFIG_IF_CFG_MASK) ? 16 : 8)

/*----------------------------------------------------------------------*/
/*                         s e t I p l S i z e                          */
/*                                                                      */
/* Open the extended IPL of cascaded DiskOnChip and return previous     */
/* max ID number.                                                       */
/*                                                                      */
/* Note floor 0 resides of offset 0                                     */
/*      floor 1 resides of offset 0x400                                 */
/*      floor 2 resides of offset 0x1800                                */
/*      floor 3 resides of offset 0x1c00                                */
/*                                                                      */
/* Parameters:                                                          */
/*      flash      : Pointer identifying drive                          */
/*      noOfFloors : Number of floors to open                           */
/*                                                                      */
/*                                                                      */
/* Returns: The previous max ID number.                                 */
/*----------------------------------------------------------------------*/

static byte setIplSize(FLFlash * flash, byte noOfFloors)
{
   byte prevMaxId = flRead8bitRegPlus(flash,NconfigInput);
   flWrite8bitRegPlus(flash,NconfigInput,(byte)((prevMaxId & (~CONFIG_MAX_ID_MASK))|((noOfFloors-1)<<4)));
   return (prevMaxId & CONFIG_MAX_ID_MASK);
}

/*----------------------------------------------------------------------*/
/*                    g e t C o n t r o l l e r I D                     */
/*                                                                      */
/* Get the controller (ASIC) indetification byte from offset 0x1000.    */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Returns: One of the following values.                                */
/*       CHIP_ID_MDOCP - 0x40 - DiskOnChip Millennium Plus 32MB         */
/*       CHIP_ID_MDOCP - 0x41 - DiskOnChip Millennium Plus 16MB         */
/*       other         - Unknown DiskOnChip                             */
/*----------------------------------------------------------------------*/

#define getControllerID(flash) flRead8bitRegPlus(flash,NchipId)

/*----------------------------------------------------------------------*/
/*                             b u s y                                  */
/*                                                                      */
/* Pole the selected flash busy signal.                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*                                                                      */
/* Returns TRUE if the flash is busy, otherwise FALSE.                  */
/*----------------------------------------------------------------------*/

#define busy(flash) (((flRead8bitRegPlus(flash,NflashControl) & (Reg8bitType)FLS_FR_B_MASK) == FLS_FR_B_MASK) ? FALSE:TRUE)

/*----------------------------------------------------------------------*/
/*                        w a i t F o r R e a d y                       */
/*                                                                      */
/* Wait until flash device is ready or timeout.                         */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/* Returns:                                                             */
/*      FALSE if timeout error, otherwise TRUE.                         */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLBoolean  waitForReady (FLFlash * flash)
{
  volatile Reg8bitType junk = 0;
  int i;

  /* before polling for BUSY status perform 4 read operations from
     NNOPreg */
  for(i=0;( i < 4 ); i++ )
    junk += flRead8bitRegPlus(flash,NNOPreg);

  for(i=0;( i < BUSY_DELAY ); i++)
  {
    if( busy(flash) )
    {
      continue;  /* it's not ready */
    }
    return( TRUE );                     /* ready at last.. */
  }

  DEBUG_PRINT(("Debug: timeout error in waitForReady routine.\r\n"));

  /* Restore write proection to reduce power consumption */
  selectChip(flash,MPLUS_SEL_WP);
  return( FALSE );
}

#ifndef MTD_STANDALONE
#ifndef DO_NOT_YIELD_CPU
/*----------------------------------------------------------------------*/
/*              w a i t F o r R e a d y W i t h Y i e l d C P U         */
/*                                                                      */
/* Wait until flash device is ready or timeout.                         */
/* The function yields CPU while it waits till flash is ready           */
/*                                                                      */
/* Parameters:                                                          */
/*  flash : Pointer identifying drive                                   */
/*                                                                      */
/* Returns:                                                             */
/*  FALSE if timeout error, otherwise TRUE.                             */
/*----------------------------------------------------------------------*/

static FLBoolean  waitForReadyWithYieldCPU (FLFlash * flash, word millisecToSleep)
{
   int i;

   for (i=0;  i < (millisecToSleep / YIELD_CPU); i++)
   {
  #ifndef NT5PORT
      flsleep(YIELD_CPU);
    #endif /*NT5PORT*/
      if( busy(flash) )
         continue;
      return( TRUE );                     /* ready at last.. */
   }
   return( FALSE );
}
#endif /* DO_NOT_YIELD_CPU */
#endif /* MTD_STANDALONE */

/*----------------------------------------------------------------------*/
/*                        s e l e c t F l o o r                         */
/*                                                                      */
/* Change the floor according to the given address.                     */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      address : Address of the new floor                              */
/*                                                                      */
/* Note - global variable NFDC21thisVars->currentFloor is updated       */
/*----------------------------------------------------------------------*/

static void selectFloor (FLFlash * flash, CardAddress address)
{
  if( flash->noOfFloors > 1 )
  {
    NFDC21thisVars->currentFloor = (byte)(address >> NFDC21thisVars->floorSizeBits);
    setFloor(flash,NFDC21thisVars->currentFloor);  /* select ASIC */
  }
}

/*----------------------------------------------------------------------*/
/*                  r e l e a s e P o w e r D o w n                     */
/*                                                                      */
/* Release the controller (ASIC) from power down mode.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Note - While in power down the registers can not be read or written  */
/*        to.                                                           */
/*----------------------------------------------------------------------*/

void releasePowerDown(FLFlash * flash)
{
  int i;
  volatile Reg8bitType junk = 0;

  /*  perform 3 reads + 1 from 0x1fff */
  for(i = 0;( i < 4 ); i++ )
    junk += flRead8bitRegPlus(flash,NreleasePowerDown);
}

/*----------------------------------------------------------------------*/
/*                  i s A c c e s s E r r o r                           */
/*                                                                      */
/* Check if protection violation had accured.                           */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Note - While in protection violation state, the registers can not be */
/* read or written to.                                                  */
/*                                                                      */
/* Returns: TRUE on protection violation, otherwise FALSE.              */
/*----------------------------------------------------------------------*/

#define isAccessError(flash) ((flRead8bitRegPlus(flash,NprotectionStatus) & PROTECT_STAT_ACCERR) ? TRUE:FALSE)

/*----------------------------------------------------------------------*/
/*              r e c o v e r A c c e s s E r r o r                     */
/*                                                                      */
/* Recover from protection violation.                                   */
/*                                                                      */
/* Note : DiskOnChip must already be in Normal mode.                    */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Note : If the device was indeed in access error the routine will     */
/*        force the device into reset mode.                             */
/*                                                                      */
/* Returns: flOK on success, otherwise flHWProtection.                  */
/*----------------------------------------------------------------------*/

static FLStatus recoverFromAccessError(FLFlash * flash)
{
    int i = 0;

    /* Check if there realy is an access error if not return */
    if(isAccessError(flash)==FALSE)
        return flOK;

    /* Folloing is the sequance to remove the protection violation */
    /* Write 0xff to the flash command register                    */
    /* Write twice to the write pipeline termination register      */
    /* Write once to the NOop register                             */

    flWrite8bitRegPlus(flash,NflashCommand,(Reg8bitType)RESET_FLASH);
    for(i = 0; i< 2; i++)
       flWrite8bitRegPlus(flash,NwritePipeTerm,(Reg8bitType)0);
    flWrite8bitRegPlus(flash,NNOPreg,(Reg8bitType)0);

    /* Check if access error was removed */
    if (flRead8bitRegPlus(flash,NprotectionStatus) & PROTECT_STAT_ACCERR)
    {
        DEBUG_PRINT(("Can't recover from protection violation\r\n"));
        return flHWProtection;
    }
    return flOK;
}

/*----------------------------------------------------------------------*/
/*                       s e t A S I C m o d e                          */
/*                                                                      */
/* Set the controller (ASIC) operation mode.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      mode    : One of the modes below:                               */
/*                 DOC_CNTRL_MODE_RESET    - Reset mode                 */
/*                 DOC_CNTRL_MODE_NORMAL   - Normal mode                */
/*                 DOC_CNTRL_MODE_PWR_DWN  - Power down mode            */
/*                                                                      */
/* Note: The mode is common to all cascaded floors.                     */
/*                                                                      */
/* Returns: flOK on success, otherwise flHWProtection.                  */
/*----------------------------------------------------------------------*/

static FLStatus setASICmode (FLFlash * flash, Reg8bitType mode)
{
   volatile Reg8bitType stat = 0;

   /* Get out of power down mode - just in case */
   releasePowerDown(flash);

   /* Set ASIC state
    * Use default bit values to all bits but the last 2 mode bits
    * ORed with the given mode. The mode is written to the the
    * NDOCcontrol register and its complement to the
    * NDOCcontrolConfirm register
    */

   stat = DOC_CNTRL_DEFAULT | mode;
   flWrite8bitRegPlus(flash,NDOCcontrol,stat); /* the control data */
   flWrite8bitRegPlus(flash,NDOCcontrolConfirm, (Reg8bitType)~stat);  /* confirm */

   if (mode & DOC_CNTRL_MODE_PWR_DWN)
     return flOK;

   /* Read Controller's (ASIC) modes register */
   stat = flRead8bitRegPlus(flash,NDOCcontrol);

   /* Check for power down mode      */
   if (stat & DOC_CNTRL_MODE_NORMAL)
   {
      /* Check for protection violation */
      return recoverFromAccessError(flash);
   }
   return flOK;
}

/*----------------------------------------------------------------------*/
/*                       c h k A S I C m o d e                          */
/*                                                                      */
/* Check the controller (ASIC) mode and change it to normal.            */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Note: The mode is common to all cascaded floors.                     */
/* Note: This routine is called by each of the MTD exported routine.    */
/*                                                                      */
/* Returns: flOK on success, otherwise flHWProtection.                  */
/*----------------------------------------------------------------------*/

FLStatus chkASICmode (FLFlash * flash)
{
   volatile Reg8bitType stat;
   FLStatus status = flOK;

   stat = flRead8bitRegPlus(flash,NDOCcontrol);

   if ((isAccessError(flash) == TRUE) ||       /* Protection violation   */
       (!(stat & DOC_CNTRL_MODE_NORMAL))) /* already in normal mode */
   {
      status = setASICmode(flash,DOC_CNTRL_MODE_NORMAL);
      setFloor (flash, NFDC21thisVars->currentFloor);
   }
   return status;
}

/*----------------------------------------------------------------------*/
/*                     c h k I P L D o w n l o a d                      */
/*                                                                      */
/* Check if IPL was downloaded without an IPL dwonload error.           */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*                                                                      */
/* Returns: TRUE if download was succesfull on both copies.             */
/*----------------------------------------------------------------------*/

#define chkIPLDownload(flash) ((flRead8bitRegPlus(flash, NdownloadStatus) & (DWN_STAT_IPL0 | DWN_STAT_IPL1)) ?  FALSE : TRUE)

/*----------------------------------------------------------------------*/
/*                     c h k A S I C D o w n l o a d                    */
/*                                                                      */
/* Check if DPS and OTP were downloaded without any error from the      */
/* specified floor.                                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*      floor           : The floor to check                            */
/*                                                                      */
/* Note - The routine changes the controller (ASIC) mode to normal.     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, flBadDownload on download error */
/*                        and flHWProtection if controller mode could   */
/*                        not be changed.                               */
/*----------------------------------------------------------------------*/

static FLStatus chkASICDownload (FLFlash * flash,byte floorNo)
{
   FLStatus status;
   status = setASICmode(flash, DOC_CNTRL_MODE_NORMAL);
   if(status != flOK)
      return status;
   setFloor(flash,floorNo);
   if(flRead8bitRegPlus(flash,NdownloadStatus) & DWN_STAT_DWLD_ERR)
     return flBadDownload;
   return flOK;
}

/*----------------------------------------------------------------------*/
/*                       p o w e r D o w n                              */
/*                                                                      */
/* Change the device mode to minimal power consumption (but not active) */
/* and back to normal mode.                                             */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*      state           : DEEP_POWER_DOWN flag for entering power down  */
/*                        otherwise return to normal mode.              */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise fail.                 */
/*----------------------------------------------------------------------*/

static FLStatus powerDown(FLFlash * flash, word state)
{
   if (state & DEEP_POWER_DOWN)
   {
     return setASICmode (flash, DOC_CNTRL_MODE_PWR_DWN);
   }
   else
   {
     return chkASICmode (flash);
   }
}

#if (defined(HW_PROTECTION) || !defined(NO_IPL_CODE) || defined (HW_OTP))
/*----------------------------------------------------------------------*/
/*                       f o r c e D o w n l o a d                      */
/*                                                                      */
/* Force download of protection mechanism and IPL code.                 */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*                                                                      */
/* Note - The routine changes the controller (ASIC) mode to normal.     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, flBadDownload on download error */
/*                        and flHWProtection if controller mode could   */
/*                        not be changed.                               */
/*----------------------------------------------------------------------*/

static FLStatus forceDownLoad(FLFlash * flash)
{
   volatile Reg8bitType val;
   register byte        i;
   dword                counter = 0;
   FLStatus             status;

   /* Prevent assertion of the BUSY# signal */
   for(i=0;i<flash->noOfFloors;i++)
   {
      /* Select floor */
      setFloor(flash,i);
      /* Remove last bit */
      val = flRead8bitRegPlus(flash, NoutputControl) & OUT_CNTRL_BSY_DISABLE_MASK;
      flWrite8bitRegPlus(flash, NoutputControl, val);
   }

   /* Force download */
   flWrite8bitRegPlus(flash, NfoudaryTest, FOUNDRY_WRITE_ENABLE);
   flWrite8bitRegPlus(flash, NfoudaryTest, FOUNDRY_DNLD_MASK);
   flDelayMsecs(100);

   /* Check that the download is really over. The Device does not
      respond while in download state therfore we try to write and
      read to a harmless register 10 times assuming if all 10 times
      are good then the download is over */
   do
   {
      /* Set device to normal mode */
      flWrite8bitRegPlus(flash,NDOCcontrol,DOC_CNTRL_DEFAULT | DOC_CNTRL_MODE_NORMAL);
      flWrite8bitRegPlus(flash,NDOCcontrolConfirm,(byte)(~(DOC_CNTRL_DEFAULT | DOC_CNTRL_MODE_NORMAL)));

      for (i=0; i<10; i++,counter++) /* must get expecetd result 10 times in a row */
      {
        val = (i & 1 ? 0x55 : 0xAA) + i;           /* generate various data for the test pattern */
        flWrite8bitRegPlus(flash,NaliasResolution,(byte)val); /* write the test data                        */
        flWrite8bitRegPlus(flash,NNOPreg,(byte)~val);         /* put the complement on the data bus         */
        if (flRead8bitRegPlus(flash,NaliasResolution) != (byte)val) /* verify test data                     */
           break;                                 /* still downloading so start over            */
       }
   } while ((i < 10) && (counter < DOWNLOAD_BUSY_DELAY)); /* i==10 only when download has completed */

   /* Check for download errors on all floors */
   for (i=0;i<flash->noOfFloors;i++)
   {
     status = chkASICDownload(flash,i);
     if(status != flOK)
       return status;
   }

   return flOK;
}

#endif /* HW_PROTECTION or !NO_IPL_CODE or HW_OTP */

/*----------------------------------------------------------------------*/
/*                      c h e c k T o g g l e                           */
/*                                                                      */
/* Read the toggle bit twice making sure it toggles.                    */
/*                                                                      */
/* Note : This routine assumes that the memory access routines have     */
/* already been initialized by the called routine.                      */
/*                                                                      */
/* Parameters:                                                          */
/*      FLFlash      : Pointer to flash structure.                      */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus: TRUE if the bit toggles verifing that this is indeed  */
/*                a DiskOnChip device, otherwise FALSE.                 */
/*----------------------------------------------------------------------*/

static FLBoolean checkToggle(FLFlash * flash)
{
   volatile Reg8bitType toggle1;
   volatile Reg8bitType toggle2;

   toggle1 = flRead8bitRegPlus(flash,NECCcontrol);
   toggle2 = toggle1 ^ flRead8bitRegPlus(flash,NECCcontrol);

   if( (toggle2 & ECC_CNTRL_TOGGLE_MASK) == 0 )
   {
      return FALSE;
   }
   return TRUE;
}

#ifndef MTD_STANDALONE

/*----------------------------------------------------------------------*/
/*                c h e c k W i n F o r D O C P L U S                   */
/*                                                                      */
/* Send commands to release MDOCP from power down, reset it and set it  */
/* normal mode. Then make sure this is an MDOCP by reading chip ID and  */
/* check the toggle bit.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      socketNo            : Device number                             */
/*      memWinPtr           : Pointer to DiskOnChip window              */
/*                                                                      */
/* Returns: TRUE if this is an MDOCP, otherwise FALSE.                  */
/*----------------------------------------------------------------------*/

FLBoolean checkWinForDOCPLUS(unsigned socketNo, NDOC2window memWinPtr)
{
   register int i;
   volatile Reg8bitType junk = 0;
   Reg8bitType prevNDOCcontrol, prevNDOCcontrolConfirm;
   FLFlash * flash = flFlashOf(socketNo);

   /* Initialize socket memory access routine */
   flash->win = memWinPtr;

#ifndef FL_NO_USE_FUNC
   if(setDOCPlusBusType(flash, flBusConfig[socketNo] , 1,
      chooseDefaultIF_CFG(flBusConfig[socketNo])) == FALSE)
      return FALSE;
#endif /* FL_NO_USE_FUNC */

   /* release from Power Down Mode                   */
   /*  perform 3 reads from anywhere + 1 from 0x1fff */
   for(i = 0;( i < 4 ); i++ )
     junk += flRead8bitRegPlus(flash,NreleasePowerDown);

   /* Save memory data before writting it */
   prevNDOCcontrol = flRead8bitRegPlus(flash,NDOCcontrol);
   prevNDOCcontrolConfirm = flRead8bitRegPlus(flash,NDOCcontrolConfirm);

   /* set ASIC to RESET MODE */
   junk = DOC_CNTRL_DEFAULT | DOC_CNTRL_MODE_RESET;
   flWrite8bitRegPlus(flash,NDOCcontrol,junk); /* the control data */
   flWrite8bitRegPlus(flash,NDOCcontrolConfirm,(Reg8bitType)~junk);  /* confirm */

   /* set ASIC to NORMAL MODE */
   junk |= DOC_CNTRL_MODE_NORMAL; /* write normal mode */
   flWrite8bitRegPlus(flash,NDOCcontrol,junk); /* the control data */
   flWrite8bitRegPlus(flash,NDOCcontrolConfirm,(Reg8bitType)~junk);  /* confirm */

   /* check if it's MDOCP ID + check the toggle bit */
   junk = getControllerID(flash);
   if((junk == CHIP_ID_MDOCP) || (junk == CHIP_ID_MDOCP16))
   {
#ifndef FL_NO_USE_FUNC
     /* Check if_cfg before checking toggle bit */
     if(setDOCPlusBusType(flash,flBusConfig[socketNo],1,chkIF_CFG(flash)) == FALSE)
     {
        setDOCPlusBusType(flash,flBusConfig[socketNo],1,
                          chooseDefaultIF_CFG(flBusConfig[socketNo]));
     }
     else
#endif /* FL_NO_USE_FUNC */
     {
        if(checkToggle(flash))
           return TRUE;
     }
   }

   /* If this is not a MDOCP return the previous values */
   flWrite8bitRegPlus(flash,NDOCcontrol,prevNDOCcontrol);
   flWrite8bitRegPlus(flash,NDOCcontrolConfirm,prevNDOCcontrolConfirm);
   return FALSE;
}
#endif /* MTD_STANDALONE */

/*----------------------------------------------------------------------*/
/*                f l D o c W i n d o w B a s e A d d r e s s           */
/*                                                                      */
/* Return the host base address of the window.                          */
/* If the window base address is programmable, this routine selects     */
/* where the base address will be programmed to.                        */
/*                                                                      */
/* Parameters:                                                          */
/*      socketNo    :    FLite socket No (0..SOCKETS-1)                 */
/*      lowAddress,                                                     */
/*      highAddress :   host memory range to search for DiskOnChip Plus */
/*                      memory window                                   */
/*                                                                      */
/* Returns:                                                             */
/*      Host physical address of window divided by 4 KB                 */
/*      nextAddress :   The address of the next DiskOnChip.             */
/*----------------------------------------------------------------------*/

static unsigned flDocWindowBaseAddress(byte socketNo, dword lowAddress,
                                dword highAddress, dword *nextAddress)
{
#ifndef NT5PORT

  dword                winSize;
  FLFlash              *flash;
  FLBoolean            stopSearch = FALSE;
  volatile Reg8bitType junk       = 0;

  /* if memory range to search for DiskOnChip window is not specified      */
  /* assume the standard x86 PC architecture where DiskOnChip Plus appears */
  /* in a memory range reserved for BIOS expansions                        */
  if (lowAddress == 0x0L)
  {
    lowAddress  = START_ADR;
    highAddress = STOP_ADR;
  }

  /* Initialize socket memory access routine */
  flash = flFlashOf(socketNo);

#ifndef FL_NO_USE_FUNC
   if(setDOCPlusBusType(flash, flBusConfig[socketNo], 1,
      chooseDefaultIF_CFG(flBusConfig[socketNo])) == FALSE)
      return ( 0 );
#endif /* FL_NO_USE_FUNC */

  winSize = DOC_WIN;

  /* set all possible controllers (ASIC) to RESET MODE */
  for(*nextAddress = lowAddress; *nextAddress <= highAddress;
      *nextAddress += winSize)
  {
     flash->win = (NDOC2window)physicalToPointer(*nextAddress,winSize,socketNo);

     junk = DOC_CNTRL_DEFAULT | DOC_CNTRL_MODE_RESET;
     flWrite8bitRegPlus(flash,NDOCcontrol,junk); /* the control data */
     flWrite8bitRegPlus(flash,NDOCcontrolConfirm,(Reg8bitType)~junk);  /* confirm */
  }

  /* current address initialization */
  for(*nextAddress = lowAddress ; *nextAddress <= highAddress ;
      *nextAddress += winSize)
  {
      flash->win = (NDOC2window)physicalToPointer(*nextAddress,winSize,socketNo);
      /* set controller (ASIC) to NORMAL MODE */
      junk = DOC_CNTRL_DEFAULT | DOC_CNTRL_MODE_NORMAL; /* write normal mode */
      flWrite8bitRegPlus(flash,NDOCcontrol,junk); /* the control data */
      flWrite8bitRegPlus(flash,NDOCcontrolConfirm,(Reg8bitType)~junk);  /* confirm */
      junk = getControllerID(flash);
      if((junk != CHIP_ID_MDOCP) && (junk != CHIP_ID_MDOCP16))
      {
         if( stopSearch == TRUE )  /* DiskOnChip was found */
           break;
         else
           continue;
      }
      if( stopSearch == FALSE )
      {
         /* detect card - identify bit toggles on consequitive reads */
#ifndef FL_NO_USE_FUNC
         /* Check if_cfg before checking toggle bit */
         if(setDOCPlusBusType(flash,flBusConfig[socketNo],1,chkIF_CFG(flash)) == FALSE)
         {
            setDOCPlusBusType(flash,flBusConfig[socketNo], 1,
                              chooseDefaultIF_CFG(flBusConfig[socketNo]));
            continue;
         }
#endif /* FL_NO_USE_FUNC */
         if(checkToggle(flash) == FALSE)
            continue;

         /* DiskOnChip found, mark alias resolution register */
         flWrite8bitRegPlus(flash,NaliasResolution,(Reg8bitType)ALIAS_RESOLUTION);
         stopSearch = TRUE;
         lowAddress = *nextAddress;   /* save DiskOnChip address */
      }
      else  /* DiskOnChip found, continue to skip aliases */
      {
         /* skip Aliases that have the mark */
         if(flRead8bitRegPlus(flash,NaliasResolution) != ALIAS_RESOLUTION)
            break;
      }
  }
  if( stopSearch == FALSE )  /* DiskOnChip  memory window not found */
    return( 0 );

  return((unsigned)(lowAddress >> 12));

#else /*NT5PORT*/
        DEBUG_PRINT(("Tffsport mdocplus.c :flDocWindowBaseAddress(): Before returning baseAddress()\n"));
        return (unsigned)(((ULONG_PTR)pdriveInfo[socketNo].winBase)>> 12);
#endif /*NT5PORT*/

}

/*----------------------------------------------------------------------*/
/*                         s e t A d d r e s s                          */
/*                                                                      */
/* Latch address to selected flash device.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*      address         : byte address to latch.                        */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus setAddress (FLFlash * flash, CardAddress address)
{
  /*
   *  bits  0..7     stays as are
   *  bit      8     is thrown away from address
   *  bits 31..9 ->  bits 30..8
   */

  address &= NFDC21thisVars->floorSizeMask;            /* Convert to floor offset        */
  address = address >> (flash->interleaving-1);        /* Convert to interleaved address */
  address = ((address >> 9) << 8)  |  ((byte)address); /* Remove bit 8                   */

  /* Send 3 bytes addres */
  flWrite8bitRegPlus(flash,NflashAddress,(byte)address);
  flWrite8bitRegPlus(flash,NflashAddress,(byte)(address >> 8));
  flWrite8bitRegPlus(flash,NflashAddress,(byte)(address >> 16));

  /* write twice to pipeline termination register */
  flWrite8bitRegPlus(flash,NwritePipeTerm,(Reg8bitType)0);
  flWrite8bitRegPlus(flash,NwritePipeTerm,(Reg8bitType)0);

  if (waitForReady(flash)==FALSE)     /* wait for ready */
    return flTimedOut;

  if (isAccessError(flash) == TRUE)  /* Protection violation   */
  {
    /* Restore write proection to reduce power consumption */
    selectChip(flash,MPLUS_SEL_WP);
    return flHWProtection;
  }
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                        c o m m a n d                                 */
/*                                                                      */
/* Latch command byte to selected flash device.                         */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      code    : Command to set.                                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void command(FLFlash * flash, Reg8bitType flCode)
{
    /* write the command to the flash */
    flWrite8bitRegPlus(flash,NflashCommand,flCode);
    /* write twice to pipline termination register */
    flWrite8bitRegPlus(flash,NwritePipeTerm,flCode);
    flWrite8bitRegPlus(flash,NwritePipeTerm,flCode);
}

/*----------------------------------------------------------------------*/
/*                        r d B u f                                     */
/*                                                                      */
/* Auxiliary routine for reading from flash I\O registers.              */
/* It can be data,status or flash ID.                                   */
/*                                                                      */
/* Note - The read procedure is devided into 3 parts:                   */
/*          1) pipeline initialization.                                 */
/*          2) read data from aliased I\O registers.                    */
/*          3) read the last 2 bytes from the last data read register.  */
/* Note - Only the last 2 bytes are read from the pipeline (not 4).     */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      buf     : Buffer to read into.                                  */
/*      howmany : Number of bytes to read.                              */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void rdBuf (FLFlash * flash, void FAR1 *buf, word howmany)
{
    volatile Reg16bitType junkWord = 0;
    register int i;
    word length = TFFSMAX(0,(Sword)howmany-2);

    switch(NFDC21thisVars->if_cfg)
    {
       case 16:     /* Host access type is 16 bit */
           switch (flash->interleaving)
           {
              case 1:
                 /* Pineline init */
                 for (i = 0; i < ((howmany == 1) ? 1 : 2); i++)
                    junkWord = flRead16bitRegPlus(flash, NreadPipeInit);
                 /* Read data */
                 if (length > 0) /* Can use only one byte (int1 operation) */
                 {
                    docPlusRead(flash->win,NFDC21thisIO,(byte FAR1 *)buf,length);
                 }
                 /* Before reading the last data perform dummy read cycles */
                 for (i=0; i< ((howmany > 1) ? 0 : 2 ); i++)
                    junkWord = flRead16bitRegPlus(flash, NreadLastData_1);
                 /* Read last data from last data read registers */
                 for (i = length ; i < howmany ; i++)
                    *BYTE_ADD_FAR(buf,i) = flRead8bitRegPlus(flash, NreadLastData_1);
                 break;

              case 2:
                 /* Pineline init */
                 for (i=0; i< ((howmany < 4) ? 1 : 2); i++)
                    junkWord = flRead16bitRegPlus(flash, NreadPipeInit);
                 /* Read data */
                 if (length > 0)
                 {
                    docPlusRead(flash->win,NFDC21thisIO,(byte FAR1 *)buf,length);
                 }
                 /* Before reading the last data perform dummy read cycles */
                 for (i = 0; i < ((howmany > 3) ? 0 : 2) ; i++)
                    junkWord = flRead16bitRegPlus(flash, NreadLastData_1);
                 /* Read last data from last data read registers */
                 for (i = length ; i < howmany ; i += flash->interleaving)
                 {
                    junkWord = flRead16bitRegPlus(flash, NreadLastData_1);
                    *BYTE_ADD_FAR(buf,i)   = ((byte FAR1*)(&junkWord))[0];
                    *BYTE_ADD_FAR(buf,i+1) = ((byte FAR1*)(&junkWord))[1];
                 }
           }
           break;

       case 8:      /* Host access type is 8 bit */
          /* Pineline init */
          for (i=0; i< ((howmany >> (flash->interleaving -1)) ==1 ?1:2); i++)
            junkWord += flRead8bitRegPlus(flash, NreadPipeInit);
          /* Read data */
          if (length > 0)
             docPlusRead(flash->win,NFDC21thisIO,(byte FAR1 *)buf,length);
          /* Before reading the last data perform dummy read cycles */
          for (i=0; ( i < ((howmany >> (flash->interleaving -1)) > 1 ?
               0 : ((flash->interleaving == 2) ? 4:2)));i++)
             junkWord = flRead8bitRegPlus(flash, NreadLastData_1);
          /* Read last data from last data read registers */
          for (i=length ; i< howmany ; i++)
          {
             *BYTE_ADD_FAR(buf,i) = flRead8bitRegPlus(flash, NreadLastData_1);
          }
          break;
     }
}

/*----------------------------------------------------------------------*/
/*                        r d B u f S                                   */
/*                                                                      */
/* Auxiliary routine for reading from flash I\O registers.              */
/* This routine is the pipeline initialization of the full rdBuf func'. */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      howmany : Number of bytes to read.                              */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void rdBufS (FLFlash * flash, word howmany)
{
    volatile Reg16bitType junkWord = 0;
    register int i;

    switch(NFDC21thisVars->if_cfg)
    {
       case 16:     /* Host access type is 16 bit */
          /* Pineline init */
          for (i=0; i< ((howmany >> (flash->interleaving -1)) ==1 ?1:2); i++)
            junkWord = flRead16bitRegPlus(flash, NreadPipeInit);
          break;

       case 8:      /* Host access type is 8 bit */
          /* Pineline init */
          for (i=0; i< ((howmany >> (flash->interleaving -1)) ==1 ?1:2); i++)
            junkWord += flRead8bitRegPlus(flash, NreadPipeInit);
          break;
    }
}


/*----------------------------------------------------------------------*/
/*                        r e a d C o m m a n d                         */
/*                                                                      */
/* Issue read command.                                                  */
/*                                                                      */
/* Note - The routine also checks that the controller is in normal mode */
/* , latches the address and waits for the ready signal.                */
/*                                                                      */
/* Parametes:                                                           */
/*      flash   : Pointer identifying drive                             */
/*      cmd     : Command to issue (AREA_A, AREA_B or AREA_C).          */
/*      addr    : address to read from.                                 */
/*                                                                      */
/* Returns: flOK on success, flTimedOut or flHWProtection on failures.  */
/*----------------------------------------------------------------------*/

static FLStatus readCommand (FLFlash * flash, CardAddress addr, Reg8bitType cmd)
{
  FLStatus status;

  selectFloor(flash,addr);
  /* Check mode of ASIC and set to NORMAL.*/
  status = chkASICmode(flash);
  if(status != flOK)
    return status;
  /* Select the device and remove flash write protection */
  selectChip(flash,MPLUS_SEL_CE|MPLUS_SEL_WP);
  /* Move flash pointer to respective area of the page */
  command (flash, cmd);
  /* Latche the address */
  status = setAddress (flash, addr);
  if(status != flOK)
    return status;

  /* ALE down */
  flWrite8bitRegPlus(flash,NflashControl, 0x0);
  /* Write twice to NOP */
  flWrite8bitRegPlus(flash,NNOPreg, 0x0);
  flWrite8bitRegPlus(flash,NNOPreg, 0x0);

  return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                        r e a d S t a t u s                           */
/*                                                                      */
/* Read status of selected flash device.                                */
/*                                                                      */
/* Note - The status indicated success of write and erase operations.   */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Returns: TRUE for failed status, FALSE for success.                  */
/*----------------------------------------------------------------------*/

static FLBoolean readStatus (FLFlash * flash)
{
  word status = 0;

  /* send command to read status */
  command(flash,READ_STATUS);

  rdBuf(flash, &status,2);

  return ((status & 1) ? TRUE:FALSE);
}

/*----------------------------------------------------------------------*/
/*                        w r i t e C o m m a n d                       */
/*                                                                      */
/* Issue write command.                                                 */
/*                                                                      */
/* Note - The routine also checks that the controller is in normal mode */
/* , latches the address and waits for the ready signal.                */
/*                                                                      */
/* Parametes:                                                           */
/*      flash   : Pointer identifying drive                             */
/*      cmd     : Command to issue (AREA_A, AREA_B or AREA_C).          */
/*      addr    : address to read from.                                 */
/*                                                                      */
/* Returns: flOK on success, flTimedOut or flHWProtection on failures.  */
/*----------------------------------------------------------------------*/

static FLStatus writeCommand (FLFlash * flash, CardAddress addr, Reg8bitType cmd)
{
  FLStatus status;

  selectFloor(flash,addr);
  /* Check mode of ASIC and set to NORMAL.*/
  status = chkASICmode(flash);
  if(status != flOK)
    return status;

  /* Select the device and remove flash write protection */
  selectChip(flash,MPLUS_SEL_CE);
  /* Prepare flash for write operation */
  command (flash, RESET_FLASH);   /* Reset flash */
  if (waitForReady(flash)==FALSE)   /* always wait after flash reset */
    return flTimedOut;

  /* Move flash pointer to respective area of the page */
  flWrite8bitRegPlus(flash,NflashCommand, (Reg8bitType)cmd); /* page area */
  command (flash,SERIAL_DATA_INPUT);        /* data input stream type */
  /* Latche the address */
  return setAddress(flash, addr);    /* set page pointer       */
}

/*----------------------------------------------------------------------*/
/*                        w r i t e E x e c u t e                       */
/*                                                                      */
/* Execute write.                                                       */
/*                                                                      */
/* Parametes:                                                           */
/*      flash   : Pointer identifying drive                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*----------------------------------------------------------------------*/

static FLStatus writeExecute (FLFlash * flash)
{
  /* Pipe termination to preceeding write cycle */

  flWrite8bitRegPlus(flash,NwritePipeTerm,(byte)0);
  flWrite8bitRegPlus(flash,NwritePipeTerm,(byte)0);
  command (flash, SETUP_WRITE);             /* execute page program */
  if (waitForReady(flash)==FALSE)   /* wait for ready signal */
    return flTimedOut;

  if( readStatus(flash) )
  {
    DEBUG_PRINT(("Debug: NFDC MDOCP write failed.\r\n"));
    return( flWriteFault );
  }
  selectChip(flash,MPLUS_SEL_WP);
  return( flOK );
}

#ifndef NO_EDC_MODE
/*----------------------------------------------------------------------*/
/*                  w r i t e D a t a P l u s E D C                     */
/*                                                                      */
/* Write 512 bytes data with edc                                        */
/*                                                                      */
/* Parameters:                                                          */
/*   flash          : Pointer identifying drive                         */
/*   buffer         : Pointer to user buffer to write from              */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void writeDataPlusEDC(FLFlash * flash, const byte FAR1 *buffer)
{
   register int i;
   static byte  syndrom[SYNDROM_BYTES];

   eccONwrite(flash); /* ECC ON for write    */

   docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, SECTOR_SIZE); /* user data */

   /* clock data thru pipeline prior reading ECC syndrome*/
   for(i=0; i<3; i++)
      flWrite8bitRegPlus(flash,NNOPreg, 0);

   /* read the syndrom bits */

   if (NFDC21thisVars->if_cfg == 8)
   {
      for(i=0; i<SYNDROM_BYTES; i++)
        syndrom[i] = flRead8bitRegPlus(flash,(word)(Nsyndrom+i));
   }
   else
   {
      for(i=0; i<SYNDROM_BYTES; i+=2)
         *(word *)(syndrom + i) = flRead16bitRegPlus(flash,(word)(Nsyndrom+i));
   }

#ifdef D2TST
   tffscpy(saveSyndromForDumping,syndrom,SYNDROM_BYTES);
#endif
   eccOFF(flash);                           /* ECC OFF  */

   docPlusWrite(flash->win,NFDC21thisIO,(byte FAR1 *)syndrom,SYNDROM_BYTES);
}
#endif /* NO_EDC_MODE */
#endif /* FL_READ_ONLY */

#ifndef NO_EDC_MODE
/*----------------------------------------------------------------------*/
/*                  r e a d D a t a P l u s E D C                       */
/*                                                                      */
/* Read 512 bytes data with edc                                         */
/*                                                                      */
/* Parameters:                                                          */
/*   flash          : Pointer identifying drive                         */
/*   buffer         : Pointer to user buffer to read into               */
/*   length         : Length to read                                    */
/*   modes          : With or without second try option                 */
/*   address        : Address to read from                              */
/*   cmd            : Area command to read from                         */
/*   endhere        : Flag indicating if more bytes are needed from     */
/*                    this page. Importent for last byte read operation */
/*                                                                      */
/* Return: flOK on success, otherwise flDataError.                      */
/*----------------------------------------------------------------------*/

static FLStatus readDataPlusEDC(FLFlash * flash, const byte FAR1 *buffer,
                word length, word modes, CardAddress address,
                byte cmd,FLBoolean endHere)
{
  byte          syndrom[SYNDROM_BYTES];
  word          unreadBytes = SECTOR_SIZE - length;
  volatile word tmp;
  FLStatus      status;
#ifdef LOG_FILE
  FILE *out;
#endif /* LOG_FILE */

  /* To avoid page fault, read first and last bytes of the page */
  if (length > 0)
  {
     ((byte FAR1 *)buffer)[0]        = 0;
     ((byte FAR1 *)buffer)[length-1] = 0;
  }

  /* activate ecc mechanism */
  eccONread(flash);

  /* read the sector data */
  docPlusRead(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, length);


  /* read syndrom to let it through the ECC unit */
  if ((NFDC21thisVars->if_cfg == 16) && (flash->interleaving == 2))
  {
     /* Partial page read with EDC must let rest of page through
        the HW edc mechanism */

     for (;unreadBytes > 0;unreadBytes -=2)
     {
        tmp = flRead16bitRegPlus(flash, NFDC21thisIO);
     }

     /* read syndrom using 16 bits access */

     for (tmp=0; tmp<SYNDROM_BYTES-2; tmp+=2)               /* read the 4 syndrome */
        *(word *)(syndrom+tmp) = flRead16bitRegPlus(flash, NFDC21thisIO);   /* bytes & store them  */

     /* If this is the last data read from this page read the last 2 bytes
        from a dedicated register otherwise from NFDC IO register */
     *(word *)(syndrom + SYNDROM_BYTES - 2) = (endHere == TRUE) ?
           flRead16bitRegPlus(flash, NreadLastData_1):
           flRead16bitRegPlus(flash, NFDC21thisIO);
  }
  else
  {
     /* Partial page read with EDC must let rest of page through
        the HW edc mechanism */

     for (;unreadBytes > 0;unreadBytes--)
     {
        tmp = flRead8bitRegPlus(flash, NFDC21thisIO);
     }

     /* read syndrom using 8 bits access */

     for (tmp=0; tmp<SYNDROM_BYTES-2; tmp++)               /* read the 4 syndrome */
        syndrom[tmp] = flRead8bitRegPlus(flash, NFDC21thisIO);   /* bytes & store them  */

     /* If this is the last data read from this page read the last 2 bytes
        from a dedicated register */

     for (tmp=SYNDROM_BYTES-2;tmp<SYNDROM_BYTES;tmp++)
       syndrom[tmp] = flRead8bitRegPlus(flash, (word)(((endHere == TRUE) ?
                        NreadLastData_1 : NFDC21thisIO)));
  }

  if( eccError(flash) )
  {     /* try to fix ECC error */
#ifdef LOG_FILE
      out=FL_FOPEN("EDCerr.txt","a");
      FL_FPRINTF(out,"error on address %lx\n",address);
      FL_FCLOSE(out);
#endif /* LOG_FILE */
      if ( modes & NO_SECOND_TRY )             /* 2nd try */
      {
#ifdef LOG_FILE
         out=FL_FOPEN("EDCerr.txt","a");
         FL_FPRINTF(out,"second read failed as well on address %lx",address);
#endif /* LOG_FILE */

        if (NFDC21thisVars->if_cfg != 16)
        {
           /* read syndrom using 8 bits access */

           for(modes=0; modes<SYNDROM_BYTES; modes++)
              syndrom[modes] = flRead8bitRegPlus(flash,(word)(Nsyndrom+modes));
        }
        else
        {
           /* read syndrom using 16 bits access */

           for(modes=0; modes<SYNDROM_BYTES; modes+=2)
              *(word *)(syndrom + modes) = flRead16bitRegPlus(flash,(word)(Nsyndrom+modes));
        }

        tmp        = (word)syndrom[0]; /* Swap 1 and 3 words */
        syndrom[0] = syndrom[4];
        syndrom[4] = (byte)tmp;
        tmp        = (word)syndrom[1];
        syndrom[1] = syndrom[5];
        syndrom[5] = (byte)tmp;

        if(flCheckAndFixEDC((char FAR1 *)buffer,(char*)syndrom, 1) !=
                            NO_EDC_ERROR)
        {
#ifdef LOG_FILE
            FL_FPRINTF(out," Could not be fixed\n");
            FL_FCLOSE(out);
#endif /* LOG_FILE */
           DEBUG_PRINT(("Debug: EDC error for NFDC MDOCP.\r\n"));
           return flDataError;
        }
#ifdef LOG_FILE
        FL_FPRINTF(out," But is was fixed\n");
        FL_FCLOSE(out);
#endif /* LOG_FILE */
      }
      else                                  /* 1st try - try once more */
      {
        status = readCommand(flash, address, cmd);
        if(status != flOK)
          return status;
        rdBufS(flash, SECTOR_SIZE);
        return readDataPlusEDC(flash,buffer,length,(word)(modes | NO_SECOND_TRY),address,cmd,endHere);
      }
  }
  eccOFF(flash);
  return flOK;
}

#endif /* NO_EDC_MODE */

/*----------------------------------------------------------------------*/
/*                        s e t E x t r a P t r                         */
/*                                                                      */
/* Calculate the physical address and page offset according to the      */
/* logical address given with an EXTRA mode flag                        */
/*                                                                      */
/* Parameters:                                                          */
/*              flash   : Pointer identifying drive                     */
/*              offset  : Logical page offset given to the MTD          */
/*              length  : Size to write\read (migh have implication)    */
/*                                                                      */
/* Return:                                                              */
/*              cmd     : Returns the page area.                        */
/*              offset  : Physical offset of the page.                  */
/*----------------------------------------------------------------------*/
/*****************************************************************************/
/* 0-5   |     6-7       |   518-519     |512-517|    8-15     |   520-527   */
/*****************************************************************************/
/* 0-2   |      3        |      4        |  5-7  |    8-11     |      12-15  */
/* edc 0 | sector flag 0 | sector flag 1 | edc 1 | unit data 0 | unit data 1 */
/*****************************************************************************/
/*            AREA_B                     |               AREA_C              */
/*****************************************************************************/

static void setExtraPtr(FLFlash * flash, word * offset, dword length,
                        Reg8bitType * cmd)
{
   *cmd = AREA_C;
   if (*offset >= SECTOR_SIZE)  /* Second sector */
   {
      *offset &= SECTOR_SIZE_MASK; /* sector offset */
      if (*offset < EDC_PLUS_SECTOR_FLAGS )       /* not unit data */
      {
         if ((*offset >= EDC_SIZE) ||        /* start after edc area */
             (*offset + length > EDC_SIZE))  /* or with sector flags */
         {
            *offset = SECOND_SECTOR_FLAGS_OFFSET; /* sector flags    */
            *cmd = AREA_B;
         }
         else /* Only edc of second sector */
         {
            *offset += END_OF_SECOND_SECTOR_DATA; /* area c + 10 */
         }
      }
      else  /* unit data */
      {
         *offset += UNIT_DATA_OFFSET; /* after first sector unit data (area c) */
      }
   }
   else                         /* First sector */
   {
      if (flash->interleaving==2) /* otherwise do not change offset */
      {
         if (*offset < EDC_PLUS_SECTOR_FLAGS)      /* not unit data */
         {
            *cmd = AREA_B;    /* start from edc */
         } /* if it is unit data keep offset as is in area c */
         else
         {
            *offset += UNIT_DATA_OFFSET_MINUS_8; /* minus current offset */
         }
      }
   }
}

/*----------------------------------------------------------------------*/
/*                s e t S e c t o r D a t a P t r                       */
/*                                                                      */
/* Calculate the physical area and offset according to the logical      */
/* address given when no area mode flags was given (sector data area).  */
/*                                                                      */
/* Parameters:                                                          */
/*          flash    : Pointer identifying drive                        */
/*          offset   : Logical offset send to the MTD                   */
/*          markFlag : True if the sector flags need to be addressed    */
/*                                                                      */
/* Return:                                                              */
/*          cmd      : Returns the page area.                           */
/*          offset   : Physical offset of the page.                     */
/*----------------------------------------------------------------------*/
static void setSectorDataPtr(FLFlash * flash,word * offset,Reg8bitType * cmd,
                 FLBoolean markFlag)
{
    if (*offset >= SECTOR_SIZE) /* second sector */
    {
       if ((markFlag)&&(*offset == SECTOR_SIZE)) /* write operation */
       {
          *offset = SECOND_SECTOR_FLAGS_OFFSET; /* Write sector flags first */
          *cmd = AREA_B;
          return;
       }
       else
       {
          *offset += START_OF_SECOND_SECTOR_DATA; /* Start from actual data */
       }
    }
    if (*offset < NFDC21thisVars->pageAreaSize)
    {
       *cmd = AREA_A;
    }
    else if (*offset < flash->pageSize)
    {
       *cmd = AREA_B;
    }
    else
    {
       *cmd = AREA_C;
    }
    *offset &= (NFDC21thisVars->pageAreaSize-1);
}

/*----------------------------------------------------------------------*/
/*                    r e a d E x t r a A r e a                         */
/*                                                                      */
/* Read from the extra area.                                            */
/*                                                                      */
/* Note - Only the last 2 bytes are read from the pipeline (not 4).     */
/*                                                                      */
/* Parameters:                                                          */
/*          flash    : Pointer identifying drive                        */
/*          address  : Physical flash address                           */
/*          buffer   : Buffer to write from                             */
/*          length   : Size to write                                    */
/*                                                                      */
/* Return:                                                              */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*----------------------------------------------------------------------*/

static FLStatus readExtraArea  (FLFlash * flash, dword address,
                void FAR1 *buffer, dword length)
{
   FLStatus status;
   word     offset = (word)(address & NFDC21thisVars->pageMask);
   word     savedOffset = (word)(offset & (SECTOR_SIZE-1));
   word     readNow;
   byte     cmd;

   /* Arg check */
   if (length + savedOffset > 16)
      return flBadLength;

   /* Calculate page offset and address */
   setExtraPtr(flash, &offset, length , &cmd);
   address = (address & ~NFDC21thisVars->pageMask) + offset;

   /* Set flash to write mode and pointer to repective page ofset */
   status = readCommand(flash, address, cmd);
   if(status != flOK)
     return status;

   if (flash->interleaving == 1)
   {
       readNow = (word)TFFSMIN((word)(TOTAL_EXTRA_AREA - savedOffset), length);
       rdBuf (flash, buffer, readNow);
       length -= readNow;
   }
   else
   {
      if (cmd == AREA_C) /* unit data / second sector edc */
      {
         if (offset >= EDC_PLUS_SECTOR_FLAGS) /* either sectors unit data */
         {
            readNow = (word)TFFSMIN((word)(TOTAL_EXTRA_AREA - savedOffset), length);
         }
         else /* only edc data (already verified in setExtraAreaPtr */
         {
            readNow = (word)TFFSMIN((word)(EDC_SIZE - savedOffset), length);
         }
         rdBuf (flash, buffer, readNow);
         length -= readNow;
      }
      else  /* first sector edc / both sectors sector flags */
      {
         if (offset < EDC_PLUS_SECTOR_FLAGS) /* start from first sector */
         {
            readNow = (word)TFFSMIN((word)(EDC_PLUS_SECTOR_FLAGS - savedOffset), length);
            rdBuf (flash, buffer, readNow);
            length -= readNow;
            if (length > 0)  /* continue to sector unit data area */
            {
                return readExtraArea(flash,address - offset +
                                     EDC_PLUS_SECTOR_FLAGS,
                                     addToFarPointer(buffer,readNow),length);
            }
         }
         else /* Start form sector flags of second sector */
         {
            /* Switch sector flags to be compatible with interleave 2 */

            rdBuf (flash, BYTE_ADD_FAR(buffer,EDC_SIZE - savedOffset), SECTOR_FLAG_SIZE);
            length -= SECTOR_FLAG_SIZE;

            if (length > 0) /* continue with edc data of second sector */
            {
               readNow = (EDC_SIZE - savedOffset);
               address = address - offset + savedOffset + SECTOR_SIZE;
               if (readNow > 0)
               {
                  status = readExtraArea(flash,address,buffer,readNow);
                  if(status != flOK)
                     return status;
                  length -= readNow;
               }
               if (length > 0) /* continue with unit data of second sector */
               {
                  readNow = (word)TFFSMIN(UNIT_DATA_SIZE, length);
                  return readExtraArea(flash,address - savedOffset +
                            UNIT_DATA_SIZE,addToFarPointer(buffer,
                            EDC_PLUS_SECTOR_FLAGS - savedOffset),readNow);
               }
            }
         }
      }
   }
   selectChip(flash,MPLUS_SEL_WP);
   return flOK;
}

/*----------------------------------------------------------------------*/
/*                    r e a d S e c t o r D a t a                       */
/*                                                                      */
/* Read sector data from the page.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*          flash    : Pointer identifying drive                        */
/*          address  : Physical flash address                           */
/*          buffer   : Buffer to write from                             */
/*          length   : Size to write                                    */
/*          edc      : EDC to add edc after data and write sector flags */
/*                                                                      */
/* Note: Sector flags area written automaticly as 0x55 , 0x55.          */
/* Note: Sector flags are written only if edc is on.                    */
/*                                                                      */
/* Note - Only the last 2 bytes are read from the pipeline (not 4).     */
/*                                                                      */
/* Return:                                                              */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*----------------------------------------------------------------------*/
static FLStatus readSectorData(FLFlash * flash, CardAddress address,
                       byte FAR1 *buffer, dword length, word modes)
{
   word     offset      = (word)(address & NFDC21thisVars->pageMask);
   word     savedOffset = offset;
   word     lenInPage   = (word)TFFSMIN(length, (dword)(flash->pageSize - savedOffset));
   word     readNow     = 0; /* Initialized to remove warrnings */
   byte     cmd;
   FLStatus status;
   register int i;

  /******************************************************/
  /* Loop over pages while reading the proper area data */
  /******************************************************/

  setSectorDataPtr(flash,&offset , &cmd,0);
  address = (address & ~NFDC21thisVars->pageMask) + offset;
  while (length > 0)
  {
     /* Set flash to write mode and pointer to repective page offset */
     status = readCommand(flash, address, cmd);
     if(status != flOK)
        return status;

     /* Calculate the bytes neaded to be read from this page */
     length -= lenInPage;

     /* Send read pipeline init */
     rdBufS(flash, lenInPage);

      /* Read First sector of page */

     if ((cmd == AREA_A) || (flash->interleaving == 1))
     {
        readNow = (word)TFFSMIN((word)(SECTOR_SIZE - savedOffset), lenInPage);

        /* EDC and sector flags 0x5555 are written only if EDC is required.
         * and a full 512 bytes area written */

#ifndef NO_EDC_MODE
        if ( /* Full 512 bytes + EDC requested */
            ((readNow == SECTOR_SIZE) && (modes & EDC))  ||
             /* Partial page with EDC requested */
            ((modes   == PARTIAL_EDC) && (savedOffset == 0)))
        {
           status = readDataPlusEDC(flash,buffer,readNow,modes,address,
                       cmd,(lenInPage == readNow) ? TRUE:FALSE);
           if(status != flOK)
              return status;
        }
        else
#endif /* NO_EDC_MODE */
        {
           /* user data (the last 2 bytes are read from a diffrent register */
           word realyReadNow = (word)((lenInPage == readNow) ?
                                      (readNow - 2) : readNow);

           docPlusRead(flash->win,NFDC21thisIO,buffer,realyReadNow);
        }
        lenInPage -= readNow;
     }

      /* Read Second sector of page */

     if ((lenInPage > 0)&&(flash->interleaving==2))
     {
        if (cmd == AREA_A)  /* Started from first sector */
        {
           byte tmpBuf[10];
#ifndef NO_EDC_MODE
           if ((readNow != SECTOR_SIZE) || /* not Full 512 bytes  */
               !(modes & EDC))             /* or EDC not requesed */
#endif /* NO_EDC_MODE */
           {
              docPlusRead(flash->win,NFDC21thisIO,tmpBuf, EDC_SIZE); /* skip edc and sector flags */
           }
           docPlusRead(flash->win,NFDC21thisIO,tmpBuf, SECTOR_FLAG_SIZE<<1); /* skip 2 sector flags  */
           buffer      = BYTE_ADD_FAR(buffer,readNow);
           savedOffset = SECTOR_SIZE;
           address    += (readNow+START_OF_SECOND_SECTOR_DATA);
           cmd         = AREA_B;
        }
        readNow = lenInPage;
#ifndef NO_EDC_MODE
        if ( /* Full 512 bytes + EDC requested */
            ((readNow == SECTOR_SIZE)     && (modes & EDC)) ||
             /* Partial page with EDC requested */
            ((savedOffset == SECTOR_SIZE) && (modes & PARTIAL_EDC)) )

        {
           status = readDataPlusEDC(flash,buffer,readNow,modes,address,
                       cmd,(lenInPage == readNow) ? TRUE:FALSE);
           if(status != flOK)
              return status;
        }
        else
#endif /* NO_EDC_MODE */
        {
           /* user data (the last 2 bytes are read from a diffrent register */
           docPlusRead(flash->win,NFDC21thisIO,buffer, (word)((lenInPage == readNow) ?
                       (readNow - 2) : readNow));
        }
     }

#ifndef NO_EDC_MODE
     /* If no EDC, Read last data from dedicated register */
     if (((modes & EDC) == 0)      ||      /* EDC not requesed      */
         ((readNow != SECTOR_SIZE) &&      /* not Full 512 bytes       */
          ((modes   & PARTIAL_EDC) == 0))) /* And not PARTIAL page EDC */
#endif /* NO_EDC_MODE */
     {
        if ((NFDC21thisVars->if_cfg == 16) && (flash->interleaving == 2))
        {
           volatile Reg16bitType junkWord;

           /* Before reading the last data perform dummy read cycles */
           for (i=0; i< ((readNow >> (flash->interleaving -1)) > 1 ?0:2); i++)
              offset = flRead16bitRegPlus(flash, NreadLastData_1); /* junk */
           /* Now read the data from the last data read register make
              sure not to cast pointer to word since it might not be
              word aligned */
           junkWord = flRead16bitRegPlus(flash, NreadLastData_1);
           *BYTE_ADD_FAR(buffer,readNow-2) = ((byte FAR1*)(&junkWord))[0];
           *BYTE_ADD_FAR(buffer,readNow-1) = ((byte FAR1*)(&junkWord))[1];
        }
        else
        {
           /* Before reading the last data perform dummy read cycles */
           for (i=0; ( i < ((readNow >> (flash->interleaving -1)) > 1 ?
               0 : ((flash->interleaving == 2) ? 4:2)));i++)
              cmd = flRead8bitRegPlus(flash, NreadLastData_1); /* junk */
           /* Now read the data from the last data read register */
           for (i=2;i>0;i--)
           {
              *BYTE_ADD_FAR(buffer,readNow-i) = flRead8bitRegPlus(flash, NreadLastData_1);
           }
        }
     }

     /* Calculate next address and page offset */
     if (length > 0)
     {
        buffer = BYTE_ADD_FAR(buffer,readNow);
        address = (address & (~NFDC21thisVars->pageMask)) + flash->pageSize;
        lenInPage = (word)TFFSMIN(length,flash->pageSize);
        savedOffset = 0;
        cmd = AREA_A;
     }
     selectChip(flash,MPLUS_SEL_WP);
  }
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                       d o c 2 R e a d                                */
/*                                                                      */
/* Read some data from the flash. This routine will be registered as    */
/* the read routine for this MTD.                                       */
/*                                                                      */
/* Note - address + length must reside inside media.                    */
/* Note - global variables changed:                                     */
/*    global variable NFDC21thisVars->currentFloor is updated           */
/*    flash->socket.window.currentPage = pageToMap;                     */
/*    flash->socket.remapped = TRUE;                                    */
/*                                                                      */
/* Note - PARTIAL_EDC mode must not be called with an uneven number of  */
/*        bytes.                                                        */
/*                                                                      */
/* Parameters:                                                          */
/*    flash     : Pointer identifying drive                             */
/*    address   : Address of sector to write to.                        */
/*    buffer    : buffer to write from.                                 */
/*    length    : number of bytes to write.                             */
/*    modes     : EDC / EXTRA flags.                                    */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, otherwise failed.                     */
/*----------------------------------------------------------------------*/

static FLStatus doc2Read(FLFlash * flash, CardAddress address,
                         void FAR1 *buffer, dword length, word modes)
{
  FLStatus status;
  byte     align[2];

#ifdef ENVIRONMENT_VARS
  if((flSuspendMode & FL_SUSPEND_IO) == FL_SUSPEND_IO)
     return flIOCommandBlocked;
#endif /* ENVIRONMENT_VARS */

  if (address & 1) /* Start from uneven address */
  {
     status = doc2Read(flash,address-1,align,2,0);
     if(status != flOK)
        return status;

     *(byte FAR1*)buffer = align[1];
     buffer = BYTE_ADD_FAR(buffer,1);
     address++;
     length--;
  }

  if (length & 1) /* Read an uneven length */
  {
     length--;
     status = doc2Read(flash,address+length,align,2,modes);
     if(status != flOK)
        return status;

     *BYTE_ADD_FAR(buffer,length) = align[0];
  }

  if(modes & EXTRA) /* EXTRA AREA */
  {
     return readExtraArea(flash,address, buffer , length);
  }
  else
  {
     return readSectorData(flash,address, (byte FAR1 *)buffer, length , modes);
  }
}

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                    w r i t e E x t r a A r e a                       */
/*                                                                      */
/* Write to the extra area.                                             */
/*                                                                      */
/* Parameters:                                                          */
/*          flash    : Pointer identifying drive                        */
/*          address  : Physical flash address                           */
/*          buffer   : Buffer to write from                             */
/*          length   : Size to write                                    */
/*                                                                      */
/* Return:                                                              */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*----------------------------------------------------------------------*/

static FLStatus writeExtraArea  (FLFlash * flash, dword address,
                 const void FAR1 *buffer, dword length)
{
   word     offset      = (word)(address & NFDC21thisVars->pageMask);
   word     savedOffset = (word)(offset & (SECTOR_SIZE-1));
   word     writeNow    = 0;
   FLStatus status;
   byte     sectorFlags [2];
   byte     cmd;

   /* Calculate page offset */
   setExtraPtr(flash, &offset, length , &cmd);
   address = (address & ~NFDC21thisVars->pageMask) + offset;
   /* Set flash to write mode and pointer to repective page ofset */
   status = writeCommand(flash, address, cmd);
   if(status != flOK)
      return status;

   if (flash->interleaving == 1)
   {
       writeNow = (word)TFFSMIN((byte)(TOTAL_EXTRA_AREA - savedOffset), length);
       docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, writeNow);
       length -= writeNow;
   }
   else
   {
      if (cmd == AREA_C) /* unit data / second sector edc */
      {
         if (offset >= EDC_PLUS_SECTOR_FLAGS) /* either sectors unit data */
         {
            writeNow = (word)TFFSMIN((byte)(TOTAL_EXTRA_AREA - savedOffset), length);
         }
         else /* only edc data (already verified in setExtraAreaPtr */
         {
            writeNow = (word)TFFSMIN((byte)(EDC_PLUS_SECTOR_FLAGS - savedOffset), length);
         }
         docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, writeNow);
         length -= writeNow;
      }
      else  /* first sector edc + both sectors sector flags */
      {
         if (offset < EDC_PLUS_SECTOR_FLAGS)
         {
            /* start from first sector edc and sector flags */
            writeNow = (word)TFFSMIN((byte)(EDC_PLUS_SECTOR_FLAGS - savedOffset), length);
            docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, writeNow);
            length -= writeNow;
            if (length > 0)  /* continue to sector unit data area */
            {
               buffer = addToFarPointer(buffer,writeNow);
               /* skip second sector to reach the unit data area */
               docPlusSet(flash->win,NFDC21thisIO,SECTOR_SIZE+EDC_PLUS_SECTOR_FLAGS,0xff);
               /* unit data */
               writeNow = (word)TFFSMIN(UNIT_DATA_SIZE , length);
               docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, writeNow);
               length -= writeNow;
            }
         }
         else /* Start form sector flags of second sector */
         {
            /* Switch sector flags to be compatible with interleave 2 */
            sectorFlags[0] = *BYTE_ADD_FAR(buffer,6 - savedOffset);
            sectorFlags[1] = *BYTE_ADD_FAR(buffer,7 - savedOffset);
#ifndef NT5PORT
            docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)&sectorFlags, SECTOR_FLAG_SIZE);
#else /*NT5PORT*/
            docPlusWrite(flash->win,NFDC21thisIO, sectorFlags, SECTOR_FLAG_SIZE);
#endif /*NT5PORT*/
            length -= SECTOR_FLAG_SIZE;

            if (length > 0) /* continue with edc data of second sector */
            {
               docPlusSet (flash->win,NFDC21thisIO, (word)(SECTOR_SIZE + savedOffset), 0xff); /* skip second sector data */
                 /* + offset in edc         */
               writeNow = EDC_SIZE - savedOffset;
               docPlusWrite(flash->win, NFDC21thisIO, (byte FAR1 *)buffer, writeNow);
               length -= writeNow;
               if (length > 0) /* continue with unit data of second sector */
               {
                  buffer = addToFarPointer(buffer,writeNow+SECTOR_FLAG_SIZE);
                  docPlusSet (flash->win, NFDC21thisIO, UNIT_DATA_SIZE, 0xff); /* skip second sector unit data */
                  writeNow = (word)TFFSMIN(UNIT_DATA_SIZE, length);
                  docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, writeNow);
                  length -= writeNow;
               }
            }
         }
      }
   }
   /* Exit nicly */
   if (length > 0 )
   {
      return flBadLength;
   }
   else     /* Commit data to flash */
   {
      return writeExecute (flash);
   }
}

/*----------------------------------------------------------------------*/
/*                    w r i t e S e c t o r D a t a                     */
/*                                                                      */
/* Write sector data of the page.                                       */
/*                                                                      */
/* Parameters:                                                          */
/*          flash    : Pointer identifying drive                        */
/*          address  : Physical flash address                           */
/*          buffer   : Buffer to write from                             */
/*          length   : Size to write                                    */
/*          edc      : EDC to add edc after data and write sector flags */
/*                                                                      */
/* Return:                                                              */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*----------------------------------------------------------------------*/

static FLStatus writeSectorData(FLFlash * flash, CardAddress address,
                const byte FAR1 *buffer, dword length,
                unsigned edc)
{
   static byte anandMark[2] = { 0x55, 0x55 };
   FLStatus    status;
   word        offset       = (word)(address & NFDC21thisVars->pageMask);
   word        savedOffset  = offset;
   word        writeNow     = 0;    /* Initialized to remove warrnings */
   byte        cmd;

  /*******************************************************/
  /* Loop over pages while writting the proper area data */
  /*******************************************************/

  setSectorDataPtr(flash,&offset , &cmd, ((edc & EDC) &&
                       (length >= SECTOR_SIZE)) ? TRUE:FALSE);
  address = (address & ~NFDC21thisVars->pageMask) + offset;

  while (length > 0)
  {
     /* Set flash to write mode and pointer to repective page ofset */
     status = writeCommand(flash, address, cmd);
     if(status != flOK)
        return status;

     /* Write First sector of page */

     if ((cmd == AREA_A)||(flash->interleaving==1))
     {
        writeNow = (word)TFFSMIN((word)(SECTOR_SIZE - savedOffset), length);
        length -= writeNow;

        /* EDC and sector flags 0x5555 are written only if EDC is required.
         * and a full 512 bytes area written */
#ifndef NO_EDC_MODE
        if ((writeNow == SECTOR_SIZE) && /* Full 512 bytes      */
            (edc == EDC))               /* And EDC is requesed */
        {
           writeDataPlusEDC(flash,buffer);
           docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)anandMark, sizeof(anandMark)); /* sector used */
        }
        else
#endif /* NO_EDC_MODE */
        {
           docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, writeNow);            /* user data */
        }
     }

     /* Write Second sector of page */

     if ((length > 0)&&(flash->interleaving==2))
     {
        /* Skip to begining of sector */

        if (cmd == AREA_A)  /* Started from first sector */
        {
#ifndef NO_EDC_MODE
           if ((writeNow != SECTOR_SIZE) || /* not Full 512 bytes  */
               (edc != EDC))                /* or EDC not requesed */
#endif /* NO_EDC_MODE */
           {
              docPlusSet (flash->win, NFDC21thisIO, EDC_PLUS_SECTOR_FLAGS, 0xff); /* skip edc and sector flags */
           }
           buffer = BYTE_ADD_FAR(buffer,writeNow);
           savedOffset = SECTOR_SIZE;
        }

        /* Read sector data */

        writeNow = (word)TFFSMIN((word)(flash->pageSize - savedOffset) , length);
#ifndef NO_EDC_MODE
        if ((writeNow == SECTOR_SIZE) && /* Full 512 bytes      */
            (edc == EDC))               /* And EDC is requesed */
        {
           docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)anandMark, sizeof(anandMark)); /* sector used */
           writeDataPlusEDC(flash,buffer);
        }
        else
#endif /* NO_EDC_MODE */
        {
           if ((savedOffset == SECTOR_SIZE)&&(cmd==AREA_A))
              docPlusSet(flash->win, NFDC21thisIO,sizeof(anandMark),0xff);  /* Skip sector flags */
           docPlusWrite(flash->win,NFDC21thisIO, (byte FAR1 *)buffer, writeNow);         /* user data */
        }
        length -= writeNow;
     }
     /* Incremeant buffer and address */
     buffer      = BYTE_ADD_FAR(buffer,writeNow);
     address     = (address & (~NFDC21thisVars->pageMask)) + flash->pageSize;
     savedOffset = 0;
     cmd         = AREA_A;
     /* Commit operation */
     status = writeExecute(flash);
     if(status != flOK)
        return status;
  }
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                  d o c 2 W r i t e                                   */
/*                                                                      */
/* Write some data to the flash. This routine will be registered as the */
/* write routine for this MTD.                                          */
/*                                                                      */
/* Note - address + length must reside inside media.                    */
/* Note - global variables changed:                                     */
/*    global variable NFDC21thisVars->currentFloor is updated           */
/*    flash->socket.window.currentPage = pageToMap;                     */
/*    flash->socket.remapped = TRUE;                                    */
/*                                                                      */
/* Parameters:                                                          */
/*    flash     : Pointer identifying drive                             */
/*    address   : Address of sector to write to.                        */
/*    buffer    : buffer to write from.                                 */
/*    length    : number of bytes to write.                             */
/*    modes     : EDC flags.                                            */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, otherwise failed.                     */
/*----------------------------------------------------------------------*/

static FLStatus doc2Write(FLFlash * flash, CardAddress address,
                          const void FAR1 *buffer, dword length, word modes)
{
  FLStatus status;
  byte align[2];

#ifdef ENVIRONMENT_VARS
  if(flSuspendMode & FL_SUSPEND_WRITE)
     return flIOCommandBlocked;
#endif /* ENVIRONMENT_VARS */

#ifndef MTD_STANDALONE
  /* Check if socket is software write protected */
  if (flWriteProtected(flash->socket))
    return( flWriteProtect );
#endif /* MTD_STANDALONE */

  if (address & 1) /* Start from uneven address */
  {
     align[1] = *(byte FAR1*)buffer;
     align[0] = 0xff;
#ifdef VERIFY_WRITE
     if (modes & EXTRA) /* EXTRA AREA */
     {
        status = writeExtraArea(flash,address-1, align , 2);
     }
     else
     {
        status = writeSectorData(flash,address-1,
                                (const byte FAR1 *)align,2,modes);
     }
     if(status != flOK)
     {
        /* Restore flash write protection */
        selectChip(flash,MPLUS_SEL_WP); /* write protect all chips */
     }
     checkStatus(doc2Read(flash,address-1,align,2,modes));

     if(align[1] != *(byte FAR1*)buffer)
     {
        DEBUG_PRINT(("reading back data failure of first unaligned byte\r\n"));
        return flWriteFault;
     }
#else
     checkStatus(doc2Write(flash,address-1,align,2,modes));
#endif /* VERIFY_WRITE */
     buffer = BYTE_ADD_FAR(buffer,1);
     address++;
     length--;
  }
  if (length & 1) /* Write an uneven length */
  {
     length--;
     align[0] = *BYTE_ADD_FAR(buffer,length);
     align[1] = 0xff;
#ifdef VERIFY_WRITE
     if (modes & EXTRA) /* EXTRA AREA */
     {
        status = writeExtraArea(flash,address+length, align , 2);
     }
     else
     {
        status = writeSectorData(flash,address+length,
                                (const byte FAR1 *)align,2,modes);
     }
     if(status != flOK)
     {
        /* Restore flash write protection */
        selectChip(flash,MPLUS_SEL_WP); /* write protect all chips */
     }
     checkStatus(doc2Read(flash,address+length,align,2,modes));
     if(align[0] != *BYTE_ADD_FAR(buffer,length))
     {
        DEBUG_PRINT(("reading back data failure of last unaligned byte\r\n"));
        return flWriteFault;
     }
#else
     checkStatus(doc2Write(flash,address+length,align,2,modes));
#endif /* VERIFY_WRITE */
  }

  if (modes & EXTRA) /* EXTRA AREA */
  {
     status = writeExtraArea(flash,address, buffer , length);
  }
  else
  {
     status = writeSectorData(flash,address, (const byte FAR1 *)buffer, length , modes);
  }

  /* Restore flash write protection */
  selectChip(flash,MPLUS_SEL_WP); /* write protect all chips */

#ifdef VERIFY_WRITE

  /* Read back after write and verify */

  if(
#ifndef MTD_STANDALONE
     (flash->socket->verifyWrite==FL_ON) &&
#endif /* MTD_STANDALONE */
     (status==flOK) )
  {
     word curRead = 0;
     void FAR1* bufPtr = (void FAR1*)buffer;
     for (;length > 0;length -= curRead,
          bufPtr = BYTE_ADD_FAR(bufPtr,curRead),address+=curRead)
     {
        curRead = (word)TFFSMIN(length , READ_BACK_BUFFER_SIZE);
        status = doc2Read(flash,address,NFDC21thisVars->readBackBuffer,curRead,modes);
        if ((status != flOK) ||
            (tffscmp(bufPtr,NFDC21thisVars->readBackBuffer,curRead)))
        {
            DEBUG_PRINT(("reading back data failure\r\n"));
            return flWriteFault;
        }
     }
  }
#endif /* VERIFY_WRITE */
  return status;
}

#ifdef VERIFY_ERASE

/*----------------------------------------------------------------------*/
/*                        c h e c k E r a s e                           */
/*                                                                      */
/* Check if media is truly erased (main areas of page only).            */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      address : Address of page to check.                             */
/*                                                                      */
/* Note - global variables changed at doc2Read:                         */
/*      global variable NFDC21thisVars->currentFloor is updated         */
/*      flash->socket.window.currentPage = pageToMap;                   */
/*      flash->socket.remapped = TRUE;                                  */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 if page is erased, otherwise writeFault.    */
/*----------------------------------------------------------------------*/

static FLStatus checkErase( FLFlash * flash, CardAddress address)
{
  register int i, j;
  word inc = READ_BACK_BUFFER_SIZE;
  dword * bufPtr = (dword *)NFDC21thisVars->readBackBuffer;
  CardAddress curAddress = address;
  word block = (word)(flash->erasableBlockSize / inc);
  dword * endBufPtr = bufPtr+(inc / sizeof(dword));
  dword * curBufPtr;

  /* Check main area */
  for ( i = 0 ; i < block ; i++, curAddress += inc )
  {
    if ( doc2Read(flash,curAddress,(void FAR1 *)bufPtr,(dword)inc,0) != flOK )
      return( flWriteFault );

    for ( curBufPtr = bufPtr ;
          curBufPtr < endBufPtr ; curBufPtr++)
      if ( *bufPtr != 0xFFFFFFFFL )
        return( flWriteFault );
  }

  /* Check extra area */
  for ( i = 0 ; i < NFDC21thisVars->pagesPerBlock ; i++)
  {
    if ( doc2Read(flash,address,(void FAR1 *)bufPtr,
                  NFDC21thisVars->tailSize, EXTRA) !=  flOK )
      return( flWriteFault );

    for (j=0;j<(NFDC21thisVars->tailSize>>2);j++)
    {
       if (bufPtr[j] != 0xFFFFFFFFL)
         return( flWriteFault );
    }
  }

  return( flOK );
}

#endif /* VERIFY_ERASE */

/*----------------------------------------------------------------------*/
/*                        d o c 2 E r a s e                             */
/*                                                                      */
/* Erase number of blocks. This routine will be registered as the       */
/* erase routine for this MTD.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*      flash           : Pointer identifying drive                     */
/*      blockNo         : First block to erase.                         */
/*      blocksToErase   : Number of blocks to erase.                    */
/*                                                                      */
/* Note - The amount of blocks to erase must be inside media.           */
/* Note - global variables changed at checkErase:                       */
/*      global variable NFDC21thisVars->currentFloor is updated         */
/*      flash->socket.window.currentPage = pageToMap                    */
/*      flash->socket.remapped = TRUE                                   */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus                : 0 on success, otherwise failed.       */
/*----------------------------------------------------------------------*/

static FLStatus doc2Erase(FLFlash * flash, word blockNo, word blocksToErase)
{
  CardAddress  startAddress = (CardAddress)blockNo * flash->erasableBlockSize;
  FLStatus     status;
  dword        pageNo;
  byte         floorToUse = (byte)(startAddress / NFDC21thisVars->floorSize);
  dword        i;
  word         nextFloorBlockNo = (word) (((floorToUse + 1) *
               NFDC21thisVars->floorSize) / flash->erasableBlockSize);

#ifdef ENVIRONMENT_VARS
  if(flSuspendMode & FL_SUSPEND_WRITE)
     return flIOCommandBlocked;
#endif /* ENVIRONMENT_VARS */

#ifndef MTD_STANDALONE
  if (flWriteProtected(flash->socket))
    return( flWriteProtect );
#endif /* MTD_STANDALONE */

  /* Arg check (out of media) */
  if( blockNo + blocksToErase > NFDC21thisVars->noOfBlocks * flash->noOfChips)
    return( flWriteFault );

  /* First erase higher floors units */
  if( blockNo + blocksToErase > nextFloorBlockNo )
  {           /* erase on higher floors */
    status = doc2Erase(flash, nextFloorBlockNo,(word)(blocksToErase -
                       (nextFloorBlockNo - blockNo)));
    if(status != flOK)
       return status;

    blocksToErase = nextFloorBlockNo - blockNo;
  }

  /* Selet Floor */
  selectFloor(flash,startAddress);

  pageNo = ((dword)(blockNo % (4096 >> flash->interleaving)) * NFDC21thisVars->pagesPerBlock);

  for (i = 0; (word)i < blocksToErase ; i++, pageNo+=NFDC21thisVars->pagesPerBlock)
  {
     /* Make sure Asic is in normal mode */
     status = chkASICmode(flash);
     if(status != flOK)
        return status;

     /* Select chip and remove write protection */
     selectChip(flash,MPLUS_SEL_CE);

     command (flash,RESET_FLASH);      /* reset flashes         */
     if (waitForReady(flash)==FALSE)   /* wait for ready signal */
        return flTimedOut;

     /* enable EDGE or LEVEL MDOC+ interrupt before the erase command */
#ifdef ENABLE_EDGE_INTERRUPT
     /* enable interrupt: EDGE, clear previous interrupt, FREADY source */
     flWrite8bitRegPlus(flash,NinterruptControl ,
                   (INTR_EDGE_MASK | INTR_IRQ_P_MASK | INTR_IRQ_F_MASK | 0x1));
#else
#ifdef ENABLE_LEVEL_INTERRUPT
     /* enable interrupt: LEVEL, clear previous interrupt, FREADY source */
     flWrite8bitRegPlus(flash,NinterruptControl ,
                   (INTR_IRQ_P_MASK | INTR_IRQ_F_MASK | 0x1));
#endif /* ENABLE_LEVEL_INTERRUPT */
#endif /* ENABLE_EDGE_INTERRUPT */

     command (flash,SETUP_ERASE);      /* send erase command    */

     /* Set address */

     flWrite8bitRegPlus(flash,NflashAddress,(Reg8bitType)(pageNo));
     flWrite8bitRegPlus(flash,NflashAddress,(Reg8bitType)(pageNo >> 8));

     flWrite8bitRegPlus(flash,NwritePipeTerm,(Reg8bitType)0);
     flWrite8bitRegPlus(flash,NwritePipeTerm,(Reg8bitType)0);

     /* send the confirm erase command */
     command(flash, CONFIRM_ERASE);
#ifndef MTD_STANDALONE
#ifndef DO_NOT_YIELD_CPU
     if(waitForReadyWithYieldCPU(flash,MAX_WAIT)==FALSE)
#endif /* DO_NOT_YIELD_CPU */
#endif /* MTD_STANDALONE */
     {
        if (waitForReady(flash)==FALSE)   /* wait for ready signal */
          return flTimedOut;
     }

     if(isAccessError(flash))
     {
        /* Restore write proection to reduce power consumption */
        selectChip(flash,MPLUS_SEL_WP);
        return flHWProtection;
     }

     /* Validate erase command status */
     if ( readStatus(flash)  ) /* erase operation failed */
     {
        DEBUG_PRINT(("Debug: doc2Erase - erase failed.\r\n"));
        /* reset flash device write protect them and abort */
        command(flash, RESET_FLASH);
        if (waitForReady(flash)==FALSE)   /* wait for ready signal */
           return flTimedOut;
        selectChip(flash,MPLUS_SEL_WP);
        return flWriteFault;
     }

     /* no failure reported */
#ifdef VERIFY_ERASE
     if ( checkErase( flash, startAddress ) != flOK )
     {
        DEBUG_PRINT(("Debug: doc2Erase- erase failed in verification.\r\n"));
        return flWriteFault ;
     }
#else
     /* Restore write proection */
     selectChip(flash,MPLUS_SEL_WP);
#endif  /* VERIFY_ERASE */
  }
  return flOK;
}
#endif   /* FL_READ_ONLY */

#ifndef MTD_STANDALONE
/*----------------------------------------------------------------------*/
/*                        d o c 2 M a p                                 */
/*                                                                      */
/* Map through buffer. This routine will be registered as the map       */
/* routine for this MTD.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive                             */
/*      address : Flash address to be mapped.                           */
/*      length  : number of bytes to map.                               */
/*                                                                      */
/* Note - Size must not be greater then 512 bytes                       */
/*                                                                      */
/* Returns:                                                             */
/*      Pointer to the buffer data was mapped to.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void FAR0 *doc2Map ( FLFlash * flash, CardAddress address, int length )
{
  doc2Read(flash,address,NFDC21thisBuffer,length, 0);
  /* Force remapping of internal catched sector */
  flash->socket->remapped = TRUE;
  return( (void FAR0 *)NFDC21thisBuffer );
}
#endif /* MTD_STANDALONE */

#ifdef MTD_READ_BBT

/*----------------------------------------------------------------------*/
/*                           R e a d B B T                              */
/*                                                                      */
/*  Read the media Bad Blocks Table to a user buffer.                   */
/*                                                                      */
/*  Parameters:                                                         */
/*  flash       : Pointer identifying drive                             */
/*  unitNo      : indicated which unit number to start checking from.   */
/*  unitToRead  : indicating how many units to check                    */
/*  buffer      : buffer to read into.                                  */
/*  reconstruct : Ignored, irelevant for DiskOnChip Millennium Plus     */
/*                                                                      */
/*  Note: blocks is a minimal flash erasable area.                      */
/*  Note: unit can contain several blocks.                              */
/*  Note: There is no current implementation of a unit that contains    */
/*        more then a single block.                                     */
/*  Note: The format of the BBT is byte per unit 0 for bad any other    */
/*        value for good.                                               */
/*  Note: global variables changed at doc2Read:                         */
/*      global variable NFDC21thisVars->currentFloor is updated         */
/*      flash->socket.window.currentPage = pageToMap;                   */
/*      flash->socket.remapped = TRUE;                                  */
/*  Note: At least 4 bytes must be read                                 */
/*                                                                      */
/*  RETURNS:                                                            */
/*     flOK on success                                                  */
/*     flBadLength if one of the units is out of the units range        */
/*     flBadBBT on read fault                                           */
/*----------------------------------------------------------------------*/
/* BBT format (in interleave-1)                                         */
/* ----------                                                           */
/* Offset 512 of the floor holds the BBT of the entire floor in the     */
/* following format:                                                    */
/*                 (even district)   (odd  district)                    */
/* byte 0 bit 0,1     block 0           block 1024                      */
/*        bit 2,3     block 1           block 1025                      */
/*        bit 4,5     block 2           block 1026                      */
/*        bit 6,7     block 3           block 1027                      */
/* byte 1 bit 0,1     block 4           block 1028                      */
/*        bit 2,3     block 5           block 1029                      */
/*        bit 4,5     block 6           block 1030                      */
/*        bit 6,7     block 7           block 1031                      */
/* and so on. The data is protected by EDC.                             */
/*----------------------------------------------------------------------*/

static FLStatus readBBT(FLFlash * flash, dword unitNo, dword unitsToRead,
                        byte blockMultiplier, byte FAR1 * buffer,
                        FLBoolean reconstruct)
{
   register    Sword i;
   FLStatus    status;
   byte        tmp;
   dword       addr;
   Sdword      bufPtr = unitsToRead - 1; /* Point to last byte of user buffer */
   word        bytesPerFloor;
   byte        firstBlocks;
   byte        smallBBT[8];
   dword       start;
   dword       last;
   word        length;
   byte  FAR1* tmpBuffer;
   CardAddress floorInc;                  /* floor address incrementor */
   word        actualRead;
   dword       alignAddr;
   word        curRead;    /* Number of bytes to read from this floor BBT */
   /* Interleave-2 has 2 block entries for each combined block. This variable */
   /* is used to shift the bbt size. 0 for int-1 1 for int-2                  */
   dword       shift = (flash->interleaving - 1);

   /* Arg sanity check */
   if ((((unitNo + unitsToRead) << blockMultiplier) <<
       flash->erasableBlockSizeBits) > (flash->noOfChips * flash->chipSize))
     return flBadParameter;  /* Too many blocks  */

   if (unitsToRead == 0)     /* No blocks at all */
      return flOK;

   if(unitsToRead < 8) /* Algorithm does not fit */
   {
      status = readBBT(flash,unitNo,8,blockMultiplier,smallBBT,FALSE);
      tffscpy(buffer,smallBBT,unitsToRead);
      return status;
   }

#ifndef MTD_STANDALONE
   /* Force remapping of internal catched sector */
   flash->socket->remapped = TRUE;
#endif /* MTD_STANDALONE */

   bytesPerFloor = (word)(NFDC21thisVars->floorSize >>
                          flash->erasableBlockSizeBits) >>
                         ((flash->mediaType == MDOCP_TYPE) ? 1 : 2);

   if(blockMultiplier == 0) /* 2 blocks per byte */
   {
      /* Calculate the first and last bytes of BBT to read. There area 4
         interleave-1 blocks per byte, so interleave-2 has 4 blocks per 2
         bytes */

      start     = ((unitNo >> 2)<<shift);                     /* in bytes  */
      last      = (((unitNo+unitsToRead-1) >> 2)<<shift);     /* in bytes  */
      length    = (word)(last - start + flash->interleaving); /* in bytes  */
      tmpBuffer = buffer;                     /* bbt buffer pointer        */

      for (floorInc = (start / bytesPerFloor) * NFDC21thisVars->floorSize +
           BBT_MEDIA_OFFSET, last = (dword) length,
           start = start % bytesPerFloor; last > 0 ;
           floorInc += NFDC21thisVars->floorSize)
      {
         curRead   = (word)TFFSMIN(bytesPerFloor - start,last);
         last     -= curRead;       /* bytes left to read */
         alignAddr = (start >> SECTOR_SIZE_BITS)<<SECTOR_SIZE_BITS;

         /* Not in Millennium plus but there might be 1024 BBT bytes
            per floor */

         for ( ;curRead > 0 ; alignAddr+=SECTOR_SIZE,start = 0)
         {
            if (doc2Read(flash,alignAddr + floorInc, NFDC21thisBuffer,
                SECTOR_SIZE , EDC) != flOK)
            {
               DEBUG_PRINT(("Debug: Error reading DiskOnChip Millennium Plus BBT.\r\n"));
               return flBadBBT;
            }
            actualRead = (word)TFFSMIN((word)(SECTOR_SIZE - start),curRead);
            tffscpy(tmpBuffer,NFDC21thisBuffer + start, actualRead);
            tmpBuffer = BYTE_ADD_FAR(tmpBuffer,actualRead); /* increament buffer */
            curRead  -= actualRead;
         }
      }

      /* Convert last byte if only some of the blocks represented by it
         are needed and if it is not the only byte read */

      /* Save first the first byte - 1 for int-1 2 for int-2 */
      if(shift)
      {
         firstBlocks = buffer[0] & buffer[1];
         /* Convert last 2 bytes */
         tmp = (*BYTE_ADD_FAR(buffer,length-1)) & /* lower lane   */
               (*BYTE_ADD_FAR(buffer,length-2));  /* higher lane  */
      }
      else
      {
         firstBlocks = buffer[0];
         /* Convert last bytes */
         tmp = *BYTE_ADD_FAR(buffer,length-1);
      }

      switch ((unitNo+unitsToRead) & 3)  /* Last block number byte offset */
      {
         case 3:
            *BYTE_ADD_FAR(buffer,bufPtr) = tmp | 0xCF;
            bufPtr--;
         case 2:
            *BYTE_ADD_FAR(buffer,bufPtr) = tmp | 0xF3;
            bufPtr--;
         case 1:
            *BYTE_ADD_FAR(buffer,bufPtr) = tmp | 0xFC;
            bufPtr--;
            length -= 2; /* Point to last bbt byte */
         default:
            break;
      }

      /* Convert all aligned blocks */
      while (bufPtr > flash->interleaving)
      {
        if(shift)
        {
           tmp = (*BYTE_ADD_FAR(buffer,length-1)) & /* lower lane  */
                 (*BYTE_ADD_FAR(buffer,length-2));  /* higher lane */
        }
        else
        {
           tmp = *BYTE_ADD_FAR(buffer,length-1);
        }
        *BYTE_ADD_FAR(buffer,bufPtr  ) = tmp | 0x3f;
        *BYTE_ADD_FAR(buffer,bufPtr-1) = tmp | 0xcf;
        *BYTE_ADD_FAR(buffer,bufPtr-2) = tmp | 0xf3;
        *BYTE_ADD_FAR(buffer,bufPtr-3) = tmp | 0xfc;
        bufPtr -= 4;
        length -= flash->interleaving;
      }

      /* Convert first unaligned blocks (0,1,2) */
      bufPtr=0;
      switch(unitNo & 3)
      {
         case 1:
            *BYTE_ADD_FAR(buffer,bufPtr) = firstBlocks | 0xF3;
            bufPtr++;
         case 2:
            *BYTE_ADD_FAR(buffer,bufPtr) = firstBlocks | 0xCF;
            bufPtr++;
         case 3:
            *BYTE_ADD_FAR(buffer,bufPtr) = firstBlocks | 0x3F;
         default:
            break;
      }

      /* Mark all bad blocks with 0 */
      for (bufPtr=0;bufPtr<(Sdword)unitsToRead;bufPtr++)
      {
         if (*BYTE_ADD_FAR(buffer,bufPtr) != BBT_GOOD_UNIT)
         {
            *BYTE_ADD_FAR(buffer,bufPtr) = 0;
         }
      }

      /* Add OTP and 2 DPS for all floors */
      for (tmp=0,addr=0;tmp<flash->noOfFloors;tmp++,addr=tmp<<10)
      {
         for (i=0;i<((shift) ? 3 : 5);i++) /* reserved units */
           if ((addr+i >= unitNo)&&(addr+i <= unitNo+unitsToRead))
              *BYTE_ADD_FAR(buffer,addr+i-unitNo) = BBT_UNAVAIL_UNIT;
      }
   }
   else /* several blocks per unit */
   {
      return flBadBBT;
   }
   return flOK;
}
#endif /* MTD_READ_BBT */

/*----------------------------------------------------------------------*/
/*                   c h a n g e I n t e r l e a v e                    */
/*                                                                      */
/* Change to new interleave mode.                                       */
/*                                                                      */
/* Note : DiskOnChip Millennium Plus 16MB always reports flOK           */
/*                                                                      */
/* Parameters:                                                          */
/*      flash    : Pointer identifying drive.                           */
/*      interNum : New interleave factor.                               */
/*                                                                      */
/* Note - Devices that were HW configured to interleave 1 can not       */
/*        change to interleave - 2.                                     */
/* Note - Global variables changed:                                     */
/*    flash->interleaving                                               */
/*    NFDC21thisVars->pageAreaSize                                      */
/*    flash->pageSize                                                   */
/*    NFDC21thisVars->tailSize                                          */
/*    NFDC21thisVars->pageMask                                          */
/*    flash->erasableBlockSize                                          */
/*    NFDC21thisVars->noOfBlocks                                        */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, otherwise flInterlreavError.                   */
/*----------------------------------------------------------------------*/

FLStatus    changeInterleave(FLFlash * flash, byte interNum)
{
    Reg8bitType prevInterleaveReg;

    if(setDOCPlusBusType(flash,flBusConfig[flSocketNoOf(flash->socket)],
                         interNum,NFDC21thisVars->if_cfg) == FALSE)
        return flGeneralFailure;

    if(flash->mediaType == MDOCP_TYPE) /* DiskOnChip Millennium Plus 32MB */
    {

       /* Save current configuration */
       prevInterleaveReg = flRead8bitRegPlus(flash,NconfigInput);

       /* check if we need to change interleave */
       if ((prevInterleaveReg & CONFIG_INTLV_MASK) == ((interNum-1)<<2))
          return flOK;

       if(interNum == 1)
       {
          flWrite8bitRegPlus(flash,NconfigInput,(byte)(prevInterleaveReg & ~CONFIG_INTLV_MASK)); /* interleave 1 */
          if((flRead8bitRegPlus(flash,NconfigInput) & CONFIG_INTLV_MASK) != 0)
              return(flInterleaveError); /* could not change interleave */
       }
       else
       {
          flWrite8bitRegPlus(flash,NconfigInput,(byte)(prevInterleaveReg | CONFIG_INTLV_MASK)); /* interleave 2 */
          if((flRead8bitRegPlus(flash,NconfigInput) & CONFIG_INTLV_MASK) != CONFIG_INTLV_MASK)
             return(flInterleaveError); /* could not change interleave */
       }
    }
    else
    {
       interNum = 1;
    }

    /* change structure elements values */

    flash->interleaving          = interNum-1 ;
    NFDC21thisVars->pageAreaSize = 0x100 << flash->interleaving;
    flash->pageSize              = 0X200 << flash->interleaving;
    NFDC21thisVars->tailSize     = EXTRA_LEN << flash->interleaving; /* 8 in interleave-1, 16 in interleave-2 */
    NFDC21thisVars->pageMask     = (unsigned short)(flash->pageSize - 1);
    flash->erasableBlockSize     = NFDC21thisVars->pagesPerBlock * flash->pageSize;
    NFDC21thisVars->noOfBlocks   = (unsigned short)( flash->chipSize / flash->erasableBlockSize );
    flash->interleaving++;
    for(flash->erasableBlockSizeBits = 0 ;
        (1UL << flash->erasableBlockSizeBits) < flash->erasableBlockSize;
        flash->erasableBlockSizeBits++);

    return(flOK);
}

#if (!defined(NO_IPL_CODE) && defined (HW_PROTECTION))

/*----------------------------------------------------------------------*/
/*                            r e a d I P L                             */
/*                                                                      */
/* Find a good copy of the IPL and read it to user buffer.              */
/*                                                                      */
/* Parameters:                                                          */
/*      vol     : Pointer identifying drive.                            */
/*      buffer  : buffer to read to.                                    */
/*      length  : number of bytes to read.                              */
/*                                                                      */
/* Note - Length must be an integer number of 512 bytes.                */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

static FLStatus readIPL(FLFlash  * flash, void FAR1 * buffer, word length)
{
  byte FAR1 *      bufPtr            = (byte FAR1 *)buffer;
  const void FAR0* winPtr            = (const void FAR1*)flash->win;
  word             tmpLength         = 0;
  int              i;
  volatile byte    prevMaxId;

  /* IPL must be read using full 512 bytes sector */
  if ((length % SECTOR_SIZE != 0)&&(length > flash->noOfFloors*IPL_MAX_SIZE))
    return flBadLength;

  /* Force IPL to be loaded */
  checkStatus(forceDownLoad(flash));
  /* Force NORMAL mode */
  checkStatus(chkASICmode(flash));
  if(flash->win == NULL)
    return flGeneralFailure;

  /* Store max ID and open IPL of high floors */
  prevMaxId = setIplSize(flash, flash->noOfFloors);

  for(i = 0 ; length > 0 ; length -= tmpLength,i++)
  {
     tmpLength = TFFSMIN(length,IPL_MAX_SIZE);

     tffscpy(bufPtr , (void FAR1*)winPtr , tmpLength);
     bufPtr = BYTE_ADD_FAR(bufPtr,tmpLength);
     switch(i)
     {
        case 1:
           winPtr = BYTE_ADD_FAR(winPtr,5*IPL_MAX_SIZE);
           break;
        case 0:
        case 2:
           winPtr = BYTE_ADD_FAR(winPtr,IPL_MAX_SIZE);
        default:
           break;
     }
  }

  /* Restore MAX id */
  prevMaxId = setIplSize(flash, prevMaxId);
  return flOK;
}

#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                        w r i t e I P L                               */
/*                                                                      */
/* Write new IPL.                                                       */
/*                                                                      */
/* Note : When write operation starts from the middle of the IPL, it    */
/*        not erase the previous content. Therefore you should use the  */
/*        use offset != 0 only after an operation that did start from 0.*/
/*                                                                      */
/* Note : Offset parameter is given in sector (512 bytes).              */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive.                            */
/*      buffer  : buffer to write from.                                 */
/*      length  : number of bytes to write.                             */
/*      offset  : sector number to start from.                          */
/*      flags   : Modes to write IPL :                                  */
/*                FL_IPL_MODE_NORMAL - Normal mode.                     */
/*                FL_IPL_DOWNLOAD    - Download new IPL when done       */
/*                FL_IPL_MODE_SA     - Strong Arm IPL mode              */
/*                FL_IPL_MODE_XSCALE - X-Scale IPL mode                 */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

static FLStatus writeIPL(FLFlash * flash, const void FAR1 * buffer,
                         word length,byte offset, unsigned flags)
{
  FLBoolean   restoreInterleave = FALSE;
  FLStatus    status;
  FLStatus    secondStatus;
  int         i;
  byte FAR1 * tmpPtr            = (byte FAR0 *)buffer;
  byte        dps[NO_OF_DPS][SIZE_OF_DPS];
  CardAddress iplOffset[4];
  byte        floor;
  byte        downloadStatus;
  dword       floorInc;
  word        curWrite;
  word        redundantUnit; /* First unit to erase - might have bad data */
  word        goodUnit;      /* Second unit to erase - has valid DPS      */
  dword       goodDPS;       /* Where to read DPS - in second unit        */
  dword       redundantDPS;  /* Where to write DPS - in first unit        */
  dword       dps1Copy0;     /* Offset to DPS1 copy 0                     */
  word        dps1UnitNo;    /* Offset to redundant DPS unit              */
  dword       copyOffset;    /* Offset to redundant units                 */
  unsigned    iplModeFlags;  /* IPL Strong Arm and\or XScale mode flags.  */

  /* Check IPL requested size against the real IPL size */
  if (length + (offset<<SECTOR_SIZE_BITS) > flash->noOfFloors*IPL_MAX_SIZE)
    return flBadLength;

  /* Check mode of ASIC and set to NORMAL.*/
  status = chkASICmode(flash);
  if(status != flOK)
    return status;

  /* Check IPL mode flags */
  iplModeFlags = flags & (FL_IPL_MODE_SA|FL_IPL_MODE_XSCALE);
  if(iplModeFlags) /* Write MODE mark */
  {
     if(iplModeFlags == (FL_IPL_MODE_SA|FL_IPL_MODE_XSCALE))
     {
        DEBUG_PRINT(("ERROR - Can write IPL with both Strong Arm and X-Scale modes\r\n"));
        return flBadParameter;
     }

     if(flash->mediaType == MDOCP_TYPE) /* DiskOnChip Millennium Plus 32MB */
     {
        DEBUG_PRINT(("ERROR - DiskOnChip Millennium Plus 32MB does not support special IPL modes\r\n"));
        return flFeatureNotSupported;
     }
  }

  /* Send default key for unprotected partitions */
  if (flash->protectionKeyInsert != NULL)
  {
     status = flash->protectionKeyInsert(flash,1, (byte *)DEFAULT_KEY);
     if(status != flOK)
        return status;
  }

  /* make sure to be in interleave 1 mode */
  if (flash->interleaving==2)  /* store previous */
  {
     restoreInterleave = TRUE;
     status = changeInterleave(flash, 1); /* change to interleave 1. abort if failed */
     if(status != flOK)
       return status;
  }

#ifndef MTD_STANDALONE
  /* Force remapping of internal catched sector */
  flash->socket->remapped = TRUE;
#endif /* MTD_STANDALONE */

  if(flash->mediaType == MDOCP_TYPE) /* DiskOnChip Millennium Plus 32MB */
  {
    copyOffset   = flash->chipSize>>1; /* The chips are consequtive */
    dps1UnitNo   = DPS1_UNIT_NO_32;
    dps1Copy0    = DPS1_COPY0_32;
    iplOffset[0] = IPL0_COPY0_32;
    iplOffset[2] = IPL1_COPY0_32;
  }
  else                               /* DiskOnChip Millennium Plus 16MB */
  {
    /* DPS0 / DPS1 / DPS0 copy / DPS 1 copy */
    copyOffset   = flash->erasableBlockSize;
    dps1UnitNo   = DPS1_UNIT_NO_16;
    dps1Copy0    = DPS1_COPY0_16;
    iplOffset[0] = IPL0_COPY0_16;
    iplOffset[2] = IPL1_COPY0_16;
  }
  iplOffset[1] = iplOffset[0]+SECTOR_SIZE;
  iplOffset[3] = iplOffset[2]+SECTOR_SIZE;

  floor   = offset >> 1;  /* Skip to proper floor (2 * 512 per floor) */
  offset -= floor << 1;   /* Update offset                            */

  /* Reading IPL starting from 1k of floor 0 and up */
  for (floorInc=floor * NFDC21thisVars->floorSize;
       (floor<flash->noOfFloors)&&(length>0);
       floor++,floorInc+=NFDC21thisVars->floorSize)
  {
     setFloor(flash,floor); /* Set the floor to use */
     /* Prepare inernal write buffer */
     /* Note - buffer and NFDC21thisBuffer might be the same buffer */
     curWrite = (word)TFFSMIN(length,SECTOR_SIZE);
     tffscpy(NFDC21thisBuffer,(void *)tmpPtr,curWrite);
     tffsset(NFDC21thisBuffer+curWrite,0xff,SECTOR_SIZE-curWrite);

     /* When starting from the second sector do not erase the units */
     if (offset != 0)
     {
        status = doc2Write(flash,iplOffset[2]+floorInc,NFDC21thisBuffer,SECTOR_SIZE,EDC);
        if(status!=flOK) goto END_WRITE_IPL;
        status = doc2Write(flash,iplOffset[2]+SECTOR_SIZE+floorInc,NFDC21thisBuffer,SECTOR_SIZE,EDC);
        if(status!=flOK) goto END_WRITE_IPL;
        status = doc2Write(flash,iplOffset[2]+copyOffset+floorInc,NFDC21thisBuffer,SECTOR_SIZE,EDC);
        if(status!=flOK) goto END_WRITE_IPL;
        status = doc2Write(flash,iplOffset[2]+SECTOR_SIZE+copyOffset+floorInc,NFDC21thisBuffer,SECTOR_SIZE,EDC);
        if(status!=flOK) goto END_WRITE_IPL;
        offset = 0;
        goto WRITE_IPL_NEXT_FLOOR;
     }

     /* Decide which copy to use acording to the previous download */
     downloadStatus = flRead8bitRegPlus(flash,NdownloadStatus);

     switch (downloadStatus & DWN_STAT_DPS1_ERR)
     {
        case DWN_STAT_DPS1_ERR:  /* Both copies are invalid */
           status = flBadDownload;
           goto END_WRITE_IPL;

        case DWN_STAT_DPS10_ERR: /* First copy is bad */
           if(flash->mediaType == MDOCP_TYPE)
           {
              redundantUnit = (word)(dps1UnitNo + floor*(NFDC21thisVars->floorSize>>flash->erasableBlockSizeBits));
              goodUnit      = (word)(redundantUnit + (copyOffset>>flash->erasableBlockSizeBits));
              redundantDPS  = dps1Copy0 + floorInc;
              goodDPS       = redundantDPS + copyOffset;
           }
           else
           {
              redundantUnit = (word)(dps1UnitNo + floor*(NFDC21thisVars->floorSize>>flash->erasableBlockSizeBits));
              goodUnit      = (word)(redundantUnit + (copyOffset>>flash->erasableBlockSizeBits));
              redundantDPS  = dps1Copy0 + floorInc;
              goodDPS       = redundantDPS + copyOffset;
           }

           break;

        default:                 /* Both copies are good */
           goodUnit      = (word)(dps1UnitNo + floor*(NFDC21thisVars->floorSize>>flash->erasableBlockSizeBits));
           redundantUnit = (word)(goodUnit + (copyOffset>>flash->erasableBlockSizeBits));
           goodDPS       = dps1Copy0 + floorInc;
           redundantDPS  = goodDPS + copyOffset;
     }
     /* Read previous dps */
     status = doc2Read(flash,goodDPS,&(dps[0][0]),SIZE_OF_DPS,0);
     if(status!=flOK) goto END_WRITE_IPL;
     status = doc2Read(flash,goodDPS + REDUNDANT_DPS_OFFSET,
                       &(dps[1][0]),SIZE_OF_DPS,0);
     if(status!=flOK) goto END_WRITE_IPL;
     /* Erase the other unit - not the one we downloaded from */
     status = flash->erase(flash,redundantUnit,1);
     if(status!=flOK) goto END_WRITE_IPL;
     /* Write DPS */
     status = doc2Write(flash,redundantDPS,&(dps[0][0]),SIZE_OF_DPS,0);
     if(status!=flOK) goto END_WRITE_IPL;
     status = doc2Write(flash,redundantDPS + REDUNDANT_DPS_OFFSET,
                        &(dps[1][0]),SIZE_OF_DPS,0);
     if(status!=flOK) goto END_WRITE_IPL;
     /* Erase the unit that we downloaded from */
     status = flash->erase(flash,goodUnit,1);
     if(status!=flOK) goto END_WRITE_IPL;
     /* Write DPS */
     status = doc2Write(flash,goodDPS, &(dps[0][0]),SIZE_OF_DPS,0);
     if(status!=flOK) goto END_WRITE_IPL;
     status = doc2Write(flash,goodDPS + REDUNDANT_DPS_OFFSET,
                        &(dps[1][0]),SIZE_OF_DPS,0);


     /* Write IPL - 2 copies of first unit */
     for(i=0;i<2;i++)
     {
        status = doc2Write(flash,iplOffset[i]+floorInc,NFDC21thisBuffer,SECTOR_SIZE,EDC);
        if(status!=flOK) goto END_WRITE_IPL;
        status = doc2Write(flash,iplOffset[i]+floorInc+copyOffset,NFDC21thisBuffer,SECTOR_SIZE,EDC);
        if(status!=flOK) goto END_WRITE_IPL;
     }

     /* Write next 512 bytes of IPL if needed */
     length -= curWrite;
     if (length > 0)
     {
        /* Prepare next buffer */
        tmpPtr = BYTE_ADD_FAR(tmpPtr,SECTOR_SIZE);
        curWrite = (word)TFFSMIN(length,SECTOR_SIZE);
        tffscpy(NFDC21thisBuffer,tmpPtr,curWrite);
        tffsset(NFDC21thisBuffer+curWrite,0x0,SECTOR_SIZE-curWrite);

        for(;i<4;i++)
        {
           status = doc2Write(flash,iplOffset[i]+floorInc,NFDC21thisBuffer,SECTOR_SIZE,EDC);
           if(status!=flOK) goto END_WRITE_IPL;
           status = doc2Write(flash,iplOffset[i]+floorInc+copyOffset,NFDC21thisBuffer,SECTOR_SIZE,EDC);
           if(status!=flOK) goto END_WRITE_IPL;
        }
     }
WRITE_IPL_NEXT_FLOOR:
     length -= curWrite;
     if(length>0)
       tmpPtr = BYTE_ADD_FAR(tmpPtr,SECTOR_SIZE);
     if(iplModeFlags) /* Write MODE mark */
     {
        byte  mark = IPL_SA_MODE_MARK; /* Strong arm is the default */

        if(flags & FL_IPL_MODE_XSCALE) /* Unless X-Scale wase asked for */
           mark = IPL_XSCALE_MODE_MARK;

        status = doc2Write(flash,IPL_MODE_MARK_OFFSET+floorInc,&mark,1,EXTRA);
        if(status!=flOK) goto END_WRITE_IPL;
     }
  } /* End for loop over floors */
END_WRITE_IPL:
  if ( restoreInterleave == TRUE)
  {
     chkASICmode(flash); /* Release posible access error */
     secondStatus = changeInterleave(flash, 2); /* change to interleave 2. */
     if(secondStatus != flOK)
        return secondStatus;
  }
  if(status == flOK)
  {
     if((flags & FL_IPL_DOWNLOAD) == 0)
        return flOK;

     if(flash->download != NULL)
         return flash->download(flash);
     DFORMAT_PRINT(("ERROR - IPL was not downloaded since MTD does not support the feature\r\n"));
  }
  return status;
}
#endif /* FL_READ_ONLY */
#endif /* not NO_IPL_CODE & HW_PROTECTION */

#ifdef  HW_OTP
#ifndef FL_READ_ONLY
/*----------------------------------------------------------------------*/
/*                        w r i t e O T P                               */
/*                                                                      */
/* Write and lock the customer OTP.                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive.                            */
/*      buffer  : buffer to write from.                                 */
/*      length  : number of bytes to write.                             */
/*                                                                      */
/* Note - customer OTP memory structure: (flash pages 6-31              */
/*          byte  0      - Indicates the lock state (0 for locked).     */
/*          bytes 3-7    - OTP used size.                               */
/*          page  7-19   - 6K of the unit - customer data.              */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

static FLStatus writeOTP(FLFlash * flash , const void FAR1 * buffer, word length)
{
  word          lastSectorSize = (word)(length % SECTOR_SIZE);
  OTPLockStruct lock;
  FLStatus      status;
  int           shift = flash->interleaving-1;

  selectFloor(flash,0);
  /* Check mode of ASIC and set to NORMAL.*/
  status = chkASICmode(flash);
  if(status != flOK)
     return status;

  if (length > CUSTOMER_OTP_SIZE)
     return flBadLength;

  /* write the data with EDC */
  status = doc2Write(flash, (CUSTOMER_OTP_START<<shift)+flash->pageSize, buffer,
                     length-lastSectorSize, EDC);
  if(status != flOK)
     return status;

  /* Write last partial sector */
  if (lastSectorSize > 0)
  {
     /* Force remapping of internal catched sector */
#ifndef MTD_STANDALONE
     flash->socket->remapped = TRUE;
#endif /* MTD_STANDALONE */

     tffsset(NFDC21thisBuffer,0,sizeof(NFDC21thisBuffer));
     tffscpy(NFDC21thisBuffer,BYTE_ADD_FAR(buffer,length-lastSectorSize),lastSectorSize);
     status = doc2Write(flash, (CUSTOMER_OTP_START<<shift) + flash->pageSize +
         length-lastSectorSize, NFDC21thisBuffer, SECTOR_SIZE, EDC);
     if(status != flOK)
        return status;
  }

  /* Lock area */
  tffsset((void FAR1 *)&lock,0,sizeof(lock));
  lock.lockByte[0] = OTP_LOCK_MARK;

  toLE4(lock.usedSize,(dword)length); /* store size of data */
  status = doc2Write(flash, (CUSTOMER_OTP_START<<shift), &lock, sizeof(lock), 0);

  if(status == flOK)
     status = forceDownLoad(flash);

  return status;
}
#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                        o t p S i z e                                 */
/*                                                                      */
/* Returns the size and state of the OTP area.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      flash       : Pointer identifying drive.                        */
/*      sectionSize : Total OTP size.                                   */
/*      usedSize    : Used OTP size.                                    */
/*      locked      : Lock state (LOCKED_OTP for locked).               */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

static FLStatus otpSize(FLFlash * flash,  dword FAR2* sectionSize,
                        dword FAR2* usedSize, word FAR2* locked)
{
  OTPLockStruct lock;
  FLStatus      status = flOK;
  int           shift = flash->interleaving-1;

  selectFloor(flash,0);
  if (flRead8bitRegPlus(flash,NprotectionStatus) & PROTECT_STAT_COTPL_MASK)
  {
     status = doc2Read(flash,(CUSTOMER_OTP_START<<shift) , &lock, sizeof(lock), 0);
     *usedSize = LE4(lock.usedSize);
     *locked   = LOCKED_OTP;
  }
  else
  {
     *locked = 0;
     *usedSize = 0;
  }
  /* return the maximum capacity available */
  *sectionSize = CUSTOMER_OTP_SIZE;
  return status;
}

/*----------------------------------------------------------------------*/
/*                        r e a d O T P                                 */
/*                                                                      */
/* Read data from the customer OTP.                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive.                            */
/*      offset  : Offset from the beginning of OTP area to read from.   */
/*      buffer  : buffer to read into.                                  */
/*      length  : number of bytes to read.                              */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

static FLStatus readOTP(FLFlash * flash, word offset, void FAR1 * buffer, word length)
{
  dword       usedSize;
  dword       tmp;
  word        locked;
  FLStatus    status;
  CardAddress otpStartAddr,startReadAddr,endReadAddr,remainder;

  byte FAR1*  bufPtr = (byte FAR1*) buffer;
  int         shift = flash->interleaving-1;

  selectFloor(flash,0);
  /* Check mode of ASIC and set to NORMAL.*/
  status = chkASICmode(flash);
  /* Check otp area written size */
  if(status==flOK)
    status = otpSize(flash,&tmp,&usedSize,&locked);
  if(status != flOK)
    return status;

  if (locked != LOCKED_OTP)
    return flNoSpaceInVolume; /* Area not locked    */
  if ((dword)(offset+length) > usedSize)
    return flBadLength;       /* Exceeds used space */

#ifndef MTD_STANDALONE
  /* Force remapping of internal catched sector */
  flash->socket->remapped = TRUE;
#endif /* MTD_STANDALONE */

  /**************************/
  /* read the data with EDC */
  /**************************/

  otpStartAddr  = (CUSTOMER_OTP_START<<shift) + flash->pageSize;
  /* tmp - OTP offset rounded down to sectors */
  tmp           = (dword)((offset >> SECTOR_SIZE_BITS) << SECTOR_SIZE_BITS);
  /* startReadAddr - Physical address of first sector to read */
  startReadAddr = otpStartAddr + tmp;
  /* remainder - size of last partial sector to read */
  remainder     = (offset+length) % SECTOR_SIZE;
  /* endReadAddr - Physical address of the last OTP sector to be read */
  endReadAddr   = otpStartAddr + offset + length - remainder;

  if (tmp != offset) /* Start at unaligned address */
  {
     checkStatus(doc2Read(flash, startReadAddr, NFDC21thisBuffer, SECTOR_SIZE, EDC));
     usedSize       = TFFSMIN(SECTOR_SIZE + tmp - offset,length);
     tffscpy(bufPtr,NFDC21thisBuffer + offset - tmp,(word)usedSize);
     bufPtr         = BYTE_ADD_FAR(bufPtr,usedSize);
     startReadAddr += usedSize;
     length        -= (word)usedSize;
  }
  /* Start at aligned address */
  if(length > 0)
  {
    checkStatus(doc2Read(flash, startReadAddr, bufPtr,
                         endReadAddr-startReadAddr , EDC));
    /* Read last sector partial page */
    if(remainder)
    {
       bufPtr   = BYTE_ADD_FAR(bufPtr,endReadAddr-startReadAddr);
       checkStatus(doc2Read(flash, endReadAddr, NFDC21thisBuffer, SECTOR_SIZE, EDC));
       tffscpy(bufPtr,NFDC21thisBuffer,remainder);
    }
  }
  return flOK;
}

/*----------------------------------------------------------------------*/
/*                    g e t U n i q u e I d                             */
/*                                                                      */
/* Retreave the device 16 bytes unique ID.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive.                            */
/*      buffer  : buffer to read into.                                  */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

static FLStatus getUniqueId(FLFlash * flash,void FAR1 * buffer)
{
  /* Make sure contorller is set to NORMAL. */
  FLStatus status = chkASICmode(flash);

  if(status != flOK)
    return status;

#ifndef MTD_STANDALONE
  /* Force remapping of internal catched sector */
  flash->socket->remapped = TRUE;
#endif /* MTD_STANDALONE */

  /* read unit 0 sector 0 with ecc */
  checkStatus(doc2Read(flash, 0 , NFDC21thisBuffer, SECTOR_SIZE, EDC));

  /* copy relevant unique ID from 512 bytes buffer to user buffer */
  tffscpy(buffer ,
          NFDC21thisBuffer+(UNIQUE_ID_OFFSET << (flash->interleaving - 1)) ,
          UNIQUE_ID_SIZE);

  return flOK;

}
#endif  /* HW_OTP */


/*----------------------------------------------------------------------*/
/*                  d o c P l u s I d e n t i f y                       */
/*                                                                      */
/* Identify flash. This routine will be registered as the               */
/* identification routine for this MTD.                                 */
/*                                                                      */
/* Parameters:                                                          */
/*    flash      : Pointer identifying drive                            */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, otherwise failed.                     */
/*----------------------------------------------------------------------*/

FLStatus docPlusIdentify(FLFlash * flash)
{
  FLStatus status;
  int      maxDevs, dev;
  byte     floor;

#ifdef NT5PORT
  byte     socketNo = (byte)flSocketNoOf(flash->socket);
#else
  byte     socketNo = flSocketNoOf(flash->socket);
#endif NT5PORT


  DEBUG_PRINT(("Debug: entering NFDC MDOCP identification routine.\r\n"));

  flash->mtdVars = &docMtdVars[socketNo];

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE))
  /* Get pointer to read back buffer */
  NFDC21thisVars->readBackBuffer = flReadBackBufferOf(socketNo);
#endif /* VERIFY_WRITE || VERIFY_ERASE */

#ifndef MTD_STANDALONE
  /* get pointer to buffer (we assume SINGLE_BUFFER is not defined) */
  NFDC21thisVars->buffer = flBufferOf(socketNo);

  flSetWindowBusWidth(flash->socket, 16);/* use 16-bits */
  flSetWindowSpeed(flash->socket, 120);  /* 120 nsec. */
#else

#if (defined (HW_PROTECTION) || defined (HW_OTP) || !defined (NO_IPL_CODE) || defined (MTD_READ_BBT))
  NFDC21thisVars->buffer = &globalMTDBuffer;
#endif /* HW_PROTECTION || HW_OTP || !NO_IPL_CODE || MTD_READ_BBT */
#endif /* MTD_STANDALONE */

  /* detect card - identify bit toggles on consequitive reads */
  NFDC21thisWin = (NDOC2window)flMap(flash->socket, 0);
  flash->win    = NFDC21thisWin;
  if (NFDC21thisWin == NULL)
     return flUnknownMedia;

#ifndef FL_NO_USE_FUNC
  /* Set default access routines */
  if(setDOCPlusBusType(flash,flBusConfig[socketNo],1,
     chooseDefaultIF_CFG(flBusConfig[socketNo])) == FALSE)
     return flUnknownMedia;
#endif /* FL_NO_USE_FUNC */

  /* Change controller to normal mode */
  status = setASICmode (flash, DOC_CNTRL_MODE_NORMAL);
  if(status != flOK)
    return status;

#ifndef FL_NO_USE_FUNC
  /* Set permenant access routines accoring to if_cfg and interleave */
  if(setDOCPlusBusType(flash,flBusConfig[socketNo],
                       chkInterleave(flash),chkIF_CFG(flash)) == FALSE)
     return flUnknownMedia;
#endif /* FL_NO_USE_FUNC */

  dev = getControllerID(flash); /* Read chip ID */
  switch (dev)
  {
     case CHIP_ID_MDOCP:    /* Millennium Plus 32MB */
        flash->chipSize                  = CHIP_TOTAL_SIZE<<1;
        flash->mediaType                 = MDOCP_TYPE;
        flash->changeableProtectedAreas  = 1;
        NFDC21thisVars->floorSizeBits    = 25;
        flash->firstUsableBlock          = 3;
        break;
     case CHIP_ID_MDOCP16:  /* Millennium Plus 16MB */
        flash->chipSize                  = CHIP_TOTAL_SIZE;
        flash->mediaType                 = MDOCP_16_TYPE;
        flash->changeableProtectedAreas  = 2;
        NFDC21thisVars->floorSizeBits    = 24;
        flash->firstUsableBlock          = 5;
        break;
     default:
        DEBUG_PRINT(("Debug: failed to identify NFDC MDOCP.\r\n"));
        return( flUnknownMedia );
  }
  NFDC21thisVars->win_io = NIPLpart2; /* NFDC21thisIO */

  /* select flash device. change the address according floor!! */
  setFloor   (flash, 0);      /* Map window to selected controler.   */
  selectChip (flash, MPLUS_SEL_CE|MPLUS_SEL_WP);  /* Map window to selected flash device.*/

  if (checkToggle(flash) == FALSE)
  {
    DEBUG_PRINT(("Debug: failed to identify NFDC MDOCP.\r\n"));
    return( flUnknownMedia );
  }

  /* find the interleave value */
  flash->interleaving = chkInterleave(flash);

  /* reset all flash devices */
  maxDevs = MAX_FLASH_DEVICES_MDOCP;

  for ( floor = 0 ;floor < MAX_FLOORS ;floor++)
  {
    /* select floor */
    setFloor(flash,floor);

    /* select device */
    for ( dev = 0 ; dev < maxDevs ; dev++ )
    {
      selectChip(flash, MPLUS_SEL_CE|MPLUS_SEL_WP );
      command(flash, RESET_FLASH);
    }
  }

  /* Set MDOCP flash parameters */
  NFDC21thisVars->vendorID          = 0x98;  /* remember for next chips */
  NFDC21thisVars->chipID            = 0x75;
  flash->type                       = TC58256_FLASH;
  NFDC21thisVars->pagesPerBlock     = MDOCP_PAGES_PER_BLOCK;
  NFDC21thisVars->floorSize         = flash->chipSize;
  NFDC21thisVars->pageAreaSize      = CHIP_PAGE_SIZE * flash->interleaving;
  flash->pageSize                   = NFDC21thisVars->pageAreaSize << 1;
  flash->erasableBlockSize          = NFDC21thisVars->pagesPerBlock * flash->pageSize;
  NFDC21thisVars->tailSize          = EXTRA_LEN * flash->interleaving;/* 8 in interleave-1, 16 in interleave-2 */
  NFDC21thisVars->pageMask          = (word)(flash->pageSize - 1);
  NFDC21thisVars->noOfBlocks        = (word)(flash->chipSize / flash->erasableBlockSize);

  /* Try changing to interleave 2 */
  changeInterleave(flash, 2);

    /* identify and count flash chips, figure out flash parameters */

  flash->noOfChips = 0; /* One floor already found    */
  for( floor = 0; floor < MAX_FLOORS;  floor++ )
  {
    setFloor(flash,floor);

    /* check floor for MDOCP ID + check the toggle bit */

    dev = getControllerID(flash); /* Read chip ID */

    if(((dev != CHIP_ID_MDOCP  ) &&
        (dev != CHIP_ID_MDOCP16)   ) ||
       (checkToggle(flash) == FALSE)    )
       break;

    /* check for DPS and OTP download errors */

    if (chkASICDownload (flash,floor))
    {
      DEBUG_PRINT(("Debug: failed to download OTP/DPS.\r\n"));
      return( flBadDownload );
    }
    selectChip (flash, MPLUS_SEL_WP);  /* Map window to selected flash device.*/
  }

  /* update total floors in structure and ASIC configuration register */
  flash->noOfChips  = floor;
  flash->noOfFloors = floor;

  /* back to ground floor */
  NFDC21thisVars->currentFloor = (byte)0;
  setFloor(flash,NFDC21thisVars->currentFloor);

  if (flash->noOfChips == 0) {
    DEBUG_PRINT(("Debug: failed to identify NFDC MDOCP.\r\n"));
    return( flUnknownMedia );
  }

 /*
  *  Open IPL of high floors
  *
  *  dev = setIplSize(flash, flash->noOfFloors);
  */

  /* Get host access type (8  bit or 16 bit data access if_cfg */
  NFDC21thisVars->if_cfg = chkIF_CFG(flash);

  /* Register our flash handlers and flash parameters */
#ifndef FL_READ_ONLY
  flash->write                  = doc2Write;
  flash->erase                  = doc2Erase;
#else
  flash->erase                  = NULL;
  flash->write                  = NULL;
#endif
  flash->read                   = doc2Read;
#ifndef MTD_STANDALONE
  flash->map                    = doc2Map;
#endif /* MTD_STANDALONE */
  flash->enterDeepPowerDownMode = powerDown;
#if (defined(HW_PROTECTION) || !defined(NO_IPL_CODE) || defined (HW_OTP))
  flash->download               = forceDownLoad;
#endif /* HW_PROTECTION or !NO_IPL_CODE */

#ifdef MTD_READ_BBT
  flash->readBBT                = readBBT;
#endif /* MTD_READ_BBT */

#if (!defined(NO_IPL_CODE) && defined (HW_PROTECTION))
#ifndef FL_READ_ONLY
  flash->writeIPL               = writeIPL;
#endif /* FL_READ_ONLY */
  flash->readIPL                = readIPL;
#endif /* not NO_IPL_CODE & HW_PROTECTION */

#ifdef HW_OTP
  flash->otpSize                = otpSize;
  flash->readOTP                = readOTP;
#ifndef FL_READ_ONLY
  flash->writeOTP               = writeOTP;
#endif /* FL_READ_ONLY */
  flash->getUniqueId            = getUniqueId;
#endif /* HW_OTP */
#ifdef  HW_PROTECTION
  flash->protectionBoundries    = protectionBoundries;
  flash->protectionKeyInsert    = protectionKeyInsert;
  flash->protectionKeyRemove    = protectionKeyRemove;
  flash->protectionType         = protectionType;
#ifndef FL_READ_ONLY
  flash->protectionSet          = protectionSet;
#endif /* FL_READ_ONLY */
#endif /* HW_PROTECTION */
  flash->totalProtectedAreas       = 2;
  flash->ppp                       = 5;
  flash->flags                     = INFTL_ENABLED;
  flash->maxEraseCycles            = 1000000L;
  NFDC21thisVars->floorSizeMask    = NFDC21thisVars->floorSize-1;
/*  checkStatus(forceDownLoad(flash)); *//* For testing purposes only @@*/

  DEBUG_PRINT(("Debug: identified NFDC MDOCP.\r\n"));
  return( flOK );
}

#ifndef MTD_STANDALONE

/*----------------------------------------------------------------------*/
/*              f l R e g i s t e r D O C P L U S S O C                 */
/*                                                                      */
/* Installs routines for DiskOnChip Plus family.                        */
/*                                                                      */
/* Parameters:                                                          */
/*      lowAddress,                                                     */
/*      highAddress     : host memory range to search for DiskOnChip    */
/*                        PLUS memory window                            */
/*                                                                      */
/* Returns:                                                             */
/*    FLStatus    : 0 on success, otherwise failure                     */
/*----------------------------------------------------------------------*/
#ifndef NT5PORT

FLStatus flRegisterDOCPLUSSOC(dword lowAddress, dword highAddress)
{
  int serialNo;

  if( noOfSockets >= SOCKETS )
    return flTooManyComponents;

  /* Try to register DiskOnChip using */
  for(serialNo=0;( noOfSockets < SOCKETS );serialNo++,noOfSockets++)
  {
        FLSocket * socket = flSocketOf(noOfSockets);

        socket->volNo = noOfSockets;

        docSocketInit(socket);

        /* call DiskOnChip MTD's routine to search for memory window */

        flSetWindowSize(socket, 2);  /* 4 KBytes */

        socket->window.baseAddress = flDocWindowBaseAddress
             ((byte)(socket->volNo), lowAddress, highAddress, &lowAddress);

        if (socket->window.baseAddress == 0)   /* DiskOnChip not detected */
          break;
  }
  if( serialNo == 0 )
    return flAdapterNotFound;

  return flOK;
}
#endif /* NT5PORT*/
#else /* MTD_STANDALONE */

/*----------------------------------------------------------------------*/
/*            d o c P l u s S e a r c h F o r W i n d o w               */
/*                                                                      */
/* Search for the DiskOnChip ASIC in a given memory range and           */
/* initialize the given socket record.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*      socket      :   Record used to store the sockets parameters     */
/*      lowAddress  :   host memory range to search for DiskOnChip Plus */
/*      highAddress :   memory window                                   */
/*                                                                      */
/* Output:  initialize the following fields in the FLFlash record:      */
/*                                                                      */
/*      base  -  Pointer to DiskOnChip window                           */
/*      size  -  DiskOnChip window size usualy 8K                       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus    : 0 on success, flDriveNotAvailable on failure.     */
/*                                                                      */
/* NOTE: This routine is not used by OSAK. It is used by standalone     */
/*       applications using the MTD (BDK for example) as a replacement  */
/*       for the OSAK DOCSOC.C file.                                    */
/*       The FLSocket record used by this function is not the one used  */
/*       by OSAK defined in flsocket.h but a replacement record defined */
/*       in flflash.h.                                                  */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus docPlusSearchForWindow(FLSocket * socket,
             dword lowAddress,
             dword highAddress)
{
    dword baseAddress;   /* Physical base as a 4K page */

    socket->size = 2 * 0x1000L;         /* 4 KBytes */
    baseAddress = (dword) flDocWindowBaseAddress(0, lowAddress, highAddress,&lowAddress);
    socket->base = physicalToPointer(baseAddress << 12, socket->size,0);
    if (baseAddress)    /* DiskOnChip detected */
      return flOK;
    else                        /* DiskOnChip not detected */
      return flDriveNotAvailable;
}

#ifndef MTD_FOR_EXB
/*----------------------------------------------------------------------*/
/*                d o c P l u s F r e e W i n d o w                     */
/*                                                                      */
/* Free any resources used for the DiskOnChip window                    */
/*                                                                      */
/* Parameters:                                                          */
/*      socket      :   Record used to store the sockets parameters     */
/*                                                                      */
/* Returns: None                                                        */
/*                                                                      */
/* NOTE: This routine is used only by virtual memory systems in order   */
/*       to unmap the DiskOnChip window.                                */
/*                                                                      */
/*----------------------------------------------------------------------*/

void docPlusFreeWindow(FLSocket * socket)
{
   freePointer(socket->base,DOC_WIN);
}
#endif /* MTD_FOR_EXB */
#endif /* MTD_STANDALONE */

#ifndef MTD_FOR_EXB
/*----------------------------------------------------------------------*/
/*                      f l R e g i s t e r D O C P L U S               */
/*                                                                      */
/* Registers this MTD for use                                           */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failure               */
/*----------------------------------------------------------------------*/

FLStatus flRegisterDOCPLUS(void)
{
  if (noOfMTDs >= MTDS)
    return( flTooManyComponents );

#ifdef MTD_STANDALONE
  socketTable[noOfMTDs] = docPlusSearchForWindow;
  freeTable[noOfMTDs]   = docPlusFreeWindow;
#endif /* MTD_STANDALONE */

  mtdTable[noOfMTDs++]  = docPlusIdentify;

  return( flOK );
}
#endif /* MTD_FOR_EXB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\mtdsa.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/MTDSA.C_V  $
 * 
 *    Rev 1.14   Apr 15 2002 07:37:56   oris
 * flBusConfig array was changed from byte variables to dword.
 * 
 *    Rev 1.13   Jan 23 2002 23:33:48   oris
 * Bad include directive to flBuffer.h
 * 
 *    Rev 1.12   Jan 17 2002 23:03:24   oris
 * Changed flbase.h include with docsys.h and nanddefs.h
 * Moved boot SDK MTD related variables from docbdk.c
 * Define flSocketOf and flFlashOf routines.
 * 
 *    Rev 1.11   Jul 13 2001 01:07:40   oris
 * Added readback buffer allocation and flBuffer.h include directive.
 * 
 *    Rev 1.10   Jun 17 2001 22:29:52   oris
 * Removed typo *
 * 
 *    Rev 1.9   Jun 17 2001 16:39:12   oris
 * Improved documentation and remove warnings.
 * 
 *    Rev 1.8   May 29 2001 19:48:32   oris
 * Compilation problem when using the default delay routine.
 * 
 *    Rev 1.7   May 21 2001 16:11:02   oris
 * Added USE_STD_FUNC ifdef.
 * 
 *    Rev 1.6   May 20 2001 14:36:00   oris
 * Added delay routines for vx_works and psos OS.
 * 
 *    Rev 1.5   May 16 2001 21:20:54   oris
 * Bug fix - delay routine did not support delay milliseconds that did not fit into 
 * a 2 bytes variable.
 * 
 *    Rev 1.4   Apr 24 2001 17:10:30   oris
 * Removed warnings.
 * 
 *    Rev 1.3   Apr 10 2001 23:55:58   oris
 * Added flAddLongToFarPointer routine for the standalone version.
 * 
 *    Rev 1.2   Apr 09 2001 15:08:36   oris
 * End with an empty line.
 * 
 *    Rev 1.1   Apr 01 2001 07:53:24   oris
 * copywrite notice.
 * Removed nested comments.
 *
 *    Rev 1.0   Feb 04 2001 12:19:56   oris
 * Initial revision.
 *
 */

/*************************************************************************/
/*                        M-Systems Confidential                         */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001  */
/*                         All Rights Reserved                           */
/*************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                    */
/*                           SOFTWARE LICENSE AGREEMENT                  */
/*                                                                       */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE       */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                    */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                     */
/*      E-MAIL = info@m-sys.com                                          */
/*************************************************************************/

/************************************************************************/
/*                                                                      */
/* Standalone MTD Kit                                                   */
/*                                                                      */
/************************************************************************/

/************************************************************************/
/* File Header                                                          */
/* -----------                                                          */
/* Name : mtdsa.c                                                       */
/*                                                                      */
/* Description : This file contains auxiliary routines for the MTD      */
/*               standalone package, replacing TrueFFS routines.        */
/*                                                                      */
/* Note : This file should be added to the project only if the          */
/*        MTS_STANDALONE compilation flag is defined in the file mtdsa.h*/
/*        IT HAS NO PART IN A TrueFFS project                           */
/*                                                                      */
/************************************************************************/

#include "flbase.h"
#include "nanddefs.h"
#include "docsys.h"

#ifdef MTD_STANDALONE
#include "flbuffer.h" /* defintion for READ_BACK_BUFFER_SIZE */

#if (defined (VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT))
byte globalReadBack[SOCKETS][READ_BACK_BUFFER_SIZE];
#endif /* VERIFY_WRITE */

#if (defined (HW_PROTECTION) || defined (HW_OTP) || defined (MTD_READ_BBT_CODE) || !defined (NO_IPL_CODE) || defined(MTD_READ_BBT))
FLBuffer globalMTDBuffer;
#endif /* HW_PROTECTION || HW_OTP || NO_IPL_CODE || MTD_READ_BBT */

#ifndef FL_NO_USE_FUNC
dword      flBusConfig[SOCKETS] = {FL_NO_ADDR_SHIFT        |
                                   FL_BUS_HAS_8BIT_ACCESS  |
                                   FL_BUS_HAS_16BIT_ACCESS |
                                   FL_BUS_HAS_32BIT_ACCESS};
#endif /* FL_NO_USE_FUNC */
FLFlash    flash[SOCKETS];  /* flash record for the stand alone version  */
FLSocket   socket[SOCKETS]; /* socket record for the stand alone version */
NFDC21Vars docMtdVars[SOCKETS]; /* flash internal record */
MTDidentifyRoutine    mtdTable   [MTDS];
SOCKETidentifyRoutine socketTable[MTDS];
FREEmtd               freeTable  [MTDS];
int                   noOfMTDs   = 0;


/************************************************************************/
/*                    f l F l a s h O f                                 */
/*                                                                      */
/* Gets the flash connected to a volume no.                             */
/*                                                                      */
/* Parameters:                                                          */
/*    volNo        : Volume no. for which to get flash                  */
/*                                                                      */
/* Returns:                                                             */
/*     flash of volume no.                                              */
/************************************************************************/

FLFlash *flFlashOf(unsigned volNo)
{
  return &flash[volNo];
}

/************************************************************************/
/*                        f l S o c k e t O f                           */
/*                                                                      */
/* Gets the socket connected to a volume no.                            */
/*                                                                      */
/* Parameters:                                                          */
/*        volNo                : Volume no. for which to get socket     */
/*                                                                      */
/* Returns:                                                             */
/*         socket of volume no.                                         */
/************************************************************************/

FLSocket *flSocketOf(unsigned volNo)
{
  return &socket[volNo];
}

/************************************************************************/
/************************************************************************/
/****     P l a t f o r m   D e p e n d e n t    R o u t i n e s     ****/
/************************************************************************/
/************************************************************************/

/************************************************************************/
/* Delay                                                                */
/*-------                                                               */
/* Delay for the specified amount of milliseconds, Scaled by CPU speed. */
/* The function below can be customized to one of the follwing OS:      */
/*    VXWORKS                                                           */
/*    PSOS                                                              */
/*    DOS                                                               */
/************************************************************************/

#ifdef DOS_DELAY
#include <dos.h>
#endif /* DOS */

#ifdef PSS_DELAY
/* ticks per second */
#include <bspfuncs.h>

static unsigned long  flSysClkRate = (unsigned long) KC_TICKS2SEC;

#define MILLISEC2TICKS(msec)  ((flSysClkRate * (msec)) / 1000L)


/************************************************************************/
/* p s s D e l a y M s e c s                                            */
/*                                                                      */
/* Wait for specified number of milliseconds                            */
/*                                                                      */
/* Parameters:                                                          */
/*      milliseconds    : Number of milliseconds to wait                */
/*                                                                      */
/************************************************************************/

void  pssDelayMsecs (unsigned milliseconds)
{
  unsigned long  ticksToWait = MILLISEC2TICKS(milliseconds);

  tm_wkafter (ticksToWait ? ticksToWait : 0x1L );        /* go to sleep */
}

#endif /* PSS_DELAY */

#ifdef VXW_DELAY
#include <vxWorks.h>
#include <tickLib.h>
#include <sysLib.h>

void vxwDelayMsecs (unsigned milliseconds)
{
  unsigned long stop, ticksToWait;

  ticksToWait = (milliseconds * sysClkRateGet()) / 500;
  if( ticksToWait == 0x0l )
    ticksToWait++;

  stop = tickGet() + ticksToWait;
  while( tickGet() <= stop );
}

#endif

void flDelayMsecs(unsigned long msec)
{
  unsigned curDelay;

#ifdef DOS_DELAY 
  while (msec>0)
  {
     curDelay = (unsigned)msec;
     delay( curDelay );
     msec -= curDelay;
  }
#elif defined PSS_DELAY
  while (msec>0)
  {
     curDelay = (unsigned)msec;
     pssDelayMsecs (curDelay);
     msec -= curDelay;
  }
#elif defined VXW_DELAY
  while (msec>0)
  {
     curDelay = (unsigned)msec;
     vxwDelayMsecs(curDelay);
     msec -= curDelay;
  }
#else
  while( msec-- > 0 ) curDelay += (unsigned)msec;
#endif /* DOS_DELAY */
}

/************************************************************************/
/* Use customized tffscpy, tffsset and tffscmp routines.                */
/************************************************************************/

#ifndef USE_STD_FUNC

/************************************************************************/
/* tffscpy - copy one memory block to the other.                        */
/************************************************************************/
void tffscpy(void FAR1 *dest, void FAR1 *src, unsigned length)
{
  while( length-- )
    *(((char FAR1 *)dest)++) = *(((char FAR1 *)src)++);
}

/************************************************************************/
/* tffscmp - compare two memory blocks.                                 */
/************************************************************************/
int tffscmp(void FAR1 *src1, void FAR1 *src2, unsigned length)
{
  while( length-- )
    if (*(((char FAR1 *)src1)++) != *(((char FAR1 *)src2)++))
      return(TRUE);
  return(FALSE);
}

/************************************************************************/
/* tffsset - set a memory blocks to a certain value.                    */
/************************************************************************/
void tffsset(void FAR1 *dest, unsigned char value, unsigned length)
{
  while( length-- )
    *(((char FAR1 *)dest)++) = value;
}

#endif /* USE_STD_FUNC */

/************************************************************************/
/* f l A d d L o n g T o F a r P o i n t e r                            */
/*                                                                      */
/* Add unsigned long offset to the far pointer                          */
/*                                                                      */
/* Parameters:                                                          */
/*      ptr             : far pointer                                   */
/*      offset          : offset in bytes                               */
/*                                                                      */
/************************************************************************/

void FAR0 *flAddLongToFarPointer(void FAR0 *ptr, unsigned long offset)
{
  return physicalToPointer( pointerToPhysical(ptr) + offset, 0,0 );
}

#endif /* MTD_STANDALONE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\mdocplus.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/MDOCPLUS.H_V  $
 * 
 *    Rev 1.14   Apr 15 2002 07:37:48   oris
 * Added OUT_CNTRL_STICKY_BIT_ENABLE definition.
 * Added FOUNDRY_WRITE_ENABLE definition.
 * Changed OUT_CNTRL_BSY_EN_MASK to OUT_CNTRL_BSY_DISABLE_MASK and used the complimentary value.
 * 
 *    Rev 1.13   Jan 29 2002 20:09:50   oris
 * Added IPL_SA_MODE_MARK and IPL_XSCALE_MODE_MARK definitions.
 * Changed DPS1_COPY0_16 to unit 3 instead of unit 2.
 * Changed IPL_SA_MARK_OFFSET1 to IPL_MODE_MARK_OFFSET.
 * 
 *    Rev 1.12   Jan 17 2002 23:03:12   oris
 * Changed flash addresses to interleave-1 to fit both 32MB and 16MB Plus DiskOnChip devices
 * include docsys file instead of docsysp.
 * Add 16MB Plus DiskOnChip ID 0x41
 * 
 *    Rev 1.11   Nov 22 2001 19:48:56   oris
 * Changed FLS__SEL_WP_MASK and FLS__SEL_CE_MASK to MPLUS_SEL_CE and MPLUS_SEL_WP.
 * 
 *    Rev 1.10   Sep 15 2001 23:47:26   oris
 * Include docsysp.h instead of docsys.h
 *
 *    Rev 1.9   Jul 13 2001 01:08:20   oris
 * Added BBT_MEDIA_OFFSET definition.
 * Moved VERIFY_WRITE and VERIFY_ERASE compilation flag to flcustom.h.
 *
 *    Rev 1.8   May 16 2001 21:20:44   oris
 * Added busy delay for download operation DOWNLOAD_BUSY_DELAY.
 * Moved SYNDROM_BYTES definition to flflash.h.
 *
 *    Rev 1.7   May 09 2001 00:33:24   oris
 * Removed the IPL_CODE and READ_BBT_CODE defintion.
 *
 *    Rev 1.6   May 06 2001 22:42:12   oris
 * redundant was misspelled.
 *
 *    Rev 1.5   Apr 30 2001 18:02:40   oris
 * Added READ_BBT_CODE defintion.
 *
 *    Rev 1.4   Apr 24 2001 17:11:40   oris
 * Bug fix - otp start address definition did not take interleave into acount.
 *
 *    Rev 1.3   Apr 18 2001 21:25:58   oris
 * Added OTPLockStruct record.
 *
 *    Rev 1.2   Apr 16 2001 13:55:20   oris
 * Removed warrnings.
 *
 *    Rev 1.1   Apr 09 2001 15:08:22   oris
 * End with an empty line.
 *
 *    Rev 1.0   Apr 01 2001 07:42:32   oris
 * Initial revision.
 *
 */

/*******************************************************************
 *
 *    DESCRIPTION: basic mtd functions for the MDOC32
 *
 *    AUTHOR: arie tamam
 *
 *    HISTORY: created november 14, 2000
 *
 *******************************************************************/
/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/
#ifndef MDOCPLUS_H
#define MDOCPLUS_H

/** include files **/
#include "docsys.h"

/** public functions **/
extern FLStatus changeInterleave(FLFlash vol, byte interNum);
extern FLStatus chkASICmode (FLFlash vol);

#ifndef MTD_STANDALONE
extern FLBoolean checkWinForDOCPLUS(unsigned driveNo, NDOC2window memWinPtr);
#endif /* MTD_STANDALONE */

      /*.*/
      /*    Feature list            */
      /*.*/

/* #define MULTI_ERASE   */  /* use multiple block erase feature */
/* #define WIN_FROM_SS   */  /* call Socket Services to get window location */
/* #define LOG_FILE      */  /* log edc errors                              */

/*----------------------------------------------------------------------*/
/*                          s e t F l o o r                             */
/*                                                                      */
/* Set the specified floor as the active floor.                         */
/*                                                                      */
/* Parameters:                                                          */
/*      vol     : Pointer identifying drive                             */
/*      floor   : The new active floor                                  */
/*                                                                      */
/*----------------------------------------------------------------------*/

#define setFloor(volume,floor) flWrite8bitRegPlus(volume,NASICselect,floor); /* select ASIC */


/* The first page of the customer OTP area */
typedef struct {
byte    lockByte[4];
LEulong usedSize;
} OTPLockStruct;

#define DOWNLOAD_BUSY_DELAY 300000L
#define BUSY_DELAY          30000
#define START_ADR           0xC8000L
#define STOP_ADR            0xF0000L

#define MDOCP_PAGES_PER_BLOCK 0x20    /* 16 pages per block on a single chip */
#define CHIP_PAGE_SIZE        0x100   /* Page Size of 2 Mbyte Flash */
#define IPL_MAX_SIZE          1024l   /* IPL maximum media size     */
#define CHIP_TOTAL_SIZE       0x1000000L
#define SIZE_OF_DPS           0x12
#define NO_OF_DPS             2
#define SECTOR_SIZE_MASK      0xff
#define BBT_MEDIA_OFFSET      2048L
     /* Flash page area sizes */

#define SECTOR_FLAG_SIZE            2
#define UNIT_DATA_SIZE              8
#define EDC_SIZE                    6
#define EDC_PLUS_SECTOR_FLAGS       8
#define END_OF_SECOND_SECTOR_DATA   10
#define START_OF_SECOND_SECTOR_DATA 10
#define UNIT_DATA_OFFSET            16
#define UNIT_DATA_OFFSET_MINUS_8    8
#define SECOND_SECTOR_FLAGS_OFFSET  8
#define TOTAL_EXTRA_AREA            16

     /* OTP defintions */

#define OTP_LOCK_MARK       0
#define CUSTOMER_OTP_SIZE   6*1024
#define CUSTOMER_OTP_START  SECTOR_SIZE*6L
#define UNIQUE_ID_OFFSET    0x10
#define UNIQUE_ID_SIZE      16

     /* IPL flash media offsets */

#define IPL_START_OFFSET    (SECTOR_SIZE<<1)
#define IPL_HIGH_SECTOR     (SECTOR_SIZE<<1)

#define IPL0_COPY0_32 (flash->erasableBlockSize << 1) + IPL_START_OFFSET/* Unit 2 + 1024 */
#define IPL1_COPY0_32 IPL0_COPY0_32 + IPL_HIGH_SECTOR                   /* Unit 2 + 2048 */

#define IPL0_COPY0_16 (flash->erasableBlockSize * 3) + IPL_START_OFFSET /* Unit 3 + 1024 */
#define IPL1_COPY0_16 IPL0_COPY0_16 + IPL_HIGH_SECTOR                   /* Unit 3 + 2048 */


     /* DPS flash media offsets */

#define REDUNDANT_DPS_OFFSET (SECTOR_SIZE+0x80)
#define DPS0_COPY0    flash->erasableBlockSize       /* Unit 1 */
#define DPS1_COPY0_32 (flash->erasableBlockSize<<1L) /* Unit 2 */
#define DPS1_COPY0_16 (flash->erasableBlockSize*3L)  /* Unit 3 */


#define DPS0_UNIT_NO    1
#define DPS1_UNIT_NO_32 2
#define DPS1_UNIT_NO_16 3

     /* Strong arm mark offset */

#define IPL_MODE_MARK_OFFSET    IPL1_COPY0_16+8

#define IPL_SA_MODE_MARK        0xF8 /* Strong Arm */
#define IPL_XSCALE_MODE_MARK    0X8F /* X-Scale    */

     /* miscellaneous limits */

#define MAX_FLASH_DEVICES_MDOCP 1 /* maximum flash inside one MDOC */
#define MAX_FLOORS              4
#define CHIP_ID_MDOCP          0x40  /* MDOCP 32MB chip identification value */
#define CHIP_ID_MDOCP16        0x41  /* MDOCP 16MB chip identification value */
#define MDOC_ALIAS_RANGE       0x100
#define ALIAS_RESOLUTION       (MAX_FLASH_DEVICES_MDOCP + 10)

  /*Ŀ
     Definition for writing boot image  
    */

#define SPL_SIZE           0x2000 /* 8 KBytes */
#define MAX_CODE_MODULES   6      /* max number of code modules in boot area (incl. SPL) */

   /*-----------------------------------------
    | Definition of MDOC32 memory window  |
    ----------------------------------------*/

/*        MDOC32 memory window layout :

         0000 .... 07FF    RAM ( 1KB aliased across 2KB)
         0800 .... 0FFF    Flash Data Register (2KB alias of address 1028H-1029H)
               1000    Chip Identification register
               1002     NOP register
               1004     Alias Resolution register
               1006     DOC Control register
               1008     Device ID select register
               100a     Configuration Input register
               100c     Output Control register
               100e     Interrupt Control register
               1012     Output Enable Delay  register
            101E - 101F Flash Slow Read register[1:0]
               1020     Flash Control Register
               1022     Flash Select register
               1024     Flash Command register
               1026     Flash Address register
            1028-1029   Flash Data Register
               102A     Read Pipeline Initialization register
            102C-102D   Last Data Read register
               102E     Write Pipeline Termination register
            1040-1045   ECC Syndrome register[5:0]
               1046     ECC Control register
               1048     Customer OTP Pointer register
               105A     Flash Geometry register
            105C-105D   Data Protect Structure Status register[1:0]
            105E-105f   Data Protect Structure Pointer register[1:0]
            1060-1063   Data Protect Lower Address register 0 [3:0]
            1064-1067   Data Protect Upper Address register 0 [3:0]
            1068-106B   Data Protect Lower Address register 1 [3:0]
            106C-106F   Data Protect Upper Address register 1 [3:0]
               1070     Data Protect Key register[0]
               1072     Data Protect Key register[1]
               1074     Download status register
               1076     DOC Control Confirmation register
               1078     Protection Status register
               107E     Foundry Test register
            1800-1FFE   RAM (1KB aliased across 2KB)
               1FFF     Release from power down mode

*/

#define Nio              0x800      /* Flash Data Register (2KB alias of address 1028H-1029H) read/write  */
#define NIPLpart2        0x800      /* Flash Data Register (2KB alias of address 1028H-1029H) read/write */

#define NchipId          0x1000     /* Chip Identification register. read       */
#define ID_FAMILY_MASK      0xf0    /* family .  */
#define ID_VERSION_MASK     0x7     /* version.  */

#define NNOPreg          0x1002     /* NOP register. read/write    */

#define NaliasResolution 0x1004     /* Alias Resolution register. read write  */

/* Asic controll register  */

#define NDOCcontrol         0x1006  /* DOC Control register.  read/write */
#define NDOCcontrolConfirm  0x1076  /*DOC Control Confirmation register.read only*/
#define DOC_CNTRL_RAM_WE_MASK   0x20    /* ram write enable. 1=allow write to RAM. */
#define DOC_CNTRL_RST_LAT_MASK  0x10    /* reset mode latched. */
#define DOC_CNTRL_BDETCT_MASK   0x8     /* boot detect. */
#define DOC_CNTRL_MDWREN_MASK   0x4     /* mode write enable. */
#define DOC_CNTRL_MODE_MASK     0x3     /* mode of operation. 00=reset, 01=normal, 1x=power down */
#define DOC_CNTRL_MODE_RESET    0x0     /* Reset mode + MDWREN      */
#define DOC_CNTRL_MODE_NORMAL   0x1     /* Normal mode + MDWREN     */
#define DOC_CNTRL_MODE_PWR_DWN  0x2     /* Power down mode + MDWREN */
/* The modes are ORed with the following state:
   a) Do not enable ram write.       ~0x20
   b) Reset the reset mode latche.   0x10
   c) Reset the boot detect latche   0x08
   d) Enable writing new mode        0x04
   e) Clear mode bits                2 LSB             */
#define DOC_CNTRL_DEFAULT       0x1c

#define NASICselect      0x1008     /* Device ID select register. read/ write */
#define ASIC_SELECT_ID_MASK 0x3     /* identification */

#define NconfigInput     0x100A     /* Configuration Input register. read/write  */
#define CONFIG_IF_CFG_MASK  0x80    /* state of IF_CFG input pin. */
#define CONFIG_MAX_ID_MASK  0x30    /* maximum device ID */
#define CONFIG_BD_IHN_MASK  0x8     /* boot detector inhibit */
#define CONFIG_INTLV_MASK   0x4     /* interleave. 0=interleave-1, 1=interleave-2  */

#define NoutputControl   0x100C     /* Output Control register. read/write */
#define OUT_CNTRL_BSY_DISABLE_MASK  0xfe /* busy enable . 1=enable assertion of the BUSY# output */
#define OUT_CNTRL_STICKY_BIT_ENABLE 0x8  /* sticky bit  . 8=prevent key insertion */

#define NinterruptControl   0x100E  /* Interrupt Control register. read/write */
#define INTR_IRQ_P_MASK     0x40    /* interrupt request on protection violation */
#define INTR_IRQ_F_MASK     0x20    /* interrupt request on FREADY */
#define INTR_EDGE_MASK      0x10    /* edge/level interrupt. 1=edge */
#define INTR_PROT_T_MASK    0x8 /* protection trigger */
#define INTR_FRDY_T_MASK    0x7 /* flash ready trigger */

#define NoutputEnableDelay  0x1012  /* Output Enable Delay  register. read/write */

#define NslowIO             0x101E     /* Flash Slow Read register[1:0]. read only */

#define NflashControl       0x1020     /* Flash Control Register. read write */
#define FLS_FR_B_MASK       0xc0    /* flash ready/busy for 2 byte lanes*/
#define FLS_FR_B_EVEN_MASK  0x40    /* flash ready/busy for even lane*/
#define FLS_FR_B_ODD_MASK   0x80    /* flash ready/busy for odd lane*/
#define FLS_ALE_MASK        0x4     /* address latch enable */
#define FLS_CLE_MASK        0x2     /* command latch enable */

#define NflashSelect        0x1022  /* Flash Select register. read write */
#define MPLUS_SEL_CE        0x80    /* chip enable */
#define MPLUS_SEL_WP        0x60    /* write protect*/
#define FLS_SEL_BANK_MASK   0x2 /* select flash bank to access */
#define FLS_SEL_BYTE_L_MASK 0x1 /* select flash device of the bankbyte lane*/
/* The default for MDOCP is the following combination:
   a) Send chip enable.          - 0x80
   b) Lower write protect.       - 0x40
   c) Select chip bank 0 chip 0  - 0 for bits 0-5 */
#define FLS_SEL_DEFAULT  0x80

#define NflashCommand    0x1024     /*Flash Command register. write only */

#define NflashAddress    0x1026     /* Flash Address register. write only */

#define NflashData       0x1028     /* Flash Data Register[1:0]. read/write */

#define NreadPipeInit    0x102A     /* Read Pipeline Initialization register. read only */

#define NreadLastData_1  0x102C     /* Last Data Read register. read only */

#define NreadLastData_2  0x102D     /* Last Data Read register. read only */

#define NwritePipeTerm   0x102E     /*Write Pipeline Termination register. write  only */

#define Nsyndrom         0x1040     /*ECC Syndrome register[5:0]. read only       */

#define NECCcontrol       0x1046     /*ECC Control register. read/write  */
#define ECC_CNTRL_ERROR_MASK    0x80    /*EDC error detection */
#define ECC_CNTRL_ECC_RW_MASK   0x20    /* ECC read/write. 1=ECC in write mode*/
#define ECC_CNTRL_ECC_EN_MASK   0x8 /* ECC enable */
#define ECC_CNTRL_TOGGLE_MASK   0x4 /* identify presence of MDOC*/
#define ECC_CNTRL_IGNORE_MASK   0x1 /* ignore the ECC unit*/
#define ECC_RESET   0   /* reset the ECC */

#define NcustomerOTPptr  0x1048     /* Customer OTP Pointer register. read only*/

#define NflashGeometry   0x105A     /* Flash Geometry register. read only */

#define NdownloadStatus         0x1074  /*Download status register. read only*/
#define DWN_STAT_IPL_ERR        0x30
#define DWN_STAT_IPL_INVALID    0x20
#define DWN_STAT_IPL_1_ERR      0x10
#define DWN_STAT_OTP_ERR        0x40    /* */
#define DWN_STAT_DPS1_ERR       0xc
#define DWN_STAT_DPS0_ERR       0x3
#define DWN_STAT_DPS10_ERR      0x4
#define DWN_STAT_DPS11_ERR      0x8
#define DWN_STAT_DPS00_ERR      0x1
#define DWN_STAT_DPS01_ERR      0x2
#define DWN_STAT_DWLD_ERR       0x4a    /* otp + all 4 copies of dps */

#define NprotectionStatus       0x1078  /*Protection Status register. read only*/
#define PROTECT_STAT_ACCERR     0x80
#define PROTECT_STAT_LOCK_INPUT_MASK 0x10
#define PROTECT_STAT_4BA_MASK   0x8
#define PROTECT_STAT_COTPL_MASK 0x4
#define PROTECT_STAT_BUC_MASK   0x2
#define PROTECT_STAT_FOTPL_MASK 0x1

#define NfoudaryTest            0x107E  /* Foundry Test register. write only */
#define FOUNDRY_WRITE_ENABLE    0xc3
#define FOUNDRY_DNLD_MASK       0x80
#define NreleasePowerDown       0x1FFF  /* Release from power down. */

#endif /* MDOCPLUS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\inftl.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/inftl.h_V  $
 * 
 *    Rev 1.17   Apr 15 2002 07:37:28   oris
 * Added pointer to verify write in Bnand record.
 * Added support for VERIFY_ERASED_SECTOR compilation flag.
 * 
 *    Rev 1.16   Feb 19 2002 21:00:30   oris
 * Added FL_NORMAL_FOLDING / FL_FORCE_FOLDING / FL_NOT_IN_PLACE / CLEAR_DISCARD and UNIT_TAILER_OFFSET_2
 * 
 *    Rev 1.15   Jan 28 2002 21:25:56   oris
 * Removed the use of back-slashes in macro definitions.
 * Changed constants to Unsigned Long.
 * 
 *    Rev 1.14   Jan 23 2002 23:33:26   oris
 * Added definition of QUICK_MOUNT_VALID_SING_OFFSET.
 * 
 *    Rev 1.13   Jan 20 2002 10:50:44   oris
 * Added new defintions :
 *  - MAX_CREATE_UNIT_COUNT 
 *  - SECTORS_VERIFIED_PER_FOLDING 
 *  - ANAND_BAD_CHAIN_ADDRESS
 *  - ANAND_BAD_CHAIN_UNIT
 * Changed FL_BAD_ERASE_MARK to 0
 * Reorganized Bnand structure. 
 *  - Changed fields order 
 *  - Changed memory tables pointers to FAR1 pointers - for BIOS driver FAR heap.
 *  - Added fields to Bnand structure : verifiedSectorNo / curSectorWrite / firstMediaWrite
 *  - Removed badFormat field
 * Added verifiedSectorNo to quick mount record.
 * 
 *    Rev 1.12   Nov 16 2001 00:22:54   oris
 * Remove warnings.
 * removed QUICK_MOUNT_FEATURE ifdef.
 * 
 *    Rev 1.11   Nov 08 2001 10:49:58   oris
 * Reorganized Bnand structure and added debug state field.
 * Added INFTL_FAILED_MOUNT, ALL_PARITY_BITS_OK , DISCARD_UNIT_OFFSET definitions.
 * 
 *    Rev 1.10   Sep 24 2001 18:23:56   oris
 * Changed UNIT_UNAVAIL from 0x6a to 0x60 in order not to loose sector count.
 * 
 *    Rev 1.9   Sep 16 2001 21:48:02   oris
 * changed the MAX_UNIT_NUM to 32K
 * 
 *    Rev 1.8   Sep 15 2001 23:47:04   oris
 * Added MAX_FOLDING_LOOP definition.
 * Changed MAX_UNIT_NUM to cause 576MB to group 2 physical units to a single virtual unit.
 * 
 *    Rev 1.7   Jul 13 2001 01:06:24   oris
 * Changed second header offset to page 4 to prevent 6 PPP.
 * 
 *    Rev 1.6   Jun 17 2001 08:18:16   oris
 * Changed recusive include define to INFTL_H.
 * Added FL_BAD_ERASE_MARK    definition for units without the erase mark on mount operation.
 * 
 *    Rev 1.5   May 16 2001 21:20:20   oris
 * Added the FL_ prefix to the following defines: MALLOC and FREE.
 * Changed wear level counter from 0xFF to 0xFFF0
 * Change "data" named variables to flData to avoid name clashes.
 * 
 *    Rev 1.4   Apr 16 2001 13:51:10   oris
 * Changed stack allocation of multi-sector buffers to dynamic allocation.
 * 
 *    Rev 1.3   Apr 09 2001 15:14:18   oris
 * End with an empty line.
 * 
 *    Rev 1.2   Apr 01 2001 07:56:52   oris
 * copywrite notice.
 * Removed nested comments.
 * Moved macroes to the c file.
 * Changed variable types to standard flite types.
 * Compilation problem for big endien fixed.
 * Aliggned unit header structure (SecondANANDUnitHeader) to 8 bytes.
 * Changed BAD_UNIT define.
 * Added FL_VALID, FL_FIRST_VALID, FL_PRELIMINARY, FL_FIRST_PRELIMINARY defines.
 *
 *    Rev 1.1   Feb 14 2001 02:06:24   oris
 * Changed MAX_CHAIN_LENGTH to an environment variable.
 *
 *    Rev 1.0   Feb 13 2001 02:16:00   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/*************************************************/
/* T r u e F F S   5.0   S o u r c e   F i l e s */
/* --------------------------------------------- */
/*************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Name : inftl.h                                                             *
*                                                                            *
* Description : Data strucute and genreal defintions for INFTL flash         *
*               translation layer.                                           *
*                                                                            *
*****************************************************************************/


#ifndef INFTL_H
#define INFTL_H

#include "flbuffer.h"
#include "flflash.h"
#include "fltl.h"

typedef Sdword ANANDVirtualAddress;
typedef byte ANANDPhysUnit;
typedef word ANANDUnitNo;

/* Partition flags */

#define INFTL_BINARY                0x20000000L
#define INFTL_BDTL                  0x40000000L
#define INFTL_LAST                  0x80000000L
/* PROTECTABLE            defined in flbase.h as 1  */
/* READ_PROTECTED         defined in flbase.h as 2  */
/* WRITE_PROTECTED        defined in flbase.h as 4  */
/* LOCK_ENABLED           defined in flbase.h as 8  */
/* LOCK_ASSERTED          defined in flbase.h as 16 */
/* KEY_INSERTED           defined in flbase.h as 32 */
/* CHANGEABLE_PROTECTION  defined in flbase.h as 64 */


/* Media flags */

#define QUICK_MOUNT               1

/* TL limits */

#define MAX_NO_OF_FLOORS          4
#define MAX_VOLUMES_PER_DOC       4
#define MAX_FOLDING_LOOP          10
#define MAX_CREATE_UNIT_COUNT     1024
#define MAX_QUICK_MOUNT_UNITS     10

#ifdef ENVIRONMENT_VARS
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
#define SECTORS_VERIFIED_PER_FOLDING flSectorsVerifiedPerFolding
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
#define MAX_UNIT_CHAIN               flMaxUnitChain
#else
#define SECTORS_VERIFIED_PER_FOLDING 64UL
#define MAX_UNIT_CHAIN               20
#endif /* ENVIRONMENT_VARS */
#define DOUBLE_MAX_UNIT_CHAIN        64 /* Double max unit chain */

/* Folding flags */

#define FL_NORMAL_FOLDING         0
#define FL_FORCE_FOLDING          1
#define FL_NOT_IN_PLACE           2

/* General defines */

#define NO_OF_MEDIA_HEADERS       2
#define HEADERS_SPACING           (8UL<<SECTOR_SIZE_BITS)
#define RAM_FACTOR                3L /* byte per erasable block for ram tables */
#define HEADER_SEARCH_BOUNDRY     16 /* must be a multiplication of 8 */
#define QUICK_MOUNT_VALID_SIGN    0xaaaa5555L

#define ANAND_UNASSIGNED_ADDRESS 0xffffffffL
#define ANAND_BAD_CHAIN_ADDRESS  0xfffffffeL
#define ANAND_SPARE_SIZE         16

#define UNIT_DATA_OFFSET              8UL
#define SECTOR_DATA_OFFSET            6UL
#define SECOND_HEADER_OFFSET          (4UL*SECTOR_SIZE)
#define UNIT_TAILER_OFFSET            (2UL*SECTOR_SIZE + 8UL)
#define UNIT_TAILER_OFFSET_2          (6UL*SECTOR_SIZE + 8UL)
#define DISCARD_UNIT_OFFSET           (UNIT_DATA_OFFSET + 7UL)
#define QUICK_MOUNT_VALID_SIGN_OFFSET 44UL

#define FL_VALID                 0x1
#define FL_FIRST_VALID           0x81
#define FL_PRELIMINARY           0x2
#define FL_FIRST_PRELIMINARY     0x82

#define ERASE_MARK               0x3c69
#define FL_BAD_ERASE_MARK        0x0

#define ANAND_UNIT_FREE    0xff
#define UNIT_COUNT         0x7f
#define FIRST_IN_CHAIN     0x80

#define UNIT_UNAVAIL       0x60    /* Illegal count denoting unit not available */
#define UNIT_BAD           0x6B
#define UNIT_MAX_COUNT     0x40    /* Largest valid count       */
#define DISCARD            0xAA    /* Valid used unit signature */
#define CLEAR_DISCARD      0x0     /* Mark unit as discarded    */
#define ANAND_BAD_PERCENTAGE 2     /* Maximum bad units         */

/*  Parity bits for unit header fields */
#define VU_PARITY_BIT        8     /* virtual Unit number  */
#define PU_PARITY_BIT        4     /* previous Unit number */
#define ANAC_PARITY_BIT      2     /* ANAC field           */
#define NAC_PARITY_BIT       1     /* NAC field            */
#define ALL_PARITY_BITS_OK   0xf   /* All parity bits      */

#define IS_BAD(u)       ( u == UNIT_BAD_MOUNT )

/*#define UNIT_BAD_MARKED   7*/

#define MAX_UNIT_SIZE_BITS   15
#define MORE_UNIT_BITS_MASK  3
#define ANAND_NO_UNIT        0xffff
#define ANAND_BAD_CHAIN_UNIT 0xfffe
#define MAX_UNIT_NUM         32768L


/* Block flags */

#define SECTOR_FREE         0xff
#define SECTOR_USED         0x55
#define SECTOR_IGNORE       0x11
#define SECTOR_DELETED      0x00


/* Debug modes flags */
#define INFTL_FAILED_MOUNT    1


#ifdef NFTL_CACHE
/* values for 2-bit entries in Sector Flags cache */
#define S_CACHE_SECTOR_DELETED 0x00
#define S_CACHE_SECTOR_IGNORE  0x01
#define S_CACHE_SECTOR_USED    0x02
#define S_CACHE_SECTOR_FREE    0x03
#define S_CACHE_4_SECTORS_FREE 0xff
#endif /* NFTL_CACHE */

#ifdef NFTL_CACHE
/* Unit Header cache entry, close relative of struct UnitHeader */
typedef struct {
  word virtualUnitNo;
  word prevUnitNo;
  byte  ANAC;
  byte  NAC;
} ucacheEntry; /* See doc2exb.c uses this value */

#endif /* NFTL_CACHE */

/* erase record */
typedef struct {
  LEulong  eraseCount;
  LEushort eraseMark;
  LEushort eraseMark1;
} UnitTailer;

/* unit header  */
typedef struct {
  LEushort virtualUnitNo;
  LEushort prevUnitNo;
  byte ANAC;
  byte NAC;
  byte parityPerField;
  byte discarded;
} ANANDUnitHeader;

/*  Second copy of unitHeader */
typedef struct {
  byte parityPerField;
  byte ANAC;
  LEushort prevUnitNo;
  LEushort virtualUnitNo;
  byte NAC;
  byte junk; /* alignment filed for int - 2 */
} SecondANANDUnitHeader;

/* Medium Boot Record */

typedef struct {
  LEmin    bootRecordId[2];      /* "BNAND" */
  LEmin    noOfBootImageBlocks;  /* number of good blocks in the boot image area */
  LEmin    noOfBinaryPartitions; /* number of binary partitions */
  LEmin    noOfBDTLPartitions;   /* number of BDTL partitions   */
  LEmin    blockMultiplierBits;   /* number of bits used to represent the
                      times a flash erasable block fits inside
                      an INFTL erasable unit. */
  LEmin    formatFlags;     /* QUICK_MOUNT */
  LEmin    osakVersion;     /* version of osak used to format the media */
  LEmin    percentUsed;
} BNANDBootRecord;

/* Volume record */

typedef struct {
  LEmin    virtualUnits; /* Virtual size exported by the trasnaltion layer */
  LEmin    firstUnit;    /* First unit of the partition                    */
  LEmin    lastUnit;     /* Last unit of the partition                     */
  LEmin    flags;        /* PROTECTABLE,CHANGEABLE_PROTECTION,INFTL_BINARY,INFTL_BDTL,INFTL_LAST */
  LEmin    spareUnits;   /* Number of spare garanteed units for INFTL partition */
  LEmin    firstQuickMountUnit; /* first unit used for the quick mount data */
  LEmin    protectionArea;      /* Number of protection area */
} BNANDVolumeHeaderRecord;

#ifndef FL_MALLOC

#define ANAND_HEAP_SIZE    (0x100000l / ASSUMED_NFTL_UNIT_SIZE) * (sizeof(ANANDUnitNo) + sizeof(ANANDPhysUnit)) * MAX_VOLUME_MBYTES

#ifdef NFTL_CACHE
#define U_CACHE_SIZE    ((MAX_VOLUME_MBYTES * 0x100000l) / ASSUMED_NFTL_UNIT_SIZE)
#define S_CACHE_SIZE    ((MAX_VOLUME_MBYTES * 0x100000l) / (SECTOR_SIZE * 4))
#endif

#endif /* FL_MALLOC */

#define WLnow           0xfff0

typedef struct {
  word alarm;
  ANANDUnitNo currUnit;
} WLdata;

struct tTLrec{
  FLFlash            *flash;         /* Poniter to MTD record           */
  dword              *verifyBuffer;  /* Pointer to socket verify buffer */
  FLBuffer           *buffer;        /* Pointer to socket buffer        */
  ANANDPhysUnit FAR1 *physicalUnits; /* unit table by physical no.      */
  ANANDUnitNo   FAR1 *virtualUnits;  /* unit table by logical no.       */
  const void    FAR0 *mappedSector;
#ifdef NFTL_CACHE
  ucacheEntry   FAR1 *ucache;               /* Unit Header cache */
  byte          FAR1 *scache;               /* Sector Flags cache */
#endif
#ifndef FL_MALLOC
  char*             heap;
#endif /* FL_MALLOC */
  CardAddress       mappedSectorAddress;

  /* Accumulated statistics. */
  Sdword            sectorsRead,
                    sectorsWritten,
                    sectorsDeleted,
                    parasiteWrites,
                    unitsFolded;

  WLdata            wearLevel;
  dword             eraseSum;
#ifdef NFTL_CACHE
  dword             firstUnitAddress;    /* address of the first unit of the volume */
#endif /* NFTL_CACHE */
  ANANDUnitNo       firstQuickMountUnit; /* The quick mount first unit            */
  ANANDUnitNo       firstUnit;           /* first unit number of the volume       */
  ANANDUnitNo       freeUnits;           /* Free units on media                   */
  ANANDUnitNo       noOfVirtualUnits;    /* No of units exported by the TL */
  ANANDUnitNo       noOfUnits;           /* No of units in the partition          */
  ANANDUnitNo       bootUnits;           /* No of boot units of the media         */
  ANANDUnitNo       roverUnit;    /* Starting point for allocation search         */
  ANANDUnitNo       countsValid;  /* Number of units for which unit count was set */
  word              sectorsPerUnit;      /* Number of 512 bytes in a unit         */
  word              sectorsPerUnitBits;  /* Bits used for no of sectors per unit  */
  word              sectorsPerUnitMask;  /* Number of 512 bytes in a unit - 1     */  
  SectorNo          virtualSectors;      /* No of sectors exported by the TL      */
  SectorNo          mappedSectorNo;      /* Currently mapped sector               */
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  SectorNo          verifiedSectorNo;    /* Largest sector verified so far        */
  SectorNo          curSectorWrite;      /* Current update sector                 */
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
  byte              flags;                 /* QUICK_MOUNT or not                  */
  byte              socketNo;              /* The volumes socket serial number    */
  byte              blockMultiplierBits;   /* the number of ersable blocks in     */
                                           /* an INFTL unit                       */
  byte              erasableBlockSizeBits; /* log2 of erasable block size         */
  byte              unitSizeBits;          /* log2 of TL unit size                */
  FLBoolean         firstMediaWrite;
#ifdef CHECK_MOUNT
  dword             debugState;            /* Used for internal debug */
#endif /* CHECK_MOUNT */
};

typedef TLrec Bnand;

typedef struct {
     LEulong      freeUnits;
     LEulong      roverUnit;
     LEulong      countsValid;
     LEulong      sectorsRead;
     LEulong      sectorsWritten;
     LEulong      sectorsDeleted;
     LEulong      parasiteWrites;
     LEulong      unitsFolded;
     LEulong      wearLevel_1;
     LEulong      wearLevel_2;
     LEulong      eraseSum;
     LEulong      validate; /* QUICK_MOUNT_VALID_SIGN */
     LEulong      checksum; /* checksum of entire quick mount info should be 55 */
     LEulong      verifiedSectorNo; /* Largest sector verified so far           */
}savedBnand;

#define VALIDATE_OFFSET     11*sizeof(LEmin)
#define inftlBuffer         vol.buffer->flData
#endif /* INFTL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\inftl.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/inftl.c_V  $
 *
 *    Rev 1.40   Apr 15 2002 20:14:40   oris
 * Changed the use of SecondUnitStructure for INFTLTEST utility.
 *
 *    Rev 1.39   Apr 15 2002 08:39:32   oris
 * Placed quick mount under if def of CHECK_MOUNT for INFTLTST.
 *
 *    Rev 1.38   Apr 15 2002 07:37:20   oris
 * Improved power failure resistant:
 *  - setUnavail macro was changed for improved code readability.
 *  - MarkSectorAsChecking macro was changed to  MarkSectorAsChecked
 *  - Bug fix - getSectorFlags - in case invalid sector flags are found do not forget to reset TL buffer to ff's and mark it as remapped.
 *  - Added support for VERIFY_ERASED_SECTOR compilation flag - make sure a sector is free before writing it - most of the code
 *    is found in writeAndCheck routine.
 *  - Added MAKE_SURE_IGNORE_HAS_BAD_EDC compilation flag - make sure that the sector is really marked
 *    as ignored. If not mark   the entire sector as 0.
 *  - Initialize a addition 1k buffer for the TL - used for verify erase.
 *  - Bug fix - verifySector routine had several bugs.
 *  - Bug fix - foldUnit routine bad comparison in FL_OFF mode.
 *  - Bug fix - foldBestChain routine missing update of sector count after folding failed and bad search for free unit.
 *  - Bug fix - mountUnit routine had bad handling for corrupted unit header.
 * Added support for RAM based MTD power failure tests.
 * Remove cache allocation checks - They are not needed since the cache routine itself check for proper allocation.
 * Bug fix - prevent initialization of flash record in case flash is NULL.
 * Bug fix - defragment routine used to call allocateUnit instead of foldBestChain.
 * Bug fix - bad debug print when format routine none INFTL media.
 * Bug fix - missing several dismount in INFTL format.
 * Bug fix - format routine could not place protection onto binary partition containing only the bios driver.
 * Changed format debug massages.
 *
 *    Rev 1.37   Feb 19 2002 21:00:22   oris
 * Fixed FL_READ_ONLY compilation problems.
 * Replaced TL_LEAVE_BINARY_AREA with FL_LEAVE_BINARY_AREA
 * Improved protection against power failures:
 * - formatUnit/getUnitTailer and setUnitTailer - Added argument to support temporary units (unit with erase mark on an invalid offset so that if not fixed before next mount they will be considered as free).
 * - foldUnit - Removed setUnavailable (not called only from foldBestChain) and added code to restore temporary unit into permanent ones(mark erase mark in proper place).
 * - foldBestChain - added folding not in place and several bug fixes.
 * - AllocatUnit - Change sequence to be more robust.
 * - checkFolding/applyWearLeveling - Bug fix - read newest unit in chain after allocate call it might change as part of the allocate process.
 * - deleteSector - check status of write operation.
 * - mountInftl - perforce space reclamation only if no free units.
 *
 *    Rev 1.36   Jan 29 2002 20:09:28   oris
 * Removed warnings.
 * Buf fix - chainging protection attributes of a DiskOnChip with more then a single floor.
 * Bug fix - if an invalid sector flag is found in getSectorFlags routine and read operation failed, SECTOR_IGNORED should have been returned.
 *
 *    Rev 1.35   Jan 28 2002 21:25:46   oris
 * Bug fix - discard mark write operation had bad casting causing the
 * mark to be written to much lower addresses.
 * Changed discard variable to static const.
 * allocateAndWriteSectors - improved going along chain algorithm to scan
 * chain only once.
 *
 *    Rev 1.34   Jan 23 2002 23:33:20   oris
 * Removed CHECK_DISCARD compilation flag.
 * Bug fix - bad casting caused discard mark to be written to a different unit then was expected in formatUnit().
 * Changed discardQuickMountInfo to mark quick mount area as discarded instead of erasing it.
 * Improved markAsIgnored routine.
 * Bug fix - Problems with insert and remove key routines.
 * Bug fix - write BBT for INFTL formatted DiskOnChip was not supported.
 * Changed DFORMAT_PRINT syntax
 *
 *    Rev 1.33   Jan 21 2002 20:44:56   oris
 * Bug fix - Erase of quick mount information does not take block multiplication into account.
 *
 *    Rev 1.32   Jan 20 2002 20:28:48   oris
 * Removed warnings
 * Changed putGetBuffer to handle FAR pointers (prototype and pointers arithmetic's).
 * Quick mount is now saved if either of the following occurs
 *  - Last mount did not use quick mount information.
 *  - A write operation was made in this mount
 * Bug in quickMount units size calculation (affected large DiskOnChips).
 *
 *    Rev 1.31   Jan 20 2002 10:49:52   oris
 * Added initialization of Bnand record in mount and format.
 * Removed badFormat field from Bnand record.
 * Improoved last sector cache mechanism
 * Removed support for PPP=3 interleave-2
 * Changed FL_MALLOC allocation calls to FL_FAR_MALLOC and changed RAM tables pointers to FAR1.
 * Split preMount routine into protection routine and other premount routins.
 * Added DOUBLE_MAX_UNIT_CHAIN instead of MAX_UNIT_CHAIN*2
 * Added protection agains power failures.
 *  - Added several modes of verify write :
 *     - FL_UPS no protection
 *     - FL_ON verify each and every write operation
 *     - FL_OFF full protection with minmal performance penalty.
 *     - Added verifyVolume API to scan the media for slower mount, but with not further performance penalty.
 *     - default after mount is FL_OFF
 *  - Added folding not in place.
 *  - Added verification of last sector of the chains (in folding).
 *  - Added discard mark before erasing.
 *  - Changed sector flags and unit data retrival error correction logic.
 *  - Limit foldBestChain folding tryies.
 *  - Improoved mount logic for choosing between invalid chains.
 * Quick mount mechanism
 *  - Forced quick mount as default
 *  - Delete previous data only after first write operation.
 *  - Remove previous quick mount info with an erase operation.
 *  - Added remove previous quick mount info API (In preMount).
 * Imprroved error report mechanizm of brocken chains (should never happen):
 *  - error on read return unused area of flash
 *  - error on write report flGeneralFailure
 *  - error on mount fix chains. If error on a chain that was already validated , report flGeneralFailure
 * Format routine
 *  - Force quick mount (ignoring user flag)
 *  - Bug fix - format with leave binary partition of a protected binary partition.
 *  - Removed single floor support.
 *
 *    Rev 1.30   Nov 21 2001 11:38:26   oris
 * Changed FL_MARK_DELETE to FL_ON.
 * Changed FL_WITH_VERIFY_WRITE and FL_WITHOUT_VERIFY_WRITE to FL_ON and FL_OFF.
 *
 *    Rev 1.29   Nov 16 2001 00:22:22   oris
 * Reorganized - removed function declaration, moved debug routines to a
 * separated file.
 * Bug fix - VERIFY_WRITE logic - marking unit as unavailable was done on the
 * virtual unit and not the last physical unit plus the least sector count and
 * max chain length , where not reinitialized in foldBestChange. The result
 * might cause infinite loop in foldbestchain if foldUnit fails.
 * Bug fix - Support for DiskOnChip with last floors having less chips.
 * Improved progress callback routine to show current unit starting from 1 and
 not 0 and to indicate bad and unavailable blocks as well.
 * Bug fix - all routines that changed protection attributes might not use
 * Bug fix - formatting with LEAVE_BINARY_PARTITION when binary partition is
 * exactly the floor size (virtual size). and improved it for bootAreaLen not
 * 0 and not -1 (leave only part of the previous binary partition).
 * Quick mount feature - Made sure the mount operation changes quick_mount
 * validity even if QUICK_MOUNT_FEATURE is commented.
 * Support 2 unchangeable protected partitions (not only 1).
 * Added discard mark before erase and placed this option under ifdef (default off).
 * Changed isValidUnitFlags to check all fields (isValidParityResult) not just
 * PUN and VUN.
 * getUnitData - bug in the logic of using second unit data structure.
 * No need to reread the unit data if verify write is activated after setUnitData.
 * Added check in virtual2physical to make sure this the unit found is valid.
 * initINFTLbasic - Use dword variable to calculate blocks per unit (support 64k blocks).
 * Change block multiplication from MORE then 32K units (not equal)
 * Improved support for read only mode including mount - FL_READ_ONLY
 * Add runtime option of VERIFY_WRITE
 * Bug fix - Binary partition in the first floor used only 1001 units while in
 * other floors 1002 units.
 *
 *    Rev 1.28   Oct 11 2001 23:54:58   oris
 * Bug fix - When changing protection attribute of a BDTL partition (change
 * key, change lock , change protection type) on a DiskOnChip with more then
 * a single floor, an error massage might be returned since changing
 * protection attributes uses the same buffer as the structure holding the
 * protection area to work on.
 *
 *    Rev 1.27   Sep 24 2001 18:23:50   oris
 * Bug fix - missing break in foldBestChain - very rare case.
 * Removed warnings.
 *
 *    Rev 1.26   Sep 16 2001 21:47:54   oris
 * Placed intergrity check of sector in the last unit of the virtual unit under
 * VERIFY_WRITE compilation flag.
 * Bug fix - missing big-endian conversion when using static memory allocation.
 *
 *    Rev 1.25   Sep 15 2001 23:46:54   oris
 * Removed redundant isAvailable checks.
 * Make sure mount operation does not reconstruct BBT.
 * Bug fix - folding in wear leveling does not change NAC to 1.
 * Bug fix - Bad casting caused bad protection type to be returned under BIG_ENDIAN.
 * Changed change protection attributes routine applied on protected partition
 * from flWrongKey to flHWProtection.
 * Improved algorithm reliability with VERIFY_WRITE. Following are the changes in the algorithm:
 * 1) virtual2Physical -
 * a) added flag stating if the specific sector is not free in the last unit of the chain.
 * 2) foldUnit -
 * a) if can not copy sector to the last unit of the chain, mark unit as
 * unavailable and return error code.
 * b) If verify write is enabled check even sectors that re marked as used and
 * are found on the last unit of the chain.
 * 3) foldBestChain -
 * a) Ignore unavailable units
 * b) If folding failed start looking from the beginning (it will be marked as
 * unavailable by the foldunit routine).
 * c) when done make all unit available.
 * 4) Added checkFolding routine - after folding check if succeeded. If not
 * loop up to MAX_FOLDING_LOOP each time free a unit with foldbestchain,
 * append a unit to the problematic chain and try to fold it.
 * 5) allocateUnit - Now when there are less then 2 unit reclaim space. This is
 * to minimize the chance of folding within a fold operation.
 * 6) MountINFTL - Make sure there are at least 2 free units.
 *
 *    Rev 1.24   Jul 29 2001 16:10:00   oris
 * eraseOrphanUnit bug was fixed ( we did not add vol.firstUnit to the unitNo).
 *
 *    Rev 1.23   Jul 15 2001 20:45:12   oris
 * Improoved documentation.
 * Changed unitBaseAddress function to a macro.
 * Removed unneccesary if statments in applyWearLeveling().
 *
 *    Rev 1.22   Jul 13 2001 01:06:14   oris
 * Changed multiBufferCounter to signed allowing a better buffer management.
 * Changed consequtiveNumbers routine into a macro.
 * Reorganized the DEBUG chains routines.
 * Bug fix - H/W read protected partition did not report as such.
 * Changed swapUnits routine name to applyWearleveling.
 * Added basics for last sector return mechanism -
 *     foldUnit receives an additional field.
 *     read2Sectors returns edc error sector address and actually read sector address
 * Added several static prefixes for static routines.
 * Added edc check for media header read operation.
 * Bug fix - parturition size smaller then a unit was acceptable.
 * Added default protection for unused DPSes.
 * Bug fix - formatINFTL with leave binary partition flag when previous binary
 * partition was larger then a single floor.
 * Improved mount documentation.
 * Changed policy - do not erase unit with bad erase mark.
 *
 *    Rev 1.21   Jun 17 2001 08:20:06   oris
 * Added NO_READ_BBT_CODE compilation flag to reduce code size.
 * Improoved Reliability:
 * 1) Try to return next sector in chain if the current one has EDC error
 * 2) Mount routine erases all blocks not marked with the erase mark.
 *
 * Affected routines:
 * 1) virtual2Physical can recive the physical address to start looking for and
 * not the last virtual unit of the chain.
 * 2) copySector ,foldUnit, mapSector, read2sectors- if EDC error accures
 * return try returning the next sector.
 * 3) foldUnit - if EDC error accures return try returning the next sector.
 * 4) writeMultiSecotr - improove ppp = 3
 * 5) mountINFTL - erase all units not marked with the erase mark.
 *
 *    Rev 1.21   Jun 17 2001 08:18:02   oris
 * Changed recusive include define to INFTL_H.
 * Added FL_BAD_ERASE_MARK    definition for units without the erase mark on
 * mount operation.
 *
 * For the rest of the revisions see revision 1.24 in the PVCS.
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

/*************************************************/
/* T r u e F F S   5.0   S o u r c e   F i l e s */
/* --------------------------------------------- */
/*************************************************/

/*****************************************************************************
* File Header                                                                *
* -----------                                                                *
* Name : inftl.c                                                             *
*                                                                            *
* Description : Implementation of INFTL flash translation layer.             *
*                                                                            *
*****************************************************************************/

/* Internal compilation flags */

/* #define CHAINS_DEBUG  */ /* Prints unit chains after mount routine   */
/* #define CHECK_MOUNT   */ /* Print serious tl debug warnings to       */
                            /* tl_out global file handle                */
/* #define MAKE_SURE_IGNORE_HAS_BAD_EDC */ /* Make sure the ignore mark was */
                                           /* written. If not fill sector   */
                                           /* with 0's.                     */
/* List of included files */

#include "inftl.h"

/* Private variables */

static Bnand vols[VOLUMES];
#ifndef FL_MALLOC
#ifdef NFTL_CACHE
static ucacheEntry   socketUcache[SOCKETS][U_CACHE_SIZE];
static byte socketScache[SOCKETS][S_CACHE_SIZE];
#endif /* NFTL_CACHE */
static Sbyte socketHeap[SOCKETS][ANAND_HEAP_SIZE];
static byte multiSectorBuf[SOCKETS][SECTOR_SIZE<<1];
#else
static byte *multiSectorBuf[SOCKETS];
static Sbyte multiSectorBufCounter[SOCKETS];
#endif /* FL_MALLOC */
#ifdef NFTL_CACHE
/* translation table for Sector Flags cache */
static byte scacheTable[4] = { SECTOR_DELETED, /* 0 */
            SECTOR_IGNORE,  /* 1 */
            SECTOR_USED,    /* 2 */
            SECTOR_FREE };  /* 3 */
#endif /* NFTL_CACHE */

/* Macros */
#define roundToUnits(var) ((var > 0) ? ((ANANDUnitNo)((var - 1) >> vol.unitSizeBits) + 1) : 0)
#define NextGoodUnit(addr,bbt) for(;bbt[(addr >> vol.unitSizeBits) - vol.firstQuickMountUnit]!=ANAND_UNIT_FREE;addr+=1L<<vol.unitSizeBits)
#define countOf(unitNo)      (vol.physicalUnits[unitNo] & UNIT_COUNT)
#define isAvailable(unitNo)  ((vol.physicalUnits[unitNo] == ANAND_UNIT_FREE) || (countOf(unitNo) <= UNIT_MAX_COUNT))
#define setUnavail(unitNo)   (vol.physicalUnits[unitNo]  = UNIT_UNAVAIL)

#define setUnitCount(unitNo,unitCount) { vol.physicalUnits[unitNo] &= ~UNIT_COUNT; vol.physicalUnits[unitNo] |= (ANANDPhysUnit)unitCount; }
#define isLegalUnit(unitNo)  ((unitNo < vol.noOfUnits) || (unitNo == ANAND_NO_UNIT))
#define isValidSectorFlag(sectorFlag) ((sectorFlag==SECTOR_FREE)||(sectorFlag==SECTOR_USED)||(sectorFlag==SECTOR_DELETED))
#define badParityResult(parityResult)   (parityResult != ALL_PARITY_BITS_OK)
#define consecutiveNumbers(first,second) ((byte)(second+1)==first)
#define unitBaseAddress(vol,unitNo) ((CardAddress)((ANANDUnitNo)unitNo+(ANANDUnitNo)vol.firstUnit) << vol.unitSizeBits)
#define distanceOf(read, expected) (onesCount((byte)(read ^ expected)))
#define MarkSectorAsChecked(addr) (scannedBlocks[((addr)>>SECTOR_SIZE_BITS) & vol.sectorsPerUnitMask] = TRUE)
#define WasSectorChecked(addr)     scannedBlocks[((addr)>>SECTOR_SIZE_BITS) & vol.sectorsPerUnitMask]

/* M-Systems INFTL debug routines */
#ifndef CHECK_MOUNT
#define TL_DEBUG_PRINT(x,y,z)
#define SET_EXIT(x)
#define DID_MOUNT_FAIL 1
#endif /* CHECK_MOUNT */
#if (defined(CHECK_MOUNT) || defined (CHAINS_DEBUG))
#include "inftldbg.c"
#endif /* CHECK_MOUNT || CHAINS_DEBUG */


/*------------------------------------------------------*/
/*                o n e s C o u n t                     */
/*                                                      */
/*  counts number of bits that valued 1 in a given byte */
/*------------------------------------------------------*/

static byte onesCount(byte flag)
{
   byte counter;

   for (counter = 0; flag; flag >>= 1)
          if (flag & 1)
           counter++;

   return counter;
}


/*----------------------------------------------------------------------*/
/*                       g e t U n i t T a i l e r                      */
/*                                                                      */
/* Get the erase record of a unit.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit number                          */
/*      eraseMark       : Receives the erase mark of the unit           */
/*      eraseCount      : Receives the erase count of the unit          */
/*      offset          : offset in unit                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus getUnitTailer(Bnand vol,
          ANANDUnitNo unitNo,
          word *eraseMark,
          dword *eraseCount,
          dword offset)
{
  UnitTailer unitTailer;
  FLStatus status;

  status = vol.flash->read(vol.flash,
      unitBaseAddress(vol,unitNo) + offset,
      &unitTailer,
      sizeof(UnitTailer),
      EXTRA);

  /* Mask out any 1 -> 0 bit faults by or'ing with spare data */
  *eraseMark = (word)(LE2(unitTailer.eraseMark) | LE2(unitTailer.eraseMark1));
  *eraseCount = LE4(unitTailer.eraseCount);
  return status;
}


#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                       s e t U n i t T a i l e r                      */
/*                                                                      */
/* Set the erase record of a unit.                                      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit number                          */
/*      eraseMark       : Erase mark to set                             */
/*      eraseCount      : Erase count to set                            */
/*      offset          : offset in unit                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus setUnitTailer(Bnand vol,
        ANANDUnitNo unitNo,
        word eraseMark,
        dword eraseCount,
        dword offset)
{
  UnitTailer unitTailer;

  toLE2(unitTailer.eraseMark,eraseMark);
  toLE2(unitTailer.eraseMark1,eraseMark);
  toLE4(unitTailer.eraseCount,eraseCount);

  return vol.flash->write(vol.flash,
          unitBaseAddress(vol,unitNo) + offset,
          &unitTailer,
          sizeof(UnitTailer),
          EXTRA);
}


/*----------------------------------------------------------------------*/
/*                          m a r k U n i t B a d                       */
/*                                                                      */
/* Mark a unit as bad in the conversion table and the bad units table.  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical number of bad unit                   */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus markUnitBad(Bnand vol, ANANDUnitNo unitNo)
{
  word eraseMark;
  dword eraseCount;
  FLStatus status;

  vol.physicalUnits[unitNo] = UNIT_BAD;
  if(vol.freeUnits)
    vol.freeUnits--;

  status = getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount,UNIT_TAILER_OFFSET);
  if (status == flOK)
     status = setUnitTailer(&vol,unitNo,FL_BAD_ERASE_MARK,eraseCount,UNIT_TAILER_OFFSET);

#ifdef NFTL_CACHE
  if (vol.ucache != NULL) /* Mark unit cache as unavaialbel */
  {
     vol.ucache[unitNo].virtualUnitNo = 0xDEAD;
     vol.ucache[unitNo].prevUnitNo    = 0xDEAD;
  }
#endif /* NFTL_CACHE */
  return status;
}


/*----------------------------------------------------------------------*/
/*                        f o r m a t U n i t                           */
/*                                                                      */
/* Format one unit. Erase the unit, and mark the physical units table.  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit to format                       */
/*      eraseMarkOffset : Offset to place erase mark                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus formatUnit(Bnand vol, ANANDUnitNo unitNo,
                           dword eraseMarkOffset)
{
  word eraseMark;
  dword eraseCount;
  FLStatus status;
#ifndef RAM_MTD
  static const
#endif /* RAM_MTD */
  byte discard = (byte)CLEAR_DISCARD;

  status = getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount,UNIT_TAILER_OFFSET);
  if(status != flOK)
    return status;

#ifdef NFTL_CACHE
  /* Update ANANDUnitHeader cache to prevent re-filling from flash */
  if (vol.ucache != NULL) {
      vol.ucache[unitNo].virtualUnitNo     = ANAND_NO_UNIT;
      vol.ucache[unitNo].prevUnitNo        = ANAND_NO_UNIT;
      vol.ucache[unitNo].ANAC              = ANAND_UNIT_FREE;
      vol.ucache[unitNo].NAC               = ANAND_UNIT_FREE;
  }

  /*
   * Purge the Sector Flags cache (set entries for all the unit's
   * sectors to SECTOR_FREE).
   */

  if(vol.scache!=NULL)
  {
    tffsset(&(vol.scache[unitNo << (vol.unitSizeBits - SECTOR_SIZE_BITS-2)]),
    S_CACHE_4_SECTORS_FREE, 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS - 2));
  }
#endif /* NFTL_CACHE */

  /* Mark unit as unusable before erase */
  vol.flash->write(vol.flash,(((dword)(vol.firstUnit + unitNo))<<vol.unitSizeBits)+DISCARD_UNIT_OFFSET,&discard,1,EXTRA);

  /* Physicaly erase unit */
  status = vol.flash->erase(vol.flash,(word)((word)(vol.firstUnit + unitNo)
           << vol.blockMultiplierBits),(word)(1 << vol.blockMultiplierBits));

  vol.eraseSum++;
  eraseCount++;
  if (eraseCount == 0)          /* was hex FF's */
    eraseCount++;

  if (status == flOK)
     status = setUnitTailer(&vol,unitNo,ERASE_MARK,eraseCount,eraseMarkOffset);

  if (status != flOK) {
    markUnitBad(&vol,unitNo);   /* make sure unit format is not valid */
    return status;
  }

  if (vol.physicalUnits[unitNo] != ANAND_UNIT_FREE)
  {
     vol.physicalUnits[unitNo] = ANAND_UNIT_FREE;
     vol.freeUnits++;
  }

  return status;
}

#endif /* FL_READ_ONLY */


/*----------------------------------------------------------------------*/
/*                       g e t U n i t D a t a                          */
/*                                                                      */
/* Get virtual unit No. and replacement unit no. of a unit.             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol              : Pointer identifying drive                    */
/*      unitNo           : Physical unit number                         */
/*      virtualUnitNo    : Returns the virtual unit no.                 */
/*      prevUnitNo       : Returns the previous unit no.                */
/*      ANAC             : Returns the Accumulating Number Along Chain. */
/*      NAC              : Returns the Number Along Chain value.        */
/*      validFields      : Returns a bit map of the valid fields.       */
/*                                                                      */
/* Returns:                                                             */
/*    flOK on success, flHWProtection on H/W read protection.           */
/*----------------------------------------------------------------------*/

static FLStatus getUnitData(Bnand vol,
        ANANDUnitNo unitNo,
        ANANDUnitNo *virtualUnitNo,
        ANANDUnitNo *prevUnitNo,
        byte *ANAC,
        byte *NAC,
        byte *validFields)
{
  ANANDUnitHeader       unitData;
  SecondANANDUnitHeader secondUnitData;
  FLStatus              status;
  byte                  parityPerField=0;
  byte                  temp;
  byte                  returnedValidField = ALL_PARITY_BITS_OK;
  byte                  curValidFields[2];
  int                   index;

#ifdef NFTL_CACHE
  /* on cache miss read ANANDUnitHeader from flash and re-fill cache */
  if ((vol.ucache != NULL)&&(vol.ucache[unitNo].virtualUnitNo != 0xDEAD) &&
      (vol.ucache[unitNo].prevUnitNo != 0xDEAD))
  {
     *virtualUnitNo = vol.ucache[unitNo].virtualUnitNo;
     *prevUnitNo = vol.ucache[unitNo].prevUnitNo;
     *ANAC = vol.ucache[unitNo].ANAC;
     *NAC = vol.ucache[unitNo].NAC;
  }
  else
#endif  /* NFTL_CACHE */
  {   /* no ANANDUnitHeader cache MUST read first header */

      *validFields       = 0; /* Set all fields to be invalid */

      /* Read first unit data */
      status = vol.flash->read(vol.flash,
                   unitBaseAddress(vol,unitNo) + UNIT_DATA_OFFSET,
                   &unitData,
                   sizeof(ANANDUnitHeader),
                   EXTRA);
      if(status != flOK)
         return status;

      *virtualUnitNo = LE2(unitData.virtualUnitNo);
      *prevUnitNo    = LE2(unitData.prevUnitNo   );
      *ANAC          = unitData.ANAC;
      *NAC           = unitData.NAC;

      for(index=0;index<2;index++)
      {
         /* If all data is 0xff assume a free unit */
         if((*virtualUnitNo     == ANAND_NO_UNIT  )&&
            (*prevUnitNo        == ANAND_NO_UNIT  )&&
            (*ANAC              == ANAND_UNIT_FREE)&&
            (*NAC               == ANAND_UNIT_FREE)&&
            (unitData.discarded == ANAND_UNIT_FREE))
         {
#ifndef FL_READ_ONLY
            if(index!=0)
            {
               /* If this is the second copy then the first was not  */
               /* erased, but since it was written first it makes no */
               /* sence. Let us erase it just in case.               */

               status = formatUnit(&vol,unitNo,UNIT_TAILER_OFFSET);
               if(status != flOK)
                  return status;
            }
#endif /* FL_READ_ONLY */
            break;
         }

         /* Not a free unit check unit data validity (discard and partity) */
         if ((onesCount((byte)(unitData.discarded^DISCARD))>1))
         {
            /* Discarded mark is more then 1 bit distance from 0xAA  */
            /* Assume erase operation was interrupted and erase unit */

            TL_DEBUG_PRINT(tl_out,"getUnitData : unit %d has an invalid discard mark\n",unitNo);
            TL_DEBUG_PRINT(tl_out,"              it might be helpful to know it was %d\n",unitData.discarded);

#ifndef FL_READ_ONLY
            status = formatUnit(&vol,unitNo,UNIT_TAILER_OFFSET);
            if(status != flOK)
               return status;
#endif /* FL_READ_ONLY */
            *virtualUnitNo = ANAND_NO_UNIT;
            *prevUnitNo    = ANAND_NO_UNIT;
            *ANAC          = ANAND_UNIT_FREE;
            *NAC           = ANAND_UNIT_FREE;
            break;
         }

         /* Discarded OK now check parity field */
         parityPerField = 0;
         temp=(byte)(((byte *)virtualUnitNo)[0]^((byte *)virtualUnitNo)[1]);
         if((onesCount(temp) & 1)==1)
            parityPerField|=VU_PARITY_BIT;
         temp=(byte)(((byte *)prevUnitNo)[0]^((byte *)prevUnitNo)[1]);
         if((onesCount(temp) & 1)==1)
            parityPerField|=PU_PARITY_BIT;
         if((onesCount(unitData.ANAC) & 1)==1)
            parityPerField|=ANAC_PARITY_BIT;
         if((onesCount(unitData.NAC) & 1)==1)
            parityPerField|=NAC_PARITY_BIT;

         /* Store valid fields using bitmap */
         curValidFields[index] = (byte)((~(parityPerField ^ unitData.parityPerField))
                         & ALL_PARITY_BITS_OK);

         if(curValidFields[index] == ALL_PARITY_BITS_OK)
         {
            /* If either copies has valid fields (all of them) use it */
            break;
         }
         else
         {
            if(index>0)
            {
               /* Use first header data if possible otherwise use second */
               returnedValidField = (byte)(curValidFields[0] | curValidFields[1]);
               TL_DEBUG_PRINT(tl_out,"getUnitData : The returned valid field indicator is %d\n",returnedValidField);
               TL_DEBUG_PRINT(tl_out,"              While %d indicates a valid unit data\n",ALL_PARITY_BITS_OK);
               if(curValidFields[0] & VU_PARITY_BIT)
                  *virtualUnitNo = LE2(unitData.virtualUnitNo);

               if(curValidFields[0] & PU_PARITY_BIT)
                  *prevUnitNo    = LE2(unitData.prevUnitNo   );

               if(curValidFields[0] & ANAC_PARITY_BIT)
                  *ANAC          = unitData.ANAC;

               if(curValidFields[0] & NAC_PARITY_BIT)
                  *NAC           = unitData.ANAC;
               break;
            }
         }

         /* Read second unit header for next iteration */
         status = vol.flash->read(vol.flash, unitBaseAddress(vol,unitNo) +
                      SECOND_HEADER_OFFSET + UNIT_DATA_OFFSET,
                      &secondUnitData,
                      sizeof(SecondANANDUnitHeader),
                      EXTRA);
         if(status != flOK)
            return status;

         *virtualUnitNo = LE2(secondUnitData.virtualUnitNo);
         *prevUnitNo    = LE2(secondUnitData.prevUnitNo   );
         *ANAC          = secondUnitData.ANAC;
         *NAC           = secondUnitData.NAC;

         TL_DEBUG_PRINT(tl_out,"getUnitData : First unit header is not OK in unit %d \n",unitNo);
         TL_DEBUG_PRINT(tl_out,"getUnitData : Virtual Unit No  = %d \n",LE2(unitData.virtualUnitNo));
         TL_DEBUG_PRINT(tl_out,"getUnitData : Previous Unit No = %d \n",LE2(unitData.prevUnitNo));
         TL_DEBUG_PRINT(tl_out,"getUnitData : ANAC             = %d \n",unitData.ANAC);
         TL_DEBUG_PRINT(tl_out,"getUnitData : NAC              = %d \n",unitData.NAC);
         TL_DEBUG_PRINT(tl_out,"getUnitData : ParityPerField   = %d \n",unitData.parityPerField);
         TL_DEBUG_PRINT(tl_out,"getUnitData : Discarded        = %d \n",unitData.discarded);

         TL_DEBUG_PRINT(tl_out,"getUnitData : Second unit header of the same unit %d is:\n",unitNo);
         TL_DEBUG_PRINT(tl_out,"getUnitData : Virtual Unit No  = %d \n",LE2(secondUnitData.virtualUnitNo));
         TL_DEBUG_PRINT(tl_out,"getUnitData : Previous Unit No = %d \n",LE2(secondUnitData.prevUnitNo));
         TL_DEBUG_PRINT(tl_out,"getUnitData : ANAC             = %d \n",secondUnitData.ANAC);
         TL_DEBUG_PRINT(tl_out,"getUnitData : NAC              = %d \n",secondUnitData.NAC);
         TL_DEBUG_PRINT(tl_out,"getUnitData : ParityPerField   = %d \n",secondUnitData.parityPerField);
      }

#ifdef NFTL_CACHE
      if ((vol.ucache != NULL) &&                     /* Cache enabled    */
          (returnedValidField == ALL_PARITY_BITS_OK)) /* All fields valid */
      {
         vol.ucache[unitNo].virtualUnitNo = *virtualUnitNo;
         vol.ucache[unitNo].prevUnitNo    = *prevUnitNo;
         vol.ucache[unitNo].ANAC          = *ANAC;
         vol.ucache[unitNo].NAC           = *NAC;
      }
#endif /* NFTL_CACHE */
   }
   *validFields = returnedValidField;
   return flOK;

}


/*----------------------------------------------------------------------*/
/*                       g e t P r e v U n i t                          */
/*                                                                      */
/* Get next unit in chain.                                              */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit number                          */
/*      virUnitNo       : The expected virtual unit number              */
/*                                                                      */
/* Returns:                                                             */
/*      Physical unit number of the unit following unitNo in the chain. */
/*      If such unit do not exist, return ANAND_NO_UNIT.                */
/*----------------------------------------------------------------------*/

static ANANDUnitNo getPrevUnit(Bnand vol, ANANDUnitNo unitNo, ANANDUnitNo virUnitNo)
{
  ANANDUnitNo virtualUnitNo, replacementUnitNo;
  byte ANAC,NAC;
  byte parityPerField;

  /* If first in chain there can be not previous unit */
  if ((vol.physicalUnits[unitNo] & FIRST_IN_CHAIN))
    return ANAND_NO_UNIT;

  getUnitData(&vol,unitNo,&virtualUnitNo,&replacementUnitNo,&ANAC,&NAC,&parityPerField);

  /* check if unit is valid */
  if((badParityResult(parityPerField)) || ( virUnitNo != virtualUnitNo ))
  {
     TL_DEBUG_PRINT(tl_out,"getPrevUnit : An invalid unit was detected on getPrevUnit - parity is %x/0xf ",parityPerField);
     TL_DEBUG_PRINT(tl_out,"given virtual unit no is %d ",virUnitNo);
     TL_DEBUG_PRINT(tl_out,"where %d was read\n",virtualUnitNo);
     SET_EXIT(INFTL_FAILED_MOUNT);
     return ANAND_BAD_CHAIN_UNIT;
  }
  return replacementUnitNo;
}


#ifdef NFTL_CACHE

/*----------------------------------------------------------------------*/
/*           g e t S e c t o r F l a g s F r o m C a c h e              */
/*                                                                      */
/* Get sector flags from Sector Cache.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address         : starting address of the sector                */
/*                                                                      */
/* Returns:                                                             */
/*      sector flags (SECTOR_USED, SECTOR_DELETED etc.)                 */
/*----------------------------------------------------------------------*/

static byte getSectorFlagsFromCache(Bnand vol, CardAddress address)
{
  return scacheTable[((vol.scache[(address - vol.firstUnitAddress) >> (SECTOR_SIZE_BITS+2)] >>
                     (((word)address >> 8) & 0x7)) & 0x3)];
}


/*----------------------------------------------------------------------*/
/*               s e t S e c t o r F l a g s C a c h e                  */
/*                                                                      */
/* Get sector flags from Sector Cache.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address         : starting address of the sector                */
/*      sectorFlags     : one of SECTOR_USED, SECTOR_DELETED etc.       */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void setSectorFlagsCache(Bnand vol, CardAddress address,
        byte sectorFlags)
{
  register byte tmp, val;

  if (vol.scache == NULL)
    return;

  tmp = vol.scache[(address - vol.firstUnitAddress) >> (SECTOR_SIZE_BITS+2)];

  switch(sectorFlags) {
    case SECTOR_USED:          val = S_CACHE_SECTOR_USED;    break;
    case SECTOR_FREE:          val = S_CACHE_SECTOR_FREE;    break;
    case SECTOR_DELETED:       val = S_CACHE_SECTOR_DELETED; break;
    default:/* SECTOR_IGNORE */val = S_CACHE_SECTOR_IGNORE;  break;
  }

  switch (((word)address >> 8) & 0x7) {
    case 0: tmp = (tmp & 0xfc) | (val     ); break;  /* update bits 0..1 */
    case 2: tmp = (tmp & 0xf3) | (val << 2); break;  /*        bits 2..3 */
    case 4: tmp = (tmp & 0xcf) | (val << 4); break;  /*        bits 4..5 */
    case 6: tmp = (tmp & 0x3f) | (val << 6); break;  /*        bits 6..7 */
  }

  vol.scache[(address - vol.firstUnitAddress) >> (SECTOR_SIZE_BITS+2)] = tmp;
}

#endif /* NFTL_CACHE */


/*----------------------------------------------------------------------*/
/*                      g e t S e c t o r F l a g s                     */
/*                                                                      */
/* Get sector status.                                                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorAddress           : Physical address of the sector        */
/*                                                                      */
/* Returns:                                                             */
/*      Return the OR of the two bytes in the sector status area (the   */
/*      bytes should contain the same data).                            */
/*----------------------------------------------------------------------*/

static byte getSectorFlags(Bnand vol, CardAddress sectorAddress)
{
  byte     flags[2];
  byte     blockFlag = SECTOR_IGNORE;
  byte     index,tmpSector;
  FLStatus status;

#ifdef NFTL_CACHE
  if (vol.scache != NULL) {  /* check for Sector Flags cache hit */

    blockFlag = getSectorFlagsFromCache(&vol, sectorAddress);
    if (blockFlag != SECTOR_IGNORE)
      return blockFlag;
  }
#endif /* NFTL_CACHE */

  vol.flash->read(vol.flash, sectorAddress + SECTOR_DATA_OFFSET,
                  flags, sizeof flags, EXTRA);

  if((flags[0] == flags[1]) && (isValidSectorFlag(flags[0])))
  {
     blockFlag = flags[0];
  }
  else /* Sector flags that were read are not legal or not valid */
  {
     TL_DEBUG_PRINT(tl_out,"getSectorFlags : Sector flags are not valid - physical addr %ld ",sectorAddress);
     TL_DEBUG_PRINT(tl_out,"first flag was %x ",flags[0]);
     TL_DEBUG_PRINT(tl_out,"while scond is %x\n",flags[1]);
     SET_EXIT(INFTL_FAILED_MOUNT);

     /* Force remapping of internal catched sector */
     vol.flash->socket->remapped = TRUE;

     /* Check for ignored sector using the EDC */
     status = vol.flash->read(vol.flash, sectorAddress,
                     inftlBuffer, SECTOR_SIZE, EDC);
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
     /* Now restore the ff's for the verifySectors routine */
     tffsset(inftlBuffer,0xff,SECTOR_SIZE);
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */

     if(status == flOK)
     {
        /* Check if distance is less then 2 bits failure since */
        /* 2 bits failure can be either delete or used         */
        for (index=0 , tmpSector = (byte)SECTOR_USED ; index < 2 ;
             index++ , tmpSector = (byte)SECTOR_DELETED)
        {
           if (distanceOf(flags[0], tmpSector) +
               distanceOf(flags[1], tmpSector) <= 2)
           {
              blockFlag = tmpSector;
              break;
           }
        }
        if(index>=2)
           return SECTOR_IGNORE;
     }
     else
     {
        return SECTOR_IGNORE;
     }
  }

#ifdef NFTL_CACHE
  /* update Sector Flags cache */
  setSectorFlagsCache(&vol, sectorAddress, blockFlag);
#endif /* NFTL_CACHE */

  return blockFlag;
}


#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                       s e t U n i t D a t a                          */
/*                                                                      */
/* Set virtual unit No. and replacement unit no. of a unit.             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit number                          */
/*      virtualUnitNo   : Virtual unit no.                              */
/*      prevUnitNo      : Previous unit no.                             */
/*      ANAC            : Accumulating Number Along Chain               */
/*      NAC             : Number Along Chain.                           */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus          : 0 on success, failed otherwise              */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus setUnitData(Bnand vol,
          ANANDUnitNo unitNo,
          ANANDUnitNo virtualUnitNo,
          ANANDUnitNo prevUnitNo,byte ANAC,byte NAC)
{
  ANANDUnitHeader       unitData;
  SecondANANDUnitHeader secondUnitData;
  FLStatus              status;
  ANANDUnitNo newVirtualUnitNo, newPrevUnitNo;
  byte newANAC,newNAC;
  byte temp;
  byte parityPerField = 0;

  if( prevUnitNo == unitNo )              /* prevent chain loop */
    return flGeneralFailure;

  /* Calculate parity per field */
  temp=(byte)(((byte *)&virtualUnitNo)[0]^((byte *)&virtualUnitNo)[1]);
  if((onesCount(temp) & 1)==1)
     parityPerField|=VU_PARITY_BIT;

  temp=(byte)(((byte *)&prevUnitNo)[0]^((byte *)&prevUnitNo)[1]);
  if((onesCount(temp) & 1)==1)
     parityPerField|=PU_PARITY_BIT;

  if((onesCount(ANAC) & 1)==1)
     parityPerField|=ANAC_PARITY_BIT;

  if((onesCount(NAC) & 1)==1)
     parityPerField|=NAC_PARITY_BIT;

  /* Store fields in proper unit header record */
  toLE2(unitData.virtualUnitNo,virtualUnitNo);
  toLE2(secondUnitData.virtualUnitNo,virtualUnitNo);
  toLE2(unitData.prevUnitNo,prevUnitNo);
  toLE2(secondUnitData.prevUnitNo,prevUnitNo);
  unitData.ANAC=secondUnitData.ANAC=ANAC;
  unitData.NAC=secondUnitData.NAC=NAC;
  unitData.parityPerField=secondUnitData.parityPerField=parityPerField;
  unitData.discarded=DISCARD;

  /* Write first unit header */
  status = vol.flash->write(vol.flash,
                               unitBaseAddress(vol,unitNo) + UNIT_DATA_OFFSET,
                               &unitData,
                               sizeof(ANANDUnitHeader),
                               EXTRA);
  if(status == flOK) /* Write second unit header */
     status = vol.flash->write(vol.flash, unitBaseAddress(vol,unitNo) +
                               SECOND_HEADER_OFFSET+UNIT_DATA_OFFSET,
                               &secondUnitData,
                               sizeof(SecondANANDUnitHeader),
                               EXTRA);
  if(status == flOK)
  {

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
     if (vol.flash->socket->verifyWrite == FL_ON)
        goto fillCache;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

#ifdef NFTL_CACHE
     if (vol.ucache != NULL) /* Mark unit cache as none valid before read */
     {
        vol.ucache[unitNo].virtualUnitNo = 0xDEAD;
        vol.ucache[unitNo].prevUnitNo    = 0xDEAD;
     }
#endif /* NFTL_CACHE */

     status = getUnitData(&vol,unitNo,&newVirtualUnitNo, &newPrevUnitNo,&newANAC,&newNAC,&parityPerField);
     if (status == flOK)
     {
         if ((virtualUnitNo == newVirtualUnitNo) &&
             (prevUnitNo    == newPrevUnitNo   ) &&
             (!badParityResult(parityPerField) )   )
            goto fillCache;
     }
  }

  /* If we reached here we failed in writing unit header */
  /* Erase unit and report write fault                   */

  DEBUG_PRINT(("setUnitData : Failed setting unit data\r\n"));
  status = formatUnit(&vol,unitNo,UNIT_TAILER_OFFSET);
  if (status != flOK)
  {
     markUnitBad(&vol,unitNo);
     return status;
  }
  else
  {
     return flWriteFault;
  }

fillCache: /* Unit headers were placed OK, now update cache */
#ifdef NFTL_CACHE
  /* Update ANANDUnitHeader cache to prevent re-filling from flash */
  if (vol.ucache != NULL) {
      vol.ucache[unitNo].virtualUnitNo = virtualUnitNo;
      vol.ucache[unitNo].prevUnitNo    = prevUnitNo;
      vol.ucache[unitNo].ANAC          = ANAC;
      vol.ucache[unitNo].NAC           = NAC;
  }
#endif /* NFTL_CACHE */
  return flOK;
}

/*----------------------------------------------------------------------*/
/*             d i s c a r d Q u i c k M o u n t I n f o                */
/*                                                                      */
/* Mark quick mount information is none valid.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus discardQuickMountInfo(Bnand vol)
{
#ifndef RAM_MTD
   static const
#endif /* RAM_MTD */
   dword tmp = 0;
   /* Dis - validate quick mount data */
   if(vol.firstMediaWrite == FALSE)
   {
      vol.firstMediaWrite = TRUE;
      return vol.flash->write(vol.flash, QUICK_MOUNT_VALID_SIGN_OFFSET +
                              ((dword)vol.firstQuickMountUnit <<
                                vol.unitSizeBits),
                              &tmp,
                              sizeof(tmp),
                              0);
   }
   return flOK;
}

/*----------------------------------------------------------------------*/
/*                      m a r k A s I g n o r e d                       */
/*                                                                      */
/* Mark sector at given address as ignored.                             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      addr            : Physical address of the sector                */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void markAsIgnored(Bnand vol,CardAddress addr)
{
#ifndef RAM_MTD
    static const
#endif /* RAM_MTD */
    byte sectorFlags[2] = {SECTOR_IGNORE,SECTOR_IGNORE};

    DEBUG_PRINT(("markAsIgnored : A sector is being marked as ignored\r\n"));

    discardQuickMountInfo(&vol);

#ifdef NFTL_CACHE
    setSectorFlagsCache(&vol, addr, SECTOR_IGNORE);
#endif /* NFTL_CACHE */
     vol.flash->write(vol.flash,addr+SECTOR_DATA_OFFSET,sectorFlags,sizeof(sectorFlags),EXTRA);

#ifdef MAKE_SURE_IGNORE_HAS_BAD_EDC
     /* Force remapping of internal catched sector */
     vol.flash->socket->remapped = TRUE;

     /* Make sure EDC is wrong - a slite problem with PPP */
     if(vol.flash->read(vol.flash,addr,inftlBuffer,sizeof(inftlBuffer),EDC)==flOK)
     {
        tffsset(inftlBuffer,0,sizeof(inftlBuffer));
        vol.flash->write(vol.flash,addr,inftlBuffer,sizeof(inftlBuffer),0);
     }
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
     /* Now restore the ff's for the verifySectors routine */
     tffsset(inftlBuffer,0xff,sizeof(inftlBuffer));
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
#endif /* MAKE_SURE_IGNORE_HAS_BAD_EDC */

}

#endif /* FL_READ_ONLY */


/*----------------------------------------------------------------------*/
/*                       v i r t u a l 2 P h y s i c a l                */
/*                                                                      */
/* Translate virtual sector number to physical address.                 */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Virtual sector number                         */
/*      startAddress    : Physical address to start from                */
/*      lastOK          : TRUE - the current sector in the last unit of */
/*                        virtual unit chain is free (not marked as     */
/*                        deleted / ignored or used).                   */
/*                                                                      */
/* Note: The first unit of the search is assumed to be valid.           */
/*                                                                      */
/* Returns:                                                             */
/*      physical address of sectorNo                                    */
/*----------------------------------------------------------------------*/

static CardAddress virtual2Physical(Bnand vol, SectorNo sectorNo,
                    CardAddress startAddress,FLBoolean* lastOK)
{
  word        unitOffset = (word)((sectorNo & vol.sectorsPerUnitMask) << SECTOR_SIZE_BITS);
  ANANDUnitNo unitNo, virUnitNo;
  ANANDUnitNo chainBound    = 0;
  CardAddress sectorAddress = ANAND_UNASSIGNED_ADDRESS;
  byte sectorFlags          = SECTOR_FREE;

  /* follow the chain */
  virUnitNo = (ANANDUnitNo)(sectorNo >> vol.sectorsPerUnitBits);
  if (startAddress == ANAND_UNASSIGNED_ADDRESS)
  {
     /* Start from last unit in chain */
     unitNo = vol.virtualUnits[virUnitNo];
  }
  else
  {
     /* Start from the unit that follows the given unit */

     TL_DEBUG_PRINT(tl_out,"virtual2Physical : Virtual to physical started from middle of chain on unit %d\n",virUnitNo);
     SET_EXIT(INFTL_FAILED_MOUNT);
     unitNo = getPrevUnit(&vol,(ANANDUnitNo)((startAddress >> vol.unitSizeBits) - vol.firstUnit),virUnitNo);
     if(unitNo == ANAND_BAD_CHAIN_UNIT)
        return ANAND_BAD_CHAIN_ADDRESS;
  }

  for (;unitNo != ANAND_NO_UNIT;unitNo = getPrevUnit(&vol,unitNo,virUnitNo))
  {
     if((unitNo == ANAND_BAD_CHAIN_UNIT     ) ||
        (chainBound >= DOUBLE_MAX_UNIT_CHAIN)   )
        return ANAND_BAD_CHAIN_ADDRESS;

     sectorAddress = unitBaseAddress(vol,unitNo) + unitOffset;
     sectorFlags   = getSectorFlags(&vol,sectorAddress);

     /* Report if the last unit of the chain is used */
     if ((unitNo == vol.virtualUnits[virUnitNo]) &&
         (sectorFlags != SECTOR_FREE))
        *lastOK = FALSE;

     if((sectorFlags==SECTOR_FREE) || (sectorFlags==SECTOR_IGNORE))
     {
        chainBound++;
        continue;
     }
     break;
  }

  if((sectorFlags==SECTOR_IGNORE)||(sectorFlags==SECTOR_FREE)||(sectorFlags==SECTOR_DELETED)) /* Sector was never written*/
     return  ANAND_UNASSIGNED_ADDRESS;
  return sectorAddress;
}


/*----------------------------------------------------------------------*/
/*                   i n i t I N F T L b a s i c                        */
/*                                                                      */
/* Initializes essential volume data                                    */
/*                                                                      */
/* Note : This routine is called both by the mount and format initINFTL */
/* and as a preparation for counting the number of partitions function. */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      flash           : Flash media mounted on this socket            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus initINFTLbasic(Bnand vol, FLFlash *flash)
{
  dword noOfUnits; /* Keep this variable dword , for large DiskOnChips */

  if (flash == NULL || !(flash->flags & INFTL_ENABLED))
  {
    DEBUG_PRINT(("\nDebug: media is not fit for INFTL format.\r\n"));
    return flUnknownMedia;
  }
  if(flash->readBBT == NULL)
  {
     DEBUG_PRINT(("\nDEBUG : MTD read BBT routine was not initialized\r\n"));
     return flFeatureNotSupported;
  }

  vol.flash                 = flash;
  vol.erasableBlockSizeBits = flash->erasableBlockSizeBits;
  vol.unitSizeBits          = vol.erasableBlockSizeBits;
  noOfUnits = (dword)((vol.flash->noOfChips * vol.flash->chipSize) >> vol.unitSizeBits);

  /* Bound number of units to find room in 64 Kbytes Segment */

  if((noOfUnits > MAX_UNIT_NUM) && (vol.unitSizeBits < MAX_UNIT_SIZE_BITS))
  {
    vol.unitSizeBits++;
    noOfUnits >>= 1;
  }

  vol.blockMultiplierBits = vol.unitSizeBits - vol.erasableBlockSizeBits;

  /* get pointer to buffer (we assume SINGLE_BUFFER is not defined) */
  vol.buffer              = flBufferOf(flSocketNoOf(vol.flash->socket));
#ifdef VERIFY_ERASED_SECTOR
  vol.verifyBuffer        = (dword *)flReadBackBufferOf(flSocketNoOf(flash->socket));
#endif /* VERIFY_ERASED_SECTOR */
  flash->socket->remapped = TRUE;

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                           i n i t N F T L                            */
/*                                                                      */
/* Initializes essential volume data as a preparation for mount or      */
/* format.                                                              */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      flash           : Flash media mounted on this socket            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus initINFTL(Bnand vol, FLFlash *flash)
{
  dword    chipSize; /* Keep this variable dword , for large DiskOnChips */
  FLStatus status;

  if(flash!=NULL)
  {
     tffsset(&vol,0,sizeof(Bnand));     /* Clear Bnand volume */

#ifdef NT5PORT
  vol.socketNo = (byte)(flSocketNoOf(flash->socket)); /* socket No */
#else
    vol.socketNo = flSocketNoOf(flash->socket); /* socket No */
#endif /*NT5PORT*/

  }

  status = initINFTLbasic(&vol, flash);
  if(status != flOK)
    return status;

  chipSize = (dword)(flash->chipSize * flash->noOfChips);

#ifndef FL_MALLOC
  if (chipSize > (dword)MAX_VOLUME_MBYTES << 20)
  {
    DEBUG_PRINT(("\nDebug: TrueFFS is customized for smaller media capacities.\r\n"));
    return flGeneralFailure;
  }
  if (ASSUMED_NFTL_UNIT_SIZE > (1L<<vol.unitSizeBits))
  {
    DEBUG_PRINT(("\nDebug: TrueFFS is customized for smaller unit sizes.\r\n"));
    return flGeneralFailure;
  }
#endif /* FL_MALLOC */

  vol.physicalUnits = NULL;
  vol.virtualUnits  = NULL;

#ifdef NFTL_CACHE
  vol.ucache        = NULL;
  vol.scache        = NULL;
#endif /* NFTL_CACHE */

  vol.mappedSectorNo      = UNASSIGNED_SECTOR;
  vol.countsValid         = 0;    /* No units have a valid count yet */
  vol.firstUnit           = 0;
  vol.sectorsPerUnit      = 1 << (vol.unitSizeBits - SECTOR_SIZE_BITS);
  vol.sectorsPerUnitBits  = vol.unitSizeBits - SECTOR_SIZE_BITS;
  vol.sectorsPerUnitMask  = vol.sectorsPerUnit - 1;
  vol.noOfUnits           = (ANANDUnitNo)(chipSize >> vol.unitSizeBits);
  vol.firstMediaWrite     = FALSE;
#if (defined(VERIFY_WRITE) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  vol.verifiedSectorNo = 0;    /* Largest sector verified so far     */
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */

#ifdef CHECK_MOUNT
  vol.debugState = 0;
#endif /* CHECK_MOUNT */

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                          i n i t T a b l e s                         */
/*                                                                      */
/* Allocates and initializes the dynamic volume table, including the    */
/* unit tables and secondary virtual map.                               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      ramForUnits   : Number of bytes allocated to previous volumes   */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

#ifdef FL_MALLOC
static FLStatus initTables(Bnand vol)
{
  /* Allocate the conversion tables */

  vol.physicalUnits = (ANANDPhysUnit FAR1*) FL_FAR_MALLOC(vol.noOfUnits * sizeof(ANANDPhysUnit));
  if (vol.noOfVirtualUnits > 0)
     vol.virtualUnits = (ANANDUnitNo FAR1*) FL_FAR_MALLOC(vol.noOfVirtualUnits * sizeof(ANANDUnitNo));
  if ((vol.physicalUnits == NULL) ||
      ((vol.virtualUnits  == NULL) && (vol.noOfVirtualUnits > 0)))
  {
    DEBUG_PRINT(("\nDebug: failed allocating conversion tables for INFTL.\r\n"));
    return flNotEnoughMemory;
  }

  /* Allocate the multi-sector buffer (one per socket) */
  if (++(multiSectorBufCounter[vol.socketNo]) == 0)
  {
     multiSectorBuf[vol.socketNo] = (byte *)FL_MALLOC(SECTOR_SIZE<<1);
     if (multiSectorBuf[vol.socketNo] == NULL)
     {
        DEBUG_PRINT(("\nDebug: failed allocating multi-sector buffers for INFTL.\r\n"));
        return flNotEnoughMemory;
     }
  }
  return flOK;
}
#else
static FLStatus initTables(Bnand vol,dword ramForUnits)
{
  Sbyte *heapPtr;

  vol.heap = &socketHeap[flSocketNoOf(vol.flash->socket)][ramForUnits];
  heapPtr = vol.heap;
  vol.physicalUnits = (ANANDPhysUnit FAR1*) heapPtr;
  heapPtr += vol.noOfUnits * sizeof(ANANDPhysUnit);
  vol.virtualUnits = (ANANDUnitNo FAR1*) heapPtr;
  heapPtr += vol.noOfVirtualUnits * sizeof(ANANDUnitNo);

  if ((ANAND_HEAP_SIZE < heapPtr - vol.heap) ||
          (ASSUMED_NFTL_UNIT_SIZE > 1L << vol.unitSizeBits))
  {
    DEBUG_PRINT(("\nDebug: not enough memory for INFTL conversion tables.\r\n"));
    return flNotEnoughMemory;
  }
  return flOK;
}
#endif /* FL_MALLOC */


/*----------------------------------------------------------------------*/
/*                    f i r s t I n C h a i n                           */
/*                                                                      */
/* Find first unit in chain.                                            */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Start the search from this unit               */
/*      nextUnit        : Returns the Second unit of the chain.         */
/*                                                                      */
/* Returns:                                                             */
/*      Physical unit number of the last unit in chain.                 */
/*----------------------------------------------------------------------*/

static ANANDUnitNo firstInChain(Bnand vol, ANANDUnitNo unitNo,ANANDUnitNo* nextUnit)
{
  ANANDUnitNo firstVirtualUnitNo, firstReplacementUnitNo,prevVirtualUnitNo;
  ANANDUnitNo nextUnitNo,prevReplacementUnitNo;
  ANANDUnitNo chainBound = 0;
  byte ANAC,NAC,parityPerField;

  if(unitNo==ANAND_NO_UNIT) /* Sanity check */
  {
     if(nextUnit!=NULL)
         *nextUnit=ANAND_NO_UNIT;
     return unitNo;
  }

  /* If this unit is the first of its chain , no need to keep looking */
  if( vol.physicalUnits[unitNo] & FIRST_IN_CHAIN )
  {
     if(nextUnit!=NULL)
        *nextUnit=ANAND_NO_UNIT;
     return unitNo;
  }
  getUnitData(&vol,unitNo,&firstVirtualUnitNo,&firstReplacementUnitNo,&ANAC,&NAC,&parityPerField);
  /* check if unit is valid */
  if(badParityResult(parityPerField))
  {
     DEBUG_PRINT(("\nFirst In chain found bad unit header\r\n"));
     if(nextUnit!=NULL)
        *nextUnit=ANAND_NO_UNIT;
     return ANAND_BAD_CHAIN_UNIT;
  }

  nextUnitNo=unitNo;
  unitNo=firstReplacementUnitNo;
  while( (unitNo < vol.noOfUnits) &&  /* Validate replacement unit no. */
         (chainBound < DOUBLE_MAX_UNIT_CHAIN) )
  {
    if(unitNo==ANAND_NO_UNIT)
       break;
    getUnitData(&vol,unitNo,&prevVirtualUnitNo,&prevReplacementUnitNo,&ANAC,&NAC,&parityPerField);
    /* check if unit is valid */
    if(badParityResult(parityPerField))
    {
       DEBUG_PRINT(("\nFirst In chain found bad unit header\r\n"));
       if(nextUnit!=NULL)
         *nextUnit=ANAND_NO_UNIT;

       return ANAND_BAD_CHAIN_UNIT;
    }

    if(( vol.physicalUnits[unitNo] & FIRST_IN_CHAIN )&&(firstVirtualUnitNo==prevVirtualUnitNo))
    {
       if(nextUnit!=NULL)
         *nextUnit=nextUnitNo;

       return unitNo;
    }

    if( prevVirtualUnitNo != (firstVirtualUnitNo ) )
    {
       /* This one does not belong to the chain */
       if(nextUnit!=NULL)
          *nextUnit=ANAND_NO_UNIT;

       return nextUnitNo;
    }
    nextUnitNo = unitNo;
    unitNo = prevReplacementUnitNo;
    chainBound++;
  }

  return ANAND_BAD_CHAIN_UNIT;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                      w r i t e A n d C h e c k                       */
/*                                                                      */
/* Physicaly write up to 2 sectors on given address and verify.         */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address         : Physical address of the sector to write to    */
/*      fromAddress     : Buffer of data to write                       */
/*      flags           : Write flags (ECC, overwrite etc.)             */
/*      howMany         : Number of sectors to write.                   */
/*                                                                      */
/* Returns:                                                             */
/*      Status          : 0 on success, failed otherwise.               */
/*----------------------------------------------------------------------*/

static FLStatus writeAndCheck(Bnand vol,
        CardAddress address,
        void FAR1 *fromAddress,
        unsigned flags,word howMany)
{
  FLStatus     status;
  register int i;
#ifdef VERIFY_ERASED_SECTOR
  register int noOfDword;
  int j;
#endif /* VERIFY_ERASED_SECTOR */

  /* Toggle verify write flag */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  switch (flVerifyWrite[vol.socketNo][vol.flash->socket->curPartition])
  {
     case FL_OFF:
        if (vol.verifiedSectorNo>vol.curSectorWrite+howMany)
           break;
     case FL_ON:
#ifdef VERIFY_WRITE
        vol.flash->socket->verifyWrite = FL_ON;
#endif /* VERIFY_WRITE */
#ifdef VERIFY_ERASED_SECTOR
        /* Make sure all of the sectors are really free */
        checkStatus(vol.flash->read(vol.flash,address,vol.verifyBuffer,SECTOR_SIZE*howMany,0));
        noOfDword = SECTOR_SIZE/sizeof(dword);
        for(j=0;j<howMany;j++) /* Loop over sectors */
        {
           for(i = 0;i<noOfDword;i++)          /* Loop over sector data */
           {
              if(vol.verifyBuffer[i]!=0xffffffffL)
              {
                markAsIgnored(&vol,address+j*SECTOR_SIZE);
                DEBUG_PRINT(("writeAndCheck : The sector was not erased and is ignored\r\n"));
                return flWriteFault;
              }
           }
        }
#endif /* VERIFY_ERASED_SECTOR */
        break;
     default:
        break;
  }
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

  /* Write sector */
  status = vol.flash->write(vol.flash,address,fromAddress,SECTOR_SIZE*howMany,(word)flags);

#ifdef VERIFY_WRITE
  if(flVerifyWrite[vol.socketNo][vol.flash->socket->curPartition] != FL_ON)
     vol.flash->socket->verifyWrite = FL_OFF;
#endif /* VERIFY_WRITE */

  /* Make sure write succeded and update sector catche */
  if (status == flWriteFault)
  {  /* write failed, ignore this sector */
    DEBUG_PRINT(("writeAndCheck : Write of a sector failed and was marked as ignored\r\n"));

    for(i=0;i<howMany;i++)
    {
       markAsIgnored(&vol,address+i*SECTOR_SIZE);
    }
  }
#ifdef NFTL_CACHE
  else
  {
    for(i=0;i<howMany;i++)
       setSectorFlagsCache(&vol, address+i*SECTOR_SIZE, SECTOR_USED);
  }
#endif /* NFTL_CACHE */

  return status;
}


/*----------------------------------------------------------------------*/
/*                         a s s i g n U n i t                          */
/*                                                                      */
/* Assigns a virtual unit no. to a unit                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      vol              : Pointer identifying drive                    */
/*      unitNo           : Physical unit number                         */
/*      virtualUnitNo    : Virtual unit number to assign                */
/*      ANAC             : Accumulating Number Along Chain              */
/*      NAC              : Number Along Chain.                          */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus assignUnit(Bnand vol, ANANDUnitNo unitNo,
                           ANANDUnitNo virtualUnitNo, byte ANAC,
                           byte NAC)
{
  FLStatus status;

  /* Perpare sector count */
  if((vol.countsValid > virtualUnitNo ) &&       /* Has sector count */
     (vol.virtualUnits[virtualUnitNo] != ANAND_NO_UNIT)) /* Was used */
  {
     vol.physicalUnits[unitNo] = countOf(vol.virtualUnits[virtualUnitNo]);
  }
  else
  {
     vol.physicalUnits[unitNo] = 0;
  }

  /* Vadim for ASAP policy*/
#ifdef ENVIRONMENT_VARS
  if(NAC>=MAX_UNIT_CHAIN)
     NAC=MAX_UNIT_CHAIN-1;
#endif /* ENVIRONMENT_VARS */
  status = setUnitData(&vol,unitNo,virtualUnitNo,(ANANDUnitNo)vol.virtualUnits[virtualUnitNo],(byte)(ANAC+1),(byte)(NAC+1));
  if (status != flOK)
  {
    markUnitBad(&vol,unitNo);
  }
  else
  {
    if(unitNo>vol.noOfUnits)
      return flGeneralFailure;
    vol.virtualUnits[virtualUnitNo]=unitNo;
    if(vol.freeUnits)
       vol.freeUnits--;
  }
  return status;
}


/*----------------------------------------------------------------------*/
/*                         f o r m a t C h a i n                        */
/*                                                                      */
/* Format all the units in a chain. Start from the last one and go      */
/* backwards until unitNo is reached.                                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Format the chain from this unit onwards       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus formatChain(Bnand vol, ANANDUnitNo unitNo)
{
  /* Erase the chain from end to start */
  ANANDUnitNo chainBound;
  ANANDUnitNo unitToErase;
  FLStatus    status;

  for (chainBound=0;; chainBound++)
  {
    /* Find last unit in chain */
    unitToErase = firstInChain(&vol,unitNo,NULL);

    if((unitToErase == ANAND_BAD_CHAIN_UNIT ) ||
       (chainBound  >= DOUBLE_MAX_UNIT_CHAIN)   )
      return flGeneralFailure;

    status = formatUnit(&vol,unitToErase,UNIT_TAILER_OFFSET);
    if(status != flOK)
       return status;

    if (unitToErase == unitNo)
      break;    /* Erased everything */
  }

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                    c r e a t e U n i t C o u n t                     */
/*                                                                      */
/* Count the number of sectors in a unit that hold valid data.          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit number                          */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void createUnitCount(Bnand vol, ANANDUnitNo unitNo)
{
  register int i;
  SectorNo sectorNo;
  ANANDUnitNo physicalUnitNo = vol.virtualUnits[unitNo];
  CardAddress sectorAddress;
  FLBoolean   lastOK; /* Dummy variable */

  if (physicalUnitNo == ANAND_NO_UNIT)
    return;

  /* Get a count of the valid sector in this unit */
  setUnitCount(physicalUnitNo,0);

  sectorNo = (SectorNo)unitNo << vol.sectorsPerUnitBits;
  for (i = 0; i < vol.sectorsPerUnit; i++, sectorNo++)
  {
    sectorAddress = virtual2Physical(&vol,sectorNo,ANAND_UNASSIGNED_ADDRESS,&lastOK);
    /* Do not check for brocken chain. If one exists we will have a */
    /* large sector count , which will delay folding.               */
    if (sectorAddress != ANAND_UNASSIGNED_ADDRESS)
      vol.physicalUnits[physicalUnitNo]++;
  }
}

#if (defined(VERIFY_WRITE) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))

/*----------------------------------------------------------------------*/
/*                        v e r i f y S e c t o r s                     */
/*                                                                      */
/* Verify sectors for power failures simptoms and fix if neccesary.     */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorCount     : No of sectors to verify                       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

FLStatus verifySectors(Bnand vol, dword sectorCount)
{
   FLStatus    status;
   word        unitOffset;
   ANANDUnitNo virUnitNo;
   ANANDUnitNo unitNo;
   dword       curRead;
   CardAddress sectorAddress;
   word        j;
   byte        chainBound,index;
   byte        sectorFlags[2];
   static      FLBoolean  scannedBlocks[MAX_SECTORS_PER_BLOCK];
   byte FAR1*  buffer;

   if (vol.verifiedSectorNo >= vol.virtualSectors)
      return flOK;

   /* Initialize variables */
   buffer      = flReadBackBufferOf(vol.socketNo);

   if(buffer==NULL)
   {
       DEBUG_PRINT(("\nDebug : Can not verify sectors since no buffer was allocated\r\n"));
       return flOK;
   }

   virUnitNo   = (ANANDUnitNo)(vol.verifiedSectorNo >> vol.sectorsPerUnitBits);
   sectorCount = TFFSMIN(vol.virtualSectors - vol.verifiedSectorNo,sectorCount);

   /* Force remapping of internal catched sector */
   vol.flash->socket->remapped = TRUE;
   tffsset(inftlBuffer,0xff,sizeof(inftlBuffer)); /* Useds as FF'S buffer */

   /* Run over required number of virtual sectors */
   for (; sectorCount > 0 ; virUnitNo++ ,sectorCount -= curRead)
   {
      /* Calculate needed number of sector in this unit */
      unitOffset = (word)((vol.verifiedSectorNo & vol.sectorsPerUnitMask) << SECTOR_SIZE_BITS);
      curRead = TFFSMIN(sectorCount,((1UL<<vol.unitSizeBits)-unitOffset)>>SECTOR_SIZE_BITS);
      unitNo  = vol.virtualUnits[virUnitNo];

      if(unitNo == ANAND_NO_UNIT) /* Unit is empty */
      {
         vol.verifiedSectorNo += ((1<<vol.unitSizeBits)-unitOffset)>>SECTOR_SIZE_BITS;
         continue;
      }

      /* Unit is not empty - initialize sector array */
      if(unitOffset==0)
          tffsset(scannedBlocks,FALSE,sizeof(scannedBlocks));

      for(chainBound=0;;chainBound++)
      {   /* Go over the chain from newest unit to oldest */

         if(chainBound!=0) /* Get next unit */
         {
            unitNo = getPrevUnit(&vol,unitNo,virUnitNo);
            if((unitNo == ANAND_BAD_CHAIN_UNIT  ) ||
               (chainBound>=DOUBLE_MAX_UNIT_CHAIN)   )
            {
              DEBUG_PRINT(("\nverifySectors : Bad chain was found\r\n"));
              return flGeneralFailure;
            }
            if(unitNo == ANAND_NO_UNIT)
               break;
         }

         /* Check required sectors of the unit - 2 sectors at a time */
         sectorAddress = unitBaseAddress(vol,unitNo)+unitOffset;
         for (index=0;index<curRead;index+=2)
         {
            /* Read sector flags if needed
             *
             * Note - getSectorFlags routine must not change the inftlBuffer
             */
            if(WasSectorChecked(sectorAddress) == FALSE)
               sectorFlags[0] = getSectorFlags(&vol,sectorAddress);
            if(WasSectorChecked(sectorAddress+SECTOR_SIZE) == FALSE)
               sectorFlags[1] = getSectorFlags(&vol,sectorAddress+SECTOR_SIZE);

            /* Try checking 2 sectors together */
            if((sectorFlags[0]==sectorFlags[1]                      ) &&
               (WasSectorChecked(sectorAddress+SECTOR_SIZE) == FALSE) &&
               (WasSectorChecked(sectorAddress)             == FALSE))
            {
               /* Indenctical sector flags - sectors are checked together */
               switch(sectorFlags[0])
               {
                  case SECTOR_FREE:
                     status = vol.flash->read(vol.flash,sectorAddress,buffer,SECTOR_SIZE<<1,0);
                     if(status != flOK)
                        return status;
                     if (tffscmp(inftlBuffer,buffer,sizeof(inftlBuffer)))
                     {
                        markAsIgnored(&vol,sectorAddress);
                        createUnitCount(&vol,virUnitNo);
                     }
                     if (tffscmp(inftlBuffer,buffer+sizeof(inftlBuffer),sizeof(inftlBuffer)))
                     {
                        markAsIgnored(&vol,sectorAddress+SECTOR_SIZE);
                        createUnitCount(&vol,virUnitNo);
                     }
                     break;
                  case SECTOR_DELETED:
                  case SECTOR_USED:
                     status = vol.flash->read(vol.flash,sectorAddress,buffer,SECTOR_SIZE<<1,EDC);
                     if(status == flDataError)
                     {
                        status = vol.flash->read(vol.flash,sectorAddress,buffer,SECTOR_SIZE,EDC);
                        if(status != flOK)
                        {
                           markAsIgnored(&vol,sectorAddress);
                           status = vol.flash->read(vol.flash,sectorAddress+SECTOR_SIZE,buffer,SECTOR_SIZE,EDC);
                           if(status != flOK)
                           {
                              markAsIgnored(&vol,sectorAddress+SECTOR_SIZE);
                           }
                           else
                           {
                              MarkSectorAsChecked(sectorAddress+SECTOR_SIZE);
                           }
                        }
                        else
                        {
                           MarkSectorAsChecked(sectorAddress);
                           markAsIgnored(&vol,sectorAddress+SECTOR_SIZE);
                        }
                        createUnitCount(&vol,virUnitNo);
                        break;
                     }
                     MarkSectorAsChecked(sectorAddress);
                  default: /* SECTOR_IGNORE */
                     break;
               }/* Flag type case */
               sectorAddress+=SECTOR_SIZE<<1;
            } /* Flags are indentical */
            else /* Check each sectors individualy */
            {
               for(j=0;j<2;j++,sectorAddress+=SECTOR_SIZE)
               {
                  if(WasSectorChecked(sectorAddress) == TRUE)
                     continue;

                  switch(sectorFlags[j])
                  {
                     case SECTOR_FREE:
                        status = vol.flash->read(vol.flash,sectorAddress,buffer,SECTOR_SIZE,0);
                        if(status != flOK)
                           return status;
                        if (tffscmp(inftlBuffer,buffer,sizeof(inftlBuffer)))
                        {
                           markAsIgnored(&vol,sectorAddress);
                           createUnitCount(&vol,virUnitNo);
                        }
                        break;
                     case SECTOR_USED:
                     case SECTOR_DELETED:
                        status = vol.flash->read(vol.flash,sectorAddress,buffer,SECTOR_SIZE,EDC);
                        if(status == flDataError)
                        {
                           markAsIgnored(&vol,sectorAddress);
                           createUnitCount(&vol,virUnitNo);
                        }
                        MarkSectorAsChecked(sectorAddress);
                     default: /* SECTOR_IGNORE || SECTOR_DELETED */
                        break;
                  } /* Flag type */
               } /* Try second sector */
            } /* Flags are NOT indentical */
         } /* Loop over all sector of unit or until required sectors */
      } /* Loop over all units chains */
      vol.verifiedSectorNo+=curRead;
   } /* Loop over all required sectors */
   return flOK;
}


/*----------------------------------------------------------------------*/
/*                        c h e c k V o l u m e                         */
/*                                                                      */
/* Scanthe entire media for partialy written sectors.                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus checkVolume(Bnand vol)
{
   return verifySectors(&vol, 0xffffffffL); /* Force scan of entire media */
}

#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */


/*----------------------------------------------------------------------*/
/*                           f o l d U n i t                            */
/*                                                                      */
/* Copy all the sectors that hold valid data in the chain to the last   */
/* unit of the chain and erase the chain.                               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      virtualUnitNo   : Virtual unit number of the first unit in      */
/*                        chain.                                        */
/*      foldingFlag     : One of the following flags:                   */
/*       FL_NORMAL_FOLDING - Returns fail status if can not fold        */
/*       FL_FORCE_FOLDING  - Force folding even if last sector is used  */
/*       FL_NOT_IN_PLACE   - Fold into a unit with no erase mark        */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus foldUnit(Bnand vol, ANANDUnitNo virtualUnitNo,
                         int foldingFlag)
{
  ANANDUnitNo unitNo = vol.virtualUnits[virtualUnitNo];
  ANANDUnitNo prevUnitNo;
  SectorNo    virtualSectorNo;
  CardAddress targetSectorAddress;
  int         newSectorCount = 0;
  int         i;
  byte        ANAC,NAC,parityPerField;
#ifdef ENVIRONMENT_VARS
  ANANDUnitNo nextUnitNo       = ANAND_NO_UNIT;
  CardAddress firstUnitAddress = ANAND_UNASSIGNED_ADDRESS;
  ANANDUnitNo firstUnit        = ANAND_NO_UNIT;
  FLBoolean   foldFirstOnly    = (flPolicy[vol.socketNo]
                                          [vol.flash->socket->curPartition] ==
                                          FL_COMPLETE_ASAP) ? TRUE : FALSE;
#endif /* ENVIRONMENT_VARS */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  byte        verifyWriteState = flVerifyWrite[vol.socketNo]
                                              [vol.flash->socket->curPartition];
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
  FLBoolean   lastOK;
  byte        chainBound;
  FLStatus    status;
  CardAddress sourceSectorAddress;

  /* Sanity checks */
  if(unitNo>=vol.noOfUnits) /* Empty or INVALID */
  {
     return flGeneralFailure;
  }

  /* Internal statistics */
  vol.unitsFolded++;
  /* Force remapping of internal catched sector */
  vol.flash->socket->remapped = TRUE;
  virtualSectorNo             = (SectorNo)virtualUnitNo << vol.sectorsPerUnitBits;
  targetSectorAddress         = unitBaseAddress(vol,unitNo);

  /* When verify write option is set to FL_OFF a very lazy check of the */
  /* media is done every time a folding operation is issued             */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  if(verifyWriteState == FL_OFF)
  {
     status = verifySectors(&vol,SECTORS_VERIFIED_PER_FOLDING);
     if(status != flOK)
        return status;
     vol.curSectorWrite = virtualSectorNo; /* Store virtual sector Number */
  }
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

  /* When policy is set to FL_COMPLETE_ASAP - folding is performed only on */
  /* the oldest unit, so find oldest unit and store its location           */
#ifdef ENVIRONMENT_VARS
  if(foldFirstOnly == TRUE)
  {
     firstUnit = firstInChain(&vol,unitNo,&nextUnitNo);
     if(firstUnit == ANAND_BAD_CHAIN_UNIT) /* Error going along chain  */
     {
        return flGeneralFailure;
     }
     firstUnitAddress = unitBaseAddress(vol,firstUnit);
  }
#endif

  /* If chain has no valid sectors simply erase it. */
  if((vol.countsValid>virtualUnitNo) && /* Unit valid sectors were counted */
     (countOf(unitNo)==0))              /* No valid sectors in unit chain  */
  {
#ifdef ENVIRONMENT_VARS
     if((foldFirstOnly == TRUE) && (nextUnitNo != ANAND_NO_UNIT))
     {
        /* Erase only first unit of chain */
        vol.physicalUnits[nextUnitNo] = FIRST_IN_CHAIN;
        return formatChain(&vol,firstUnit);
     }
     else
#endif /* ENVIRONMENT_VARS */
     {
        /* Erase chain completely */
        vol.virtualUnits[virtualUnitNo] = ANAND_NO_UNIT;
        return formatChain(&vol,unitNo);
     }
  }

  /* Single unit with valid sectors can not be folded */
  if((vol.physicalUnits[unitNo]&FIRST_IN_CHAIN)==FIRST_IN_CHAIN)
     return flGeneralFailure;

  /***********************************/
  /* Copy all sectors to target unit */
  /***********************************/

  for (i = 0; i < vol.sectorsPerUnit;
#ifdef ENVIRONMENT_VARS
       firstUnitAddress += SECTOR_SIZE,
#endif /* ENVIRONMENT_VARS */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
       vol.curSectorWrite++, /* Update virtual sector Number */
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
       i++, virtualSectorNo++,targetSectorAddress += SECTOR_SIZE)
  {
    lastOK = TRUE; /* Set last sector of chain as valid */
    sourceSectorAddress = virtual2Physical(&vol,virtualSectorNo,ANAND_UNASSIGNED_ADDRESS,&lastOK);

    /* Check if sector is on the target unit. If so on some configuration we */
    /* Verify the content and on some , we just assume the data is fine.     */
    if(sourceSectorAddress == targetSectorAddress)
    {
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
       switch(verifyWriteState)
       {
          case FL_ON:  /* Always verify */
             break;
          case FL_OFF: /* Verify only if area was not scanned yet */
             if(virtualSectorNo >= vol.verifiedSectorNo)
                break;
          default: /* FL_UPS - Never verify */
             newSectorCount++;
             continue;
       }
#else
       newSectorCount++;
       continue;
#endif /* VERIFY WRITE */
    }

    /* Read sector - Loop down the chain as long as there is an EDC error */
    /* or infinit loop chain (chain bound)                                */
    for (chainBound=0 ; (sourceSectorAddress != ANAND_UNASSIGNED_ADDRESS) ; chainBound++)
    {
       if(sourceSectorAddress == ANAND_BAD_CHAIN_ADDRESS) /* Could not follow chain */
          return flGeneralFailure;

       status = vol.flash->read(vol.flash,sourceSectorAddress,
                               inftlBuffer,SECTOR_SIZE,EDC);
       if (status != flOK)
       {
          if (status == flDataError)
          {
             DEBUG_PRINT(("foldUnit : EDC error on folding\r\n"));
             if (chainBound >= MAX_UNIT_CHAIN)
                return status;
             sourceSectorAddress = virtual2Physical(&vol,virtualSectorNo,sourceSectorAddress,&lastOK);
             continue;
          }
          else
          {
             return status;
          }
       }
       break;
    } /* chain bound EDC error loop */

    if (sourceSectorAddress == ANAND_UNASSIGNED_ADDRESS) /* Sector not found */
       continue;

    newSectorCount++;
    if (sourceSectorAddress == targetSectorAddress) /* Sector already exists */
       continue;

    /* Try and copy the relevant sector */

#ifdef ENVIRONMENT_VARS
    /* On FL_COMPLETE_ASAP copy sector only if it is on the first unit */
    if((flPolicy[vol.socketNo][vol.flash->socket->curPartition]==FL_COMPLETE_ASAP) &&
       (sourceSectorAddress!=firstUnitAddress))
       continue;
#endif /* ENVIRONMENT_VARS */

    if ((lastOK == FALSE) && (foldingFlag == FL_NORMAL_FOLDING))
    {
       /* Last sector of the chain is already used */
       return flCanNotFold;
    }
    status = writeAndCheck(&vol,targetSectorAddress,inftlBuffer,EDC,1);
    vol.parasiteWrites++;

    /* On EDC error assume previous sector is empty */

    switch (status)
    {
       case flOK:         /* Success */
          break;

       case flWriteFault: /* Faild in verify write */
          if (foldingFlag == FL_NORMAL_FOLDING)
          {
             DEBUG_PRINT(("foldUnit : Failed to write a sector while folding but will not force folding\r\n"));
             return flCanNotFold;
          }
          break;

       default :          /* Protection error or any other */
          return status;
    }
  } /* Sector copy loop */

  /***************************************************************/
  /* After all sectors have been copied , erase the unused units */
  /***************************************************************/

  if(foldingFlag == FL_NOT_IN_PLACE) /* Add erase mark to validate unit */
  {
      word  eraseMark;
      dword eraseCount;

      checkStatus(getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount,UNIT_TAILER_OFFSET_2));
      checkStatus(setUnitTailer(&vol,unitNo,eraseMark,eraseCount,UNIT_TAILER_OFFSET));
  }

  if (newSectorCount > 0)  /* Some sectors remaining*/
  {
    /* Set target unit in physical unit table as first in chain */
    status = getUnitData(&vol,unitNo,&virtualUnitNo, &prevUnitNo,&ANAC,&NAC,&parityPerField);
    if(status != flOK)
       return status;
    /* check if unit is valid */
    if(badParityResult(parityPerField))
       return flGeneralFailure;
#ifdef ENVIRONMENT_VARS
    /* Erase only oldest unit */
    if(flPolicy[vol.socketNo][vol.flash->socket->curPartition]==FL_COMPLETE_ASAP)
    {
       vol.physicalUnits[nextUnitNo] |= FIRST_IN_CHAIN;
       return formatUnit(&vol, firstUnit,UNIT_TAILER_OFFSET);
    }
    else
#endif
    {
       vol.physicalUnits[unitNo]     |= FIRST_IN_CHAIN;
       unitNo=prevUnitNo; /* erase all units in chain but the last one */
    }
  }
  else
  {
    /* Erase chain completely */
    vol.virtualUnits[virtualUnitNo] = ANAND_NO_UNIT;
  }

  /* Erase source units */
  return formatChain(&vol,unitNo);
}


/*----------------------------------------------------------------------*/
/*                           f o l d B e s t C h a i n                  */
/*                                                                      */
/* Find the best chain to fold and fold it.A good chain to fold is a    */
/* long chain with a small number of sectors that hold valid data.      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Receives the physical unit no. of the first   */
/*                        unit in the chain that was folded.            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus foldBestChain(Bnand vol, ANANDUnitNo *unitNo)
{
  word        leastCount, longestChain, unitCount;
  ANANDUnitNo u, firstUnitNo, newVirtualUnitNo, prevUnitNo;
  ANANDUnitNo virtualUnitNo;
  ANANDUnitNo frozenCandidate  = ANAND_NO_UNIT;
  ANANDUnitNo lazyMountCounter = 0;
  ANANDUnitNo newestUnit;
  FLStatus    status           = flOK;
  byte        NAC,ANAC,parityPerField;
  int         foldingTries;

  /* Will exit when no more units are available or up to 10 times */
  for (*unitNo = ANAND_NO_UNIT,foldingTries = 0 ;
       foldingTries < MAX_FOLDING_LOOP ; foldingTries++)
  {
     /*********************************************/
     /* Pick unit to fold using huristic function */
     /*********************************************/

     virtualUnitNo = ANAND_NO_UNIT;
     longestChain  = 1; /* Minimal chain length to fold == 1 */
     leastCount    = vol.sectorsPerUnit+1;

     for (u = 0; u < vol.noOfVirtualUnits; u++)
     {
        firstUnitNo = vol.virtualUnits[u];
        if(firstUnitNo == ANAND_NO_UNIT) /* Free unit */
           continue;

        if( !(isAvailable(firstUnitNo)) )
        {
           /* Do not attempt to fold frozen unit.                   */
           /* They will become unfrozen by the end of this routine. */
           frozenCandidate = u; /* Remember for forced folding */
           DEBUG_PRINT(("FoldBestChains : Skiped unavailable unit\r\n"));
           continue;
        }

        /* Lazy mount - Make sure unit has a valid sector count */
        if (vol.countsValid <= u)
        {
           if(lazyMountCounter>=MAX_CREATE_UNIT_COUNT)
           {
              /* If lazy mount takes too long , try and shorten it. */
              if(virtualUnitNo!=ANAND_NO_UNIT)
                 break;
           }
           createUnitCount(&vol,u);
           lazyMountCounter++;
           vol.countsValid = u + 1;
        }

        unitCount = countOf(firstUnitNo); /* No of valid sectors */

        /* If empty unit, use it. */
        if(unitCount==0)
        {
           leastCount    = unitCount; /* Store minimal sector count */
           virtualUnitNo = u;         /* Store virtual unit number  */
           break;
        }

        if ((leastCount < unitCount) ||            /* Already found a better unit */
            (vol.physicalUnits[firstUnitNo] & FIRST_IN_CHAIN)) /* 1 unit in chain */
            continue;

        /* Sector count is smaller or equal now check chains length */
        status = getUnitData(&vol,firstUnitNo,&newVirtualUnitNo, &prevUnitNo,&ANAC,&NAC,&parityPerField);
        if(status != flOK)
           return status;
        /* check if unit is valid */
        if((badParityResult(parityPerField)) || (newVirtualUnitNo != u))
           return flGeneralFailure;

        if((leastCount == unitCount) &&   /* If sector count is equal */
           (longestChain >= NAC)        ) /* Use chain length         */
           continue;

        /* If we reached here the current unit is the best so far */
        longestChain   = NAC;       /* Store maximal chain length */
        leastCount     = unitCount; /* Store minimal sector count */
        virtualUnitNo  = u;         /* Store virtual unit number  */
     } /* End of unit huristic loop */

     /****************************************/
     /* Try folding the unit that was picked */
     /****************************************/

     if (virtualUnitNo != ANAND_NO_UNIT) /* Found a chain (more then 1 unit) */
     {

        *unitNo = firstInChain(&vol,vol.virtualUnits[virtualUnitNo],NULL);
        if(*unitNo==ANAND_BAD_CHAIN_UNIT)
           return flGeneralFailure;

        status = foldUnit(&vol,virtualUnitNo,FL_NORMAL_FOLDING);
        switch(status)
        {
           case flOK:
              /* Try to make sure that there are at least 2 free units */
              if(pVol->freeUnits < 2)
              {
                 DEBUG_PRINT(("foldBestChains : Folding success, but need more units.\r\n"));
                 continue;
              }
              break;
           case flCanNotFold:
              DEBUG_PRINT(("foldBestChains : Failed folding, mark as unavailable and try folding another\r\n"));
              setUnavail(vol.virtualUnits[virtualUnitNo]);
              *unitNo = ANAND_NO_UNIT;
              continue;
           default:
              DEBUG_PRINT(("foldBestChains : ERROR - Failed folding, with status diffrent then flCanNotFold.\r\n"));
              return status;
    }
     }
     else /* All remaining chains have single unit */
     {

        if (frozenCandidate == ANAND_NO_UNIT) /* Simply no chain larger then 1 */
        {
            if(*unitNo == ANAND_NO_UNIT) /* Not even 1 unit was folded */
            {
               DEBUG_PRINT(("foldBestChains : Failed - not enough units on flash.\r\n"));
               return flNotEnoughMemory;
            }
            else /* Aleady freed one unit - simply tried to get */
            {
               return flOK;
            }
        }
     }
     break;
  } /* End folding tries loop */

  /**************************************************************/
  /* Unfreeze all frozen units , and fold them using freed unit */
  /**************************************************************/

  if (frozenCandidate != ANAND_NO_UNIT) /* At least one unit was frozen */
  {
     DEBUG_PRINT(("foldBestChains : Found a frozen unit.\r\n"));
     /* find free unit to be appended */
     if(*unitNo==ANAND_NO_UNIT) /* No unit was folded */
     {
        DEBUG_PRINT(("foldBestChains : No free unit was found so far, so search for one.\r\n"));

    if(vol.freeUnits) /* There are free units */
    {
       ANANDUnitNo originalUnit = vol.roverUnit;
           do
           {
               if (++vol.roverUnit >= vol.noOfUnits)
                  vol.roverUnit = 0;

               if (vol.physicalUnits[vol.roverUnit] == ANAND_UNIT_FREE)
               { /* found a free unit, if not erased, */
                  if (formatUnit(&vol,vol.roverUnit,UNIT_TAILER_OFFSET_2) != flOK)
                     continue;   /* this unit is bad, find another */

                  *unitNo = vol.roverUnit;
                  DEBUG_PRINT(("foldBestChains : Found a free unit for folding not in place.\r\n"));
                  break;
               }
           }while (vol.roverUnit != originalUnit);
        }
    if(*unitNo==ANAND_NO_UNIT) /* No unit was found */
    {
           /* Force folding of the last frozen unit - Loose data */
           DEBUG_PRINT(("foldBestChains : Will force folding on Frozen candidate\r\n"));
           *unitNo = firstInChain(&vol,vol.virtualUnits[frozenCandidate],NULL);
           if(*unitNo==ANAND_BAD_CHAIN_UNIT)
              return flGeneralFailure;
           createUnitCount(&vol,frozenCandidate);
           status = foldUnit(&vol,frozenCandidate,FL_FORCE_FOLDING);
           if(status!= flOK)
              return status;
    }
     }

     for (u=0 ; u < vol.noOfVirtualUnits ; u++) /* Loop over units and unfreeze */
     {
        if(vol.virtualUnits[u] == ANAND_NO_UNIT)
           continue;
        if(isAvailable(vol.virtualUnits[u]))
           continue;
        createUnitCount(&vol,u);
        DEBUG_PRINT(("foldBestChains : Now free all frozen units.\r\n"));
        /* If unit is unavailable append newly found unit to chain and fold */
        checkStatus(getUnitData(&vol,vol.virtualUnits[u],&newVirtualUnitNo, &prevUnitNo,&ANAC,&NAC,&parityPerField));
        /* check if unit is valid */
        if((badParityResult(parityPerField)) || (newVirtualUnitNo != u))
           return flGeneralFailure;
        /* Remember the appended unit */
        newestUnit = *unitNo;
    /* Remember oldest unit to return as new allocated unit */
        *unitNo = firstInChain(&vol,vol.virtualUnits[u],NULL);
    /* Erase the erase mark and move erase count to offset 6K */
        checkStatus(formatUnit(&vol,newestUnit,UNIT_TAILER_OFFSET_2));
        checkStatus(assignUnit(&vol,newestUnit,u,ANAC,NAC));
        status = foldUnit(&vol,u,FL_NOT_IN_PLACE);
        if(status != flOK)
          return status;
     }
  }
  return flOK;
}


/*----------------------------------------------------------------------*/
/*                           a l l o c a t e U n i t                    */
/*                                                                      */
/* Find a free unit to allocate, erase it if necessary.                 */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Receives the physical number of the allocated */
/*                        unit                                          */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus allocateUnit(Bnand vol, ANANDUnitNo *unitNo)
{
  ANANDUnitNo originalUnit = vol.roverUnit;
  FLStatus    status;
  dword       eraseCount;
  word        eraseMark;

  if (vol.freeUnits < 2)
  {
      status = foldBestChain(&vol,unitNo);  /* make free units by folding the best chain */
      if(status != flNotEnoughMemory)
          return status;

      DEBUG_PRINT(("Debug: Using last free unit of the media.\r\n"));
  }

  do
  {
    if (++vol.roverUnit >= vol.noOfUnits)
       vol.roverUnit = 0;

    if (vol.physicalUnits[vol.roverUnit] == ANAND_UNIT_FREE)
    { /* found a free unit, if not erased, */

       status = getUnitTailer(&vol,vol.roverUnit,&eraseMark,&eraseCount,UNIT_TAILER_OFFSET);
       if(status != flOK)
          return status;
       if (eraseMark != ERASE_MARK)
       {
          if (formatUnit(&vol,vol.roverUnit,UNIT_TAILER_OFFSET) != flOK)
             continue;   /* this unit is bad, find another */
       }
       *unitNo = vol.roverUnit;
       return flOK;
    }
  } while (vol.roverUnit != originalUnit);

  return foldBestChain(&vol,unitNo);  /* make free units by folding the best chain */
}


/*----------------------------------------------------------------------*/
/*                       c h e c k F o l d i n g                        */
/*                                                                      */
/* Check and complete a failed folding operation.                       */
/*                                                                      */
/* Parameters:                                                          */
/*      foldStatus      : Pointer identifying drive                     */
/*      virtualUnitNo   : Virtual unit number of the first unit in      */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus checkFolding(Bnand vol,FLStatus foldStatus,ANANDUnitNo virtualUnitNo)
{
   ANANDUnitNo newVirtualUnitNo, prevUnitNo , dummyUnitNo;
   byte ANAC,NAC,parityPerField;

   if(foldStatus == flCanNotFold)
   {
      DEBUG_PRINT(("checkFolding : Perform folding not in place\r\n"));

      /* Get a new unit for extending the virtual unit */
      checkStatus(allocateUnit(&vol,&dummyUnitNo));
      checkStatus(getUnitData(&vol,vol.virtualUnits[virtualUnitNo],&newVirtualUnitNo,
                              &prevUnitNo,&ANAC,&NAC,&parityPerField));
      if((newVirtualUnitNo!=virtualUnitNo)||
         (badParityResult(parityPerField)))
      {
         return flGeneralFailure;
      }

#ifdef ENVIRONMENT_VARS
      /* Prepare NAC */
      if(NAC>=MAX_UNIT_CHAIN)
         NAC=MAX_UNIT_CHAIN-1;
#endif /* ENVIRONMENT_VARS */
      checkStatus(assignUnit(&vol,dummyUnitNo,virtualUnitNo,ANAC,NAC));
      foldStatus = foldUnit(&vol,virtualUnitNo,FL_FORCE_FOLDING);
   }
   return foldStatus;
}


/*----------------------------------------------------------------------*/
/*                  a p p l y W e a r l e v e l i n g                   */
/*                                                                      */
/* Try to extend the current vurtial chain in order to force static     */
/* files wear leveling.                                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus applyWearleveling(Bnand vol)
{
  ANANDUnitNo replacementUnitNo,newVirtualUnitNo;
  ANANDUnitNo startUnit,curUnit;
  FLStatus    status;
  byte        NAC,ANAC,parityPerField;

  /* Increament wear leveling counter */
  vol.wearLevel.currUnit++;
  if(vol.wearLevel.currUnit>=vol.noOfVirtualUnits)
    vol.wearLevel.currUnit=0;

  /****************************************************/
  /* Searching for a candidate virtual unit to extend */
  /****************************************************/

  startUnit = vol.wearLevel.currUnit;
  for(curUnit = startUnit ;
      vol.virtualUnits[curUnit] == ANAND_NO_UNIT;curUnit++)
  {
    if(curUnit>=vol.noOfVirtualUnits)
      curUnit = 0;
    if(startUnit == curUnit)
      break;
  }

  if(startUnit == curUnit) /* the media is empty*/
  {
     return flOK;
  }

  vol.wearLevel.currUnit = curUnit; /* Store last leveld unit */

  /***************************************************************************/
  /* Now fold the virtual chain. (if a single unit chain add before folding) */
  /***************************************************************************/

  if(vol.physicalUnits[vol.virtualUnits[curUnit]] & FIRST_IN_CHAIN) /* chain is 1 unit long */
  {
      /* This is a one unit chain, so we have to add a unit before folding */

     status = allocateUnit(&vol,&replacementUnitNo); /* Find unit to append */
     if(status != flOK)
        return status;

     if(vol.virtualUnits[curUnit] == ANAND_NO_UNIT)
     {
         /* We did folding for the very same unit and now virtual unit is FREE */
         vol.freeUnits--;
         return flOK;
     }

     /* Get previous unit information (ANAC and NAC) */
     status = getUnitData(&vol,vol.virtualUnits[curUnit],&newVirtualUnitNo, &replacementUnitNo,
                          &ANAC,&NAC,&parityPerField);
     if(status != flOK)
        return status;

     if(badParityResult(parityPerField)) /* check if unit is valid */
        return flGeneralFailure;

     if(newVirtualUnitNo != curUnit) /* Problem with RAM tables */
     {
        return flGeneralFailure;
     }

     status = assignUnit(&vol,replacementUnitNo,curUnit,ANAC,NAC);
     if(status != flOK)
        return status;
  }
  /* Perform folding and verify operation */
  status = foldUnit(&vol,curUnit,FL_NORMAL_FOLDING);
  if (status != flOK)
    return checkFolding(&vol,status,curUnit);
  return flOK;
}

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                           m a p S e c t o r                          */
/*                                                                      */
/* Maps and returns location of a given sector no.                      */
/* NOTE: This function is used in place of a read-sector operation.     */
/*                                                                      */
/* A one-sector cache is maintained to save on map operations.          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Sector no. to read                            */
/*      physAddress     : Optional pointer to receive sector address    */
/*                                                                      */
/* Returns:                                                             */
/*      Pointer to physical sector location. NULL returned if sector    */
/*      does not exist.                                                 */
/*----------------------------------------------------------------------*/

static const void FAR0 *mapSector(Bnand vol, SectorNo sectorNo, CardAddress *physAddress)
{
  FLStatus  status;
  FLBoolean lastOK; /* Dummy variable */
  byte      chainBound;

  if ((sectorNo != vol.mappedSectorNo) ||
      (vol.flash->socket->remapped)    ||
      (vol.buffer->owner == &vol)        )
  {
    vol.flash->socket->remapped = TRUE;
    vol.mappedSector            = NULL;
    vol.mappedSectorAddress     = ANAND_UNASSIGNED_ADDRESS;
    if (sectorNo < vol.virtualSectors) /* While EDC error on sector read */
    {
      for (chainBound=0 ; (chainBound < DOUBLE_MAX_UNIT_CHAIN) ; chainBound++)
      {
         vol.mappedSectorAddress = virtual2Physical(&vol,sectorNo,vol.mappedSectorAddress,&lastOK);
         switch(vol.mappedSectorAddress)
         {
            case ANAND_UNASSIGNED_ADDRESS:
            case ANAND_BAD_CHAIN_ADDRESS:
               vol.mappedSector = NULL;        /* no such sector */
               break;

            default:
               vol.mappedSector = inftlBuffer;
               status = vol.flash->read(vol.flash,vol.mappedSectorAddress,inftlBuffer,SECTOR_SIZE,EDC);
               if (status == flOK)
                  break;
               if (status != flDataError)
                  return dataErrorToken;
               continue;
         }
         break;
      }
      if (chainBound >= DOUBLE_MAX_UNIT_CHAIN)
        return dataErrorToken;

      /* Store sector for next mapping operation */
      vol.mappedSectorNo = sectorNo;       /* Sector number */
      vol.buffer->owner  = &vol;           /* Partition     */
      vol.flash->socket->remapped = FALSE; /* Valid         */
    }
  }

  if (physAddress)
    *physAddress = vol.mappedSectorAddress;

  return vol.mappedSector;
}


/*----------------------------------------------------------------------*/
/*                           r e a d 2 S e c t o r s                    */
/*                                                                      */
/* read content of a set of consecutive sectors.                        */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Sector no. to read                            */
/*      dest            : pointer to buffer to read                     */
/*      sectorCount     : # of sectors to read ( up to 2 )              */
/*                                                                      */
/* Returns:                                                             */
/*      status of the read operaton                                     */
/*----------------------------------------------------------------------*/

static FLStatus read2Sectors(Bnand vol, SectorNo sectorNo, byte FAR1 *dest,
                             SectorNo sectorCount)

{
  CardAddress mappedSectorAddress[2];
  FLStatus status    = flOK;
  FLStatus retStatus = flOK;
  word i;
  byte chainBound;
  FLBoolean lastOK; /* Dummy variable */

  if ((sectorNo+sectorCount-1) >= vol.virtualSectors)
  {
     return flSectorNotFound; /* Out of bounds */
  }
  else
  {
     /* find physical location of the 2 sectors */
     for(i=0;i<sectorCount;i++)
     {
        mappedSectorAddress[i] = virtual2Physical(&vol,sectorNo+i,
                                 ANAND_UNASSIGNED_ADDRESS,&lastOK);
        /* If chain is brocken report sector not found */
        if(mappedSectorAddress[i] == ANAND_BAD_CHAIN_ADDRESS)
           mappedSectorAddress[i] = ANAND_UNASSIGNED_ADDRESS;
     }

     /* When possible read the 2 sectors together */
     if((sectorCount==2)&&
        ( mappedSectorAddress[1] > mappedSectorAddress[0]              ) &&
        ((mappedSectorAddress[1] - mappedSectorAddress[0])==SECTOR_SIZE) &&
        ( mappedSectorAddress[0] != ANAND_UNASSIGNED_ADDRESS           ) &&
        ( mappedSectorAddress[1] != ANAND_UNASSIGNED_ADDRESS           ))
     {
        if (vol.flash->read(vol.flash,mappedSectorAddress[0],
            dest,SECTOR_SIZE<<1,EDC) == flOK)
        {
           vol.sectorsRead+=2;
           return flOK;
        }
     }

     /* Sectors are not together */
     for (i=0;i<sectorCount;i++,dest = (byte FAR1 *)flAddLongToFarPointer(dest,SECTOR_SIZE))
     {
        /* While EDC error on sector read - keep reading from older unit */
        for (chainBound=0 ; (chainBound < DOUBLE_MAX_UNIT_CHAIN) ; chainBound++)
        {
           if (mappedSectorAddress[i] == ANAND_UNASSIGNED_ADDRESS)
           {
              tffsset(dest,0,SECTOR_SIZE);
              retStatus = flSectorNotFound;
              break;
           }
           else
           {
              status=vol.flash->read(vol.flash,mappedSectorAddress[i],
                                    dest,SECTOR_SIZE,EDC);
              vol.sectorsRead++;
              if (status == flOK)
              {
                 break;
              }
              else if (status == flDataError)
              {
                 mappedSectorAddress[i] = virtual2Physical(&vol,sectorNo+i,mappedSectorAddress[i],&lastOK);
                 /* If chain is brocken report sector not found */
                 if(mappedSectorAddress[i]==ANAND_BAD_CHAIN_ADDRESS)
                    mappedSectorAddress[i] = ANAND_UNASSIGNED_ADDRESS;
              }
              else
              {
                 return status;
              }
           }
        }
        if (chainBound >= DOUBLE_MAX_UNIT_CHAIN)
           return status;
     }
  }
  return retStatus;
}


/*----------------------------------------------------------------------*/
/*                      r e a d S e c t o r s                           */
/*                                                                      */
/* Read content of a set of consecutive sectors.                        */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*      sectorNo       : Sector no. to read                             */
/*      dest           : pointer to buffer to read                      */
/*      sectorCount    : # of sectors to read                           */
/*                                                                      */
/* Returns:                                                             */
/*      status of the read operaton                                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus readSectors(Bnand vol, SectorNo sectorNo, void FAR1 *dest,
                     SectorNo sectorCount)
{
  byte FAR1* curDest;
  SectorNo   lastSector = 0;
  FLStatus   retStatus  = flOK;
  FLStatus   status;
  SectorNo   i;

#ifdef SCATTER_GATHER
  curDest = *(byte FAR1 **)dest;
#else
  curDest = (byte FAR1 *)dest;
#endif /* SCATTER_GATHER */

  if ((sectorNo+sectorCount) > vol.virtualSectors)
  {
     return flSectorNotFound; /* Out of bounds */
  }

 /****************************************************************/
 /*   Read first sector if it's only one or it has odd address   */
 /****************************************************************/
   if(((sectorNo & 1)!=0)||(sectorCount==1))
   {
      status=read2Sectors(&vol, sectorNo, curDest,1);
      if (status != flOK)
      {
         if (status == flSectorNotFound)
         {
            retStatus = flSectorNotFound;
         }
         else
         {
            return status;
         }
      }
      if(sectorCount==1)
         return status;
      sectorNo++;
      sectorCount--;
#ifdef SCATTER_GATHER
      dest = (byte FAR1 **)dest+1;
#else
      dest = flAddLongToFarPointer(dest,SECTOR_SIZE);
#endif /* SCATTER_GATHER */
   }

   if(((sectorNo+sectorCount-1) & 1)==0)   /* keep last sector if it has odd address*/
      lastSector=sectorNo+sectorCount-1;

 /*****************************************/
 /*   Read pairs of consequtive sectors   */
 /*****************************************/

#ifdef SCATTER_GATHER
   curDest = multiSectorBuf[vol.socketNo];
#else
   curDest = (byte FAR1 *)dest;
#endif /* SCATTER_GATHER */

   for(i=0;i<((sectorCount>>1)<<1);i+=2) /* read pair of sectors*/
   {
      status=read2Sectors(&vol,sectorNo+i, curDest,2);
      if (status != flOK)
      {
         if (status == flSectorNotFound)
         {
            retStatus = flSectorNotFound;
         }
         else
         {
            return status;
         }
      }
#ifdef SCATTER_GATHER
      /* copy from temporary buffer to user scattered buffers */
      tffscpy(*(byte FAR1 **)dest,curDest,SECTOR_SIZE);
      tffscpy(*((byte FAR1 **)dest+1),&(curDest[SECTOR_SIZE]),SECTOR_SIZE);
      dest = (byte FAR1 **)dest+2;
#else
      curDest=(byte FAR1 *)flAddLongToFarPointer(curDest,(SECTOR_SIZE<<1));
#endif /* SCATTER_GATHER */
   }

 /********************************/
 /*   Read last uneven sectors   */
 /********************************/

#ifdef SCATTER_GATHER
   curDest = *(byte FAR1 **)dest;
#endif /* SCATTER_GATHER */

   if(lastSector!=0)          /*  read last sector */
   {
      checkStatus(read2Sectors(&vol,lastSector, curDest,1));
   }
   return retStatus;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                   a l l o c a t e A n d W r i t e S e c t o r s      */
/*                                                                      */
/* Write to sectorNo. if necessary, allocate a free sector first.       */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Virtual sector no. to write                   */
/*      fromAddress     : Address of sector data.                       */
/*      howMany         : Number of sectors to write.                   */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus allocateAndWriteSectors(Bnand vol,
             SectorNo sectorNo,
             void FAR1 *fromAddress,word howMany)
{
  ANANDUnitNo newVirtualUnitNo, newPrevUnitNo;
  ANANDUnitNo virtualUnitNo = (ANANDUnitNo)(sectorNo >> vol.sectorsPerUnitBits);
  ANANDUnitNo lastUnitNo = vol.virtualUnits[virtualUnitNo];
  ANANDUnitNo unitNo,prevUnitNo;
  FLStatus    status;
  byte ANAC,NAC,parityPerField;
  word unitOffset = (word)((sectorNo & vol.sectorsPerUnitMask) << SECTOR_SIZE_BITS);
  word chainBound = 0;
  word foundSoFar = 0;
  word newSect = howMany;
  byte sectorFlags;
  FLBoolean firstUnitFound     = FALSE;
  FLBoolean secondUnitFound    = FALSE;
  FLBoolean noneFreeFound      = FALSE;
  ANANDUnitNo commonPrevUnitNo = ANAND_NO_UNIT;
  ANANDUnitNo commonUnitNo     = lastUnitNo;

  /************************************/
  /* Find a unit to write this sector */
  /************************************/

  unitNo     = lastUnitNo;    /* newest unit that either sectors is not FREE */
  prevUnitNo = ANAND_NO_UNIT; /* oldest unit with place for required sectors */

  while (unitNo != ANAND_NO_UNIT)
  {
     if(firstUnitFound == FALSE)
     {
        sectorFlags = getSectorFlags(&vol,unitBaseAddress(vol,unitNo) + unitOffset);

        switch(sectorFlags)
        {
           case SECTOR_USED:
              newSect--; /* Sector exists - do not increament counter */
           case SECTOR_DELETED:
              foundSoFar++;
              firstUnitFound = TRUE;
           case SECTOR_IGNORE:
              if(noneFreeFound == FALSE) /* Store none free space */
              {
                 commonPrevUnitNo = prevUnitNo;
                 commonUnitNo     = unitNo;
                 noneFreeFound    = TRUE;
              }
           default:
              break;
        }
     }
     if(howMany==2)
     {
        if(secondUnitFound == FALSE)
        {
           sectorFlags = getSectorFlags(&vol,unitBaseAddress(vol,unitNo) + unitOffset+512);

           switch(sectorFlags)
           {
              case SECTOR_USED:
                 newSect--; /* Sector exists - do not increament counter */
              case SECTOR_DELETED:
                 foundSoFar++;
                 secondUnitFound = TRUE;
              case SECTOR_IGNORE:
                 if(noneFreeFound == FALSE) /* Store none free space */
                 {
                    commonPrevUnitNo = prevUnitNo;
                    commonUnitNo     = unitNo;
                    noneFreeFound    = TRUE;
                 }
              default:
                 break;
           }
        }
     }

     if(foundSoFar == howMany) /* Both sectors have been found */
        break;

     /* Both sectors are FREE */
     prevUnitNo = unitNo;
     unitNo     = getPrevUnit(&vol,unitNo,virtualUnitNo);
     if(unitNo == ANAND_BAD_CHAIN_UNIT)
        return flGeneralFailure;
     chainBound++;
     if(chainBound >= DOUBLE_MAX_UNIT_CHAIN)
        return flGeneralFailure;
  } /* End of - go over chain while */
  if(noneFreeFound == TRUE)
  {
    prevUnitNo = commonPrevUnitNo; /* Common free unit for both sectors  */
    unitNo     = commonUnitNo;     /* First unit with wither used sector */
  }

  if ((prevUnitNo == ANAND_NO_UNIT)) /* No place to write sectors */
  {
    if(unitNo!=ANAND_NO_UNIT) /* Unit already exists */
    {
       status = getUnitData(&vol,unitNo,&newVirtualUnitNo, &newPrevUnitNo,&ANAC,&NAC,&parityPerField);
       if (status != flOK)
          return status;

       if(badParityResult(parityPerField)) /* check if unit is valid */
          return flGeneralFailure;

       /* Check if chain length is graeter then allowed, but remember  */
       /* that the first unit of the chain has invalid NAC.            */
       if ((NAC>=MAX_UNIT_CHAIN) &&
           ((vol.physicalUnits[unitNo]&FIRST_IN_CHAIN)!=FIRST_IN_CHAIN))
       {
          status = foldUnit(&vol,virtualUnitNo,FL_NORMAL_FOLDING);
          if (status != flOK)
          {
             status = checkFolding(&vol,status,virtualUnitNo);
             if (status != flOK)
                return status;
          }
       }
    }
    status = allocateUnit(&vol,&prevUnitNo);
    if (status != flOK)
       return status;

    unitNo = vol.virtualUnits[virtualUnitNo];

    if(unitNo==ANAND_NO_UNIT) /* Free virtual unit */
    {
       /* New Virtual unit. reinitialize NAC,ANAC and sector count */
       ANAC=NAC=0;
       /* Force FIRST_IN_CHAIN and sector count to 0. it must be done */
       /* after assignUnit, so that assign unit will not change it.   */
       unitNo=ANAND_NO_UNIT;
    }
    else /* Read unit data to set ANAC , NAC and sector count */
    {
       status = getUnitData(&vol,unitNo,&newVirtualUnitNo, &newPrevUnitNo,
                            &ANAC,&NAC,&parityPerField);
       if (status != flOK)
          return status;

       /* Check if unit is valid */
       if((badParityResult(parityPerField)) || /* Bad unit data       */
          (newVirtualUnitNo!=virtualUnitNo))   /* Bad virtual unit no */
          return flGeneralFailure;

       if(vol.physicalUnits[unitNo]&FIRST_IN_CHAIN)
          NAC=1;
    }

    status = assignUnit(&vol,prevUnitNo,virtualUnitNo,ANAC,NAC);
    if (status != flOK)
       return status;

    if(unitNo==ANAND_NO_UNIT) /* First physical unit of chain */
    {
       vol.physicalUnits[prevUnitNo]=FIRST_IN_CHAIN;
    }
    lastUnitNo = vol.virtualUnits[virtualUnitNo];
    unitNo=prevUnitNo;
  }
  else
  {
    unitNo=prevUnitNo;
  }

  /***********************************************/
  /* Area has been allocated , now write sectors */
  /***********************************************/

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  vol.curSectorWrite = sectorNo; /* Store virtual sector Number */
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

  status = writeAndCheck(&vol,unitBaseAddress(vol,unitNo) + unitOffset,fromAddress,EDC,howMany);
  if (status != flOK)
     return status;

  /* Take care of sector count */
  if (vol.countsValid > virtualUnitNo)
  {
    lastUnitNo=vol.virtualUnits[virtualUnitNo];

    if (countOf(lastUnitNo) + newSect <= UNIT_MAX_COUNT)
    {
       vol.physicalUnits[lastUnitNo]+=newSect; /* Increment block count */
    }
    else /* Should never happen , but sector count is not correct */
    {
       return flGeneralFailure;
    }
  }
  return flOK;
}


/*----------------------------------------------------------------------*/
/*                        w r i t e 2 S e c t o r s                     */
/*                                                                      */
/* Writes up to 2 consecutive sector.                                   */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Virtual sector no. to write                   */
/*      fromAddress     : Data to write                                 */
/*      sectorCount     : No of sectors to write                        */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus write2Sectors(Bnand vol, SectorNo sectorNo,
                              void FAR1 *fromAddress,word sectorCount)
{
  FLStatus status;
  byte i;

  if ((sectorNo+sectorCount-1) >= vol.virtualSectors)
    return flSectorNotFound;

  /* Check if cached sector is still valid */
  if ((sectorNo             == vol.mappedSectorNo                  ) &&
      (sectorNo+sectorCount == vol.mappedSectorNo + sectorCount - 1)   )
     vol.flash->socket->remapped = TRUE;

#ifdef ENVIRONMENT_VARS
  if(flPolicy[vol.socketNo][vol.flash->socket->curPartition]==FL_DEFAULT_POLICY)
#endif /* ENVIRONMENT_VARS */
  if((vol.wearLevel.currUnit!=ANAND_NO_UNIT))
  {
    vol.wearLevel.alarm++;
    if(vol.wearLevel.alarm>=WLnow)
    {
      vol.wearLevel.alarm = 0;
      status = applyWearleveling(&vol);
      if (status != flOK)
         return status;
    }
  }
  status              = flWriteFault;
  vol.sectorsWritten += sectorCount;

  /* Try writing the sector up to 4 times before reporting an error */
  for (i = 0; (i < 4) && (status == flWriteFault); i++)
    status = allocateAndWriteSectors(&vol,sectorNo,fromAddress,sectorCount);

  return status;
}


/*----------------------------------------------------------------------*/
/*                        w r i t e S e c t o r                         */
/*                                                                      */
/* Writes a sector.                                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Virtual sector no. to write                   */
/*      fromAddress     : Data to write                                 */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus writeSector(Bnand vol, SectorNo sectorNo,
                            void FAR1 *fromAddress)
{
  checkStatus(discardQuickMountInfo(&vol));
  return  write2Sectors( &vol, sectorNo, fromAddress, ((SectorNo)1) );
}

#ifdef ENVIRONMENT_VARS

/*----------------------------------------------------------------------*/
/*                  w r i t e F u l l U n i t                           */
/*                                                                      */
/* Write set of consecutive sectors that occupies a full unit.          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Sector no. to write                           */
/*      fromAddress     : Pointer to buffer to write                    */
/*                                                                      */
/* Returns:                                                             */
/*      status of the write operaton                                    */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus writeFullUnit(Bnand vol, SectorNo sectorNo, void FAR1 *fromAddress)
{
   ANANDUnitNo virtualUnitNo = (ANANDUnitNo)(sectorNo >> vol.sectorsPerUnitBits);
   ANANDUnitNo lastUnitNo,newVirtualUnitNo;
   ANANDUnitNo unitNo,prevUnitNo;
   FLStatus    status;
   byte        ANAC,NAC,parityPerField;

   if(virtualUnitNo==ANAND_NO_UNIT) /* Sanity check */
      return flGeneralFailure;

   status = allocateUnit(&vol,&unitNo);
   if(status != flOK)
      return status;

   lastUnitNo = vol.virtualUnits[virtualUnitNo];
   if(lastUnitNo == ANAND_NO_UNIT)
   {
      /* First time we write to this VU */
      ANAC = NAC = 0;
   }
   else
   {
      status = getUnitData(&vol,lastUnitNo,&newVirtualUnitNo, &prevUnitNo,&ANAC,&NAC,&parityPerField);
      if(status != flOK)
         return status;

      /* check if unit is valid */
      if((badParityResult(parityPerField)  ) ||
         (virtualUnitNo != newVirtualUnitNo)   )
      {
         DEBUG_PRINT(("\nwriteFullUnit: Found a brocken chain\r\n"));
         return flGeneralFailure;
      }
      /* Update NAC */
      if(vol.physicalUnits[lastUnitNo]&FIRST_IN_CHAIN)
      {
         NAC = 1; /* One unit chain , set proper NAC */
      }
      else
      {
         if(NAC>=MAX_UNIT_CHAIN)
         {
            status = foldUnit(&vol,virtualUnitNo,FL_NORMAL_FOLDING);
            if (status != flOK)
            {
              status = checkFolding(&vol,status,virtualUnitNo);
              if(status != flOK)
                 return status;
            }
            if(vol.virtualUnits[virtualUnitNo]==ANAND_NO_UNIT)
            {
               /* Unit had no used sectors and was erased */
               lastUnitNo = ANAND_NO_UNIT;
               ANAC = NAC = 0;
            }
            else /* After folding must be 1 unit chain */
            {
               NAC = 1;
            }
         }
      }
   }
   status = assignUnit(&vol,unitNo,virtualUnitNo,ANAC,NAC);
   if(status != flOK)
     return status;

   setUnitCount(unitNo,vol.sectorsPerUnit);

   if(lastUnitNo==ANAND_NO_UNIT)
      vol.physicalUnits[unitNo]    |= FIRST_IN_CHAIN;
   vol.virtualUnits[virtualUnitNo]  = unitNo;

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
   /* Turn verify write off since this is a new unit */
   vol.curSectorWrite = 0; /* Store virtual sector Number */
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

#ifdef SCATTER_GATHER
   /* Write in pairs (NAC is used as a simple index) */
   for (NAC=0;NAC<vol.sectorsPerUnit;NAC+=2)
   {
      tffscpy(multiSectorBuf[vol.socketNo],
              *((byte FAR1 **)fromAddress+NAC),SECTOR_SIZE);
      tffscpy(multiSectorBuf[vol.socketNo]+SECTOR_SIZE,
              *((byte FAR1 **)fromAddress+NAC+1),SECTOR_SIZE);
      status = writeAndCheck(&vol,unitBaseAddress(vol,unitNo)+
                             (NAC<<(SECTOR_SIZE_BITS+1)),
                             multiSectorBuf[vol.socketNo],EDC,2);
      if(status != flOK)
         return status;
   }
   return status;
#else
   return writeAndCheck(&vol,unitBaseAddress(vol,unitNo),fromAddress,
                        EDC,vol.sectorsPerUnit);
#endif /* SCATTER_GATHER */
}

#endif /* ENVIRONMENT_VARS */

/*----------------------------------------------------------------------*/
/*                  w r i t e M u l t i S e c t o r                     */
/*                                                                      */
/* Write set of consecutive sectors                                     */
/*                                                                      */
/* Note : Special care was taken for SCATTER_GATHER option. In this     */
/*        user buffer is given as an array of 512 bytes buffers and not */
/*        as a single large (sectors*512 Bytes) array.                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : Sector no. to write                           */
/*      fromAddress     : pointer to buffer to write                    */
/*      sectorCount     : # of sectors to write                         */
/*                                                                      */
/* Returns:                                                             */
/*      status of the write operaton                                    */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus writeMultiSector(Bnand vol, SectorNo sectorNo,
                                 void FAR1 *fromAddress,SectorNo sectorCount)
{
  byte FAR1* curAddr    = (byte FAR1 *)fromAddress;
  SectorNo   lastSector;
  SectorNo   i;
  FLStatus   status = flOK;

  /* Check if sector is in virtual size boundries */
  if (sectorNo + sectorCount > vol.virtualSectors)
    return flSectorNotFound;

  checkStatus(discardQuickMountInfo(&vol));

  /*****************************************************/
  /*   Start from an odd address or only a one sector  */
  /*****************************************************/

  if(((sectorNo & 1)!=0)||(sectorCount==1))
  {
     status=write2Sectors(&vol, sectorNo,
#ifdef SCATTER_GATHER
                          *(char FAR1 **)
#endif /* SCATTER_GATHER */
                          fromAddress,1);

     if((sectorCount == 1   ) ||  /* finished (only 1 sector) */
        (status      != flOK)   ) /* or operation failed      */
        return status;

     sectorNo++;
     sectorCount--;
     /* Increament user buffer */
#ifdef SCATTER_GATHER
     fromAddress=(void FAR1 *)((char FAR1 **)fromAddress+1);
#else
     fromAddress=(byte FAR1 *)flAddLongToFarPointer(fromAddress,SECTOR_SIZE);
#endif /* SCATTER_GATHER */
  }

  /************************************************/
  /*   Write all the sequantial pair of sectors.  */
  /************************************************/

  if(((sectorNo+sectorCount-1) & 1)==0)
  {
     /* Keep last sector since it can not be written as a pair */
     lastSector = sectorNo+sectorCount-1;
  }
  else
  {
     lastSector = 0; /* All sectors can be written in pairs */
  }

  sectorCount = (sectorCount>>1)<<1; /* round down to even no' of sectors */

  for(i=0;i<sectorCount;i+=2) /* write pair of sectors*/
  {
#ifdef SCATTER_GATHER
     curAddr = (void FAR1 *)((byte FAR1 **)fromAddress+i);
#else
     curAddr=(byte FAR1 *)flAddLongToFarPointer(fromAddress,SECTOR_SIZE*i);
#endif /* SCATTER_GATHER */
#ifdef ENVIRONMENT_VARS
     if((flPolicy[vol.socketNo][vol.flash->socket->curPartition]==FL_COMPLETE_ASAP) &&
        /* sector is unit aligned */
        (((sectorNo    + i ) &  vol.sectorsPerUnitMask) == 0) &&
        /* enough sectors to fill a unit */
        ( (sectorCount - i ) >= vol.sectorsPerUnit    ))
     {
        status = writeFullUnit(&vol,sectorNo+i,curAddr);
        if(status != flOK)
           return status;
        i += vol.sectorsPerUnit-2;
        continue;
     }
#endif /* ENVIRONMENT_VARS */
#ifdef SCATTER_GATHER
     /* Copy scattered buffers to internal 1k buffer */
     tffscpy(multiSectorBuf[vol.socketNo],*((char FAR1 **)curAddr),SECTOR_SIZE);
     tffscpy(multiSectorBuf[vol.socketNo]+SECTOR_SIZE,*((char FAR1 **)curAddr+1),SECTOR_SIZE);
     curAddr = multiSectorBuf[vol.socketNo];
#endif /* SCATTER_GATHER */
     status = write2Sectors(&vol,sectorNo+i, curAddr,2);
     if(status != flOK)
        return status;
  }

  /*********************************************/
  /*   Write the last sector (not full page).  */
  /*********************************************/

  if(lastSector!=0)          /*  write last sector */
  {
#ifdef SCATTER_GATHER
     fromAddress = (void FAR1 *)((byte FAR1 **)fromAddress+i);
#else
     fromAddress = (void FAR1 *)flAddLongToFarPointer(fromAddress,SECTOR_SIZE*i);
#endif /* SCATTER_GATHER */
     status=write2Sectors(&vol, lastSector,
#ifdef SCATTER_GATHER
                          *(char FAR1 **)
#endif /* SCATTER_GATHER */
                          fromAddress,1);
  }
  return status;
}


/*----------------------------------------------------------------------*/
/*                       d e l e t e S e c t o r                        */
/*                                                                      */
/* Marks contiguous sectors as deleted.                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorNo        : First sector no. to delete                    */
/*      noOfSectors     : No. of sectors to delete                      */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus deleteSector(Bnand vol, SectorNo sectorNo,
                             SectorNo noOfSectors)
{
  CardAddress sectorAddress;
  SectorNo    iSector;
  ANANDUnitNo virtualUnitNo;
  ANANDUnitNo currUnitNo;
  byte        sectorFlags[2] = {SECTOR_DELETED,SECTOR_DELETED};
  FLBoolean   lastOK; /* Dummy variable */

  if (sectorNo + noOfSectors > vol.virtualSectors)
    return flSectorNotFound;

  checkStatus(discardQuickMountInfo(&vol));

  for (iSector = 0; iSector < noOfSectors; iSector++, sectorNo++,
       vol.sectorsDeleted++)
  {
    sectorAddress = virtual2Physical(&vol,sectorNo,ANAND_UNASSIGNED_ADDRESS,&lastOK);
    switch(sectorAddress)
    {
       case ANAND_UNASSIGNED_ADDRESS:
          continue;

       case ANAND_BAD_CHAIN_ADDRESS:
          return flGeneralFailure;

       default:
          virtualUnitNo = (ANANDUnitNo)(sectorNo >> vol.sectorsPerUnitBits);
#ifdef NFTL_CACHE
          setSectorFlagsCache(&vol, sectorAddress, SECTOR_DELETED);
#ifdef ENVIRONMENT_VARS
          if (((flMarkDeleteOnFlash == FL_ON) &&
              (flPolicy[vol.socketNo][vol.flash->socket->curPartition] != FL_COMPLETE_ASAP)) ||
              (vol.scache == NULL))
#endif /* ENVIRONMENT_VARS */
#endif /* NFTL_CACHE */
          {

#ifndef NT5PORT
              checkStatus(vol.flash->write(vol.flash,
                              sectorAddress + SECTOR_DATA_OFFSET,
                              &sectorFlags,
                              sizeof sectorFlags,
                              EXTRA));
#else /*NT5PORT*/
             vol.flash->write(vol.flash,
                              sectorAddress + SECTOR_DATA_OFFSET,
                              sectorFlags,
                              sizeof sectorFlags,
                              EXTRA);
#endif /*NT5PORT*/

          }
          currUnitNo = vol.virtualUnits[virtualUnitNo];

          if (vol.countsValid > virtualUnitNo)
          {
             if (countOf(currUnitNo) > 0)
             {
                vol.physicalUnits[currUnitNo]--; /* Decrement block count */
             }
             else
             {
                DEBUG_PRINT(("delete sector : Unit does not apear to have any sectors\r\n"));
                return flGeneralFailure;
             }
          }
     } /* End sectorAddress switch */
  } /* End delete sector loop */

  return flOK;
}

#ifdef DEFRAGMENT_VOLUME

/*----------------------------------------------------------------------*/
/*                          d e f r a g m e n t                         */
/*                                                                      */
/* Performs unit allocations to arrange a minimum number of writable    */
/* sectors.                                                             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      sectorsNeeded   : Minimum required sectors                      */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus defragment(Bnand vol, long FAR2 *sectorsNeeded)
{
  ANANDUnitNo dummyUnitNo;
  ANANDUnitNo firstFreeUnit = ANAND_NO_UNIT;
  FLBoolean   firstRound    = TRUE;
  FLStatus    status        = flOK;

  checkStatus(discardQuickMountInfo(&vol));

  if( (*sectorsNeeded) == -1 ) /* fold single best chain */
  {
    status = foldBestChain(&vol,&dummyUnitNo);
    if( (status != flOK) && (vol.freeUnits == 0) )
      return status;
    *sectorsNeeded = (long)vol.freeUnits << vol.sectorsPerUnitBits;
    return flOK;
  }

  /* Perform folding until the required number of sectors is achived */

  while (((long)vol.freeUnits << vol.sectorsPerUnitBits) < *sectorsNeeded)
  {
     status = foldBestChain(&vol,&dummyUnitNo); /* make more free units */
     if(status != flOK)
        break;
  }

  *sectorsNeeded = (long)vol.freeUnits << vol.sectorsPerUnitBits;

  return status;
}

#endif /* DEFRAGMENT */

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                        t l S e t B u s y                             */
/*                                                                      */
/* Notifies the start and end of a file-system operation.               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      state           : FL_ON (1) = operation entry                   */
/*                        FL_OFF(0) = operation exit                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus tlSetBusy(Bnand vol, FLBoolean state)
{
  return flOK;
}


/*----------------------------------------------------------------------*/
/*                      s e c t o r s I n V o l u m e                   */
/*                                                                      */
/* Gets the total number of sectors in the volume                       */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns:                                                             */
/*      Number of sectors in the volume                                 */
/*----------------------------------------------------------------------*/

static SectorNo sectorsInVolume(Bnand vol)
{
  return vol.virtualSectors;
}


/*----------------------------------------------------------------------*/
/*                    p u t G e t B u f f e r                           */
/*                                                                      */
/* Write \ Read a buffer to the flash from a specific flash offset      */
/* while making sure only good units are used.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol            : Pointer identifying drive                      */
/*      length         : Size of the buffer (always full pages)         */
/*      bufferPtr      : Data buffer                                    */
/*      flashAddr      : Physcial address on the flash                  */
/*      bbt            : Buffer containing BBT of the quick mount area  */
/*      readFlag       : TRUE - read data , FLASE - write data          */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*      bufferPtr      : Increamented data buffer                       */
/*      flashAddr      : Increamented physcial address on the flash     */
/*----------------------------------------------------------------------*/

#ifdef QUICK_MOUNT_FEATURE

static FLStatus putGetBuffer(Bnand vol, dword length, byte FAR1** bufferPtr,
                      CardAddress* flashAddr, byte* bbt, FLBoolean readFlag)
{
  FLStatus status;
  word     writeNow = 0;

  while (length > 0)
  {
     writeNow = (word)TFFSMIN(length,(((*flashAddr >> vol.unitSizeBits)+1)
                   << vol.unitSizeBits) - *flashAddr);
     if (readFlag)
     {
        status = vol.flash->read(vol.flash,*flashAddr,*bufferPtr,
                   (dword)writeNow,EDC);
     }
#ifndef FL_READ_ONLY
     else
     {
        status = vol.flash->write(vol.flash,*flashAddr,*bufferPtr,
                   (dword)writeNow,EDC);
     }
#endif /* FL_READ_ONLY */
     if(status != flOK)
        return status;

     length     -= writeNow;
     *flashAddr += writeNow;
     *bufferPtr  = BYTE_ADD_FAR(*bufferPtr,writeNow);
     NextGoodUnit(*flashAddr,bbt);
  }
  return flOK;
}


/*----------------------------------------------------------------------*/
/*                   q u i c k M o u n t D a t a                        */
/*                                                                      */
/* Saves or restores the quick mount data to and from the flash         */
/*                                                                      */
/* Note : the data is saved according to the mechines architecture. Big */
/*        Indien is not converted into little indien like the rest of   */
/*        of INFTL flash data structure                                 */
/*                                                                      */
/* The following will be saved :                                        */
/*                                                                      */
/* 1) physical Units table                                              */
/* 2) virutal Units table                                               */
/* 3) TL strucutre (Not by this routien but by its caller               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      readFlag        : TRUE for retrieve data FALSE for writing it   */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success other error codes for erase\read\write failures */
/*      start           : Unit offset (from the first unit of the       */
/*                        volume to start writting quick mount data.    */
/*                        (remember migh be bad).                       */
/*----------------------------------------------------------------------*/

static FLStatus quickMountData(Bnand vol, FLBoolean readFlag, byte* start)
{
  dword       length;
  dword       remainder;
  word        partialSize;
  CardAddress flashAddr;
  FLStatus    status;
  byte FAR1*  bufferPtr = vol.physicalUnits;
  byte        bbt[MAX_QUICK_MOUNT_UNITS]; /* Minimal bad blocks table */

  /* Read bad block tabel and find the first good block of the volume */

  status = vol.flash->readBBT(vol.flash,vol.firstQuickMountUnit,
              MAX_QUICK_MOUNT_UNITS,vol.blockMultiplierBits,bbt,FALSE);
  if(status != flOK)
     return status;

  for(*start = 0 ; (*start<MAX_QUICK_MOUNT_UNITS) &&
      (bbt[*start] != BBT_GOOD_UNIT) ; (*start)++);
  if (*start == MAX_QUICK_MOUNT_UNITS)
  {
     DEBUG_PRINT(("\nDebug: Too many Bad blocks in quick mount area\r\n"));
     return flBadBBT;
  }
  /* Skip first page for Bnand record */
  flashAddr = ((CardAddress)(vol.firstQuickMountUnit + (*start))
              << vol.unitSizeBits) + vol.flash->pageSize;

  /* Only the full pages of physical table */

  length     = vol.noOfUnits * sizeof(ANANDPhysUnit); /* Physicals length  */
  remainder  = length & (SECTOR_SIZE-1)/*vol.flash->pageSize*/; /* Last partial page */
  length    -= remainder;                                 /* Round to pages    */

  status = putGetBuffer(&vol, length, &bufferPtr, &flashAddr,bbt,readFlag);
  if(status != flOK)
     return status;

  /* Partial page of the physical table + begining of virtual table */

  length      = vol.noOfVirtualUnits * sizeof(ANANDUnitNo); /* Virtuals */
  partialSize = (word)TFFSMIN(length,(dword)SECTOR_SIZE-remainder);

  if (remainder > 0)
  {
     if (readFlag)
     {
        status = vol.flash->read(vol.flash,flashAddr , inftlBuffer,
                    sizeof(inftlBuffer),EDC);
        tffscpy(bufferPtr,inftlBuffer,(word)remainder);
        tffscpy(vol.virtualUnits,inftlBuffer+(word)remainder,partialSize);
     }
#ifndef FL_READ_ONLY
     else
     {
        tffscpy(inftlBuffer,bufferPtr, (word)remainder);
        tffscpy(inftlBuffer+(word)remainder,vol.virtualUnits,partialSize);
        status = vol.flash->write(vol.flash,flashAddr,inftlBuffer,
                    sizeof(inftlBuffer),EDC);
     }
#endif /* FL_READ_ONLY */
     if(status != flOK)
        return status;

     bufferPtr  = partialSize + (byte FAR1*)vol.virtualUnits;
     flashAddr += SECTOR_SIZE/*vol.flash->pageSize*/;
     NextGoodUnit(flashAddr,bbt);        /* if needed check for next good unit */
  }
  else
  {
     bufferPtr = (byte FAR1*)vol.virtualUnits;
  }

  /* Only the full pages of virtual table */

  length    -= partialSize;                 /* Remaining virtuals */
  remainder  = length % SECTOR_SIZE/*vol.flash->pageSize*/; /* Last partial page  */
  length    -= remainder;                   /* Round to pages     */

  status = putGetBuffer(&vol,length,&bufferPtr,&flashAddr,bbt,readFlag);
  if(status != flOK)
     return status;

  /* Partial page of the virtual table */

  if (remainder>0)
  {
     if(readFlag)
     {
        status = vol.flash->read(vol.flash,flashAddr,inftlBuffer,
                                 sizeof(inftlBuffer),EDC);
        tffscpy(bufferPtr , inftlBuffer,(word)remainder);
     }
#ifndef FL_READ_ONLY
     else
     {
        tffscpy(inftlBuffer , bufferPtr , (word)remainder);
        status = vol.flash->write(vol.flash,flashAddr,inftlBuffer,
                                  sizeof(inftlBuffer),EDC);
     }
#endif /* FL_READ_ONLY */
  }
  return status;
}

#endif /* QUICK_MOUNT_FEATURE */


/*----------------------------------------------------------------------*/
/*                       d i s m o u n t I N F T L                      */
/*                                                                      */
/* Dismount INFTL volume                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

static void dismountINFTL(Bnand vol)
{
  DEBUG_PRINT(("\nDebug: starting INFTL dismount.\r\n"));

#if (defined(QUICK_MOUNT_FEATURE) && !defined(FL_READ_ONLY))
  if ((vol.flags & QUICK_MOUNT) && (vol.firstMediaWrite == TRUE))
  {
     savedBnand* newVol = (savedBnand*)inftlBuffer;
     byte start;
     FLStatus status;

     DEBUG_PRINT(("\nDebug: with save operation of quick mount data.\r\n"));

     start  = vol.firstUnit - vol.firstQuickMountUnit;
     status = vol.flash->erase(vol.flash,(word)(vol.firstQuickMountUnit
                        << vol.blockMultiplierBits),
                        (word)((1 << vol.blockMultiplierBits) * start));
     if (status==flOK)
     {
        vol.flags &= ~QUICK_MOUNT; /* Prevent resaving the data */
        status = quickMountData(&vol, FALSE,&start);
        if (status == flOK)
        {
           /* Place Bnand record */

           tffsset(inftlBuffer,0,sizeof(inftlBuffer)); /* Clear inftlBuffer */

           /*********************************************************/
           /* Convert internal volume to little indian dword fields */
           /*********************************************************/

           toLE4(newVol->freeUnits      , vol.freeUnits         );
           toLE4(newVol->roverUnit      , vol.roverUnit         );
           toLE4(newVol->countsValid    , vol.countsValid       );
           toLE4(newVol->sectorsRead    , vol.sectorsRead       );
           toLE4(newVol->sectorsWritten , vol.sectorsWritten    );
           toLE4(newVol->sectorsDeleted , vol.sectorsDeleted    );
           toLE4(newVol->parasiteWrites , vol.parasiteWrites    );
           toLE4(newVol->unitsFolded    , vol.unitsFolded       );
           toLE4(newVol->wearLevel_1    , vol.wearLevel.alarm   );
           toLE4(newVol->wearLevel_2    , vol.wearLevel.currUnit);
           toLE4(newVol->eraseSum       , vol.eraseSum          );
           toLE4(newVol->validate       , QUICK_MOUNT_VALID_SIGN);
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
           toLE4(newVol->verifiedSectorNo , vol.verifiedSectorNo);
#else
           toLE4(newVol->verifiedSectorNo , 0);
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

           status = vol.flash->write(vol.flash,((CardAddress)(vol.firstQuickMountUnit
           +start))<< vol.unitSizeBits,inftlBuffer, sizeof(inftlBuffer),EDC);
        }
        if (status != flOK)
           DEBUG_PRINT(("Debug: ERROR writing quick mount information.\r\n"));
     }
     else /* continue with dismount */
     {
        DEBUG_PRINT(("Debug: Error erasing quick mount information.\r\n"));
     }
  }
#endif /* QUICK_MOUNT_FEATURE && not FL_READ_ONLY */

#ifdef FL_MALLOC
  /* Free multi sector buffers */
  if (multiSectorBufCounter[vol.socketNo] == 0)
  {
     if (multiSectorBuf[vol.socketNo] != NULL)
     {
        FL_FREE(multiSectorBuf[vol.socketNo]);
        multiSectorBuf[vol.socketNo] = NULL;
     }
  }
  if (multiSectorBufCounter[vol.socketNo] >= 0)
  {
     multiSectorBufCounter[vol.socketNo]--;
  }
  /* Free convertion tables */
  if( vol.physicalUnits != NULL )
  {
#if (defined (CHAINS_DEBUG) && !defined(CHECK_MOUNT))
     FILE * out;

     out = getFileHandle(&vol,0);
     if (out == NULL)
     {
       DEBUG_PRINT(("Debug: Can not open debug file.\r\n"));
     }
     else
     {
       checkVirtualChains(&vol,out);
       checkVolumeStatistics(&vol,out);
     }
#endif /* CHAINS_DEBUG AND NOT CHECK_MOUNT*/
     FL_FAR_FREE(vol.physicalUnits);
  }
  if( vol.virtualUnits != NULL )
    FL_FAR_FREE(vol.virtualUnits);
  vol.physicalUnits = NULL;
  vol.virtualUnits  = NULL;
  /* Free catche tables */
#ifdef NFTL_CACHE
  if( vol.ucache != NULL )
    FL_FAR_FREE(vol.ucache);
  if( vol.scache != NULL )
    FL_FAR_FREE(vol.scache);
  vol.ucache = NULL;
  vol.scache = NULL;
#endif /* NFTL_CACHE */
#endif /* FL_MALLOC */
  DEBUG_PRINT(("Debug: finished INFTL dismount.\r\n"));
}


/*----------------------------------------------------------------------*/
/*                      r e t r i e v e H e a d e r                     */
/*                                                                      */
/* Retrieve media header by oring the headers of each floor             */
/*                                                                      */
/* Note:  The header of each floor is read to the first half of the     */
/*        buffer and then ORed to the second half therefor constructing */
/*        the real header in the upper half. After all copies are read  */
/*        the data is copied to the first half.                         */
/*                                                                      */
/* Note:  No endian format changes are made.                            */
/*                                                                      */
/* Parameters:                                                          */
/*  vol           : Pointer identifying drive                           */
/*  originalUnits : Array to store original units locations             */
/*  readFullBBT   : Boolean flag. When true the entire BBT will be read */
/*                  and media units locations will be returned through  */
/*                  the originalUnits argument array. When FALSE only   */
/*                  the size of HEADER_SEARCH_BOUNDRY of each floor     */
/*                  be read.                                            */
/*  retrieveData  : Boolean flag. When true the header will be read     */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success any other value on error                        */
/*      flBadFormat if header was not found                             */
/*----------------------------------------------------------------------*/

FLStatus retrieveHeader (Bnand vol , ANANDUnitNo * originalUnits,
                         FLBoolean readFullBBT , FLBoolean retrieveData)
{
  ANANDUnitNo iUnit,index;
  ANANDUnitNo noOfUnitsPerFloor;
  byte        headerSize;
  byte        floorNo;
  FLStatus    status=flOK;
  byte        bbt[HEADER_SEARCH_BOUNDRY];
  byte FAR1*  BBT;

  noOfUnitsPerFloor = (ANANDUnitNo)(vol.flash->chipSize >> vol.unitSizeBits) *
    ((vol.flash->noOfChips + (vol.flash->noOfChips % vol.flash->noOfFloors)) /
      vol.flash->noOfFloors);

  headerSize = sizeof(BNANDBootRecord)+MAX_TL_PARTITIONS*sizeof(BNANDVolumeHeaderRecord);
  tffsset(originalUnits,0,sizeof(ANANDUnitNo) * MAX_NO_OF_FLOORS);

  if (readFullBBT == TRUE) /* read entire BBT into vol records (format) */
  {
     status = vol.flash->readBBT(vol.flash,0,vol.noOfUnits,
                                 vol.blockMultiplierBits,
                                 vol.physicalUnits,TRUE);
     if(status != flOK)
        return status;
     BBT = vol.physicalUnits;
  }
  else
  {
     BBT = bbt;
  }

  /* Go over all of the media floors and find header location */

  for (floorNo = 0 ; floorNo < vol.flash->noOfFloors ; floorNo++)
  {
     iUnit = (ANANDUnitNo)floorNo * noOfUnitsPerFloor;
     if (readFullBBT == FALSE) /* read small part of the floors BBT */
     {
        status = vol.flash->readBBT(vol.flash,iUnit,
                 HEADER_SEARCH_BOUNDRY,vol.blockMultiplierBits,BBT,FALSE);
        if(status != flOK)
           return status;

        iUnit=0;
     }

     /* find and save location of the first good block of the floor */

     index = iUnit + HEADER_SEARCH_BOUNDRY;
     while ((iUnit<index)&&(BBT[iUnit]!=BBT_GOOD_UNIT))
     {
        iUnit++;
     }
     if (iUnit==index)
     {
        DEBUG_PRINT(("Debug: ERROR too many bad blocks (can not find place for INFTL header.\r\n"));
        return flBadBBT;
     }

     if (readFullBBT == FALSE) /* Restore iUnit pointer to the physical media */
     {
        iUnit += (ANANDUnitNo)floorNo * noOfUnitsPerFloor;
     }
     originalUnits[floorNo] = iUnit; /* Save origial unit location */
  }

  if (retrieveData == FALSE)
    return flOK;

  /* Need to read the previous header */

  tffsset(inftlBuffer,0,SECTOR_SIZE);
  for (floorNo = 0 ; floorNo < vol.flash->noOfFloors ; floorNo++)
  {
     for (index=0;index<NO_OF_MEDIA_HEADERS;index++) /* both 2 copies */
     {
        status = vol.flash->read(vol.flash,((CardAddress)originalUnits[floorNo]
                    << vol.unitSizeBits) + index * HEADERS_SPACING,
                    inftlBuffer + headerSize,headerSize,PARTIAL_EDC);
        if (status != flOK)
        {
           DEBUG_PRINT(("Debug: ERROR reading original unit header.\r\n"));
        }
        else
        {
           if (tffscmp(inftlBuffer + headerSize, "BNAND", sizeof("BNAND")) == 0)
              break;
        }
     }
     if (index>=NO_OF_MEDIA_HEADERS)
     {
        DEBUG_PRINT(("Debug: Media header was not found on all copies.\r\n"));
        return flBadFormat;
     }

     /* merge with previous headers */
     for (index = 0 ; headerSize > index ; index++)
     {
        inftlBuffer[index] |= inftlBuffer[index + headerSize];
     }
  } /* loop of the floors */

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                     I N F T L I n f o                                */
/*                                                                      */
/* get INFTL information.                                               */
/*                                                                      */
/* Parameters:                                                          */
/*  vol           : Pointer discribing volume.                          */
/*  tlInfo        : Pointer to user record                              */
/*                                                                      */
/* Returns:                                                             */
/*  FLStatus      : 0 on success, failed otherwise                      */
/*  tlInfo        : Record containing tl infromation.                   */
/*----------------------------------------------------------------------*/

static FLStatus  INFTLInfo(Bnand vol, TLInfo *tlInfo)
{
  tlInfo->sectorsInVolume = vol.virtualSectors;
  tlInfo->bootAreaSize    = (dword)vol.bootUnits << vol.unitSizeBits;
  tlInfo->eraseCycles     = vol.eraseSum;
  tlInfo->tlUnitBits      = vol.unitSizeBits;
  return flOK;
}

#ifndef NO_READ_BBT_CODE

/*----------------------------------------------------------------------*/
/*                      r e a d B B T                                   */
/*                                                                      */
/* Returns a pointer to the BBT of the device.                          */
/* Note: Bad unit are marked with a 4 bytes address of the unit.        */
/* Note: A unit can contain several blocks                              */
/*                                                                      */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive                                 */
/*  buf     : pointer to buffer to read into                            */
/*                                                                      */
/* Returns:                                                             */
/*  FLStatus    : 0 on success, failed otherwise                        */
/*  noOfBB      : returns the number of bad unit of the media           */
/*  meidaSize   : returns the media size in bytes                       */
/*----------------------------------------------------------------------*/

static FLStatus  readBBT(Bnand vol, CardAddress FAR1 * buf,
                       long FAR2 * mediaSize, unsigned FAR2 * noOfBB)
{
   dword       iUnit;
   dword       noOfUnits = (ANANDUnitNo)(((dword)vol.flash->noOfChips * vol.flash->chipSize) >> vol.unitSizeBits);
   dword       index,curRead;
   ANANDUnitNo maxBad = (ANANDUnitNo)(noOfUnits * ANAND_BAD_PERCENTAGE / 100);
   CardAddress FAR1 * ptr = buf;
   *noOfBB = 0;

   if ( vol.flash->readBBT == NULL)
   {
       DEBUG_PRINT(("Debug: ERROR unerasable BBT not supported by MTD.\r\n"));
       return flGeneralFailure;
   }
   else
   {
      for (iUnit=vol.flash->firstUsableBlock;iUnit<noOfUnits;iUnit+=curRead)
      {
        curRead = TFFSMIN(SECTOR_SIZE,noOfUnits-iUnit);
        vol.flash->readBBT(vol.flash,iUnit,curRead,vol.blockMultiplierBits,multiSectorBuf[vol.socketNo],FALSE);
        for ( index = 0 ; (index < curRead) && (*noOfBB < maxBad); index++)
           if ((*(multiSectorBuf[vol.socketNo] + index) != BBT_GOOD_UNIT) &&  /* Not good unit */
           (*(multiSectorBuf[vol.socketNo] + index) != BBT_UNAVAIL_UNIT)) /* Not used for a special purpose */
           {
              *ptr = (iUnit+index) << vol.unitSizeBits;
              ptr = (CardAddress FAR1*)flAddLongToFarPointer((byte FAR1 *)ptr,
              sizeof(CardAddress));
              (*noOfBB)++;
           }
        if ( *noOfBB == maxBad)
        {
           DEBUG_PRINT(("Debug: ERROR to many bad blocks.\r\n"));
           return flVolumeTooSmall;
        }
      }
   }
   *mediaSize = (long) noOfUnits << vol.unitSizeBits;
   return flOK;
}

#endif /* NO_READ_BBT_CODE */

/*----------------------------------------------------------------------*/
/*                  c o n v e r t C h a i n                             */
/*                                                                      */
/* Convert candidate chain to given value.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      newestUnitNo    : newest unit in chain                          */
/*      oldestUnitNo    : oldest unit in chain                          */
/*      virtualUnitNo   : virtual unit no                               */
/*      chainsMark      : new value                                     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus convertChain(Bnand vol,
                             ANANDUnitNo newestUnitNo,
                             ANANDUnitNo oldestUnitNo,
                             ANANDUnitNo virtualUnitNo,
                             byte        chainsMark)
{
   ANANDUnitNo  chainBound = 0;

   for(;newestUnitNo != oldestUnitNo ; chainBound++,
        newestUnitNo  = getPrevUnit(&vol,newestUnitNo,virtualUnitNo))
   {
       if((newestUnitNo == ANAND_BAD_CHAIN_UNIT ) ||  /* Brocken chain */
          (chainBound   >= DOUBLE_MAX_UNIT_CHAIN))    /* Infinit loop  */
          return flGeneralFailure;

       vol.physicalUnits[newestUnitNo] = chainsMark;
   }
   vol.physicalUnits[oldestUnitNo]     = chainsMark;
   return flOK;
}

#ifndef FL_READ_ONLY

/*----------------------------------------------------------------------*/
/*                e r a s e O r p h a n U n i t                         */
/*                                                                      */
/* Erase one unit.                                                      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Unit to format                                */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus eraseOrphanUnit(Bnand vol, ANANDUnitNo unitNo)
{
  word eraseMark;
  dword eraseCount;
  FLStatus status;

  status = getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount,UNIT_TAILER_OFFSET);
  if(status != flOK)
    return status;

  if(unitNo+(ANANDUnitNo)vol.firstUnit<(ANANDUnitNo)vol.firstUnit)
  {
     return flGeneralFailure;
  }

  status = vol.flash->erase(vol.flash,
                (word)(((dword)unitNo+(dword)vol.firstUnit) << (vol.unitSizeBits - vol.erasableBlockSizeBits)),
                (word)(1 << vol.blockMultiplierBits));

  if (status != flOK) {
    markUnitBad(&vol,unitNo);   /* make sure unit format is not valid */
    return status;
  }

  vol.eraseSum++;
  eraseCount++;
  if (eraseCount == 0)          /* was hex FF's */
    eraseCount++;

  return setUnitTailer(&vol,unitNo,ERASE_MARK,eraseCount,UNIT_TAILER_OFFSET);
}

#endif /* FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                      c h e c k U n i t H e a d                       */
/*                                                                      */
/* Compare 2 copies of unit header.                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      vol              : Pointer identifying drive                    */
/*      unitNo           : Physical unit number                         */
/*                                                                      */
/* Returns:                                                             */
/*    flOK on success, flFormattingError on miscompare.                 */
/*----------------------------------------------------------------------*/

static FLStatus checkUnitHead(Bnand vol, ANANDUnitNo unitNo)
{
  ANANDUnitHeader       unitData;
  SecondANANDUnitHeader secondUnitData;

  /* Read first unit data */
  checkStatus(vol.flash->read(vol.flash,
                   unitBaseAddress(vol,unitNo) + UNIT_DATA_OFFSET,
                   &unitData,
                   sizeof(ANANDUnitHeader),
                   EXTRA));
  checkStatus(vol.flash->read(vol.flash, unitBaseAddress(vol,unitNo) +
                      SECOND_HEADER_OFFSET + UNIT_DATA_OFFSET,
                      &secondUnitData,
                      sizeof(SecondANANDUnitHeader),
                      EXTRA));
  if((LE2(secondUnitData.virtualUnitNo) != LE2(unitData.virtualUnitNo)) ||
     (LE2(secondUnitData.prevUnitNo   ) != LE2(unitData.prevUnitNo   )) ||
     (secondUnitData.ANAC               != secondUnitData.ANAC        )   )
     return flFormattingError;

  return flOK;
}

/*----------------------------------------------------------------------*/
/*                      g o A l o n g C h a i n                         */
/*                                                                      */
/* Go along the INFTL chaine while marking the chain in the convertion  */
/* tables. This routine is called by the mount routine in order to      */
/* initialize the volumes convertion tables.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit to check.                       */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus goAlongChain(Bnand vol,ANANDUnitNo unitNo)
{
   ANANDUnitNo origVirtualNo,virtualUnitNo,prevUnitNo;
   ANANDUnitNo lastCurrent,nextUnitNo,lastUnitNo;
   byte ANAC, NAC, prevANAC, parityPerField;
   FLStatus status;
   word  eraseMark;
   dword eraseCount;

   /* Check if already been here */
   if((vol.physicalUnits[unitNo]==FL_VALID)       ||
      (vol.physicalUnits[unitNo]==FL_FIRST_VALID) ||
      (vol.physicalUnits[unitNo]==FL_PRELIMINARY) ||
      (vol.physicalUnits[unitNo]==FL_FIRST_PRELIMINARY))
       return flOK;

   /* Read unit tailor to check the erase mark */

   status = getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount,UNIT_TAILER_OFFSET);
   if(status != flOK)
      return status;
   vol.eraseSum+=eraseCount;
   if (eraseMark != ERASE_MARK)
   {
      /* Do not perform erase in the mount. The allocateUnit routine */
      /* rechecks for the erase mark and it will erase this unit.    */
      vol.physicalUnits[unitNo] = ANAND_UNIT_FREE;
      return flOK;
   }

   status = getUnitData(&vol,unitNo,&virtualUnitNo, &prevUnitNo,
                        &ANAC,&NAC,&parityPerField);
   if(status != flOK)
      return status;

   /* Check parity result of values returned by getUnitData */

   if(badParityResult(parityPerField))
   {
      vol.physicalUnits[unitNo]=FL_PRELIMINARY;
      return flOK;
   }

   /* Check if the unit is free (all fields are FF) */

   if((virtualUnitNo == ANAND_NO_UNIT  ) &&
      (prevUnitNo    == ANAND_NO_UNIT  ) &&
      (ANAC          == ANAND_UNIT_FREE) &&
      (NAC           == ANAND_UNIT_FREE))
     return flOK;    /*  free unit */

   /* Check virtual unit number that was returned */
   if((virtualUnitNo        == ANAND_NO_UNIT) ||
      (vol.noOfVirtualUnits <= virtualUnitNo)   )
   {
      vol.physicalUnits[unitNo]=FL_PRELIMINARY;
      return flOK;
   }

   /* Save location of currently known newest unit of our chain */
   lastUnitNo = vol.virtualUnits[virtualUnitNo];


   /* If older unit is none existing then there is only one unit in this */
   /* chain so lets not complicate things.                               */

   if(prevUnitNo >= vol.noOfUnits)
   {
      if(lastUnitNo == ANAND_NO_UNIT )
      {
         /* First access to this unit therefore a one unit chain */

         vol.virtualUnits[virtualUnitNo] = unitNo;
         vol.physicalUnits[unitNo]       = FL_VALID | FIRST_IN_CHAIN;
         return flOK;
      }
      else
      {
         /* One unit chain that has 2 ends mark and deal later  */
         if(checkUnitHead(&vol,unitNo)!=flOK) /* Invalid header */
         {
            vol.physicalUnits[unitNo]          = FL_PRELIMINARY;
            return flOK;
         }
         else
         {
            if(checkUnitHead(&vol,lastUnitNo)!=flOK)
            {
               vol.physicalUnits[lastUnitNo]   = FL_PRELIMINARY;
               vol.virtualUnits[virtualUnitNo] = unitNo;
               vol.physicalUnits[unitNo]       = FL_VALID | FIRST_IN_CHAIN;
               /* Might want to check rest of chain - but not neccesary */
               return flOK;
            }
         }
         vol.physicalUnits[unitNo]             = FL_PRELIMINARY;
         DEBUG_PRINT(("Debug: We have reached a unit twice while mounting.\r\n"));
         return flOK;
      }
   }

   /* We know that our unit points to a valid unit , now check if we */
   /* already checked that older unit                                */

   if((vol.physicalUnits[prevUnitNo]     == FL_VALID)||
      (vol.physicalUnits[prevUnitNo]     == FL_FIRST_VALID))
   {
      if(lastUnitNo == prevUnitNo)
      {
         /* Our older unit is the head of the current chain. All we need */
         /* to do is append our newer unit and mark it as the new head   */

         vol.physicalUnits[unitNo]       = FL_VALID;
         vol.virtualUnits[virtualUnitNo] = unitNo;
         /* Might be nice to check for ANAC consistency */
         return flOK;
      }
      else /* The previous unit is not the newest unit of our chain */
      {
         if(lastUnitNo == ANAND_NO_UNIT)
         {
            /* This is the first time we accessed this chain, but the */
            /* unit indicated by the previous unit field is taken. We */
            /* must assume that it no longer belongs to our chain.    */

            vol.virtualUnits[virtualUnitNo] = unitNo;
            vol.physicalUnits[unitNo]       = FL_VALID | FIRST_IN_CHAIN;
            return flOK;
         }
         else /* Virtual chain already has a head - 2 ends of chain */
         {
            /* If we reached this point we have a problem - its bad.        */
            /* We were never visited, so we are'nt a part of a known chain. */
            /* Our previous unit is used and was visited so:                */
            /* a) It belong to our chain - so why is it not it's head       */
            /* b) It does not belong to our chain - so it will not lead     */
            /*    us to the rest of our chain which was already found.      */

            if(checkUnitHead(&vol,unitNo)!=flOK) /* Invalid header */
            {
               vol.physicalUnits[unitNo]    = FL_PRELIMINARY;
               return flOK;
            }
            else
            {
               if(checkUnitHead(&vol,lastUnitNo)!=flOK)
               {
                  vol.physicalUnits[lastUnitNo]   = FL_PRELIMINARY;
                  vol.virtualUnits[virtualUnitNo] = unitNo;
                  vol.physicalUnits[unitNo]       = FL_VALID | FIRST_IN_CHAIN;
                  /* Might want to check rest of chain - but not neccesary */
                  return flOK;
               }
            }
            vol.physicalUnits[unitNo]       = FL_PRELIMINARY;
            DEBUG_PRINT(("Debug: We have reached a unit twice while mounting.\r\n"));
            return flOK;
         }
      }
   }

   /* If we reached this point , we have a valid older unit pointer   */
   /* and it points to a unit we did not mark as visited yet. We need */
   /* to go along the chain and reconstruct it in the RAM tables.     */

   /* Save location of our unit and virtual unit number         */
   lastCurrent               = unitNo;
   origVirtualNo             = virtualUnitNo;

   /* Mark unit as Orphane until we shall verify the 2 ends connect */
   vol.physicalUnits[unitNo] = FL_PRELIMINARY;

   /************************************************************/
   /* Go over the chain starting the unit previous to our unit */
   /************************************************************/

   while(1)
   {
     nextUnitNo = unitNo;
     unitNo     = prevUnitNo;
     prevANAC   = ANAC;
     if(unitNo == ANAND_NO_UNIT)
        break;

     /* If already been to this unit */
     if((vol.physicalUnits[unitNo] == FL_VALID)||
        (vol.physicalUnits[unitNo] == FL_FIRST_VALID))
     {
        if(lastUnitNo == unitNo)
        {
           /* We have returned to the chains head , so the unit is valid */
           /* Convert all the units we passed as valid and mark new head */
           status = convertChain(&vol,lastCurrent,nextUnitNo,
                                 origVirtualNo,FL_VALID);
           vol.virtualUnits[origVirtualNo] = lastCurrent;
           return flOK;
        }
        /* We have reached a unit that was already checked, but was not   */
        /* registeredour as the chains head. We can safely assume it does */
        /* not belong to our virtual unit                                 */
        break;
     }

     /* Read unit header of our previous unit */

     status = getUnitData(&vol,unitNo,&virtualUnitNo, &prevUnitNo,
                          &ANAC,&NAC,&parityPerField);
     if(status != flOK)
        return status;

     if(badParityResult(parityPerField)) /* Bad unit header */
     {
        /* We can no longer follow the chain */
        vol.physicalUnits[unitNo] = FL_PRELIMINARY; /* Delete later */
        break;
     }

     /* Check if unit belongs to our chain */

     if((virtualUnitNo != origVirtualNo    ) ||  /* Correct virtual unit no */
        (!consecutiveNumbers(prevANAC,ANAC))   ) /* ANAC is consecutive     */
     {
        /* Note : none consecutive ANAC might still be connected to the end */
        /* the chain , on the next time we will read it.                    */
        break;
     }

     /* We have verified that unit belongs to our chain               */
     /* Mark unit as Orphane until we shall verify the 2 ends connect */
     vol.physicalUnits[unitNo]=FL_PRELIMINARY;
  }

  /* Chain reached a unit pointing to an invalid unit. */
  if(lastUnitNo == ANAND_NO_UNIT)
  {
     /* Chain did not have a head so mark it as a valid chain */
     status = convertChain(&vol,lastCurrent,nextUnitNo,
                           origVirtualNo,FL_VALID);
     vol.physicalUnits[nextUnitNo]   = FL_VALID | FIRST_IN_CHAIN;
     vol.virtualUnits[origVirtualNo] = lastCurrent;
  }
  else
  {
     /* Chain had a head. Check if previous head is valid. */

     if(checkUnitHead(&vol,lastUnitNo)!=flOK) /* Invalid header */
     {
        /* The unit we found earlier was a result of power failure */
        vol.physicalUnits[lastUnitNo]   = FL_PRELIMINARY;
        vol.virtualUnits[virtualUnitNo] = lastCurrent;
        status = convertChain(&vol,lastCurrent,nextUnitNo,
                              origVirtualNo,FL_VALID);
        vol.physicalUnits[nextUnitNo]   = FL_VALID | FIRST_IN_CHAIN;
        return status;
     }
     DEBUG_PRINT(("Debug: We have reached a unit twice while mounting.\r\n"));
     status = convertChain(&vol,lastCurrent,nextUnitNo,
                           origVirtualNo,FL_PRELIMINARY);
  }

  return status;
}

#ifdef QUICK_MOUNT_FEATURE

/*----------------------------------------------------------------------*/
/*                c h e c k Q u i c k M o u n t  I n f o                */
/*                                                                      */
/* Read the quick mount information and verfiy its itegrity.            */
/*                                                                      */
/* Note : If the data is valid it will be read to the vol record and    */
/*        will mark the current data as invalid.                        */
/*                                                                      */
/* Note : checksum will be added in future versions.                    */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/* Returns: TRUE if data is valid otherwise FALSE.                      */
/*----------------------------------------------------------------------*/

static FLBoolean checkQuickMountInfo(Bnand vol)
{
   byte  start;     /* The first goot unit of the quick mount data */
   FLStatus status;
   savedBnand *newVol;

   DEBUG_PRINT(("Debug: trying to read quick mount information.\r\n"));

   status = quickMountData(&vol, TRUE,&start);
   if (status==flOK)
   {
      status = vol.flash->read(vol.flash,(((CardAddress)(vol.firstQuickMountUnit
      +start))<< vol.unitSizeBits),inftlBuffer, sizeof(inftlBuffer),EDC);
      if (status == flOK)
      {
         /* Convert the dword fields  to the internal volume */

         newVol = (savedBnand *) inftlBuffer;
         if (LE4(newVol->validate) == QUICK_MOUNT_VALID_SIGN)
         {
            vol.freeUnits          = (ANANDUnitNo)LE4(newVol->freeUnits     );
            vol.roverUnit          = (ANANDUnitNo)LE4(newVol->roverUnit     );
            vol.countsValid        = (ANANDUnitNo)LE4(newVol->countsValid   );
            vol.sectorsRead        = LE4(newVol->sectorsRead   );
            vol.sectorsWritten     = LE4(newVol->sectorsWritten);
            vol.sectorsDeleted     = LE4(newVol->sectorsDeleted);
            vol.parasiteWrites     = LE4(newVol->parasiteWrites);
            vol.unitsFolded        = LE4(newVol->unitsFolded   );
            vol.wearLevel.alarm    = (word)LE4(newVol->wearLevel_1   );
            vol.wearLevel.currUnit = (ANANDUnitNo)LE4(newVol->wearLevel_2   );
            vol.eraseSum           = LE4(newVol->eraseSum      );
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
            vol.verifiedSectorNo   = LE4(newVol->verifiedSectorNo);
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */
            DEBUG_PRINT(("Debug: quick mount information was successfuly restored.\r\n"));
            return TRUE;
         }
      }
   }
   DEBUG_PRINT(("Debug: Error getting quick mount information.\r\n"));
   return FALSE;
}

#endif /* QUICK_MOUNT_FEATURE */
#ifdef NFTL_CACHE

/*----------------------------------------------------------------------*/
/*                      i n i t C a t c h                               */
/*                                                                      */
/* Initialize and allocate the unit and sector catche.                  */
/*                                                                      */
/* Note - need to add check for not enough static memory.               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      ramForCache     : Cache offset of previous volumes on device    */
/*                                                                      */
/* Returns:                                                             */
/*----------------------------------------------------------------------*/

#ifndef FL_MALLOC
void initCatch(Bnand vol, dword ramForCache)
#else
void initCatch(Bnand vol)
#endif /* FL_MALLOC */
{
  dword scacheSize = 0; /* Initialized to remove warrnings */
  dword iUnit;

  /* create and initialize ANANDUnitHeader cache */
#ifdef ENVIRONMENT_VARS
  if( flUseNFTLCache == 1 ) /* behave according to the value of env variable */
#endif
  {
#ifdef FL_MALLOC
     vol.ucache = (ucacheEntry FAR1*) FL_FAR_MALLOC(vol.noOfUnits * sizeof(ucacheEntry));
#else
     vol.ucache = &socketUcache[flSocketNoOf(vol.flash->socket)][ramForCache];
#endif /* FL_MALLOC */
  }
#ifdef ENVIRONMENT_VARS
  else
  {
    vol.ucache = NULL;
  }
#endif /* ENVIRONMENT_VARS */
  if (vol.ucache != NULL)
  {
    for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++)
    {
       vol.ucache[iUnit].virtualUnitNo = 0xDEAD;
       vol.ucache[iUnit].prevUnitNo    = 0xDEAD;
    }
  }
  else
  {
    DEBUG_PRINT(("Debug: INFTL runs without U-cache\r\n"));
  }

  /* create and initialize SectorFlags cache */
#ifdef ENVIRONMENT_VARS
  if( flUseNFTLCache == 1 ) /* behave according to the value of env variable */
#endif /* ENVIRONMENT_VARS */
  {
     scacheSize = (dword)vol.noOfUnits << (vol.unitSizeBits - SECTOR_SIZE_BITS - 2);
#ifdef FL_MALLOC
     if( (sizeof(unsigned) < sizeof(scacheSize)) &&
         (scacheSize >= 0x10000L) )            /* Out of Segment Boundary */
     {
        vol.scache = NULL;
     }
     else
     {
        vol.scache = (byte FAR1*) FL_FAR_MALLOC(scacheSize);
     }
#else
     vol.scache = &socketScache[flSocketNoOf(vol.flash->socket)][ramForCache << (vol.unitSizeBits - SECTOR_SIZE_BITS - 2)];
#endif /* FL_MALLOC */
  }
#ifdef ENVIRONMENT_VARS
  else
  {
    vol.scache = NULL;
  }
#endif /* ENVIRONMENT_VARS */
  if (vol.scache != NULL)
  {
    /*
     * Whenever SECTOR_IGNORE is found in Sector Flags cache it is double
     * checked by reading actual sector flags from flash-> This is way
     * all the cache entries are initially set to SECTOR_IGNORE.
     */
    byte val = (S_CACHE_SECTOR_IGNORE << 6) | (S_CACHE_SECTOR_IGNORE << 4) |
                            (S_CACHE_SECTOR_IGNORE << 2) |  S_CACHE_SECTOR_IGNORE;
    dword iC;

    for(iC=0;( iC < scacheSize );iC++)
      vol.scache[iC] = val;
  }
  else
  {
    DEBUG_PRINT(("Debug: INFTL runs without S-cache\r\n"));
  }
}
#endif /* NFTL_CACHE */

/*----------------------------------------------------------------------*/
/*                          m o u n t I N F T L                           */
/*                                                                      */
/* Mount the volume. Initialize data structures and conversion tables   */
/*                                                                      */
/* Parameters:                                                          */
/*      volNo           : Volume serial no.                             */
/*      tl              : Mounted translation layer on exit             */
/*      flash           : Flash media mounted on this socket            */
/*      volForCallback  : Pointer to FLFlash structure for power on     */
/*                        callback routine.                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/
static FLStatus mountINFTL(unsigned volNo, TL *tl, FLFlash *flash, FLFlash **volForCallback)
{
  Bnand                     vol            = &vols[volNo];
  ANANDUnitNo               iUnit;
  ANANDUnitNo               originalUnits[MAX_NO_OF_FLOORS];
  BNANDBootRecord         * mediaHeader;  /* Disk header record        */
  BNANDVolumeHeaderRecord * volumeHeader; /* volume header record      */
  FLStatus                  status;
  byte                      index;
#ifndef FL_MALLOC
  dword                     ramForUnits=0;
#ifdef NFTL_CACHE
  dword                     ramForCache=0;
#endif /* NFTL_CACHE */
#endif /* FL_MALLOC */
#ifdef EXTRA_LARGE
  word                      moreUnitBits;
#endif /* EXTRA_LARGE */
#ifdef CHAINS_DEBUG
  FILE * out;
#endif /* CHAINS_DEBUG */

  DEBUG_PRINT(("Debug: starting INFTL mount.\r\n"));

  /*************************/
  /* Find the media header */
  /*************************/

  tffsset(&vol,0,sizeof(vol));
  status = initINFTL(&vol,flash);
  if(status == flOK)
     status = retrieveHeader(&vol,originalUnits,FALSE,TRUE);
  if(status != flOK)
     return status;

  mediaHeader  = (BNANDBootRecord *)inftlBuffer;
  if (tl->partitionNo >= LE4(mediaHeader->noOfBDTLPartitions))
  {
     DEBUG_PRINT(("Debug: wrong partition number.\r\n"));
     return flBadDriveHandle;
  }
  *volForCallback = vol.flash;
  vol.eraseSum    = 0;

  /* Get media information from unit header */

  volumeHeader  = (BNANDVolumeHeaderRecord *)(inftlBuffer +
                  sizeof(BNANDBootRecord) +
                  (word)((LE4(mediaHeader->noOfBinaryPartitions) *
                  sizeof(BNANDVolumeHeaderRecord))));
  vol.bootUnits = (ANANDUnitNo)LE4(volumeHeader->firstQuickMountUnit);

#ifndef FL_MALLOC

  /* calculate the memory offset for static allocation */

  for (index = tl->partitionNo;index>0;index--,volumeHeader++)
  {
     ramForUnits += LE4(volumeHeader->virtualUnits) * sizeof(ANANDUnitNo); /* virtual size */
     iUnit = (word)(LE4(volumeHeader->lastUnit) - LE4(volumeHeader->firstUnit) + 1);
     ramForUnits += iUnit * sizeof(ANANDPhysUnit);
#ifdef NFTL_CACHE
     ramForCache += iUnit;
#endif /* NFTL_CACHE */
  }
#else
  volumeHeader += tl->partitionNo;
#endif /* FL_MALLOC */

  vol.noOfVirtualUnits     = (ANANDUnitNo)LE4(volumeHeader->virtualUnits);
  vol.flags                = (byte)LE4(mediaHeader->formatFlags);
  vol.firstQuickMountUnit  = (ANANDUnitNo)LE4(volumeHeader->firstQuickMountUnit);
  vol.firstUnit            =(ANANDUnitNo) LE4(volumeHeader->firstUnit);
#ifdef NFTL_CACHE
  vol.firstUnitAddress     = (dword)vol.firstUnit << vol.unitSizeBits;
#endif /* NFTL_CACHE */

  vol.virtualSectors = (SectorNo)((LE4(volumeHeader->virtualUnits)<<
                                  vol.unitSizeBits) >> SECTOR_SIZE_BITS);
  vol.noOfUnits      = (ANANDUnitNo)(LE4(volumeHeader->lastUnit) -
                       LE4(volumeHeader->firstUnit) + 1);

  /* Validy check  */

  if((ANANDUnitNo)(vol.noOfVirtualUnits > vol.noOfUnits))
  {
     DEBUG_PRINT(("Reported no of virtual unit is larger then no of physical units\r\n"));
     return flBadFormat;
  }

#ifdef FL_MALLOC
  status = initTables(&vol);
#else
  status = initTables(&vol,ramForUnits);
#endif /* MALLOCK */
  if(status != flOK)
     return status;

#ifdef NFTL_CACHE
#ifndef FL_MALLOC
  initCatch(&vol, ramForCache);
#else
  initCatch(&vol);
#endif /* FL_MALLOC */
#endif /* NFTL_CACHE */

#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASED_SECTOR))
  /* Default for INFTL is FL_OFF */
  flVerifyWrite[vol.socketNo][tl->partitionNo] = FL_OFF;
#endif /* VERIFY_WRITE || VERIFY_ERASED_SECTOR */

  /******************************************/
  /* Try mounting from the quick mount data */
  /******************************************/

#ifdef QUICK_MOUNT_FEATURE
#if (!defined(RAM_MTD) && !defined(CHECK_MOUNT))
  if (((LE4(mediaHeader->formatFlags) & QUICK_MOUNT) == 0) ||
      ( checkQuickMountInfo(&vol) == FALSE               )   )
#endif /* not RAM_MTD && not CHECK_MOUNT */
#endif /* QUICK_MOUNT_FORMAT */
  {
     vol.firstMediaWrite = TRUE; /* Force writing quick mount information */

     /***************************************/
     /* Read BBT to internal representation */
     /***************************************/

     status = flash->readBBT(vol.flash,vol.firstUnit,
              vol.noOfUnits,vol.blockMultiplierBits, vol.physicalUnits,FALSE);
     if( status != flOK )
     {
        DEBUG_PRINT(("Debug: Error reading BBT.\r\n"));
        dismountINFTL(&vol); /* Free tables must be done after call to initTables */
        return status;
     }
     /* Translate bad unit table to internal representation */
     for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++)
     {
        if (vol.physicalUnits[iUnit] != BBT_GOOD_UNIT)
        {
           vol.physicalUnits[iUnit] = UNIT_BAD;
        }
        else
        {
           vol.physicalUnits[iUnit] = ANAND_UNIT_FREE;
        }
     }
     /* Translate original units to bad blocks */
     for (index=0;index < vol.flash->noOfFloors;index++)
     {
        iUnit = originalUnits[index]-vol.firstUnit;
        if ((iUnit < vol.noOfUnits) && (originalUnits[index] > vol.firstUnit))
           vol.physicalUnits[iUnit] = UNIT_BAD;
     }

     /*************************/
     /* Mount the unit chains */
     /*************************/

     /* Initialize virutal units table */

     for (iUnit = 0; iUnit < vol.noOfVirtualUnits; iUnit++)
       vol.virtualUnits[iUnit] = ANAND_NO_UNIT;

#ifdef CHECK_MOUNT
     status = checkMountINFTL(&vol);
     if (status != flOK)
     {
       TL_DEBUG_PRINT(tl_out,"Failed check Mount routine with status %d\n",status);
       SET_EXIT(INFTL_FAILED_MOUNT);
     }
#endif /* CHECK_MOUNT */

     for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++)
     {
       if (vol.physicalUnits[iUnit] != UNIT_BAD)
       {
         status = goAlongChain(&vol,iUnit);
         if(status != flOK)
         {
            DEBUG_PRINT(("Debug: Error going along INFTL chains.\r\n"));
            dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
            return status;
         }
       }
     }
#ifdef CHAINS_DEBUG
     out = getFileHandle(&vol,0);
     if (out == NULL)
     {
        if (DID_MOUNT_FAIL)
           DEBUG_PRINT(("Debug: Can not open debug file.\r\n"));
     }
     else
     {
        checkVirtualChains(&vol,out);
     }
#endif /* CHAINS_DEBUG */
     vol.freeUnits = 0;
     for (iUnit = 0; iUnit < vol.noOfUnits; iUnit++)
     {
       switch( vol.physicalUnits[iUnit] )
       {
         case ANAND_UNIT_FREE:
           vol.freeUnits++;
       break;

         case FL_FIRST_VALID:         /* Mark as first in chain */
         case FL_VALID:
           vol.physicalUnits[iUnit] &= FIRST_IN_CHAIN;
           break;

         case FL_FIRST_PRELIMINARY:        /* Vadim :erase this unit*/
         case FL_PRELIMINARY:
           DEBUG_PRINT(("Orphan unit found\r\n"));
           TL_DEBUG_PRINT(tl_out,"Orphan units found , unit no %d\n",iUnit);
           SET_EXIT(INFTL_FAILED_MOUNT);
#ifndef FL_READ_ONLY
           if( eraseOrphanUnit(&vol,iUnit) == flOK)
           {
             vol.physicalUnits[iUnit] = ANAND_UNIT_FREE;
             vol.freeUnits++;
           }
           break;
#else
#ifndef CHECK_MOUNT
           dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
           return flWriteFault;
#endif /* CHECK_MOUNT */
#endif /* FL_READ_ONLY */

         default:          /* nothing here */
           break;
       }
     }
     /* Initialize allocation rover */
     vol.roverUnit = 0;

     /* Initialize statistics */
     vol.sectorsRead = vol.sectorsWritten = vol.sectorsDeleted = 0;
     vol.parasiteWrites = vol.unitsFolded = 0;

     vol.wearLevel.alarm    = (word)(vol.eraseSum % WLnow);
     vol.wearLevel.currUnit = (ANANDUnitNo)(vol.eraseSum % vol.noOfVirtualUnits);
  } /* end quick mounted succesful if */

#ifdef CHAINS_DEBUG
  if (out != NULL)
  {
     checkVolumeStatistics(&vol,out);
  }
#endif /* CHAINS_DEBUG */

#ifdef CHECK_MOUNT
  dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
  if(vol.debugState & INFTL_FAILED_MOUNT)
  {
     TL_DEBUG_PRINT(tl_out,"Test failed\n\n");
     fclose(tl_out);
     exit(EXIT_FAILURE);
  }
  else
  {
     TL_DEBUG_PRINT(tl_out,"Test success\n\n");
     exit(EXIT_SUCCESS);
  }
#endif /* CHECK_MOUNT */

#ifndef FL_READ_ONLY
  /* Make sure there are at least 2 free units */
  if(vol.freeUnits == 0)
  {
      status = foldBestChain(&vol,&iUnit);
      switch(status)
      {
         case flNotEnoughMemory:
            DEBUG_PRINT(("Debug: Not enough free units. Media is read only.\r\n"));
         case flOK:
            break;
         default:
             return status;
      }
  }
  tl->writeSector      = writeSector;
  tl->deleteSector     = deleteSector;
  tl->writeMultiSector = writeMultiSector;
#ifdef DEFRAGMENT_VOLUME
  tl->defragment       = defragment;
#endif /* DEFRAGMENT */
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  tl->checkVolume      = checkVolume;
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */
#else /* FL_READ_ONLY */
  tl->writeSector      = NULL;
  tl->deleteSector     = NULL;
  tl->writeMultiSector = NULL;
#ifdef DEFRAGMENT_VOLUME
  tl->defragment       = NULL;
#endif /* DEFRAGMENT */
#if (defined(VERIFY_WRITE) || defined (VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  tl->checkVolume      = NULL;
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */

#endif /* FL_READ_ONLY */

  tl->rec              = &vol;
  tl->mapSector        = mapSector;
  tl->sectorsInVolume  = sectorsInVolume;
  tl->getTLInfo        = INFTLInfo;
  tl->tlSetBusy        = tlSetBusy;
  tl->dismount         = dismountINFTL;
  tl->readSectors      = readSectors;
#ifndef NO_READ_BBT_CODE
  tl->readBBT          = readBBT;
#endif
  DEBUG_PRINT(("Debug: finished INFTL mount.\r\n"));
  return flOK;
}

#ifdef HW_PROTECTION

/*----------------------------------------------------------------------*/
/*                   p r o t e c t i o n I N F T L                      */
/*                                                                      */
/* Common entry point to all protection routines.                       */
/*                                                                      */
/* Parameters:                                                          */
/*      vol       : Pointer identifying drive                           */
/*      volume    : Pointer to partition record of the media header     */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failure               */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus protectionINFTL(Bnand vol,BNANDVolumeHeaderRecord* volume,
                                IOreq FAR2* ioreq , FLFunctionNo callType)
{
  FLFlash *   flash = vol.flash;
  FLStatus    status;
#ifndef FL_READ_ONLY
  CardAddress low;
  CardAddress high;
  byte        floorNo;
#endif /* FL_READ_ONLY */
  byte        tempFlags = 0; /* Initialized to remove warrnings */
  byte        area;
  word        returnedFlags;

  /* Save protection area since "volume" is overwritten by protectionSet */

  area = (byte)LE4(volume->protectionArea); /* Protection area */
  if ((LE4(volume->flags) & PROTECTABLE) == 0)
     return flNotProtected;

  /* Routine that need to get the partition type before executing */
  if ((callType != FL_PROTECTION_INSERT_KEY) &&
      (callType != FL_PROTECTION_REMOVE_KEY))
  {
     tempFlags = (byte)ioreq->irFlags;
     if (flash->protectionType == NULL)
        return flFeatureNotSupported;

     status = flash->protectionType(flash,area,&returnedFlags);
     ioreq->irFlags = (unsigned)returnedFlags;
     if (status != flOK)
        return status;

     /* Routines that need to change the protection attributes */

#ifndef FL_READ_ONLY
     if (callType!=FL_PROTECTION_GET_TYPE)
     {
        if((returnedFlags & KEY_INSERTED) == 0) /* Make sure the key is inserted */
        {
           DEBUG_PRINT(("Please insert key before trying to change protection attributes\r\n"));
           return flHWProtection;
        }

        if ((flash->protectionBoundries == NULL ) ||
            (flash->protectionSet       == NULL ) ||
            (flash->protectionKeyInsert == NULL ))
        {
           DEBUG_PRINT(("Protection routine are NULL\r\n"));
           return flFeatureNotSupported;
        }

        if (!(LE4(volume->flags) & CHANGEABLE_PROTECTION))
           return flUnchangeableProtection;

        /* The DPS of unprotected partitions is protected by a default key */
        flash->protectionKeyInsert(flash,area,(byte *)DEFAULT_KEY);
     }
#endif /* FL_READ_ONLY */
  } /* End of protection change routine */


  /* Execute each of the posible protection routines */

  switch (callType)
  {
     case FL_PROTECTION_GET_TYPE:

        ioreq->irFlags |= PROTECTABLE;
        if (LE4(volume->flags) & CHANGEABLE_PROTECTION)
        {
           if ((ioreq->irFlags & CHANGEABLE_PROTECTION)==0)
           {
              DEBUG_PRINT(("Debug: INFTL reported CHANGEALE protection, but MTD does not allow it.\r\n"));
              return flBadFormat;
           }
        }
        else
        {
           ioreq->irFlags &= (~CHANGEABLE_PROTECTION);
        }
        break;

#ifndef FL_READ_ONLY

     case FL_PROTECTION_SET_LOCK:

        if (tempFlags & LOCK_ENABLED)
        {
           ioreq->irFlags |= LOCK_ENABLED;
        }
        else
        {
           ioreq->irFlags &=~LOCK_ENABLED;
        }
        for (floorNo = 0 ; floorNo < flash->noOfFloors ; floorNo++)
        {
           /* Find boundries */
           status = flash->protectionBoundries(flash,
                         area,&low,&high,floorNo);
           if(status == flOK) /* Set new protection values */
           {
              status = flash->protectionSet(flash,area,
                       (word)((high == 0) ? PROTECTABLE : ioreq->irFlags),
                       low,high,NULL,
                       (byte)((floorNo == flash->noOfFloors - 1) ?
                       COMMIT_PROTECTION : DO_NOT_COMMIT_PROTECTION),floorNo);
           }
           if(status != flOK)
             return status;
        }
        break;

     case FL_PROTECTION_CHANGE_KEY:

        for (floorNo = 0 ; floorNo < flash->noOfFloors ; floorNo++)
        {
           /* Find boundries */
           status = flash->protectionBoundries(flash,area,
                         &low,&high,floorNo);
           if(status == flOK) /* Set new protection values */
           {
              status = flash->protectionSet(flash,area,
                       (word)((high == 0) ? PROTECTABLE : ioreq->irFlags),
                       low,high,(byte FAR1*)ioreq->irData,
                       (byte)((floorNo == flash->noOfFloors - 1) ?
                       COMMIT_PROTECTION : DO_NOT_COMMIT_PROTECTION),floorNo);
           }
           if(status != flOK)
             return status;
        }
        break;

     case FL_PROTECTION_CHANGE_TYPE:

        /* Only read and or write protected types are available */
        if (((tempFlags & (READ_PROTECTED | WRITE_PROTECTED |
               PROTECTABLE)) != tempFlags) ||
               ((tempFlags & PROTECTABLE) == 0))
           return flBadParameter;

        for (floorNo = 0 ; floorNo < flash->noOfFloors ; floorNo++)
        {
           /* Find boundries */
           status = flash->protectionBoundries(flash,area,
                                               &low,&high,floorNo);
           if(status == flOK) /* Set new protection values */
           {
              status = flash->protectionSet(flash,area,
                       (word)((high == 0) ? PROTECTABLE : tempFlags),
                       low,high,NULL,(byte)((floorNo == flash->noOfFloors - 1)
                       ? COMMIT_PROTECTION : DO_NOT_COMMIT_PROTECTION),floorNo);
           }
           if(status != flOK)
             return status;
        }
        break;

#endif /* FL_READ_ONLY */

     case FL_PROTECTION_REMOVE_KEY:

        if (flash->protectionKeyRemove == NULL)
        {
           DEBUG_PRINT(("Protection routine is NULL\r\n"));
           return flFeatureNotSupported;
        }
        return flash->protectionKeyRemove(flash,area);

     case FL_PROTECTION_INSERT_KEY:

        if (flash->protectionKeyInsert == NULL)
        {
           DEBUG_PRINT(("Protection routine is NULL\r\n"));
           return flFeatureNotSupported;
        }
        return flash->protectionKeyInsert(flash,area,(byte FAR1*)ioreq->irData);
     default:
        break;
  } /* protection routines */
  return flOK;
}

#endif /* HW_PROTECTION */

/*----------------------------------------------------------------------*/
/*                     p r e M o u n t I N F T L                        */
/*                                                                      */
/* Common entry point to all tl routines that may be perfomed before    */
/* the volume is mounted (except for the format routine                 */
/*                                                                      */
/* Parameters:                                                          */
/*      callType        : Enum type of posible routines                 */
/*      ioreq           : Input and output request packet               */
/*      flash           : Flash media mounted on this socket            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failure               */
/*                                                                      */
/*----------------------------------------------------------------------*/

static FLStatus preMountINFTL(FLFunctionNo callType, IOreq FAR2* ioreq ,FLFlash* flash, FLStatus* status)
{
  BNANDVolumeHeaderRecord* volume;
  ANANDUnitNo originalUnits[MAX_NO_OF_FLOORS];
  Bnand       vol       = vols + FL_GET_SOCKET_FROM_HANDLE(ioreq);
  byte        partition = FL_GET_PARTITION_FROM_HANDLE(ioreq);
  FLStatus    tmpStatus;

  DEBUG_PRINT(("Debug: starting INFTL preMount operation.\r\n"));

  /*************************/
  /* Find the media header */
  /*************************/

  tmpStatus = initINFTLbasic(&vol,flash);
  if(tmpStatus == flOK)
    tmpStatus = retrieveHeader(&vol,originalUnits,FALSE,TRUE);
  if(tmpStatus != flOK)
    return tmpStatus;

  *status = flOK;

  if (callType == FL_COUNT_VOLUMES) /* get number of BDTL volumes routine */
  {
     ioreq->irFlags = (byte)LE4(((BNANDBootRecord *)inftlBuffer)->
                       noOfBDTLPartitions);
     return flOK;
  }

  /* Check media header for the specific partition */
  volume = (BNANDVolumeHeaderRecord*)(inftlBuffer + sizeof(BNANDBootRecord));

  if (partition > LE4(((BNANDBootRecord *)inftlBuffer)->noOfBDTLPartitions))
  {
     *status = flBadDriveHandle;
  }
  else
  {
     volume += (LE4(((BNANDBootRecord *)inftlBuffer)->noOfBinaryPartitions)+
               partition);
  }

  switch (callType)
  {
#if (defined(QUICK_MOUNT_FEATURE) && !defined(FL_READ_ONLY))
     case FL_CLEAR_QUICK_MOUNT_INFO:
        if(*status != flBadDriveHandle) /* Valid partition number */
           *status = flash->erase(flash,
           (word)(LE4(volume->firstQuickMountUnit) << vol.blockMultiplierBits),
           (word)((LE4(volume->firstUnit) - LE4(volume->firstQuickMountUnit))
                  << vol.blockMultiplierBits));
        break;
#endif /* QUICK_MOUNT_FEATURE AND NOT FL_READ_ONLY */

#ifdef HW_PROTECTION
     case FL_PROTECTION_GET_TYPE:       /* Protection routines */
     case FL_PROTECTION_SET_LOCK:
     case FL_PROTECTION_CHANGE_KEY:
     case FL_PROTECTION_CHANGE_TYPE:
     case FL_PROTECTION_INSERT_KEY:
     case FL_PROTECTION_REMOVE_KEY:
        if(*status == flBadDriveHandle) /* Valid partition number */
           break;
        *status = protectionINFTL(&vol,volume,ioreq,callType);
        break;
#endif  /* HW_PROTECTION */

     default: /* not supported pre mount routine */
        return flBadParameter;
  } /* end of callType switch */
  return flOK; /* This TL took responsibility of this call */
}


#if (defined(FORMAT_VOLUME) && !defined(FL_READ_ONLY))

/*----------------------------------------------------------------------*/
/*                                e r a s e U n i t                     */
/*                                                                      */
/* Erase the unit while retaining the erase count.                      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      unitNo          : Physical unit to format                       */
/*                                                                      */
/*      the progress is repored by the progressCallBack routine         */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus eraseUnit(Bnand vol, ANANDUnitNo unitNo,
                          FLProgressCallback progressCallback)
{
  word     eraseMark;
  dword    eraseCount;
  FLStatus status;

  if (progressCallback)
  {
     status = (*progressCallback)((word)(vol.flash->noOfChips *
                                  (vol.flash->chipSize >> vol.unitSizeBits)),(word)(unitNo+1));
     if(status != flOK)
     {
        DFORMAT_PRINT(("Debug: ERROR failed reporting progress callback.\r\n"));
        dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
        return status;
     }
  }
  status = getUnitTailer(&vol,unitNo,&eraseMark,&eraseCount,UNIT_TAILER_OFFSET);
  if(status == flOK)
  {
     status = vol.flash->erase(vol.flash,(word)(unitNo << vol.blockMultiplierBits),
              (word)(1 << vol.blockMultiplierBits));
  }
  if (status == flOK)
  {
     eraseCount++;
     if (eraseCount == 0)               /* was hex FF's */
     eraseCount++;
     status = setUnitTailer(&vol,unitNo,ERASE_MARK,eraseCount,UNIT_TAILER_OFFSET);
  }
  if (status != flOK)
  {
     DEBUG_PRINT(("Debug: ERROR failed formating unit.\r\n"));
     markUnitBad(&vol,unitNo);  /* make sure unit format is not valid */
     dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
  }

  return status;
}


/*----------------------------------------------------------------------*/
/*                       f o r m a t I N F T L                          */
/*                                                                      */
/* Perform INFTL Format.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      volNo           : Volume serial no.                             */
/*      fp              : Address of FormatParams structure to use      */
/*      flash           : Flash media mounted on this socket            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, failed otherwise                */
/*----------------------------------------------------------------------*/

static FLStatus formatINFTL(unsigned volNo, TLFormatParams *fp, FLFlash *flash)
{
  Bnand                       vol          = &vols[volNo];            /* TL record    */
  BDTLPartitionFormatParams   FAR2* bdtl   = fp->BDTLPartitionInfo;   /* bdtl input   */
  BinaryPartitionFormatParams FAR2* binary = fp->binaryPartitionInfo; /* binary input */
  BNANDBootRecord             * mediaHeader;   /* Disk header record     */
  BNANDVolumeHeaderRecord     * volumeHeader;  /* volume header record   */
  BNANDVolumeHeaderRecord     * volumeHeader2; /* volume header record   */
  CardAddress iBlock;                   /* Block counter index           */
  ANANDUnitNo iUnit;                    /* unit index for loops          */
  ANANDUnitNo unitsNeededForVolume;     /* good units needed for volume  */
  ANANDUnitNo floorGarantiedUnitsLeft;  /* garantied units not yet distributed */
  ANANDUnitNo binaryUnitsInFloor;       /* number of binary unit in this floor */
  ANANDUnitNo noOfUnitsPerFloor[MAX_NO_OF_FLOORS];
  ANANDUnitNo floorGarantiedUnits[MAX_NO_OF_FLOORS]; /* garantied good units in floor */
  ANANDUnitNo originalUnits[MAX_NO_OF_FLOORS]; /* unit no' of the original units */
  ANANDUnitNo goodUnits[MAX_NO_OF_FLOORS];     /* no of good blocks in floor */
  ANANDUnitNo skipedUnits;     /* number of good units to leave as unfrmated */
  ANANDUnitNo goodBlocks;
  FLStatus    status;                   /* status of TrueFFS routines      */
  Sbyte       volumeNo;                 /* current volume index            */
  Sbyte       noOfVolumes = fp->noOfBDTLPartitions + fp->noOfBinaryPartitions;
  dword       index;                    /* general loops index             */
  dword       sizeOfLastBinary;
  byte *      firstVolumePtr;
  byte        headersBuffer[sizeof(inftlBuffer)];
  byte        floorNo;                  /* current floor index             */
  byte        noOfFloors;
  byte        temp;
  byte        lastBinaryFloor;
#ifdef HW_PROTECTION
  ANANDUnitNo volumeStart;
  word        protectionType = 0;       /* Initialized to remove warrnings */
  /* Highest floor to leave DPS untouched - per DPS */
  byte        binaryFloorOfDPS[MAX_PROTECTED_PARTITIONS];
  byte        changeableProtection    = 0;
  byte        unchangeableProtection  = 0;
  byte        protectionKey[PROTECTION_KEY_LENGTH];
#endif /* HW_PROTECTION */
#ifdef WRITE_EXB_IMAGE
  BinaryPartitionFormatParams exbBinaryPartition;
  byte        exbSign[BINARY_SIGNATURE_LEN];
  byte        noOfBinary = fp->noOfBinaryPartitions;
#endif /* WRITE_EXB_IMAGE */
#ifdef QUICK_MOUNT_FEATURE
  Sword       quickMount[MAX_VOLUMES_PER_DOC];

/*  fp->flags |= TL_QUICK_MOUNT_FORMAT; */
  for (volumeNo=0;volumeNo<MAX_VOLUMES_PER_DOC;volumeNo++)
  {
     quickMount[volumeNo]=0;
  }
#endif /* QUICK_MOUNT_FEATURE */

 /*-------------------------------------------------------
  * Media header || Binary 0 + exb file || Binary 1,.. ||
  *-------------------------------------------------------*/

 /*-----------------------------------------------------
  * quick mount + BDTL 0 || quick mount + BDTL 1, ... ||
  *-----------------------------------------------------*/

  DEBUG_PRINT(("Debug: starting INFTL format by verifying arguments.\r\n"));

  tffsset(&vol,0,sizeof(vol));

  /* Check that there is up to 4 volumes on the device provided one is a
   * BDTL volume. If there is an exb file to be placed it would require
   * at least 1 binary volume
   */

  if ((fp->noOfBDTLPartitions < 1) ||
#ifdef WRITE_EXB_IMAGE
      ((fp->exbLen > 0) && (fp->noOfBDTLPartitions == MAX_VOLUMES_PER_DOC)) ||
#endif /* WRITE_EXB_IMAGE */
      (noOfVolumes > MAX_VOLUMES_PER_DOC))
  {
     DFORMAT_PRINT(("ERROR - There can be up to 4 volumes while at least one is a BDTL.\r\n"));
     return flBadParameter;
  }

  /*******************/
  /* Initialization  */
  /*******************/

  checkStatus(initINFTL(&vol,flash)); /* Initialize variables */
  noOfFloors = flash->noOfFloors;
  vol.noOfVirtualUnits = 0;

#ifdef FL_MALLOC
  status = initTables(&vol);   /* Allocate tables      */
#else
  status = initTables(&vol,0);
#endif /* FL_MALLOC */

  if(status != flOK)
  {
     DFORMAT_PRINT(("ERROR - Failed allocating memory for INFTL tables.\r\n"));
     dismountINFTL(&vol); /*Free tables must be done after call to initTables*/
     return status;
  }
  /* Calculate units per floor */
  noOfUnitsPerFloor[0] = (ANANDUnitNo)(vol.flash->chipSize >> vol.unitSizeBits) *
    ((vol.flash->noOfChips + (vol.flash->noOfChips % vol.flash->noOfFloors)) /
      vol.flash->noOfFloors);
  floorGarantiedUnits[0] = (ANANDUnitNo)((dword)((dword)fp->percentUse * (dword)noOfUnitsPerFloor[0]) / 100 - 1); /* - header */
  for (index=0;index+1<vol.flash->noOfFloors;index++)
  {
    noOfUnitsPerFloor[index] = noOfUnitsPerFloor[0];
    floorGarantiedUnits[index] = floorGarantiedUnits[0];
  }
  /* Last floor might have diffrent number of chips */
  noOfUnitsPerFloor[index] = (ANANDUnitNo)(vol.noOfUnits - (index*noOfUnitsPerFloor[0]));
  floorGarantiedUnits[index] = (ANANDUnitNo)((dword)fp->percentUse *
                               noOfUnitsPerFloor[index] / 100 - 1);

  /********************************************************************/
  /* Read BBT , find headers location and count number of good blocks */
  /********************************************************************/

  status = retrieveHeader (&vol ,originalUnits,TRUE,
             (fp->flags & FL_LEAVE_BINARY_AREA) ? TRUE : FALSE);
  tffscpy(headersBuffer,inftlBuffer,sizeof(headersBuffer));
  mediaHeader = (BNANDBootRecord *)headersBuffer;
  firstVolumePtr= headersBuffer + sizeof(BNANDBootRecord);

  /* If previous header was not found it is not possible to leave
   * the previous binary partition.
   */

  if(status == flBadFormat)
  {
     if(fp->flags & FL_LEAVE_BINARY_AREA)
     {
       DFORMAT_PRINT(("NOTE -  Previous binary partition data could not be found.\r\n"));
       fp->flags &= ~FL_LEAVE_BINARY_AREA;
     }
  }

  if(status == flBadBBT)
  {
     DFORMAT_PRINT(("ERROR - Unreadable Bad Blocks Table.\r\n"));
     dismountINFTL(&vol); /*Free tables must be done after call to initTables*/
     return status;
  }

  if(vol.physicalUnits[0] == BBT_BAD_UNIT)
  {
    DFORMAT_PRINT(("ERROR - IPL block is bad.\r\n"));
    dismountINFTL(&vol); /*Free tables must be done after call to initTables*/
    return flBadIPLBlock;
  }

  /* Loop over the floors of the media while counting the good units
   * the good units are needed for the transfere unit calculation.
   * In addition change the MTD values of Bad unit ro INFTL
   */

  for (floorNo = 0 , iUnit = 0 , index = 0 ; floorNo<noOfFloors ; floorNo++)
  {
     index += noOfUnitsPerFloor[floorNo];
     goodBlocks = noOfUnitsPerFloor[floorNo];
     for (;iUnit<index;iUnit++)
     {
        if (vol.physicalUnits[iUnit]!=BBT_GOOD_UNIT)
        {
           goodBlocks--;
           vol.physicalUnits[iUnit] = UNIT_BAD;
        }
        else
        {
           vol.physicalUnits[iUnit] = ANAND_UNIT_FREE;
        }
     }
     goodBlocks--; /* Do not count one unit for floor header */
     if (goodBlocks < floorGarantiedUnits[floorNo])
     {
        DFORMAT_PRINT(("ERROR - Too many bad block on flash->\r\n"));
        dismountINFTL(&vol); /*Free tables must be done after call to initTables*/
        return flVolumeTooSmall;
     }
     /* Save amount of good blocks for later */
     goodUnits[floorNo] = goodBlocks;
  }

  /************************************/
  /* Construct binary volumes headers */
  /************************************/

  volumeHeader = (BNANDVolumeHeaderRecord *) firstVolumePtr;
  goodBlocks   = 0; /* good units already used (counting headers)            */
  skipedUnits  = 0; /* good units to leave unformated (not counting headers) */
#ifdef HW_PROTECTION
  for(index = 0 ; index < MAX_PROTECTED_PARTITIONS ; index++)
    binaryFloorOfDPS[index] = MAX_NO_OF_FLOORS; /* Invalid floor no */
#endif /* HW_PROTECTION */

  if(fp->flags & FL_LEAVE_BINARY_AREA) /* Previous Boot area is kept */
  {
     if(fp->bootImageLen == -1) /* kept entirely */
     {
         for (index = 0;index < LE4(mediaHeader->noOfBinaryPartitions);
              index++,volumeHeader++)
         {
            /* not including headers */
            skipedUnits  += (ANANDUnitNo)LE4(volumeHeader->virtualUnits);
#ifdef HW_PROTECTION
            if (LE4(volumeHeader->flags) & PROTECTABLE)
            {
               if (LE4(volumeHeader->protectionArea) >= flash->totalProtectedAreas)
               {
                  tffsset(headersBuffer,0,sizeof(headersBuffer));
                  DFORMAT_PRINT(("ERROR - Previous Binary partition had a bad protection area field.\r\n"));
                  dismountINFTL(&vol); /*Free tables must be done after call to initTables*/
                  return flBadFormat;
               }
               binaryFloorOfDPS[LE4(volumeHeader->protectionArea)] =
               skipedUnits / floorGarantiedUnits[0];
            }
#endif /* HW_PROTECTION */
         }
     }
     else /* erase all previous binary partitions */
     {
        tffsset(headersBuffer,0,sizeof(headersBuffer));
        if(fp->bootImageLen != 0)
           DFORMAT_PRINT(("ERROR - Requested Binary partition size is diffrent then previous one.\r\n"));
     }
     /* clean the bdtl entries */
     tffsset(volumeHeader, 0,(word)(sizeof(headersBuffer)-((byte *)volumeHeader-headersBuffer)));
     goodBlocks  = skipedUnits;
     /* Update the number of partitions with the binary partitions */
     fp->noOfBinaryPartitions = (byte)(volumeHeader - (BNANDVolumeHeaderRecord *) firstVolumePtr);
     noOfVolumes = fp->noOfBDTLPartitions + fp->noOfBinaryPartitions;
     if(noOfVolumes > MAX_VOLUMES_PER_DOC)
     {
        DFORMAT_PRINT(("ERROR - There can be up to 4 volumes while at least one is a BDTL.\r\n"));
        dismountINFTL(&vol); /*Free tables must be done after call to initTables*/
        return flBadParameter;
     }
  }
  else /* Apply binary area format parameters */
  {
     tffsset(headersBuffer,0,sizeof(headersBuffer)); /* reset all binary area */
     for (volumeNo=0;volumeNo<fp->noOfBinaryPartitions;
          volumeNo++,binary++,volumeHeader++)
     {
        binary->length             = roundToUnits(binary->length);
        if (binary->length == 0)
        {
#ifdef WRITE_EXB_IMAGE
           if(((fp->exbLen == 0) && (volumeNo == 0)) ||
              ( volumeNo   != 0                    )   )
#endif /* WRITE_EXB_IMAGE */
           {
              DFORMAT_PRINT(("ERROR - BINARY partition length should not be 0.\r\n"));
              dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
              return flBadParameter;
           }
        }
        toLE4(volumeHeader->virtualUnits,binary->length);
#ifdef HW_PROTECTION
        toLE4(volumeHeader->flags       ,INFTL_BINARY |
                                         binary->protectionType);
#else
        toLE4(volumeHeader->flags       ,INFTL_BINARY);
#endif /* HW_PROTECTION */
        goodBlocks += (ANANDUnitNo)LE4(volumeHeader->virtualUnits); /* In Units */
     }
     binary = fp->binaryPartitionInfo;

     /* Add EXB area */
#ifdef WRITE_EXB_IMAGE
     if (fp->exbLen>0)
     {
        fp->exbLen  = roundToUnits(fp->exbLen);
        goodBlocks += (ANANDUnitNo)fp->exbLen;
        tffscpy(exbSign,SIGN_SPL,BINARY_SIGNATURE_NAME);
        tffsset(exbSign+BINARY_SIGNATURE_NAME,'F',BINARY_SIGNATURE_NAME);
        if (fp->noOfBinaryPartitions > 0)  /* Add firmware blocks */
        {
           toLE4(((BNANDVolumeHeaderRecord*)firstVolumePtr)->virtualUnits,
                 LE4(((BNANDVolumeHeaderRecord*)firstVolumePtr)->virtualUnits)
           + fp->exbLen);
        }
        else /* Must create a binary partition just for firmware */
        {
           fp->noOfBinaryPartitions          = 1;
           toLE4(volumeHeader->virtualUnits,fp->exbLen  );
#ifdef HW_PROTECTION
           if(noOfBinary) /* Do not use binary record unless it was allocated */
           {
              toLE4(volumeHeader->flags       ,INFTL_BINARY |
                                               binary->protectionType);
              exbBinaryPartition.protectionType = binary->protectionType;
           }
           else
#endif /* HW_PROTECTION */
              toLE4(volumeHeader->flags       ,INFTL_BINARY);
           binary                            = &exbBinaryPartition;
           volumeHeader++;
           noOfVolumes++;
        }
        fp->exbLen <<= vol.blockMultiplierBits;
     }
#endif /* WRITE_EXB_IMAGE */
     toLE4(mediaHeader->noOfBinaryPartitions, fp->noOfBinaryPartitions);
  }

  binaryUnitsInFloor = goodBlocks % floorGarantiedUnits[0];
  lastBinaryFloor    = goodBlocks / floorGarantiedUnits[0];
  goodBlocks        += noOfFloors;

  /********************************/
  /* Construct Main media header  */
  /********************************/

  tffscpy(mediaHeader->bootRecordId,"BNAND", TL_SIGNATURE);
  tffscpy(&(mediaHeader->osakVersion),TrueFFSVersion,sizeof(TrueFFSVersion));
  toLE4(mediaHeader->percentUsed        , fp->percentUse         );
  toLE4(mediaHeader->blockMultiplierBits , vol.blockMultiplierBits);
  toLE4(mediaHeader->formatFlags        , 0                      );
  toLE4(mediaHeader->noOfBDTLPartitions , fp->noOfBDTLPartitions );
/* noOfBinaryPartitions was already determinded */

  /**********************************/
  /* Construct BDTL volumes headers */
  /**********************************/

  for (volumeNo=1;(byte)volumeNo<LE4(mediaHeader->noOfBDTLPartitions);
       bdtl++,volumeNo++,volumeHeader++)
  {
     if (bdtl->length < flash->erasableBlockSize)
     {
        DFORMAT_PRINT(("ERROR - INFTL partition length should not be least one unit long.\r\n"));
        dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
        return flBadParameter;
     }
     toLE4(volumeHeader->virtualUnits        , roundToUnits(bdtl->length));
     toLE4(volumeHeader->spareUnits          , bdtl->noOfSpareUnits      );
     toLE4(volumeHeader->flags               , INFTL_BDTL                );
     goodBlocks += (ANANDUnitNo)LE4(volumeHeader->virtualUnits) + bdtl->noOfSpareUnits;
#ifdef HW_PROTECTION
     toLE4(volumeHeader->flags,LE4(volumeHeader->flags) |
                               bdtl->protectionType);
#endif /* HW_PROTECTION */
#ifdef QUICK_MOUNT_FEATURE
/*     if (fp->flags & TL_QUICK_MOUNT_FORMAT) */
     {
        dword quickMountBytes;

        quickMountBytes  = (ANANDUnitNo)(LE4(volumeHeader->virtualUnits) +
                           LE4(volumeHeader->spareUnits));
        quickMountBytes += ((quickMountBytes / noOfUnitsPerFloor[0] + 1) *
                           noOfUnitsPerFloor[0] * (100L-fp->percentUse) / 100L);
        quickMountBytes *= RAM_FACTOR;
        quickMountBytes += flash->pageSize;
        quickMount[volumeNo-1] = roundToUnits(quickMountBytes);
        goodBlocks += quickMount[volumeNo-1];
     }
#endif /* QUICK_MOUNT_FEATURE */
  }

  /* The size of the last partition is defined by the media itself */

  goodBlocks                             += fp->noOfSpareUnits;
  for(index=0,floorNo=0;floorNo<noOfFloors;floorNo++)
  {
    index+=floorGarantiedUnits[floorNo];
  }
  toLE4(volumeHeader->flags               , INFTL_BDTL | INFTL_LAST);
  toLE4(volumeHeader->spareUnits          , fp->noOfSpareUnits     );
  toLE4(volumeHeader->lastUnit            , vol.noOfUnits-1);
  toLE4(volumeHeader->virtualUnits        , index + noOfFloors - goodBlocks);
#ifdef QUICK_MOUNT_FEATURE
/*  if (fp->flags & TL_QUICK_MOUNT_FORMAT) */
  {
     dword quickMountBytes;

     quickMountBytes  = (ANANDUnitNo)(LE4(volumeHeader->virtualUnits) +
                        LE4(volumeHeader->spareUnits));
     quickMountBytes += ((quickMountBytes / noOfUnitsPerFloor[0] + 1) *
                        noOfUnitsPerFloor[0] * (100L-fp->percentUse) / 100L);
     quickMountBytes *= RAM_FACTOR;
     quickMountBytes += flash->pageSize;

     toLE4(mediaHeader->formatFlags   , QUICK_MOUNT);
     quickMount[volumeNo-1]      = roundToUnits(quickMountBytes);
     toLE4(volumeHeader->virtualUnits , LE4(volumeHeader->virtualUnits) -
                                        quickMount[volumeNo-1]);
  }
#endif /* QUICK_MOUNT_FEATURE */

  if ((LE4(volumeHeader->virtualUnits) < 1) ||
      (LE4(volumeHeader->virtualUnits) > vol.noOfUnits))
  {
     DFORMAT_PRINT(("ERROR - Partition lengths could not be placed on the media.\r\n"));
     dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
     return flVolumeTooSmall;
  }

  /*******************************************/
  /* Allocate protection area to the volumes */
  /*******************************************/

#ifdef HW_PROTECTION
  toLE4(volumeHeader->flags,LE4(volumeHeader->flags) | /* Ignore other flags */
                            fp->protectionType);

  for (volumeNo = noOfVolumes,
       volumeHeader = (BNANDVolumeHeaderRecord *)firstVolumePtr;
       volumeNo>0;volumeNo--,volumeHeader++)
  {
     if (LE4(volumeHeader->flags) & PROTECTABLE)
     {
        if (flash->protectionSet == NULL)
        {
           DFORMAT_PRINT(("ERROR - setting protection routines are not available.\r\n"));
           dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
           return flFeatureNotSupported;
        }
        if (LE4(volumeHeader->flags) & CHANGEABLE_PROTECTION) /* last areas (n,n-1,n-2..)*/
        {
           changeableProtection++; /* Number of protected partitions */
           toLE4(volumeHeader->protectionArea ,
                 flash->totalProtectedAreas - changeableProtection);
        }
        else /* first areas (0,1,2,..) */
        {
           toLE4(volumeHeader->protectionArea , unchangeableProtection);
           unchangeableProtection++;
        }
     }
  }

  /* Make sure the device support enough protected areas */

  if ((changeableProtection   > flash->changeableProtectedAreas) ||
      (unchangeableProtection + changeableProtection >
       flash->totalProtectedAreas))
  {
     DFORMAT_PRINT(("ERROR - too many protected areas.\r\n"));
     dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
     return flBadParameter;
  }

  /* Clear previous protection areas and write protect them */

  for (index=0;index<flash->totalProtectedAreas;index++)
  {
     /* Send default key to open all protected areas */
     status = flash->protectionKeyInsert(flash,(byte)index,(byte FAR1 *)DEFAULT_KEY);
  }

  /* Clear all floors execpt for those that have only binary partitions */
  for (floorNo=skipedUnits/floorGarantiedUnits[0];floorNo<noOfFloors;floorNo++)
  {
     for (index=0;index<flash->totalProtectedAreas;index++)
     {
        if(binaryFloorOfDPS[index] == floorNo)
           break; /* Belongs to a binary partition that must be left */
        status = flash->protectionSet(flash,(byte)index,
                 WRITE_PROTECTED,                           /* Write protect */
                 (index+1) << flash->erasableBlockSizeBits, /* Low address   */
                 (index+1) << flash->erasableBlockSizeBits, /* High address  */
                 (byte *)DEFAULT_KEY,DO_NOT_COMMIT_PROTECTION,floorNo);
        if (status != flOK)
        {
           DFORMAT_PRINT(("ERROR - FAILED clearing previous protection areas.\r\n"));
           dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
           return status;
        }
     }
  }
#endif /* HW_PROTECTION */

  /***********************************/
  /* Actual format of the partitions */
  /***********************************/

  DEBUG_PRINT(("Debug: INFTL format arguments have been verified, starting format.\r\n"));

  unitsNeededForVolume = 0;
  floorNo      = skipedUnits / floorGarantiedUnits[0];
  volumeNo     = -1;                  /* bdtl volume number */
  bdtl         = fp->BDTLPartitionInfo;
  iUnit        = originalUnits[floorNo]+1;  /* write after the first header */
  volumeHeader = (BNANDVolumeHeaderRecord *) firstVolumePtr; /* location of first partition header */
  floorGarantiedUnitsLeft = floorGarantiedUnits[floorNo]; /* floors units left */

  /* Skip the boot image area if the FL_LEAVE_BINARY_AREA was set */

  if (skipedUnits > 0 )
  {
     skipedUnits %= floorGarantiedUnits[0]; /* skipped units on the current floor */
     floorGarantiedUnitsLeft -= skipedUnits; /* floors units left */
     volumeHeader += (word)LE4(mediaHeader->noOfBinaryPartitions);
     sizeOfLastBinary = LE4((volumeHeader-1)->virtualUnits);

     /* Clear previous BDTL entries and adjust binary partition */
     for (index = 0 ; index < floorNo ; index++)
     {
        /* read previous floor header */
        status = flash->read(flash,((CardAddress)originalUnits[index]
                    << vol.unitSizeBits) + sizeof(BNANDBootRecord),
                    firstVolumePtr, sizeof(BNANDVolumeHeaderRecord) *
                    (fp->noOfBinaryPartitions) ,0);

        if(status != flOK)
        {
           DFORMAT_PRINT(("ERROR - FAILED reading previous INFTL header.\r\n"));
           dismountINFTL(&vol); /*Free tables must be done after call to initTables*/
           return status;
        }
        toLE4((volumeHeader-1)->virtualUnits , sizeOfLastBinary); /* adjust virtual size */
        if((index == (dword)(floorNo - 1)) && (skipedUnits == 0))
           toLE4((volumeHeader-1)->lastUnit , ((index+1) * noOfUnitsPerFloor[0]) - 1); /* adjust last block */

        /* Erase and write the new updated header */
        status = eraseUnit(&vol,originalUnits[index],fp->progressCallback);
        if(status != flOK)
        {
           DFORMAT_PRINT(("ERROR - FAILED erasing previous INFTL header.\r\n"));
           return status;
        }
        for (temp = 0 ; temp < NO_OF_MEDIA_HEADERS ; temp++)
        {
           status = flash->write(flash,((CardAddress)originalUnits[index]
                    << vol.unitSizeBits) + temp * HEADERS_SPACING,
                    headersBuffer, sizeof(headersBuffer),EDC);
           if (status != flOK)
           {
              DFORMAT_PRINT(("ERROR - FAILED rewriting INFTL header.\r\n"));
              dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
              return status;
           }
        }
     }

     /* Skip to first BDTL block */
     for (;skipedUnits > 0;skipedUnits--)
     {
        do
        {
           iUnit++;
        }while (vol.physicalUnits[iUnit] == UNIT_BAD);
     }

     /* Save last binary unit for floors header */
     if(iUnit != originalUnits[floorNo]+1)
        toLE4((volumeHeader-1)->lastUnit , iUnit - 1); /* adjust last block */
  }

  do /* loop over floors */
  {
     goodBlocks = goodUnits[floorNo]; /* Good blocks of the floor */

     /* Format as many volumes as posible in this floor */

     while((floorGarantiedUnitsLeft > 0) && (noOfVolumes >= 0))
     {
        if (unitsNeededForVolume == 0) /* Read header of next volume */
        {
           noOfVolumes--;
           toLE4(volumeHeader->firstQuickMountUnit , iUnit);
           unitsNeededForVolume = (ANANDUnitNo)(LE4(volumeHeader->virtualUnits) +
                                  LE4(volumeHeader->spareUnits));
#ifdef QUICK_MOUNT_FEATURE
           if (LE4(volumeHeader->flags) & INFTL_BDTL)
           {
              volumeNo++;
              unitsNeededForVolume +=quickMount[volumeNo];
           }
#else
           toLE4(volumeHeader->firstUnit , iUnit);
#endif /* QUICK_MOUNT_FEATURE */

      /* Copy protection key and type */

#ifdef HW_PROTECTION
           if (LE4(volumeHeader->flags) & INFTL_BDTL)
           {
              if (LE4(volumeHeader->flags) & INFTL_LAST)
              {
                 tffscpy(protectionKey,fp->protectionKey,PROTECTION_KEY_LENGTH);
                 protectionType = fp->protectionType;
              }
              else
              {
                 tffscpy(protectionKey,bdtl->protectionKey,PROTECTION_KEY_LENGTH);
                 protectionType = bdtl->protectionType;
              }
           }
           else /* Binary */
           {
              tffscpy(protectionKey,binary->protectionKey,PROTECTION_KEY_LENGTH);
              protectionType = binary->protectionType;
           }
#endif /* HW_PROTECTION */
        }

        /* update format indexs. */

        if (unitsNeededForVolume > floorGarantiedUnitsLeft)
        {
           /* Volume does not fits in floor */
           index                    = floorGarantiedUnitsLeft;
           unitsNeededForVolume    -= floorGarantiedUnitsLeft;
           floorGarantiedUnitsLeft  = 0;
        }
        else
        {
           /* Entire volume fits in floor */
           index                    = unitsNeededForVolume;
           floorGarantiedUnitsLeft -= unitsNeededForVolume;
           unitsNeededForVolume     = 0;
        }

        /*******************************************/
        /* Format the volumes blocks of this floor */
        /*******************************************/

#ifdef HW_PROTECTION
        volumeStart = iUnit;
#endif /* HW_PROTECTION */
        if (LE4(volumeHeader->flags) & INFTL_BDTL) /* BDTL VOLUME FORMAT   */
        {
           /* Add transfer units */

           if (floorNo == lastBinaryFloor)
           {
              index *= (goodBlocks - binaryUnitsInFloor);
              index /= (floorGarantiedUnits[floorNo] - binaryUnitsInFloor);
           }
           else
           {
              index *= goodBlocks;
              index /= floorGarantiedUnits[floorNo];
           }

           /* Format units */

           while (index > 0)
           {
              if (vol.physicalUnits[iUnit] == ANAND_UNIT_FREE)
              {
#ifdef QUICK_MOUNT_FEATURE
                 /* Set the real first unit after the quick mount data */

                 if (quickMount[volumeNo] >= 0)
                 {
                    if(quickMount[volumeNo] == 0)
                    {
                       toLE4(volumeHeader->firstUnit , iUnit);
                    }
                    (quickMount[volumeNo])--;
                 }
#endif /* QUICK_MOUNT_FEATURE */
                 index--;
                 status = eraseUnit(&vol, iUnit,fp->progressCallback);
                 if(status != flOK)
                    return status;
              }
              else
              {
                 if (fp->progressCallback)
                 {
                    (*fp->progressCallback)((word)(flash->noOfChips *
                    (flash->chipSize >> vol.unitSizeBits)),(word)(iUnit+1));
                 }
              }
              iUnit++;
           }
           if (unitsNeededForVolume == 0)
              bdtl++;
        }
        if (LE4(volumeHeader->flags) & INFTL_BINARY) /* BINARY VOLUME FORMAT */
        {
           toLE4(volumeHeader->firstUnit , LE4(volumeHeader->firstQuickMountUnit));
           for (; (index > 0) ; iUnit++)
           {
              if (vol.physicalUnits[iUnit] == ANAND_UNIT_FREE)
              {
                 index--;
                 status = eraseUnit(&vol, iUnit,fp->progressCallback);
                 if(status != flOK)
                    return status;

                 for (iBlock=0;iBlock<(1UL<<vol.unitSizeBits);iBlock+=(1L<<vol.erasableBlockSizeBits))
                 {
#ifdef WRITE_EXB_IMAGE
                    if (fp->exbLen > 0)
                    {
                       fp->exbLen--;
                       status = flash->write(flash, 8 + iBlock +
                         ((CardAddress)(iUnit) << vol.unitSizeBits),
                         exbSign,BINARY_SIGNATURE_LEN,EXTRA);
                    }
                    else
#endif /* WRITE_EXB_IMAGE */
                    {
                       status = flash->write(flash, binary->signOffset + iBlock +
                         ((CardAddress)(iUnit) << vol.unitSizeBits),
                         binary->sign,BINARY_SIGNATURE_NAME,EXTRA);
                    }
                    if (status != flOK)
                    {
                       DFORMAT_PRINT(("ERROR - FAILED formating binary unit.\r\n"));
                       dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
                       return status;
                    }
                 }
              }
              else                   /* unit is bad */
              {
                 if (fp->progressCallback)
                 {
                    (*fp->progressCallback)((word)(flash->noOfChips *
                    (flash->chipSize >> vol.unitSizeBits)),(word)(iUnit+1));
                 }
              }
           }
           if (unitsNeededForVolume == 0)
              binary++;
        }
#ifdef HW_PROTECTION

        /* Place protection attributes to the volume */

        if (LE4(volumeHeader->flags) & PROTECTABLE)
        {

#ifndef NT5PORT
            status = flash->protectionSet(flash,(byte)LE4(volumeHeader->protectionArea),
              protectionType, ((CardAddress)volumeStart %
              noOfUnitsPerFloor[floorNo]) << vol.unitSizeBits,
              ((CardAddress)((iUnit-1) % noOfUnitsPerFloor[floorNo])) << vol.unitSizeBits ,
              (byte *)&protectionKey,DO_NOT_COMMIT_PROTECTION,floorNo);
#else  /*NT5PORT*/
           status = flash->protectionSet(flash,(byte)LE4(volumeHeader->protectionArea),
              protectionType, ((CardAddress)volumeStart %
              noOfUnitsPerFloor[floorNo]) << vol.unitSizeBits,
              ((CardAddress)((iUnit-1) % noOfUnitsPerFloor[floorNo])) << vol.unitSizeBits ,
              protectionKey,DO_NOT_COMMIT_PROTECTION,floorNo);
#endif /*NT5PORT*/

           if (status != flOK)
           {
              DFORMAT_PRINT(("ERROR - FAILED setting protection.\r\n"));
              dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
              return status;
           }
        }
#endif /* HW_PROTECTION */

        if (unitsNeededForVolume == 0)
        {
           toLE4(volumeHeader->lastUnit , iUnit - 1);
           volumeHeader++;
        }
     } /* loop until no more units in this floor */

     /* Convert any leftovers to BDTL units */

     index = noOfUnitsPerFloor[floorNo] + floorNo*noOfUnitsPerFloor[0];
     while (iUnit < index)
     {
        if (vol.physicalUnits[iUnit] == ANAND_UNIT_FREE)
        {
           status = eraseUnit(&vol, iUnit,fp->progressCallback);
           if(status != flOK)
              return status;
        }
        else
        {
           if (fp->progressCallback)
           {
              (*fp->progressCallback)((word)(flash->noOfChips *
              (flash->chipSize >> vol.unitSizeBits)),(word)(iUnit+1));
           }
        }
        iUnit++;
     }

     /* Update last unit of BDTL partition */
     if ((unitsNeededForVolume == 0) &&
         (LE4((volumeHeader-1)->flags) & INFTL_BDTL))
     {
        toLE4((volumeHeader-1)->lastUnit , iUnit-1);
     }

     /***************************/
     /* Place the floors header */
     /***************************/

     iUnit = originalUnits[floorNo];

     status = eraseUnit(&vol, iUnit,NULL);
     if(status != flOK)
        return status;

     for (index = 0 ; index < NO_OF_MEDIA_HEADERS;index++)
     {
        status = flash->write(flash,((CardAddress)iUnit << vol.unitSizeBits)
                              + index * HEADERS_SPACING,headersBuffer,
                              sizeof(headersBuffer),EDC);
        if (status != flOK)
        {
           DFORMAT_PRINT(("ERROR - FAILED writing INFTL header.\r\n"));
           dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
           return status;
        }
     }

     /**************************/
     /* Prepare next iteration */
     /**************************/

     floorNo++;
     if (floorNo < noOfFloors)
     {
        iUnit=originalUnits[floorNo]+1;
        floorGarantiedUnitsLeft = floorGarantiedUnits[floorNo];

        /* Erase physical unit locations to enable independet unit headers */

        volumeHeader2 = (BNANDVolumeHeaderRecord *) firstVolumePtr; /* location of first partition header */
        while (volumeHeader2<=volumeHeader)
        {
           toLE4(volumeHeader2->firstUnit           , 0);
           toLE4(volumeHeader2->lastUnit            , 0);
           toLE4(volumeHeader2->firstQuickMountUnit , 0);
           volumeHeader2++;
        }
     }
     else
     {
        break;
     }
  } while (1); /* loop over floors */

  DEBUG_PRINT(("Debug: finished INFTL format.\r\n"));

  dismountINFTL(&vol);  /*Free tables must be done after call to initTables*/
  return flOK;
}

#endif /* FORMAT_VOLUME && not FL_READ_ONLY */

/*----------------------------------------------------------------------*/
/*                       f l R e g i s t e r I N F T L                  */
/*                                                                      */
/* Register this translation layer                                      */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failure               */
/*----------------------------------------------------------------------*/

FLStatus flRegisterINFTL(void)
{
#ifdef FL_MALLOC
  int i;
#endif /* FL_MALLOC */

  if (noOfTLs >= TLS)
    return flTooManyComponents;

  tlTable[noOfTLs].mountRoutine     = mountINFTL;
  tlTable[noOfTLs].preMountRoutine  = preMountINFTL;

#if (defined(FORMAT_VOLUME) && !defined(FL_READ_ONLY))
  tlTable[noOfTLs].formatRoutine = formatINFTL;
#else
  tlTable[noOfTLs].formatRoutine = noFormat;
#endif /* FORMAT_VOLUME && not FL_READ_ONLY */
  noOfTLs++;

#ifdef FL_MALLOC
  /* reset multi sector buffer */
  for(i=0;( i < SOCKETS );i++) {
    multiSectorBufCounter[i] = -1;
  }
  /* reset convertion tables */
  for(i=0;( i < VOLUMES );i++) {
    vols[i].physicalUnits = NULL;
    vols[i].virtualUnits = NULL;
#ifdef NFTL_CACHE
  /* reset catche tables */
    vols[i].ucache = NULL;
    vols[i].scache = NULL;
#endif /* NFTL_CACHE */
  }
#endif /* FL_MALLOC */
  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\osak.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/OSAK.H_V  $
 * 
 *    Rev 1.1   Apr 01 2001 07:46:32   oris
 * Updated copywrite notice
 * 
 *    Rev 1.0   Feb 04 2001 12:35:48   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*		DiskOnChip 2000 O/S Adaptation Kit			*/
/*		Copyright (C) M-Systems Ltd. 1998			*/
/*									*/
/************************************************************************/


#ifndef OSAK_H
#define OSAK_H

#include "blockdev.h"
#include "dosformt.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\nfdc2148.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/NFDC2148.H_V  $
 * 
 *    Rev 1.1   Apr 01 2001 07:46:42   oris
 * Updated copywrite notice
 * 
 *    Rev 1.0   Feb 04 2001 12:40:46   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*		FAT-FTL Lite Software Development Kit			*/
/*              Copyright (C) M-Systems Ltd. 1995-2001                  */
/*									*/
/************************************************************************/
#ifndef NFDC2148_H
#define NFDC2148_H

#include "diskonc.h"

#endif /* NFDC2148_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\ntioctl.h ===
#ifndef _NTIOCTL_H_
#define _NTIOCTL_H_

#include <ntddk.h>
#include "flioctl.h"

#define FILE_DEVICE_TFFS_IOCTL		0x8000
#define ACCESS_DEVICE_TFFS_IOCTL	0x800


#define IOCTL_TFFS_GET_INFO										\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_GET_INFO),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_DEFRAGMENT									\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_DEFRAGMENT),		\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_WRITE_PROTECT								\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_WRITE_PROTECT),	\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_MOUNT_VOLUME									\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_MOUNT_VOLUME),		\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_FORMAT_VOLUME								\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_FORMAT_VOLUME),	\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_BDK_OPERATION								\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_BDK_OPERATION),	\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_DELETE_SECTORS								\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_DELETE_SECTORS),	\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_READ_SECTORS									\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_READ_SECTORS),		\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_WRITE_SECTORS								\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_WRITE_SECTORS),	\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_NUMBER_OF_PARTITIONS									\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_NUMBER_OF_PARTITIONS),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_CUSTOMER_ID									\
	CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_CUSTOMER_ID),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_EXTENDED_WRITE_IPL									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_EXTENDED_WRITE_IPL),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_EXTENDED_ENVIRONMENT_VARIABLES),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFSFL_UNIQUE_ID									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_UNIQUE_ID),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFSFL_INQUIRE_CAPABILITIES									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_INQUIRE_CAPABILITIES),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_DEEP_POWER_DOWN_MODE									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_DEEP_POWER_DOWN_MODE),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,							\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_FORMAT_PHYSICAL_DRIVE),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_BDTL_HW_PROTECTION									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,												\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_BDTL_HW_PROTECTION),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_BINARY_HW_PROTECTION									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,												\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_BINARY_HW_PROTECTION),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_OTP									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,												\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_OTP),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_PLACE_EXB_BY_BUFFER									\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,												\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_PLACE_EXB_BY_BUFFER),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES				\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,												\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_EXTENDED_ENVIRONMENT_VARIABLES),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#define IOCTL_TFFS_VERIFY_VOLUME				\
CTL_CODE( FILE_DEVICE_TFFS_IOCTL,												\
		(ACCESS_DEVICE_TFFS_IOCTL + FL_IOCTL_VERIFY_VOLUME),			\
		METHOD_BUFFERED, FILE_ANY_ACCESS )

#endif /* _NTIOCTL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\nanddefs.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/NANDDEFS.H_V  $
 * 
 *    Rev 1.9   Apr 15 2002 07:38:10   oris
 * Added 2 additional fields to mtdVars record for backwards compatibility (under RAM_MTD compilation flag) 
 *  -  unsigned short        pageSize;
 *  -  unsigned short        pageAndTailSize;
 * 
 *    Rev 1.8   Jan 20 2002 20:29:14   oris
 * Changed doc2000FreeWindow prototype to remove warnings.
 * Changed docPlusFreeWindow  prototype to remove warnings.
 * 
 *    Rev 1.7   Jan 17 2002 23:03:52   oris
 * Definitions for the new memory access routine mechanism
 *  - NDOC2window was moved from docsys.h
 *  - Add pointer to read back buffer when MTD_RECONSTRUCT_BBT and VERIFY_VOLUME compilation flags are defined.
 * Replaced flbuffer.h include with flflash.h
 * Changed win_io from unsigned to word.
 * Changed the use of vol (macro *pVol) to *flash in NFDC21thisVars.
 * 
 *    Rev 1.6   Sep 15 2001 23:47:50   oris
 * Added 128MB flash support
 * 
 *    Rev 1.5   Jul 13 2001 01:08:58   oris
 * Added readBackBuffer pointer for the VERIFY_WRITE Compilation flag.
 * 
 *    Rev 1.4   May 16 2001 21:21:14   oris
 * Change "data" named variables to flData to avoid name clashes.
 * 
 *    Rev 1.3   Apr 10 2001 16:43:40   oris
 * Added prototype of docSocketInit.
 * 
 *    Rev 1.2   Apr 01 2001 07:48:26   oris
 * Revised in order to support both  diskonchip 2000 family and doc plus family.
 * 
 *    Rev 1.1   Feb 07 2001 17:42:24   oris
 * removed MAX_FLASH_DEVICES_MDOC define since alone can support 16 chips
 *
 *    Rev 1.0   Feb 04 2001 12:26:10   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*                FAT-FTL Lite Software Development Kit                 */
/*                Copyright (C) M-Systems Ltd. 1995-2001                */
/*                                                                      */
/************************************************************************/
#ifndef NANDDEFS_H
#define NANDDEFS_H

#include "flflash.h"

typedef byte Reg8bitType;
typedef word Reg16bitType;

typedef struct {
#ifdef RAM_MTD
  unsigned short        pageSize;
  unsigned short        pageAndTailSize;
#endif /* RAM_MTD */
  unsigned short        vendorID;
  unsigned short        chipID;
  dword                 pageMask;        /* ...these............... */
  unsigned short        pageAreaSize;    /* .......variables....... */
  unsigned short        tailSize;        /* .............interleave */
  unsigned short        noOfBlocks;      /* total erasable blocks in flash device*/
  unsigned short        pagesPerBlock;
  unsigned char         currentFloor;    /*    0 .. totalFloors-1   */
  long                  floorSize;       /*    in bytes             */
  long                  floorSizeMask;
  byte                  floorSizeBits;
  byte                  if_cfg;          /* host access type        */
  unsigned short        flags;           /* bitwise: BIG_PAGE, SLOW_IO etc. */
  FLBuffer*             buffer;          /* buffer for map through buffer */
#if (defined(VERIFY_WRITE) || defined(VERIFY_ERASE) || defined(MTD_RECONSTRUCT_BBT) || defined(VERIFY_VOLUME))
  byte*                 readBackBuffer;  /* buffer for map through buffer */
#endif /* VERIFY_WRITE || VERIFY_ERASE || VERIFY_VOLUME */
  word                  win_io;          /* pointer to DOC CDSN_IO          */
  NDOC2window           win;             /* pointer to DOC memory window    */
} NFDC21Vars;

#define NFDC21thisVars   ((NFDC21Vars *) flash->mtdVars)
#define NFDC21thisWin    (NFDC21thisVars->win)
#define NFDC21thisIO     (NFDC21thisVars->win_io)
#define NFDC21thisBuffer (NFDC21thisVars->buffer->flData)

     /* Flash commands */

#define SERIAL_DATA_INPUT   0x80
#define READ_MODE           0x00
#define READ_MODE_2         0x50
#define RESET_FLASH         0xff
#define SETUP_WRITE         0x10
#define SETUP_ERASE         0x60
#define CONFIRM_ERASE       0xd0
#define READ_STATUS         0x70
#define READ_ID             0x90
#define SUSPEND_ERASE       0xb0
#define REGISTER_READ       0xe0

/* commands for moving flash pointer to areeas A,B or C of page */
typedef enum { AREA_A = READ_MODE, AREA_B = 0x1, AREA_C = READ_MODE_2 } PointerOp;

#define FAIL        0x01    /* error in block erase   */
#define EXTRA_LEN   8       /* In memory of 4MB chips */ 
#define SECTOR_EXTRA_LEN 16 

     /* Flash IDs*/

#define KM29N16000_FLASH    0xec64
#define KM29N32000_FLASH    0xece5
#define KM29V64000_FLASH    0xece6
#define KM29V128000_FLASH   0xec73
#define KM29V256000_FLASH   0xec75
#define KM29V512000_FLASH   0xec76

#define NM29N16_FLASH       0x8f64
#define NM29N32_FLASH       0x8fe5
#define NM29N64_FLASH       0x8fe6
#define TC5816_FLASH        0x9864
#define TC5832_FLASH        0x98e5
#define TC5864_FLASH        0x98e6
#define TC58128_FLASH       0x9873
#define TC58256_FLASH       0x9875
#define TC58512_FLASH       0x9876
#define TC581024_FLASH       0x9877

   /*******************************/
   /****   Exported routines   ****/
   /*******************************/

/* DiskOnChip 2000 family registration routines */
#ifndef MTD_STANDALONE
  extern FLBoolean checkWinForDOC(unsigned driveNo, NDOC2window memWinPtr);
#endif /* MTD_STANDALONE */
#ifndef MTD_FOR_EXB
  extern FLStatus flRegisterDOC2000(void);
  extern FLStatus flRegisterDOCSOC(dword lowAddress, dword highAddress);
#else
  FLStatus doc2000SearchForWindow(FLSocket * socket, dword lowAddress,
                                  dword highAddress);
  FLStatus doc2000Identify(FLFlash vol);
  void doc2000FreeWindow(FLSocket * socket);
#endif /* MTD_FOR_EXB */

/* DiskOnChip Plus family registration routines */ 
#ifndef MTD_STANDALONE
  extern FLBoolean checkWinForDOCPLUS(unsigned driveNo, NDOC2window memWinPtr);
  extern void docSocketInit(FLSocket vol);
#endif /* MTD_STANDALONE */
#ifndef MTD_FOR_EXB
  extern FLStatus flRegisterDOCPLUS(void);
  extern FLStatus flRegisterDOCPLUSSOC(dword lowAddress, dword highAddress);
#else
  FLStatus docPlusSearchForWindow(FLSocket * socket, dword lowAddress,
                                  dword highAddress);
  FLStatus docPlusIdentify(FLFlash vol);
  void docPlusFreeWindow(FLSocket * socket);
#endif /* MTD_FOR_EXB */

#endif /* NANDDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\nftllite.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/NFTLLITE.H_V  $
 * 
 *    Rev 1.6   Apr 15 2002 07:38:34   oris
 * Added the following fields to Anand record - 
 *  - verifyBuffer pointer.
 *  - invalidReplacement.
 * Added support for VERIFY_ERASED_SECTOR compilation flag.
 * 
 *    Rev 1.5   Jan 28 2002 21:26:20   oris
 * Removed the use of back-slashes in macro definitions.
 * 
 *    Rev 1.4   Jan 17 2002 23:04:34   oris
 * Added SECTORS_VERIFIED_PER_FOLDING - defines the number of sectors  verified per folding when using FL_OFF verify write mode
 * Added DOUBLE_MAX_UNIT_CHAIN instead of MAX_UNIT_CHAIN*2
 * Added MAX_FOLDING_TRIES - For improved power failures algorithm
 * Added S_CACHE_4_SECTORS_FREE for quicker cache initialization.
 * Added new macros :
 *  - distanceOf : Counting bit difference between 2 bytes.
 *  - isValidSectorFlags : one of the valid sector flags (not including  IGNORE)
 * Changed Anand record :
 *  - Added socketNo field storing the socket number used by the TL.
 *  - Changed RAM tables pointer to FAR1 for BIOS driver far malloc.
 *  - Changed FLFlash record to a pointer (TrueFFS now uses a single  FLFlash record per socket).
 *  - Added verifiedSectorNo and curSectorWrite fields for FL_OFF verify  write mode.
 * 
 *    Rev 1.3   May 16 2001 21:21:34   oris
 * Added the FL_ prefix to the following defines: MALLOC and FREE.
 * Changed wear level counter from 0xFF to 0xFFF0
 * Change "data" named variables to flData to avoid name clashes.
 * 
 *    Rev 1.2   Apr 01 2001 07:52:36   oris
 * copywrite notice.
 * Alligned left all # directives.
 * 
 *    Rev 1.1   Feb 14 2001 02:05:30   oris
 * Changed MAX_CHAIN_LENGTH to an environment variable.
 *
 *    Rev 1.0   Feb 05 2001 12:26:30   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/


#ifndef NFTLLITE_H
#define NFTLLITE_H

#include "flbuffer.h"
#include "flflash.h"
#include "fltl.h"

typedef long int ANANDVirtualAddress;
typedef unsigned char ANANDPhysUnit;
typedef unsigned short ANANDUnitNo;

#define ANAND_UNASSIGNED_ADDRESS     0xffffffffl
#define ANAND_SPARE_SIZE             16

#define UNIT_DATA_OFFSET             8
#define SECTOR_DATA_OFFSET           6
#define UNIT_TAILER_OFFSET           (SECTOR_SIZE + 8)
#define FOLD_MARK_OFFSET             (2 * SECTOR_SIZE + 8)

#define ERASE_MARK                   0x3c69

#ifdef ENVIRONMENT_VARS
#define SECTORS_VERIFIED_PER_FOLDING flSectorsVerifiedPerFolding
#define MAX_UNIT_CHAIN               flMaxUnitChain
#else
#define SECTORS_VERIFIED_PER_FOLDING 64
#define MAX_UNIT_CHAIN               20
#endif /* ENVIRONMENT_VARS */
#define DOUBLE_MAX_UNIT_CHAIN        64 /* Double max unit chain */
#define MAX_FOLDING_TRIES            20

#define ANAND_UNIT_FREE 0xff
#define UNIT_REPLACED   0x80
#define UNIT_COUNT      0x7f
#define UNIT_ORPHAN     0x10

#define UNIT_UNAVAIL    0x6a    /* Illegal count denoting unit not available */
#define UNIT_BAD_MOUNT  0x6b    /* Bad unit sign after mount */

#define UNIT_MAX_COUNT  0x40    /* Largest valid count */

#define IS_BAD(u)       ( u == UNIT_BAD_MOUNT )

#define UNIT_BAD_ORIGINAL 0

#define distanceOf(read, expected) (onesCount((byte)(read ^ expected)))
#define isValidSectorFlag(sectorFlag) ((sectorFlag==SECTOR_FREE)||(sectorFlag==SECTOR_USED)||(sectorFlag==SECTOR_DELETED))
#define countOf(unitNo)     (vol.physicalUnits[unitNo] & UNIT_COUNT)
#define isAvailable(unitNo) ((vol.physicalUnits[unitNo] == ANAND_UNIT_FREE) || (vol.physicalUnits[unitNo] == (ANAND_UNIT_FREE & ~UNIT_ORPHAN)) || (countOf(unitNo) <= UNIT_MAX_COUNT))
#define setUnavail(unitNo)  {vol.physicalUnits[unitNo] &= ~UNIT_COUNT; vol.physicalUnits[unitNo] |= UNIT_UNAVAIL; }
#define isReplaced(unitNo)  (vol.physicalUnits[unitNo] & UNIT_REPLACED)
#define setUnitCount(unitNo,unitCount) { vol.physicalUnits[unitNo] &= ~UNIT_COUNT; vol.physicalUnits[unitNo] |= (ANANDPhysUnit)unitCount; }
#define isLegalUnit(unitNo)  ((unitNo < vol.noOfUnits) || (unitNo == ANAND_NO_UNIT))

#define MAX_UNIT_SIZE_BITS      15
#define MORE_UNIT_BITS_MASK     3
#define ANAND_BAD_PERCENTAGE    2
#define ANAND_NO_UNIT           0xffff
#define ANAND_REPLACING_UNIT    0x8000

#define MAX_UNIT_NUM            (12 * 1024)


/* Block flags */

#define SECTOR_FREE             0xff
#define SECTOR_USED             0x55
#define SECTOR_IGNORE           0x11
#define SECTOR_DELETED          0x00


#ifdef NFTL_CACHE
/* values for 2-bit entries in Sector Flags cache */
#define S_CACHE_SECTOR_DELETED  0x00
#define S_CACHE_SECTOR_IGNORE   0x01
#define S_CACHE_SECTOR_USED     0x02
#define S_CACHE_SECTOR_FREE     0x03
#define S_CACHE_4_SECTORS_FREE  0xff
#endif /* NFTL_CACHE */


#define FOLDING_IN_PROGRESS     0x5555
#define FOLDING_COMPLETE        0x1111

#define ERASE_NOT_IN_PROGRESS   -1

#ifdef NFTL_CACHE
/* Unit Header cache entry, close relative of struct UnitHeader */
typedef struct {
  unsigned short virtualUnitNo;
  unsigned short replacementUnitNo;
} ucacheEntry;

#endif /* NFTL_CACHE */

/* erase record */
typedef struct {
  LEulong  eraseCount;
  LEushort eraseMark;
  LEushort eraseMark1;
} UnitTailer;

/* unit header  */
typedef struct {
  LEushort virtualUnitNo;
  LEushort replacementUnitNo;
  LEushort spareVirtualUnitNo;
  LEushort spareReplacementUnitNo;
} ANANDUnitHeader;

/* Medium Boot Record */

typedef struct {
  char      bootRecordId[6];          /* = "ANAND" */
  LEushort  noOfUnits;
  LEushort  bootUnits;
  Unaligned4 virtualMediumSize;
#ifdef EXTRA_LARGE
  unsigned char anandFlags;
#endif /* EXTRA_LARGE */
} ANANDBootRecord;

#ifndef FL_MALLOC

#define ANAND_HEAP_SIZE    (0x100000l / ASSUMED_NFTL_UNIT_SIZE) * (sizeof(ANANDUnitNo) + sizeof(ANANDPhysUnit)) * MAX_VOLUME_MBYTES

#ifdef NFTL_CACHE
#define U_CACHE_SIZE    ((MAX_VOLUME_MBYTES * 0x100000l) / ASSUMED_NFTL_UNIT_SIZE)
#define S_CACHE_SIZE    ((MAX_VOLUME_MBYTES * 0x100000l) / (SECTOR_SIZE * 4))
#endif

#endif /* FL_MALLOC */

#define WLnow           0xfff0

typedef struct {
  unsigned short alarm;
  ANANDUnitNo currUnit;
} WLdata;

struct tTLrec{
  byte            socketNo;
  FLBoolean       badFormat;             /* true if TFFS format is bad  */

  ANANDUnitNo     orgUnit,               /* Unit no. of boot record     */
                  spareOrgUnit;          /* ... and spare copy of it    */
  ANANDUnitNo     freeUnits;             /* Free units on media         */
  unsigned int    erasableBlockSizeBits; /* log2 of erasable block size */
  ANANDUnitNo     noOfVirtualUnits;
  ANANDUnitNo     noOfTransferUnits;
  unsigned long   unitOffsetMask;        /* = 1 << unitSizeBits - 1 */
  unsigned int    sectorsPerUnit;

  ANANDUnitNo     noOfUnits,
                  bootUnits;
  unsigned int    unitSizeBits;
  SectorNo        virtualSectors;

  ANANDUnitNo     roverUnit,   /* Starting point for allocation search  */
                  countsValid; /* Number of units with valid unit count */
  ANANDPhysUnit FAR1 *physicalUnits;    /* unit table by physical no. */
  ANANDUnitNo   FAR1 *virtualUnits;     /* unit table by logical no.  */

#ifdef NFTL_CACHE
  ucacheEntry   FAR1 *ucache;            /* Unit Header cache  */
  byte          FAR1 *scache;            /* Sector Flags cache */
#endif

  SectorNo        mappedSectorNo;
  const void FAR0 *mappedSector;
  CardAddress     mappedSectorAddress;
#if (defined(VERIFY_WRITE) || defined(VERIFY_VOLUME) || defined(VERIFY_ERASED_SECTOR))
  SectorNo        verifiedSectorNo;   /* Largest sector verified so far */
  SectorNo        curSectorWrite;
#endif /* VERIFY_WRITE || VERIFY_VOLUME || VERIFY_ERASED_SECTOR */

  /* Accumulated statistics. */
  long int        sectorsRead,
                  sectorsWritten,
                  sectorsDeleted,
                  parasiteWrites,
                  unitsFolded;

  FLFlash         *flash;
  FLBuffer        *buffer;
  dword           *verifyBuffer;  /* Pointer to socket verify buffer */

#ifndef FL_MALLOC
  char            heap[ANAND_HEAP_SIZE];
#ifdef NFTL_CACHE
  ucacheEntry     ucacheBuf[U_CACHE_SIZE];
  unsigned char   scacheBuf[S_CACHE_SIZE];
#endif
#endif /* FL_MALLOC */

  WLdata          wearLevel;
  unsigned long   eraseSum;
  ANANDUnitNo     invalidReplacement; /* Unit with bad header - for mount */
};

typedef TLrec Anand;

#define nftlBuffer  vol.buffer->flData

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\nfdc2048.c ===
/*
 * $Log:   P:/user/amir/lite/vcs/nfdc2048.c_v  $
 *
 *    Rev 1.28   19 Oct 1997 15:41:54   danig
 * Changed tffscpy16 and tffsset16 for far pointers &
 * cast to FAR0 in mapContInterface
 *
 *    Rev 1.27   06 Oct 1997 18:37:34   ANDRY
 * no COBUX
 *
 *    Rev 1.26   06 Oct 1997 18:04:34   ANDRY
 * 16-bit access only for interleave 2 cards, COBUX
 *
 *    Rev 1.25   05 Oct 1997 12:02:32   danig
 * Support chip ID 0xEA
 *
 *    Rev 1.24   10 Sep 1997 16:14:08   danig
 * Got rid of generic names
 *
 *    Rev 1.23   08 Sep 1997 17:47:00   danig
 * fixed setAddress for big-endian
 *
 *    Rev 1.22   04 Sep 1997 13:59:44   danig
 * Debug messages
 *
 *    Rev 1.21   31 Aug 1997 15:18:04   danig
 * Registration routine return status
 *
 *    Rev 1.20   28 Aug 1997 17:47:08   danig
 * Buffer\remapped per socket
 *
 *    Rev 1.19   28 Jul 1997 15:10:36   danig
 * setPowerOnCallback & moved standard typedefs to flbase.h
 *
 *    Rev 1.18   24 Jul 1997 18:04:12   amirban
 * FAR to FAR0
 *
 *    Rev 1.17   21 Jul 1997 18:56:00   danig
 * nandBuffer static
 *
 *    Rev 1.16   20 Jul 1997 18:21:14   danig
 * Moved vendorID and chipID to Vars
 *
 *    Rev 1.15   20 Jul 1997 17:15:06   amirban
 * Added Toshiba 8MB
 *
 *    Rev 1.14   07 Jul 1997 15:22:26   amirban
 * Ver 2.0
 *
 *    Rev 1.13   02 Jul 1997 14:59:22   danig
 * More wait for socket to power up
 *
 *    Rev 1.12   01 Jul 1997 13:39:54   danig
 * Wait for socket to power up
 *
 *    Rev 1.11   22 Jun 1997 18:34:32   danig
 * Documentation
 *
 *    Rev 1.10   12 Jun 1997 17:22:24   amirban
 * Allow LONG extra read/writes
 *
 *    Rev 1.9   08 Jun 1997 19:18:06   danig
 * BIG_PAGE & FULL_PAGE moved to flash.h
 *
 *    Rev 1.8   08 Jun 1997 17:03:40   amirban
 * Fast Toshiba and power on callback
 *
 *    Rev 1.7   05 Jun 1997 12:31:38   amirban
 * Write corrections, and att reg changes
 *
 *    Rev 1.6   03 Jun 1997 18:45:14   danig
 * powerUp()
 *
 *    Rev 1.5   01 Jun 1997 13:42:52   amirban
 * Rewrite of read/write extra + major reduction
 *
 *    Rev 1.4   25 May 1997 16:41:38   amirban
 * Bg-endian, Toshiba fix & simplifications
 *
 *    Rev 1.3   18 May 1997 17:34:50   amirban
 * Use 'dataError'
 *
 *    Rev 1.2   23 Apr 1997 11:02:14   danig
 * Update to TFFS revision 1.12
 *
 *    Rev 1.1   15 Apr 1997 18:48:02   danig
 * Fixed FAR pointer issues.
 *
 *    Rev 1.0   08 Apr 1997 18:29:28   danig
 * Initial revision.
 */

/************************************************************************/
/*                                                                      */
/*              FAT-FTL Lite Software Development Kit                   */
/*              Copyright (C) M-Systems Ltd. 1995-1997                  */
/*                                                                      */
/************************************************************************/

#include "ntddk.h"

#include "flflash.h"
#include "reedsol.h"

#define NFDC2048        /* Support NFDC2048 ASIC controller */

#define MAX_FLASH_DEVICES   16

#define PAGES_PER_BLOCK     16          /* 16 pages per block on a single chip*/
#define SYNDROM_BYTES       6            /* Number of syndrom bytes: 5 + 1 parity*/

/* Flash IDs*/
#define KM29N16000_FLASH    0xec64
#define KM29N32000_FLASH    0xece5
#define KM29V64000_FLASH    0xece6
#define KM29V128000_FLASH   0xec73
#define KM29V256000_FLASH   0xec75
#define NM29N16_FLASH       0x8f64
#define NM29N32_FLASH       0x8fe5
#define NM29N64_FLASH       0x8fe6
#define TC5816_FLASH        0x9864
#define TC5832_FLASH        0x98e5
#define TC5864_FLASH        0x98e6
#define TC58128_FLASH       0x9873
#define TC58256_FLASH       0x9875

/* Flash commands:*/
#define SERIAL_DATA_INPUT   0x80
#define READ_MODE           0x00
#define READ_MODE_2         0x50
#define RESET_FLASH         0xff
#define SETUP_WRITE         0x10
#define SETUP_ERASE         0x60
#define CONFIRM_ERASE       0xd0
#define READ_STATUS         0x70
#define READ_ID             0x90
#define SUSPEND_ERASE       0xb0
#define REGISTER_READ       0xe0

/* commands for moving flash pointer to areeas A,B or C of page*/
typedef enum  { AREA_A = READ_MODE, AREA_B = 0x1, AREA_C = READ_MODE_2 } PointerOp;

typedef union {  USHORT w ; UCHAR b ;  } WordByte;


        /*Ŀ
             Memory window to cards common memory    
          */

typedef struct
{
  volatile WordByte             signals;            /* CDSN control register*/

          #define CE                  0x01
          #define CLE                 0x02
          #define ALE                 0x04
          #define NOT_WP              0x08
          #define RB                  0x80

          #define FAIL                0x01
          #define SUSPENDED           0x20
          #define READY               0x40
          #define NOT_PROTECTED       0x80

           UCHAR        fillerA[1024 - sizeof(WordByte)];
  volatile LEushort             deviceSelector;
  volatile WordByte             eccConfig;  /* EDC configuration register*/

        #define TOGGLE    0x04              /* Read*/
#ifdef NFDC2048
        #define ECC_RST   0x04              /* Write*/
        #define ECC_EN    0x08              /* Read / Write*/
        #define PAR_DIS   0x10              /* Read / Write*/
        #define ECC_RW    0x20              /* Read / Write*/
        #define ECC_RDY   0x40              /* Read */
        #define ECC_ERROR 0x80              /* Read*/

  volatile USHORT       syndrom[3];
           UCHAR        fillerC[1024-10];   /* 1kbytes minus 10 bytes*/
#else
           UCHAR        fillerC[1024-4];    /* 1kbytes minus 3 words */
#endif  /* NFDC2048 */
  volatile WordByte             io[1024];
} ContComWin;

/* #defines for writing to ContComWin.eccConfig */  /* HOOK - added */
#define SET_ECC_CONFIG(win,val) tffsWriteByteFlash(&((win)->eccConfig.b), (UCHAR)(val))
#define CHK_ECC_ERROR(win)      (tffsReadByteFlash(&((win)->eccConfig.b)) & (UCHAR)ECC_ERROR)

typedef ContComWin FAR0 * Interface;

#define  DBL(x)   ( (UCHAR)(x) * 0x101u )
#define  SECOND_TRY 0x8000

#ifdef NFDC2048

/* Controller registers: Addresses & values */

#define ATTRIBUTE_MEM_START 0x8000000L  /* Attribute memory starts at 128MB    */

/* Controller configuration register */
#define CONFIG1         ATTRIBUTE_MEM_START + 0x3ffc

        #define PWR_DN     0x01              /* Read / Write*/
        #define PWR_DN2    0x02              /* Read / Write*/
        #define STOP_CDSN  0x04              /* Read / Write*/
        #define STOP_CDSNS 0x08              /* Read / Write*/
        #define C_CDSN     0x10              /* Read / Write*/
        #define R_CDSN     0x20              /* Read / Write*/
        #define WP_C       0x40              /* Read / Write*/
        #define WP_A       0x80              /* Read / Write*/

/* board's jumper settings*/
#define JUMPERS         ATTRIBUTE_MEM_START + 0x3ffe

        #define JMPER_INLV      0x08
        #define JMPER_CDSNS     0x10
        #define JMPER_EXT_CIS   0x20
        #define JMPER_LDR_MASK  0x40
        #define JMPER_MAX_MODE  0x80

/* PCMCIA register #0*/
#define CONFIG_OPTION   ATTRIBUTE_MEM_START + 0x4000

        #define CONFIGIDX 0x3F              /* Read / Write*/
        #define SREST     0x80              /* Read / Write*/

/* PCMCIA register #1*/
#define CARD_CONFIG     ATTRIBUTE_MEM_START + 0x4002

        #define PWRDWN    0x04              /* Read / Write*/

#else

#define INLV 2          /* Must define interleaving statically */

#endif /* NFDC2048 */

/* customization for this MTD*/
/*#define MULTI_ERASE  */   /* use multiple block erase feature*/
#define USE_EDC             /* use Error Detection /Correction Code */
/* #define VERIFY_AFTER_WRITE */

typedef struct {
  USHORT        vendorID;
  USHORT        chipID;
  USHORT        pageSize ;              /* all....................*/
  USHORT        pageMask ;              /* ...these...............*/
  USHORT        pageAreaSize ;          /* .......variables.......*/
  USHORT        tailSize ;              /* .............interleave*/
  USHORT        noOfBlocks ;            /* total erasable blocks in flash device*/
  USHORT        pagesPerBlock;          /* number of pages per block */
  FLBuffer              *buffer;                /* buffer for map through buffer */
} Vars;

Vars mtdVars_nfdc2048[SOCKETS];

#define thisVars   ((Vars *) vol.mtdVars)
#define thisBuffer (thisVars->buffer->flData)

                    /*Ŀ
                        Auxiliary methods  
                      */

/*----------------------------------------------------------------------*/
/*              t f f s c p y 1 6                                       */
/*                                                                      */
/* Move data in 16-bit words.                                           */
/*                                                                      */
/* Parameters:                                                          */
/*      dst             : destination buffer                            */
/*      src             : source buffer                                 */
/*      len             : bytes to move                                 */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID tffscpy16fromMedia (UCHAR FAR0       *dst,
                       const UCHAR FAR0 *src,
                       LONG                      len)
{
  register LONG i;
  USHORT FAR0 *dstPtr = (USHORT FAR0 *) dst;
  const USHORT FAR0 *srcPtr = (USHORT FAR0 *) src;

  /* move data in 16-bit words */
  for (i = len;  i > 0; i -= 2)
    *dstPtr++ = tffsReadWordFlash(srcPtr++);
}

VOID tffscpy16toMedia (UCHAR FAR0       *dst,
                       const UCHAR FAR0 *src,
                       LONG                      len)
{
  register LONG i;
  USHORT FAR0 *dstPtr = (USHORT FAR0 *) dst;
  const USHORT FAR0 *srcPtr = (USHORT FAR0 *) src;

  /* move data in 16-bit words */
  for (i = len;  i > 0; i -= 2)
    tffsWriteWordFlash(dstPtr++,*srcPtr++);
}


/*----------------------------------------------------------------------*/
/*              t f f s s e t 1 6                                       */
/*                                                                      */
/* Set data buffer in 16-bit words.                                     */
/*                                                                      */
/* Parameters:                                                          */
/*      dst             : destination buffer                            */
/*      val             : byte value tofill the buffer                  */
/*      len             : setination buffer size in bytes               */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID tffsset16 (UCHAR FAR0 *dst,
                       UCHAR      val,
                       LONG                len)
{
  register USHORT  wval = ((USHORT)val << 8) | val;
  register LONG   i = 0;
  USHORT FAR0 *dstPtr;

  /* set data in 16-bit words */
  for (i = 0;  i < len - 1; i += 2) {
    dstPtr = (USHORT FAR0 *)addToFarPointer(dst, i);
    tffsWriteWordFlash(dstPtr,wval);
  }

  /* set last byte (if any) */
  if (len & 1) {
    dstPtr = (USHORT FAR0 *)addToFarPointer(dst, len - 1);
    tffsWriteByteFlash(dstPtr,wval);
  }
}



#ifdef NFDC2048

/*----------------------------------------------------------------------*/
/*                      r e a d S y n d r o m                           */
/*                                                                      */
/* Read ECC syndrom and swap words to prepare it for writing to flash.  */
/*                                                                      */
/* Parameters:                                                          */
/*      Interface       : Pointer to window.                            */
/*      to              : buffer to read to.                            */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID readSyndrom_nfdc2048( Interface interface, USHORT *to )
{
  to[0] = tffsReadWordFlash(&(interface->syndrom[2]));
  to[1] = tffsReadWordFlash(&(interface->syndrom[1]));
  to[2] = tffsReadWordFlash(&(interface->syndrom[0]));
}

#ifdef USE_EDC

/*----------------------------------------------------------------------*/
/*                      r e a d S y n d r o m O n S y n d r o m         */
/*                                                                      */
/* Read ECC syndrom.                                                    */
/*                                                                      */
/* Parameters:                                                          */
/*      Interface       : Pointer to window.                            */
/*      to              : buffer to read to.                            */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID readSyndromOnSyndrom ( Interface interface, USHORT *to )
{
  to[0] = tffsReadWordFlash(&(interface->syndrom[0]));
  to[1] = tffsReadWordFlash(&(interface->syndrom[1]));
  to[2] = tffsReadWordFlash(&(interface->syndrom[2]));
}

#endif  /* USE_EDC */


              /*Ŀ
                  Miscellaneous routines   
                */

/*----------------------------------------------------------------------*/
/*                      g e t A t t R e g                               */
/*                                                                      */
/* Get ASIC register residing in card's Attribute memory.               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address         : Address of register.                          */
/*                                                                      */
/* Returns:                                                             */
/*      Value of register.                                              */
/*                                                                      */
/*----------------------------------------------------------------------*/

UCHAR getAttReg(FLFlash vol, CardAddress reg)
{
  return (UCHAR) (tffsReadByteFlash((USHORT FAR0 *) flMap(vol.socket,reg)));
}



/*----------------------------------------------------------------------*/
/*                      s e t A t t R e g                               */
/*                                                                      */
/* Set ASIC register residing in card's Attribute memory.               */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address         : Address of register.                          */
/*      value           : Value to set                                  */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID setAttReg(FLFlash vol, CardAddress reg, UCHAR value)
{
  tffsWriteWordFlash((USHORT FAR0 *) flMap(vol.socket,reg), DBL(value));
}


/*----------------------------------------------------------------------*/
/*                      p o w e r U p                                   */
/*                                                                      */
/* Power up the controller.                                             */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID powerUp(VOID *pVol)
{
  flDelayMsecs(1);
  setAttReg ((FLFlash *) pVol, CONFIG1, WP_C);  /* Power up the controller */
}

#endif  /* NFDC2048 */


/*----------------------------------------------------------------------*/
/*                      m a p C o n t I n t e r f a c e                 */
/*                                                                      */
/* Select flash device.                                                 */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address         : Address in flash.                             */
/*                                                                      */
/* Returns:                                                             */
/*      Pointer to the mapped window.                                   */
/*                                                                      */
/*----------------------------------------------------------------------*/

Interface mapContInterface(FLFlash vol, CardAddress address)
{
  Interface interface = (Interface) flMap(vol.socket,(CardAddress)0);
  LEushort  tmp;

  toLE2(*((LEushort FAR0 *) &tmp), (USHORT)(address / (vol.chipSize * vol.interleaving)));

  /* Select flash device with 16-bit write */
  tffsWriteWordFlash(((USHORT FAR0 *) &interface->deviceSelector), *((USHORT *) &tmp));

  return interface;
}


/*----------------------------------------------------------------------*/
/*                      w a i t F o r R e a d y                         */
/*                                                                      */
/* Wait for the selected device to be ready.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      Interface       : Pointer tot the window.                       */
/*                                                                      */
/* Returns:                                                             */
/*      TRUE if device is ready, FALSE if timeout error.                */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLBoolean waitForReady_nfdc2048 (Interface interface)
{
  LONG i;

  for( i = 0;  i < 20000;  i++)
  {
    if( (~(tffsReadWordFlash(&(interface->signals.w))) & DBL(RB)) == 0)
      return TRUE ;                     /* ready at last..*/
    flDelayMsecs(1);
  }

  DEBUG_PRINT(("Debug: timeout error in NFDC 2048.\n"));

  return FALSE;                       /* timeout error  */
}



/*----------------------------------------------------------------------*/
/*                        m a k e C o m m a n d                         */
/*                                                                      */
/* Set Page Pointer to Area A, B or C in page.                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      cmd     : receives command relevant to area                     */
/*      addr    : receives the address to the right area.               */
/*      modes   : mode of operation (EXTRA ...)                         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID makeCommand_nfdc2048 (FLFlash vol, PointerOp *cmd, CardAddress *addr , LONG modes )
{
  USHORT offset;

  if ( !(vol.flags & BIG_PAGE) ) {
    if (modes & EXTRA) {
      offset = (USHORT) (*addr & (SECTOR_SIZE - 1));
      *cmd = AREA_C;
      if (vol.interleaving == 1) {
        if (offset < 8)         /* First half of extra area */
          *addr += 0x100;       /* ... assigned to 2nd page */
        else                    /* Second half of extra area */
          *addr -= 8;           /* ... assigned to 1st page */
      }
    }
    else
      *cmd = AREA_A;
  }
  else {
    offset = (USHORT)(*addr) & thisVars->pageMask ;   /* offset within device Page */

    *addr -= offset;            /* align at device Page*/

    if (vol.interleaving == 2 && offset >= 512)
      offset += 16;             /* leave room for 1st extra area */
    if (modes & EXTRA)
      offset += SECTOR_SIZE;

    if ( offset < thisVars->pageAreaSize )  /* starting in area A*/
      *cmd = AREA_A ;
    else if ( offset < thisVars->pageSize )    /* starting in area B */
      *cmd = AREA_B ;
    else                                  /* got into area C*/
      *cmd = AREA_C ;

    offset &= (thisVars->pageAreaSize - 1) ;          /* offset within area of device Page*/
    *addr += offset ;
  }
}



/*----------------------------------------------------------------------*/
/*                        c o m m a n d                                 */
/*                                                                      */
/* Latch command byte to selected flash device.                         */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      Interface       : Pointer to window.                            */
/*      code            : Command to set.                               */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID command2048(FLFlash vol, Interface interface, UCHAR code)
{
  tffsWriteWordFlash(&(interface->signals.w), DBL( CLE | NOT_WP | CE ));

  if ( vol.interleaving == 1 ) {                         /* 8-bit */
      tffsWriteByteFlash(&(interface->io[0].b), code);
  } else {                                             /* 16-bit */
      tffsWriteWordFlash(&(interface->io[0].w), DBL( code ));
  }

  tffsWriteWordFlash(&(interface->signals.w), DBL(       NOT_WP ));
}


/*----------------------------------------------------------------------*/
/*                        s e t A d d r e s s                           */
/*                                                                      */
/* Latch address to selected flash device.                              */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      Interface       : Pointer to window.                            */
/*      address         : address to set.                               */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID setAddress2048(FLFlash vol, Interface interface, CardAddress address )
{
  address &= (vol.chipSize * vol.interleaving - 1) ;  /* address within flash device*/
  address /= vol.interleaving ;                         /* .................... chip */

  if ( vol.flags & BIG_PAGE )
  {
    /*
       bits  0..7     stays as are
       bit      8     is thrown away from address
       bits 31..9 ->  bits 30..8
    */
    address = ((address >> 9) << 8)  |  ((UCHAR)address) ;
  }

  tffsWriteWordFlash(&(interface->signals.w), DBL(ALE | NOT_WP | CE));

  /* send address to flash in the following sequence: */
  /*      bits  7...0 first                           */
  /*      bits 15...8 next                            */
  /*      bits 23..16 finally                         */
  if ( vol.interleaving == 1 )
  {
    tffsWriteByteFlash(&(interface->io[0].b), (UCHAR)address );
    tffsWriteByteFlash(&(interface->io[0].b), (UCHAR)(address >> 8));
    tffsWriteByteFlash(&(interface->io[0].b), (UCHAR)(address >> 16));
  }
  else
  {
    tffsWriteWordFlash(&(interface->io[0].w), (USHORT)DBL(address));
    tffsWriteWordFlash(&(interface->io[0].w), (USHORT)DBL(address >> 8));
    tffsWriteWordFlash(&(interface->io[0].w), (USHORT)DBL(address >> 16));
  }

  tffsWriteWordFlash(&(interface->signals.w), DBL(      NOT_WP | CE));
}


/*----------------------------------------------------------------------*/
/*                        r e a d C o m m a n d                         */
/*                                                                      */
/* Issue read command.                                                  */
/*                                                                      */
/* Parametes:                                                           */
/*      vol             : Pointer identifying drive                     */
/*      Interface       : Pointer to window.                            */
/*      cmd             : Command to issue (according to area).         */
/*      addr            : address to read from.                         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID readCommand2048 (FLFlash vol, Interface interface, PointerOp  cmd, CardAddress addr)
{
  command2048 (&vol, interface, (UCHAR) cmd) ;       /* move flash pointer to respective area of the page*/
  setAddress2048 (&vol, interface, addr) ;

  waitForReady_nfdc2048(interface) ;
}


/*----------------------------------------------------------------------*/
/*                        w r i t e C o m m a n d                       */
/*                                                                      */
/* Issue write command.                                                 */
/*                                                                      */
/* Parametes:                                                           */
/*      vol             : Pointer identifying drive                     */
/*      interface       : Pointer to window.                            */
/*      cmd             : Command to issue (according to area).         */
/*      addr            : address to write to.                          */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID writeCommand2048 (FLFlash vol, Interface interface, PointerOp  cmd, CardAddress addr)
{
  if (vol.flags & FULL_PAGE) {
    command2048 (&vol, interface, RESET_FLASH); /* Clear page buffer */
    waitForReady_nfdc2048(interface);
  }
  command2048 (&vol, interface, (UCHAR) cmd) ;       /* move flash pointer to respective area of the page  */
  command2048 (&vol, interface, SERIAL_DATA_INPUT);       /* start data loading for write  */
  setAddress2048 (&vol, interface, addr) ;
}


/*----------------------------------------------------------------------*/
/*                        r e a d S t a t u s                           */
/*                                                                      */
/* Read status of selected flash device.                                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      interface       : Pointer to window.                            */
/*                                                                      */
/* Returns:                                                             */
/*      Chip status.                                                    */
/*                                                                      */
/*----------------------------------------------------------------------*/

USHORT readStatus2048(FLFlash vol, Interface interface)
{
  USHORT chipStatus ;

  command2048(&vol, interface, READ_STATUS);

  tffsWriteWordFlash(&(interface->signals.w), DBL( NOT_WP | CE ));

  if ( vol.interleaving == 1 )                    /* 8-bit*/
    chipStatus = DBL(tffsReadByteFlash(&(interface->io[0].b)));
  else                                              /* 16-bit  */
    chipStatus = tffsReadWordFlash(&(interface->io[0].w));

  tffsWriteWordFlash(&(interface->signals.w), DBL( NOT_WP ));

  return chipStatus;
}


/*----------------------------------------------------------------------*/
/*                        w r i t e E x e c u t e                       */
/*                                                                      */
/* Execute write.                                                       */
/*                                                                      */
/* Parametes:                                                           */
/*      vol             : Pointer identifying drive                     */
/*      interface       : Pointer to window.                            */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus writeExecute2048 (FLFlash vol, Interface interface)
{
  command2048 (&vol, interface, SETUP_WRITE);             /* execute page program*/
  if (!waitForReady_nfdc2048(interface)) {
    return flTimedOut;
  }
  if( readStatus2048(&vol, interface) & DBL(FAIL) )
    return flWriteFault ;

  return flOK ;
}



/*----------------------------------------------------------------------*/
/*                        r e a d O n e S e c t o r                     */
/*                                                                      */
/* Read up to one 512-byte block from flash.                            */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address : Address to read from.                                 */
/*      buffer  : buffer to read to.                                    */
/*      length  : number of bytes to read (up to sector size).          */
/*      modes   : EDC flag etc.                                         */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus: 0 on success, otherwise failed.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus readOneSector_nfdc2048 (FLFlash vol,
                             CardAddress address,  /* starting flash address*/
                             CHAR FAR1 *buffer,     /* target buffer */
                             LONG length,           /* bytes to read */
                             LONG modes)            /* EDC flag etc.*/
{
  FLStatus  status = flOK;
  PointerOp   cmd;
  CardAddress addr  = address ;

  Interface interface = mapContInterface(&vol, address);  /* select flash device */


           /* move flash pointer to areas A,B or C of page*/

  makeCommand_nfdc2048 (&vol, &cmd, &addr, modes) ;

  readCommand2048 (&vol, interface, cmd, addr);

#ifdef NFDC2048
  if(modes & EDC) {
      SET_ECC_CONFIG(interface, ECC_RST | ECC_EN); /*ECC reset and ON for read*/
  }
#endif  /* NFDC2048 */

  if ((vol.interleaving == 1) && !(vol.flags & BIG_PAGE) )        /* 8-bit */
  {
              /* read up to two pages separately, starting page.. */

    LONG toFirstPage, toSecondPage;

    toFirstPage = (cmd == AREA_C ? 8 : 0x100) -
                    ((USHORT)address & (cmd == AREA_C ? 7 : 0xff));
    if (toFirstPage > length)
      toFirstPage = length;
    toSecondPage = length - toFirstPage ;

    tffscpy16fromMedia ((UCHAR*)buffer, (const UCHAR FAR0 *) interface->io, toFirstPage ) ;

    if ( toSecondPage > 0 )
    {
              /* next page*/

      readCommand2048 (&vol, interface, AREA_A, address + toFirstPage) ;

      tffscpy16fromMedia( (UCHAR*)(buffer + toFirstPage),
                 (const UCHAR FAR0 *) interface->io,
                 toSecondPage ) ;
    }
  }
  else                            /* interleaving == 2 so 16-bit read*/
    tffscpy16fromMedia( (UCHAR*)buffer, (const UCHAR FAR0 *) interface->io, length );

#ifdef NFDC2048
  if( modes & EDC )
  {
    UCHAR    extraBytes[SYNDROM_BYTES];
          /* read syndrom to let it through the ECC unit*/

    SET_ECC_CONFIG(interface, ECC_EN | PAR_DIS); /* parity off in ECC*/

    tffscpy16fromMedia( extraBytes, (const UCHAR FAR0 *) interface->io, SYNDROM_BYTES ) ;

    if( CHK_ECC_ERROR(interface) )             /* ECC error*/
    {
      if( (vol.interleaving == 1) && !(vol.flags & BIG_PAGE) )
        {  /* HOOK : make ECC working on 2M /INLV 1 */ }
      else
      {
#ifdef USE_EDC
                  /* try to fix ECC error*/

        if ( modes & SECOND_TRY )             /* 2nd try*/
        {
          UCHAR syndrom[SYNDROM_BYTES];

                  /* read syndrom-on-syndrom from ASIC*/

          readSyndromOnSyndrom(interface, (USHORT*)syndrom );

          if (flCheckAndFixEDC(buffer, (CHAR FAR1 *)syndrom, vol.interleaving == 2) != NO_EDC_ERROR) {
            DEBUG_PRINT(("Debug: ECC error in NFDC 2048.\n"));
            status = flDataError;
          }
        }
        else                                  /* 1st try - try once more*/
        {
          SET_ECC_CONFIG(interface,  PAR_DIS); /* reset ECC*/

          return  readOneSector_nfdc2048(&vol, address, buffer, length, modes | SECOND_TRY ) ;
        }
#endif /* USE_EDC*/
      }
    }

    SET_ECC_CONFIG(interface,  PAR_DIS);      /* ECC off*/
  }
#endif  /* NFDC2048 */

  interface->signals.w = DBL(NOT_WP) ;

  return status;
}



/*----------------------------------------------------------------------*/
/*                        w r i t e O n e S e c t o r                   */
/*                                                                      */
/* Write data in one 512-byte block to flash.                           */
/* Assuming that EDC mode never requested on partial block writes.      */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address : Address of sector to write to.                        */
/*      buffer  : buffer to write from.                                 */
/*      length  : number of bytes to write (up to sector size).         */
/*      modes   : OVERWRITE, EDC flags etc.                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus: 0 on success, otherwise failed.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus writeOneSector_nfdc2048(FLFlash vol,
                             CardAddress address,    /* target flash addres  */
                             const CHAR FAR1 *buffer, /* source RAM buffer   */
                             LONG length,             /* bytes to write (up to BLOCK) */
                             LONG modes)              /* OVERWRITE, EDC flags etc.  */
{
  FLStatus    status;
  PointerOp cmd;

  Interface interface = mapContInterface(&vol, address);  /* select flash device*/

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

  /* move flash pointer to areas A,B or C of page  */

  makeCommand_nfdc2048 (&vol, &cmd, &address, modes) ;

  if ((vol.flags & FULL_PAGE) && cmd == AREA_B) {
    ULONG prePad = 2 + ((USHORT) address & thisVars->pageMask);

    writeCommand2048(&vol, interface, AREA_A, address + thisVars->pageAreaSize - prePad);
    tffsset16( (UCHAR FAR0 *) interface->io, 0xff, prePad);
  }
  else
    writeCommand2048(&vol, interface, cmd, address);

#ifdef NFDC2048
  if (modes & EDC)
    SET_ECC_CONFIG(interface, ECC_EN | ECC_RW); /* ECC ON for write*/
#endif

           /* load data and syndrom*/

  if( (vol.interleaving == 1) && !(vol.flags & BIG_PAGE) )    /* 8-bit*/
  {
    LONG toFirstPage, toSecondPage ;
                    /* write up to two pages separately*/

    toFirstPage = (modes & EXTRA ? 8 : 0x100) -
                    ((USHORT)address & (modes & EXTRA ? 7 : 0xff));
    if (toFirstPage > length)
      toFirstPage = length;
    toSecondPage = length - toFirstPage ;

    tffscpy16toMedia( (UCHAR FAR0 *) interface->io,            /* user data */
                (const UCHAR *)buffer,
                toFirstPage);

    if ( toSecondPage > 0 )
    {
      checkStatus( writeExecute2048(&vol, interface) ) ;          /* done with 1st page  */

      writeCommand2048(&vol, interface, AREA_A, address + toFirstPage);
                                                 /* user data*/
      tffscpy16toMedia( (UCHAR FAR0 *) interface->io,
                  (const UCHAR *)(buffer + toFirstPage),
                  toSecondPage);
    }
  }
  else                                                  /* 16-bit*/
    tffscpy16toMedia( (UCHAR FAR0 *) interface->io,             /* user data*/
               (const UCHAR *)buffer,
               length );

  if(modes & EDC)
  {
    USHORT extraBytes[SYNDROM_BYTES / sizeof(USHORT) + 1];
               /* Read the ECC syndrom*/

#ifdef NFDC2048
    tffsWriteWordFlash(&(interface->signals.w), DBL(NOT_WP));
    SET_ECC_CONFIG(interface, ECC_EN | PAR_DIS | ECC_RW); /* ECC parity off*/

    readSyndrom_nfdc2048( interface, (USHORT*)extraBytes) ;

               /* Write ECC syndrom and ANAND mark to the tail*/

    SET_ECC_CONFIG(interface, PAR_DIS);                   /* ECC off*/
    interface->signals.w = DBL(NOT_WP | CE);
#else
    extraBytes[0] = extraBytes[1] = extraBytes[2] = 0xffff;
#endif  /* NFDC2048 */

    extraBytes[SYNDROM_BYTES / sizeof(USHORT)] = 0x5555;        /* Anand mark */

    tffscpy16toMedia((UCHAR FAR0 *) interface->io, (const UCHAR *)extraBytes,
                                            sizeof extraBytes);
  }

  status = writeExecute2048(&vol, interface);

  tffsWriteWordFlash(&(interface->signals.w), DBL(NOT_WP));

  return status;
}


    /*Ŀ
        Core MTD methods - read, write and erase  
      */

/*----------------------------------------------------------------------*/
/*                        c d s n R e a d                               */
/*                                                                      */
/* Read some data from the flash. This routine will be registered as    */
/* the read routine for this MTD.                                       */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address : Address to read from.                                 */
/*      buffer  : buffer to read to.                                    */
/*      length  : number of bytes to read (up to sector size).          */
/*      modes   : EDC flag etc.                                         */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus: 0 on success, otherwise failed.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus cdsnRead(  FLFlash vol,
                         CardAddress address, /* target flash address */
                         VOID FAR1 *buffer,    /* source RAM buffer  */
                         dword length,          /* bytes to write      */
                         word modes)           /* Overwrite, EDC flags etc. */
{
  CHAR FAR1 *temp;
  ULONG readNow;

              /* read in sectors; first and last might be partial*/

  ULONG block = modes & EXTRA ? 8 : SECTOR_SIZE;

  readNow = block - ((USHORT)address & (block - 1));
  temp = (CHAR FAR1 *)buffer;
  for ( ; length > 0 ; )
  {
    if (readNow > length)
      readNow = length;

    /* turn off EDC on partial block read*/
    checkStatus( readOneSector_nfdc2048(&vol, address, temp, readNow,
                                (readNow != SECTOR_SIZE ? (modes & ~EDC) : modes)) );

    length -= readNow;
    address += readNow;
    temp += readNow;

    /* align at sector */
    readNow = block;
  }

  return flOK ;
}


/*----------------------------------------------------------------------*/
/*                        c d s n W r i t e                             */
/*                                                                      */
/* Write some data to the flash. This routine will be registered as the */
/* write routine for this MTD.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address : Address of sector to write to.                        */
/*      buffer  : buffer to write from.                                 */
/*      length  : number of bytes to write (up to sector size).         */
/*      modes   : OVERWRITE, EDC flags etc.                             */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus: 0 on success, otherwise failed.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus cdsnWrite( FLFlash vol,
                         CardAddress address,       /* target flash address*/
                         const VOID FAR1 *buffer,    /* source RAM buffer  */
                         dword length,                /* bytes to write      */
                         word modes)                 /* Overwrite, EDC flags etc.*/
{
  ULONG writeNow;
  const CHAR FAR1 *temp;
  FLStatus      status = flOK;
#ifdef VERIFY_AFTER_WRITE
  CardAddress  saveAddress = address;
  USHORT flReadback[SECTOR_SIZE / sizeof(USHORT)];
#endif

  /* write in sectors; first and last might be partial*/
  LONG block = modes & EXTRA ? 8 : SECTOR_SIZE;

  writeNow = block - ((USHORT)address & (block - 1));
  temp = (const CHAR FAR1 *)buffer;
  for ( ; length > 0 ; )
  {
    if (writeNow > length)
      writeNow = length;

    /* turn off EDC on partial block write*/
    status = writeOneSector_nfdc2048(&vol, address, temp, writeNow,
                 writeNow != SECTOR_SIZE ? (modes & ~EDC) : modes);

    if (status != flOK)
      break;

#ifdef VERIFY_AFTER_WRITE
    status = readOneSector_nfdc2048 (&vol, address, (CHAR FAR1 *)flReadback,
                 writeNow, (writeNow != SECTOR_SIZE ? (modes & ~EDC) : modes));

    if((status != flOK) || (tffscmp(temp, flReadback, writeNow) != 0))
      { status = flWriteFault;  break; }
#endif

    length -= writeNow;
    address += writeNow;
    temp += writeNow;

    /* align at sector */
    writeNow = block;
  }

  return flOK ;
}


/*----------------------------------------------------------------------*/
/*                        c d s n E r a s e                             */
/*                                                                      */
/* Erase number of blocks. This routine will be registered as the       */
/* erase routine for this MTD.                                          */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      blockNo         : First block to erase.                         */
/*      blocksToErase   : Number of blocks to erase.                    */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failed.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus cdsnErase( FLFlash vol,
                         word blockNo,              /* start' block (0 .. chipNoOfBlocks-1)*/
                         word blocksToErase)        /* Number of blocks to be erased */
{
  LONG i;
  FLStatus status   = flOK;

  Interface interface =
     mapContInterface(&vol, (LONG)blockNo * vol.erasableBlockSize ) ;    /* select device*/

  if (flWriteProtected(vol.socket))
    return flWriteProtect;

  blockNo %= thisVars->noOfBlocks ;                        /* within flash device  */

  if ( blockNo + blocksToErase > thisVars->noOfBlocks )    /* accross device boundary */
    return flBadParameter;

  for ( i=0 ; i < blocksToErase ; i++, blockNo++ )
  {
    USHORT pageNo = (USHORT) (blockNo * thisVars->pagesPerBlock);

    command2048(&vol, interface, SETUP_ERASE);

    tffsWriteWordFlash(&(interface->signals.w), DBL(ALE | NOT_WP | CE));

    /* send 'pageNo' to the flash in the following sequence: */
    /*   bits  7..0  first                                   */
    /*   bits 15..8  next                                    */
    if (vol.interleaving == 1)
    {
      tffsWriteByteFlash(&(interface->io[0].b),(UCHAR)pageNo);
      tffsWriteByteFlash(&(interface->io[0].b),(UCHAR)(pageNo >> 8));
    }
    else
    {
      tffsWriteWordFlash(&(interface->io[0].w), DBL(pageNo));
      tffsWriteWordFlash(&(interface->io[0].w), DBL(pageNo >> 8));
    }

    tffsWriteWordFlash(&(interface->signals.w), DBL(NOT_WP | CE));

              /* if only one block may be erase at a time then do it
                 otherwise leave it for later*/

    command2048(&vol, interface, CONFIRM_ERASE);

    if (!waitForReady_nfdc2048(interface))
      status = flTimedOut;

    if ( readStatus2048(&vol, interface) & DBL(FAIL)) {    /* erase operation failed*/
      status = flWriteFault ;
    }

    if (status != flOK) {                              /* reset flash device and abort */
      DEBUG_PRINT(("Debug: erase failed in NFDC 2048.\n"));
      command2048(&vol, interface, RESET_FLASH ) ;
      waitForReady_nfdc2048(interface) ;

      break ;
    }
  }       /* block loop */

#ifdef MULTI_ERASE
        /* do multiple block erase as was promised*/

    command2048(&vol, interface, CONFIRM_ERASE);
    if (!waitForReady_nfdc2048(interface))
      status = flTimedOut;

    if ( readStatus2048(interface) & DBL(FAIL)) {   /* erase operation failed*/
      status = flWriteFault ;
    }

    if (status != flOK) {                       /* reset flash device and abort*/
      DEBUG_PRINT(("Debug: erase failed in NFDC 2048.\n"));
      command2048(&vol, interface, RESET_FLASH ) ;
      waitForReady_nfdc2048(interface) ;
    }
#endif   /* MULTI_ERASE*/

  if(status == flOK)
    if ( readStatus2048(&vol, interface) & DBL(FAIL) ) {
      DEBUG_PRINT(("Debug: erase failed in NFDC 2048.\n"));
      status = flWriteFault;
    }

  return status;
}


/*----------------------------------------------------------------------*/
/*                        c d s n M a p                                 */
/*                                                                      */
/* Map through buffer. This routine will be registered as the map       */
/* routine for this MTD.                                                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      address : Flash address to be mapped.                           */
/*      length  : number of bytes to map.                               */
/*                                                                      */
/* Returns:                                                             */
/*      Pointer to the buffer data was mapped to.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID FAR0 * cdsnMap ( FLFlash vol,
                            CardAddress address,
                            int length )
{
  cdsnRead(&vol,address,thisBuffer,length, 0);
  vol.socket->remapped = TRUE;
  return (VOID FAR0 *)thisBuffer;
}

#ifdef NFDC2048
/*----------------------------------------------------------------------*/
/*                        c d s n S e t C a l l b a c k                 */
/*                                                                      */
/* Register a routine (powerUp()) for power on callback.                */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID cdsnSetCallback(FLFlash vol)
{
  flSetPowerOnCallback(vol.socket, powerUp, &vol);
}
#endif /* NFDC2048 */

/*----------------------------------------------------------------------*/
/*                        i s K n o w n M e d i a                       */
/*                                                                      */
/* Check if this flash media is supported. Initialize relevant fields   */
/* in data structures.                                                  */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      vendorId_P      : vendor ID read from chip.                     */
/*      chipId_p        : chip ID read from chip.                       */
/*      dev             : dev chips were accessed before this one.      */
/*                                                                      */
/* Returns:                                                             */
/*      TRUE if this media is supported, FALSE otherwise.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLBoolean isKnownMedia_nfdc2048( FLFlash vol,
                         USHORT vendorId_p,
                         USHORT chipId_p,
                         LONG dev )
{
#ifdef NFDC2048
  if ((chipId_p & 0xff00) == 0x6400)
    chipId_p = DBL(0x64);   /* Workaround for TC5816/NFDC2048 problem */
#endif /* NFDC2048 */

  if (dev == 0)
  {
    thisVars->vendorID = vendorId_p;  /* remember for next chips */
    thisVars->chipID = chipId_p;
    thisVars->pagesPerBlock = PAGES_PER_BLOCK;

    if (vendorId_p == DBL(0xEC))                  /* Samsung */
    {
      switch (chipId_p)
      {
        case DBL(0x64):                         /* 2M */
        case DBL(0xEA) :
          vol.type = KM29N16000_FLASH ;
          vol.chipSize = 0x200000L;
          return TRUE;

        case DBL(0xE5):
        case DBL(0xE3):                         /* 4M */
          vol.type = KM29N32000_FLASH;
          vol.flags |= BIG_PAGE;
          vol.chipSize = 0x400000L;
          return TRUE;

        case DBL(0xE6):                         /* 8M */
          vol.type = KM29V64000_FLASH;
          vol.flags |= BIG_PAGE;
          vol.chipSize = 0x800000L;
          return TRUE;

	case DBL(0x73): 		        /* 16 Mb */
	  vol.type = KM29V128000_FLASH;
          vol.flags |= BIG_PAGE;
	  vol.chipSize = 0x1000000L;
          thisVars->pagesPerBlock *= 2;
          return TRUE;

        case DBL(0x75):           		/* 32 Mb */
	  vol.type = KM29V256000_FLASH;
          vol.flags |= BIG_PAGE;
          vol.chipSize = 0x2000000L;
          thisVars->pagesPerBlock *= 2;
	  return TRUE;
      }
    }
    else
    if (vendorId_p == DBL(0x8F))                /* National */
    {
      switch (chipId_p)
      {
        case DBL(0x64):                         /* 2M */
          vol.type = NM29N16_FLASH;
          vol.chipSize = 0x200000L;
          return TRUE;
      }
    }
    else
    if (vendorId_p == DBL(0x98))                        /* Toshiba */
    {
      vol.flags |= FULL_PAGE;             /* no partial page programming */

      switch (chipId_p)
      {
        case DBL(0x64):                         /* 2M */
        case DBL(0xEA) :
          vol.type = TC5816_FLASH;
          vol.chipSize = 0x200000L;
          return TRUE;

        case DBL(0x6B):                         /* 4M */
        case DBL(0xE5):
          vol.type = TC5832_FLASH;
          vol.flags |= BIG_PAGE;
          vol.chipSize = 0x400000L;
          return TRUE;

        case DBL(0xE6):                         /* 8M */
          vol.type = TC5816_FLASH;
          vol.flags |= BIG_PAGE;
          vol.chipSize = 0x800000L;
          return TRUE;

	case DBL(0x73): 		        /* 16 Mb */
	  vol.type = TC58128_FLASH;
          vol.flags |= BIG_PAGE;
	  vol.chipSize = 0x1000000L;
          thisVars->pagesPerBlock *= 2;
          return TRUE;

        case DBL(0x75):           		/* 32 Mb */
	  vol.type = TC58256_FLASH;
          vol.flags |= BIG_PAGE;
          vol.chipSize = 0x2000000L;
          thisVars->pagesPerBlock *= 2;
	  return TRUE;
      }
    }
  }
  else               /* dev != 0*/
  if( (vendorId_p == thisVars->vendorID) && (chipId_p == thisVars->chipID) )
    return TRUE ;

  return FALSE ;
}


/*----------------------------------------------------------------------*/
/*                        r e a d F l a s h I D                         */
/*                                                                      */
/* Read vendor and chip IDs, count flash devices. Initialize relevant   */
/* fields in data structures.                                           */
/*                                                                      */
/* Parameters:                                                          */
/*      vol             : Pointer identifying drive                     */
/*      interface       : Pointer to window.                            */
/*      dev             : dev chips were accessed before this one.      */
/*                                                                      */
/* Returns:                                                             */
/*      TRUE if this media is supported, FALSE otherwise.               */
/*                                                                      */
/*----------------------------------------------------------------------*/

LONG readFlashID2048 (FLFlash vol, Interface interface, LONG dev)
{
  USHORT vendorId_p, chipId_p  ;

  KeStallExecutionProcessor(250 * 1000);
  command2048(&vol, interface, RESET_FLASH ) ;
  flDelayMsecs(10);
  command2048(&vol, interface, READ_ID);
  
  tffsWriteWordFlash(&(interface->signals.w), DBL(ALE | NOT_WP | CE));

  if (vol.interleaving == 1) {
      tffsWriteByteFlash(&(interface->io[0].b), 0);    /* Read ID from*/
  } else {                            /* address 0. */
      tffsWriteWordFlash(&(interface->io[0].w), 0);
  }

  tffsWriteWordFlash(&(interface->signals.w), DBL(NOT_WP | CE));

            /* read vendor and chip IDs */

  vendorId_p = (vol.interleaving == 1 ? DBL(tffsReadByteFlash(&(interface->io[0].b))) : tffsReadWordFlash(&(interface->io[0].w))) ;
  chipId_p   = (vol.interleaving == 1 ? DBL(tffsReadByteFlash(&(interface->io[0].b))) : tffsReadWordFlash(&(interface->io[0].w)));

  tffsWriteWordFlash(&(interface->signals.w), DBL(NOT_WP));

  if ( isKnownMedia_nfdc2048(&vol, vendorId_p, chipId_p, dev) != TRUE )    /* no chip or diff.*/
    return  FALSE ;                                         /* type of flash  */

            /* set flash parameters*/

  if ( dev == 0 )
  {
    thisVars->pageAreaSize = (USHORT) (0x100 * vol.interleaving);
    thisVars->pageSize = (USHORT) ((vol.flags & BIG_PAGE ? 0x200 : 0x100) * vol.interleaving);
    thisVars->tailSize = (USHORT) ((vol.flags & BIG_PAGE ? 16 : 8) * vol.interleaving);
    thisVars->pageMask = thisVars->pageSize - 1 ;
    vol.erasableBlockSize = thisVars->pagesPerBlock * thisVars->pageSize;
    thisVars->noOfBlocks = (USHORT)( (vol.chipSize * vol.interleaving)
                                / vol.erasableBlockSize ) ;
  }

  return TRUE ;
}


/*----------------------------------------------------------------------*/
/*                        c d s n I d e n t i f y                       */
/*                                                                      */
/* Identify flash. This routine will be registered as the               */
/* identification routine for this MTD.                                 */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus: 0 on success, otherwise failed.                       */
/*                                                                      */
/*----------------------------------------------------------------------*/

FLStatus cdsnIdentify(FLFlash vol)
{
  LONG addr = 0L ;
  Interface interface;

  DEBUG_PRINT(("Debug: Entering NFDC 2048 identification routine\n"));

  flDelayMsecs(10);       /* wait for socket to power up */

  flSetWindowBusWidth(vol.socket,16);/* use 16-bits */
  flSetWindowSpeed(vol.socket,250);  /* 250 nsec. */
  flSetWindowSize(vol.socket,2);        /* 4 KBytes */

  vol.mtdVars = &mtdVars_nfdc2048[flSocketNoOf(vol.socket)];
  /* get pointer to buffer (we assume SINGLE_BUFFER is not defined) */
  thisVars->buffer = flBufferOf(flSocketNoOf(vol.socket));

          /* detect card - identify bit toggles on consequitive reads*/

  vol.chipSize = 0x200000L ;    /* Assume something ... */
  vol.interleaving = 1;       /* unimportant for now  */
  interface = mapContInterface(&vol, 0);
  KeStallExecutionProcessor(250 * 1000);

  if((tffsReadByteFlash(&(interface->eccConfig.b)) & TOGGLE) == (tffsReadByteFlash(&(interface->eccConfig.b)) & TOGGLE))
    return flUnknownMedia;

          /* read interleave from the card*/

#ifdef NFDC2048
  vol.interleaving = ( (getAttReg(&vol, JUMPERS ) & JMPER_INLV) ? 1 : 2 );

  powerUp((VOID *) &vol);
  interface = mapContInterface(&vol, 0);
  KeStallExecutionProcessor(250 * 1000);

  if (vol.interleaving == 1)
    flSetWindowBusWidth(vol.socket, 8);

 #else
  vol.interleaving = INLV;
#endif  /* NFDC2048 */

          /* reset all flash devices*/

  tffsWriteWordFlash(&(interface->signals.w), DBL(NOT_WP));

           /* identify and count flash chips, figure out flash parameters*/

  for (vol.noOfChips = 0 ;
       vol.noOfChips < MAX_FLASH_DEVICES;
       vol.noOfChips += vol.interleaving,
       addr += vol.chipSize * vol.interleaving)
  {
    interface = mapContInterface(&vol, addr) ;
    if ( readFlashID2048(&vol, interface, vol.noOfChips) != TRUE )       /* no chip or different type of flash*/
      break ;
  }

  if ( vol.noOfChips == 0 )                        /* no chips were found */
    return flUnknownMedia;

            /* ECC off*/

  interface = mapContInterface(&vol, 0);
  KeStallExecutionProcessor(250 * 1000);

#ifdef NFDC2048
  SET_ECC_CONFIG(interface, PAR_DIS); /* disable ECC and parity*/
  setAttReg(&vol, CARD_CONFIG, PWRDWN);
#endif  /* NFDC2048 */

  /* Register our flash handlers */
  vol.write = cdsnWrite;
  vol.erase = cdsnErase;
  vol.read = cdsnRead;
  vol.map = cdsnMap;
#ifdef NFDC2048
  vol.setPowerOnCallback = cdsnSetCallback;
#endif

  vol.flags |= NFTL_ENABLED;

  DEBUG_PRINT(("Debug: Identified NFDC 2048.\n"));

  return flOK;
}


/*----------------------------------------------------------------------*/
/*                      f l R e g i s t e r C D S N                     */
/*                                                                      */
/* Registers this MTD for use                                           */
/*                                                                      */
/* Parameters:                                                          */
/*      None                                                            */
/*                                                                      */
/* Returns:                                                             */
/*      FLStatus        : 0 on success, otherwise failure               */
/*----------------------------------------------------------------------*/

FLStatus flRegisterCDSN(VOID)
{
  if (noOfMTDs >= MTDS)
    return flTooManyComponents;

  mtdTable[noOfMTDs++] = cdsnIdentify;

  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\protectp.c ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/PROTECTP.C_V  $
 * 
 *    Rev 1.18   Apr 15 2002 07:38:44   oris
 * Added static qualifier for private functions (findChecksum and makeDPS).
 * Removed readDPS and writeDPS routine prototypes (no longer exist).
 * Added setStickyBit routine for DiskOnChip Plus 128Mbit.
 * 
 *    Rev 1.17   Jan 28 2002 21:26:24   oris
 * Removed the use of back-slashes in macro definitions.
 * 
 *    Rev 1.16   Jan 17 2002 23:04:54   oris
 * Replaced docsysp include directive with docsys.
 * Changed the use of vol (macro *pVol) to *flash.
 * Add support for DiskOnChip Millennium Plus 16MB :
 *  - Copy extra area of IPL independently of the EDC to copy Strong arm  mark.
 *  - DPS 0 and 1 location where changed  - affects protectionSet routine.
 * Bug fix - Wrong usage of findChecksum, caused the use of the second  copy of the DPS instead of the first.
 * 
 *    Rev 1.15   Sep 24 2001 18:24:18   oris
 * removed ifdef and forced using flRead8bitRegPlus instead of reading with flRead16bitRegPlus.
 * 
 *    Rev 1.14   Sep 15 2001 23:47:56   oris
 * Remove all 8-bit access to uneven addresses.
 *
 *    Rev 1.13   Jul 16 2001 17:41:54   oris
 * Ignore write protection of the DPSs.
 *
 *    Rev 1.12   Jul 13 2001 01:09:26   oris
 * Bug fix for protection boundaries when using Millennium Plus devices that can not access a single byte.
 * Added send default key before trying a protection violation command.
 * Bug fix - bad IPL second copy offset.
 *
 *    Rev 1.11   May 16 2001 21:21:42   oris
 * Removed warnings.
 *
 *    Rev 1.10   May 09 2001 00:35:48   oris
 * Bug fix - Lock asserted was reported opposite of the real state.
 * Bug fix - Make sure to return "key inserted" if the partition is not read\write protected.
 * This is to enable a partition that does not span over all of the media floors to return "key inserted".
 *
 *    Rev 1.9   May 06 2001 22:42:18   oris
 * Bug fix - insert key does not try to insert key to a floor that is not read\write protected.
 * Bug fix - protection type does not return key inserted is one of the floors key is not inserted.
 * Bug fix - set protection no longer clears the IPL.
 * redundant was misspelled.
 *
 *    Rev 1.8   May 01 2001 14:24:56   oris
 * Bug fix - CHANGEABLE_PRTOECTION was never reported.
 *
 *    Rev 1.7   Apr 18 2001 17:19:02   oris
 * Bug fix - bad status code returned by protection set routine du to  calling changaInterleave while in access error.
 *
 *    Rev 1.6   Apr 18 2001 09:29:32   oris
 * Bug fix - remove key routine always return bad status code.
 *
 *    Rev 1.5   Apr 16 2001 13:58:28   oris
 * Removed warrnings.
 *
 *    Rev 1.4   Apr 12 2001 06:52:32   oris
 * Changed protectionBounries and protectionSet routine to be floor specific.
 *
 *    Rev 1.3   Apr 10 2001 23:56:30   oris
 * Bug fix - protectionBounries routine - floor did not change.
 * Bug fix - protectionSet routine - floors with no protected areas were not updated.
 * Bug fix - protectionBounries routine - bad paranthesis in MAX calculation.
 *
 *    Rev 1.2   Apr 09 2001 19:04:24   oris
 * Removed warrnings.
 *
 */

/*******************************************************************
 *
 *    DESCRIPTION:  MTD protection mechanism routines for the MDOC32
 *
 *    AUTHOR:  arie tamam
 *
 *    HISTORY:  created november 14, 2000
 *
 *******************************************************************/


/** include files **/
#include "mdocplus.h"
#include "protectp.h"
#include "docsys.h"

/** local definitions **/

/* default settings */

/** external functions **/

/** external data **/

/** internal functions **/
static byte findChecksum(byte * buffer, word size);
static void makeDPS(CardAddress addressLow, CardAddress addressHigh,
             byte FAR1*  key , word flag, byte* buffer);

#define MINUS_FLOORSIZE(arg) ((arg > NFDC21thisVars->floorSize) ? arg - NFDC21thisVars->floorSize : 0)

/** public data **/

/** private data **/

/** public functions **/

#ifdef  HW_PROTECTION

/**********/
/* Macros */
/**********/

/* check if key is correct */
#define isArea0Protected(flash) (((flRead8bitRegPlus(flash,NdataProtect0Status) & PROTECT_STAT_KEY_OK_MASK) != PROTECT_STAT_KEY_OK_MASK) ? TRUE : FALSE)

#define isArea1Protected(flash) (((flRead8bitRegPlus(flash,NdataProtect1Status) & PROTECT_STAT_KEY_OK_MASK) != PROTECT_STAT_KEY_OK_MASK) ? TRUE : FALSE)

/*----------------------------------------------------------------------*/
/*                    s e t S t i c k y B i t                           */
/*                                                                      */
/* Set the sticky bit to prevent the insertion of the protection key.   */
/*                                                                      */
/* Parameters:                                                          */
/*      flash   : Pointer identifying drive.                            */
/*                                                                      */
/* Returns:                                                             */
/*      flOK on success, none zero otherwise.                           */
/*----------------------------------------------------------------------*/

FLStatus setStickyBit(FLFlash * flash)
{
   volatile Reg8bitType val;
   register int         i;

   /* Raise the sticky bit, while keeping the other bits of the register */
   for(i=0;i<flash->noOfFloors;i++)
   {
      /* Remove last bit */
      val = flRead8bitRegPlus(flash, NoutputControl) |
            OUT_CNTRL_STICKY_BIT_ENABLE;
      flWrite8bitRegPlus(flash, NoutputControl, val);
   }
   return flOK;
}


/*
 ** protectBoundries
 *
 *
 *  PARAMETERS:
 *  flash       : Pointer identifying drive
 *  area        : indicated which protection area to work on.  0 or 1.
 *  AddressLow  : address of lower boundary of protected area
 *  AddressHigh : address of upper boundary of protected area
 *
 *  DESCRIPTION:  Gets protection boundaries from registers
 *
 *  NOTE : protection areas are assumed to be consequtive although they
 *         may skip DPS , OTP and header units.
 *
 *  RETURNS:
 *           flOK on success
 *
 */

FLStatus protectionBoundries(FLFlash * flash, byte area,CardAddress* addressLow,
                             CardAddress* addressHigh, byte floorNo)
{
  /* Check mode of ASIC and set to NORMAL.*/
  FLStatus status = chkASICmode(flash);

  if(status != flOK)
    return status;

  setFloor(flash,floorNo);
  switch (area)
  {
     case 0: /* data protect structure 0 */

        /* read the data protect 0 addresses */

        *addressLow = ((dword)flRead8bitRegPlus(flash,NdataProtect0LowAddr)   << 10)| /* ADDR_1 */
                      ((dword)flRead8bitRegPlus(flash,NdataProtect0LowAddr+1) << 18); /* ADDR_2 */
        *addressHigh = ((dword)flRead8bitRegPlus(flash,NdataProtect0UpAddr)   << 10)| /* ADDR_1 */
                       ((dword)flRead8bitRegPlus(flash,NdataProtect0UpAddr+1) << 18); /* ADDR_2 */
        break;

     case 1: /* data protect structure 1 */

        /* read the data protect 1 addresses */
        *addressLow = ((dword)flRead8bitRegPlus(flash,NdataProtect1LowAddr)   << 10)| /* ADDR_1 */
                      ((dword)flRead8bitRegPlus(flash,NdataProtect1LowAddr+1) << 18); /* ADDR_2 */
        *addressHigh = ((dword)flRead8bitRegPlus(flash,NdataProtect1UpAddr)   << 10)| /* ADDR_1 */
                       ((dword)flRead8bitRegPlus(flash,NdataProtect1UpAddr+1) << 18); /* ADDR_2 */
        break;

     default: /* No such protection area */

        return flGeneralFailure;
  }

  return(flOK);
}

/*
 ** tryKey
 *
 *
 *  PARAMETERS:
 *  flash   : Pointer identifying drive
 *  area    : indicated which protection area to work on. 0 or 1.
 *  Key     : an 8 byte long array containing the protection password.
 *            unsigned char * is an 8 bytes unsigned char array
 *
 *  DESCRIPTION: Sends protection key
 *
 *  RETURNS:
 *           flOK on success otherwise flWrongKey
 *
 */

FLStatus  tryKey(FLFlash * flash, byte area, unsigned char FAR1* key)
{
   int i;

   switch (area)
   {
      case 0: /* data protect structure 0 */

         for(i=0; i<PROTECTION_KEY_LENGTH; i++)  /* Send key */
            flWrite8bitRegPlus(flash,NdataProtect0Key, key[i]);

         /* check if key is valid */
         if (isArea0Protected(flash) == TRUE)
         {
            return flWrongKey;
         }
         else
         {
            return flOK;
         }

      case 1: /* data protect structure 0 */

         for(i=0; i<PROTECTION_KEY_LENGTH; i++)  /* Send key */
            flWrite8bitRegPlus(flash,NdataProtect1Key, key[i]);

         /* check if key is valid */
         if (isArea1Protected(flash) == TRUE)
         {
            return flWrongKey;
         }
         else
         {
            return flOK;
         }

      default: /* No such protection area */

         return flGeneralFailure;
   }
}

/*
 ** protectKeyInsert
 *
 *
 *  PARAMETERS:
 *  flash   : Pointer identifying drive
 *  area    : indicated which protection area to work on. 0 or 1.
 *  Key     : an 8 byte long array containing the protection password.
 *      unsigned char * is an 8 bytes unsigned char array
 *
 *  DESCRIPTION: Sends protection key only to protected areas.
 *
 *  NOTE : If key is already inserted the given key will not be sent.
 *  NOTE : The key will be sent to all the devices floors even if a key
 *         did not fit one of them.
 *  NOTE : This 2 notes above allow inserting diffrent key to
 *         diffrent floors in the case of power failure while formmating
 *         the device.
 *
 *  RETURNS:
 *           flOK on success otherwise flWrongKey
 *
 */

FLStatus  protectionKeyInsert(FLFlash * flash, byte area, unsigned char FAR1* key)
{
  byte floor;
  FLStatus status;
  FLStatus tmpStatus;

  /* Check mode of ASIC and set to NORMAL.*/
  status = chkASICmode(flash);
  if(status != flOK)
    return status;

  /* Send key to all floors */
  for (floor = 0;floor<flash->noOfFloors;floor++)
  {
    setFloor(flash,floor);

    switch (area)
    {
      case 0: /* data protect structure 0 */

     /* check if key is already inserted */
     if ((isArea0Protected(flash) == FALSE) || /* Key is in */
         ((flRead8bitRegPlus(flash,NdataProtect0Status) &   /* Or not protected */
          (PROTECT_STAT_WP_MASK | PROTECT_STAT_RP_MASK)) == 0))
        continue;

     break;

      case 1: /* data protect structure 1 */

     /* check if key is already inserted */
     if ((isArea1Protected(flash) == FALSE) || /* Key is in */
         ((flRead8bitRegPlus(flash,NdataProtect1Status) &   /* Or not protected */
          (PROTECT_STAT_WP_MASK | PROTECT_STAT_RP_MASK)) == 0))
        continue;
         break;

      default: /* No such protection area */

        return flGeneralFailure;
    }
    tmpStatus = tryKey(flash,area,key);
    if (tmpStatus == flOK)
       continue;

    /* Try default key */
    tmpStatus = tryKey(flash,area,(byte *)DEFAULT_KEY);
    if (tmpStatus != flOK)
       status = tmpStatus;
  }
  return(status);
}

/*
 ** protectKeyRemove
 *
 *
 *  PARAMETERS:
 *  flash       : Pointer identifying drive
 *  area        : indicated which protection area to work on. 0 or 1.
 *
 *  DESCRIPTION:  Removes protection key
 *
 *  RETURNS:
 *           Return flOK 
 *
 */

FLStatus    protectionKeyRemove(FLFlash * flash, byte area)
{
  byte     tmpKey[8];
  byte     floor;
  FLStatus status;

  for (floor = 0;floor < flash->noOfFloors;floor++)
  {
    setFloor(flash,floor);
    status = tryKey(flash,area,tmpKey);
    if (status == flOK) /* Unfortunatly the key was fine */
    {
       tmpKey[0]++;
       status = tryKey(flash,area,tmpKey);
    }
  }
  return flOK;
}

/*
 ** protectType
 *
 *
 *  PARAMETERS:
 *  flash       : Pointer identifying drive.
 *  area        : indicated which protection area to work on. 0 or 1.
 *  flag        : returns any combination of
 *      LOCK_ENABLED    - The LOCK signal is enabled.
 *      LOCK_ASSERTED   - The LOCK signal input pin is asserted.
 *      KEY_INSERTED    - The key has been correctly written
 *      READ_PROTECTED  - The area is protected against read operations
 *      WRITE_PROTECTED - The area is protected against write operations
 *
 *  DESCRIPTION: Gets protection type
 *
 *  NOTE: The type is checked for all floors. The attributes are ored
 *        giving the harshest protection attributes.
 *
 *  RETURNS:
 *       flOK on success
 */

FLStatus protectionType(FLFlash * flash, byte area,  word* flag)
{
  volatile Reg8bitType protectData;
  byte        floor;
  FLBoolean   curFlag; /* Indicated if the floor has r/w protection */
  CardAddress addressLow,addressHigh;
  FLStatus    status;

  status = chkASICmode(flash);
  if(status != flOK)
    return status;

  *flag = KEY_INSERTED | LOCK_ASSERTED; /* initiate the flags */

  for (floor = 0;floor < flash->noOfFloors;floor++)
  {
     setFloor(flash,floor);

     /* read data protect structure status */

     switch (area)
     {
        case 0: /* data protect structure 0 */

           protectData = flRead8bitRegPlus(flash,NdataProtect0Status) ;
           break;

        case 1: /* data protect structure 1 */

           protectData = flRead8bitRegPlus(flash,NdataProtect1Status) ;
           *flag      |= CHANGEABLE_PROTECTION;
           break;

        default: /* No such protection area */

           return flGeneralFailure;
     }
     curFlag = FALSE;
     /* Check if area is write protected */
     if((protectData & PROTECT_STAT_WP_MASK) ==PROTECT_STAT_WP_MASK)
     {
        status = protectionBoundries(flash, area, &addressLow,
                                         &addressHigh, floor);
        if(status != flOK)
           return status;

        if ((addressLow != addressHigh) ||
            (addressLow != ((CardAddress)(area + 1)<<flash->erasableBlockSizeBits)))
        {
           *flag |= WRITE_PROTECTED;
           curFlag = TRUE;
        }
     }
     /* Check if area is read protected */
     if((protectData & PROTECT_STAT_RP_MASK) ==PROTECT_STAT_RP_MASK)
     {
        *flag |= READ_PROTECTED;
        curFlag = TRUE;
     }
     /* Check if key is corrently inserted */
     if(((protectData & PROTECT_STAT_KEY_OK_MASK) !=
         PROTECT_STAT_KEY_OK_MASK) && (curFlag == TRUE))
        *flag &= ~KEY_INSERTED;
     /* Check if HW signal is enabled */
     if((protectData & PROTECT_STAT_LOCK_MASK) == PROTECT_STAT_LOCK_MASK)
        *flag |=LOCK_ENABLED ;
     /* Check if HW signal is asserted */
     if((flRead8bitRegPlus(flash,NprotectionStatus) &
        PROTECT_STAT_LOCK_INPUT_MASK) ==  PROTECT_STAT_LOCK_INPUT_MASK)
        *flag &= ~LOCK_ASSERTED;
  }
  return(flOK);
}

#ifndef FL_READ_ONLY

static byte findChecksum(byte * buffer, word size)
{
   register int i;
   byte answer;

   answer = 0xff;
   for(i=0 ; i<size ; i++)
     answer -= buffer[i];
   return answer;
}

/*
 ** SetProtection
 *
 *
 *  PARAMETERS:
 *  flash       : Pointer identifying drive
 *  area        : indicated which protection area to work on.  0 or 1.
 *  AddressLow  : sets address of lower boundary of protected area. 0 - floor size.
 *  AddressHigh : sets address of upper boundary of protected area. AddressLow - floor size.
 *  Key         : an 8 byte long array containing the protection password.
 *  flag        : any combination of the following flags:
 *      LOCK_ENABLED    - The LOCK signal is enabled.
 *      READ_PROTECTED - The area is protected against read operations
 *      WRITE_PROTECTED - The area is protected against write operations
 *  modes       : Either COMMIT_PROTECTION will cause the new values to
 *                take affect immidiatly or DO_NOT_COMMIT_PROTECTION for
 *                delaying the new values to take affect only after the
 *                next reset.
 *
 *  DESCRIPTION:  Sets the definitions of a protected area: location, key and protection type
 *
 *  RETURNS:
 *    flOK           - success
 *    FlWriteProtect - protection violetion,
 *    FlReadProtect  - protection violetion.
 *    FlDataError    - any other read failure.
 *    FlWriteFault   - any other write error.
 *    flBadLength    - if the length of the protected area exceeds
 *                     allowed length
 */

FLStatus protectionSet ( FLFlash * flash, byte area, word flag,
                         CardAddress addressLow, CardAddress addressHigh,
                         byte FAR1*  key , byte modes, byte floorNo)
{
  FLBoolean restoreInterleave = FALSE;
  byte      downloadStatus;
  DPSStruct dps;
  dword     floorInc = floorNo * NFDC21thisVars->floorSize;
  word      goodUnit,redundantUnit;
  dword     goodDPS,redundantDPS;
  FLStatus  status;
  dword     goodIPL      = 0; /* Initialized to remove warrnings */
  dword     redundantIPL = 0; /* Initialized to remove warrnings */
  dword     copyOffset;       /* Offset to redundant DPS unit    */
  dword     ipl0Copy0;     /* Offset to IPL second 512 bytes copy 0     */
  dword     dps1Copy0;     /* Offset to DPS1 copy 0                     */
  word      dps1UnitNo;    /* Offset to redundant DPS unit              */


  status = chkASICmode(flash);
  if(status != flOK)
    return status;

  /* check if exceeds the size */
  if( (addressLow > addressHigh) ||
      (addressHigh - addressLow >= (dword)NFDC21thisVars->floorSize))
     return( flBadLength );

  /* change to interleave 1 */
  if ( flash->interleaving == 2)
  {
     restoreInterleave = TRUE;
     status = changeInterleave(flash,1);
     if(status != flOK)
       return status;
  }

  if(flash->mediaType == MDOCP_TYPE) /* DiskOnChip Millennium Plus 32MB */
  {
    copyOffset   = flash->chipSize>>1; /* The chips are consequtive */
    dps1Copy0    = DPS1_COPY0_32;
    dps1UnitNo   = DPS1_UNIT_NO_32;
    ipl0Copy0    = IPL0_COPY0_32;
  }
  else
  {
    copyOffset   = flash->chipSize>>1; /* The chips are consequtive */
    dps1Copy0    = DPS1_COPY0_16;
    dps1UnitNo   = DPS1_UNIT_NO_16;
    ipl0Copy0    = IPL0_COPY0_16;
  }

  /* find if previous download */
  downloadStatus = flRead8bitRegPlus(flash,NdownloadStatus);

  /* prepare buffer */

  switch (area)
  {
     case 0: /* data protect structure 0 */

        switch (downloadStatus & DWN_STAT_DPS0_ERR)
        {
           case DWN_STAT_DPS01_ERR: /* Both  are bad */
              return flBadDownload;

           case DWN_STAT_DPS00_ERR: /* First is  bad */
              redundantUnit = (word)(DPS0_UNIT_NO + floorNo * (NFDC21thisVars->floorSize>>flash->erasableBlockSizeBits));
              goodUnit      = (word)(redundantUnit + (copyOffset>>flash->erasableBlockSizeBits));
              goodDPS       = DPS0_COPY0+floorInc + copyOffset;
              redundantDPS  = DPS0_COPY0+floorInc;
              break;

           default:                 /* Both copies are good */
              goodUnit      = (word)(DPS0_UNIT_NO + floorNo*(NFDC21thisVars->floorSize>>flash->erasableBlockSizeBits));
              redundantUnit = (word)(goodUnit + (copyOffset>>flash->erasableBlockSizeBits));
              goodDPS       = DPS0_COPY0+floorInc;
              redundantDPS  = DPS0_COPY0+floorInc + copyOffset;
        }
        break;

     case 1: /* data protect structure 0 */

        switch (downloadStatus & DWN_STAT_DPS1_ERR)
        {
           case DWN_STAT_DPS11_ERR: /* Both  are bad */
              return flBadDownload;

           case DWN_STAT_DPS10_ERR: /* First is  bad */
              redundantUnit = (word)(dps1UnitNo + floorNo*(NFDC21thisVars->floorSize>>flash->erasableBlockSizeBits));
              goodUnit      = (word)(redundantUnit + (copyOffset>>flash->erasableBlockSizeBits));
              goodDPS       = dps1Copy0+floorInc + copyOffset;
              redundantDPS  = dps1Copy0+floorInc;
              redundantIPL  = ipl0Copy0 + floorInc;
              goodIPL       = redundantIPL + copyOffset;
              break;

           default :                /* First is good */
              goodUnit      = (word)(dps1UnitNo + floorNo*(NFDC21thisVars->floorSize>>flash->erasableBlockSizeBits));
              redundantUnit = (word)(goodUnit + (copyOffset>>flash->erasableBlockSizeBits));
              goodDPS       = dps1Copy0+floorInc;
              redundantDPS  = dps1Copy0+floorInc + copyOffset;
              goodIPL       = ipl0Copy0 + floorInc;
              redundantIPL  = goodIPL + copyOffset;
        }
        break;

     default: /* No such protection area */

        return flGeneralFailure;
  }

  /* Build new DPS */
  if (key==NULL) /* key must be retreaved from previous structure */
  {
     status = flash->read(flash,goodDPS,(void FAR1 *)&dps,SIZE_OF_DPS,0);
     if(status!=flOK) goto END_WRITE_DPS;
     if(findChecksum((byte *)&dps,SIZE_OF_DPS)!=0) /* bad copy */
        status = flash->read(flash,goodDPS+REDUNDANT_DPS_OFFSET,
                          (void FAR1*)&dps,SIZE_OF_DPS,0);
     makeDPS(addressLow,addressHigh,(byte FAR1*)(dps.key),flag,(byte *)&dps);
  }
  else           /* key is given as a parameter */
  {
     makeDPS(addressLow,addressHigh,(byte FAR1*)key,flag,(byte *)&dps);
  }

  /* Erase redundant unit       */
  status = flash->erase(flash,redundantUnit,1);
  if(status!=flOK) goto END_WRITE_DPS;

  /* Write new DPS              */
  status = flash->write(flash,redundantDPS,&dps,SIZE_OF_DPS,0);
  if(status!=flOK) goto END_WRITE_DPS;
  status = flash->write(flash,redundantDPS + REDUNDANT_DPS_OFFSET,
                     &dps,SIZE_OF_DPS,0);
  if(status!=flOK) goto END_WRITE_DPS;

  if (area == 1) /* copy the IPL */
  {
#ifndef MTD_STANDALONE
     /* Force remapping of internal catched sector */
     flash->socket->remapped = TRUE;
#endif /* MTD_STANDALONE */

     /* Read first 512 bytes IPL   */
     status = flash->read(flash,goodIPL,NFDC21thisBuffer,SECTOR_SIZE,0);
     if(status!=flOK) goto END_WRITE_DPS;

     /* Write first 512 bytes IPL  */
     status = flash->write(flash,redundantIPL,NFDC21thisBuffer,SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;
     status = flash->write(flash,redundantIPL + SECTOR_SIZE,
                        NFDC21thisBuffer,SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;

     /* Read second 512 bytes IPL  */
     status = flash->read(flash,goodIPL + IPL_HIGH_SECTOR,
                       NFDC21thisBuffer,SECTOR_SIZE,0);
     if(status!=flOK) goto END_WRITE_DPS;

     /* Write second 512 bytes IPL */
     status = flash->write(flash,redundantIPL + IPL_HIGH_SECTOR,
                        NFDC21thisBuffer,SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;
     status = flash->write(flash,redundantIPL + IPL_HIGH_SECTOR +
            SECTOR_SIZE, NFDC21thisBuffer,SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;
     /* Read Srong Arm mark */
     status = flash->read(flash,goodIPL + IPL_HIGH_SECTOR + 8,
                       NFDC21thisBuffer,1,EXTRA);
     if(status!=flOK) goto END_WRITE_DPS;
     /* Write Srong Arm mark */
     status = flash->write(flash,redundantIPL + IPL_HIGH_SECTOR + 8 +
            SECTOR_SIZE, NFDC21thisBuffer,1,EXTRA);
     if(status!=flOK) goto END_WRITE_DPS;
     status = flash->write(flash,redundantIPL + IPL_HIGH_SECTOR + 8,
                        NFDC21thisBuffer,1,EXTRA);
     if(status!=flOK) goto END_WRITE_DPS;
  }

  /* Erase good unit         */
  status = flash->erase(flash,goodUnit,1);
  if(status!=flOK) goto END_WRITE_DPS;

  /* Write over previous DPS */
  status = flash->write(flash,goodDPS,&dps,SIZE_OF_DPS,0);
  if(status!=flOK) goto END_WRITE_DPS;
  status = flash->write(flash,goodDPS + REDUNDANT_DPS_OFFSET,
                     &dps,SIZE_OF_DPS,0);
  if(status!=flOK) goto END_WRITE_DPS;

  if (area == 1) /* copy the IPL */
  {
     /* Read first 512 bytes IPL   */
     status = flash->read(flash,redundantIPL,NFDC21thisBuffer,SECTOR_SIZE,0);
     if(status!=flOK) goto END_WRITE_DPS;

     /* Write first 512 bytes IPL  */
     status = flash->write(flash,goodIPL,NFDC21thisBuffer,SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;
     status = flash->write(flash,goodIPL + SECTOR_SIZE,
                        NFDC21thisBuffer,SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;

     /* Read second 512 bytes IPL  */
     status = flash->read(flash,redundantIPL + IPL_HIGH_SECTOR,
                       NFDC21thisBuffer,SECTOR_SIZE,0);
     if(status!=flOK) goto END_WRITE_DPS;

     /* Write second 512 bytes IPL */
     status = flash->write(flash,goodIPL + IPL_HIGH_SECTOR,
                        NFDC21thisBuffer,SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;
     status = flash->write(flash,goodIPL + IPL_HIGH_SECTOR +
                        SECTOR_SIZE, NFDC21thisBuffer,
                        SECTOR_SIZE,EDC);
     if(status!=flOK) goto END_WRITE_DPS;
  }

END_WRITE_DPS:
  if ( restoreInterleave == TRUE)
  {
     FLStatus status2;

     chkASICmode(flash);                   /* Release posible access error */
     status2 = changeInterleave(flash, 2); /* change back to interleave 2 */
     if(status2 != flOK)
        return status2;
  }
  if (status == flOK)
  {
     if ((modes & COMMIT_PROTECTION) && /* The new values will take affect now */
         (flash->download != NULL))
        status = flash->download(flash);
  }
  return status;

}

/*
 ** makeDataProtectStruct
 *
 *
 *  PARAMETERS:
 *  AddressLow  : sets address of lower boundary of protected area
 *  AddressHigh: sets address of upper boundary of protected area
 *  Key     : an 8 byte long array containing the protection password.
 *  flag        : any combination of the following flags:
 *      LOCK_ENABLED    - The LOCK signal is enabled.
 *      READ_PROTECTED - The area is protected against read operations
 *      WRITE_PROTECTED - The area is protected against write operations
 *  buffer - buffer pointer of the returned structure.
 *
 *  DESCRIPTION:  Sets the definitions of a protected structure: location, key and protection type
 *
 *  RETURNS:
 *
 */

static void makeDPS(CardAddress addressLow, CardAddress addressHigh,
             byte FAR1* key , word flag, byte* buffer)
{
    int i;
    DPSStruct* dps = (DPSStruct *)buffer;

    /* convert to little endien and store */
    toLE4(dps->addressLow,addressLow >>10);
    toLE4(dps->addressHigh,addressHigh >>10);

    /*insert protection key */
    for(i=0; i<PROTECTION_KEY_LENGTH; i++)
        dps->key[i] = key[i];

    /* insert flags */
    dps->protectionType = 0;
    if((flag & LOCK_ENABLED)==LOCK_ENABLED)
        dps->protectionType |= DPS_LOCK_ENABLED;
    if((flag & READ_PROTECTED)==READ_PROTECTED)
        dps->protectionType |= DPS_READ_PROTECTED;
    if((flag & WRITE_PROTECTED)==WRITE_PROTECTED)
        dps->protectionType |= DPS_WRITE_PROTECTED;

    /* calculate and store checksum */
    dps->checksum = findChecksum(buffer,SIZE_OF_DPS-1);
}
#endif /* FL_READ_ONLY */
#endif   /*  HW_PROTECTION */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\stdcomp.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/STDCOMP.H_V  $
 * 
 *    Rev 1.3   Jul 31 2001 22:29:36   oris
 * Improved documentation.
 * 
 *    Rev 1.2   Jun 17 2001 16:40:04   oris
 * Improved documentation.
 * 
 *    Rev 1.1   Apr 01 2001 07:55:24   oris
 * Copywrite notice.
 * flRegisterDOC2400 was changed to flRegisterDOCPLUS.
 * flRegisterDOCSOC2400 was changed to flRegisterDOCPLUSSOC.
 * 
 *    Rev 1.0   Feb 04 2001 12:39:10   oris
 * Initial revision.
 *
 */

/***********************************************************************************/
/*                        M-Systems Confidential                                   */
/*           Copyright (C) M-Systems Flash Disk Pioneers Ltd. 1995-2001            */
/*                         All Rights Reserved                                     */
/***********************************************************************************/
/*                            NOTICE OF M-SYSTEMS OEM                              */
/*                           SOFTWARE LICENSE AGREEMENT                            */
/*                                                                                 */
/*      THE USE OF THIS SOFTWARE IS GOVERNED BY A SEPARATE LICENSE                 */
/*      AGREEMENT BETWEEN THE OEM AND M-SYSTEMS. REFER TO THAT AGREEMENT           */
/*      FOR THE SPECIFIC TERMS AND CONDITIONS OF USE,                              */
/*      OR CONTACT M-SYSTEMS FOR LICENSE ASSISTANCE:                               */
/*      E-MAIL = info@m-sys.com                                                    */
/***********************************************************************************/

#ifndef STDCOMP_H
#define STDCOMP_H

#include "flbase.h"

/************************************************************************/
/* Registration routines for MTDs supplied with TrueFFS			*/
/************************************************************************/

FLStatus    flRegisterI28F008(void);                  /* see I28F008.C  */
FLStatus    flRegisterI28F016(void);                  /* see I28F016.C  */
FLStatus    flRegisterAMDMTD(void);                   /* see AMDMTD.C   */
FLStatus    flRegisterWAMDMTD(void);                  /* see WAMDMTD.C  */
FLStatus    flRegisterCDSN(void);                     /* see NFDC2048.C */
FLStatus    flRegisterCFISCS(void);                   /* see CFISCS.C   */
FLStatus    flRegisterDOC2000(void); 	              /* see DISKONC.C  */
FLStatus    flRegisterDOCPLUS(void); 	              /* see MDOCPLUS.C */

/************************************************************************/
/* Registration routines for socket I/F supplied with TrueFFS		*/
/************************************************************************/

FLStatus    flRegisterPCIC(unsigned int, unsigned int, unsigned char);
						      /* see PCIC.C     */
FLStatus    flRegisterElanPCIC(unsigned int, unsigned int, unsigned char);
						      /* see PCICELAN.C */
FLStatus    flRegisterLFDC(FLBoolean);                /* see LFDC.C     */

FLStatus    flRegisterElanRFASocket(int, int);        /* see ELRFASOC.C */
FLStatus    flRegisterElanDocSocket(long, long, int); /* see ELDOCSOC.C */
FLStatus    flRegisterVME177rfaSocket(unsigned long, unsigned long);
						      /* FLVME177.C */
FLStatus    flRegisterCobuxSocket(void);              /* see COBUXSOC.C */
FLStatus    flRegisterCEDOCSOC(void);                 /* see CEDOCSOC.C */
FLStatus    flRegisterCS(void);                       /* see CSwinCE.C */

FLStatus    flRegisterDOCSOC(unsigned long, unsigned long);
						      /* see DOCSOC.C */
FLStatus    flRegisterDOCPLUSSOC(unsigned long, unsigned long);
						      /* see DOCSOC.C */

#ifdef NT5PORT
FLStatus		flRegisterNT5PCIC();											/* see SOCKETNT.C */
#endif /*NT5PORT*/

/************************************************************************/
/* Registration routines for translation layers supplied with TrueFFS	*/
/************************************************************************/

FLStatus    flRegisterFTL(void);                      /* see FTLLITE.C  */
FLStatus    flRegisterNFTL(void);                     /* see NFTLLITE.C */
FLStatus    flRegisterINFTL(void);                    /* see INFTL.C */
FLStatus    flRegisterSSFDC(void);                    /* see SSFDC.C    */
FLStatus    flRegisterATAtl(void);                    /* see atatl.c    */
FLStatus    flRegisterZIP(void);		      /* see ZIP.C	*/

/************************************************************************/
/* Multi-TL also known as Multi-DOC: Combine different devices into a   */
/* single big device allowing each of the devices to be formatted with  */
/* any kind of the TL mentioned above                                   */
/************************************************************************/

FLStatus    flRegisterMTL(void);                      /* see FLMTL.C    */

/************************************************************************/
/* Component registration routine in FLCUSTOM.C				*/
/************************************************************************/

FLStatus    flRegisterComponents(void);

#endif /* STDCOMP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\reedsol.c ===
/* HOOK. Fixed comments; otherwise impossible to compile */
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/REEDSOL.C_V  $
 * 
 *    Rev 1.3   Jul 13 2001 01:10:00   oris
 * Moved saved syndrome array definition (used by d2tst).
 *
 *    Rev 1.2   Apr 09 2001 15:10:20   oris
 * End with an empty line.
 *
 *    Rev 1.1   Apr 01 2001 08:00:14   oris
 * copywrite notice.
 *
 *    Rev 1.0   Feb 04 2001 12:37:38   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*		FAT-FTL Lite Software Development Kit			*/
/*		Copyright (C) M-Systems Ltd. 1995-2001			*/
/*									*/
/************************************************************************/


#include "reedsol.h"

#define T 2			 /* Number of recoverable errors */
#define SYND_LEN (T*2)           /* length of syndrom vector */
#define K512  (((512+1)*8+6)/10) /* number of inf symbols for record
				    of 512 bytes (K512=411) */
#define N512  (K512 + SYND_LEN)  /* code word length for record of 512 bytes */
#define INIT_DEG 510
#define MOD 1023

#define BLOCK_SIZE 512

#ifdef D2TST
byte    saveSyndromForDumping[SYNDROM_BYTES];
#endif /* D2TST */

static short  gfi(short val);
static short  gfmul( short f, short s );
static short  gfdiv( short f, short s );
static short  flog(short val);
static short  alog(short val);

/*------------------------------------------------------------------------------*/
/* Function Name: RTLeightToTen                                                 */
/* Purpose......: convert an array of five 8-bit values into an array of        */
/*                four 10-bit values, from right to left.                       */
/* Returns......: Nothing                                                       */
/*------------------------------------------------------------------------------*/
static void RTLeightToTen(char *reg8, unsigned short reg10[])
{
	reg10[0] =  (reg8[0] & 0xFF)       | ((reg8[1] & 0x03) << 8);
	reg10[1] = ((reg8[1] & 0xFC) >> 2) | ((reg8[2] & 0x0F) << 6);
	reg10[2] = ((reg8[2] & 0xF0) >> 4) | ((reg8[3] & 0x3F) << 4);
	reg10[3] = ((reg8[3] & 0xC0) >> 6) | ((reg8[4] & 0xFF) << 2);
}




/*----------------------------------------------------------------------------*/
static void unpack( short word, short length, short vector[] )
/*                                                                            */
/*   Function unpacks word into vector                                        */
/*                                                                            */
/*   Parameters:                                                              */
/*     word   - word to be unpacked                                           */
/*     vector - array to be filled                                            */
/*     length - number of bits in word                                        */

{
  short i, *ptr;

  ptr = vector + length - 1;
  for( i = 0; i < length; i++ )
  {
    *ptr-- = word & 1;
    word >>= 1;
  }
}


/*----------------------------------------------------------------------------*/
static short pack( short *vector, short length )
/*                                                                            */
/*   Function packs vector into word                                          */
/*                                                                            */
/*   Parameters:                                                              */
/*     vector - array to be packed                                            */
/*     length - number of bits in word                                        */

{
  short tmp, i;

  vector += length - 1;
  tmp = 0;
  i = 1;
  while( length-- > 0 )
  {
    if( *vector-- )
      tmp |= i;
    i <<= 1;
  }
  return( tmp );
}


/*----------------------------------------------------------------------------*/
static short gfi( short val)		/* GF inverse */
{
  return alog((short)(MOD-flog(val)));
}


/*----------------------------------------------------------------------------*/
static short gfmul( short f, short s ) /* GF multiplication */
{
  short i;
  if( f==0 || s==0 )
     return 0;
  else
  {
    i = flog(f) + flog(s);
    if( i > MOD ) i -= MOD;
    return( alog(i) );
  }
}


/*----------------------------------------------------------------------------*/
static short gfdiv( short f, short s ) /* GF division */
{
  return gfmul(f,gfi(s));
}




/*----------------------------------------------------------------------------*/
static void residue_to_syndrom( short reg[], short realsynd[] )
{
   short i,l,alpha,x,s,x4;
   short deg,deg4;


   for(i=0,deg=INIT_DEG;i<SYND_LEN;i++,deg++)
   {
      s = reg[0];
      alpha = x = alog(deg);
      deg4 = deg+deg;
      if( deg4 >= MOD ) deg4 -= MOD;
      deg4 += deg4;
      if( deg4 >= MOD ) deg4 -= MOD;
      x4 = alog(deg4);

      for(l=1;l<SYND_LEN;l++)
      {
	s ^= gfmul( reg[l], x );
	x  = gfmul( alpha, x );
      }

      realsynd[i] = gfdiv( s, x4 );
   }
}


/*----------------------------------------------------------------------------*/
static short alog(short i)
{
  short j=0, val=1;

  for( ; j < i ; j++ )
  {
    val <<= 1 ;

    if ( val > 0x3FF )
    {
      if ( val & 8 )   val -= (0x400+7);
      else             val -= (0x400-9);
    }
  }

  return val ;
}


static short flog(short val)
{
  short j, val1;

  if (val == 0)
    return (short)0xFFFF;

  j=0;
  val1=1;

  for( ; j <= MOD ; j++ )
  {
    if (val1 == val)
      return j;

    val1 <<= 1 ;

    if ( val1 > 0x3FF )
    {
      if ( val1 & 8 )   val1 -= (0x400+7);
      else              val1 -= (0x400-9);
    }

  }

  return 0;
}



/*----------------------------------------------------------------------------*/
static short convert_to_byte_patterns( short *locators, short *values,
				short noferr, short *blocs, short *bvals )
{
  static short mask[] = { 0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff };

  short i,j,n, n0, n1, tmp;
  short n_bit, n_byte, k_bit, nb;

  for( i = 0, nb = 0; i< noferr; i++)
  {
    n = locators[i];
    tmp = values[i];
    n_bit = n *10 - 6 ;
    n_byte = n_bit >> 3;
    k_bit  = n_bit - (n_byte<<3);
    n_byte++;
    if( k_bit == 7 )
    {
      /* 3 corrupted bytes */
      blocs[nb] = n_byte+1;
      bvals[nb++] = tmp & 1 ? 0x80 : 0;

      tmp >>= 1;
      blocs[nb] = n_byte;
      bvals[nb++] = tmp & 0xff;

      tmp >>= 8;
      bvals[nb++] = tmp & 0xff;
    }
    else
    {
      n0 = 8 - k_bit;
      n1 = 10 - n0;

      blocs[nb] = n_byte;
      bvals[nb++] = (tmp & mask[n1]) << (8 - n1);

      tmp >>= n1;
      blocs[nb] = n_byte - 1;
      bvals[nb++] = (tmp & mask[n0]);
    }
  }

  for( i = 0, j = -1; i < nb; i++ )
  {
    if( bvals[i] == 0 ) continue;
    if( (blocs[i] == blocs[j]) && ( j>= 0 ) )
    {
      bvals[j] |= bvals[i];
    }
    else
    {
      j++;
      blocs[j] = blocs[i];
      bvals[j] = bvals[i];
    }
  }
  return j+1;
}


/*----------------------------------------------------------------------------*/
static short deg512( short x )
{
  short i;
  short l,m;

  l = flog(x);
  for( i=0;i<9;i++)
  {
    m = 0;
    if( (l & 0x200) )
      m = 1;
    l =  ( ( l << 1 ) & 0x3FF  ) | m;
  }
  return alog(l);
}


/*----------------------------------------------------------------------------*/
static short decoder_for_2_errors( short s[], short lerr[], short verr[] )
{
  /* decoder for correcting up to 2 errors */
  short i,j,k,temp,delta;
  short ind, x1, x2;
  short r1, r2, r3, j1, j2;
  short sigma1, sigma2;
  short xu[10], ku[10];
  short yd, yn;

  ind = 0;
  for(i=0;i<SYND_LEN;i++)
    if( s[i] != 0 )
      ind++;                /* ind = number of nonzero syndrom symbols */

  if( ind == 0 ) return 0;  /* no errors */

  if( ind < 4 )
    goto two_or_more_errors;


/* checking s1/s0 = s2/s1 = s3/s2 = alpha**j for some j */

  r1 = gfdiv( s[1], s[0] );
  r2 = gfdiv( s[2], s[1] );
  r3 = gfdiv( s[3], s[2] );

  if( r1 != r2 || r2 != r3)
    goto two_or_more_errors;

  j = flog(r1);
  if( j > 414 )
    goto two_or_more_errors;

  lerr[0] = j;

/*  pattern = (s0/s1)**(510+1) * s1

	  or

    pattern = (s0/s1)**(512 - 1 )  * s1 */

  temp = gfi( r1 );

#ifndef NT5PORT
  {
    int i;

    for (i = 0; i < 9; i++)
      temp = gfmul( temp, temp );  /* deg = 512 */
  }
#else /*NT5PORT*/
  for (i = 0; i < 9; i++)
  {
      temp = gfmul( temp, temp );  /* deg = 512 */
  }
#endif /*NT5PORT*/

  verr[0] = gfmul( gfmul(temp, r1), s[1] );

  return 1;    /* 1 error */

two_or_more_errors:

  delta = gfmul( s[0], s[2] ) ^ gfmul( s[1], s[1] );

  if( delta == 0 )
    return -1;  /* uncorrectable error */

  temp = gfmul( s[1], s[3] ) ^ gfmul( s[2], s[2] );

  if( temp == 0 )
    return -1;  /* uncorrectable error */

  sigma2 = gfdiv( temp, delta );

  temp = gfmul( s[1], s[2] ) ^ gfmul( s[0], s[3] );

  if( temp == 0 )
    return -1;  /* uncorrectable error */

  sigma1 = gfdiv( temp, delta );

  k = gfdiv( sigma2, gfmul( sigma1, sigma1 ) );

  unpack( k, 10, ku );

  if( ku[2] != 0 )
    return -1;

  xu[4] = ku[9];
  xu[5] = ku[0] ^ ku[1];
  xu[6] = ku[6] ^ ku[9];
  xu[3] = ku[4] ^ ku[9];
  xu[1] = ku[3] ^ ku[4] ^ ku[6];
  xu[0] = ku[0] ^ xu[1];
  xu[8] = ku[8] ^ xu[0];
  xu[7] = ku[7] ^ xu[3] ^ xu[8];
  xu[2] = ku[5] ^ xu[7] ^ xu[5] ^ xu[0];
  xu[9] = 0;

  x1 = pack( xu, 10 );
  x2 = x1 | 1;

  x1 = gfmul( sigma1, x1 );
  x2 = gfmul( sigma1, x2 );


  j1 = flog(x1);
  j2 = flog(x2);

  if( (j1 > 414) || (j2 > 414) )
    return -1;


  r1 = x1 ^ x2;
  r2 = deg512( x1 );
  temp = gfmul( x1, x1 );
  r2 = gfdiv( r2, temp );
  yd = gfmul( r2, r1 );

  if( yd == 0 )
    return -1;

  yn = gfmul( s[0], x2 ) ^ s[1];
  if( yn == 0 )
    return -1;

  verr[0] = gfdiv( yn, yd );

  r2 = deg512( x2 );
  temp = gfmul( x2, x2 );
  r2 = gfdiv( r2, temp );
  yd = gfmul( r2, r1 );

  if( yd == 0 )
    return -1;

  yn = gfmul( s[0], x1 ) ^ s[1];
  if( yn == 0 )
    return -1;

  verr[1] = gfdiv( yn, yd );

  if( j1 > j2 ) {
    lerr[0] = j2;
    lerr[1] = j1;
    temp = verr[0];
    verr[0] = verr[1];
    verr[1] = temp;
  }
  else
  {
    lerr[0] = j1;
    lerr[1] = j2;
  }

  return 2;
}


/*------------------------------------------------------------------------------*/
/* Function Name: flDecodeEDC                                                   */
/* Purpose......: Trys to correct errors.                                       */
/*                errorSyndrom[] should contain the syndrom as 5 bytes and one  */
/*                parity byte. (identical to the output of calcEDCSyndrom()).   */
/*                Upon returning, errorNum will contain the number of errors,   */
/*                errorLocs[] will contain error locations, and                 */
/*                errorVals[] will contain error values (to be XORed with the   */
/*                data).                                                        */
/*                Parity error is relevant only if there are other errors, and  */
/*                the EDC code fails parity check.                              */
/*                NOTE! Only the first errorNum indexes of the above two arrays */
/*                      are relevant. The others contain garbage.               */
/* Returns......: The error status.                                             */
/*                NOTE! If the error status is NO_EDC_ERROR upon return, ignore */
/*                      the value of the arguments.                             */
/*------------------------------------------------------------------------------*/
EDCstatus flDecodeEDC(char *errorSyndrom, char *errorsNum,
		    short errorLocs[3*T],  short errorVals[3*T])
{
  short noferr;                         /* number of errors */
  short dec_parity;                     /* parity byte of decoded word */
  short rec_parity;                     /* parity byte of received word */
  short realsynd[SYND_LEN];             /* real syndrom calculated from residue */
  short locators[T],                    /* error locators */
  values[T];                            /* error values */
  short reg[SYND_LEN];                  /* register for main division procedure */
  int i;

  RTLeightToTen(errorSyndrom, (unsigned short *)reg);
  rec_parity = errorSyndrom[5] & 0xFF;  /* The parity byte */

  residue_to_syndrom(reg, realsynd);
  noferr = decoder_for_2_errors(realsynd, locators, values);

  if(noferr == 0)
    return NO_EDC_ERROR;                /* No error found */

  if(noferr < 0)                        /* If an uncorrectable error was found */
    return UNCORRECTABLE_ERROR;

  for (i=0;i<noferr;i++)
    locators[i] = N512 - 1 - locators[i];

  *errorsNum = (char)convert_to_byte_patterns(locators, values, noferr, errorLocs, errorVals);

  for(dec_parity=i=0; i < *errorsNum; i++)/* Calculate the parity for all the */
  {                                       /*   errors found: */
    if(errorLocs[i] <= 512)
      dec_parity ^= errorVals[i];
  }

  if(dec_parity != rec_parity)
    return UNCORRECTABLE_ERROR;         /* Parity error */
  else
    return CORRECTABLE_ERROR;
}


/*------------------------------------------------------------------------------*/
/* Function Name: flCheckAndFixEDC                                              */
/* Purpose......: Decodes the EDC syndrom and fixs the errors if possible.      */
/*                block[] should contain 512 bytes of data.                     */
/*                NOTE! Call this function only if errors where detected by     */
/*                      syndCalc or by the ASIC module.                         */
/* Returns......: The error status.                                             */
/*------------------------------------------------------------------------------*/
EDCstatus flCheckAndFixEDC(char FAR1 *block, char *syndrom, FLBoolean byteSwap)
{
  char errorsNum;
  short errorLocs[3*T];
  short errorVals[3*T];
  EDCstatus status;

  status = flDecodeEDC(syndrom, &errorsNum, errorLocs, errorVals);

  if(status == CORRECTABLE_ERROR)       /* Fix the errors if possible */
  {
    int i;

    for (i=0; i < errorsNum; i++)
      if( (errorLocs[i] ^ byteSwap) < BLOCK_SIZE )  /* Fix only in Data Area */
        block[errorLocs[i] ^ byteSwap] ^= errorVals[i];

    return NO_EDC_ERROR;                /* All errors are fixed */
  }
  else
    return status;                      /* Uncorrectable error */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\reedsol.h ===
/*
 * $Log:   V:/Flite/archives/TrueFFS5/Src/REEDSOL.H_V  $
 * 
 *    Rev 1.2   Jul 13 2001 01:10:10   oris
 * Moved syndrome byte length definition (SYNDROM_BYTES).
 * Moved saved syndrome array forward definition (used by d2tst).
 *
 *    Rev 1.1   Apr 01 2001 08:00:20   oris
 * copywrite notice.
 *
 *    Rev 1.0   Feb 04 2001 12:37:48   oris
 * Initial revision.
 *
 */

/************************************************************************/
/*                                                                      */
/*		FAT-FTL Lite Software Development Kit			*/
/*		Copyright (C) M-Systems Ltd. 1995-2001		*/
/*									*/
/************************************************************************/


#ifndef FLEDC_H
#define FLEDC_H

#include "flbase.h"

#define SYNDROM_BYTES            6

/* Global variable containing the EDC/ECC of the last operation */

#ifdef D2TST
extern byte    saveSyndromForDumping[SYNDROM_BYTES];
#endif /* D2TST */

typedef enum { NO_EDC_ERROR, CORRECTABLE_ERROR, UNCORRECTABLE_ERROR, EDC_ERROR } EDCstatus;

EDCstatus flCheckAndFixEDC(char FAR1 *block, char *syndrom, FLBoolean byteSwap);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\protectp.h ===
/*******************************************************************
 *
 *    DESCRIPTION: protection header file
 *
 *    AUTHOR: arie tamam
 *
 *    HISTORY: created november 14, 2000   
 *
 *******************************************************************/

#ifndef PROTECT_MDOCP_H
#define PROTECT_MDOCP_H

/** include files **/

/** local definitions **/
/* protection types */

/* default settings */

/** external functions **/
extern FLStatus protectionBoundries(FLFlash vol, byte area ,
                                    CardAddress* addressLow ,
                                    CardAddress* addressHigh ,
                                    byte floorNo);
extern FLStatus protectionKeyInsert(FLFlash  vol, byte area, byte FAR1* key);
extern FLStatus protectionKeyRemove(FLFlash  vol, byte area);
extern FLStatus protectionType(FLFlash vol, byte area,  word* flag);
extern FLStatus setStickyBit(FLFlash * flash);
#ifndef FL_READ_ONLY
extern FLStatus protectionSet ( FLFlash vol, byte area, word flag,
                                CardAddress addressLow,
                                CardAddress addressHigh,
                                byte FAR1* key , byte modes, byte floorNo);
#endif /* FL_READ_ONLY */
/** external data **/

/** internal functions **/

/** public data **/

/** private data **/

/** public functions **/

/** private functions **/
typedef byte HWKey[8];

typedef struct {
     LEulong addressLow;
     LEulong addressHigh;
     HWKey   key;
     byte    protectionType;
     byte    checksum;
}DPSStruct;

#define NdataProtect0Status 0x105C  /* Data Protect Structure Status register[0].read only */
#define NdataProtect1Status 0x105D  /* Data Protect Structure Status register[1].read only */
#define PROTECT_STAT_KEY_OK_MASK    0x10    /* 1=key correctly written */
#define PROTECT_STAT_LOCK_MASK      0x8     /* value of this bit in data protect structure */
#define PROTECT_STAT_WP_MASK        0x4     /* write protect. value of this bit in data protect structure */
#define PROTECT_STAT_RP_MASK        0x2     /* read protect. value of this bit in data protect structure */

#define NdataProtect0Pointer    0x105E  /*Data Protect Structure Pointer register[0]. read only */
#define NdataProtect1Pointer    0x105F  /*Data Protect Structure Pointer register[1]. read only */
#define PROTECT_POINTER_HN_MASK 0xf0    /* high nibble. */
#define PROTECT_POINTER_LN_MASK 0xf0    /* low nibble. */

#define NdataProtect0LowAddr    0x1060  /*Data Protect Lower Address register 0 [3:0].read only*/
#define NdataProtect0UpAddr     0x1064  /*Data Protect Upper Address register 0 [3:0].read only*/

#define NdataProtect1LowAddr    0x1068  /*Data Protect Lower Address register 1 [3:0].read only*/
#define NdataProtect1UpAddr     0x106C  /*Data Protect Upper Address register 1 [3:0].read only*/

#define NdataProtect0Key        0x1070  /*Data Protect Key register[0]. write only*/
#define NdataProtect1Key        0x1072  /*Data Protect Key register[1]. write only*/

/* DPS values */
#define DPS_READ_PROTECTED   0x2
#define DPS_WRITE_PROTECTED  0x4
#define DPS_LOCK_ENABLED     0x8
#endif /* PROTECT_MDOCP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\socketnt.c ===
/*
 * $Log: $
 */

/************************************************************************/
/*                                                                      */
/*      FAT-FTL Lite Software Development Kit           */
/*      Copyright (C) M-Systems Ltd. 1995-1996          */
/*                                  */
/************************************************************************/


#include "flsocket.h"
#include "scsi.h"
#include "tffsport.h"
#include "INITGUID.H"
#include "ntddpcm.h"

#define ANTI_CRASH_WINDOW

#ifdef ANTI_CRASH_WINDOW
CHAR antiCrashWindow_socketnt[0x2000];
#endif

/*NTsocketParams driveInfo[SOCKETS];
NTsocketParams * pdriveInfo = driveInfo;
*/
extern NTsocketParams driveInfo[SOCKETS];
extern NTsocketParams * pdriveInfo;
PCMCIA_INTERFACE_STANDARD driveContext[SOCKETS];

NTSTATUS queryInterfaceCompletionRoutine (
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp,
                         IN PVOID Context
                         )
{
  PKEVENT event = Context;
  KeSetEvent(event, EVENT_INCREMENT, FALSE);
  return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
updatePcmciaSocketParams(PDEVICE_EXTENSION fdoExtension)
{
    PIRP irp = NULL;
    NTSTATUS status;

    //
    // Setup a query interface request for the pcmcia pdo
    //
    irp = IoAllocateIrp(fdoExtension->LowerDeviceObject->StackSize, FALSE);

    if (irp)
    {
        PIO_STACK_LOCATION irpSp;
        KEVENT event;
        ULONG device = fdoExtension->UnitNumber;

        irpSp = IoGetNextIrpStackLocation(irp);

        irpSp->MajorFunction = IRP_MJ_PNP;
        irpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        irpSp->Parameters.QueryInterface.InterfaceType = &GUID_PCMCIA_INTERFACE_STANDARD;
        irpSp->Parameters.QueryInterface.Size          = sizeof(PCMCIA_INTERFACE_STANDARD);
        irpSp->Parameters.QueryInterface.Version       = 1;
        irpSp->Parameters.QueryInterface.Interface     = (PINTERFACE) &driveContext[device];
        irpSp->Parameters.QueryInterface.InterfaceSpecificData = NULL;

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoSetCompletionRoutine(irp, queryInterfaceCompletionRoutine, &event, TRUE, TRUE, TRUE);
        status = IoCallDriver(fdoExtension->LowerDeviceObject, irp);

        if (status == STATUS_PENDING)
        {
            status = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        }

        status = irp->IoStatus.Status;
        IoFreeIrp (irp);

        if (NT_SUCCESS(status))
        {
            driveInfo[device].windowSize   = fdoExtension->pcmciaParams.windowSize;
            driveInfo[device].physWindow   = fdoExtension->pcmciaParams.physWindow;
            driveInfo[device].winBase      = fdoExtension->pcmciaParams.windowBase;
            driveInfo[device].fdoExtension = (PVOID) fdoExtension;
            driveInfo[device].interfAlive  = 1;
        }
    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


/************************************************************************/
/*                                                                      */
/*      Beginning of controller-customizable code               */
/*                                                                      */
/* The function prototypes and interfaces in this section are standard  */
/* and are used in this form by the non-customizable code. However, the */
/* function implementations are specific to the 82365SL controller. */
/*                                  */
/* You should replace the function bodies here with the implementation  */
/* that is appropriate for your controller.             */
/*                                  */
/* All the functions in this section have no parameters. This is    */
/* because the parameters needed for an operation may be themselves */
/* depend on the controller. Instead, you should use the value in the   */
/* 'vol' structure as parameters.                   */
/* If you need socket-state variables specific to your implementation,  */
/* it is recommended to add them to the 'vol' structure rather than */
/* define them as separate static variables.                */
/*                                  */
/************************************************************************/

/*----------------------------------------------------------------------*/
/*                    c a r d D e t e c t e d           */
/*                                  */
/* Detect if a card is present (inserted)               */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/* Returns:                                                             */
/*  0 = card not present, other = card present          */
/*----------------------------------------------------------------------*/

FLBoolean cardDetected_socketnt(FLSocket vol)
{
  return TRUE;    /* we will know when card is removed */
  /*Implemented by upper layers*/
}


/*----------------------------------------------------------------------*/
/*                         V c c O n                */
/*                                  */
/* Turns on Vcc (3.3/5 Volts). Vcc must be known to be good on exit.    */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID VccOn_socketnt(FLSocket vol)
{
}


/*----------------------------------------------------------------------*/
/*                       V c c O f f                */
/*                                  */
/* Turns off Vcc.                           */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID VccOff_socketnt(FLSocket vol)
{
}


#ifdef SOCKET_12_VOLTS

/*----------------------------------------------------------------------*/
/*                         V p p O n                */
/*                                  */
/* Turns on Vpp (12 Volts. Vpp must be known to be good on exit.    */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/* Returns:                                                             */
/*  FLStatus    : 0 on success, failed otherwise        */
/*----------------------------------------------------------------------*/

FLStatus VppOn_socketnt(FLSocket vol)
{

  if (driveInfo[vol.volNo].fdoExtension != NULL) {
    if (((PDEVICE_EXTENSION)driveInfo[vol.volNo].fdoExtension)->DeviceFlags & DEVICE_FLAG_REMOVED) {
        return flVppFailure;
    }
  }
  else
      return flVppFailure;

  if (driveContext[vol.volNo].SetVpp(driveContext[vol.volNo].Context, PCMCIA_VPP_12V)) {
      return flOK;
  }
  else {
    return flVppFailure;
  }
}


/*----------------------------------------------------------------------*/
/*                       V p p O f f                */
/*                                  */
/* Turns off Vpp.                           */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID VppOff_socketnt(FLSocket vol)
{
  if (driveInfo[vol.volNo].fdoExtension != NULL) {
    if (((PDEVICE_EXTENSION)driveInfo[vol.volNo].fdoExtension)->DeviceFlags & DEVICE_FLAG_REMOVED) {
          return;
    }
  }
  else
      return;

  if (driveInfo[vol.volNo].interfAlive) {
      driveContext[vol.volNo].SetVpp(driveContext[vol.volNo].Context, PCMCIA_VPP_IS_VCC);
  }
}

#endif  /* SOCKET_12_VOLTS */


/*----------------------------------------------------------------------*/
/*                    i n i t S o c k e t                   */
/*                                  */
/* Perform all necessary initializations of the socket or controller    */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/* Returns:                                                             */
/*  FLStatus    : 0 on success, failed otherwise        */
/*----------------------------------------------------------------------*/

FLStatus initSocket_socketnt(FLSocket vol)
{
  return flOK;  /* nothing to initialize */
}


/*----------------------------------------------------------------------*/
/*                      s e t W i n d o w               */
/*                                  */
/* Sets in hardware all current window parameters: Base address, size,  */
/* speed and bus width.                         */
/* The requested settings are given in the 'vol.window' structure.  */
/*                                  */
/* If it is not possible to set the window size requested in        */
/* 'vol.window.size', the window size should be set to a larger value,  */
/* if possible. In any case, 'vol.window.size' should contain the   */
/* actual window size (in 4 KB units) on exit.              */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID setWindow_socketnt(FLSocket vol)
{
  vol.window.size = driveInfo[vol.volNo].windowSize;
  vol.window.base = driveInfo[vol.volNo].winBase;
}

/*----------------------------------------------------------------------*/
/*             s e t M a p p i n g C o n t e x t            */
/*                                  */
/* Sets the window mapping register to a card address.          */
/*                                  */
/* The window should be set to the value of 'vol.window.currentPage',   */
/* which is the card address divided by 4 KB. An address over 128KB,    */
/* (page over 32K) specifies an attribute-space address.        */
/*                                  */
/* The page to map is guaranteed to be on a full window-size boundary.  */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID setMappingContext_socketnt(FLSocket vol, unsigned page)
{
  UCHAR winSpeed;
  if (driveInfo[vol.volNo].fdoExtension != NULL) {
    if (((PDEVICE_EXTENSION)driveInfo[vol.volNo].fdoExtension)->DeviceFlags & DEVICE_FLAG_REMOVED) {
#ifdef ANTI_CRASH_WINDOW
          vol.window.base = antiCrashWindow_socketnt;
#else
        vol.window.base = NULL;
#endif
        return;
    }
  }
  else {
#ifdef ANTI_CRASH_WINDOW
      vol.window.base = antiCrashWindow_socketnt;
#else
      vol.window.base = NULL;
#endif
      return;
  }
  winSpeed = (UCHAR)(4 - ((vol.window.speed - 100) % 50));

  driveContext[vol.volNo].ModifyMemoryWindow(driveContext[vol.volNo].Context,
                                                   driveInfo[vol.volNo].physWindow,
                                                   ((ULONGLONG)page << 12),
                                                   FALSE,
                                                   vol.window.size,
                                                   winSpeed,
                                                   (UCHAR)((vol.window.busWidth == 16) ? PCMCIA_MEMORY_16BIT_ACCESS : PCMCIA_MEMORY_8BIT_ACCESS),
                                                   FALSE);

  if (!(driveContext[vol.volNo].ModifyMemoryWindow(driveContext[vol.volNo].Context,
                                                   driveInfo[vol.volNo].physWindow,
                                                   ((ULONGLONG)page << 12),
                                                   TRUE,
                                                   vol.window.size,
                                                   winSpeed,
                                                   (UCHAR)((vol.window.busWidth == 16) ? PCMCIA_MEMORY_16BIT_ACCESS : PCMCIA_MEMORY_8BIT_ACCESS),
                                                   FALSE))) {

#ifdef ANTI_CRASH_WINDOW
    vol.window.base = antiCrashWindow_socketnt;
#else
    vol.window.base = NULL;
#endif
  }
}


/*----------------------------------------------------------------------*/
/*       g e t A n d C l e a r C a r d C h a n g e I n d i c a t o r    */
/*                                  */
/* Returns the hardware card-change indicator and clears it if set. */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/* Returns:                                                             */
/*  0 = Card not changed, other = card changed          */
/*----------------------------------------------------------------------*/

FLBoolean getAndClearCardChangeIndicator_socketnt(FLSocket vol)
{
  return FALSE;
}


/*----------------------------------------------------------------------*/
/*                    w r i t e P r o t e c t e d           */
/*                                  */
/* Returns the write-protect state of the media             */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/* Returns:                                                             */
/*  0 = not write-protected, other = write-protected        */
/*----------------------------------------------------------------------*/

FLBoolean writeProtected_socketnt(FLSocket vol)
{
  if (driveInfo[vol.volNo].fdoExtension != NULL) {
    if (((PDEVICE_EXTENSION)driveInfo[vol.volNo].fdoExtension)->DeviceFlags & DEVICE_FLAG_REMOVED) {
          return TRUE;
    }
  }
  else
      return TRUE;

  return driveContext[vol.volNo].IsWriteProtected(driveContext[vol.volNo].Context);
}

#ifdef EXIT
/*----------------------------------------------------------------------*/
/*                    f r e e S o c k e t               */
/*                                  */
/* Free resources that were allocated for this socket.          */
/* This function is called when FLite exits.                */
/*                                  */
/* Parameters:                                                          */
/*  vol     : Pointer identifying drive         */
/*                                                                      */
/*----------------------------------------------------------------------*/

VOID freeSocket_socketnt(FLSocket vol)
{
}
#endif /* EXIT */

/*----------------------------------------------------------------------*/
/*                  f l R e g i s t e r P C I C         */
/*                                  */
/* Installs routines for the PCIC socket controller.            */
/*                                  */
/* Returns:                             */
/*  FLStatus    : 0 on success, otherwise failure       */
/*----------------------------------------------------------------------*/

FLStatus flRegisterNT5PCIC()
{
  LONG serialNo = 0;

  for (; noOfSockets < SOCKETS; noOfSockets++) {
    FLSocket vol = flSocketOf(noOfSockets);

        vol.volNo = noOfSockets;
    vol.serialNo = serialNo;
    vol.cardDetected = cardDetected_socketnt;
    vol.VccOn = VccOn_socketnt;
    vol.VccOff = VccOff_socketnt;
#ifdef SOCKET_12_VOLTS
    vol.VppOn = VppOn_socketnt;
    vol.VppOff = VppOff_socketnt;
#endif
    vol.initSocket = initSocket_socketnt;
    vol.setWindow = setWindow_socketnt;
    vol.setMappingContext = setMappingContext_socketnt;
    vol.getAndClearCardChangeIndicator = getAndClearCardChangeIndicator_socketnt;
    vol.writeProtected = writeProtected_socketnt;
#ifdef EXIT
    vol.freeSocket = freeSocket_socketnt;
#endif
    PRINTF("Debug: flRegisterNT5PCIC():Socket No %d is register.\n", noOfSockets);
  }
  if (noOfSockets == 0)
    return flAdapterNotFound;
  return flOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\tffsport\tffsport.c ===
/*

Copyright (c) 1997 M-Systems

Module Name:

    tffsport.c

Author:

    Alexander Geller

Environment:

    Kernel mode

--*/

#include "ntddk.h"
#include "scsi.h"
#include "ntdddisk.h"
#include "ntddscsi.h"
#include "string.h"
#include "stdio.h"
#include "stdarg.h"
#include "ntddstor.h"
#include "initguid.h"
#include "ntddscsi.h"

#include "blockdev.h"
#include "nfdc2148.h"
//#include "mdocplus.h"
#include "tffsport.h"
#include "ntioctl.h"

#define TFFSPORT_POOL_TAG   'dffT' // - Tffd    Tffsport Driver Tag

KTIMER  timerObject;
KDPC    timerDpc;
BOOLEAN timerWasStarted = FALSE;
BOOLEAN patitionTwo = FALSE;




/* Private GUID for WMI */
DEFINE_GUID(WmiTffsportAddressGuid,
    0xd9a8f150,
    0xf830,
    0x11d2,
    0xb5, 0x72, 0x00, 0xc0, 0x4f, 0x65, 0xb3, 0xd9
);

TempINFO info[VOLUMES];

ULONG TrueffsNextDeviceNumber_tffsport = 0;
CRASHDUMP_DATA DumpData;
extern NTsocketParams driveInfo[SOCKETS];
ULONG VerifyWriteState[SOCKETS];
FAST_MUTEX driveInfoReferenceMutex;

const TFFS_DEVICE_TYPE TffsDeviceType_tffsport[] = {
    {"Disk",    "GenDisk",    "DiskPeripheral"}
};

const TFFS_DEVICE_TYPE TffsDeviceTypeFDO_tffsport[] = {
    {"Controller",    "FlashDiskController",    "FlashDiskPeripheral"}
};


BOOLEAN
DebugLogEvent(IN PDRIVER_OBJECT DriverObject, IN ULONG Value);


NTSTATUS
TrueffsStartDeviceOnDetect(IN PDEVICE_EXTENSION deviceExtension, IN PCM_RESOURCE_LIST ResourceList, IN BOOLEAN CheckResources);


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, TrueffsThread)
#endif


NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)

/*++

Routine Description:

    This routine is called at system initialization time so we can fill in the basic dispatch points

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS

--*/

{
    PTRUEFFSDRIVER_EXTENSION trueffsDriverExtension;
    NTSTATUS status;
    ULONG i;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DriverEntry\n"));
    DebugLogEvent(DriverObject, 1);
    DebugLogEvent(DriverObject, 2);
    DebugLogEvent(DriverObject, 3);

    for (i = 0; i < SOCKETS; i++) {
        driveInfo[i].interfAlive = 0;
        driveInfo[i].fdoExtension = NULL;
    }

    for (i = 0; i < VOLUMES; i++) {
        info[i].baseAddress= 0;
        info[i].nextPartition= 0;
    }

    ExInitializeFastMutex(&driveInfoReferenceMutex);

    if (!DriverObject) {

        return TrueffsCrashDumpDriverEntry(RegistryPath);
    }

    // Allocate Driver Object Extension for storing the RegistryPath
    status = IoAllocateDriverObjectExtension(
                 DriverObject,
                 DRIVER_OBJECT_EXTENSION_ID,
                 sizeof (DRIVER_EXTENSION),
                 &trueffsDriverExtension
                 );

    if (!NT_SUCCESS(status)) {

        TffsDebugPrint ((TFFS_DEB_ERROR,"Trueffs: DriverEntry: Unable to create driver extension\n"));
        return status;
    }

    RtlZeroMemory (
        trueffsDriverExtension,
        sizeof (DRIVER_EXTENSION)
        );

    // make copy of the RegistryPath
    trueffsDriverExtension->RegistryPath.Buffer = ExAllocatePoolWithTag (NonPagedPool, RegistryPath->Length * sizeof(WCHAR), TFFSPORT_POOL_TAG);
    if (trueffsDriverExtension->RegistryPath.Buffer == NULL) {
        TffsDebugPrint ((TFFS_DEB_ERROR,"Trueffs: DriverEntry: Unable to allocate memory for registry path\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    trueffsDriverExtension->RegistryPath.Length = 0;
    trueffsDriverExtension->RegistryPath.MaximumLength = RegistryPath->Length;
    RtlCopyUnicodeString (&trueffsDriverExtension->RegistryPath, RegistryPath);

    // Initialize the Driver Object with driver's entry points
    DriverObject->MajorFunction[IRP_MJ_CREATE] = TrueffsCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = TrueffsCreateClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = TrueffsDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SCSI] = TrueffsScsiRequests;

    DriverObject->DriverExtension->AddDevice = TrueffsAddDevice;
    DriverObject->MajorFunction[IRP_MJ_PNP] = TrueffsPnpDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_POWER] = TrueffsPowerControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = TrueffsDispatchSystemControl;

    DriverObject->DriverStartIo = TrueffsStartIo;
    DriverObject->DriverUnload = TrueffsUnload;

    TrueffsWmiInit();
    TrueffsDetectDiskOnChip(DriverObject, RegistryPath);

    return STATUS_SUCCESS;
}

NTSTATUS
TrueffsFetchKeyValue(
    IN PDRIVER_OBJECT       DriverObject,
    IN PUNICODE_STRING  RegistryPath,
        IN PWSTR                        KeyName,
        IN OUT ULONG*               KeyValue
)
    {
    RTL_QUERY_REGISTRY_TABLE    Table[3]; //must be parmaters + 2
    UNICODE_STRING                      SubPath;
    WCHAR                                           PathNameBuffer[30];
    NTSTATUS                                    ntStatus;

    //TffsDebugPrint(("Trueffs: TrueffsFetchKeyValue Start\n"));

    // Prepare Table - Must be Zero Terminated
    RtlZeroMemory(Table, sizeof(Table));

    // Create name string for the query Table
    SubPath.Buffer = PathNameBuffer;
    SubPath.MaximumLength = sizeof(PathNameBuffer);
    SubPath.Length = 0;

    RtlAppendUnicodeToString(&SubPath,L"Parameters");

    // 0 - just move us to the correct place under "Parameters" subkey
    Table[0].Name       = SubPath.Buffer;
    Table[0].Flags  = RTL_QUERY_REGISTRY_SUBKEY;

    Table[1].Name                   = KeyName;
    Table[1].Flags              = RTL_QUERY_REGISTRY_DIRECT;
    Table[1].EntryContext = KeyValue;

    *KeyValue = -1;

    ntStatus = RtlQueryRegistryValues(
                                    RTL_REGISTRY_ABSOLUTE,
                                    RegistryPath->Buffer,
                                    Table,
                                    NULL,NULL);

    if ( ((*KeyValue)==-1) || (!NT_SUCCESS(ntStatus)) )
        {
        //TffsDebugPrint(("Trueffs: TrueffsFetchKeyValue End, Key Not Found\n"));
        return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    else
        {
        //TffsDebugPrint(("Trueffs: TrueffsFetchKeyValue End, Key Found\n"));
        return ntStatus;
        }

    }

NTSTATUS
TrueffsDetectRegistryValues(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
)
    {
        RTL_QUERY_REGISTRY_TABLE    Table[14]; //must be parmaters + 2


        NTSTATUS                                    ntStatus;
        ULONG                                           prevValue;
        ULONG                                           keyValue;
        FLStatus                    status = flOK;
        ULONG                                           CurrVerifyWriteState;
        ULONG                                           currSocket = 0;



        //TffsDebugPrint(("Trueffs: TrueffsDetectRegistryValues Start\n"));
#ifdef ENVIRONMENT_VARS
        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_ISRAM_CHECK_ENABLED",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_IS_RAM_CHECK_ENABLED,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_TL_CACHE_ENABLED",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_TL_CACHE_ENABLED,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_DOC_8BIT_ACCESS",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_DOC_8BIT_ACCESS,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_SUSPEND_MODE",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_SUSPEND_MODE,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_MTD_BUS_ACCESS_TYPE",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_MTD_BUS_ACCESS_TYPE,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_SET_POLICY",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_SET_POLICY,keyValue,&prevValue);



        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL0",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus) && currSocket++<SOCKETS)
                VerifyWriteState[0] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL1",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus)&& currSocket++<SOCKETS)
                VerifyWriteState[1] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL2",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus)&& currSocket++<SOCKETS)
                VerifyWriteState[2] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL3",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus)&& currSocket++<SOCKETS)
                VerifyWriteState[3] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL4",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus)&& currSocket++<SOCKETS)
                VerifyWriteState[4] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL5",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus)&& currSocket++<SOCKETS)
                VerifyWriteState[5] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL6",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus)&& currSocket++<SOCKETS)
                VerifyWriteState[6] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BDTL7",&CurrVerifyWriteState);
        if (NT_SUCCESS(ntStatus)&& currSocket++<SOCKETS)
                VerifyWriteState[7] = CurrVerifyWriteState;

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_SECTORS_VERIFIED_PER_FOLDING",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_SECTORS_VERIFIED_PER_FOLDING,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_BINARY",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_VERIFY_WRITE_BINARY,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_VERIFY_WRITE_OTHER",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_VERIFY_WRITE_OTHER,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_SET_MAX_CHAIN",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_SET_MAX_CHAIN,keyValue,&prevValue);

        ntStatus = TrueffsFetchKeyValue(DriverObject,RegistryPath,L"FL_MARK_DELETE_ON_FLASH",&keyValue);
        if (NT_SUCCESS(ntStatus))
            status = flSetEnvAll(FL_MARK_DELETE_ON_FLASH,keyValue,&prevValue);

        return ntStatus;
#endif /* ENVIRONMENT_VARS*/
        //TffsDebugPrint(("Trueffs: TrueffsDetectRegistryValues End\n"));


        return STATUS_SUCCESS;
    }

ULONG
TrueffsCrashDumpDriverEntry (
    PVOID Context
    )
/*++

Routine Description:

    dump driver entry point

Arguments:

    Context - PCRASHDUMP_INIT_DATA

Return Value:

    NT Status

--*/
{
    PINITIALIZATION_CONTEXT context = Context;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CrashDumpDriverEntry\n"));

    DumpData.CrashInitData = (PCRASHDUMP_INIT_DATA) context->PortConfiguration;
    DumpData.StallRoutine  = context->StallRoutine;

    context->OpenRoutine    = TrueffsCrashDumpOpen;
    context->WriteRoutine   = TrueffsCrashDumpWrite;
    context->FinishRoutine  = TrueffsCrashDumpFinish;

    return STATUS_SUCCESS;
}


BOOLEAN
TrueffsCrashDumpOpen (
    IN LARGE_INTEGER PartitionOffset
    )
{
    TffsDebugPrint((TFFS_DEB_INFO, "Trueffs: CrashDumpOpen: PartitionOffset = 0x%x%08x...\n", PartitionOffset.HighPart, PartitionOffset.LowPart));
    DumpData.PartitionOffset = PartitionOffset;
    RtlMoveMemory (&DumpData.fdoExtension,DumpData.CrashInitData->cdFdoExtension,sizeof (DEVICE_EXTENSION));
    DumpData.MaxBlockSize = DumpData.fdoExtension.BytesPerSector * 256;
    return TRUE;
}


NTSTATUS
TrueffsCrashDumpWrite (
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    )
{
    NTSTATUS    status;
    ULONG       blockSize;
    ULONG       bytesWritten = 0;
    ULONG       startingSector;
    FLStatus    tffsStatus;
    IOreq       ioreq;

    TffsDebugPrint((TFFS_DEB_INFO,
               "TrueffsCrashDumpWrite: Write memory at 0x%x for 0x%x bytes\n",
                Mdl->MappedSystemVa,
                Mdl->ByteCount));

    if (Mdl->ByteCount % DumpData.fdoExtension.BytesPerSector) {
        // must be complete sectors
        TffsDebugPrint((TFFS_DEB_ERROR, "TrueffsCrashDumpWrite ERROR: not writing full sectors\n"));
        return STATUS_INVALID_PARAMETER;
    }
    if ((Mdl->ByteCount / DumpData.fdoExtension.BytesPerSector) > 256) {
        // need code to split request up
        TffsDebugPrint((TFFS_DEB_ERROR, "TrueffsCrashDumpWrite ERROR: can't handle large write\n"));
        return STATUS_INVALID_PARAMETER;
    }
    do {
        if ((Mdl->ByteCount - bytesWritten) > DumpData.MaxBlockSize) {
            blockSize = DumpData.MaxBlockSize;
            TffsDebugPrint((TFFS_DEB_INFO, "Trueffs: TrueffsCrashDumpWrite: can't do a single write\n"));

        } else {
            blockSize = Mdl->ByteCount - bytesWritten;
        }
        status = STATUS_UNSUCCESSFUL;
        startingSector = (ULONG)((DumpData.PartitionOffset.QuadPart +
                        (*DiskByteOffset).QuadPart +
                        (ULONGLONG) bytesWritten) / DumpData.fdoExtension.BytesPerSector);

        ioreq.irHandle = DumpData.fdoExtension.UnitNumber;
        ioreq.irSectorNo = startingSector;
        ioreq.irSectorCount = blockSize / DumpData.fdoExtension.BytesPerSector;
        ioreq.irData = ((PUCHAR) Mdl->MappedSystemVa) + bytesWritten;
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CrashDumpWrite: Starting sector is %x, Number of bytes %x\n",
                            startingSector,
                            blockSize));
        tffsStatus = flAbsWrite(&ioreq);
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CrashDumpWrite: Write status %Xh\n", tffsStatus));

        if (tffsStatus == flOK) {
            status = STATUS_SUCCESS;
            bytesWritten += blockSize;
        }
    } while (bytesWritten < Mdl->ByteCount);
    return status;
}


VOID
TrueffsCrashDumpFinish (
    VOID
    )
{
    TffsDebugPrint((TFFS_DEB_INFO, "Trueffs: TrueffsCrashDumpFinish\n"));
    return;
}


NTSTATUS
TrueffsDispatchSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL (WMI) IRPs

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION thisIrpSp;
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    PPDO_EXTENSION pdoExtension;
    PDEVICE_EXTENSION_HEADER devExtension;

    thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
    devExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;
    if (IS_FDO(devExtension)) {

        TffsDebugPrint((TFFS_DEB_WARN,"Trueffs: DispatchSystemControl: WMI IRP (FDO) %Xh not handled. Passing it down.\n",thisIrpSp->MinorFunction));
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExtension->LowerDeviceObject, Irp);
    }
    else {

        if (thisIrpSp->MinorFunction < NUM_WMI_MINOR_FUNCTION) {

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DispatchSystemControl (WMI) %Xh PDO\n",thisIrpSp->MinorFunction));
            status = TrueffsWmiSystemControl(DeviceObject, Irp);
        } else {

            TffsDebugPrint((TFFS_DEB_WARN,"Trueffs: DispatchSystemControl (WMI) %Xh PDO unsupported\n",thisIrpSp->MinorFunction));
            status = Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
    }
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DispatchSystemControl status %Xh\n", status));
    return status;
}


NTSTATUS
TrueffsFindDiskOnChip(
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber,
    IN ULONG            StartSearchAddress,
    IN LONG             WindowSize,
    IN BOOLEAN          StartSearch,
    OUT PVOID           *WindowBase
    )

{
    ULONG                           DOCAddressSpace = TFFS_MEMORY_SPACE;
    PVOID                           DOCAddressBase = NULL;
    PHYSICAL_ADDRESS                DOCAddressMemoryBase;
    NTSTATUS                        status;
    ULONG                           winBase;
    volatile UCHAR                  chipId;
    volatile UCHAR                  toggle1;
    volatile UCHAR                  toggle2;
    volatile UCHAR                  deviceSearch;

    DOC2window                      *memDOC2000WinPtr = NULL;
        MDOCPwindow                                         *memWinPtr = NULL;

    status = TrueffsTranslateAddress(InterfaceType,
                          BusNumber,
                          RtlConvertLongToLargeInteger(StartSearchAddress),
                          WindowSize,
                          &DOCAddressSpace,
                          &DOCAddressBase,
                              &DOCAddressMemoryBase);

    if (!NT_SUCCESS(status)) {
       if (status == STATUS_NOT_IMPLEMENTED) {
           status = STATUS_UNSUCCESSFUL;
       }

             TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():Failed to alloc memory\n"));
       return status;
    }

        /* DOC2000*/
    memDOC2000WinPtr = (DOC2window *) DOCAddressBase;

    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, ASIC_NORMAL_MODE);
    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, ASIC_NORMAL_MODE);

    chipId = tffsReadByte(memDOC2000WinPtr->chipId);

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():After read DOC2000 chipID\n"));
        if ((chipId == CHIP_ID_DOC) || (chipId == CHIP_ID_MDOC)) {
            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():In chip ID  DOC2000 or MDOC\n"));
      if (chipId == CHIP_ID_MDOC) {
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():In the MDOC\n"));
          toggle1 = tffsReadByte(memDOC2000WinPtr->ECCconfig);
          toggle2 = toggle1 ^ tffsReadByte(memDOC2000WinPtr->ECCconfig);
      }
      else {
                  TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():In the DOC2000\n"));
          toggle1 = tffsReadByte(memDOC2000WinPtr->ECCstatus);
          toggle2 = toggle1 ^ tffsReadByte(memDOC2000WinPtr->ECCstatus);
      }

      if (!StartSearch) {
         if ((toggle2 & TOGGLE) != 0) {
             if (chipId == CHIP_ID_MDOC) {
                 tffsWriteByte(memDOC2000WinPtr->aliasResolution, ALIAS_RESOLUTION);
             }
             else {
                                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():Failed  Toggle\n"));
                 tffsWriteByte(memDOC2000WinPtr->deviceSelector, ALIAS_RESOLUTION);
             }
             *WindowBase = DOCAddressBase;
             TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DiskOnChip detected on %Xh\n",StartSearchAddress));
             return STATUS_SUCCESS;
         }
      }
      else {
         deviceSearch = ( chipId == CHIP_ID_MDOC ) ? tffsReadByte(memDOC2000WinPtr->aliasResolution) :
                                                     tffsReadByte(memDOC2000WinPtr->deviceSelector);
         if (((toggle2 & TOGGLE) != 0) && (deviceSearch == ALIAS_RESOLUTION)) {
                     TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():Free Window pointer\n"));
              TrueffsFreeTranslatedAddress(
                   DOCAddressBase,
                   WindowSize,
                   DOCAddressSpace
                   );

              TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Alias detected on %Xh\n",StartSearchAddress));
              return STATUS_NOT_IMPLEMENTED;
         }
      }
    }

        //Start MDOCP code
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():Start looking for MDOCP\n"));
        memWinPtr = (MDOCPwindow *) DOCAddressBase;

        memWinPtr->DOCcontrol       =  (unsigned char)0x05; /* Set RESET Mode */
        memWinPtr->DocCntConfirmReg = (unsigned char)0xfa;

        chipId = memWinPtr->chipId;


        if (chipId == 0x40)
        {
                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():Identify as MDOCP\n"));
                toggle1 = tffsReadByte(memWinPtr->EccCntReg);
        toggle2 = toggle1 ^ tffsReadByte(memWinPtr->EccCntReg);

        if (!StartSearch)
        {
            //if ((toggle2 & ECC_CNTRL_TOGGLE_MASK) != 0)
            if ((toggle2 & 0x4) != 0)
            {
                tffsWriteByte(memWinPtr->AliasResolution, ALIAS_RESOLUTION);
                *WindowBase = DOCAddressBase;
                 TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MDOCP detected on %Xh\n",StartSearchAddress));
                return STATUS_SUCCESS;
            }
            else
            {

                deviceSearch = tffsReadByte(memWinPtr->AliasResolution);
                //if (((toggle2 & ECC_CNTRL_TOGGLE_MASK) != 0) && (deviceSearch == ALIAS_RESOLUTION))
                if (((toggle2 & 0x4) != 0) && (deviceSearch == ALIAS_RESOLUTION))

                {
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c :TrueffsFindDiskOnChip():MDOCP Failed togfle  - Free memory\n"));
                    TrueffsFreeTranslatedAddress(
                        DOCAddressBase,
                        WindowSize,
                        DOCAddressSpace
                        );
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Alias detected on %Xh\n",StartSearchAddress));
                    return STATUS_NOT_IMPLEMENTED;
                }

            }
        }
    }





    TrueffsFreeTranslatedAddress(
                DOCAddressBase,
                WindowSize,
                DOCAddressSpace
                );

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DiskOnChip not detected on %Xh\n", StartSearchAddress));
    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
TrueffsCheckDiskOnChip(
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber,
    IN ULONG            StartSearchAddress,
    IN LONG             WindowSize,
    OUT PVOID           *WindowBase,
    OUT PULONG          AddressSpace
    )

{
    ULONG                           DOCAddressSpace = TFFS_MEMORY_SPACE;
    PVOID                           DOCAddressBase = NULL;
    PHYSICAL_ADDRESS                DOCAddressMemoryBase;
    NTSTATUS                        status;
    volatile UCHAR                  chipId;
    volatile UCHAR                  toggle1;
    volatile UCHAR                  toggle2;

    DOC2window                      *memDOC2000WinPtr;
        MDOCPwindow                     *memWinPtr;


        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c: TrueffsCheckDiskOnChip() Started ...\n"));
    status = TrueffsTranslateAddress(InterfaceType,
                      BusNumber,
                      RtlConvertLongToLargeInteger(StartSearchAddress),
                      WindowSize,
                      &DOCAddressSpace,
                      &DOCAddressBase,
                      &DOCAddressMemoryBase);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    memDOC2000WinPtr = (DOC2window *) DOCAddressBase;

    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, 0x84);
    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, 0x84);
    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, 0x85);
    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, 0x85);

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c: TrueffsCheckDiskOnChip() DOC2000 read chip ID\n"));
    chipId = tffsReadByte(memDOC2000WinPtr->chipId);
        if ((chipId == CHIP_ID_DOC) || (chipId == CHIP_ID_MDOC)) {
            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c: TrueffsCheckDiskOnChip() DOC2000 chipID = 0x%x\n", chipId));
        if (chipId == CHIP_ID_MDOC) {
            toggle1 = tffsReadByte(memDOC2000WinPtr->ECCconfig);
            toggle2 = toggle1 ^ tffsReadByte(memDOC2000WinPtr->ECCconfig);
        }
        else {
            toggle1 = tffsReadByte(memDOC2000WinPtr->ECCstatus);
            toggle2 = toggle1 ^ tffsReadByte(memDOC2000WinPtr->ECCstatus);
        }
        if ((toggle2 & TOGGLE) != 0) {
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c: TrueffsCheckDiskOnChip() DOC2000 Finished toggle successfuly\n"));
            *WindowBase = DOCAddressBase;
            *AddressSpace = DOCAddressSpace;
            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DiskOnChip2000 found on %Xh\n",StartSearchAddress));
            return STATUS_SUCCESS;
        }
    }


        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c: TrueffsCheckDiskOnChip() MDOCPLUS Start....\n"));
        memWinPtr = (MDOCPwindow *) DOCAddressBase;
        tffsWriteByte(memWinPtr->DOCcontrol, (unsigned char)0x04);
    tffsWriteByte(memWinPtr->DocCntConfirmReg, (unsigned char)0xfb);
    tffsWriteByte(memWinPtr->DOCcontrol, (unsigned char)0x05);
    tffsWriteByte(memWinPtr->DocCntConfirmReg, (unsigned char)0xfa);
        chipId = tffsReadByte(memWinPtr->chipId);

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c: TrueffsCheckDiskOnChip() MDOCPLUS chipID = 0x%x\n", chipId));

        //if (chipId == CHIP_ID_MDOCP)
        if (chipId == 0x40)
        {
                toggle1 = tffsReadByte(memWinPtr->EccCntReg);
        toggle2 = toggle1 ^ tffsReadByte(memWinPtr->EccCntReg);

                //if ((toggle2 & ECC_CNTRL_TOGGLE_MASK) != 0)
                if ((toggle2 & 0x4) != 0)
                {
                    *WindowBase = DOCAddressBase;
                    *AddressSpace = DOCAddressSpace;
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MDOCPLUS found on %Xh\n",StartSearchAddress));
                    return STATUS_SUCCESS;
                }
        }


    TrueffsFreeTranslatedAddress(
            DOCAddressBase,
            WindowSize,
            DOCAddressSpace
            );
    return STATUS_UNSUCCESSFUL;
}


VOID
TrueffsResetDiskOnChip(
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber,
    IN ULONG            StartSearchAddress,
    IN LONG             WindowSize
    )

{
    ULONG                           DOCAddressSpace = TFFS_MEMORY_SPACE;
    PVOID                           DOCAddressBase = NULL;
    PHYSICAL_ADDRESS                DOCAddressMemoryBase;
    NTSTATUS                        status;

    DOC2window                      *memDOC2000WinPtr;

        MDOCPwindow                     *memWinPtr;


        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c:TrueffsResetDiskOnChip()b start\n"));
    status = TrueffsTranslateAddress(InterfaceType,
                          BusNumber,
                          RtlConvertLongToLargeInteger(StartSearchAddress),
                          WindowSize,
                          &DOCAddressSpace,
                          &DOCAddressBase,
                          &DOCAddressMemoryBase);

    if (!NT_SUCCESS(status)) {
        return;
    }
        /* DOC2000 CHANGES*/
    memDOC2000WinPtr = (DOC2window *) DOCAddressBase;
    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, 0x84);
    tffsWriteByte(memDOC2000WinPtr->DOCcontrol, 0x84);

        memWinPtr = (MDOCPwindow *) DOCAddressBase;
    tffsWriteByte(memWinPtr->DOCcontrol,(unsigned char)0x04 );
    tffsWriteByte(memWinPtr->DocCntConfirmReg,(unsigned char)0xfb );

        TrueffsFreeTranslatedAddress(
            DOCAddressBase,
            WindowSize,
            DOCAddressSpace
            );
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: tffsport.c:TrueffsResetDiskOnChip()b End\n"));
    return;
}

NTSTATUS
TrueffsStartSubDevice(
    IN UCHAR                deviceNo,
    IN UCHAR                partitionNumber,
    IN PDEVICE_EXTENSION    deviceExtension,
    IN PCM_RESOURCE_LIST    ResourceList,
    IN BOOLEAN              CheckResources
)
{
    NTSTATUS    status = STATUS_UNSUCCESSFUL;

    ExAcquireFastMutex(&driveInfoReferenceMutex);

    deviceExtension->UnitNumber = (partitionNumber << 4) + deviceNo;
    if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)) {
        status = TrueffsCreateSymblicLinks(deviceExtension);
        if (!NT_SUCCESS(status)) {
            return STATUS_UNSUCCESSFUL;
        }
    }
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartDevice OK\n"));
    ExReleaseFastMutex(&driveInfoReferenceMutex);
    return STATUS_SUCCESS;
}


NTSTATUS
TrueffsDetectDiskOnChip(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
)

{
    ULONG                           cmResourceListSize;
    PCM_RESOURCE_LIST               cmResourceList = NULL;
    PCM_FULL_RESOURCE_DESCRIPTOR    cmFullResourceDescriptor;
    PCM_PARTIAL_RESOURCE_LIST       cmPartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartialDescriptors;
    BOOLEAN                         conflictDetected;
    PDEVICE_OBJECT                  detectedPhysicalDeviceObject;
    PDEVICE_EXTENSION               fdoExtensions[VOLUMES];
    NTSTATUS                        status;
    ULONG                           legacyDetection = 0;
    ULONG                           searchBase, aliasSearchBase, aliasCounter;
    PVOID                           mappedWindowBase = NULL;
    KIRQL                           cIrql;
    BOOLEAN                         startSearch = FALSE;
    int noOfDevices = 0;
    int deviceNo    = 0;
    UCHAR currSockets = 0;
    int index = 0;
    CM_RESOURCE_LIST               arrayResourceList[VOLUMES];
    ULONG prevValue;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DetectDiskOnChip\n"));

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DetectDiskOnChip, go to Registry\n"));
        // Set Registry Vars to TrueFFS
        TrueffsDetectRegistryValues(DriverObject,RegistryPath);
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DetectDiskOnChip, back from Registry\n"));


    if (!TrueffsOkToDetectLegacy(DriverObject)) {
        // legacy detection is not enabled
        TffsDebugPrint((TFFS_DEB_WARN,"Trueffs: DetectDiskOnChip: detection is not enabled\n"));
        return STATUS_SUCCESS;
    }

    // disable legacy detection for next boot
    TrueffsGetParameterFromServiceSubKey (
            DriverObject,
            LEGACY_DETECTION,
            REG_DWORD,
            FALSE,
            (PVOID) &legacyDetection,
            sizeof (legacyDetection)
            );

    cmResourceListSize = sizeof (CM_RESOURCE_LIST);
    cmResourceList = ExAllocatePoolWithTag (PagedPool, cmResourceListSize, TFFSPORT_POOL_TAG);
    if (cmResourceList == NULL){
        status = STATUS_NO_MEMORY;
        goto GetOut;
    }

    RtlZeroMemory(cmResourceList, cmResourceListSize);

    for(index = 0; index < VOLUMES; index++){
        fdoExtensions[index] = NULL;
        //arrayResourceList[index] = ExAllocatePoolWithTag (PagedPool, cmResourceListSize, TFFSPORT_POOL_TAG);
        //RtlZeroMemory(arrayResourceList[index], cmResourceListSize );

    }
    RtlZeroMemory(arrayResourceList, cmResourceListSize * VOLUMES);

    // Build resource requirement list
    cmResourceList->Count = 1;
    cmFullResourceDescriptor = cmResourceList->List;
    cmFullResourceDescriptor->InterfaceType = DISKONCHIP_INTERFACE;
    cmFullResourceDescriptor->BusNumber = DISKONCHIP_BUSNUMBER;
    cmPartialResourceList = &cmFullResourceDescriptor->PartialResourceList;
    cmPartialResourceList->Version = 1;
    cmPartialResourceList->Revision = 1;
    cmPartialResourceList->Count = 1;
    cmPartialDescriptors = cmPartialResourceList->PartialDescriptors;

    cmPartialDescriptors[0].Type             = CmResourceTypeMemory;
    cmPartialDescriptors[0].ShareDisposition = CmResourceShareShared;
    cmPartialDescriptors[0].Flags            = CM_RESOURCE_MEMORY_READ_ONLY;
    cmPartialDescriptors[0].u.Memory.Length  = DISKONCHIP_WINDOW_SIZE;


    for(searchBase = START_SEARCH_ADDRESS; searchBase < END_SEARCH_ADDRESS ; searchBase += DISKONCHIP_WINDOW_SIZE) {
        cmPartialDescriptors[0].u.Memory.Start.QuadPart = searchBase;

          // check to see if the resource is available
        status = IoReportResourceForDetection (
                         DriverObject,
                         cmResourceList,
                         cmResourceListSize,
                         NULL,
                         NULL,
                         0,
                         &conflictDetected
                         );
        if (!NT_SUCCESS(status) || conflictDetected) {
            if (NT_SUCCESS(status)) {
                IoReportResourceForDetection (
                                 DriverObject,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 0,
                                 &conflictDetected
                                 );
                status = STATUS_UNSUCCESSFUL;
            }
        }
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IoReportResourceForDetection with status %Xh\n",status));

        if (!NT_SUCCESS (status)) {
            continue;
        }


        TrueffsResetDiskOnChip(cmFullResourceDescriptor->InterfaceType,cmFullResourceDescriptor->BusNumber,searchBase,DISKONCHIP_WINDOW_SIZE);

        // release the resources
        IoReportResourceForDetection (
                     DriverObject,
                     NULL,
                     0,
                     NULL,
                     NULL,
                     0,
                     &conflictDetected
                     );



        // check to see if the resource is available
        status = IoReportResourceForDetection (
                         DriverObject,
                         cmResourceList,
                         cmResourceListSize,
                         NULL,
                         NULL,
                         0,
                         &conflictDetected
                         );
        if (!NT_SUCCESS(status) || conflictDetected) {
            if (NT_SUCCESS(status)) {
                IoReportResourceForDetection (
                                 DriverObject,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 0,
                                 &conflictDetected
                                 );
                status = STATUS_UNSUCCESSFUL;
            }
        }
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IoReportResourceForDetection with status %Xh\n",status));

     //   if (!NT_SUCCESS (status)) {
     //       continue;
     //   }

        if (NT_SUCCESS (status)) {
            status = TrueffsFindDiskOnChip(cmFullResourceDescriptor->InterfaceType,cmFullResourceDescriptor->BusNumber,searchBase,DISKONCHIP_WINDOW_SIZE, startSearch,&mappedWindowBase);
        }
        else{
            continue;
        }

                // release the resources we have grab, IoReportDetectedDevice()
        // will grab them for us again when we call and it will grab them
        // on behalf of the detected PDO.
        IoReportResourceForDetection (
                     DriverObject,
                     NULL,
                     0,
                     NULL,
                     NULL,
                     0,
                     &conflictDetected
                     );

        if (NT_SUCCESS (status)) {
            detectedPhysicalDeviceObject = NULL;

            status = IoReportDetectedDevice(DriverObject,
                                            Isa,
                                            0,
                                            0,
                                            cmResourceList,
                                            NULL,
                                            FALSE,
                                            &detectedPhysicalDeviceObject);

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IoReportDetectedDevice returned status %Xh\n",status));

            if (NT_SUCCESS (status)) {

            // create a FDO and attach it to the detected PDO
                status = TrueffsCreateDevObject(
                             DriverObject,
                             detectedPhysicalDeviceObject,
                             &fdoExtensions[noOfDevices]
                             );
            }
            if (NT_SUCCESS (status)) {
                status = TrueffsStartDeviceOnDetect(fdoExtensions[noOfDevices],cmResourceList,TRUE);
                if (NT_SUCCESS (status)) {
                    memcpy(&arrayResourceList[noOfDevices++],cmResourceList, cmResourceListSize);
                    //moti tffscpy(&arrayResourceList[noOfDevices++],cmResourceList, cmResourceListSize);
                    //tffscpy(arrayResourceList[noOfDevices++],cmResourceList, cmResourceListSize);
                }
            }
        }
    }


    //Mounting all devices includes sub handles
    for(deviceNo = 0;deviceNo < noOfDevices;deviceNo++) {
        FLStatus flStatus = flOK;
        status = STATUS_SUCCESS;
        status = TrueffsMountMedia(fdoExtensions[deviceNo]);
        if (!NT_SUCCESS (status)) {
            // go through the remove sequence
            if (fdoExtensions[deviceNo]) {
                IoDetachDevice(fdoExtensions[deviceNo]->LowerDeviceObject);
                IoDeleteDevice(fdoExtensions[deviceNo]->DeviceObject);
            }
            continue;
        }
        else {
            IOreq ioreq;
            int partitionNumber = 0;
            int noOfPartitions = 0;
            ioreq.irHandle =  deviceNo;
            flStatus= flCountVolumes(&ioreq);
            if(flStatus == flOK)
                noOfPartitions = ioreq.irFlags;
            else
                noOfPartitions = 1;
            KeAcquireSpinLock(&fdoExtensions[deviceNo]->ExtensionDataSpinLock,&cIrql);
            fdoExtensions[deviceNo]->DeviceFlags &= ~DEVICE_FLAG_STOPPED;
            fdoExtensions[deviceNo]->DeviceFlags |= DEVICE_FLAG_STARTED;
            KeReleaseSpinLock(&fdoExtensions[deviceNo]->ExtensionDataSpinLock,cIrql);

            //Handle sub partitions
            for(partitionNumber = 1;partitionNumber < noOfPartitions;partitionNumber++){
                PDEVICE_EXTENSION               fdoExtension = NULL;
                status = STATUS_SUCCESS;

                // release the resources we have grab, IoReportDetectedDevice()
                // will grab them for us again when we call and it will grab them
                // on behalf of the detected PDO.
/*              IoReportResourceForDetection (
                             DriverObject,
                             NULL,
                             0,
                             NULL,
                             NULL,
                             0,
                             &conflictDetected
                             );
*/

                detectedPhysicalDeviceObject = NULL;
                status = IoReportDetectedDevice(DriverObject,
                                                Isa,
                                                0,
                                                0,
                                                &arrayResourceList[deviceNo],
                                                //arrayResourceList[deviceNo],
                                                NULL,
                                                FALSE,
                                                &detectedPhysicalDeviceObject);

                TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IoReportDetectedDevice returned status %Xh\n",status));

                if (NT_SUCCESS (status)) {

                // create a FDO and attach it to the detected PDO

                    status = TrueffsCreateDevObject(
                                 DriverObject,
                                 detectedPhysicalDeviceObject,
                                 &fdoExtension
                                 );
                }
                if (NT_SUCCESS (status)) {
                    status = TrueffsStartSubDevice((unsigned char)deviceNo,
                                                    (unsigned char)partitionNumber,
                                                    fdoExtension,
                                                    &arrayResourceList[deviceNo],
                                                    //arrayResourceList[deviceNo],
                                                    TRUE);
                }
                if (NT_SUCCESS (status)) {
                    status = TrueffsMountMedia(fdoExtension);
                    if (!NT_SUCCESS (status)) {
                    // go through the remove sequence
                        if (fdoExtension) {
                            IoDetachDevice(fdoExtension->LowerDeviceObject);
                            IoDeleteDevice(fdoExtension->DeviceObject);
                        }
                        continue;
                    }
                    else{
                        KeAcquireSpinLock(&fdoExtension->ExtensionDataSpinLock,&cIrql);
                        fdoExtension->DeviceFlags &= ~DEVICE_FLAG_STOPPED;
                        fdoExtension->DeviceFlags |= DEVICE_FLAG_STARTED;
                        KeReleaseSpinLock(&fdoExtension->ExtensionDataSpinLock,cIrql);
                    }
                }
            }
        }
    }
GetOut:

    if (cmResourceList) {
        ExFreePool (cmResourceList);
        cmResourceList = NULL;
    }

    for(index = 0; index < VOLUMES; index++){
        fdoExtensions[index] = NULL;
    }


#ifdef ENVIRONMENT_VARS

      for ( currSockets = 0; currSockets < SOCKETS; currSockets++) {
            if (VerifyWriteState[currSockets])
                status = flSetEnvSocket(FL_VERIFY_WRITE_BDTL,currSockets,VerifyWriteState[currSockets],&prevValue);
    }

#endif /*ENVIRONMENT_VARS       */


        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DetectDiskOnChip with status %Xh\n",status));

    return status;
}

NTSTATUS
TrueffsTranslateAddress(
    IN INTERFACE_TYPE      InterfaceType,
    IN ULONG               BusNumber,
    IN PHYSICAL_ADDRESS    StartAddress,
    IN LONG                Length,
    IN OUT PULONG          AddressSpace,
    OUT PVOID              *TranslatedAddress,
    OUT PPHYSICAL_ADDRESS  TranslatedMemoryAddress
    )
/*++

Routine Description:

    translate i/o address

Arguments:

    InterfaceType - bus interface

    BusNumber - bus number

    StartAddress - address to translate

    Length - number of byte to translate

    AddressSpace - address space for the given address

Return Value:

    AddressSpace - address space for the translated address

    TranslatedAddress - translated address

    TranslatedMemoryAddress - tranlated memory address if translated to memory space

    NT Status

--*/
{
    PHYSICAL_ADDRESS       translatedAddress;

    *TranslatedAddress = NULL;
    TranslatedMemoryAddress->QuadPart = (ULONGLONG) NULL;

    if (HalTranslateBusAddress(InterfaceType,
                               BusNumber,
                               StartAddress,
                               AddressSpace,
                               &translatedAddress)) {


        if (*AddressSpace == TFFS_IO_SPACE) {
            *TranslatedMemoryAddress = translatedAddress;
            *TranslatedAddress = (PVOID) translatedAddress.QuadPart;

        } else if (*AddressSpace == TFFS_MEMORY_SPACE) {

            // translated address is in memory space,
            *TranslatedMemoryAddress = translatedAddress;

            *TranslatedAddress = MmMapIoSpace(
                                    translatedAddress,
                                    Length,
                                    FALSE);
        }
    }
    if (*TranslatedAddress) {
        return STATUS_SUCCESS;

    } else {
        return STATUS_INVALID_PARAMETER;
    }
}


VOID
TrueffsFreeTranslatedAddress(
    IN PVOID               TranslatedAddress,
    IN LONG                Length,
    IN ULONG               AddressSpace
    )
/*++

Routine Description:

    free resources created for a translated address

Arguments:

    TranslatedAddress - translated address

    Length - number of byte to translated

    AddressSpace - address space for the translated address

Return Value:

    None

--*/
{
    if (TranslatedAddress) {
        if (AddressSpace == TFFS_MEMORY_SPACE) {
            MmUnmapIoSpace (
                TranslatedAddress,
                Length
                );
        }
    }
    return;
}


NTSTATUS
TrueffsAddDevice(
    PDRIVER_OBJECT  DriverObject,
    PDEVICE_OBJECT  Pdo
    )

/*++

Routine Description:

    This is our PNP AddDevice called with the PDO ejected from the bus driver

Arguments:

    Argument1          - Driver Object.
    Argument2          - PDO.


Return Value:

    A valid return code for a DriverEntry routine.

--*/

{

    NTSTATUS            status;
    PDEVICE_EXTENSION   fdoExtension;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: AddDevice\n"));
    status = TrueffsCreateDevObject (DriverObject,Pdo,&fdoExtension);
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: AddDevice with status %Xh\n", status));
    return status;
}


NTSTATUS
TrueffsCreateDevObject(
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           Pdo,
    OUT PDEVICE_EXTENSION       *FdoExtension
    )

/*++

Routine Description:

    This routine creates an object for the physical device specified and
    sets up the deviceExtension.

Arguments:

    DriverObject - Pointer to driver object created by system.

    PhysicalDeviceObject = PDO we should attach to.


Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          status;
    PDEVICE_OBJECT    deviceObject = NULL;
    STRING            deviceName;
    CCHAR             deviceNameBuffer[64];
    UNICODE_STRING    unicodeDeviceNameString;
    UNICODE_STRING    driverName;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CreateDevObject\n"));

    sprintf(deviceNameBuffer, "\\Device\\TffsPort%d",TrueffsNextDeviceNumber_tffsport);
    RtlInitString(&deviceName, deviceNameBuffer);
    status = RtlAnsiStringToUnicodeString(&unicodeDeviceNameString,
                                          &deviceName,
                                          TRUE);
    if (!NT_SUCCESS (status)) {
        return status;
    }
    status = IoCreateDevice(DriverObject,
                            sizeof(DEVICE_EXTENSION),
                            &unicodeDeviceNameString,   // our name
                            FILE_DEVICE_CONTROLLER,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &deviceObject);

    RtlFreeUnicodeString (&unicodeDeviceNameString);

    if (!NT_SUCCESS(status)) {
        TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: CreateDevObject: IoCreateDevice failed with status %Xh\n",status));
        return status;
    }
    else {
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Created FDO %Xh\n",deviceObject));
    }

    deviceExtension = deviceObject->DeviceExtension;
    RtlZeroMemory(deviceExtension,sizeof(DEVICE_EXTENSION));

    if (Pdo != NULL) {
        if ((deviceExtension->LowerDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject,Pdo))==NULL){
            TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: CreateDevObject: cannot attach device\n"));

            IoDeleteDevice(deviceObject);
            return status;
        }
    }

    KeInitializeSemaphore(&deviceExtension->requestSemaphore,0L,MAXLONG);

    KeInitializeSpinLock(&deviceExtension->listSpinLock);

    InitializeListHead(&deviceExtension->listEntry);

    KeInitializeSpinLock(&deviceExtension->ExtensionDataSpinLock);

    KeInitializeEvent(&deviceExtension->PendingIRPEvent, SynchronizationEvent, FALSE);

    deviceExtension->threadReferenceCount = -1;

    deviceExtension->pcmciaParams.physWindow = 0;
    deviceExtension->pcmciaParams.windowSize = 0;
    deviceExtension->pcmciaParams.windowBase = NULL;

    deviceObject->Flags |= DO_DIRECT_IO;
    deviceExtension->DeviceObject = deviceObject;
    deviceExtension->MainPdo = Pdo;
    deviceExtension->DriverObject = DriverObject;
    deviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;
    deviceObject->Flags &=~DO_DEVICE_INITIALIZING;
    deviceExtension->DeviceFlags |= DEVICE_FLAG_STOPPED;

#if 0 //Pcmcia cards don't have removable media
    RtlInitUnicodeString(&driverName, L"\\Driver\\Pcmcia");
    if (!RtlCompareUnicodeString(&Pdo->DriverObject->DriverName,&driverName,TRUE)) {
        deviceExtension->removableMedia = TRUE;
    }
#endif

    deviceExtension->TrueffsDeviceNumber = TrueffsNextDeviceNumber_tffsport;
    TrueffsNextDeviceNumber_tffsport++;
    deviceExtension->ScsiDeviceType = DIRECT_ACCESS_DEVICE;

    *FdoExtension = deviceExtension;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CreateDevObject with status %Xh\n",status));
    return status;
}



NTSTATUS
TrueffsStartDeviceOnDetect(
    IN PDEVICE_EXTENSION    deviceExtension,
    IN PCM_RESOURCE_LIST    ResourceList,
    IN BOOLEAN              CheckResources
)
/*++

Routine Description:

    This is our START_DEVICE, called when we get an IPR_MN_START_DEVICE.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
    NTSTATUS    status = STATUS_UNSUCCESSFUL;
    ULONG       i;
    ULONG       j;
    PVOID       mappedWindowBase =  NULL;
    ULONG       addressSpace;

    // assume we have DOC
        ExAcquireFastMutex(&driveInfoReferenceMutex);
    if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)) {
        for (i = 0; i < DOC_DRIVES; i++) {
            if (driveInfo[i].fdoExtension == NULL) {
                deviceExtension->UnitNumber = i;
                break;
            }
        }
    }
    // Check resources
    if (CheckResources) {
        if (ResourceList == NULL || ResourceList->List == NULL) {
            TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartDevice: No resources !\n"));
            goto exitStartDevice;
        }
        fullResourceList = ResourceList->List;
        for (i = 0; i < ResourceList->Count; i++) {

            partialResourceList = &(fullResourceList->PartialResourceList);
            partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

            for (j = 0; j < partialResourceList->Count; j++) {

                if (partialDescriptors[j].Type == CmResourceTypeMemory) {
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Memory %Xh Size %Xh Interf %Xh Bus %Xh\n",
                                    partialDescriptors[j].u.Memory.Start.LowPart,
                                    partialDescriptors[j].u.Memory.Length,
                                    fullResourceList->InterfaceType,
                                    fullResourceList->BusNumber));
                    status = TrueffsCheckDiskOnChip(
                        fullResourceList->InterfaceType,
                        fullResourceList->BusNumber,
                        partialDescriptors[j].u.Memory.Start.LowPart,
                        partialDescriptors[j].u.Memory.Length,
                        &mappedWindowBase,
                        &addressSpace
                        );
                    if (NT_SUCCESS(status)) {
                        deviceExtension->pcmciaParams.windowBase = mappedWindowBase;
                        deviceExtension->pcmciaParams.windowSize = partialDescriptors[j].u.Memory.Length;
                        deviceExtension->pcmciaParams.addressSpace = addressSpace;
                        deviceExtension->pcmciaParams.phWindowBase = RtlConvertLongToLargeInteger(partialDescriptors[j].u.Memory.Start.LowPart);
                        deviceExtension->pcmciaParams.physWindow = partialDescriptors[j].u.Memory.Start.QuadPart;
                        deviceExtension->pcmciaParams.InterfaceType = fullResourceList->InterfaceType;
                        deviceExtension->pcmciaParams.BusNumber = fullResourceList->BusNumber;
                        updateDocSocketParams(deviceExtension);
                        goto goodResources;
                    }
                }
            }
            fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + partialResourceList->Count);
        }

        // DiskOnChip was not found, assume this is PCMCIA
        if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)) {
            for (i = DOC_DRIVES; i < SOCKETS; i++) {
                if (driveInfo[i].fdoExtension == NULL) {
                    deviceExtension->UnitNumber = i;
                    break;
                }
            }
        }

        fullResourceList = ResourceList->List;
        for (i = 0; i < ResourceList->Count; i++) {

            partialResourceList = &(fullResourceList->PartialResourceList);
            partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

            for (j = 0; j < partialResourceList->Count; j++) {

                if (partialDescriptors[j].Type == CmResourceTypeMemory) {
                    PHYSICAL_ADDRESS AddressMemoryBase;
                    ULONG PcmciaAddressSpace = TFFS_MEMORY_SPACE;
                    deviceExtension->pcmciaParams.windowSize = partialDescriptors[j].u.Memory.Length;
                    deviceExtension->pcmciaParams.phWindowBase = RtlConvertLongToLargeInteger(partialDescriptors[j].u.Memory.Start.LowPart);
                    deviceExtension->pcmciaParams.physWindow = partialDescriptors[j].u.Memory.Start.QuadPart;
                    deviceExtension->pcmciaParams.InterfaceType = fullResourceList->InterfaceType;
                    deviceExtension->pcmciaParams.BusNumber = fullResourceList->BusNumber;
                    mappedWindowBase = NULL;
                    status = TrueffsTranslateAddress(
                                        deviceExtension->pcmciaParams.InterfaceType,
                                        deviceExtension->pcmciaParams.BusNumber,
                                        deviceExtension->pcmciaParams.phWindowBase,
                                        deviceExtension->pcmciaParams.windowSize,
                                        &PcmciaAddressSpace,
                                        &mappedWindowBase,
                                        &AddressMemoryBase);
                    deviceExtension->pcmciaParams.windowBase = mappedWindowBase;
                    deviceExtension->pcmciaParams.addressSpace = PcmciaAddressSpace;
                    if (!NT_SUCCESS(status)) {
                        goto exitStartDevice;
                                    }
                                    status = updatePcmciaSocketParams(deviceExtension);
                    if (NT_SUCCESS(status)) {
                                                goto goodResources;
                    }
                            }
                    }
                    fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + partialResourceList->Count);
            }
        TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartDevice: pnp manager gave me bad resources!\n"));
        status = STATUS_INVALID_PARAMETER;
        goto exitStartDevice;
    }

goodResources:

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Window at %Xh\n",mappedWindowBase));
    if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)) {

        // Create legacy object names
        status = TrueffsCreateSymblicLinks(deviceExtension);
        if (!NT_SUCCESS(status)) {
            goto exitStartDevice;
        }
    }
        ExReleaseFastMutex(&driveInfoReferenceMutex);
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartDevice OK\n"));
    return STATUS_SUCCESS;

exitStartDevice:

    if (!NT_SUCCESS(status)) {
        TrueffsStopRemoveDevice(deviceExtension);
        TrueffsDeleteSymblicLinks(deviceExtension);
    }
        ExReleaseFastMutex(&driveInfoReferenceMutex);
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartDevice: exit with status %Xh\n",status));
    return status;
}
//==============================================
NTSTATUS
TrueffsStartDevice(
    IN PDEVICE_EXTENSION    deviceExtension,
    IN PCM_RESOURCE_LIST    ResourceList,
    IN BOOLEAN              CheckResources
)
/*++

Routine Description:

    This is our START_DEVICE, called when we get an IPR_MN_START_DEVICE.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
    NTSTATUS    status = STATUS_UNSUCCESSFUL;
    ULONG       i;
    ULONG       j;
    PVOID       mappedWindowBase =  NULL;
    ULONG       addressSpace;

    // assume we have DOC
     ExAcquireFastMutex(&driveInfoReferenceMutex);

    // Check resources
    if (CheckResources) {
        if (ResourceList == NULL || ResourceList->List == NULL) {
            TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartDevice: No resources !\n"));
            goto exitStartDevice;
        }
        fullResourceList = ResourceList->List;
        for (i = 0; i < ResourceList->Count; i++) {

            partialResourceList = &(fullResourceList->PartialResourceList);
            partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

            for (j = 0; j < partialResourceList->Count; j++) {

                if (partialDescriptors[j].Type == CmResourceTypeMemory) {
                                    //Get handle here
                                    int  deviceIndex = 0;
                                    long baseAddress = partialDescriptors[j].u.Memory.Start.LowPart;

                                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Memory %Xh Size %Xh Interf %Xh Bus %Xh\n",
                                                                                        partialDescriptors[j].u.Memory.Start.LowPart,
                                                                                        partialDescriptors[j].u.Memory.Length,
                                                                                        fullResourceList->InterfaceType,
                                                                                        fullResourceList->BusNumber));

                                    status = TrueffsCheckDiskOnChip(
                                        fullResourceList->InterfaceType,
                                        fullResourceList->BusNumber,
                                        partialDescriptors[j].u.Memory.Start.LowPart,
                                        partialDescriptors[j].u.Memory.Length,
                                        &mappedWindowBase,
                                        &addressSpace
                                        );

                                    if (NT_SUCCESS(status)) {
                                        for(deviceIndex = 0; deviceIndex < DOC_DRIVES; deviceIndex++) {
                                            //If Main partition exists
                                             if(info[deviceIndex].baseAddress == baseAddress){
                                                deviceExtension->UnitNumber = deviceIndex + (info[deviceIndex].nextPartition << 4);
                                                info[deviceIndex].nextPartition++;
                                                break;
                                             }
                                             //In case of Main partition doesn't exist
                                             else if((info[deviceIndex].baseAddress == 0) && (baseAddress != 0)){
                                                 info[deviceIndex].baseAddress = baseAddress;
                                                deviceExtension->UnitNumber = deviceIndex;
                                                info[deviceIndex].nextPartition++;
                                                break;
                                            }
                                        }
                                        if(deviceIndex == DOC_DRIVES){
                                            goto pcmciaResources;
                                        }
                                    }
                                    if (NT_SUCCESS(status)) {
                                        deviceExtension->pcmciaParams.windowBase = mappedWindowBase;
                                        deviceExtension->pcmciaParams.windowSize = partialDescriptors[j].u.Memory.Length;
                                        deviceExtension->pcmciaParams.addressSpace = addressSpace;
                                        deviceExtension->pcmciaParams.phWindowBase = RtlConvertLongToLargeInteger(partialDescriptors[j].u.Memory.Start.LowPart);
                                        deviceExtension->pcmciaParams.physWindow = partialDescriptors[j].u.Memory.Start.QuadPart;
                                        deviceExtension->pcmciaParams.InterfaceType = fullResourceList->InterfaceType;
                                        deviceExtension->pcmciaParams.BusNumber = fullResourceList->BusNumber;

                                        //In case of Main partition
                                        if((deviceExtension->UnitNumber & 0xf0) == 0)
                                            updateDocSocketParams(deviceExtension);
                                        goto goodResources;
                                    }
                }
            }
            fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + partialResourceList->Count);
        }


pcmciaResources:
        // DiskOnChip was not found, assume this is PCMCIA
        if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)) {
            for (i = DOC_DRIVES; i < SOCKETS; i++) {
                if (driveInfo[i].fdoExtension == NULL) {
                    deviceExtension->UnitNumber = i;
                    break;
                }
            }
        }

        fullResourceList = ResourceList->List;
        for (i = 0; i < ResourceList->Count; i++) {

            partialResourceList = &(fullResourceList->PartialResourceList);
            partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

            for (j = 0; j < partialResourceList->Count; j++) {

                if (partialDescriptors[j].Type == CmResourceTypeMemory) {
                    PHYSICAL_ADDRESS AddressMemoryBase;
                    ULONG PcmciaAddressSpace = TFFS_MEMORY_SPACE;
                    deviceExtension->pcmciaParams.windowSize = partialDescriptors[j].u.Memory.Length;
                    deviceExtension->pcmciaParams.phWindowBase = RtlConvertLongToLargeInteger(partialDescriptors[j].u.Memory.Start.LowPart);
                    deviceExtension->pcmciaParams.physWindow = partialDescriptors[j].u.Memory.Start.QuadPart;
                    deviceExtension->pcmciaParams.InterfaceType = fullResourceList->InterfaceType;
                    deviceExtension->pcmciaParams.BusNumber = fullResourceList->BusNumber;
                    mappedWindowBase = NULL;
                    status = TrueffsTranslateAddress(
                                        deviceExtension->pcmciaParams.InterfaceType,
                                        deviceExtension->pcmciaParams.BusNumber,
                                        deviceExtension->pcmciaParams.phWindowBase,
                                        deviceExtension->pcmciaParams.windowSize,
                                        &PcmciaAddressSpace,
                                        &mappedWindowBase,
                                        &AddressMemoryBase);
                    deviceExtension->pcmciaParams.windowBase = mappedWindowBase;
                    deviceExtension->pcmciaParams.addressSpace = PcmciaAddressSpace;
                    if (!NT_SUCCESS(status)) {
                        goto exitStartDevice;
                    }
                    status = updatePcmciaSocketParams(deviceExtension);

                    if (NT_SUCCESS(status)) {
                        goto goodResources;
                    }
                }
             }
             fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + partialResourceList->Count);
        }
        TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StartDevice: pnp manager gave me bad resources!\n"));
        status = STATUS_INVALID_PARAMETER;
        goto exitStartDevice;
    }

goodResources:

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Window at %Xh\n",mappedWindowBase));
    if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)) {

        // Create legacy object names
        status = TrueffsCreateSymblicLinks(deviceExtension);
        if (!NT_SUCCESS(status)) {
            goto exitStartDevice;
        }
    }
        ExReleaseFastMutex(&driveInfoReferenceMutex);
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartDevice OK\n"));
    return STATUS_SUCCESS;

exitStartDevice:

    if (!NT_SUCCESS(status)) {
        TrueffsStopRemoveDevice(deviceExtension);
        TrueffsDeleteSymblicLinks(deviceExtension);
    }
        ExReleaseFastMutex(&driveInfoReferenceMutex);
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StartDevice: exit with status %Xh\n",status));
    return status;
}


NTSTATUS
TrueffsMountMedia(
    IN PDEVICE_EXTENSION    deviceExtension
)
/*++

Routine Description:

    This is a part of START_DEVICE, called when we get an IPR_MN_START_DEVICE.

Arguments:

    DeviceObject

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS       status;
    FLStatus       flStatus = flOK;
        FLStatus       flStatusProt = flOK;
    IOreq          ioreq;
        IOreq          ioreqProt;
    HANDLE         threadHandle;
        ULONG          heads, sectors, cylinders;
        ULONG                    prevValue;
        UCHAR currSockets = 0;


    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MountMedia\n"));

    ioreq.irHandle = deviceExtension->UnitNumber;
    flStatus = flAbsMountVolume(&ioreq);

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MountMedia: flMountVolume returned status %Xh\n",flStatus));

    if (flStatus != flOK) {
        status = STATUS_UNRECOGNIZED_MEDIA;
        goto exitMountMedia;
    }

    //Identify Write Protected Disk
    ioreqProt.irHandle = ioreq.irHandle;
    ioreqProt.irFlags = 0;
    flStatusProt = flIdentifyProtection(&ioreqProt);
    if(flStatusProt == flOK){
        if(ioreqProt.irFlags& WRITE_PROTECTED){

            deviceExtension->IsWriteProtected = TRUE;
            deviceExtension->IsPartitonTableWritten = FALSE;
            RtlZeroMemory (deviceExtension->PartitonTable, sizeof(deviceExtension->PartitonTable));
        }
        else{
            deviceExtension->IsWriteProtected = FALSE;
            deviceExtension->IsPartitonTableWritten = FALSE;
        }
    }
    else{

        deviceExtension->IsWriteProtected = FALSE;
        deviceExtension->IsPartitonTableWritten = FALSE;
    }

    //Identify SW Write Protected Disk
    deviceExtension->IsSWWriteProtected = FALSE;

/*      flStatusProt = flIdentifySWProtection(&ioreqProt);
    if(flStatusProt == flOK){
        if(ioreqProt.irFlags& WRITE_PROTECTED){

            deviceExtension->IsSWWriteProtected = TRUE;
        }
        else{
            deviceExtension->IsSWWriteProtected = FALSE;
        }
    }
    else{

        deviceExtension->IsSWWriteProtected = FALSE;
    }
*/
    //In case of protection allocate Partiton table
    flSectorsInVolume(&ioreq);
    deviceExtension->totalSectors    = ioreq.irLength;
    deviceExtension->BytesPerSector  = SECTOR_SIZE;
    flBuildGeometry(deviceExtension->totalSectors, &cylinders, &heads, &sectors,0);
    deviceExtension->SectorsPerTrack = sectors;
    deviceExtension->NumberOfHeads   = heads;
    deviceExtension->Cylinders       = cylinders;

    deviceExtension->totalSectors    = deviceExtension->SectorsPerTrack *
                                       deviceExtension->NumberOfHeads *
                                       deviceExtension->Cylinders;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: internal geometry #sectors %x, #heads %x, #cylinders %x #total %x\n",
                                        deviceExtension->SectorsPerTrack,
                                        deviceExtension->NumberOfHeads,
                                        deviceExtension->Cylinders,
                                        deviceExtension->totalSectors));

    if (!(deviceExtension->DeviceFlags & DEVICE_FLAG_STARTED)) {

        if (AllocatePdo(deviceExtension) == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exitMountMedia;
        }

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Created PDO %Xh\n",deviceExtension->ChildPdo));

        if (++(deviceExtension->threadReferenceCount) == 0) {
            deviceExtension->threadReferenceCount++;

            // Create the thread
            status = PsCreateSystemThread(&threadHandle,
                        (ACCESS_MASK) 0L,
                        NULL,
                        (HANDLE) 0L,
                        NULL,
                        TrueffsThread,
                        deviceExtension);

            TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: PsCreateSystemThread returned status %Xh\n", status));

            if (!NT_SUCCESS(status)) {
                deviceExtension->threadReferenceCount = -1;
                goto exitMountMedia;
            }
            else {
                status = ObReferenceObjectByHandle( threadHandle,
                                                    SYNCHRONIZE,
                                                    NULL,
                                                    KernelMode,
                                                    &deviceExtension->TffsportThreadObject,
                                                    NULL );

                ASSERT(NT_SUCCESS(status));

                // Not needed.. we have the TffsportThreadObject
                // deviceExtension->DeviceFlags |= DEVICE_FLAG_THREAD;
            }

            ZwClose(threadHandle);
        }
    }

#ifdef ENVIRONMENT_VARS

      for ( currSockets = 0; currSockets < SOCKETS; currSockets++) {
            if (VerifyWriteState[currSockets])
                status = flSetEnvSocket(FL_VERIFY_WRITE_BDTL,currSockets,VerifyWriteState[currSockets],&prevValue);
    }

#endif /*ENVIRONMENT_VARS       */

    return STATUS_SUCCESS;

exitMountMedia:

    if (!NT_SUCCESS(status)) {
        TrueffsStopRemoveDevice(deviceExtension);
        TrueffsDeleteSymblicLinks(deviceExtension);
    }
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MountMedia: exit with status %Xh\n",status));
    return status;
}

UCHAR
TrueffsGetInfoNumber
(
     PDEVICE_EXTENSION    deviceExtension
    )
{
    UCHAR unitNumber;
    UCHAR i = 0;
    for(; i < (UCHAR)DOC_DRIVES;i++){
        if(info[i].baseAddress == (long)deviceExtension->pcmciaParams.phWindowBase.LowPart)
                break;
    }

    return i;
}

NTSTATUS
TrueffsStopRemoveDevice(
    PDEVICE_EXTENSION    deviceExtension
    )
{
    IOreq ioreq;
    UCHAR deviceIndex;

    TffsDebugPrint((TFFS_DEB_ERROR,"Trueffs: StopRemoveDevice: removed deviceExtension->UnitNumber = %0x\n", deviceExtension->UnitNumber));
    if (deviceExtension->pcmciaParams.windowBase == NULL &&
            deviceExtension->pcmciaParams.physWindow == 0 &&
            driveInfo[deviceExtension->UnitNumber].fdoExtension == NULL) {
               TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: StopRemoveDevice: Device was already stopped or removed\n"));
                return STATUS_SUCCESS;
    }
    ioreq.irHandle = deviceExtension->UnitNumber;
    flDismountVolume(&ioreq);

    deviceIndex = TrueffsGetInfoNumber(deviceExtension);
    //In case of DiskOnChip (especially MDOCP)
    if( deviceIndex < DOC_DRIVES){

/*      TrueffsFreeTranslatedAddress(deviceExtension->pcmciaParams.windowBase,
                                     deviceExtension->pcmciaParams.windowSize,
                                     deviceExtension->pcmciaParams.addressSpace
                                     );
                                     */

        deviceExtension->pcmciaParams.windowBase = NULL;
        deviceExtension->pcmciaParams.physWindow = 0;

        //In case of MainPartition
        if((deviceExtension->UnitNumber & 0xf0) == 0){
            driveInfo[deviceExtension->UnitNumber].fdoExtension = NULL;
            driveInfo[deviceExtension->UnitNumber].interfAlive = 0;
            info[deviceIndex].baseAddress = 0;
        }
        info[deviceIndex].nextPartition  = (unsigned char)(((deviceExtension->UnitNumber & 0xf0) )>>4);
            //  info[deviceIndex].nextPartition--;

    }
    //PCMCIA
    else{
        TrueffsFreeTranslatedAddress(deviceExtension->pcmciaParams.windowBase,
                                         deviceExtension->pcmciaParams.windowSize,
                                         deviceExtension->pcmciaParams.addressSpace
                                         );
        deviceExtension->pcmciaParams.windowBase = NULL;
        deviceExtension->pcmciaParams.physWindow = 0;
        driveInfo[deviceExtension->UnitNumber].fdoExtension = NULL;
        driveInfo[deviceExtension->UnitNumber].interfAlive = 0;
    }
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: RemoveDevice\n"));
    return STATUS_SUCCESS;
}


NTSTATUS
TrueffsCreateSymblicLinks (
    PDEVICE_EXTENSION FdoExtension
    )
{
    NTSTATUS            status;
    ULONG               i;
    PULONG              scsiportNumber;

    STRING              deviceName;
    CCHAR               deviceNameBuffer[64];
    WCHAR               deviceSymbolicNameBuffer[64];
    UNICODE_STRING      unicodeDeviceNameString;
    UNICODE_STRING      unicodeDeviceSymbolicNameString;
    UNICODE_STRING      unicodeDeviceArcNameString;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CreateSymblicLinks\n"));

    sprintf(deviceNameBuffer, "\\Device\\TffsPort%d", FdoExtension->TrueffsDeviceNumber);
    RtlInitString(&deviceName, deviceNameBuffer);
    status = RtlAnsiStringToUnicodeString(&unicodeDeviceNameString,
                                          &deviceName,
                                          TRUE);
    if (!NT_SUCCESS (status)) {

        return status;
    }

    scsiportNumber = &IoGetConfigurationInformation()->ScsiPortCount;

    unicodeDeviceSymbolicNameString.Length = 0;
    unicodeDeviceSymbolicNameString.MaximumLength = 64 * sizeof(WCHAR);
    unicodeDeviceSymbolicNameString.Buffer = deviceSymbolicNameBuffer;

    for (i=0; i <= (*scsiportNumber); i++) {

        sprintf(deviceNameBuffer, "\\Device\\ScsiPort%d", i);
        RtlInitString(&deviceName, deviceNameBuffer);
        status = RtlAnsiStringToUnicodeString(&unicodeDeviceSymbolicNameString,
                                              &deviceName,
                                              FALSE);

        if (!NT_SUCCESS (status)) {

            break;
        }

        status = IoCreateSymbolicLink(
                     &unicodeDeviceSymbolicNameString,
                     &unicodeDeviceNameString
                     );

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: IoCreateSymbolicLink returned status %Xh\n",status));

        if (NT_SUCCESS (status)) {

            sprintf(deviceNameBuffer, "\\DosDevices\\Scsi%d:", i);
            RtlInitString(&deviceName, deviceNameBuffer);
            status = RtlAnsiStringToUnicodeString(&unicodeDeviceArcNameString,
                                                  &deviceName,
                                                  TRUE);

            if (!NT_SUCCESS (status)) {

                break;
            }

            IoAssignArcName (
                &unicodeDeviceArcNameString,
                &unicodeDeviceNameString
                );

            RtlFreeUnicodeString (&unicodeDeviceArcNameString);

            break;
        }
    }


    if (NT_SUCCESS(status)) {

        FdoExtension->SymbolicLinkCreated = TRUE;
        FdoExtension->ScsiPortNumber = i;
        (*scsiportNumber)++;
    }

    RtlFreeUnicodeString (&unicodeDeviceNameString);

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: CreateSymblicLinks exit with status %Xh\n",status));

    return status;
}


NTSTATUS
TrueffsDeleteSymblicLinks (
    PDEVICE_EXTENSION FdoExtension
    )
{
    NTSTATUS            status;
    ULONG               i;
    STRING              deviceName;
    CCHAR               deviceNameBuffer[64];
    UNICODE_STRING      unicodeDeviceSymbolicNameString;
    UNICODE_STRING      unicodeDeviceArcNameString;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeleteSymblicLinks\n"));

    if (!FdoExtension->SymbolicLinkCreated) {

        return STATUS_SUCCESS;
    }

    sprintf(deviceNameBuffer, "\\Device\\ScsiPort%d", FdoExtension->ScsiPortNumber);
    RtlInitString(&deviceName, deviceNameBuffer);
    status = RtlAnsiStringToUnicodeString(&unicodeDeviceSymbolicNameString,
                                          &deviceName,
                                          TRUE);
    if (NT_SUCCESS (status)) {

        sprintf(deviceNameBuffer, "\\DosDevices\\Scsi%d:", FdoExtension->ScsiPortNumber);
        RtlInitString(&deviceName, deviceNameBuffer);
        status = RtlAnsiStringToUnicodeString(&unicodeDeviceArcNameString,
                                              &deviceName,
                                              TRUE);

        if (NT_SUCCESS (status)) {

            status = IoDeleteSymbolicLink(
                         &unicodeDeviceSymbolicNameString
                         );

            if (NT_SUCCESS (status)) {

                IoDeassignArcName(&unicodeDeviceArcNameString);
                FdoExtension->SymbolicLinkCreated = FALSE;

                IoGetConfigurationInformation()->ScsiPortCount--;
            }

            RtlFreeUnicodeString (&unicodeDeviceArcNameString);
        }

        RtlFreeUnicodeString (&unicodeDeviceSymbolicNameString);
    }

    return status;
}


VOID
TrueffsUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Does nothing really...

Arguments:

    DriverObject - the driver being unloaded

Return Value:

    none

--*/

{
    PTRUEFFSDRIVER_EXTENSION trueffsDriverExtension;

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Unload\n"));
    flExit();
    trueffsDriverExtension = IoGetDriverObjectExtension(
                                DriverObject,
                                DRIVER_OBJECT_EXTENSION_ID
                                );

    if (trueffsDriverExtension && trueffsDriverExtension->RegistryPath.Buffer != NULL)
    {
        ExFreePool(trueffsDriverExtension->RegistryPath.Buffer);
    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: Exitting Unload\n"));
    return;
}


NTSTATUS
TrueffsDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the device control dispatcher.

Arguments:

    DeviceObject
    Irp

Return Value:


    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSTORAGE_PROPERTY_QUERY query;
    //Amir
    PGET_MEDIA_TYPES getMediaTypes;
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    PPDO_EXTENSION pdoExtension;
    PDEVICE_EXTENSION_HEADER devExtension;
    BOOLEAN Fdo = FALSE;
        //Amir
        FLStatus    tffsStatus;
    IOreq       ioreq;
        flIOctlRecord flIoctlRec;
        //End Amir
    devExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;
    if (IS_FDO(devExtension)) {
        deviceExtension = DeviceObject->DeviceExtension;
        Fdo = TRUE;
    }
    else {
        pdoExtension = DeviceObject->DeviceExtension;
        deviceExtension = pdoExtension->Pext;
    }

    Irp->IoStatus.Information = 0;
    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: Code %Xh\n",irpStack->Parameters.DeviceIoControl.IoControlCode));

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_DISK_GET_DRIVE_GEOMETRY: {

        PDISK_GEOMETRY  pDiskGeometry = NULL;

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: GET_DISK_GEOMETRY\n"));

        // Check size of return buffer
        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(DISK_GEOMETRY)) {

            status = Irp->IoStatus.Status = STATUS_INFO_LENGTH_MISMATCH;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

        pDiskGeometry = (PDISK_GEOMETRY)Irp->AssociatedIrp.SystemBuffer;

        // Trueffs is always Fixed Media
        pDiskGeometry->MediaType = FixedMedia;

        // All the fields neccesary are filled in during mount-media
        pDiskGeometry->TracksPerCylinder = deviceExtension->NumberOfHeads;
        pDiskGeometry->SectorsPerTrack = deviceExtension->SectorsPerTrack;
        pDiskGeometry->BytesPerSector = deviceExtension->BytesPerSector;
        pDiskGeometry->Cylinders.QuadPart =
            (LONGLONG)(deviceExtension->totalSectors /
                (pDiskGeometry->TracksPerCylinder * pDiskGeometry->SectorsPerTrack));

        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TracksPerCylinder 0x%x, "
                        "SectorsPerTrack 0x%x, BytesPerSector: 0x%x, Cylinders 0x%x\n",
                        pDiskGeometry->TracksPerCylinder, pDiskGeometry->SectorsPerTrack,
                        pDiskGeometry->BytesPerSector, pDiskGeometry->Cylinders.QuadPart
                        ));

        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;
    }

     //AmirM
    /*case IOCTL_STORAGE_GET_MEDIA_TYPES: {
        PGET_MEDIA_TYPES  mediaTypes = Irp->AssociatedIrp.SystemBuffer;
        PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];


        TffsDebugPrint((TFFS_DEB_INFO,"$$$$$$$$$$$$$IOCTL_STORAGE_GET_MEDIA_TYPES_EX \n"));

        //
        // Ensure that buffer is large enough.
        //

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(GET_MEDIA_TYPES)) {

            //
            // Buffer too small.
            //

            Irp->IoStatus.Information = 0;
            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        mediaTypes->DeviceType =  FILE_DEVICE_DISK;
        mediaTypes->MediaInfoCount = 1;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.Cylinders.QuadPart = (LONGLONG)(deviceExtension->totalSectors /
                                                                            (deviceExtension->NumberOfHeads * deviceExtension->SectorsPerTrack));
        mediaInfo->DeviceSpecific.RemovableDiskInfo.TracksPerCylinder = deviceExtension->NumberOfHeads;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.SectorsPerTrack = deviceExtension->SectorsPerTrack;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.BytesPerSector = deviceExtension->BytesPerSector;

        //
        // Set the type.
        //
        mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaType = FixedMedia;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.NumberMediaSides = 1;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics = MEDIA_WRITE_PROTECTED;

        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = sizeof(GET_MEDIA_TYPES);
        IoCompleteRequest(Irp, 0);
        break;
        }
*/
      case IOCTL_STORAGE_QUERY_PROPERTY: {

        // Validate the query
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: StorageQueryProperty\n"));

        query = Irp->AssociatedIrp.SystemBuffer;

        if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
           sizeof(STORAGE_PROPERTY_QUERY)) {

            status = Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, 0);
            break;
        }

        status = TrueffsQueryProperty(deviceExtension, Irp);
        TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: QueryProperty returned status %Xh\n", status));
        break;
        }

      case IOCTL_SCSI_GET_DUMP_POINTERS:

          DebugLogEvent(DeviceObject->DriverObject, 300);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: ScsiGetDumpPointers\n"));

          if (Fdo) {
            status = Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, 0);
            return status;
          }
          if (Irp->RequestorMode != KernelMode) {
              status = Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

          } else if (irpStack->Parameters.DeviceIoControl.OutputBufferLength
                    < sizeof(DUMP_POINTERS)) {
              status = Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;

          } else {
              PCRASHDUMP_INIT_DATA dumpInitData;

              dumpInitData = ExAllocatePoolWithTag (NonPagedPool, sizeof (CRASHDUMP_INIT_DATA), TFFSPORT_POOL_TAG);
              if (dumpInitData) {
                  PDUMP_POINTERS dumpPointers;
                  dumpPointers = (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;

                  RtlZeroMemory (dumpInitData, sizeof (CRASHDUMP_INIT_DATA));
                  dumpInitData->cdFdoExtension = pdoExtension->Pext;
                  dumpPointers->AdapterObject      = NULL;
                  dumpPointers->MappedRegisterBase = NULL;
                  dumpPointers->DumpData           = dumpInitData;
                  dumpPointers->CommonBufferVa     = NULL;
                  dumpPointers->CommonBufferPa.QuadPart = 0;
                  dumpPointers->CommonBufferSize      = 0;
                  dumpPointers->DeviceObject          = pdoExtension->DeviceObject;
                  dumpPointers->AllocateCommonBuffers = FALSE;

                  status = Irp->IoStatus.Status = STATUS_SUCCESS;
                  Irp->IoStatus.Information = sizeof(DUMP_POINTERS);
              } else {
                  status = Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
              }
          }
          IoCompleteRequest(Irp, 0);
          break;
            case IOCTL_TFFSFL_UNIQUE_ID:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsGetUniqueId\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: TffsGetUniqueId Completed\n"));
                    Irp->IoStatus.Status = status;
          break;

            case IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MOTIR: IOCTL_TFFS_FORMAT_PHYSICAL_DRIVE Completed\n"));
                    Irp->IoStatus.Status = status;
          break;

    #ifdef HW_PROTECTION
            case IOCTL_TFFS_BDTL_HW_PROTECTION:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_BDTL_HW_PROTECTION\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MOTIR: IOCTL_TFFS_BDTL_HW_PROTECTION Completed\n"));
                    Irp->IoStatus.Status = status;
          break;
            case IOCTL_TFFS_BINARY_HW_PROTECTION:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_BINARY_HW_PROTECTION\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MOTIR: IOCTL_TFFS_BINARY_HW_PROTECTION Completed\n"));
                    Irp->IoStatus.Status = status;
          break;
    #endif /*HW_PROTECTION*/
    #ifdef HW_OTP
            case IOCTL_TFFS_OTP:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_OTP\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MOTIR: IOCTL_TFFS_OTP Completed\n"));
                    Irp->IoStatus.Status = status;
          break;
    #endif /*HW_OTP*/
    #ifdef WRITE_EXB_IMAGE
            case IOCTL_TFFS_PLACE_EXB_BY_BUFFER:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_PLACE_EXB_BY_BUFFER\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MOTIR: IOCTL_TFFS_PLACE_EXB_BY_BUFFER Completed\n"));
                    Irp->IoStatus.Status = status;
          break;
    #endif /*WRITE_EXB_IMAGE*/
            case IOCTL_TFFS_DEEP_POWER_DOWN_MODE:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_DEEP_POWER_DOWN_MODE\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MOTIR: IOCTL_TFFS_DEEP_POWER_DOWN_MODE Completed\n"));
                    Irp->IoStatus.Status = status;
          break;
            case IOCTL_TFFSFL_INQUIRE_CAPABILITIES:
                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsGetInquireCapabilities\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: MOTIR: TffsGetInquireCapabilities Completed\n"));
                    Irp->IoStatus.Status = status;
          break;

            case IOCTL_TFFS_GET_INFO:           // User TFFS IOCTL - FL_GET_INFO

                    DebugLogEvent(DeviceObject->DriverObject, 200);
          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsGetInfo\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: TffsGetInfo start get info\n"));
                    Irp->IoStatus.Status = status;
          break;

      case IOCTL_TFFS_DEFRAGMENT:       // User TFFS IOCTL - FL_DEFRAGMENT

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsDefragment\n"));
          status = QueueIrpToThread(Irp, deviceExtension);
          Irp->IoStatus.Status = status;
          break;
#ifdef VERIFY_VOLUME
            case IOCTL_TFFS_VERIFY_VOLUME:

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsVerifyVolume\n"));
          status = QueueIrpToThread(Irp, deviceExtension);
          Irp->IoStatus.Status = status;
          break;
#endif VERIFY_VOLUME

      case IOCTL_TFFS_WRITE_PROTECT:    // User TFFS IOCTL - FL_WRITE_PROTECT

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsWriteProtect\n"));
          status = QueueIrpToThread(Irp, deviceExtension);
          Irp->IoStatus.Status = status;
          break;

      case IOCTL_TFFS_MOUNT_VOLUME:     // User TFFS IOCTL - FL_MOUNT_VOLUME

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsMountVolume\n"));
          status = QueueIrpToThread(Irp, deviceExtension);
          Irp->IoStatus.Status = status;
          break;

      case IOCTL_TFFS_FORMAT_VOLUME:    // User TFFS IOCTL - FL_FORMAT_VOLUME

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsFormatVolume\n"));
          status = QueueIrpToThread(Irp, deviceExtension);
          Irp->IoStatus.Status = status;
          break;

      case IOCTL_TFFS_BDK_OPERATION:    // User TFFS IOCTL - FL_BDK_OPERATION

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_BDK_OPERATION\n"));
                    status = QueueIrpToThread(Irp, deviceExtension);
                    Irp->IoStatus.Status = status;
                    break;

      case IOCTL_TFFS_DELETE_SECTORS:   // User TFFS IOCTL - FL_DELETE_SECTORS

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: TffsDeleteSectors\n"));
                    status = QueueIrpToThread(Irp, deviceExtension);
                    Irp->IoStatus.Status = status;
                    break;
        case IOCTL_TFFS_CUSTOMER_ID:            // User TFFS IOCTL - FL_IOCTL_NUMBER_OF_PARTITIONS

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_CUSTOMER_ID\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : start IOCTL_TFFS_CUSTOMER_ID\n"));
                    Irp->IoStatus.Status = status;
          break;

            case IOCTL_TFFS_EXTENDED_WRITE_IPL:         // User TFFS IOCTL -

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_EXTENDED_WRITE_IPL\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : start IOCTL_TFFS_EXTENDED_WRITE_IPL\n"));
                    Irp->IoStatus.Status = status;
          break;

#ifdef ENVIRONMENT_VARS
            case IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES:         // User TFFS IOCTL -

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : start IOCTL_TFFS_EXTENDED_ENVIRONMENT_VARIABLES\n"));
                    Irp->IoStatus.Status = status;
          break;
#endif /* ENVIRONMENT_VARS */

            case IOCTL_TFFS_NUMBER_OF_PARTITIONS:           // User TFFS IOCTL - FL_IOCTL_NUMBER_OF_PARTITIONS

          TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: FL_IOCTL_NUMBER_OF_PARTITIONS\n"));
            status = QueueIrpToThread(Irp, deviceExtension);
                    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: : start FL_IOCTL_NUMBER_OF_PARTITIONS\n"));
                    Irp->IoStatus.Status = status;
          break;

/*      case IOCTL_DISK_IS_WRITABLE:
            TffsDebugPrint((TFFS_DEB_ERROR,"#$$%^%$%#%$#%#%$#%#%#%#%#%#%#%$#%#%\n"));
            status = Irp->IoStatus.Status = STATUS_MEDIA_WRITE_PROTECTED;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, 0);
            break;
            */
      default:

        TffsDebugPrint((TFFS_DEB_WARN,"Trueffs: DeviceControl: not suported\n"));
        status = Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, 0);
        break;

    }

    TffsDebugPrint((TFFS_DEB_INFO,"Trueffs: DeviceControl: exit with status %Xh\n", status));

    return status;
}

NTSTATUS
TrueffsQueryProperty(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PIRP QueryIrp
    )

/*++

Routine Description:

    This routine will handle a property query request.

Arguments:

    DeviceObject - a pointer to the device object being queried

    QueryIrp - a pointer to the irp for the query

Return Value:

    STATUS_SUCCESS if the query was successful

    other error values as applicable

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(QueryIrp);
    PSTORAGE_PROPERTY_QUERY query = QueryIrp->AssociatedIrp.SystemBuffer;
    STORAGE_DEVICE_DESCRIPTOR deviceDescriptor;
    STORAGE_ADAPTER_DESCRIPTOR adapterDescriptor;
    PSTORAGE_DEVICE_DESCRIPTOR storageDeviceDescriptor;
    ULONG outBufferSize;
    ULONG numBytesToCopy;
    PUCHAR outBuffer;
    PUCHAR outBufferBegin;
    CHAR vendorString[] = VENDORSTRING;
    CHAR productString[] = PRODUCTSTRING;
    CHAR revisionString[] = REVISIONSTRING;
    CHAR serialString[] = SERIALSTRING;
    NTSTATUS status;


    if(query->QueryType >= PropertyMaskQuery) {

        status = STATUS_NOT_IMPLEMENTED;
        QueryIrp->IoStatus.Status = status;
        QueryIrp->IoStatus.Information = 0;
        IoCompleteRequest(QueryIrp, IO_NO_INCREMENT);
        return status;
    }

    if(query->QueryType == PropertyExistsQuery) {

        status = STATUS_SUCCESS;
        QueryIrp->IoStatus.Status = status;
        IoCompleteRequest(QueryIrp, IO_DISK_INCREMENT);
        return status;
    }

    switch(query->PropertyId) {

        case StorageDeviceProperty: {

            outBufferSize = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
            RtlZeroMemory (&deviceDescriptor, sizeof(STORAGE_DEVICE_DESCRIPTOR));

            //
            // The buffer needs to be large enough to hold the base
            // structure and  all  the  strings [ null terminated ]
            //
            deviceDescriptor.Version = sizeof(STORAGE_DEVICE_DESCRIPTOR);
            deviceDescriptor.Size    = sizeof(STORAGE_DEVICE_DESCRIPTOR) + 1 + VENDORSTRINGSIZE + 1 + PRODUCTSTRINGSIZE + 1 + REVISIONSTRINGSIZE + 1 + SERIALSTRINGSIZE + 1;

            deviceDescriptor.DeviceType = deviceExtension->ScsiDeviceType;

            if (deviceExtension->removableMedia)
            {
                deviceDescriptor.RemovableMedia = TRUE;
            }

            deviceDescriptor.BusType = BusTypeAta;

            if (outBufferSize >= deviceDescriptor.Size)
            {
                numBytesToCopy = deviceDescriptor.Size;
            }
            else
            {
                numBytesToCopy = outBufferSize;
            }

            QueryIrp->IoStatus.Information = numBytesToCopy;
            outBuffer = QueryIrp->AssociatedIrp.SystemBuffer;
            outBufferBegin = outBuffer;
            status = STATUS_SUCCESS;

            storageDeviceDescriptor = (PSTORAGE_DEVICE_DESCRIPTOR) QueryIrp->AssociatedIrp.SystemBuffer;

            if (numBytesToCopy > sizeof(STORAGE_DEVICE_DESCRIPTOR))
            {
                RtlCopyMemory (outBuffer, &deviceDescriptor, sizeof(STORAGE_DEVICE_D