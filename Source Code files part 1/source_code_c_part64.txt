acros
////////////////////////////////////////////////////////////////////////////////////

extern __WrapperPtr<CPerformanceEventLog>	pEventLog;
extern __WrapperPtr<WmiSecurityAttributes>	pSA;

#ifdef	_DEBUG
#define	_EVENT_MSG
#endif	_DEBUG

extern	LPCWSTR	g_szRefreshMutexLib;

////////////////////////////////////////////////////////////////////////////////////
// construction
////////////////////////////////////////////////////////////////////////////////////

WmiAdapterWrapper::WmiAdapterWrapper ( ):
m_lUseCount ( 0 ),

m_pData ( NULL ),
m_dwData ( 0 ),
m_dwDataOffsetCounter ( 0 ),
m_dwDataOffsetValidity ( 0 ),

m_dwPseudoCounter ( 0 ),
m_dwPseudoHelp ( 0 ),

m_bRefresh ( FALSE )

{
	::InitializeCriticalSection ( &m_pCS );

	////////////////////////////////////////////////////////////////////////////
	// connection to service manager
	////////////////////////////////////////////////////////////////////////////
	if ( ( hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS) ) == NULL )
	{
		if ( ::GetLastError () != ERROR_ACCESS_DENIED )
		{
			ReportEvent ( EVENTLOG_ERROR_TYPE, WMI_ADAPTER_OPEN_SCM_FAIL );
		}
	}

	m_hRefresh= ::CreateMutex	(
									pSA->GetSecurityAttributtes(),
									FALSE,
									g_szRefreshMutexLib
								);
}

////////////////////////////////////////////////////////////////////////////////////
// destruction
////////////////////////////////////////////////////////////////////////////////////

WmiAdapterWrapper::~WmiAdapterWrapper ( )
{
	::DeleteCriticalSection ( &m_pCS );
}

////////////////////////////////////////////////////////////////////////////////////
// exported functions
////////////////////////////////////////////////////////////////////////////////////

// open ( synchronized by perf app )
DWORD	WmiAdapterWrapper::Open	( LPWSTR )
{
	// returned error
	DWORD			dwResult = ERROR_ACCESS_DENIED;
	__SmartHANDLE	hInitEvent;

	if (! m_lUseCount)
	{
		try
		{
			////////////////////////////////////////////////////////////////////////////
			// connection to worker service
			////////////////////////////////////////////////////////////////////////////
			if ( hSCM.GetHANDLE() != NULL )
			{
				__SmartServiceHANDLE hService;
				if ( ( hService = ::OpenServiceW ( hSCM.GetHANDLE(), L"WMIApSrv", SERVICE_QUERY_STATUS | SERVICE_START ) ) != NULL)
				{
					SERVICE_STATUS s;
					if ( ::QueryServiceStatus ( hService, &s ) )
					{
						if ( s.dwCurrentState == SERVICE_STOPPED ||
							 s.dwCurrentState == SERVICE_PAUSED )
						{
							// start service
							if ( ! ::StartService ( hService, NULL, NULL ) )
							{
								// unable to open service
								DWORD dwError = ERROR_SUCCESS;
								dwError = ::GetLastError();

								if ( ERROR_SERVICE_ALREADY_RUNNING != dwError )
								{
									if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
									{
										if ( dwError != ERROR_ACCESS_DENIED )
										{
											ReportEvent ( EVENTLOG_ERROR_TYPE, WMI_ADAPTER_OPEN_SC_FAIL );
										}

										dwResult = dwError;
									}
									else
									{
										dwResult = static_cast < DWORD > ( E_FAIL );
									}
								}
								else
								{
									dwResult = ERROR_SUCCESS;
								}
							}
							else
							{
								dwResult = ERROR_SUCCESS;
							}
						}
						else
						{
							dwResult = ERROR_SUCCESS;
						}
					}
					else
					{
						// unable to open service
						DWORD dwError = ERROR_SUCCESS;
						dwError = ::GetLastError();

						if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
						{
							if ( dwError != ERROR_ACCESS_DENIED )
							{
								ReportEvent ( EVENTLOG_ERROR_TYPE, WMI_ADAPTER_OPEN_SC_FAIL );
							}

							dwResult = dwError;
						}
						else
						{
							dwResult = static_cast < DWORD > ( E_FAIL );
						}
					}
				}
				else
				{
					// unable to open service
					DWORD dwError = ERROR_SUCCESS;
					dwError = ::GetLastError();

					if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
					{
						if ( dwError != ERROR_ACCESS_DENIED )
						{
							ReportEvent ( EVENTLOG_ERROR_TYPE, WMI_ADAPTER_OPEN_SC_FAIL );
						}

						dwResult = dwError;
					}
					else
					{
						dwResult = static_cast < DWORD > ( E_FAIL );
					}
				}
			}
			else
			{
				// unable to operate with service
				dwResult =  static_cast < DWORD > ( ERROR_NOT_READY );
			}

			if SUCCEEDED ( HRESULT_FROM_WIN32 ( dwResult ) )
			{
				if ( ( hInitEvent = ::CreateSemaphore	(	pSA->GetSecurityAttributtes(),
															0L,
															100L, 
															L"Global\\WmiAdapterInit"
														)
					 ) != NULL
				   )
				{
					if ( hInitEvent.GetHANDLE() != INVALID_HANDLE_VALUE )
					{
						if ( ! ::ReleaseSemaphore( hInitEvent, 1, NULL ) )
						{
							DWORD dwError = ERROR_SUCCESS;
							dwError = ::GetLastError ();

							if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
							{
								dwResult = dwError;
							}
							else
							{
								dwResult = static_cast < DWORD > ( E_FAIL );
							}
						}
					}
				}
				else
				{
					DWORD dwError = ERROR_SUCCESS;
					dwError = ::GetLastError ();

					if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
					{
						dwResult = dwError;
					}
					else
					{
						dwResult = static_cast < DWORD > ( E_FAIL );
					}
				}

				if SUCCEEDED ( HRESULT_FROM_WIN32 ( dwResult ) )
				{
					DWORD dwStart	= 0;
					DWORD dwEnd		= 0;

					DWORD	dwWait	= 0L;
					DWORD	dwTime	= 0L;

					SYSTEMTIME st;
					::GetSystemTime ( &st );

					dwStart	= ( DWORD ) st.wMilliseconds;

					////////////////////////////////////////////////////////////////////////
					// connect to shared memory
					////////////////////////////////////////////////////////////////////////
					m_pMem.MemCreate	(
											L"Global\\WmiReverseAdapterMemory",
											pSA->GetSecurityAttributtes()
										);

					if ( m_pMem.MemCreate ( 4096 ), ( m_pMem.IsValid () ) )
					{
						ATLTRACE (	L"*************************************************************\n"
									L"PERFLIB connected to shared memory\n"
									L"*************************************************************\n" );

						// get count of all memories
						DWORD cbCount		= 0L;
						cbCount = MemoryCountGet ();
						MemoryCountSet ( 1 + cbCount );

						DWORD	dwCount = 0L;
						dwCount = GetCount	(
												g_szKey,
												g_szKeyValue
											);

						::GetSystemTime ( &st );

						dwEnd	= ( DWORD ) st.wMilliseconds;
						dwTime	= ( dwEnd - dwStart ) + 5;

						dwWait = 150 *  ( ( dwCount ) ? dwCount : 1 );

						#ifdef	__SUPPORT_WAIT
						// wait if we are ready now
						if ( ( m_hReady = ::CreateEvent	(	pSA->GetSecurityAttributtes(),
															TRUE,
															FALSE, 
															L"Global\\WmiAdapterDataReady"
														)
							 ) != NULL
						   )
						{
							if ( !cbCount && ( dwTime < dwWait ) )
							{
								::WaitForSingleObject (
														m_hReady,
														( ( dwWait < 5000 ) ? dwWait : 5000 ) - dwTime
													  );
							}
						}
						else
						{
						#endif	__SUPPORT_WAIT
						if ( !cbCount && ( dwTime < dwWait ) )
						{
							::Sleep ( ( ( dwWait < 5000 ) ? dwWait : 5000 ) - dwTime );
						}
						#ifdef	__SUPPORT_WAIT
						}
						#endif	__SUPPORT_WAIT

						////////////////////////////////////////////////////////////////////
						// create pseudo counter memory
						////////////////////////////////////////////////////////////////////
						PseudoCreate();

						////////////////////////////////////////////////////////////////////
						// SUCCESS
						////////////////////////////////////////////////////////////////////
						#ifdef	_EVENT_MSG
						ReportEvent	( EVENTLOG_INFORMATION_TYPE, WMI_PERFLIB_OPEN_SUCCESS );
						#endif	_EVENT_MSG

						InterlockedIncrement(&m_lUseCount);
					}
					else
					{
						DWORD dwError = ERROR_SUCCESS;
						dwError = ::GetLastError();

						if ( dwError != ERROR_ACCESS_DENIED )
						{
							////////////////////////////////////////////////////////////////
							// unable to connect into shared meory
							////////////////////////////////////////////////////////////////

							ReportEvent (
											EVENTLOG_ERROR_TYPE,
											WMI_ADAPTER_SHARED_FAIL
										) ;
							ReportEvent (
											(DWORD)E_OUTOFMEMORY,
											EVENTLOG_ERROR_TYPE,
											WMI_ADAPTER_SHARED_FAIL_STRING
										) ;
						}

						if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
						{
							dwResult = dwError;
						}
						else
						{
							dwResult = static_cast < DWORD > ( HRESULT_TO_WIN32 ( E_OUTOFMEMORY ) ) ;
						}
					}
				}
			}
		}
		catch ( ... )
		{
			////////////////////////////////////////////////////////////////////////
			// FAILURE
			////////////////////////////////////////////////////////////////////////
			dwResult =  static_cast < DWORD > ( ERROR_NOT_READY );
		}

		if FAILED ( HRESULT_FROM_WIN32 ( dwResult ) )
		{
			CloseLib ( ( hInitEvent.GetHANDLE() != NULL ) );
		}
	}

	return dwResult;
}

// close ( synchronized by perf app )
DWORD	WmiAdapterWrapper::Close ( void )
{
	if (m_lUseCount && ! (InterlockedDecrement (&m_lUseCount)))
	{
		CloseLib ();

		////////////////////////////////////////////////////////////////////////////
		// SUCCESS
		////////////////////////////////////////////////////////////////////////////
		#ifdef	_EVENT_MSG
		ReportEvent	( EVENTLOG_INFORMATION_TYPE, WMI_PERFLIB_CLOSE_SUCCESS );
		#endif	_EVENT_MSG
	}

	return static_cast < DWORD > ( ERROR_SUCCESS );
}

void	WmiAdapterWrapper::CloseLib ( BOOL bInit )
{
	if ( hSCM.GetHANDLE() != NULL )
	{
		////////////////////////////////////////////////////////////////////////
		// pseudo counter
		////////////////////////////////////////////////////////////////////////
		PseudoDelete ();

		////////////////////////////////////////////////////////////////////////////
		// destroy shared memory
		////////////////////////////////////////////////////////////////////////////
		try
		{
			if ( m_pMem.IsValid() )
			{
				// get count of all memories
				DWORD cbCount  = 0L;
				if ( ( cbCount = MemoryCountGet () ) != 0 )
				{
					MemoryCountSet ( cbCount - 1 );
				}
			}
		}
		catch ( ... )
		{
		}

		if ( m_pMem.IsValid() )
		{
			m_pMem.MemDelete();
		}

		if ( bInit )
		{
			// server stop of refreshing
			__SmartHANDLE hUninitEvent;
			if ( ( hUninitEvent = ::CreateSemaphore	(	pSA->GetSecurityAttributtes(),
														0L,
														100L, 
														L"Global\\WmiAdapterUninit"
													)
				 ) != NULL
			   )
			{
				if ( hUninitEvent.GetHANDLE() != INVALID_HANDLE_VALUE )
				{
					::ReleaseSemaphore( hUninitEvent, 1, NULL );
				}
			}
		}
	}

	return;
}

// collect ( synchronized )
DWORD	WmiAdapterWrapper::Collect	(	LPWSTR lpwszValues,
										LPVOID*	lppData,
										LPDWORD	lpcbBytes,
										LPDWORD	lpcbObjectTypes
									)
{
	DWORD dwResult = ERROR_SUCCESS;

	if ( ::TryEnterCriticalSection ( &m_pCS ) )
	{
		if ( lpwszValues && m_pMem.IsValid () )
		{
			LPVOID pStart = *lppData;

			try
			{
				DWORD dwWaitResult = 0L;
				dwWaitResult = ::WaitForSingleObject ( m_hRefresh, 0 );

				BOOL	bOwnMutex	= FALSE;
				BOOL	bRefresh	= FALSE;
				BOOL	bCollect	= FALSE;

				switch ( dwWaitResult )
				{
					case WAIT_OBJECT_0:
					{
						bOwnMutex	= TRUE;
						bCollect	= TRUE;
						break;
					}

					case WAIT_TIMEOUT:
					{
						// we are refreshing
						m_bRefresh	= TRUE;

						bRefresh	= TRUE;
						bCollect	= TRUE;
						break;
					}
					default:
					{
						(*lpcbBytes)		= 0;
						(*lpcbObjectTypes)	= 0;
						break;
					}
				}

				if ( bCollect )
				{
					#ifdef	__SUPPORT_WAIT
					if ( !m_bRefresh )
					{
						dwWaitResult = ::WaitForSingleObject ( m_hReady, 0 );
						if ( dwWaitResult == WAIT_TIMEOUT )
						{
							m_bRefresh = TRUE;
						}
					}
					#endif	__SUPPORT_WAIT

					////////////////////////////////////////////////////////////////////
					// main collect
					////////////////////////////////////////////////////////////////////
					dwResult = CollectObjects	(
												lpwszValues,
												lppData,
												lpcbBytes,
												lpcbObjectTypes
												);

					if ( bOwnMutex )
					{
						::ReleaseMutex ( m_hRefresh );
					}

					if ( bRefresh && dwResult == ERROR_SUCCESS )
					{
						m_bRefresh = bRefresh;
					}
				}
			}
			catch ( ... )
			{
				(*lppData)			= pStart;
				(*lpcbBytes)		= 0;
				(*lpcbObjectTypes)	= 0;
			}
		}
		else
		{
			(*lpcbBytes)		= 0;
			(*lpcbObjectTypes)	= 0;
		}

		::LeaveCriticalSection ( &m_pCS );
	}
	else
	{
		(*lpcbBytes)		= 0;
		(*lpcbObjectTypes)	= 0;
	}

	return dwResult;
}

DWORD	WmiAdapterWrapper::CollectObjects	(	LPWSTR lpwszValues,
												LPVOID*	lppData,
												LPDWORD	lpcbBytes,
												LPDWORD	lpcbObjectTypes
											)
{ 
	if ( m_bRefresh )
	{
		////////////////////////////////////////////////////////////////////////////////
		// is it big enough
		////////////////////////////////////////////////////////////////////////////////
		if ( ( *lpcbBytes ) < m_dwData )
		{
			// too small
			( * lpcbBytes )			= 0;
			( * lpcbObjectTypes )	= 0;

			return static_cast < DWORD > ( ERROR_MORE_DATA );
		}

		( * lpcbBytes )			= 0;
		( * lpcbObjectTypes )	= 0;

		// fill pseudo counter with valid data if exists
		if ( m_pData )
		{
			// recreate pseudo buffer
			if ( ( PseudoCreateRefresh () ) == S_OK )
			{
				memcpy ( ( * lppData ), m_pData, m_dwData );

				( * lpcbBytes )			= m_dwData;
				( * lpcbObjectTypes )	= 1;

				( * lppData )	= reinterpret_cast<PBYTE>
								( reinterpret_cast<PBYTE> ( * lppData ) + m_dwData );
			}
		}

		m_bRefresh = FALSE;
	}
	else
	{
		// get size of table
		DWORD dwOffsetBegin	= TableOffsetGet();
		// get size of all memory
		DWORD cbBytes		= RealSizeGet();

		////////////////////////////////////////////////////////////////////////////////
		// is it big enough
		////////////////////////////////////////////////////////////////////////////////
		if ( ( *lpcbBytes ) < cbBytes + m_dwData )
		{
			// too small
			( * lpcbBytes )			= 0;
			( * lpcbObjectTypes )	= 0;

			return static_cast < DWORD > ( ERROR_MORE_DATA );
		}

		////////////////////////////////////////////////////////////////////////////////
		// are data ready
		////////////////////////////////////////////////////////////////////////////////
		if ( ( dwOffsetBegin == (DWORD) -1 ) || ! cbBytes )
		{
			// fill pseudo counter with valid data if exists
			if ( m_pData )
			{
				PseudoRefresh ( 0 );
				PseudoRefresh ( FALSE );

				memcpy ( ( * lppData ), m_pData, m_dwData );

				( * lpcbBytes )			= m_dwData;
				( * lpcbObjectTypes )	= 1;

				( * lppData )	= reinterpret_cast<PBYTE>
								( reinterpret_cast<PBYTE> ( * lppData ) + m_dwData );
			}
			else
			{
				( * lpcbBytes )			= 0;
				( * lpcbObjectTypes )	= 0;
			}

			return static_cast < DWORD > ( ERROR_SUCCESS );
		}

		////////////////////////////////////////////////////////////////////////////////
		// do they want all countres
		////////////////////////////////////////////////////////////////////////////////
		if ( lstrcmpiW ( L"GLOBAL", lpwszValues ) == 0 )
		{
			//first and default values
			( * lpcbBytes )			= 0;
			( * lpcbObjectTypes )	= 0;

			BYTE* pData = NULL;
			pData = reinterpret_cast < PBYTE > ( * lppData );

			DWORD	dwCount		= 0L;
			dwCount = CountGet();

			// fill pseudo counter with valid data if exists
			if ( m_pData )
			{
				PseudoRefresh ( dwCount );
				PseudoRefresh ( );

				memcpy ( ( * lppData ), m_pData, m_dwData );

				( * lpcbBytes )			= m_dwData;
				( * lpcbObjectTypes )	= 1;

				( * lppData )	= reinterpret_cast<PBYTE>
								( reinterpret_cast<PBYTE> ( * lppData ) + m_dwData );
			}

			// fill rest of counters if possible
			if ( ! m_pMem.Read( (BYTE*) ( *lppData ),	// buffer
								cbBytes,				// size I want to read
								dwOffsetBegin			// offset from to read
							  )
			   )
			{
				HRESULT hrTemp = E_FAIL;
				hrTemp = MemoryGetLastError( dwOffsetBegin );

				if FAILED ( hrTemp ) 
				{
					ReportEvent (	( DWORD ) hrTemp,
									EVENTLOG_ERROR_TYPE,
									WMI_ADAPTER_SHARED_FAIL_READ_SZ ) ;
				}
				else
				{
					ReportEvent (	( DWORD ) E_FAIL,
									EVENTLOG_ERROR_TYPE,
									WMI_ADAPTER_SHARED_FAIL_READ_SZ ) ;
				}

				if ( m_pData )
				{
					PseudoRefresh ( FALSE );
					memcpy ( pData, m_pData, m_dwData );
				}
			}
			else
			{
				( * lpcbBytes )			= ( * lpcbBytes ) + cbBytes;
				( * lpcbObjectTypes )	= ( * lpcbObjectTypes ) + dwCount;

				( * lppData )	= reinterpret_cast<PBYTE>
								( reinterpret_cast<PBYTE> ( * lppData ) + cbBytes );
			}
		}

		////////////////////////////////////////////////////////////////////////////////
		// do they want just some of them
		////////////////////////////////////////////////////////////////////////////////
		else
		{
			//first and default values
			( * lpcbBytes )			= 0;
			( * lpcbObjectTypes )	= 0;

			// they are asking for objects :))
			WmiAdapterObjectList list ( lpwszValues );

			BYTE* pData = NULL;
			pData = reinterpret_cast < PBYTE > ( * lppData );

			BOOL bFailure = FALSE;

			DWORD	dwCount		= 0L;
			dwCount = CountGet();

			if ( list.IsInList ( m_dwPseudoCounter ) )
			{
				if ( m_pData )
				{
					PseudoRefresh ( dwCount );
					PseudoRefresh ( );

					memcpy ( ( * lppData ), m_pData, m_dwData );

					( * lpcbBytes )			= m_dwData;
					( * lpcbObjectTypes )	= 1;

					( * lppData )	= reinterpret_cast<PBYTE>
									( reinterpret_cast<PBYTE> ( * lppData ) + m_dwData );
				}
			}

			for ( DWORD dw = 0; dw < dwCount; dw++ )
			{
				if ( list.IsInList ( GetCounter ( dw ) ) )
				{
					if ( GetValidity ( dw ) != (DWORD) -1 )
					{
						DWORD dwSize	= 0;
						DWORD dwOffset	= 0;

						dwOffset = GetOffset ( dw );

						// don't forget we have a table :))
						dwOffset += dwOffsetBegin;

						// get size we want
						if ( m_pMem.Read ( ( BYTE* ) &dwSize, sizeof ( DWORD ), dwOffset ) )
						{
							// set memory
							if ( m_pMem.Read ( ( BYTE* ) ( *lppData ), dwSize, dwOffset ) )

							{
								( *lpcbBytes ) += dwSize;
								( *lpcbObjectTypes ) ++;

								( * lppData )	= reinterpret_cast<PBYTE>
												( reinterpret_cast<PBYTE> ( * lppData ) + dwSize );
							}
							else
							{
								bFailure = TRUE;
							}
						}
						else
						{
							bFailure = TRUE;
						}

						if ( bFailure )
						{
							ReportEvent (	( DWORD ) E_FAIL,
											EVENTLOG_ERROR_TYPE,
											WMI_ADAPTER_SHARED_FAIL_READ_SZ ) ;

							if ( m_pData )
							{
								PseudoRefresh ( FALSE );
								memcpy ( pData, m_pData, m_dwData );

								( * lppData )	= reinterpret_cast<PBYTE>
												( pData + m_dwData );
							}
							else
							{
								( * lpcbBytes )			= 0;
								( * lpcbObjectTypes )	= 0;

								( * lppData )			= pData;
							}

							break;
						}
					}
				}
			}
		}
	}

	return static_cast < DWORD > ( ERROR_SUCCESS );
}

////////////////////////////////////////////////////////////////////////////////////
// helper functions
////////////////////////////////////////////////////////////////////////////////////

// report event
BOOL WmiAdapterWrapper::ReportEvent (	WORD	wType,
										DWORD	dwEventID,
										WORD	wStrings,
										LPWSTR*	lpStrings
									)
{
	BOOL bResult = FALSE;

	try
	{
		if ( pEventLog )
		{
			bResult = pEventLog->ReportEvent ( wType, 0, dwEventID, wStrings, 0, (LPCWSTR*) lpStrings, 0 );
		}
	}
	catch ( ... )
	{
		bResult = FALSE;
	}

	return bResult;
}

// report event
BOOL WmiAdapterWrapper::ReportEvent ( DWORD dwError, WORD wType, DWORD dwEventSZ )
{
	LPWSTR wszError = NULL ;
	wszError = GetErrorMessageSystem ( dwError ) ;

	WCHAR wsz[_MAX_PATH]  = { L'\0' };
	LPWSTR ppwsz[1] = { NULL };

	if ( wszError && ( lstrlenW ( wszError ) + 1 ) < _MAX_PATH - 50 )
	{
		try
		{
			StringCchPrintfW	( wsz,	_MAX_PATH,	L"\n Error code :\t0x%x"
													L"\n Error description :\t%s\n", dwError, wszError
						) ;

			delete ( wszError );
		}
		catch ( ... )
		{
			delete ( wszError );
			return FALSE;
		}
	}
	else
	{
		try
		{
			StringCchPrintfW	( wsz,	_MAX_PATH,	L"\n Error code :\t0x%x"
													L"\n Error description :\t unspecified error \n", dwError
						) ;
		} 
		catch ( ... )
		{
			return FALSE;
		}
	}

	ppwsz[0] = wsz;
	return ReportEvent ( wType, dwEventSZ, 1, ppwsz ) ;
}

///////////////////////////////////////////////////////////////////////////
// get object properties from ord
///////////////////////////////////////////////////////////////////////////

DWORD	WmiAdapterWrapper::GetCounter ( DWORD dwOrd )
{
	DWORD dwResult = 0L;
	dwResult = static_cast < DWORD > ( -1 );

	if ( IsValidOrd ( dwOrd ) )
	{
		DWORD dwOffset	= 0L;
		DWORD dwIndex	= 0L;

		dwOffset = offsetObject1 + ( dwOrd * ( ObjectSize1 ) + offCounter1 );

		m_pMem.Read ( &dwResult, sizeof ( DWORD ), dwOffset );
	}

	return dwResult;
}

DWORD	WmiAdapterWrapper::GetOffset ( DWORD dwOrd )
{
	DWORD dwResult = 0L;
	dwResult = static_cast < DWORD > ( -1 );

	if ( IsValidOrd ( dwOrd ) )
	{
		DWORD dwOffset	= 0L;
		DWORD dwIndex	= 0L;

		dwOffset = offsetObject1 + ( dwOrd * ( ObjectSize1 ) + offOffset1 );

		m_pMem.Read ( &dwResult, sizeof ( DWORD ), dwOffset );
	}

	return dwResult;
}

DWORD	WmiAdapterWrapper::GetValidity ( DWORD dwOrd )
{
	DWORD dwResult = 0L;
	dwResult = static_cast < DWORD > ( -1 );

	if ( IsValidOrd ( dwOrd ) )
	{
		DWORD dwOffset	= 0L;
		DWORD dwIndex	= 0L;

		dwOffset = offsetObject1 + ( dwOrd * ( ObjectSize1 ) + offValidity1 );

		m_pMem.Read ( &dwResult, sizeof ( DWORD ), dwOffset );
	}

	return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_eventlog_base.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_eventlog_base.cpp
//
//	Abstract:
//
//					defines behaviour of evet logging
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// definitions
#include "wmi_EventLog_base.h"
#include <lmcons.h>

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// behaviour
#define	__AUTOMATIC_REFCOUNT__
#define	__AUTOMATIC_SID__

/////////////////////////////////////////////////////////////////////////////////////////
// construction & destruction
/////////////////////////////////////////////////////////////////////////////////////////

CPerformanceEventLogBase::CPerformanceEventLogBase( LPTSTR szApp ) :
m_lLogCount(0),
m_hEventLog(0),
m_pSid(0)
{
	#ifdef	__AUTOMATIC_SID__
	InitializeFromToken();
	#endif	__AUTOMATIC_SID__

	#ifdef	__AUTOMATIC_REFCOUNT__
	Open ( szApp );
	#endif	__AUTOMATIC_REFCOUNT__
}

CPerformanceEventLogBase::~CPerformanceEventLogBase()
{
	#ifdef	__AUTOMATIC_REFCOUNT__
	Close ();
	#endif	__AUTOMATIC_REFCOUNT__

	// rescue me :))
	while ( m_lLogCount > 0 )
	{
		Close ();
	}

	m_lLogCount	= 0;
	m_hEventLog		= NULL;

	delete[] m_pSid;
	m_pSid	= NULL;
}

void CPerformanceEventLogBase::Initialize ( LPTSTR szAppName, LPTSTR szResourceName )
{
	HKEY	hKey		= NULL;

	if ( szAppName )
	{
		LPTSTR	szKey		= _T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\");
		LPTSTR	szKeyFile	= _T("EventMessageFile");
		LPTSTR	szKeyType	= _T("TypesSupported");

		DWORD	dwData =	EVENTLOG_ERROR_TYPE |
							EVENTLOG_WARNING_TYPE | 
							EVENTLOG_INFORMATION_TYPE;

		LPTSTR szBuf = NULL;

		DWORD cchSize = 1 + lstrlen ( szKey ) + lstrlen ( szAppName );
		if ( ( szBuf = reinterpret_cast<LPTSTR>(new TCHAR [ cchSize ] ) ) != NULL )
		{
			if ( SUCCEEDED ( StringCchCopyW ( szBuf, cchSize, szKey ) ) )
			{
				if ( SUCCEEDED ( StringCchCatW ( szBuf, cchSize, szAppName ) ) )
				{
					if ( ! ::RegCreateKey (	HKEY_LOCAL_MACHINE, szBuf, &hKey ) )
					{
						if ( szResourceName )
						{
							// Add the name to the EventMessageFile subkey.
							::RegSetValueEx(hKey, szKeyFile, 0, REG_EXPAND_SZ, (LPBYTE) szResourceName, sizeof ( TCHAR ) * ( lstrlen( szResourceName ) + 1 ) );
						}

						// Set the supported event types in the TypesSupported subkey.
						::RegSetValueEx(hKey, szKeyType, 0, REG_DWORD, (LPBYTE) &dwData, sizeof( DWORD ) );

						::RegCloseKey(hKey);
					}
				}
			}

			delete [] ( szBuf );
			return;
		}
	}

	___ASSERT(L"Unable to initialize event logging !");
	return;
}

void CPerformanceEventLogBase::UnInitialize ( LPTSTR szAppName )
{
	if ( szAppName )
	{
		LPTSTR	szKey		= _T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\");

		LPTSTR szBuf = NULL;

		DWORD cchSize = 1 + lstrlen ( szKey ) + lstrlen ( szAppName );
		if ( ( szBuf = reinterpret_cast<LPTSTR>(new TCHAR [ cchSize ] ) ) != NULL )
		{
			if ( SUCCEEDED ( StringCchCopyW ( szBuf, cchSize, szKey ) ) )
			{
				if ( SUCCEEDED ( StringCchCatW ( szBuf, cchSize, szAppName ) ) )
				{
					::RegDeleteKey ( HKEY_LOCAL_MACHINE, szBuf );
				}
			}

			return;
		}
	}

	___ASSERT(L"Unable to uninitialize event logging !");
	return;
}

/////////////////////////////////////////////////////////////////////////////////////////
// methods
/////////////////////////////////////////////////////////////////////////////////////////

void CPerformanceEventLogBase::InitializeFromToken ( void )
{
	if ( ! m_pSid )
	{
		HANDLE	hAccessToken= NULL;

		PTOKEN_OWNER	ptOwner		= NULL;
		DWORD			dwOwnerSize	= 0;

		if ( ::OpenProcessToken ( ::GetCurrentProcess (), TOKEN_READ, &hAccessToken ) )
		{
			::GetTokenInformation( hAccessToken, TokenOwner, reinterpret_cast<LPVOID>( ptOwner ), dwOwnerSize, &dwOwnerSize );

			if ( ERROR_INSUFFICIENT_BUFFER == ::GetLastError () )
			{
				if ( ( ptOwner = reinterpret_cast<PTOKEN_OWNER>( new BYTE[ dwOwnerSize ] ) ) != NULL )
				{
					if ( ::GetTokenInformation( hAccessToken, TokenOwner, reinterpret_cast<LPVOID>( ptOwner ), dwOwnerSize, &dwOwnerSize ) )
					{
						if ( ::IsValidSid ( ptOwner -> Owner ) )
						{
							DWORD	dwSid	= ::GetLengthSid ( ptOwner -> Owner );

							if ( ( m_pSid = reinterpret_cast<PSID>( new BYTE[dwSid] ) ) != NULL )
							{
								::CopySid ( dwSid, m_pSid, ptOwner -> Owner );
							}
						}
					}

					delete [] ( ptOwner );
					ptOwner = NULL;
				}
			}

			if ( hAccessToken )
			{
				::CloseHandle ( hAccessToken );
			}

			return;
		}
	}

	___ASSERT(L"Unable to set SID of user !");
	return;
}

HRESULT	CPerformanceEventLogBase::Open ( LPTSTR szName )
{
	if ( ! m_lLogCount && szName )
	{
		if ( ( m_hEventLog = ::RegisterEventSource ( NULL, szName ) ) == NULL )
		{
			return HRESULT_FROM_WIN32( ::GetLastError () );
		}
	}

	if ( m_hEventLog )
	{
		InterlockedIncrement( &m_lLogCount );
		return S_OK;
	}

	return S_FALSE;
}

void	CPerformanceEventLogBase::Close ( void )
{
	if (! ( InterlockedDecrement ( &m_lLogCount ) ) && m_hEventLog )
	{
		::DeregisterEventSource ( m_hEventLog );
	}

	return;
}

BOOL	CPerformanceEventLogBase::ReportEvent (	WORD		wType,
											WORD		wCategory,
											DWORD		dwEventID,
											WORD		wStrings,
											DWORD		dwData,
											LPCWSTR*	lpStrings,
											LPVOID		lpData
										  )
{
	if ( m_hEventLog )
	{
		if ( !::ReportEventW ( m_hEventLog, wType, wCategory, dwEventID, m_pSid, wStrings, dwData, (LPCWSTR*) lpStrings, lpData ) )
		{
			ERRORMESSAGE_DEFINITION;
			ERRORMESSAGE ( HRESULT_FROM_WIN32 ( ::GetLastError() ) ) ;

			return FALSE;
		}

		return TRUE;
	}

	___ASSERT(L"Unable to report event !");
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_eventlog.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_EventLog.cpp
//
//	Abstract:
//
//					defines event log specific ( see wmi_eventlog_base )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////


#include "PreComp.h"

// definitions
#include "wmi_EventLog.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// need macros
#ifndef	__ASSERT_VERIFY__
#include "__macro_assert.h"
#endif	__ASSERT_VERIFY__

/////////////////////////////////////////////////////////////////////////////////////////
// construction & destruction
/////////////////////////////////////////////////////////////////////////////////////////

CPerformanceEventLog::CPerformanceEventLog( LPTSTR szApp ) :
CPerformanceEventLogBase ( szApp ),
m_dwMessageLevel(0)
{
	if ( ! m_dwMessageLevel )
	{
		InitializeMessageLevel();
	}
}

CPerformanceEventLog::CPerformanceEventLog(DWORD dwMessageLevel, LPTSTR szApp ) :
CPerformanceEventLogBase ( szApp ),
m_dwMessageLevel(dwMessageLevel)
{
	if ( ! m_dwMessageLevel )
	{
		InitializeMessageLevel();
	}
}

CPerformanceEventLog::~CPerformanceEventLog()
{
	m_dwMessageLevel= 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
// helpers
/////////////////////////////////////////////////////////////////////////////////////////

void CPerformanceEventLog::InitializeMessageLevel ( void )
{
	DWORD	dwResult	= 0;
	DWORD	dwLogLevel	= 0;

	HKEY	hKey		= NULL;

	dwResult = ::RegOpenKeyEx (	HKEY_LOCAL_MACHINE,
								_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\PerfLib"),
								NULL,
								KEY_READ,
								&hKey );

	if ( ERROR_SUCCESS == dwResult )
	{
		DWORD dwLogLevelSize = sizeof ( DWORD );
		dwResult = ::RegQueryValueEx (	hKey,
										_T("EventLogLevel"),
										NULL,
										NULL,
										reinterpret_cast<LPBYTE>(&dwLogLevel),
										&dwLogLevelSize );

		if ( ERROR_SUCCESS == dwResult )
		{
			m_dwMessageLevel = dwLogLevel;
		}

		::RegCloseKey ( hKey );
	}

	___ASSERT(L"Unable to set message log level !");
	m_dwMessageLevel = 1;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_perf.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_perf.cpp
//
//	Abstract:
//
//					Defines common helpers for conversion
//					Works with table structure for objects ( init, refresh )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "WMI_perf_data.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "wmi_perf_struct.h"

#include <pshpack8.h>
#pragma pack ( push, 8 )

////////////////////////////////////////////////////////////////////////////////////
// Initialize WINDOWS PERFORMANCE table struct from internal structure
////////////////////////////////////////////////////////////////////////////////////

HRESULT	WmiPerformanceData::InitializeTable ( void )
{
	try
	{
		m_dwDataTable =	( m_dwCount * ObjectSize ) +
						SizeSize +
						CountSize +
						RealSize;

		if ( ( m_pDataTable = (BYTE*) malloc ( m_dwDataTable ) ) != NULL )
		{
			__SetValue ( m_pDataTable, m_dwDataTable, offsetSize );
			__SetValue ( m_pDataTable, m_dwCount, offsetCount );
			__SetValue ( m_pDataTable, 0, offsetRealSize );

			for ( DWORD dw = 0; dw < m_dwCount; dw++ )
			{
				__SetValue ( m_pDataTable, dw,				offsetObject + ( dw * ( ObjectSize ) + offIndex ) );
				__SetValue ( m_pDataTable, m_Ord2Ind[dw],	offsetObject + ( dw * ( ObjectSize ) + offCounter ) );
				__SetValue ( m_pDataTable, 0,				offsetObject + ( dw * ( ObjectSize ) + offOffset ) );
				__SetValue ( m_pDataTable, 0,				offsetObject + ( dw * ( ObjectSize ) + offValidity ) );
			}
		}
	}
	catch ( ... )
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}

HRESULT	WmiPerformanceData::RefreshTable ( void )
{
	DWORD offset	= 0;

	DWORD realsize	= 0;
	DWORD realcount	= 0;

	for ( DWORD dw = 0; dw < m_dwCount; dw++ )
	{
		if ( __GetValue (	m_pDataTable, 
							offsetObject + ( dw * ( ObjectSize ) + offValidity )
						)

						== ( DWORD ) -1 
		   )
		{
			__SetValue	(	m_pDataTable,
							( DWORD ) -1,
							offsetObject + ( dw * ( ObjectSize ) + offOffset )
						);
		}
		else
		{
			__SetValue	(	m_pDataTable,
							realsize,
							offsetObject + ( dw * ( ObjectSize ) + offOffset )
						);

			if ( data.Read ( &offset, sizeof ( DWORD ), NULL, realsize ) == TRUE )
			{
				realsize	+= offset;
				realcount++;
			}
		}
	}

	// set num of objects
	__SetValue	(	m_pDataTable,
					m_dwCount,
					offsetCount
				);

	// set real size
	__SetValue	(	m_pDataTable,
					realsize,
					offsetRealSize
				);

	return S_OK;
}

#pragma pack ( pop )
#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_helper_regtable.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					regtable.cpp
//
//	Abstract:
//
//					registry updater :-))
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////
//
//	This file contains the implementation of a routine that adds/removes
//	the table's registry entries and optionally registers a type library.
//
//	RegistryTableUpdateRegistry - adds/removes registry entries for table
//     
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// definitions & macros
#include "wmi_helper_regtable.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

LONG MyRegDeleteKey(HKEY hkeyRoot, const WCHAR *pszKeyName)
{
    LONG err = ERROR_BADKEY;
    if (pszKeyName && lstrlenW(pszKeyName))
    {
        HKEY    hkey;
        err = RegOpenKeyExW(hkeyRoot, pszKeyName, 0, 
                           KEY_ENUMERATE_SUB_KEYS | KEY_SET_VALUE | DELETE, &hkey );
        if(err == ERROR_SUCCESS)
        {
            while (err == ERROR_SUCCESS )
            {
                enum { MAX_KEY_LEN = 1024 };
                WCHAR szSubKey[MAX_KEY_LEN] = { L'\0' }; 
                DWORD   dwSubKeyLength = MAX_KEY_LEN;
                err = RegEnumKeyExW(hkey, 0, szSubKey,
                                    &dwSubKeyLength, 0, 0, 0, 0);
                
                if(err == ERROR_NO_MORE_ITEMS)
                {
                    err = RegDeleteKeyW(hkeyRoot, pszKeyName);
                    break;
                }
                else if (err == ERROR_SUCCESS)
                    err = MyRegDeleteKey(hkey, szSubKey);
            }
            RegCloseKey(hkey);
            // Do not save return code because error has already occurred
        }
    }
    return err;
}

LONG RegDeleteKeyValue(HKEY hkeyRoot, const WCHAR *pszKeyName, const WCHAR *pszValueName)
{
    LONG err = ERROR_BADKEY;
    if (pszKeyName && lstrlenW(pszKeyName))
    {
        HKEY    hkey = NULL;
        err = RegOpenKeyExW(hkeyRoot, pszKeyName, 0, KEY_SET_VALUE | DELETE, &hkey );
        if(err == ERROR_SUCCESS)
            err = RegDeleteValueW(hkey, pszValueName);

        RegCloseKey(hkey);
    }
    return err;
}

////////////////////////////////////////////////////////////////////////////////////
// the routine that inserts/deletes Registry keys based on the table
////////////////////////////////////////////////////////////////////////////////////

EXTERN_C HRESULT STDAPICALLTYPE 
RegistryTableUpdateRegistry(REGISTRY_ENTRY *pEntries, BOOL bInstalling)
{
    HRESULT hr = S_OK;
    if (bInstalling)
    {
        if (pEntries)
        {
            REGISTRY_ENTRY *pHead = pEntries;
            WCHAR szKey[4096] = { L'\0' };
            HKEY hkeyRoot = 0;
        
            while (pEntries->fFlags != -1)
            {
                WCHAR szFullKey[4096] = { L'\0' };
                DWORD dwValue = pEntries->dwValue;
                if (pEntries->hkeyRoot)
                {
                    hkeyRoot = pEntries->hkeyRoot;
                    if ( FAILED ( hr = StringCchCopyW(szKey, 4096, pEntries->pszKey) ) )
					{
						return hr;
					}

                    if ( FAILED ( hr = StringCchCopyW(szFullKey, 4096, pEntries->pszKey) ) )
					{
						return hr;
					}
                }
                else
                {
                    if ( FAILED ( hr = StringCchCopyW(szFullKey, 4096, szKey) ) )
					{
						return hr;
					}

                    if ( FAILED ( hr = StringCchCatW(szFullKey, 4096, L"\\") ) ) 
					{
						return hr;
					}

                    if ( FAILED ( hr = StringCchCatW(szFullKey, 4096, pEntries->pszKey) ) )
					{
						return hr;
					}
                }
                if (hkeyRoot == 0)
                {
                    RegistryTableUpdateRegistry(pHead, FALSE);
                    return SELFREG_E_CLASS;

                }
                HKEY hkey; DWORD dw;
                if (pEntries->fFlags & (REGFLAG_DELETE_BEFORE_REGISTERING|REGFLAG_DELETE_WHEN_REGISTERING))
                {
                    LONG err = MyRegDeleteKey(hkeyRoot, szFullKey);
                    if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND) 
                    {
                        RegistryTableUpdateRegistry(pHead, FALSE);
                        return SELFREG_E_CLASS;
                    }
                }
                if (pEntries->fFlags & (REGFLAG_DELETE_ONLY_VALUE))
                {
					LONG err = RegDeleteKeyValue(hkeyRoot, szFullKey, pEntries->pszValueName);
					if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND)
						hr = SELFREG_E_CLASS;
				}
				else
                {
                    LONG err = RegCreateKeyExW(hkeyRoot, szFullKey,
                                               0, 0, REG_OPTION_NON_VOLATILE,
                                               KEY_WRITE, pEntries->pSA, &hkey, &dw);
                    if (err == ERROR_SUCCESS)
                    {
                        err = RegSetValueExW(hkey, pEntries->pszValueName, 0, REG_DWORD, (const BYTE *)(&dwValue), sizeof(DWORD));
                        RegCloseKey(hkey);
                        if (hkeyRoot == 0)
                        {
                            RegistryTableUpdateRegistry(pHead, FALSE);
                            return SELFREG_E_CLASS;
                        }
                    }
                    else
                    {
                        RegistryTableUpdateRegistry(pHead, FALSE);
                        return SELFREG_E_CLASS;
                    }
                }
                pEntries++;
            }
        }
    }
    else
    {
        if (pEntries)
        {
            WCHAR szKey[4096] = { L'\0' };
            HKEY hkeyRoot = 0;
        
            while (pEntries->fFlags != -1)
            {
                WCHAR szFullKey[4096] = { L'\0' };
                if (pEntries->hkeyRoot)
                {
                    hkeyRoot = pEntries->hkeyRoot;
                    if ( FAILED ( hr = StringCchCopyW(szKey, 4096, pEntries->pszKey) ) )
					{
						return hr;
					}

                    if ( FAILED ( hr = StringCchCopyW(szFullKey, 4096, pEntries->pszKey) ) )
					{
						return hr;
					}
                }
                else
                {
                    if ( FAILED ( hr = StringCchCopyW(szFullKey, 4096, szKey) ) )
					{
						return hr;
					}

                    if ( FAILED ( hr = StringCchCatW(szFullKey, 4096, L"\\") ) ) 
					{
						return hr;
					}

                    if ( FAILED ( hr = StringCchCatW(szFullKey, 4096, pEntries->pszKey) ) )
					{
						return hr;
					}
                }
                if (hkeyRoot)
				{
					if (!(pEntries->fFlags & REGFLAG_NEVER_DELETE) && 
						!(pEntries->fFlags & REGFLAG_DELETE_WHEN_REGISTERING) &&
						!(pEntries->fFlags & REGFLAG_DELETE_ONLY_VALUE))
					{
						LONG err = MyRegDeleteKey(hkeyRoot, szFullKey);
						if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND)
							hr = SELFREG_E_CLASS;
					}
					else
					if(pEntries->fFlags & REGFLAG_DELETE_ONLY_VALUE)
					{
						LONG err = RegDeleteKeyValue(hkeyRoot, szFullKey, pEntries->pszValueName);
						if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND)
							hr = SELFREG_E_CLASS;
					}
				}

                pEntries++;
            }
        }
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////
// the routine that inserts/deletes Registry keys based on the table
////////////////////////////////////////////////////////////////////////////////////

EXTERN_C HRESULT STDAPICALLTYPE 
RegistryTableUpdateRegistrySZ(REGISTRY_ENTRY_SZ *pEntries, BOOL bInstalling)
{
    HRESULT hr = S_OK;
    if (bInstalling)
    {
        if (pEntries)
        {
            REGISTRY_ENTRY_SZ *pHead = pEntries;
            WCHAR szKey[4096] = { L'\0' };
            HKEY hkeyRoot = 0;
        
            while (pEntries->fFlags != -1)
            {
                WCHAR szFullKey[4096] = { L'\0' };
                if (pEntries->hkeyRoot)
                {
                    hkeyRoot = pEntries->hkeyRoot;
                    if ( FAILED ( hr = StringCchCopyW(szKey, 4096, pEntries->pszKey) ) )
					{
						return hr;
					}

                    if ( FAILED ( hr = StringCchCopyW(szFullKey, 4096, pEntries->pszKey) ) )
					{
						return hr;
					}
                }
                else
                {
                    if ( FAILED ( hr = StringCchCopyW(szFullKey, 4096, szKey) ) )
					{
						return hr;
					}

                    if ( FAILED ( hr = StringCchCatW(szFullKey, 4096, L"\\") ) ) 
					{
						return hr;
					}

                    if ( FAILED ( hr = StringCchCatW(szFullKey, 4096, pEntries->pszKey) ) )
					{
						return hr;
					}
				}
                if (hkeyRoot == 0)
                {
                    RegistryTableUpdateRegistrySZ(pHead, FALSE);
                    return SELFREG_E_CLASS;

                }
                HKEY hkey; DWORD dw;
                if (pEntries->fFlags & (REGFLAG_DELETE_BEFORE_REGISTERING|REGFLAG_DELETE_WHEN_REGISTERING))
                {
                    LONG err = MyRegDeleteKey(hkeyRoot, szFullKey);
                    if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND) 
                    {
                        RegistryTableUpdateRegistrySZ(pHead, FALSE);
                        return SELFREG_E_CLASS;
                    }
                }
                if (pEntries->fFlags & (REGFLAG_DELETE_ONLY_VALUE))
                {
					LONG err = RegDeleteKeyValue(hkeyRoot, szFullKey, pEntries->pszValueName);
					if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND)
						hr = SELFREG_E_CLASS;
				}
				else
                {
                    LONG err = RegCreateKeyExW(hkeyRoot, szFullKey,
                                               0, 0, REG_OPTION_NON_VOLATILE,
                                               KEY_WRITE, pEntries->pSA, &hkey, &dw);
                    if (err == ERROR_SUCCESS)
                    {
						if (pEntries->pszValue)
                        err = RegSetValueExW(hkey, pEntries->pszValueName, 0, REG_SZ, (const BYTE *)(pEntries->pszValue), ( lstrlenW(pEntries->pszValue) + 1 ) * sizeof ( WCHAR ) );

                        RegCloseKey(hkey);
                        if (hkeyRoot == 0)
                        {
                            RegistryTableUpdateRegistrySZ(pHead, FALSE);
                            return SELFREG_E_CLASS;

                        }
                    }
                    else
                    {
                        RegistryTableUpdateRegistrySZ(pHead, FALSE);
                        return SELFREG_E_CLASS;

                    }
                }
                pEntries++;
            }
        }
    }
    else
    {
        if (pEntries)
        {
            WCHAR szKey[4096] = { L'\0' };
            HKEY hkeyRoot = 0;
        
            while (pEntries->fFlags != -1)
            {
                WCHAR szFullKey[4096] = { L'\0' };
                if (pEntries->hkeyRoot)
                {
                    hkeyRoot = pEntries->hkeyRoot;
                    if ( FAILED ( hr = StringCchCopyW(szKey, 4096, pEntries->pszKey) ) )
					{
						return hr;
					}

                    if ( FAILED ( hr = StringCchCopyW(szFullKey, 4096, pEntries->pszKey) ) )
					{
						return hr;
					}
                }
                else
                {
                    if ( FAILED ( hr = StringCchCopyW(szFullKey, 4096, szKey) ) )
					{
						return hr;
					}

                    if ( FAILED ( hr = StringCchCatW(szFullKey, 4096, L"\\") ) ) 
					{
						return hr;
					}

                    if ( FAILED ( hr = StringCchCatW(szFullKey, 4096, pEntries->pszKey) ) )
					{
						return hr;
					}
                }
                if (hkeyRoot)
				{
					if (!(pEntries->fFlags & REGFLAG_NEVER_DELETE) && 
						!(pEntries->fFlags & REGFLAG_DELETE_WHEN_REGISTERING) &&
						!(pEntries->fFlags & REGFLAG_DELETE_ONLY_VALUE))
					{
						LONG err = MyRegDeleteKey(hkeyRoot, szFullKey);
						if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND)
							hr = SELFREG_E_CLASS;
					}
					else
					if(pEntries->fFlags & REGFLAG_DELETE_ONLY_VALUE)
					{
						LONG err = RegDeleteKeyValue(hkeyRoot, szFullKey, pEntries->pszValueName);
						if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND)
							hr = SELFREG_E_CLASS;
					}
				}

                pEntries++;
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_perf_data.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_perf_data.cpp
//
//	Abstract:
//
//					implements common work with internal data structure
//					( using registry structure )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "WMI_perf_data.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "wmi_perf_reg.h"

// application
#include "WMIAdapter_App.h"
extern WmiAdapterApp		_App;

// global crit sec
extern	CStaticCritSec		g_csInit;

#ifdef	__SUPPORT_REGISTRY_DATA
#include <pshpack8.h>

////////////////////////////////////////////////////////////////////////////////////
// Initialize WINDOWS PERFORMANCE struct from internal structure ( WMI_PERFORMANCE )
////////////////////////////////////////////////////////////////////////////////////

HRESULT	WmiPerformanceData::InitializeData ( void )
{
	// have a wmi performance structure ?
	if ( ! m_perf )
	{
		return E_FAIL;
	}

	HRESULT hRes	= S_OK;

	try
	{
		// refresh internal information
		Generate ();

		if ( IsValidGenerate () )
		{
			DWORD dwCounter	= 0;
			DWORD dwHelp	= 0;

			// count num of supported objects ( first dword )
			m_dwCount = 0;

			PWMI_PERF_NAMESPACE n = NULL;
			PWMI_PERF_OBJECT	o = NULL;

			// get global size
			DWORD dwSize		= 0;
			DWORD dwSizeOrders	= 0;

			// get global index
			DWORD dwIndex	= 0;

			// size we are going to count for each object
			DWORD dwTotalByteLength = 0;
			dwTotalByteLength		=	// PERF_COUNTER_BLOCK
										sizeof ( PERF_OBJECT_TYPE ) +

										// assuming I have PERF_INSTANCE_DEFINITION TOO
										sizeof ( PERF_INSTANCE_DEFINITION ) +
										// so I need pseudo name too
										sizeof ( LPWSTR ) +

										// PERF_COUNTER_BLOCK and its alignment
										sizeof ( PERF_COUNTER_BLOCK ) + 
										sizeof ( DWORD );

			dwCounter	= m_dwFirstCounter + PSEUDO_COUNTER;	// take care of pseudo
			dwHelp		= m_dwFirstHelp + PSEUDO_COUNTER;		// take care of pseudo

			// get namespace
			n = __Namespace::First ( m_perf );
			// goes accross all namespaces
			for ( DWORD dw1 = 0; dw1 < m_perf->dwChildCount; dw1++ )
			{
				// increment count of objects
				m_dwCount += n->dwChildCount;

				// get object
				o = __Object::First ( n );
				// goes accross all objects
				for ( DWORD dw2 = 0; dw2 < n->dwChildCount; dw2++ )
				{
					dwSize =	dwSize + 
								dwTotalByteLength +

								// PERF_COUNTER_DEFINITON child times
								sizeof ( PERF_COUNTER_DEFINITION ) * (int) o->dwChildCount +

								// real data size
								o->dwChildCount * sizeof ( __int64 ) ;

					dwSizeOrders = dwSizeOrders + o->dwChildCount;

					// go accross all of objects
					o = __Object::Next ( o );
				}

				// go accross all namespaces
				n = __Namespace::Next ( n );
			}

			// create real data :))
			data.MemCreate ( dwSize );

			if ( data.IsValid () )
			{
				if SUCCEEDED ( hRes = OrdersAlloc ( m_dwCount ) )
				{
					// get namespace
					n = __Namespace::First ( m_perf );
					// goes accross all namespaces
					for ( DWORD dw1 = 0; dw1 < m_perf->dwChildCount; dw1++ )
					{
						// get object
						o = __Object::First ( n );
						// goes accross all objects
						for ( DWORD dw2 = 0; dw2 < n->dwChildCount; dw2++ )
						{
							// order <---> index
							m_Ord2Ind[ dwIndex++ ] = dwCounter;

							// move counter
							dwCounter	+= 2;
							dwHelp		+= 2;

							// count by number of childs
							dwCounter	+= o->dwChildCount * 2;
							dwHelp		+= o->dwChildCount * 2;

							// go accross all of objects
							o = __Object::Next ( o );
						}

						// go accross all namespaces
						n = __Namespace::Next ( n );
					}
				}
			}
			else
			{
				hRes = E_OUTOFMEMORY;
			}
		}
		else
		{
			hRes = E_FAIL;
		}
	}
	catch ( ... )
	{
		hRes = E_UNEXPECTED;
	}

	return hRes;
}

////////////////////////////////////////////////////////////////////////////////////
// Initialize internal WMI_PERFORMANCE struct from registry
////////////////////////////////////////////////////////////////////////////////////

HRESULT	WmiPerformanceData::InitializePerformance ( void )
{
	HRESULT hRes = S_FALSE;

	if ( m_perf.IsEmpty() )
	{
		hRes		= E_FAIL;
		HRESULT hr	= S_OK;
		LONG lTry	= 3;

		// get bit of registry ( WMI internal )
		while ( SUCCEEDED ( hr ) && FAILED ( hRes ) && lTry-- )
		{
			BYTE* pData = NULL;

			if FAILED ( hRes = GetRegistry ( g_szKey, g_szKeyValue, &pData ) )
			{
				// simulate failure to finish loop
				hr = E_FAIL;

				if ( hRes == HRESULT_FROM_WIN32 ( ERROR_FILE_NOT_FOUND ) )
				{
					if ( ::TryEnterCriticalSection ( &g_csInit ) )
					{
						// lock & leave CS
						_App.InUseSet ( TRUE );
						::LeaveCriticalSection ( &g_csInit );

						try
						{
							// refresh everything ( internal )
							hr = ( ( WmiAdapterStuff*) _App )->Generate ( FALSE ) ;
						}
						catch ( ... )
						{
						}

						if ( ::TryEnterCriticalSection ( &g_csInit ) )
						{
							// unlock & leave CS
							_App.InUseSet ( FALSE );

							::LeaveCriticalSection ( &g_csInit );
						}
					}
				}
			}
			else
			{
				if ( pData )
				{
					// success so store data to m_perf structure
					m_perf.Attach ( reinterpret_cast < WMI_PERFORMANCE * > ( pData ) );
					pData = NULL;
				}
				else
				{
					hRes = S_FALSE;
				}
			}
		}
	}

	return hRes;
}

#include <poppack.h>
#endif	__SUPPORT_REGISTRY_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_perf_data_ext.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_data_ext.cpp
//
//	Abstract:
//
//					extension to internal data struture
//					access registry ...
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "WMI_perf_data_ext.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

void WmiPerformanceDataExt::Generate ( void )
{
	// get data from registry ( COUNTER )
	GetRegistrySame ( g_szKeyCounter, L"First Counter",	&m_dwFirstCounter );
	GetRegistrySame ( g_szKeyCounter, L"First Help",	&m_dwFirstHelp );
	GetRegistrySame ( g_szKeyCounter, L"Last Counter",	&m_dwLastCounter );
	GetRegistrySame ( g_szKeyCounter, L"Last Help",		&m_dwLastHelp );
}

///////////////////////////////////////////////////////////////////////////////
// IsValid
///////////////////////////////////////////////////////////////////////////////
BOOL	WmiPerformanceDataExt::IsValidGenerate ( )
{
	return	(
				m_dwFirstCounter &&
				m_dwFirstHelp && 
				m_dwLastCounter &&
				m_dwLastHelp &&

				( m_dwFirstCounter < m_dwLastCounter ) &&
				( m_dwFirstHelp < m_dwLastHelp ) &&


				( m_dwFirstCounter + 1 == m_dwFirstHelp ) &&
				( m_dwLastCounter + 1 == m_dwLastHelp )
			);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_perf_reg.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_reg.cpp
//
//	Abstract:
//
//					definitions of registry helpers
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// definitions
#include "wmi_perf_reg.h"
#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////////////////////
// construction & destruction
//////////////////////////////////////////////////////////////////////////////////////////////

CPerformanceRegistry::CPerformanceRegistry( PWMI_PERFORMANCE pPerf ):
m_pPerf ( NULL )
{
	m_pPerf = pPerf;
}

CPerformanceRegistry::~CPerformanceRegistry()
{
	m_pPerf = NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// methods
//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CPerformanceRegistry::GetObject ( DWORD dwIndex, PWMI_PERF_OBJECT* ppObject )
{
	// test out pointer
	if ( ! ppObject )
		return E_POINTER;

	// default value
	( *ppObject ) = NULL;

	// look out
	if ( m_pPerf )
	{
		if ( m_pPerf->dwChildCount )
		{
			DWORD				dwHelper	= 0;
			PWMI_PERF_NAMESPACE	pNamespace	= __Namespace::First ( m_pPerf );

			while ( ( ++dwHelper < m_pPerf->dwChildCount ) && ( pNamespace->dwLastID < dwIndex ) )
			{
				pNamespace = __Namespace::Next ( pNamespace );
			}

			( *ppObject ) = __Object::Get ( pNamespace, dwIndex );

			if ( ( *ppObject ) )
			{
				return S_OK;
			}
		}

		return E_FAIL;
	}

	return E_UNEXPECTED;
}

HRESULT CPerformanceRegistry::GetObjectName ( DWORD dwIndex, LPWSTR* ppwsz )
{
	// test out pointer
	if ( ! ppwsz )
	{
		return E_POINTER;
	}

	// default value
	( *ppwsz ) = NULL;

	// local variables
	PWMI_PERF_OBJECT pObject = NULL;

	// look out
	if SUCCEEDED ( GetObject ( dwIndex, &pObject ) )
	{
		( *ppwsz ) = __Object::GetName ( pObject );

		if ( ( *ppwsz ) )
		{
			return S_OK;
		}

		return E_FAIL;
	}

	return E_UNEXPECTED;
}

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_perf_data_create.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_perf_data_create.cpp
//
//	Abstract:
//
//					implements creation of internal data structure
//					( using registry structure )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "WMI_perf_data.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "wmi_perf_reg.h"

#include "WMIAdapter_Stuff.h"

#ifdef	__SUPPORT_REGISTRY_DATA

inline void WmiPerformanceData::AppendMemory ( BYTE* pStr, DWORD dwStr, DWORD& dwOffset )
{
	// append structure
	data.Write ( pStr, dwStr, NULL, dwOffset );
	dwOffset += dwStr;

	return;
}
inline void WmiPerformanceData::AppendMemory ( DWORD dwValue, DWORD& dwOffset )
{
	// append structure
	data.Write ( dwValue, dwOffset );
	dwOffset += sizeof ( DWORD );

	return;
}

#include <pshpack8.h>

////////////////////////////////////////////////////////////////////////////////////
//
//	-------------------------
//	-------------------------
//	WHAT TO RESOLVE IN FINAL:
//	-------------------------
//	-------------------------
//
//	PERF_OBJECT_TYPE:
//
//		... default counter ( doesn't supported )
//
//	PERF_COUNTER_DEFINITION:
//
//		... DONE
//
//	PERF_INSTANCE_DEFINITION:
//
//		... DONE
//
//	PERF_COUNTER_BLOCK:
//
//		... DONE
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT	WmiPerformanceData::CreateData	(
											__WrapperARRAY< WmiRefresherMember < IWbemHiPerfEnum >* > & enums,
											__WrapperARRAY< WmiRefreshObject* >	& handles
										)
{
	if ( ! m_perf )
	{
		return E_FAIL;
	}

	if ( enums.IsEmpty() || handles.IsEmpty() )
	{
		return E_INVALIDARG;
	}

	HRESULT hRes = S_OK;

	DWORD dwCount = m_dwFirstCounter + PSEUDO_COUNTER;	// take care of pseudo
	DWORD dwHelp  = m_dwFirstHelp + PSEUDO_COUNTER;		// take care of pseudo

	// index of current object
	DWORD		dwIndex	= 0L;
	DWORD		offset	= 0;

	// get namespace
	PWMI_PERF_NAMESPACE n = __Namespace::First ( m_perf );
	for ( DWORD dw = 0; dw < m_perf->dwChildCount; dw++ )
	{
		// get object
		PWMI_PERF_OBJECT	o = __Object::First ( n );
		for ( DWORD dwo = 0; dwo < n->dwChildCount; dwo++ )
		{
			// enum contains all instances of object
			IWbemHiPerfEnum*			pEnum	= NULL;

			// refresher helper object
			WmiRefreshObject*			pObj	= NULL;

			if ( o )
			{
				try
				{
					pObj = handles.GetAt ( dwIndex );
				}
				catch ( ... )
				{
					pObj = NULL;
				}

				try
				{
					// create IWbemHiPerfEnum
					if ( enums.GetAt ( dwIndex ) && ( enums.GetAt ( dwIndex ) )->IsValid() )
					{
						pEnum = ( enums.GetAt ( dwIndex ) )->GetMember();
					}
				}
				catch ( ... )
				{
					pEnum = NULL;
				}

				if ( pEnum && pObj )
				{
					hRes = CreateDataInternal (	o,
												pEnum,
												pObj,
												dwCount,
												dwHelp,
												&offset
											  );
				}
				else
				{
					// object is not properly created
					__SetValue ( m_pDataTable, (DWORD) -1,	offsetObject + ( dwIndex * ( ObjectSize ) + offValidity ) );

					// increment object
					dwCount += 2;
					dwHelp	+= 2;

					// increment its counters
					dwCount += o->dwChildCount * 2;
					dwHelp	+= o->dwChildCount * 2;
				}

				dwIndex++;
			}
			else
			{
				hRes = E_UNEXPECTED;
			}

			if FAILED ( hRes )
			{
				//stop loops immediately;
				dwo = n->dwChildCount;
				dw  = m_perf->dwChildCount;
			}

			if ( dwo < n->dwChildCount - 1 )
			{
				// go accross all of objects
				o = __Object::Next ( o );
			}
		}

		if ( dw < m_perf->dwChildCount - 1 )
		{
			// go accross all namespaces
			n = __Namespace::Next ( n );
		}
	}

	return hRes;
}

////////////////////////////////////////////////////////////////////////////////////
// Create object from internal structure
////////////////////////////////////////////////////////////////////////////////////

HRESULT	WmiPerformanceData::CreateDataInternal ( PWMI_PERF_OBJECT pObject,
												 IWbemHiPerfEnum* enm,
												 WmiRefreshObject* obj,
												 DWORD& dwCounter,
												 DWORD& dwHelp,
												 DWORD* dwOffset
											   )
{
	// S_FALSE is going to be checked in the future if object is supposed to be shown in perfmon
	// this signals it is not having required properties 
	HRESULT hRes = S_FALSE;

	// find out how many objects :))
	IWbemObjectAccess**	ppAccess = NULL;
	DWORD				dwAccess = 0;

	// count size we really need
	DWORD dwTotalByteLength			= 0;
	DWORD dwTotalByteLengthOffset	= ( *dwOffset );

	if ( pObject->dwChildCount )
	{
		// Try to get the instances from the enumerator
		// ============================================

		hRes = enm->GetObjects( 0L, dwAccess, ppAccess, &dwAccess );

		// Is the buffer too small? ( HAS TO BE, OTHERWISE WMI IS SCREWED )
		// ========================

		if ( WBEM_E_BUFFER_TOO_SMALL == hRes )
		{
			// Increase the buffer size
			// ========================

			try
			{
				if ( ( ppAccess = new IWbemObjectAccess*[dwAccess] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}
			}
			catch ( ... )
			{
				return E_FAIL;
			}

			// get all objects
			hRes = enm->GetObjects( 0L, dwAccess, ppAccess, &dwAccess );
		}
		else
		{
			// it has to be small for the first time
			return hRes;
		}
	}

	if ( pObject->dwSingleton )
	{
		dwTotalByteLength		=	sizeof ( PERF_OBJECT_TYPE ) +
									sizeof ( PERF_COUNTER_DEFINITION ) * (int) pObject->dwChildCount +

									(
										( pObject->dwChildCount != 0 ) ?
										(
											dwAccess * sizeof ( PERF_INSTANCE_DEFINITION ) +

											dwAccess * (
														 sizeof ( PERF_COUNTER_BLOCK ) + 
														 sizeof ( DWORD ) + 

														 (
														 pObject->dwChildCount * sizeof ( __int64 )
														 )
													   )
										)
										:
										0
									);
	}
	else
	{
		dwTotalByteLength		=	sizeof ( PERF_OBJECT_TYPE ) +
									sizeof ( PERF_COUNTER_DEFINITION ) * (int) pObject->dwChildCount +

									(
										( pObject->dwChildCount != 0 ) ?
										(
											dwAccess * (
														 sizeof ( PERF_COUNTER_BLOCK ) + 
														 sizeof ( DWORD ) + 

														 (
														 pObject->dwChildCount * sizeof ( __int64 )
														 )
													   )
										)
										:
										0
									);
	}

	try
	{
		// get object
		PWMI_PERF_OBJECT o = pObject;

		/////////////////////////////////////////////////////////////////
		// resolve object
		/////////////////////////////////////////////////////////////////

		try
		{
			#ifndef	_WIN64
			LPWSTR	objectName = NULL;
			LPWSTR	objectHelp = NULL;
			#endif	_WIN64

			// time
			unsigned __int64 _PerfTime = 0; 
			unsigned __int64 _PerfFreq = 0;

			if ( ppAccess && obj->m_pHandles[0] )
			{
				ppAccess[0]->ReadQWORD( obj->m_pHandles[0], &_PerfTime );
			}

			if ( ppAccess && obj->m_pHandles[1] )
			{
				ppAccess[0]->ReadQWORD( obj->m_pHandles[1], &_PerfFreq );
			}

			AppendMemory (	dwTotalByteLength, ( *dwOffset ) );
			AppendMemory (	sizeof ( PERF_OBJECT_TYPE ) + 
							sizeof ( PERF_COUNTER_DEFINITION ) * (int) o->dwChildCount, ( *dwOffset ) );
			AppendMemory (	sizeof ( PERF_OBJECT_TYPE ), ( *dwOffset ) );
			AppendMemory (	dwCounter, ( *dwOffset ) );

			#ifndef	_WIN64
			AppendMemory (	(BYTE*)&objectName, sizeof ( LPWSTR ), ( *dwOffset ) );
			#else	_WIN64
			AppendMemory (	0, ( *dwOffset ) );
			#endif	_WIN64

			AppendMemory (	dwHelp, ( *dwOffset ) );

			#ifndef	_WIN64
			AppendMemory (	(BYTE*)&objectHelp, sizeof ( LPWSTR ), ( *dwOffset ) );
			#else	_WIN64
			AppendMemory (	0, ( *dwOffset ) );
			#endif	_WIN64

			AppendMemory (	o->dwDetailLevel, ( *dwOffset ) );
			AppendMemory (	o->dwChildCount, ( *dwOffset ) );
			AppendMemory (	(DWORD)-1, ( *dwOffset ) );
			AppendMemory (	( ( o->dwSingleton == 0 ) ? PERF_NO_INSTANCES : dwAccess ), ( *dwOffset ) );
			AppendMemory (	0, ( *dwOffset ) );
			AppendMemory ( (BYTE*) &_PerfTime,				sizeof ( unsigned __int64 ), ( *dwOffset ) );
			AppendMemory ( (BYTE*) &_PerfFreq,				sizeof ( unsigned __int64 ), ( *dwOffset ) );

			// increment index :)))
			dwCounter	+= 2;
			dwHelp		+= 2;

			/////////////////////////////////////////////////////////////////
			// resolve property
			/////////////////////////////////////////////////////////////////

			// get property
			PWMI_PERF_PROPERTY p = NULL;

			if ( o->dwSingleton )
			{
				// jump across instance
				PWMI_PERF_INSTANCE i = (PWMI_PERF_INSTANCE) ( reinterpret_cast<PBYTE>( o ) + o->dwLength );
				p = (PWMI_PERF_PROPERTY) ( reinterpret_cast<PBYTE>( i ) + i->dwLength );
			}
			else
			{
				p = __Property::First ( o );
			}

			// goes accross all properties
			for ( DWORD dw = 0; dw < o->dwChildCount; dw++ )
			{
				if ( p )
				{
					try
					{
						#ifndef	_WIN64
						LPWSTR	_CounterNameTitle      =	NULL; 
						LPWSTR	_CounterHelpTitle      =	NULL;
						#endif	_WIN64

						AppendMemory ( sizeof ( PERF_COUNTER_DEFINITION), ( *dwOffset ) );
						AppendMemory ( dwCounter, ( *dwOffset ) );

						#ifndef	_WIN64
						AppendMemory ( (BYTE*) &_CounterNameTitle,		sizeof ( LPWSTR ), ( *dwOffset ) );
						#else	_WIN64
						AppendMemory ( 0, ( *dwOffset ) );
						#endif	_WIN64

						AppendMemory ( dwHelp, ( *dwOffset ) );

						#ifndef	_WIN64
						AppendMemory ( (BYTE*) &_CounterHelpTitle,		sizeof ( LPWSTR ), ( *dwOffset ) );
						#else	_WIN64
						AppendMemory ( 0, ( *dwOffset ) );
						#endif	_WIN64

						AppendMemory ( p->dwDefaultScale, ( *dwOffset ) );
						AppendMemory ( p->dwDetailLevel, ( *dwOffset ) );
						AppendMemory ( p->dwCounterType, ( *dwOffset ) );
						AppendMemory ( sizeof ( __int64 ), ( *dwOffset ) );
						AppendMemory ( sizeof ( PERF_COUNTER_BLOCK ) + 
									   sizeof ( DWORD ) + 
									   sizeof ( __int64 ) * (int) dw, ( *dwOffset ) );

						// increment index :)))
						dwCounter	+= 2;
						dwHelp		+= 2;
					}
					catch ( ... )
					{
						// unexpected error
						___TRACE ( L"unexpected error" );
						hRes = E_UNEXPECTED;
						goto myCleanup;
					}

					// get next property
					p = __Property::Next ( p );
				}
				else
				{
					// out of resources
					___TRACE ( L"out of resources" );
					hRes = E_OUTOFMEMORY;
					goto myCleanup;
				}
			}

			/////////////////////////////////////////////////////////////////
			// resolve instances and perf_counter_block
			/////////////////////////////////////////////////////////////////

			if ( o->dwChildCount )
			{
				if ( ppAccess && o->dwSingleton )
				{
					// instances ( resolve instances -> counter block )
					PWMI_PERF_INSTANCE i = (PWMI_PERF_INSTANCE) ( reinterpret_cast<PBYTE>( o ) + o->dwLength );

					for ( DWORD dwi = 0; dwi < dwAccess; dwi++ )
					{
						WCHAR wszNameSimulated [ _MAX_PATH ] = { L'\0' };

						LPWSTR	wszName = NULL;
						DWORD	dwName	= 0L;

						// real length of string
						DWORD	dwHelpLength = 0L;

						CComVariant v;
						CComVariant vsz;

						CComPtr < IWbemClassObject > pClass;
						if SUCCEEDED ( hRes = ppAccess[dwi]->QueryInterface ( __uuidof ( IWbemClassObject ), ( void ** ) &pClass ) )
						{
							if SUCCEEDED ( hRes = pClass->Get	(	reinterpret_cast<LPWSTR> (&(i->dwName)),
																	0,
																	&v,
																	NULL,
																	NULL
																)
									  )
							{
								if ( V_VT ( &v ) != VT_BSTR )
								{
									if SUCCEEDED ( hRes = ::VariantChangeType ( &vsz, &v, VARIANT_NOVALUEPROP, VT_BSTR ) )
									{
										// cached name :))
										wszName = V_BSTR ( & vsz );
										dwHelpLength = ::SysStringLen ( V_BSTR ( &vsz ) ) + 1;
									}
								}
								else
								{
									// cached name :))
									wszName = V_BSTR ( & v );
									dwHelpLength = ::SysStringLen ( V_BSTR ( &v ) ) + 1;
								}
							}
						}

						// have to simulate instance name
						if FAILED ( hRes )
						{
							// sizeof buffer is big enough to hold constant + DWORD string representation
							StringCchPrintfW ( wszNameSimulated, _MAX_PATH , L"_simulated_%d", dwi ) ;

							wszName = wszNameSimulated;
							dwHelpLength = ::lstrlenW( wszName ) + 1;

							hRes = S_FALSE;
						}

						// cached size :))
						if ( ( dwHelpLength ) % 8 )
						{
							DWORD dwRem = 8 - ( ( dwHelpLength ) % 8 );
							dwName = sizeof ( WCHAR ) * ( ( dwHelpLength ) + dwRem );
						}
						else
						{
							dwName = sizeof ( WCHAR ) * ( dwHelpLength );
						}

						// change size to be real one
						dwTotalByteLength += dwName;

						p = (PWMI_PERF_PROPERTY) ( reinterpret_cast<PBYTE>( i ) + i->dwLength );
						/////////////////////////////////////////////////////////
						// resolve instance
						/////////////////////////////////////////////////////////

						try
						{
							AppendMemory ( sizeof ( PERF_INSTANCE_DEFINITION ) + dwName, ( *dwOffset ) );
							AppendMemory ( 0, ( *dwOffset ) );
							AppendMemory ( 0, ( *dwOffset ) );
							AppendMemory ( (DWORD)PERF_NO_UNIQUE_ID, ( *dwOffset ) );
							AppendMemory (	sizeof ( PERF_INSTANCE_DEFINITION ) +
											dwName -
											dwHelpLength * sizeof ( WCHAR ), ( *dwOffset ) );

							AppendMemory ( dwHelpLength * sizeof ( WCHAR ), ( *dwOffset ) );

							( *dwOffset ) += ( dwName - ( dwHelpLength * sizeof ( WCHAR ) ) );

							// copy string into structure
							AppendMemory (	(BYTE*) wszName,
											dwHelpLength * sizeof ( WCHAR ),
											( *dwOffset )
										 );
						}
						catch ( ... )
						{
							// unexpected error
							___TRACE ( L"unexpected error" );
							hRes = E_UNEXPECTED;
						}

						// append counter block
						AppendMemory	(	sizeof ( PERF_COUNTER_BLOCK ) +
											sizeof ( DWORD ) + 
											o->dwChildCount * sizeof ( __int64 ), ( *dwOffset ) );

						// fill hole ( to be 8 aligned )
						( *dwOffset ) +=  sizeof ( DWORD );

						/////////////////////////////////////////////////////////
						// resolve counter data
						/////////////////////////////////////////////////////////

						IWbemObjectAccess* pAccess = NULL;
						if ( ppAccess )
						{
							pAccess = ppAccess[dwi];
						}

						for ( dw = 0; dw < o->dwChildCount; dw++ )
						{
							if ( pAccess )
							{
								if ( p->dwTYPE == CIM_SINT32 || p->dwTYPE == CIM_UINT32 )
								{
									DWORD dwVal = 0;

									// Read the counter property value using the high performance IWbemObjectAccess->ReadDWORD().
									// NOTE: Remember to never to this while a refresh is in process!
									// ==========================================================================================

									if FAILED ( hRes = pAccess->ReadDWORD( obj->m_pHandles[dw+2], &dwVal) )
									{
										___TRACE ( L"... UNABLE TO READ DWORD DATA :))) " );
										goto myCleanup;
									}

									/////////////////////////////////////////////////////////
									// append DATA
									/////////////////////////////////////////////////////////
									AppendMemory (	dwVal, ( *dwOffset ) );
									( *dwOffset ) += sizeof ( __int64 ) - sizeof ( DWORD );
								}
								else
								if ( p->dwTYPE == CIM_SINT64 || p->dwTYPE == CIM_UINT64 )
								{
									unsigned __int64 qwVal = 0;

									// Read the counter property value using the high performance IWbemObjectAccess->ReadDWORD().
									// NOTE: Remember to never to this while a refresh is in process!
									// ==========================================================================================

									if FAILED ( hRes = pAccess->ReadQWORD( obj->m_pHandles[dw+2], &qwVal) )
									{
										___TRACE ( L"... UNABLE TO READ QWORD DATA :))) " );
										goto myCleanup;
									}

									/////////////////////////////////////////////////////////
									// append DATA
									/////////////////////////////////////////////////////////
									AppendMemory (	(BYTE*)&qwVal, sizeof ( __int64 ), ( *dwOffset ) );
								}
								else
								{
									DWORD dwVal = (DWORD) -1;

									/////////////////////////////////////////////////////////
									// append DATA
									/////////////////////////////////////////////////////////
									AppendMemory (	dwVal, ( *dwOffset ) );
									( *dwOffset ) += sizeof ( __int64 ) - sizeof ( DWORD );
								}
							}
							else
							{
								DWORD dwVal = (DWORD) -1;

								/////////////////////////////////////////////////////////
								// append DATA
								/////////////////////////////////////////////////////////
								AppendMemory (	dwVal, ( *dwOffset ) );
								( *dwOffset ) += sizeof ( __int64 ) - sizeof ( DWORD );
							}

							// next property
							p = __Property::Next ( p );
						}
					}

					AppendMemory (	dwTotalByteLength, dwTotalByteLengthOffset );
				}
				else
				{
					// append counter block
					AppendMemory	(	sizeof ( PERF_COUNTER_BLOCK ) +
										sizeof ( DWORD ) + 
										o->dwChildCount * sizeof ( __int64 ), ( *dwOffset ) );

					// fill hole ( to be 8 aligned )
					( *dwOffset ) +=  sizeof ( DWORD );

					/////////////////////////////////////////////////////////
					// resolve counter data
					/////////////////////////////////////////////////////////

					IWbemObjectAccess* pAccess = NULL;
					if ( ppAccess )
					{
						pAccess = ppAccess[0];
					}

					// property
					p = __Property::First ( o );

					for ( dw = 0; dw < o->dwChildCount; dw++ )
					{
						if ( pAccess )
						{
							if ( p->dwTYPE == CIM_SINT32 || p->dwTYPE == CIM_UINT32 )
							{
								DWORD dwVal = 0;

								// Read the counter property value using the high performance IWbemObjectAccess->ReadDWORD().
								// NOTE: Remember to never to this while a refresh is in process!
								// ==========================================================================================

								if FAILED ( hRes = pAccess->ReadDWORD( obj->m_pHandles[dw+2], &dwVal) )
								{
									___TRACE ( L"... UNABLE TO READ DWORD DATA :))) " );
									goto myCleanup;
								}

								/////////////////////////////////////////////////////////
								// append DATA
								/////////////////////////////////////////////////////////
								AppendMemory (	dwVal, ( *dwOffset ) );
								( *dwOffset ) += sizeof ( __int64 ) - sizeof ( DWORD );
							}
							else
							if ( p->dwTYPE == CIM_SINT64 || p->dwTYPE == CIM_UINT64 )
							{
								unsigned __int64 qwVal = 0;

								// Read the counter property value using the high performance IWbemObjectAccess->ReadDWORD().
								// NOTE: Remember to never to this while a refresh is in process!
								// ==========================================================================================

								if FAILED ( hRes = pAccess->ReadQWORD( obj->m_pHandles[dw+2], &qwVal) )
								{
									___TRACE ( L"... UNABLE TO READ QWORD DATA :))) " );
									goto myCleanup;
								}

								/////////////////////////////////////////////////////////
								// append DATA
								/////////////////////////////////////////////////////////
								AppendMemory (	(BYTE*)&qwVal, sizeof ( __int64 ), ( *dwOffset ) );
							}
							else
							{
								DWORD dwVal = (DWORD) -1;

								/////////////////////////////////////////////////////////
								// append DATA
								/////////////////////////////////////////////////////////
								AppendMemory (	dwVal, ( *dwOffset ) );
								( *dwOffset ) += sizeof ( __int64 ) - sizeof ( DWORD );
							}
						}
						else
						{
							DWORD dwVal = (DWORD) -1;

							/////////////////////////////////////////////////////////
							// append DATA
							/////////////////////////////////////////////////////////
							AppendMemory (	dwVal, ( *dwOffset ) );
							( *dwOffset ) += sizeof ( __int64 ) - sizeof ( DWORD );
						}

						// next property
						p = __Property::Next ( p );
					}
				}
			}
		}
		catch ( ... )
		{
			// unexpected error
			___TRACE ( L"unexpected error" );
			hRes = E_UNEXPECTED;
		}
	}
	catch ( ... )
	{
		// unexpected error
		___TRACE ( L"unexpected error" );
		hRes = E_UNEXPECTED;
	}

	myCleanup:

	// Release the objects from the enumerator's object array
	// ======================================================
	
	if ( ppAccess )
	{
		for ( DWORD nCtr = 0; nCtr < dwAccess; nCtr++ )
		{
			if (NULL != ppAccess[nCtr])
			{
				ppAccess[nCtr]->Release();
				ppAccess[nCtr] = NULL;
			}
		}
	}

	if ( NULL != ppAccess )
		delete [] ppAccess;

	// return
	return hRes;
}

#include <poppack.h>

#endif	__SUPPORT_REGISTRY_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_reverse_guard.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_reverse_guard.cpp
//
//	Abstract:
//
//					implementations of 1-writer/many-reader
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "wmi_reverse_guard.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT	WmiReverseGuard:: EnterRead ( const LONG &a_Timeout )
{
	if ( bInit ) 
	{
		LONG	t_Reason = 0;

		t_Reason = WaitForSingleObject ( m_WriterSemaphore , a_Timeout ) ;
		if ( t_Reason != WAIT_OBJECT_0 )
		{
			return E_FAIL ;
		}

		t_Reason = WaitForSingleObject ( m_ReaderSemaphore , a_Timeout ) ;
		if ( t_Reason != WAIT_OBJECT_0 )
		{
			return E_FAIL ;
		}

		LONG t_SemaphoreCount = 0 ;
		if ( ! ReleaseSemaphore ( m_WriterSemaphore , 1 , & t_SemaphoreCount ) )
		{
			return E_FAIL ;
		}

		return S_OK ;
	}

	return E_UNEXPECTED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT	WmiReverseGuard:: EnterWrite ( const LONG &a_Timeout )
{
	if ( bInit ) 
	{
		LONG t_Reason = 0;

		t_Reason = WaitForSingleObject ( m_WriterSemaphore , a_Timeout ) ;
		if ( t_Reason != WAIT_OBJECT_0 )
		{
			return E_FAIL ;
		}

		bool t_Waiting = true ;

		while ( t_Waiting )
		{
			t_Reason = WaitForSingleObject ( m_ReaderSemaphore , a_Timeout ) ;
			if ( t_Reason != WAIT_OBJECT_0 )
			{
				LONG t_SemaphoreCount = 0 ;
				ReleaseSemaphore ( m_WriterSemaphore , 1 , & t_SemaphoreCount ) ;

				return E_FAIL ;
			}

			LONG t_SemaphoreCount = 0 ;
			if ( ReleaseSemaphore ( m_ReaderSemaphore , 1 , & t_SemaphoreCount ) )
			{
				if ( t_SemaphoreCount == m_ReaderSize - 1 )
				{
					t_Waiting = false ;
				}
				else
				{
					SwitchToThread () ;
				}
			}
			else
			{
				LONG t_SemaphoreCount = 0 ;
				ReleaseSemaphore ( m_WriterSemaphore , 1 , & t_SemaphoreCount ) ;

				return E_FAIL ;
			}
		}

		return S_OK ;
	}

	return E_UNEXPECTED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT	WmiReverseGuard:: LeaveRead ()
{
	if ( bInit )
	{
		LONG t_SemaphoreCount = 0 ;
		if ( ReleaseSemaphore ( m_ReaderSemaphore , 1 , & t_SemaphoreCount ) )
		{
			return S_OK ;
		}

		return E_FAIL ;
	}
	else
	{
		return E_UNEXPECTED;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT	WmiReverseGuard:: LeaveWrite ()
{
	if ( bInit )
	{
		LONG t_SemaphoreCount = 0 ;
		if ( ReleaseSemaphore ( m_WriterSemaphore , 1 , & t_SemaphoreCount ) )
		{
			return S_OK ;
		}

		return E_FAIL ;
	}
	else
	{
		return E_UNEXPECTED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmiadapter_app.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmiadapter_app.h
//
//	Abstract:
//
//					declaration of application module
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__APP_H__
#define	__APP_H__

#include "..\WmiAdapter\resource.h"

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// event log
#include "wmi_eventlog_base.h"

// security
#include "wmi_security.h"
#include "wmi_security_attributes.h"

// stuff
#include "WMIAdapter_Stuff.h"

extern LPCWSTR	g_szAppName;

///////////////////////////////////////////////////////////////////////////////
//
// APPLICATION WRAPPER
//
///////////////////////////////////////////////////////////////////////////////

class WmiAdapterApp
{
	DECLARE_NO_COPY ( WmiAdapterApp );

	// critical section ( MAIN GUARD OF APP )
	CRITICAL_SECTION m_cs;

	// variables

	__SmartHANDLE	m_hInstance;	// test for previous instance

	#ifdef	__SUPPORT_EVENTVWR
	// event log
	__WrapperPtr<CPerformanceEventLogBase> pEventLog;
	#endif	__SUPPORT_EVENTVWR

	// security
	__WrapperPtr<WmiSecurityAttributes> pSA;

	// stuff
	__WrapperPtr<WmiAdapterStuff> pStuff;

	BOOL			m_bInUse;			// in use

	#ifdef	__SUPPORT_WAIT
	__SmartHANDLE	m_hData;			// data ready
	#endif	__SUPPORT_WAIT

	__SmartHANDLE	m_hInit;
	__SmartHANDLE	m_hUninit;

	public:

	BOOL			m_bManual;			// type of start up

	#ifdef	__SUPPORT_EVENTVWR
	HMODULE			m_hResources;		// resources ( messages etc )
	#endif	__SUPPORT_EVENTVWR

	__SmartHANDLE	m_hKill;			// kill ( service / com )

	HANDLE	GetInit() const
	{	
		ATLTRACE (	L"*************************************************************\n"
					L"WmiAdapterApp init handle value\n"
					L"*************************************************************\n" );

		return m_hInit;
	}

	HANDLE	GetUninit() const
	{	
		ATLTRACE (	L"*************************************************************\n"
					L"WmiAdapterApp uninit handle value\n"
					L"*************************************************************\n" );

		return m_hUninit;
	}

	///////////////////////////////////////////////////////////////////////////
	// in use
	///////////////////////////////////////////////////////////////////////////

	BOOL	InUseGet() const
	{
		ATLTRACE (	L"*************************************************************\n"
					L"WmiAdapterApp inuse GET\n"
					L"*************************************************************\n" );

		return m_bInUse;
	}

	void	InUseSet( const BOOL bInUse )
	{
		ATLTRACE (	L"*************************************************************\n"
					L"WmiAdapterApp inuse SET\n"
					L"*************************************************************\n" );

		m_bInUse = bInUse;
	}

	#ifdef	__SUPPORT_WAIT
	BOOL	SignalData ( BOOL bSignal = TRUE )
	{
		BOOL bResult = FALSE;

		if ( m_hData.GetHANDLE() != NULL )
		{
			if ( ! bSignal )
			{
				::ResetEvent ( m_hData );

				ATLTRACE ( L"\n SignalData TRUE ( non signaled )\n" );
				bResult = TRUE;
			}
			else
			if ( ::WaitForSingleObject ( m_hData, 0 ) != WAIT_OBJECT_0 )
			{
				::SetEvent ( m_hData );

				ATLTRACE ( L"\n SignalData TRUE ( signaled )\n" );
				bResult = TRUE;
			}
		}
		#ifdef	_DEBUG
		if ( !bResult )
		{
			ATLTRACE ( L"\n SignalData FALSE \n" );
		}
		#endif	_DEBUG

		return bResult;
	}
	#endif	__SUPPORT_WAIT

	///////////////////////////////////////////////////////////////////////////
	// cast operators
	///////////////////////////////////////////////////////////////////////////

	operator WmiAdapterStuff*() const
	{
		return pStuff;
	}

	operator WmiSecurityAttributes*() const
	{
		return pSA;
	}

	#ifdef	__SUPPORT_EVENTVWR
	operator CPerformanceEventLogBase*() const
	{
		return pEventLog;
	}
	#endif	__SUPPORT_EVENTVWR

	///////////////////////////////////////////////////////////////////////////
	// construction & destruction
	///////////////////////////////////////////////////////////////////////////

	WmiAdapterApp( );
	~WmiAdapterApp();

	///////////////////////////////////////////////////////////////////////////
	// INITIALIZATION
	///////////////////////////////////////////////////////////////////////////
	HRESULT InitKill		( void );
	HRESULT InitAttributes	( void );
	HRESULT Init			( void );

	void	Term			( void );

	///////////////////////////////////////////////////////////////////////////
	// exists instance ?
	///////////////////////////////////////////////////////////////////////////

	BOOL Exists ( void );

	///////////////////////////////////////////////////////////////////////////
	// helper functions
	///////////////////////////////////////////////////////////////////////////
	static LPCWSTR FindOneOf(LPCWSTR p1, LPCWSTR p2)
	{
		while (p1 != NULL && *p1 != NULL)
		{
			LPCWSTR p = p2;
			while (p != NULL && *p != NULL)
			{
				if (*p1 == *p)
					return CharNextW(p1);
				p = CharNextW(p);
			}
			p1 = CharNextW(p1);
		}
		return NULL;
	}
};

#endif	__APP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmiadapter_messages.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmiadapter_messages.h
//
//	Abstract:
//
//					export from resource dll
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMIADAPTERMESSAGES_H__
#define	__WMIADAPTERMESSAGES_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// export/import
#ifdef	WMIADAPTERMESSAGES_EXPORTS
#define	WMIADAPTERMESSAGES_API	__declspec(dllexport)
#else	! WMIADAPTERMESSAGES_EXPORTS
#define	WMIADAPTERMESSAGES_API	__declspec(dllimport)
#endif	WMIADAPTERMESSAGES_EXPORTS

// registration exports
WMIADAPTERMESSAGES_API HRESULT __stdcall Register_Messages		( void );
WMIADAPTERMESSAGES_API HRESULT __stdcall Unregister_Messages	( void );

#endif	__WMIADAPTERMESSAGES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmiadapter_service.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmiadapter_service.h
//
//	Abstract:
//
//					declaration of service module
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__SERVICE_H__
#define	__SERVICE_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

class WmiAdapterService
{
	DECLARE_NO_COPY ( WmiAdapterService );

    SERVICE_STATUS_HANDLE	m_hServiceStatus;
    SERVICE_STATUS			m_ServiceStatus;

	CRITICAL_SECTION m_cs;

	BOOL	m_bUsed;

	public:

	///////////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	///////////////////////////////////////////////////////////////////////////////////////////////

	WmiAdapterService() :
		m_hServiceStatus ( NULL ),
		m_bUsed ( FALSE )
	{
		::InitializeCriticalSection ( &m_cs );
	}

	~WmiAdapterService();

	///////////////////////////////////////////////////////////////////////////////////////////////
	// start
	///////////////////////////////////////////////////////////////////////////////////////////////

	BOOL StartService ( void );

	///////////////////////////////////////////////////////////////////////////////////////////////
	// service status
	///////////////////////////////////////////////////////////////////////////////////////////////
	BOOL			SetServiceStatus ( DWORD dwState );
	SERVICE_STATUS* GetServiceStatus ( void ) const;

	void WINAPI ServiceMain		( DWORD dwArgc, LPWSTR* lpszArgv );
    void WINAPI ServiceHandler	( DWORD dwOpcode);

	///////////////////////////////////////////////////////////////////////////////////////////////
	// initialization
	///////////////////////////////////////////////////////////////////////////////////////////////
	HRESULT Init ( void );

	///////////////////////////////////////////////////////////////////////////////////////////////
	// registration
	///////////////////////////////////////////////////////////////////////////////////////////////
	HRESULT	RegisterService ( void );

	///////////////////////////////////////////////////////////////////////////////////////////////
	// unregistration
	///////////////////////////////////////////////////////////////////////////////////////////////
	HRESULT	UnregisterService ( bool bStatus = true );

	///////////////////////////////////////////////////////////////////////////////////////////////
	// MAIN WORK ROUTINE
	///////////////////////////////////////////////////////////////////////////////////////////////
	LONG Work();

	private:

	///////////////////////////////////////////////////////////////////////////////////////////////
	// service initializators
	///////////////////////////////////////////////////////////////////////////////////////////////

	static void WINAPI _ServiceMain		( DWORD dwArgc, LPWSTR* lpszArgv );
	static void WINAPI _ServiceHandler	( DWORD dwOpcode );

	///////////////////////////////////////////////////////////////////////////////////////////////
	// is service installed
	//
	// -1	... internal error
	// 0	... not installed
	// 1	... installed
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

	int IsInstalled ( SC_HANDLE hSC );
};

extern WmiAdapterService _Service;

#endif	__SERVICE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmiadapter_stuff_refresh.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmiadapter_stuff_refresher.h
//
//	Abstract:
//
//					declaration of wrapper for refresher object
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__ADAPTER_STUFF_REFRESH_H__
#define	__ADAPTER_STUFF_REFRESH_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

///////////////////////////////////////////////////////////////////
//
//	WmiRefresherMember
//
//	This class facilitates the management of objects or enumerators 
//	that have been added to the refresher and the unique ID assigned
//	to them.
//
///////////////////////////////////////////////////////////////////

template<class T>
class WmiRefresherMember
{
	T*		m_pMember;
	long	m_lID;

public:
	WmiRefresherMember() : m_pMember( NULL ), m_lID( 0 ) {}
	~WmiRefresherMember() { if ( NULL != m_pMember) m_pMember->Release(); }

	void Set(T* pMember, long lID);
	void Reset();

	T* GetMember();
	long GetID(){ return m_lID; }

	BOOL IsValid();
};

template <class T> inline void WmiRefresherMember<T>::Set(T* pMember, long lID) 
{ 
	if ( NULL != pMember )
		pMember->AddRef();
	m_pMember = pMember;  
	m_lID = lID;
}

template <class T> inline void WmiRefresherMember<T>::Reset()
{
	if (NULL != m_pMember)
		m_pMember->Release();

	m_pMember = NULL;
	m_lID = 0;
}

template <class T> inline T* WmiRefresherMember<T>::GetMember()
{
	return m_pMember;
}

template <class T> inline BOOL WmiRefresherMember<T>::IsValid()
{
	return ( m_pMember != NULL );
}

#endif	__ADAPTER_STUFF_REFRESH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmiadapter_stuff.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmiadapter_stuff.h
//
//	Abstract:
//
//					declaration of stuff for performance refresh
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__ADAPTER_STUFF_H__
#define	__ADAPTER_STUFF_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// include
#include "wmi_reverse_memory_ext.h"
#include "wmi_perf_data.h"

#include "RefresherStuff.h"
#include "WMIAdapter_Stuff_Refresh.h"

//enum
#include <refreshergenerate.h>

///////////////////////////////////////////////////////////////////////////////
//  storing handles of counters of object
///////////////////////////////////////////////////////////////////////////////
class WmiRefreshObject
{
	DECLARE_NO_COPY ( WmiRefreshObject );

	public:

	LONG*	m_pHandles;

	WmiRefreshObject():
		m_pHandles ( NULL )
	{
	};

	~WmiRefreshObject()
	{
		delete [] m_pHandles;
		m_pHandles = NULL;
	};
};

///////////////////////////////////////////////////////////////////////////////
// performance refreshing
///////////////////////////////////////////////////////////////////////////////
template < class WmiRefreshParent >
class WmiRefresh;

///////////////////////////////////////////////////////////////////////////////
// adapter stuff
///////////////////////////////////////////////////////////////////////////////
class WmiAdapterStuff
{
	DECLARE_NO_COPY ( WmiAdapterStuff );

	// wmi :))
	WmiPerformanceData										m_data;		// data helper
	WmiMemoryExt < WmiReverseMemoryExt<WmiReverseGuard> >	m_pMem;		// shared memory

	WmiRefresh < WmiAdapterStuff > * m_pWMIRefresh;

	public:

	WmiRefresherStuff	m_Stuff;

	// construction & destruction
	WmiAdapterStuff();
	~WmiAdapterStuff();

	///////////////////////////////////////////////////////
	// construction & destruction helpers
	///////////////////////////////////////////////////////
	public:

	BOOL	IsValidBasePerfRegistry	( void );
	BOOL	IsValidInternalRegistry	( void );

	HRESULT Init ( void );
	HRESULT	Uninit ( void );

	///////////////////////////////////////////////////////
	// generate files & registry
	///////////////////////////////////////////////////////
	HRESULT Generate ( BOOL bInitialize = TRUE, GenerateEnum type = Normal );

	/////////////////////////////////////////////////////////////////////////
	// check usage of shared memory ( protect against perfmon has killed )
	/////////////////////////////////////////////////////////////////////////
	void CheckUsage (void );

	///////////////////////////////////////////////////////
	// performance refreshing
	///////////////////////////////////////////////////////
	HRESULT	Initialize		( void );
	void	Uninitialize	( void );

	HRESULT	InitializePerformance	( void );
	HRESULT	UninitializePerformance	( void );

	HRESULT Refresh ( void );

	///////////////////////////////////////////////////////////////////////////
	// registry refresh
	///////////////////////////////////////////////////////////////////////////
	BOOL	RequestGet();
	BOOL	RequestSet();
};

#endif	__ADAPTER_STUFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_adapter_objectlist.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter_objectlist.h
//
//	Abstract:
//
//					object list helper class ( declaration )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__ADAPTER_OBJECTLIST_H__
#define	__ADAPTER_OBJECTLIST_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

class WmiAdapterObjectList
{
	DECLARE_NO_COPY ( WmiAdapterObjectList );

	// variables
	LPWSTR	m_pwszList;
	bool	m_bValid;

	public:

	WmiAdapterObjectList ( LPCWSTR wszList = NULL ) :
	m_pwszList ( NULL ),
	m_bValid ( false )
	{
		if ( wszList )
		{
			if ( lstrcmpiW ( L"COSTLY", wszList ) != 0 )
			{
				if ( lstrcmpiW ( L"GLOBAL", wszList ) != 0 )
				{
					try
					{
						DWORD cchSize = lstrlenW(wszList) + 3;
						if ( ( m_pwszList = new WCHAR [ cchSize ] ) != NULL )
						{
							StringCchPrintfW ( m_pwszList, cchSize, L" %s ", wszList );
							m_bValid = true;
						}
					}
					catch ( ... )
					{
					}
				}
			}
		}

	}

	~WmiAdapterObjectList()
	{
		if ( m_pwszList )
		{
			delete m_pwszList;
			m_pwszList = NULL;
		}
	}

	// function to find out if asking for supported object
	bool IsInList ( DWORD dwObject )
	{
		if ( m_bValid )
		{
			bool bResult = true;

			if ( m_pwszList )
			{
				WCHAR wszObject[32] = { L'\0' };
				StringCchPrintfW( wszObject, 32, L" %d ", dwObject );
				bResult = ( wcsstr( m_pwszList, wszObject ) != NULL );
			}

			return bResult;
		}

		return m_bValid;
	}
};

#endif	__ADAPTER_OBJECTLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_adapter.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter.h
//
//	Abstract:
//
//					export of functions from perf libary
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMIREVERSESADAPTER_H__
#define	__WMIREVERSESADAPTER_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// export/import
#ifdef	WMIREVERSEADAPTER_EXPORTS
#define	WMIREVERSEADAPTER_API	__declspec(dllexport)
#else	WMIREVERSEADAPTER_EXPORTS
#define	WMIREVERSEADAPTER_API	__declspec(dllimport)
#endif	WMIREVERSEADAPTER_EXPORTS

// performance exports

WMIREVERSEADAPTER_API
DWORD __stdcall WmiOpenPerfData		(	LPWSTR lpwszDeviceNames );

WMIREVERSEADAPTER_API
DWORD __stdcall WmiClosePerfData	();

WMIREVERSEADAPTER_API
DWORD __stdcall WmiCollectPerfData	(	LPWSTR lpwszValue, 
										LPVOID *lppData, 
										LPDWORD lpcbBytes, 
										LPDWORD lpcObjectTypes
									);

// registration exports
EXTERN_C HRESULT __stdcall	DllRegisterServer	( void );
EXTERN_C HRESULT __stdcall	DllUnregisterServer	( void );

#endif	__WMIREVERSESADAPTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmiaplog.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_log.h
//
//	Abstract:
//
//					declaration of log module and class
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__MY_LOG_H__
#define	__MY_LOG_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifdef	__SUPPORT_LOGGING

////////////////////////////////////////////////////////////////////////////////////
// abstract base
////////////////////////////////////////////////////////////////////////////////////
template < class __DUMMY >
class ATL_NO_VTABLE MyLog
{
	DECLARE_NO_COPY ( MyLog );

	public:

	MyLog ( )
	{
	}

	~MyLog ( )
	{
	}

	HRESULT Log		( LPCWSTR wszName, DWORD dwResult );
	HRESULT Log		( LPCWSTR wszName );
};

template < class __DUMMY >
HRESULT MyLog < __DUMMY > :: Log ( LPCWSTR wszName, DWORD dwResult )
{
	HRESULT	hr	= E_OUTOFMEMORY;
	WCHAR*	psz	= NULL;

	if ( !wszName )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		try
		{
			DWORD cchSize = lstrlenW ( wszName ) + 1 + 2 + 8 + 1 + 1;
			if  ( ( psz = new WCHAR [ cchSize ] ) != NULL )
			{
				if ( SUCCEEDED ( hr = StringCchPrintfW ( psz, cchSize, L"%s %08x", wszName, dwResult ) ) )
				{
					hr = Log ( psz );
				}
			}
		}
		catch ( ... )
		{
			hr = E_UNEXPECTED;
		}

		if ( psz )
		{
			delete [] psz;
			psz = NULL;
		}
	}

	return hr;
}

template < class __DUMMY >
HRESULT MyLog < __DUMMY > :: Log ( LPCWSTR wszName )
{
	HRESULT	hr	= E_OUTOFMEMORY;

	if ( !wszName )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		DWORD		dwThreadId = 0L;
		SYSTEMTIME	systime;

		dwThreadId = ::GetCurrentThreadId ();
		::GetSystemTime ( &systime );

		WCHAR* psz = NULL;

		try
		{
			DWORD cchSize = lstrlenW ( wszName ) + 1 + 2 + 8 + 1 + 2 + 3 + 2 + 3 + 2 + 3 + 2 + 3 + 1 + 1;
			if ( ( psz = new WCHAR [ cchSize ] ) != NULL )
			{
				if ( SUCCEEDED ( hr = StringCchPrintfW ( psz, cchSize, L"%s %08x %02d:%02d:%02d:%02d\n", wszName, dwThreadId, systime.wHour, systime.wMinute, systime.wSecond, systime.wMilliseconds ) ) )
				{
					OutputDebugString ( psz );
					hr = S_OK;
				}
			}
		}
		catch ( ... )
		{
			hr = E_UNEXPECTED;
		}

		if ( psz )
		{
			delete [] psz;
			psz = NULL;
		}
	}

	return hr;
}

__declspec ( selectany ) MyLog< void > log;

// macros
#define AdapterLogMessage0(lpszMessage)				log.Log ( lpszMessage )
#define	AdapterLogMessage1(lpszMessage, dwResult)	log.Log ( lpszMessage, dwResult )

#else	__SUPPORT_LOGGING

// macros
#define AdapterLogMessage0(lpszMessage)
#define	AdapterLogMessage1(lpszMessage, dwResult)

#endif	__SUPPORT_LOGGING

#endif	__MY_LOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_adapter_registry_service.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter_registry_service.h
//
//	Abstract:
//
//					Declaration of the Registry for wmi reverse adapter
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef __WMI_ADAPTER_REGISTRY_SERVICE_H_
#define __WMI_ADAPTER_REGISTRY_SERVICE_H_

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifndef	_REGTABLE_H
#include "wmi_helper_regtable.h"
#endif	_REGTABLE_H

// application
#include "WMIAdapter_App.h"
extern WmiAdapterApp		_App;

extern LPCWSTR g_szKey;

class WmiAdapterRegistryService
{
	DECLARE_NO_COPY ( WmiAdapterRegistryService );

	public:

	// construction & destruction
	WmiAdapterRegistryService( )
	{
	}

	~WmiAdapterRegistryService( )
	{
	}

	// registry map

	BEGIN_CLASS_REGISTRY_TABLE_SZ(WmiAdapterRegistry)

	REGISTRY_KEY_SZ(HKEY_CLASSES_ROOT,
					L"AppID\\{63A53A38-004F-489B-BD61-96B5EEFADC04}",
					L"LocalService",
					L"WMIApSrv",
//					( ((WmiSecurityAttributes*) _App) != NULL ) ? ((WmiSecurityAttributes*) _App)->GetSecurityAttributtes() : NULL,
					NULL,
					REGFLAG_NORMAL)

	REGISTRY_KEY_SZ	(HKEY_LOCAL_MACHINE,
					g_szKey,
					NULL,
					NULL,
//					( ((WmiSecurityAttributes*) _App) != NULL ) ? ((WmiSecurityAttributes*) _App)->GetSecurityAttributtes() : NULL,
					NULL,
					REGFLAG_NORMAL | REGFLAG_DELETE_BEFORE_REGISTERING)

	END_CLASS_REGISTRY_TABLE_SZ()
};

#endif	__WMI_ADAPTER_REGISTRY_SERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_adapter_registry.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter_registry.h
//
//	Abstract:
//
//					Declaration of the Registry for wmi reverse adapter
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef __WMI_ADAPTER_REGISTRY_H_
#define __WMI_ADAPTER_REGISTRY_H_

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifndef	_REGTABLE_H
#include "wmi_helper_regtable.h"
#endif	_REGTABLE_H

// constants are declared extern
extern WCHAR g_szPath[];
extern LPCWSTR g_szOpen;
extern LPCWSTR g_szCollect;
extern LPCWSTR g_szClose;

extern __WrapperPtr<WmiSecurityAttributes>	pSA;

extern LPCWSTR	g_szKeyCounter;

extern LPCWSTR	g_szKey;
extern LPCWSTR	g_szKeyValue;

class WmiAdapterRegistry
{
	DECLARE_NO_COPY ( WmiAdapterRegistry );


	public:

	// construction & destruction
	WmiAdapterRegistry( )
	{
	}

	~WmiAdapterRegistry( )
	{
	}

	// registry map

	BEGIN_CLASS_REGISTRY_TABLE_SZ(WmiAdapterRegistry)

	REGISTRY_KEY_SZ(HKEY_LOCAL_MACHINE,
					g_szKeyCounter,
					L"Library",
					g_szPath,
					pSA->GetSecurityAttributtes(),
					REGFLAG_NORMAL)

	REGISTRY_KEY_SZ(HKEY_LOCAL_MACHINE,
					g_szKeyCounter,
					L"Open",
					g_szOpen,
					pSA->GetSecurityAttributtes(),
					REGFLAG_NORMAL)

	REGISTRY_KEY_SZ(HKEY_LOCAL_MACHINE,
					g_szKeyCounter,
					L"Collect",
					g_szCollect,
					pSA->GetSecurityAttributtes(),
					REGFLAG_NORMAL)

	REGISTRY_KEY_SZ(HKEY_LOCAL_MACHINE,
					g_szKeyCounter,
					L"Close",
					g_szClose,
					pSA->GetSecurityAttributtes(),
					REGFLAG_NORMAL)

	REGISTRY_KEY_SZ(HKEY_LOCAL_MACHINE,
					g_szKey,
					g_szKeyValue,
					NULL,
					pSA->GetSecurityAttributtes(),
					REGFLAG_DELETE_ONLY_VALUE)

	END_CLASS_REGISTRY_TABLE_SZ()

};

#endif	__WMI_ADAPTER_REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_eventlog_base.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_eventlog_base.h
//
//	Abstract:
//
//					declaration for event log wrapper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__PERF_EVENT_LOG_BASE_H__
#define	__PERF_EVENT_LOG_BASE_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// enable tstring
#ifndef	_INC_TCHAR
#include <tchar.h>
#endif	_INC_TCHAR

class CPerformanceEventLogBase
{
	// disallow assigment & copy construction
	DECLARE_NO_COPY ( CPerformanceEventLogBase )

	// variables
 	LONG	m_lLogCount;
	HANDLE	m_hEventLog;

	// report variables
	PSID	m_pSid;

 	public:

	// construction & destruction
	CPerformanceEventLogBase ( LPTSTR szName = NULL );
 	virtual ~CPerformanceEventLogBase ( void );

	// methods
 	HRESULT	Open ( LPTSTR pszName = NULL);
 	void	Close ( void );

	// report event
	BOOL	ReportEvent (	WORD		wType,
							WORD		wCategory,
							DWORD		dwEventID,
							WORD		wStrings,
							DWORD		dwData,
							LPCWSTR*	lpStrings,
							LPVOID		lpRawData
						);

 	static	void	Initialize		( LPTSTR szAppName, LPTSTR szResourceName );
 	static	void	UnInitialize	( LPTSTR szAppName );

	// helpers
	void InitializeFromToken ( void );
};

#endif	__PERF_EVENT_LOG_BASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_adapter_wrapper.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter_wrapper.h
//
//	Abstract:
//
//					declaration of adapter real working stuff
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_ADAPTER_WRAPPER_H__
#define	__WMI_ADAPTER_WRAPPER_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// shared memory 
#ifndef	__REVERSE_MEMORY_H__
#include "wmi_reverse_memory.h"
#endif	__REVERSE_MEMORY_H__

#ifndef	__REVERSE_MEMORY_EXT_H__
#include "wmi_reverse_memory_ext.h"
#endif	__REVERSE_MEMORY_EXT_H__

#include "wmi_memory_ext.h"

class WmiAdapterWrapper
{
	DECLARE_NO_COPY ( WmiAdapterWrapper );

	// variables

	LONG													m_lUseCount;	// reference count

	WmiMemoryExt < WmiReverseMemoryExt<WmiReverseGuard> >	m_pMem;			// shared memory
	CRITICAL_SECTION										m_pCS;			// critical section for collect

	__SmartServiceHANDLE hSCM;	// service manager ( helper )

	BYTE*	m_pData;
	DWORD	m_dwData;
	DWORD	m_dwDataOffsetCounter;
	DWORD	m_dwDataOffsetValidity;

	DWORD	m_dwPseudoCounter;
	DWORD	m_dwPseudoHelp;

	__SmartHANDLE	m_hRefresh;
	BOOL			m_bRefresh;

	#ifdef	__SUPPORT_WAIT
	__SmartHANDLE	m_hReady;
	#endif	__SUPPORT_WAIT

	public:

	// construction
	WmiAdapterWrapper();

	// destruction
	~WmiAdapterWrapper();

	// real functions

	DWORD	Open	( LPWSTR wszDeviceNames );
	DWORD	Close	( void );
	DWORD	Collect	( LPWSTR	wszValue,
					  LPVOID*	lppData,
					  LPDWORD	lpcbBytes,
					  LPDWORD	lpcbObjectTypes
					);

	private:

	DWORD	CollectObjects	( LPWSTR	wszValue,
							  LPVOID*	lppData,
							  LPDWORD	lpcbBytes,
							  LPDWORD	lpcbObjectTypes
							);

	void	CloseLib ( BOOL bInit = TRUE );

	// report event to event log
	BOOL ReportEvent (	WORD	wType,
						DWORD	dwEventID,
						WORD	wStrings	= 0,
						LPWSTR*	lpStrings	= NULL
					 );

	BOOL ReportEvent (	DWORD dwError, WORD wType, DWORD dwEventSZ  );

	// creation of pseudo
	HRESULT	PseudoCreateRefresh	( void );
	HRESULT	PseudoCreate		( void );
	void	PseudoDelete		( void );

	void	PseudoRefresh	( DWORD	dwCount );
	void	PseudoRefresh	( BOOL bValid = TRUE );

	// helpers
	void	AppendMemory ( BYTE* pStr, DWORD dwStr, DWORD& dwOffset );
	void	AppendMemory ( DWORD dwValue, DWORD& dwOffset );

	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////
	// count of memories
	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////

	DWORD	MemoryCountGet ( void )
	{
		return m_pMem.GetMemory ( 0 ) ->GetValue ( offsetCountMMF );
	}

	void	MemoryCountSet ( DWORD dwCount )
	{
		m_pMem.GetMemory ( 0 ) ->SetValue ( dwCount, offsetCountMMF );
	}

	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////
	// size of table
	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////

	DWORD	TableSizeGet ( void )
	{
		return m_pMem.GetMemory ( 0 ) ->GetValue ( offsetSize1 );
	}

	void	TableSizeSet ( DWORD dwSize )
	{
		m_pMem.GetMemory ( 0 ) ->SetValue ( dwSize, offsetSize1 );
	}

	DWORD	TableOffsetGet ( void )
	{
		return TableSizeGet() + offsetSize1;
	}

	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////
	// count of objects
	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////

	DWORD	CountGet ( void )
	{
		return m_pMem.GetMemory ( 0 ) ->GetValue ( offsetCount1 );
	}

	void	CountSet ( DWORD dwCount )
	{
		m_pMem.GetMemory ( 0 ) ->SetValue ( dwCount, offsetCount1 );
	}

	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////
	// real size
	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////

	DWORD	RealSizeGet ( void )
	{
		return m_pMem.GetMemory ( 0 ) ->GetValue ( offsetRealSize1 );
	}

	void	RealSizeSet ( DWORD dwSize )
	{
		m_pMem.GetMemory ( 0 ) ->SetValue ( dwSize, offsetRealSize1 );
	}

	///////////////////////////////////////////////////////////////////////////
	// get object properties from ord
	///////////////////////////////////////////////////////////////////////////

	DWORD	GetCounter ( DWORD dwOrd );
	DWORD	GetOffset ( DWORD dwOrd );
	DWORD	GetValidity ( DWORD dwOrd );

	///////////////////////////////////////////////////////////////////////////
	// is valid ordinary
	///////////////////////////////////////////////////////////////////////////

	BOOL	IsValidOrd ( DWORD dwOrd )
	{
		return ( dwOrd <= CountGet() );
	}

	// return error from memory
	HRESULT MemoryGetLastError ( DWORD dwOffsetBegin )
	{
		DWORD dwSize = 0L;
		dwSize = m_pMem.GetSize ( );

		DWORD dwCount = 0L;
		dwCount = m_pMem.GetCount ( );

		DWORD dwIndex = 0L;

		if ( dwCount )
		{
			dwSize	= dwSize / dwCount;
			dwIndex	= dwOffsetBegin / dwSize;
		}

		return m_pMem.GetMemory ( dwIndex ) -> GetLastError ();
	}
};

#endif	__WMI_ADAPTER_WRAPPER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_eventlog.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_EventLog
//
//	Abstract:
//
//					event log adapter specific declarations
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__PERF_EVENT_LOG_H__
#define	__PERF_EVENT_LOG_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// enable tstring
#ifndef	_INC_TCHAR
#include <tchar.h>
#endif	_INC_TCHAR

#include "wmi_eventlog_base.h"

class CPerformanceEventLog : public CPerformanceEventLogBase
{
	// disallow assigment & copy construction
	DECLARE_NO_COPY ( CPerformanceEventLog )

	// variables
 	DWORD	m_dwMessageLevel;

 	public:

	// construction & destruction
	CPerformanceEventLog ( LPTSTR szName = NULL );
	CPerformanceEventLog ( DWORD dwMessageLevel, LPTSTR szName = NULL );
 	virtual ~CPerformanceEventLog ( void );

	private:

	// helpers
	void	InitializeMessageLevel ( void );
};

#endif	__PERF_EVENT_LOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_helper_regtable.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_helper_regtable.h
//
//	Abstract:
//
//					registry updater declaration
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef _REGTABLE_H
#define _REGTABLE_H

// basic table layout
typedef struct _REGISTRY_ENTRY {
    HKEY        hkeyRoot;
    const WCHAR *pszKey;
    const WCHAR *pszValueName;
    DWORD		dwValue;

	LPSECURITY_ATTRIBUTES	pSA;

    int         fFlags;
} REGISTRY_ENTRY;

typedef struct _REGISTRY_ENTRY_SZ {
    HKEY        hkeyRoot;
    const WCHAR *pszKey;
    const WCHAR *pszValueName;
    const WCHAR *pszValue;

	LPSECURITY_ATTRIBUTES	pSA;

    int         fFlags;
} REGISTRY_ENTRY_SZ;

// the routine that inserts/deletes Registry keys based on the table
EXTERN_C HRESULT STDAPICALLTYPE RegistryTableUpdateRegistry(REGISTRY_ENTRY *pEntries, BOOL bInstalling);
EXTERN_C HRESULT STDAPICALLTYPE RegistryTableUpdateRegistrySZ(REGISTRY_ENTRY_SZ *pEntries, BOOL bInstalling);

// flags for 
enum REGFLAGS {
    REGFLAG_NORMAL = 0x0,
    REGFLAG_NEVER_DELETE = 0x1,
    REGFLAG_DELETE_WHEN_REGISTERING = 0x2,
    REGFLAG_DELETE_BEFORE_REGISTERING = 0x4,
	REGFLAG_DELETE_ONLY_VALUE = 0x8
};

#define BEGIN_REGISTRY_TABLE(TableName) \
static REGISTRY_ENTRY TableName [] = {        

#define REGISTRY_KEY(hkr, pszKey, pszValueName, dwValue, pSA, fFlags) \
    { hkr, pszKey, pszValueName, dwValue, pSA, fFlags },

#define END_REGISTRY_TABLE() \
    { 0, 0, 0, 0, 0, -1 } \
};

#define BEGIN_CLASS_REGISTRY_TABLE(ClassName) \
    static HRESULT STDAPICALLTYPE __UpdateRegistry(BOOL bInstalling) \
    {\
        BEGIN_REGISTRY_TABLE(entries)

#define END_CLASS_REGISTRY_TABLE() \
        END_REGISTRY_TABLE()\
        return RegistryTableUpdateRegistry(entries, bInstalling);\
    }   

#define BEGIN_REGISTRY_TABLE_SZ(TableName) \
static REGISTRY_ENTRY_SZ TableName [] = {        

#define REGISTRY_KEY_SZ(hk, pszKey, pszValueName, pszValue, pSA, fFlags) \
    { hk, pszKey, pszValueName, pszValue, pSA, fFlags },

#define END_REGISTRY_TABLE_SZ() \
    { 0, 0, 0, 0, 0, -1 } \
};

#define BEGIN_CLASS_REGISTRY_TABLE_SZ(ClassName) \
    static HRESULT STDAPICALLTYPE __UpdateRegistrySZ(BOOL bInstalling) \
    {\
        BEGIN_REGISTRY_TABLE_SZ(entries)

#define END_CLASS_REGISTRY_TABLE_SZ() \
        END_REGISTRY_TABLE_SZ()\
        return RegistryTableUpdateRegistrySZ(entries, bInstalling);\
    }   

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_memory.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_memory.h
//
//	Abstract:
//
//					declaration of memory wrapper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_MEMORY_H__
#define	__WMI_MEMORY_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// guard
#include "wmi_reverse_guard.h"

template < class CRITGUARD >
class WmiMemory
{
	DECLARE_NO_COPY ( WmiMemory );

	__WrapperPtr < CRITGUARD > m_pGuard;

	protected:

	DWORD	m_dwDataSize;
	BYTE*	m_pData;

	HRESULT m_LastError;

	public:

	/////////////////////////////////////////////////////////////////////////////////////
	//	LAST ERROR HELPER
	/////////////////////////////////////////////////////////////////////////////////////

	HRESULT GetLastError ( void )
	{
		HRESULT hr = S_OK;

		hr			= m_LastError;
		m_LastError = S_OK;

		return hr;
	}

	// construction

	WmiMemory ( LPCWSTR, DWORD dwSize = 4096, LPSECURITY_ATTRIBUTES psa = NULL  ):
		m_dwDataSize ( 0 ),
		m_pData ( NULL ),

		m_LastError ( S_OK )
	{
		try
		{
			m_pGuard.SetData ( new CRITGUARD( FALSE, 100, 1, psa ) );
		}
		catch ( ... )
		{
			___ASSERT_DESC ( m_pGuard != NULL, L"Constructor FAILED !" );
		}

		MemCreate ( NULL, dwSize, psa );
	}

	virtual ~WmiMemory ()
	{
		try
		{
			MemDelete ();
		}
		catch ( ... )
		{
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//	VALIDITY
	/////////////////////////////////////////////////////////////////////////////////////

	BOOL IsValid ( void )
	{
		return ( m_pData != NULL );
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//	ACCESSORS
	/////////////////////////////////////////////////////////////////////////////////////

	// get data
	PVOID	GetData () const
	{
		return m_pData;
	}

	// get data size
	DWORD	GetDataSize () const
	{
		return m_dwDataSize;
	}

	void	SetDataSize ( DWORD size )
	{
		m_dwDataSize = size;
	}

	// functions
	BOOL Write	(LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset);
	BOOL Read	(LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset);

	void	Write	( DWORD dwValue, DWORD dwOffset );
	PBYTE	Read	( DWORD* pdwBytesRead, DWORD dwOffset );

	// helpers
	HRESULT MemCreate ( LPCWSTR, DWORD dwSize, LPSECURITY_ATTRIBUTES psa = NULL  );
	HRESULT MemDelete ();
};

template < class CRITGUARD >
HRESULT WmiMemory < CRITGUARD > ::MemCreate ( LPCWSTR, DWORD dwSize, LPSECURITY_ATTRIBUTES )
{
	___ASSERT ( m_pData == NULL );

	if ( dwSize )
	{
		try
		{
			if ( ( m_pData = new BYTE [ dwSize ] ) != NULL )
			{
				m_pData[0] = NULL;
				m_dwDataSize = dwSize;
			}
			else
			{
				m_LastError = E_OUTOFMEMORY;
				return m_LastError;
			}
		}
		catch ( ... )
		{
			m_LastError = E_UNEXPECTED;
			return m_LastError;
		}

		m_LastError = S_OK;
		return S_OK;
	}

	m_LastError = S_FALSE;
	return S_FALSE;
}

// delete memory
template < class CRITGUARD >
HRESULT WmiMemory < CRITGUARD > ::MemDelete ()
{
	if ( m_pData )
	{
		delete [] m_pData;
		m_pData = NULL;
	}

	m_dwDataSize = 0;

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// write into memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class CRITGUARD >
BOOL WmiMemory < CRITGUARD > ::Write (LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset )
{
	___ASSERT(m_pData != NULL);
	BOOL bResult = FALSE;

	if ( m_pGuard )
	{
		m_pGuard->EnterWrite ();

		if ( dwOffset > m_dwDataSize )
		{
			if ( pdwBytesWritten )
			{
				*pdwBytesWritten = 0;
			}

			m_LastError = E_INVALIDARG;
			return FALSE;
		}
		else
		{
			DWORD dwCount = min ( dwBytesToWrite, m_dwDataSize - dwOffset );
			::CopyMemory ((LPBYTE) m_pData + dwOffset, pBuffer, dwCount);

			if (pdwBytesWritten != NULL)
			{
				*pdwBytesWritten = dwCount;
			}

			m_pGuard->LeaveWrite ();

			bResult = TRUE;
		}
	}

	return bResult;
}

template < class CRITGUARD >
void WmiMemory < CRITGUARD > ::Write (DWORD dwValue, DWORD dwOffset )
{
	___ASSERT(m_pData != NULL);

	if ( m_pGuard )
	{
		m_pGuard->EnterWrite ();
		if ( dwOffset > m_dwDataSize )
		{
			m_LastError = E_INVALIDARG;
			return;
		}

		* reinterpret_cast < PDWORD > ( (LPBYTE) m_pData + dwOffset ) = dwValue;
		m_pGuard->LeaveWrite ();
	}

	return;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// read from memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class CRITGUARD >
BOOL WmiMemory < CRITGUARD > ::Read (LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset )
{
	___ASSERT (m_pData != NULL);
	BOOL bResult = FALSE;

	if ( m_pGuard )
	{
		m_pGuard->EnterRead ();

		if (dwOffset > m_dwDataSize)
		{
			if ( pdwBytesRead )
			{
				*pdwBytesRead = 0;
			}

			m_LastError = E_INVALIDARG;
		}
		else
		{
			DWORD dwCount = min (dwBytesToRead, m_dwDataSize - dwOffset);
			::CopyMemory (pBuffer, (LPBYTE) m_pData + dwOffset, dwCount);

			if (pdwBytesRead != NULL)
			{
				*pdwBytesRead = dwCount;
			}

			m_pGuard->LeaveRead ();

			bResult = TRUE;
		}
	}

	return bResult;
}

template < class CRITGUARD >
PBYTE WmiMemory < CRITGUARD > ::Read ( DWORD* pdwBytesRead, DWORD dwOffset )
{
	___ASSERT (m_pData != NULL);
	PBYTE pByte = NULL;

	if ( m_pGuard )
	{
		m_pGuard->EnterRead ();

		if (dwOffset > m_dwDataSize)
		{
			if ( pdwBytesRead )
			{
				*pdwBytesRead = 0;
			}

			m_LastError = E_INVALIDARG;
		}
		else
		{
			pByte = (LPBYTE) m_pData + dwOffset;

			if (pdwBytesRead != NULL)
			{
				if ( pByte )
				{
					*pdwBytesRead = m_dwDataSize - dwOffset;
				}
				else
				{
					*pdwBytesRead = 0L;
				}
			}

			m_pGuard->LeaveRead ();
		}
	}

	return pByte;
}

#endif	__WMI_MEMORY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_memory_ext.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_memory.ext.h
//
//	Abstract:
//
//					declaration of single linked list of memories
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__MEMORY_EXT_H__
#define	__MEMORY_EXT_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

template < class MEMORY >
class WmiMemoryExt
{
	DECLARE_NO_COPY ( WmiMemoryExt );

	protected:

	DWORD						m_dwSize;		// size
	DWORD						m_dwGlobalSize;	// global size ( count of all )
	DWORD						m_dwCount;		// count of memories

	__WrapperARRAY < MEMORY* >	pMemory;	// array of memories

	LPCWSTR					m_wszName;
	LPSECURITY_ATTRIBUTES	m_psa;

	public:

	// construction

	WmiMemoryExt ( ) :

		m_dwGlobalSize ( 0 ),
		m_dwSize ( 0 ),
		m_dwCount ( 0 ),

		m_psa ( NULL ),

		m_wszName ( NULL )
	{
	}

	virtual ~WmiMemoryExt ()
	{
		try
		{
			MemDelete ();
		}
		catch ( ... )
		{
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//	VALIDITY
	/////////////////////////////////////////////////////////////////////////////////////

	BOOL IsValid ( void )
	{
		BOOL bValid = FALSE ;

		if( !pMemory.IsEmpty() )
		{
			bValid = TRUE ;
			for ( DWORD dw = 0 ; dw < GetCount () && bValid ; dw ++ )
			{
				if ( TRUE == ( bValid = ( NULL != GetMemory ( dw ) ) ) )
				{
					bValid = GetMemory ( dw )->IsValid() ;
				}
			}
		}

		return bValid ;
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//	ACCESSORS
	/////////////////////////////////////////////////////////////////////////////////////

	MEMORY*	GetMemory ( DWORD dwIndex ) const
	{
		if ( dwIndex < m_dwCount )
		{
			return pMemory [ dwIndex ];
		}

		return NULL;
	}

	// get name
	LPWSTR	GetName () const
	{
		return m_wszName;
	}

	// get size
	DWORD	GetSize () const
	{
		return m_dwGlobalSize;
	}

	// get count
	DWORD	GetCount () const
	{
		return m_dwCount;
	}

	// functions
	BOOL Write			(LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset);
	void Write			(DWORD dwValue, DWORD dwOffset);
	BOOL Read			(LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset, BOOL bReadAnyWay = FALSE);
	BOOL Read			(LPVOID pBuffer, DWORD dwBytesToRead, DWORD dwOffset);
	PBYTE ReadBytePtr	(DWORD dwIndex, DWORD* pdwBytesRead);

	// helpers
	HRESULT MemCreate ( LPCWSTR wszName = NULL, LPSECURITY_ATTRIBUTES psa = NULL  );
	HRESULT MemCreate ( DWORD dwSize );

	HRESULT MemDelete ();
};

// create memory
template < class MEMORY >
HRESULT WmiMemoryExt < MEMORY > ::MemCreate ( LPCWSTR wszName, LPSECURITY_ATTRIBUTES psa )
{
	// store security attributets on the first time
	if ( !m_psa && psa )
	{
		m_psa = psa;
	}

	// store name on the first time
	if ( !m_wszName && wszName )
	{
		m_wszName = wszName;
	}

	return S_OK;
}

// create memory
template < class MEMORY >
HRESULT WmiMemoryExt < MEMORY > ::MemCreate ( DWORD dwSize )
{
	HRESULT hRes = E_OUTOFMEMORY;

	try
	{
		MEMORY* mem = NULL;

		if ( m_wszName )
		{
			try
			{
				WCHAR name [_MAX_PATH] = { L'\0' };
				StringCchPrintfW ( name, _MAX_PATH, L"%s_%d", m_wszName, m_dwCount );

				if ( ( mem = new MEMORY ( name, dwSize, m_psa ) ) != NULL )
				{
					hRes = S_OK;
				}
			}
			catch ( ... )
			{
				hRes = E_UNEXPECTED;
			}
		}
		else
		{
			try
			{
				if ( ( mem = new MEMORY ( NULL, dwSize, m_psa ) ) != NULL )
				{
					hRes = S_OK;
				}
			}
			catch ( ... )
			{
				hRes = E_UNEXPECTED;
			}
		}

		if ( ! m_dwCount )
		{
			m_dwSize = mem->GetDataSize();
		}
		else
		{
			mem->SetDataSize ( dwSize );
		}

		pMemory.DataAdd ( mem );

		m_dwGlobalSize += m_dwSize;
		m_dwCount++;
	}
	catch ( ... )
	{
		hRes = E_UNEXPECTED;
	}

	return hRes;
}

// delete memory
template < class MEMORY >
HRESULT WmiMemoryExt < MEMORY > ::MemDelete ()
{
	if ( ! pMemory.IsEmpty() )
	{
		for ( DWORD dw = pMemory; dw > 0; dw-- )
		{
			if ( pMemory[dw-1] )
			{
				pMemory[dw-1]->MemDelete();
				pMemory.DataDelete(dw-1);
			}
		}

		delete [] pMemory.Detach();
	}

	m_dwSize  = 0;
	m_dwGlobalSize  = 0;
	m_dwCount = 0;

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// write into memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class MEMORY >
BOOL WmiMemoryExt < MEMORY >::Write (LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset )
{
	// we have a memory :))
	___ASSERT ( IsValid () && ( m_dwSize != 0 ) );

	if ( !IsValid() || !m_dwSize )
	{
		return FALSE;
	}

	DWORD dwMainIndex = 0L;
	DWORD dwMainCount = 0L;

	dwMainIndex = dwOffset/m_dwSize;
	dwMainCount = dwBytesToWrite/m_dwSize + ( ( dwBytesToWrite%m_dwSize ) ? 1 : 0 );

	if ( dwOffset > m_dwGlobalSize )
	{
		// they want new memory to be created :))
		for ( DWORD dw = 0; dw < dwMainIndex; dw ++ )
		{
			if FAILED ( MemCreate ( m_dwSize ) )
			{
				if ( pdwBytesWritten )
				{
					( *pdwBytesWritten ) = 0;
				}

				return FALSE;
			}
		}
	}

	if ( dwBytesToWrite > ( m_dwGlobalSize - dwOffset ) )
	{
		// they want new memory to be created :))
		for ( DWORD dw = 0; dw < dwMainCount; dw ++ )
		{
			if FAILED ( MemCreate ( m_dwSize ) )
			{
				if ( pdwBytesWritten )
				{
					( *pdwBytesWritten ) = 0;
				}

				return FALSE;
			}
		}
	}

	// memory
	MEMORY* pmem = NULL;

	DWORD dwWritten = 0;

	pmem = const_cast< MEMORY* > ( pMemory [ dwMainIndex ] );
	if ( ! pmem -> Write (	pBuffer,
							(	( ( dwBytesToWrite >= ( m_dwSize - dwOffset%m_dwSize ) ) ?
									m_dwSize - dwOffset%m_dwSize :
									dwBytesToWrite%m_dwSize
								)
							),
							&dwWritten,
							dwOffset%m_dwSize
						 )
	   )
	{
		if ( pdwBytesWritten )
		{
			( *pdwBytesWritten ) = 0;
		}

		return FALSE;
	}

	// write rest of buffer
	DWORD dwIndex = dwMainIndex;
	while ( ( dwBytesToWrite > dwWritten ) && ( dwIndex < m_dwCount ) )
	{
		DWORD dwWrite = 0;

		pmem = const_cast< MEMORY* > ( pMemory [ ++dwIndex ] );
		if ( ! pmem->Write (	(PBYTE)pBuffer + dwWritten,
								(	( ( dwBytesToWrite - dwWritten ) >= m_dwSize ) ?

									m_dwSize :
									( dwBytesToWrite - dwWritten ) % m_dwSize
								),

								&dwWrite,
								0
						   )
		   )
		{
			if ( pdwBytesWritten )
			{
				( *pdwBytesWritten ) = 0;
			}

			return FALSE;
		}

		dwWritten += dwWrite;
	}

	// how many bytes :))
	if ( pdwBytesWritten )
	{
		( * pdwBytesWritten ) = dwWritten;
	}

	return TRUE;
}

template < class MEMORY >
void WmiMemoryExt < MEMORY >::Write( DWORD dwValue, DWORD dwOffset )
{
	// we have a memory :))
	___ASSERT ( IsValid () && ( m_dwSize != 0 ) );

	if ( IsValid() && ( m_dwSize != 0 ) )
	{
		DWORD dwMainIndex = 0L;
		DWORD dwMainCount = 0L;

		dwMainIndex = dwOffset/m_dwSize;
		dwMainCount = (sizeof ( DWORD ))/m_dwSize + ( ( (sizeof ( DWORD ))%m_dwSize ) ? 1 : 0 );

		if ( dwOffset > m_dwGlobalSize )
		{
			// they want new memory to be created :))
			for ( DWORD dw = 0; dw < dwMainIndex; dw ++ )
			{
				if FAILED ( MemCreate ( m_dwSize ) )
				{
					return;
				}
			}
		}

		if ( (sizeof ( DWORD )) > ( m_dwGlobalSize - dwOffset ) )
		{
			// they want new memory to be created :))
			for ( DWORD dw = 0; dw < dwMainCount; dw ++ )
			{
				if FAILED ( MemCreate ( m_dwSize ) )
				{
					return;
				}
			}
		}

		MEMORY* pmem = const_cast< MEMORY* > ( pMemory [ dwMainIndex ] );
		pmem->Write( dwValue, dwOffset%m_dwSize );
	}

	return;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// read from memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class MEMORY >
BOOL WmiMemoryExt < MEMORY >::Read (LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset, BOOL bReadAnyWay )
{
	// we have a memory :))
	___ASSERT ( IsValid () && ( m_dwSize != 0 ) );

	if ( !IsValid() || !m_dwSize )
	{
		return FALSE;
	}

	DWORD dwMainIndex = 0L;
	DWORD dwMainCount = 0L;

	dwMainIndex = dwOffset/m_dwSize;
	dwMainCount = dwBytesToRead/m_dwSize + ( ( dwBytesToRead%m_dwSize ) ? 1 : 0 );

	if ( dwOffset > m_dwGlobalSize )
	{
		// they want new memory to be created :))
		for ( DWORD dw = 0; dw < dwMainIndex; dw ++ )
		{
			if FAILED ( MemCreate ( m_dwSize ) )
			{
				if ( pdwBytesRead )
				{
					( *pdwBytesRead ) = 0;
				}

				return FALSE;
			}
		}

		if ( !bReadAnyWay )
		{
			if ( pdwBytesRead )
			{
				( *pdwBytesRead ) = 0;
			}

			return FALSE;
		}
	}

	if ( dwBytesToRead > ( m_dwGlobalSize - dwOffset ) )
	{
		// they want new memory to be created :))
		for ( DWORD dw = 0; dw < dwMainCount; dw ++ )
		{
			if FAILED ( MemCreate ( m_dwSize ) )
			{
				if ( pdwBytesRead )
				{
					( *pdwBytesRead ) = 0;
				}

				return FALSE;
			}
		}

		if ( !bReadAnyWay )
		{
			if ( pdwBytesRead )
			{
				( *pdwBytesRead ) = 0;
			}

			return FALSE;
		}
	}

	// memory
	MEMORY* pmem = NULL;

	DWORD dwRead = 0;

	pmem = const_cast< MEMORY* > ( pMemory [ dwMainIndex ] );
	if ( ! pmem -> Read (	pBuffer,
							( ( dwBytesToRead >= m_dwSize - dwOffset%m_dwSize ) ?
								m_dwSize - dwOffset%m_dwSize :
								dwBytesToRead%m_dwSize
							),
							&dwRead,
							dwOffset%m_dwSize
						 )
	   )
	{
		if ( pdwBytesRead )
		{
			( *pdwBytesRead ) = 0;
		}

		return FALSE;
	}

	// read rest of buffer
	DWORD dwIndex    = dwMainIndex;
	while ( ( dwBytesToRead > dwRead ) && ( dwIndex < m_dwCount ) )
	{
		DWORD dwReadHelp = 0;

		pmem = const_cast< MEMORY* > ( pMemory [ ++dwIndex ] );
		if ( ! pmem->Read (	(PBYTE) ( (PBYTE)pBuffer + dwRead ),
								( ( ( dwBytesToRead - dwRead ) >= m_dwSize ) ?
										m_dwSize :
										( dwBytesToRead - dwRead ) % m_dwSize
								),
								&dwReadHelp,
								0
						   )
		   )
		{
			if ( pdwBytesRead )
			{
				( *pdwBytesRead ) = 0;
			}

			return FALSE;
		}

		dwRead += dwReadHelp;
	}

	// how many bytes :))
	if ( pdwBytesRead )
	{
		( * pdwBytesRead ) = dwRead;
	}

	return TRUE;
}

template < class MEMORY >
BOOL WmiMemoryExt < MEMORY >::Read ( LPVOID pBuffer, DWORD dwBytesToRead, DWORD dwOffset )
{
	// we have a memory :))
	___ASSERT ( IsValid () && ( m_dwSize != 0 ) );

	if ( !IsValid() || !m_dwSize )
	{
		return FALSE;
	}

	DWORD dwMainIndex = 0L;
	DWORD dwMainCount = 0L;

	dwMainIndex = dwOffset/m_dwSize;
	dwMainCount = dwBytesToRead/m_dwSize + ( ( dwBytesToRead%m_dwSize ) ? 1 : 0 );

	if ( dwOffset > m_dwGlobalSize )
	{
		// they want new memory to be created :))
		for ( DWORD dw = 0; dw < dwMainIndex; dw ++ )
		{
			if FAILED ( MemCreate ( m_dwSize ) )
			{
				return FALSE;
			}
		}
	}

	if ( dwBytesToRead > ( m_dwGlobalSize - dwOffset ) )
	{
		// they want new memory to be created :))
		for ( DWORD dw = 0; dw < dwMainCount; dw ++ )
		{
			if FAILED ( MemCreate ( m_dwSize ) )
			{
				return FALSE;
			}
		}
	}

	DWORD dwIndex	= 0L;
	DWORD dwRead	= 0;

	dwIndex = dwMainIndex;

	if ( m_dwCount && ( MEMORY** ) pMemory != NULL )
	{

		DWORD dwReadHelp = 0;

		do
		{
			MEMORY* pmem = const_cast< MEMORY* > ( pMemory [ dwIndex ] );

			if ( ! pmem -> Read (	(LPBYTE) pBuffer + dwRead,
									( ( dwBytesToRead - dwRead >= m_dwSize - dwOffset%m_dwSize ) ?
										m_dwSize - dwOffset%m_dwSize :
										( dwBytesToRead - dwRead ) % m_dwSize
									),
									&dwReadHelp,
									dwOffset%m_dwSize
								 )
			   )
			{
					return FALSE;
			}

			dwRead += dwReadHelp;
			dwOffset = 0;

			dwIndex++;

			if ( dwRead < dwBytesToRead && m_dwCount < dwIndex + 1 )
			{
				if FAILED ( MemCreate ( m_dwSize ) )
				{
					return FALSE;
				}
			}
		}
		while ( ( dwRead < dwBytesToRead ) && ( dwIndex < m_dwCount ) );
	}

	return TRUE;
}

template < class MEMORY >
PBYTE WmiMemoryExt < MEMORY >::ReadBytePtr ( DWORD dwIndex, DWORD* pdwBytesRead )
{
	if ( dwIndex < m_dwCount )
	{
		MEMORY* pmem = const_cast< MEMORY* > ( pMemory [ dwIndex ] );
		return pmem->Read ( pdwBytesRead, 0L );
	}

	if ( pdwBytesRead )
	{
		( *pdwBytesRead ) = 0L;
	}

	return NULL;
}

#endif	__MEMORY_EXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_perf_data.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_data.h
//
//	Abstract:
//
//					declaration of data performance service is dealing with
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_DATA__
#define	__WMI_PERF_DATA__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

//behaviour
#define	__SUPPORT_REGISTRY_DATA
#define	__SUPPORT_PSEUDO_COUNTER

#ifdef	__SUPPORT_PSEUDO_COUNTER
#define	PSEUDO_COUNTER	6
#else	__SUPPORT_PSEUDO_COUNTER
#define	PSEUDO_COUNTER	0
#endif	__SUPPORT_PSEUDO_COUNTER

//////////////////////////////////////////////////////////////////////////////////////////////
// includes
//////////////////////////////////////////////////////////////////////////////////////////////
#ifndef	_WINPERF_
#include "winperf.h"
#endif	_WINPERF_

#ifndef	__WMI_PERF_DATA_EXT__
#include "wmi_perf_data_ext.h"
#endif	__WMI_PERF_DATA_EXT__

#ifndef	__WMI_PERF_REGSTRUCT__
#include "wmi_perf_regstruct.h"
#endif	__WMI_PERF_REGSTRUCT__

// creator neccessary :))
#include "WMIAdapter_Stuff_Refresh.h"
class WmiRefreshObject;

///////////////////////////////////////////////////////////////////////////////
//
//	structure of memory
//
//	dwCount of MMF			... not yet
//	dwSize of MMF
//
//	dwSizeOfTable			... jumps to raw data
//	dwCountOfObjects
//	dwRealSize
//
//	---------------------------------------------
//
//	dwIndex
//	dwCounter				... object 1
//	dwOffset
//	dwValidity
//
//	---------------------------------------------
//	---------------------------------------------
//
//	dwIndex
//	dwCounter				... object 2
//	dwOffset
//	dwValidity
//
//	---------------------------------------------
//
//	raw data ( perf_object_types )
//
///////////////////////////////////////////////////////////////////////////////

#define	offsetCountMMF		0
#define	offsetSizeMMF		offsetCountMMF + sizeof ( DWORD )

#define	offsetSize1		offsetSizeMMF + sizeof ( DWORD )

#define	offsetSize		0
#define	offsetCount		offsetSize + sizeof ( DWORD )
#define	offsetRealSize	offsetCount + sizeof ( DWORD )
#define	offsetObject	offsetRealSize + sizeof ( DWORD )

#define	COUNTMMF		sizeof ( DWORD )
#define SIZEMMF			sizeof ( DWORD )

#define	SizeSize		sizeof ( DWORD )
#define	CountSize		sizeof ( DWORD )
#define	RealSize		sizeof ( DWORD )

#define	offIndex		0
#define	offCounter		offIndex + sizeof ( DWORD )
#define	offOffset		offCounter + sizeof ( DWORD )
#define	offValidity		offOffset + sizeof ( DWORD )

#define	ObjectSize		4 * sizeof ( DWORD )

//////////////////////////////////////////////////////////////////////////////////////////////
// variables
//////////////////////////////////////////////////////////////////////////////////////////////

// extrern constant

extern LPCWSTR g_szKey;
extern LPCWSTR g_szKeyValue;

//////////////////////////////////////////////////////////////////////////////////////////////
// classes
//////////////////////////////////////////////////////////////////////////////////////////////

#include <pshpack8.h>

// memory

#include "wmi_memory.h"
#include "wmi_memory_ext.h"

class WmiPerformanceData : public WmiPerformanceDataExt
{
	DECLARE_NO_COPY ( WmiPerformanceData );

	#ifdef	__SUPPORT_REGISTRY_DATA
	__WrapperPtr < WMI_PERFORMANCE >		m_perf;
	#endif	__SUPPORT_REGISTRY_DATA

	// data
	WmiMemoryExt < WmiMemory<WmiReverseGuard> > data;

	BYTE* m_pDataTable;
	DWORD m_dwDataTable;

	public:

	// construction
	WmiPerformanceData ():

		m_pDataTable ( NULL ),
		m_dwDataTable ( 0 )

	{
	}

	// destruction
	~WmiPerformanceData ()
	{
		DataClear();
		DataTableClear();

		#ifdef	__SUPPORT_REGISTRY_DATA
		ClearPerformanceData();
		#endif	__SUPPORT_REGISTRY_DATA
	}

	///////////////////////////////////////////////////////////////////////////
	// data structures ACCESSORS
	///////////////////////////////////////////////////////////////////////////

	void DataClear ( void )
	{
		data.MemDelete();
	}

	PBYTE GetData ( DWORD dwIndex, DWORD * dwBytesRead )
	{
		return data.ReadBytePtr ( dwIndex, dwBytesRead );
	}

	DWORD GetDataSize () const
	{
		return data.GetSize();
	}

	DWORD GetDataCount () const
	{
		return data.GetCount();
	}

	void DataTableClear ( void )
	{
		if ( m_pDataTable )
		{
			free ( m_pDataTable );

			m_pDataTable = NULL;
			m_dwDataTable = 0;
		}
	}

	PBYTE GetDataTable () const
	{
		return m_pDataTable;
	}

	DWORD GetDataTableSize () const
	{
		return m_dwDataTable;
	}

	DWORD GetDataTableOffset ()
	{
		return offsetSize1;
	}

	void SetDataTable ( BYTE* p )
	{
		___ASSERT ( m_pDataTable == NULL );
		m_pDataTable = p;
	}

	void SetDataTableSize ( DWORD dw )
	{
		___ASSERT ( m_dwDataTable == NULL );
		m_dwDataTable = dw;
	}

	///////////////////////////////////////////////////////////////////////////
	// performance internal structure ACCESSORS
	///////////////////////////////////////////////////////////////////////////

	#ifdef	__SUPPORT_REGISTRY_DATA

	void ClearPerformanceData ( void )
	{
		if ( ! m_perf.IsEmpty() )
		{
			delete m_perf.Detach();
		}
	}

	PWMI_PERFORMANCE GetPerformanceData () const
	{
		return m_perf;
	}

	void SetPerformanceData ( PWMI_PERFORMANCE perf )
	{
		// I'm empty one, don't I ? :)))
		___ASSERT ( m_perf == NULL );

		try
		{
			m_perf.SetData( perf );
		}
		catch ( ... )
		{
		}
	}

	void SetPerformanceDataCopy ( PWMI_PERFORMANCE perf )
	{
		// I'm empty one, don't I ? :)))
		___ASSERT ( m_perf == NULL );

		try
		{
			PWMI_PERFORMANCE p = NULL;

			if ( ( p = (PWMI_PERFORMANCE) new BYTE [ perf->dwTotalLength ] ) != NULL )
			{
				::CopyMemory ( p, perf, perf->dwTotalLength );
				m_perf.SetData ( p );
			}
		}
		catch ( ... )
		{
		}
	}

	#endif	__SUPPORT_REGISTRY_DATA

	HRESULT InitializeTable ( void );
	HRESULT	RefreshTable	( void );

	#ifdef	__SUPPORT_REGISTRY_DATA

	///////////////////////////////////////////////////////////////////////////
	// WINDOWS PERF structures
	///////////////////////////////////////////////////////////////////////////

	HRESULT InitializeData ( void );

	HRESULT	CreateData ( __WrapperARRAY< WmiRefresherMember < IWbemHiPerfEnum >* >	& enums,
						 __WrapperARRAY< WmiRefreshObject* >						& handles
					   );

	///////////////////////////////////////////////////////////////////////////
	// performance internal structure
	///////////////////////////////////////////////////////////////////////////
	HRESULT	InitializePerformance ( void );

	private:

	///////////////////////////////////////////////////////////////////////////
	// create objects
	///////////////////////////////////////////////////////////////////////////

	HRESULT	CreateDataInternal ( PWMI_PERF_OBJECT pObject,
								 IWbemHiPerfEnum* enm,
								 WmiRefreshObject* obj,
								 DWORD& dwCounter,
								 DWORD& dwHelp,
								 DWORD* pdwRes );

	#endif	__SUPPORT_REGISTRY_DATA


	private:

	///////////////////////////////////////////////////////////////////////////
	// append byte* :))
	///////////////////////////////////////////////////////////////////////////

	#ifdef	__SUPPORT_REGISTRY_DATA
	inline void AppendMemory ( BYTE* pStr, DWORD dwStr, DWORD& dwOffset );
	inline void AppendMemory ( DWORD dwValue, DWORD& dwOffset );
	#endif	__SUPPORT_REGISTRY_DATA

	public:

	///////////////////////////////////////////////////////////////////////////
	// work w/ specified offset ( UNSAFE )
	///////////////////////////////////////////////////////////////////////////

	DWORD	__GetValue ( BYTE * p, DWORD dwOffset )
	{
		___ASSERT ( p != NULL );
		return ( * reinterpret_cast<PDWORD> ( p + dwOffset ) );
	}

	void	__SetValue ( BYTE * p, DWORD dwValue, DWORD dwOffset )
	{
		___ASSERT ( p != NULL );
		* reinterpret_cast<PDWORD> ( p + dwOffset ) = dwValue;
	}
};

#include <poppack.h>
#endif	__WMI_PERF_DATA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_perf_reg.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_reg.h
//
//	Abstract:
//
//					declarations of registry helpers structure accessors etc
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_REG__
#define	__WMI_PERF_REG__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// need atl wrappers :)))
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

#include "wmi_perf_regstruct.h"

//////////////////////////////////////////////////////////////////////////////////////////////
// smart realloc
//////////////////////////////////////////////////////////////////////////////////////////////

template < typename T >
T* _RA_realloc ( T* memblock, size_t size )
{
	T* pTmp = NULL;
	if ( NULL == ( pTmp = (T*) realloc ( memblock, size ) ) )
	{
		free ( reinterpret_cast < void* > ( memblock ) );
	}

	return pTmp;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// class for creation of reg structures
//////////////////////////////////////////////////////////////////////////////////////////////

#include <pshpack8.h>

template < class REQUEST, class PARENT, class CHILD >
class CPerformanceStructureManipulator
{
	DECLARE_NO_COPY ( CPerformanceStructureManipulator );

	// variables
	REQUEST*							m_pRequest;

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	CPerformanceStructureManipulator( LPWSTR lpwsz, DWORD dwID ):
	m_pRequest(0)
	{
		m_pRequest = CreateStructure ( lpwsz, dwID );
	}

	CPerformanceStructureManipulator( DWORD dwLastID ):
	m_pRequest(0)
	{
		m_pRequest = CreateStructure ( dwLastID );
	}

	~CPerformanceStructureManipulator()
	{
		free ( m_pRequest );
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// append child object functions
	//////////////////////////////////////////////////////////////////////////////////////////

	HRESULT AppendAlloc ( CHILD* pObject )
	{
		if ( ! pObject )
			return E_INVALIDARG;

		try
		{
			if ( ( m_pRequest ) && ( ( m_pRequest = (REQUEST*) _RA_realloc ( m_pRequest, m_pRequest->dwTotalLength + pObject->dwTotalLength ) ) != NULL ) )
			{
				::CopyMemory ( GetOffset ( m_pRequest->dwTotalLength ) , pObject, pObject->dwTotalLength );
				m_pRequest->dwTotalLength += pObject->dwTotalLength;
				m_pRequest->dwChildCount++;
				return S_OK;
			}
		}
		catch ( ... )
		{
			return E_FAIL;
		}

		return E_UNEXPECTED;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// operators
	//////////////////////////////////////////////////////////////////////////////////////////

	operator REQUEST*() const
	{
		return m_pRequest;
	}

	REQUEST* operator= ( REQUEST* p )
	{
		m_pRequest = p;
		return m_pRequest;
	}

	BOOL IsEmpty ()
	{
		return (m_pRequest) ? FALSE : TRUE;
	}

	// operators BOOL
	BOOL operator! () const
	{
		return ( m_pRequest == NULL );
	}

	BOOL operator== (REQUEST* p) const
	{
		return ( m_p == p );
	}

	private:

	//////////////////////////////////////////////////////////////////////////////////////////
	// private helpers
	//////////////////////////////////////////////////////////////////////////////////////////

	// create structure & fill data
	static REQUEST* CreateStructure ( LPWSTR lpwsz, DWORD dwID )
	{
		REQUEST* pRequest = NULL;

		try
		{
			DWORD dwNameLength	= ( ::lstrlenW( lpwsz ) + 1 ) * sizeof ( WCHAR );

			DWORD dwAlignName	= 0L;
			if ( dwNameLength % 8 )
			{
				dwAlignName = 8 - ( dwNameLength % 8 );
			}

			DWORD dwAlignStruct	= 0L;
			if ( sizeof ( REQUEST ) % 8 )
			{
				dwAlignStruct = 8 - ( sizeof ( REQUEST ) % 8 );
			}

			DWORD dwLength		=	dwAlignName + dwNameLength + 
									dwAlignStruct + sizeof ( REQUEST );

			if ( ( pRequest = (REQUEST*) malloc ( dwLength ) ) != NULL )
			{
				// fill memory with zeros
				::ZeroMemory ( pRequest, dwLength );

				// copy string into structure
				::CopyMemory ( &(pRequest->dwName), lpwsz, dwNameLength );

				pRequest->dwNameLength	= dwNameLength;
				pRequest->dwLength		= dwLength;
				pRequest->dwTotalLength	= dwLength;

				pRequest->dwID = dwID;
			}
		}
		catch ( ... )
		{
		}

		return pRequest;
	}

	static REQUEST* CreateStructure ( DWORD dwLastID )
	{
		REQUEST* pRequest = NULL;

		try
		{
			DWORD dwAlignStruct	= 0L;
			if ( sizeof ( REQUEST ) % 8 )
			{
				dwAlignStruct = 8 - ( sizeof ( REQUEST ) % 8 );
			}

			DWORD dwLength		= dwAlignStruct + sizeof ( REQUEST );

			if ( ( pRequest = (REQUEST*) malloc ( dwLength ) ) != NULL )
			{
				// fill memory with zeros
				::ZeroMemory ( pRequest, dwLength );

				pRequest->dwLength		= dwLength;
				pRequest->dwTotalLength	= dwLength;

				pRequest->dwLastID = dwLastID;
			}
		}
		catch ( ... )
		{
		}

		return pRequest;
	}

	// return pointer from offset
	LPVOID GetOffset ( DWORD dwOffset )
	{
		if ( m_pRequest )
		{
			return ( ( LPVOID ) ( reinterpret_cast<PBYTE>( m_pRequest ) + dwOffset ) );
		}
		
		return NULL;
	}

};

//////////////////////////////////////////////////////////////////////////////////////////////
// typedefs
//////////////////////////////////////////////////////////////////////////////////////////////

typedef	CPerformanceStructureManipulator<WMI_PERF_PROPERTY, WMI_PERF_OBJECT, WMI_PERF_PROPERTY>		__PROPERTY;
typedef	CPerformanceStructureManipulator<WMI_PERF_OBJECT, WMI_PERF_NAMESPACE, WMI_PERF_PROPERTY>	__OBJECT;
typedef	CPerformanceStructureManipulator<WMI_PERF_NAMESPACE, WMI_PERFORMANCE, WMI_PERF_OBJECT>		__NAMESPACE;
typedef	CPerformanceStructureManipulator<WMI_PERFORMANCE, WMI_PERFORMANCE, WMI_PERF_NAMESPACE>		__PERFORMANCE;

//////////////////////////////////////////////////////////////////////////////////////////////
// class for registry
//////////////////////////////////////////////////////////////////////////////////////////////

class CPerformanceRegistry
{
	DECLARE_NO_COPY ( CPerformanceRegistry );

	// variables
	PWMI_PERFORMANCE	m_pPerf;

	public:

	// construction & detruction
	CPerformanceRegistry( PWMI_PERFORMANCE pPerf );
	~CPerformanceRegistry();

	// methods

	HRESULT	GetObject		( DWORD dwIndex, PWMI_PERF_OBJECT* ppObject );
	HRESULT	GetObjectName	( DWORD dwIndex, LPWSTR* ppwsz );
};

#include <poppack.h>

#endif	__WMI_PERF_REG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_perf_data_ext.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_data_ext.h
//
//	Abstract:
//
//					extension data declaration
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_DATA_EXT__
#define	__WMI_PERF_DATA_EXT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

//////////////////////////////////////////////////////////////////////////////////////////////
// includes
//////////////////////////////////////////////////////////////////////////////////////////////
#include "refresherUtils.h"

//////////////////////////////////////////////////////////////////////////////////////////////
// variables
//////////////////////////////////////////////////////////////////////////////////////////////

extern LPCWSTR g_szKeyCounter;

#ifndef	__COMMON__
#include "__common.h"
#endif	__COMMON__

//////////////////////////////////////////////////////////////////////////////////////////////
// classes
//////////////////////////////////////////////////////////////////////////////////////////////
class WmiPerformanceDataExt
{
	DECLARE_NO_COPY ( WmiPerformanceDataExt );

	public:

	DWORD	m_dwFirstCounter;
	DWORD	m_dwFirstHelp;
	DWORD	m_dwLastCounter;
	DWORD	m_dwLastHelp;

	DWORD*	m_Ord2Ind;

	DWORD	m_dwCount;

	// construction
	WmiPerformanceDataExt () :
		m_dwFirstCounter ( 0 ),
		m_dwFirstHelp ( 0 ),
		m_dwLastCounter ( 0 ),
		m_dwLastHelp ( 0 ),

		m_Ord2Ind ( NULL ),

		m_dwCount ( 0 )

	{
	}

	// destruction
	virtual ~WmiPerformanceDataExt ()
	{
		OrdersClear();
	}

	HRESULT	OrdersAlloc ( DWORD dwSize )
	{
		HRESULT hr = S_FALSE;

		if ( dwSize )
		{
			// clear before use
			OrdersClear();

			if ( ( m_Ord2Ind = new DWORD [ dwSize ] ) != NULL )
			{
				hr = S_OK;
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}

		return hr;
	}

	void	OrdersClear ( void )
	{
		if ( m_Ord2Ind )
		{
			delete [] m_Ord2Ind;
			m_Ord2Ind = NULL;
		}
	}

	///////////////////////////////////////////////////////////////////////////
	// refresher ( GENERATED NEW STUFF )
	///////////////////////////////////////////////////////////////////////////

	void Generate ( void );
	BOOL IsValidGenerate ( void );
};

#endif	__WMI_PERF_DATA_EXT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_perf_regstruct.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_regstruct.h
//
//	Abstract:
//
//					decalration of usefull registry structures and accessors
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_REGSTRUCT__
#define	__WMI_PERF_REGSTRUCT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

//////////////////////////////////////////////////////////////////////////////////////////////
// structures
//////////////////////////////////////////////////////////////////////////////////////////////

#include <pshpack8.h>

typedef struct _WMI_PERFORMANCE {
	DWORD	dwTotalLength;		// total length
	DWORD	dwChildCount;		// count of namespaces for performance
	DWORD	dwLastID;			// index of last namespace in performance
	DWORD	dwLength;			// length of structure
} WMI_PERFORMANCE;

typedef struct _WMI_PERF_NAMESPACE {
	DWORD	dwTotalLength;	// total length
	DWORD	dwChildCount;	// count of objects for namespace
	DWORD	dwLastID;		// index of last object in namespace
	DWORD	dwParentID;		// parent's structure index
	DWORD	dwID;			// unique index
	DWORD	dwLength;		// length of structure
	DWORD	dwNameLength;	// length, in bytes, of the namespace name
	DWORD	dwName;			// offset of name from beginning to LPWSTR
} WMI_PERF_NAMESPACE;

typedef struct _WMI_PERF_OBJECT {
	DWORD	dwTotalLength;	// total length
	DWORD	dwChildCount;	// count of properties for object
	DWORD	dwLastID;		// index of last property in object
	DWORD	dwParentID;		// parent's structure index
	DWORD	dwID;			// unique index
	DWORD	dwSingleton;	// bool singleton

	// performance specific

	DWORD	dwDetailLevel;

	DWORD	dwLength;		// length of structure
	DWORD	dwNameLength;	// length, in bytes, of the object name
	DWORD	dwName;			// offset of name from beginning to LPWSTR
} WMI_PERF_OBJECT;

typedef struct _WMI_PERF_INSTANCE {
	DWORD	dwLength;		// length of the structure
	DWORD	dwNameLength;	// length, in bytes, of the instance name
	DWORD	dwName;			// offset of name from beginning to LPWSTR
} WMI_PERF_INSTANCE;

typedef struct _WMI_PERF_PROPERTY {
	DWORD	dwTotalLength;	// total length
	DWORD	dwParentID;		// parent's structure index
	DWORD	dwID;			// unique index
	DWORD	dwTYPE;			// type of property

	// perf specific data

	DWORD	dwDefaultScale;
	DWORD	dwDetailLevel;
	DWORD	dwCounterType;

	DWORD	dwLength;		// length of structure
	DWORD	dwNameLength;	// length, in bytes, of the instance name
	DWORD	dwName;			// offset of name from beginning to LPWSTR
} WMI_PERF_PROPERTY;


//////////////////////////////////////////////////////////////////////////////////////////////
// typedefs
//////////////////////////////////////////////////////////////////////////////////////////////

typedef	WMI_PERFORMANCE*	PWMI_PERFORMANCE;
typedef	WMI_PERF_NAMESPACE*	PWMI_PERF_NAMESPACE;
typedef	WMI_PERF_OBJECT*	PWMI_PERF_OBJECT;
typedef	WMI_PERF_INSTANCE*	PWMI_PERF_INSTANCE;
typedef	WMI_PERF_PROPERTY*	PWMI_PERF_PROPERTY;

//////////////////////////////////////////////////////////////////////////////////////////////
// class for manipulation with structures
//////////////////////////////////////////////////////////////////////////////////////////////

template < class REQUEST, class PARENT, class CHILD >
class __Manipulator
{
	__Manipulator(__Manipulator&)					{}
	__Manipulator& operator=(const __Manipulator&)	{}

	public:

	// construction & detruction
	__Manipulator()		{}
	~__Manipulator()	{}

	// methods

	//////////////////////////////////////////////////////////////////////////////////////////
	// accessors
	//////////////////////////////////////////////////////////////////////////////////////////

	inline static REQUEST First ( PARENT pParent )
	{
		if ( pParent->dwChildCount )
		{
			return ( (REQUEST) ( reinterpret_cast<PBYTE>( pParent ) + pParent->dwLength ) );
		}
		else
		{
			return NULL;
		}
	}

	inline static REQUEST Next ( REQUEST pRequest )
	{
		return ( (REQUEST) ( reinterpret_cast<PBYTE>( pRequest ) + pRequest->dwTotalLength ) );
	}

	// looking function
	inline static REQUEST Get ( PARENT pParent, DWORD dwIndex )
	{
		if ( ! pParent || ( pParent->dwLastID < dwIndex ) )
		{
			return NULL;
		}

		// obtain correct namespace
		REQUEST pRequest = First ( pParent );

		if ( pRequest )
		{
			while ( pRequest->dwID < dwIndex )
			{
				pRequest = Next ( pRequest );
			}

			if ( pRequest->dwID == dwIndex )
			{
				return pRequest;
			}
		}

		// not found
		return NULL;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// names
	//////////////////////////////////////////////////////////////////////////////////////////

	// name functions
	inline static LPWSTR GetName ( REQUEST pRequest )
	{
		return reinterpret_cast<LPWSTR> (&(pRequest->dwName));
	}
};

typedef __Manipulator< PWMI_PERF_PROPERTY, PWMI_PERF_OBJECT, PWMI_PERF_PROPERTY >	__Property;
typedef __Manipulator< PWMI_PERF_OBJECT, PWMI_PERF_NAMESPACE, PWMI_PERF_PROPERTY >	__Object;
typedef __Manipulator< PWMI_PERF_NAMESPACE, PWMI_PERFORMANCE, PWMI_PERF_OBJECT >	__Namespace;

inline DWORD __TotalLength ( PWMI_PERF_PROPERTY pProperty )
{
	if (pProperty)
	return pProperty->dwLength;
	else
	return NULL;
}

inline DWORD __TotalLength ( PWMI_PERF_INSTANCE pInst )
{
	if (pInst)
	return pInst->dwLength;
	else
	return NULL;
}

inline DWORD __TotalLength ( PWMI_PERF_OBJECT pObject )
{
	if (pObject)
	{
		if ( pObject->dwChildCount )
		{
			PWMI_PERF_PROPERTY	pProperty	= __Property::First ( pObject );

			if ( pProperty )
			{
				DWORD			length		= pProperty->dwTotalLength;

				for ( DWORD i = 1; i < pObject->dwChildCount; i++ )
				{
					pProperty = __Property::Next ( pProperty );
					length	 += pProperty->dwTotalLength;
				}

				return length + pObject->dwLength;
			}
			else
			{
				return pObject->dwLength;
			}
		}
		else
		{
			return pObject->dwLength;
		}
	}
	else
	return NULL;
}

inline DWORD __TotalLength ( PWMI_PERF_NAMESPACE pNamespace )
{
	if (pNamespace)
	{
		if ( pNamespace->dwChildCount )
		{
			PWMI_PERF_OBJECT	pObject	= __Object::First ( pNamespace );

			if ( pObject )
			{
				DWORD			length		= pObject->dwTotalLength;

				for ( DWORD i = 1; i < pNamespace->dwChildCount; i++ )
				{
					pObject  = __Object::Next ( pObject );
					length	+= pObject->dwTotalLength;
				}

				return length + pNamespace->dwLength;
			}
			else
			{
				return pNamespace->dwLength;
			}
		}
		else
		{
			return pNamespace->dwLength;
		}
	}
	else
	{
		return NULL;
	}
}

inline DWORD __TotalLength ( PWMI_PERFORMANCE pPerf )
{
	if (pPerf)
	{
		if ( pPerf->dwChildCount )
		{
			PWMI_PERF_NAMESPACE	pNamespace	= __Namespace::First ( pPerf );

			if ( pNamespace )
			{
				DWORD			length		= pNamespace->dwTotalLength;

				for ( DWORD i = 1; i < pPerf->dwChildCount; i++ )
				{
					pNamespace = __Namespace::Next ( pNamespace );
					length	 += pNamespace->dwTotalLength;
				}

				return length + pPerf->dwLength;
			}
			else
			{
				return pPerf->dwLength;
			}
		}
		else
		{
			return pPerf->dwLength;
		}
	}
	else
	{
		return NULL;
	}
}

#include <poppack.h>

#endif	__WMI_PERF_REGSTRUCT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_perf_struct.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_struct.h
//
//	Abstract:
//
//					definitions of usefull accessors of perf structures
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_STRUCT__
#define	__WMI_PERF_STRUCT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

//////////////////////////////////////////////////////////////////////////////////////////////
// structures
//////////////////////////////////////////////////////////////////////////////////////////////

#include <WinPerf.h>
#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////////////////////
// ACCESSORS
//////////////////////////////////////////////////////////////////////////////////////////////

inline PPERF_OBJECT_TYPE FirstObject( PPERF_DATA_BLOCK PerfData )
{
	return( (PPERF_OBJECT_TYPE)((PBYTE)PerfData + PerfData->HeaderLength) );
}

inline PPERF_OBJECT_TYPE NextObject( PPERF_OBJECT_TYPE PerfObj )
{
	return( (PPERF_OBJECT_TYPE)((PBYTE)PerfObj + PerfObj->TotalByteLength) );
}

inline PPERF_INSTANCE_DEFINITION FirstInstance( PPERF_OBJECT_TYPE PerfObj )
{
	return( (PPERF_INSTANCE_DEFINITION)((PBYTE)PerfObj + PerfObj->DefinitionLength) );
}

inline PPERF_INSTANCE_DEFINITION NextInstance( PPERF_INSTANCE_DEFINITION PerfInst )
{
	PPERF_COUNTER_BLOCK PerfCntrBlk;
	PerfCntrBlk = (PPERF_COUNTER_BLOCK)((PBYTE)PerfInst + PerfInst->ByteLength);

	return( (PPERF_INSTANCE_DEFINITION)((PBYTE)PerfCntrBlk + PerfCntrBlk->ByteLength) );
}

inline PPERF_COUNTER_DEFINITION FirstCounter( PPERF_OBJECT_TYPE PerfObj )
{
	return( (PPERF_COUNTER_DEFINITION) ((PBYTE)PerfObj + PerfObj->HeaderLength) );
}

inline PPERF_COUNTER_DEFINITION NextCounter( PPERF_COUNTER_DEFINITION PerfCntr )
{
	return( (PPERF_COUNTER_DEFINITION)((PBYTE)PerfCntr + PerfCntr->ByteLength) );
}

#include <poppack.h>

#endif	__WMI_PERF_STRUCT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_reverse_guard.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_reverse_guard.h
//
//	Abstract:
//
//					guard critical section ( named ... uses named semaphores )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REVERSE_GUARD_H__
#define	__REVERSE_GUARD_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// security attributes
#ifndef	__WMI_SECURITY_ATTRIBUTES_H__
#include "WMI_security_attributes.h"
#endif	__WMI_SECURITY_ATTRIBUTES_H__

class WmiReverseGuard
{
	DECLARE_NO_COPY ( WmiReverseGuard );

	HANDLE	m_ReaderSemaphore ;
	LONG			m_ReaderSize ;

	HANDLE	m_WriterSemaphore ;
	LONG			m_WriterSize ;

	bool bInit;

	public:

	// construction & destruction
	WmiReverseGuard (	BOOL bNamed,
						const LONG &a_ReaderSize,
						const LONG &a_WriterSize = 1,
						LPSECURITY_ATTRIBUTES psa = NULL ) :

	m_ReaderSize ( a_ReaderSize ),
	m_WriterSize ( a_WriterSize ),

	m_ReaderSemaphore ( NULL ),
	m_WriterSemaphore ( NULL ),

	bInit ( false )
	{
		try
		{
			m_ReaderSemaphore = CreateSemaphore ( m_ReaderSize, bNamed, TRUE, psa );
			m_WriterSemaphore = CreateSemaphore ( m_WriterSize, bNamed, FALSE, psa );
		}
		catch ( ... )
		{
			m_ReaderSemaphore = NULL;
			m_WriterSemaphore = NULL;
		}

		if ( m_ReaderSemaphore && m_WriterSemaphore )
		{
			bInit = true;
		}
	}

	virtual ~WmiReverseGuard ()
	{
		if ( m_ReaderSemaphore ) 
		{
			::CloseHandle ( m_ReaderSemaphore );
			m_ReaderSemaphore = NULL ;
		}
		if ( m_WriterSemaphore ) 
		{
			::CloseHandle ( m_WriterSemaphore );
			m_WriterSemaphore = NULL ;
		}
	}

	// functions

	virtual HRESULT	EnterRead ( const LONG &a_Timeout = INFINITE ) ;
	virtual HRESULT	EnterWrite ( const LONG &a_Timeout = INFINITE ) ;

	virtual HRESULT	LeaveRead () ;
	virtual HRESULT	LeaveWrite () ;

	private:

	HANDLE	CreateSemaphore (	LONG lSize,
								BOOL bNamed,
								BOOL bReader,
								LPSECURITY_ATTRIBUTES psa = NULL	)
	{
		HANDLE hResult = NULL;

		if ( !bNamed )
		{
			hResult = ::CreateSemaphoreW ( psa , lSize, lSize, NULL );
		}
		else
		{
			if ( bReader )
			{
				hResult =::CreateSemaphoreW	( psa, lSize, lSize, L"Global\\MEMORYGuard_Reader" );
			}
			else
			{
				hResult =::CreateSemaphoreW	( psa, lSize, lSize, L"Global\\MEMORYGuard_Writter" );
			}
		}

		return hResult;
	}
};

#endif	__REVERSE_GUARD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_reverse_memory.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000 - 2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_reverse_memory.h
//
//	Abstract:
//
//					shared memory wrapper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REVERSE_MEMORY_H__
#define	__REVERSE_MEMORY_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// security attributes
#ifndef	__WMI_SECURITY_ATTRIBUTES_H__
#include "WMI_security_attributes.h"
#endif	__WMI_SECURITY_ATTRIBUTES_H__

///////////////////////////////////////////////////////////////////////////////
//
//	structure of memory
//
//	dwCount of MMF			... not yet
//	dwSize of MMF
//
//	dwSizeOfTable			... jumps to raw data
//	dwCountOfObjects
//	dwRealSize
//
//	---------------------------------------------
//
//	dwIndex
//	dwCounter				... object 1
//	dwOffset
//	dwValidity
//
//	---------------------------------------------
//	---------------------------------------------
//
//	dwIndex
//	dwCounter				... object 2
//	dwOffset
//	dwValidity
//
//	---------------------------------------------
//
//	raw data ( perf_object_types )
//
///////////////////////////////////////////////////////////////////////////////

#define	offsetCountMMF		0
#define	offsetSizeMMF		offsetCountMMF + sizeof ( DWORD )

#define	offsetSize1		offsetSizeMMF + sizeof ( DWORD )
#define	offsetCount1	offsetSize1 + sizeof ( DWORD )
#define	offsetRealSize1	offsetCount1 + sizeof ( DWORD )
#define	offsetObject1	offsetRealSize1 + sizeof ( DWORD )

#define	offIndex1		0
#define	offCounter1		offIndex1 + sizeof ( DWORD )
#define	offOffset1		offCounter1 + sizeof ( DWORD )
#define	offValidity1	offOffset1 + sizeof ( DWORD )

#define	ObjectSize1		4 * sizeof ( DWORD )

template < class _DUMMY >
class WmiReverseMemory
{
	DECLARE_NO_COPY ( WmiReverseMemory );

	protected:

	LONG	m_lCount;

	DWORD	m_dwSize;

	HANDLE	m_hMap;
	void*	m_pMem;

	HRESULT m_LastError;

	public:

	/////////////////////////////////////////////////////////////////////////////////////
	//	LAST ERROR HELPER
	/////////////////////////////////////////////////////////////////////////////////////

	HRESULT GetLastError ( void )
	{
		HRESULT hr = S_OK;

		hr			= m_LastError;
		m_LastError = S_OK;

		return hr;
	}

	// construction

	WmiReverseMemory ( LPCWSTR wszName, DWORD dwSize = 4096, LPSECURITY_ATTRIBUTES psa = NULL ):
		m_hMap ( NULL ),
		m_pMem ( NULL ),
		m_dwSize ( 0 ),
		m_lCount ( 0 ),

		m_LastError ( S_OK )
	{
		try
		{
			MemCreate ( wszName, dwSize, psa );
		}
		catch ( ... )
		{
		}
	}

	virtual ~WmiReverseMemory ()
	{
		if ( m_pMem )
		{
			// flush memory at the end
			::FlushViewOfFile ( m_pMem, m_dwSize );
		}

		try
		{
			MemDelete ();
		}
		catch ( ... )
		{
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//	VALIDITY
	/////////////////////////////////////////////////////////////////////////////////////

	BOOL IsValid ( void )
	{
		return ( m_pMem != NULL );
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//	ACCESSORS
	/////////////////////////////////////////////////////////////////////////////////////

	// get data
	PVOID	GetData () const
	{
		return m_pMem;
	}

	// get data size
	DWORD	GetDataSize () const
	{
		return m_dwSize;
	}

	void	SetDataSize ( DWORD size )
	{
		m_dwSize = size;
	}

	// functions
	virtual BOOL Write (LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset);
	virtual BOOL Read (LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset);

	virtual PBYTE Find ( PBYTE pbSearchBytes, DWORD dwSearchBytes )
	{
		___ASSERT(m_hMap != NULL);
		___ASSERT(m_pMem != NULL);

		if ( dwSearchBytes > m_dwSize )
		{
			// what are you looking for looser :))
			return NULL;
		}
		else
		{
			for ( DWORD n = 0; n < ( m_dwSize - dwSearchBytes ); n++ )
			{
				if ( static_cast<PBYTE>( m_pMem )[n] == pbSearchBytes[0] )
				{
					for (DWORD x = 1; x < dwSearchBytes; x++)
					{
						if ( static_cast<PBYTE>( m_pMem )[n + x] != pbSearchBytes[x] ) 
						{
							break; // Not a match
						}
					}

					if (x == dwSearchBytes)
					{
						return static_cast <PBYTE> ( &( static_cast<PBYTE>( m_pMem )[n] ) );
					}
				}
			}
		}

		return(NULL);
	}

	// helpers
	HRESULT MemCreate ( LPCWSTR wszName, DWORD dwSize, LPSECURITY_ATTRIBUTES psa );
	HRESULT MemDelete ();

	LONG	References ( void );

	private:
	NTSTATUS MyQuerySecurityObject ( DWORD dwFlag, PSECURITY_DESCRIPTOR psd ) ;
};

// create shared memory
template < class _DUMMY >
HRESULT WmiReverseMemory < _DUMMY > ::MemCreate ( LPCWSTR wszName, DWORD dwSize, LPSECURITY_ATTRIBUTES psa )
{
	if ( ( m_hMap = ::CreateFileMappingW (	INVALID_HANDLE_VALUE,
											psa,
											PAGE_READWRITE,
											0,
											dwSize,
											wszName
										 ) )

										!= NULL )
	{
		bool bContinue = false;
		bool bInit = false;
		bInit = ( ::GetLastError() == ERROR_ALREADY_EXISTS );

		//
		// this means it was created already
		// need to take a look if it was created
		// only by allowed users
		//
		if ( bInit )
		{
			NTSTATUS Status = 0 ;
			Status = MyQuerySecurityObject	(	OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
												psa->lpSecurityDescriptor
											) ;

			if ( NT_SUCCESS ( Status ) )
			{
				bContinue = true ;
			}
		}
		else
		{
			bContinue = true ;
		}

		if ( bContinue )
		{
			if ( ( m_pMem = ::MapViewOfFile ( m_hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0 ) ) != NULL )
			{
				if ( !bInit )
				{
					::memset ( m_pMem, 0, dwSize );
					// store real size :))
					* reinterpret_cast<PDWORD> ( (LPBYTE) m_pMem + offsetSizeMMF ) = dwSize;

					// cache size :))
					m_dwSize = dwSize;
				}
				else
				{
					// get real size from MMF
					m_dwSize = * reinterpret_cast<PDWORD> ( (LPBYTE) m_pMem + offsetSizeMMF );
				}

				::InterlockedIncrement ( &m_lCount );
			}
			else
			{
				::CloseHandle ( m_hMap );
				m_hMap = NULL;

				m_LastError = HRESULT_FROM_WIN32 ( ::GetLastError () );
			}
		}
		else
		{
			::CloseHandle ( m_hMap );
			m_hMap = NULL;

			m_LastError = HRESULT_FROM_WIN32 ( ERROR_ALREADY_EXISTS );
		}
	}
	else
	{
		m_LastError = HRESULT_FROM_WIN32 ( ::GetLastError () );
	}

	return m_LastError;
}

// delete shared memory
template < class _DUMMY >
HRESULT WmiReverseMemory < _DUMMY > ::MemDelete ()
{
	if ( m_lCount && ::InterlockedDecrement ( &m_lCount ) == 0 )
	{
		if ( m_pMem )
		{
			::UnmapViewOfFile ( m_pMem );
			m_pMem = NULL;
		}

		if ( m_hMap )
		{
			::CloseHandle ( m_hMap );
			m_hMap = NULL;
		}

		return S_OK;
	}

	m_LastError = S_FALSE;
	return m_LastError;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// write into memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class _DUMMY >
BOOL WmiReverseMemory < _DUMMY > ::Write (LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset )
{
	___ASSERT(m_hMap != NULL);
	___ASSERT(m_pMem != NULL);

	if ( dwOffset > m_dwSize )
	{
		if ( pdwBytesWritten )
		{
			*pdwBytesWritten = 0;
		}

		m_LastError = E_INVALIDARG;
		return FALSE;
	}

	DWORD dwCount = min ( dwBytesToWrite, m_dwSize - dwOffset );
	::CopyMemory ((LPBYTE) m_pMem + dwOffset, pBuffer, dwCount);

	if (pdwBytesWritten != NULL)
	{
		*pdwBytesWritten = dwCount;
	}

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// read from memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class _DUMMY >
BOOL WmiReverseMemory < _DUMMY > ::Read (LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset )
{
	___ASSERT (m_hMap != NULL);
	___ASSERT (m_pMem != NULL);

	if (dwOffset > m_dwSize)
	{
		if ( pdwBytesRead )
		{
			*pdwBytesRead = 0;
		}

		m_LastError = E_INVALIDARG;
		return FALSE;
	}

	DWORD dwCount = min (dwBytesToRead, m_dwSize - dwOffset);
	::CopyMemory (pBuffer, (LPBYTE) m_pMem + dwOffset, dwCount);

	if (pdwBytesRead != NULL)
	{
		*pdwBytesRead = dwCount;
	}

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// undocumented kernel stuff for having number of object here
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class CRITSEC >
LONG WmiReverseMemory < CRITSEC > :: References ( void )
{
	LONG				lResult = -1;
	
	if ( m_hMap )
	{
		NTSTATUS Status = 0;
		OBJECT_BASIC_INFORMATION	BasicInfo;

		Status = NtQueryObject	(	m_hMap,
									ObjectBasicInformation,
									(PVOID)&BasicInfo,
									sizeof(BasicInfo),
									NULL
								);

		if ( NT_SUCCESS ( Status ) )
		{
			lResult = static_cast < LONG > ( BasicInfo.HandleCount );
		}
	}

	return lResult;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// undocumented kernel stuff for having shared memory security descriptor recognized
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class CRITSEC >
NTSTATUS WmiReverseMemory < CRITSEC > :: MyQuerySecurityObject ( DWORD dwFlag, PSECURITY_DESCRIPTOR psd )
{
	NTSTATUS                status	= STATUS_UNSUCCESSFUL ;
	ULONG                   sdLength = 0L ;
	PSECURITY_DESCRIPTOR    sd = NULL ;
	if ( m_hMap )
	{
		status = NtQuerySecurityObject	(
											m_hMap,
											dwFlag,
											NULL,
											0,
											&sdLength
										);
		if (status == STATUS_BUFFER_TOO_SMALL)
		{
			sd = static_cast < PSECURITY_DESCRIPTOR > ( new BYTE [ sdLength ] ) ;
			if ( NULL != sd )
			{
				status = NtQuerySecurityObject	(
													m_hMap,
													dwFlag,
													sd,
													sdLength,
													&sdLength
												);
				if (NT_SUCCESS(status))
				{
					PSID                    sid = NULL ;
					PSID                    sid1 = NULL ;
					BOOLEAN		ownerDefaulted = FALSE ;
					BOOLEAN		ownerDefaulted1 = FALSE ;

					status = RtlGetOwnerSecurityDescriptor(sd, &sid, &ownerDefaulted);
					if (NT_SUCCESS(status))
					{
						status = RtlGetOwnerSecurityDescriptor(psd, &sid1, &ownerDefaulted1);
						if (NT_SUCCESS(status))
						{
							//
							// owner sid compare
							//

							if (RtlEqualSid(sid, sid1))
							{
								PACL                    acl = NULL ;
								PACL                    acl1 = NULL ;

								BOOLEAN		daclDefaulted = FALSE ;
								BOOLEAN		daclPresent = FALSE ;
								BOOLEAN		daclDefaulted1 = FALSE ;
								BOOLEAN		daclPresent1 = FALSE ;

								status = RtlGetDaclSecurityDescriptor(sd, &daclPresent, &acl, &daclDefaulted);
								if (NT_SUCCESS(status))
								{
									//
									// this security descriptor is given to us
									// from shared memory we may not create originaly
									// so we need to make sure dacl is present here
									//

									if ( daclPresent && acl )
									{
										status = RtlGetDaclSecurityDescriptor(psd, &daclPresent1, &acl1, &daclDefaulted1);
										if (NT_SUCCESS(status))
										{
											//
											// compare DACL's
											//

											if ( acl->AceCount == acl1->AceCount )
											{
												PACCESS_ALLOWED_ACE	ace = NULL ;
												PACCESS_ALLOWED_ACE	ace1 = NULL ;

												for ( DWORD dw = 0; dw < acl->AceCount && NT_SUCCESS ( status ); dw++ )
												{
													status = RtlGetAce(acl, dw, reinterpret_cast < PVOID*> ( &ace ) );
													if ( NT_SUCCESS ( status ) )
													{
														status = RtlGetAce(acl1, dw, reinterpret_cast < PVOID*> ( &ace1 ) );
														if ( NT_SUCCESS ( status ) )
														{
															if ( ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE &&
																ace1->Header.AceType == ACCESS_ALLOWED_ACE_TYPE )
															{
																if ( ! RtlEqualSid((PSID) &ace->SidStart, (PSID) &ace1->SidStart) )
																{
																	status = STATUS_UNSUCCESSFUL ;
																}
															}
															else
															{
																status = STATUS_UNSUCCESSFUL ;
															}
														}
													}
												}
											}
											else
											{
												status = STATUS_UNSUCCESSFUL ;
											}
										}
									}
									else
									{
										status = STATUS_UNSUCCESSFUL ;
									}
								}
							}
							else
							{
								status = STATUS_UNSUCCESSFUL ;
							}
						}
					}
				}

				delete [] ( static_cast < BYTE*> ( sd ) ) ;
			}
			else
			{
				status = STATUS_NO_MEMORY ;
			}
		}
	}

	return status ;
}

#endif	__REVERSE_MEMORY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_reverse_memory_ext.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_reverse_memory_ext.h
//
//	Abstract:
//
//					shared memory extension
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REVERSE_MEMORY_EXT_H__
#define	__REVERSE_MEMORY_EXT_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// guard
#include "wmi_reverse_guard.h"

// performance
#ifndef	__WMI_PERF_STRUCT__
#include "wmi_perf_struct.h"
#endif	__WMI_PERF_STRUCT__

#ifndef	_WINPERF_
#include "winperf.h"
#endif	_WINPERF_

// shared memory
#include "wmi_reverse_memory.h"

///////////////////////////////////////////////////////////////////////////////
//	CRITGUARD 
//
//	requirements
//
//	constructor for object by name
//	enter ( read , write ) /leave ( read , write ) functions
//
///////////////////////////////////////////////////////////////////////////////

#include <pshpack8.h>

template < class CRITGUARD >
class WmiReverseMemoryExt : public WmiReverseMemory < void >
{
	DECLARE_NO_COPY ( WmiReverseMemoryExt );

	__WrapperPtr < CRITGUARD > m_pGUARD;

	public:

	// construction
	WmiReverseMemoryExt ( LPCWSTR wszName, DWORD dwSize = 4096, LPSECURITY_ATTRIBUTES psa = NULL ) : 
	WmiReverseMemory < void > ( wszName, dwSize, psa )
	{
		// create cross process guard
		try
		{
			m_pGUARD.SetData ( new CRITGUARD( TRUE, 100, 1, psa ) );
		}
		catch ( ... )
		{
			___ASSERT_DESC ( m_pGUARD != NULL, L"Constructor FAILED !" );
		}
	}

	virtual ~WmiReverseMemoryExt ()
	{
	}

	virtual BOOL Write (LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset);
	virtual BOOL Read (LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset);

	///////////////////////////////////////////////////////////////////////////
	// work w/ specified offset
	///////////////////////////////////////////////////////////////////////////

	DWORD	GetValue ( DWORD dwOffset )
	{
		DWORD dw = (DWORD) -1;
		Read ( &dw, sizeof ( DWORD ), 0, dwOffset );

		return dw;
	}

	void	SetValue ( DWORD dwValue, DWORD dwOffset )
	{
		Write ( &dwValue, sizeof ( DWORD ), 0, dwOffset );
	}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
// write into memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class CRITGUARD >
BOOL WmiReverseMemoryExt < CRITGUARD > ::Write (LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset)
{
	___ASSERT(m_hMap != NULL);
	___ASSERT(m_pMem != NULL);

	BOOL bResult = FALSE;

	if ( !m_pGUARD )
	{
		try
		{
			bResult = WmiReverseMemory < void > :: Write ( pBuffer, dwBytesToWrite, pdwBytesWritten, dwOffset );
		}
		catch ( ... )
		{
		}
	}
	else
	{
		m_pGUARD->EnterWrite ();
		try
		{
			bResult = WmiReverseMemory < void > :: Write ( pBuffer, dwBytesToWrite, pdwBytesWritten, dwOffset );
		}
		catch ( ... )
		{
		}
		m_pGUARD->LeaveWrite ();
	}

	return bResult;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// read from memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class CRITGUARD >
BOOL WmiReverseMemoryExt < CRITGUARD > ::Read (LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset)
{
	___ASSERT (m_hMap != NULL);
	___ASSERT (m_pMem != NULL);

	BOOL bResult = FALSE;

	if ( !m_pGUARD )
	{
		try
		{
			bResult = WmiReverseMemory < void > :: Read ( pBuffer, dwBytesToRead, pdwBytesRead, dwOffset);
		}
		catch ( ... )
		{
		}
	}
	else
	{
		m_pGUARD->EnterRead ();
		try
		{
			bResult = WmiReverseMemory < void > :: Read ( pBuffer, dwBytesToRead, pdwBytesRead, dwOffset);
		}
		catch ( ... )
		{
		}
		m_pGUARD->LeaveRead ();
	}

	return bResult;
}

#include <poppack.h>

#endif	__REVERSE_MEMORY_EXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_security_attributes.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_security_attributes.h
//
//	Abstract:
//
//					security attributtes wrapper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_SECURITY_ATTRIBUTES_H__
#define	__WMI_SECURITY_ATTRIBUTES_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifndef	__WMI_SECURITY_H__
#include "WMI_security.h"
#endif	__WMI_SECURITY_H__

class WmiSecurityAttributes
{
	DECLARE_NO_COPY ( WmiSecurityAttributes );

	// variables
	__WrapperPtr < SECURITY_ATTRIBUTES >	m_psa;
	__WrapperPtr < WmiSecurity >			m_psd;

	public:

	BOOL	m_bInitialized;

	// construction
	WmiSecurityAttributes ( BOOL bInherit = FALSE ) :
	m_bInitialized ( FALSE )
	{
		BOOL bInit  = FALSE;
		BOOL bAlloc	= FALSE;

		try
		{
			m_psa.SetData ( new SECURITY_ATTRIBUTES() );
			if ( ! m_psa.IsEmpty() )
			{
				bAlloc = TRUE;

				m_psd.SetData ( new WmiSecurity() );
				if ( ! m_psd.IsEmpty() )
				{
					if ( m_psd->Get () )
					{
						// init security attributes
						m_psa->nLength				= sizeof ( SECURITY_ATTRIBUTES );
						m_psa->lpSecurityDescriptor = m_psd->Get ();
						m_psa->bInheritHandle		= bInherit;

						bInit = TRUE;
					}
				}
			}
		}
		catch ( ... )
		{
		}

		if ( bAlloc && !bInit )
		{
			SECURITY_ATTRIBUTES* atr = NULL;
			atr = m_psa.Detach ();

			if ( atr )
			{
				delete atr;
				atr = NULL;
			}

			WmiSecurity* sec = NULL;
			sec = m_psd.Detach ();

			if ( sec )
			{
				delete sec;
				sec = NULL;
			}
		}

		m_bInitialized = bInit;
	}

	// destruction
	~WmiSecurityAttributes ()
	{
		// direct delete ( not neccessary )
		delete m_psd.Detach();
		delete m_psa.Detach();
	}

	// operator
	operator PSECURITY_ATTRIBUTES()
	{
		return GetSecurityAttributtes();
	}

	PSECURITY_ATTRIBUTES GetSecurityAttributtes()
	{
		return ( m_psa.IsEmpty() ) ? NULL : (PSECURITY_ATTRIBUTES) m_psa;
	}

	PSECURITY_DESCRIPTOR GetSecurityDescriptor()
	{
		return ( m_psd.IsEmpty() ) ? NULL : (PSECURITY_DESCRIPTOR) m_psd->Get();
	}

	PSECURITY_DESCRIPTOR GetAbsoluteSecurityDescriptor()
	{
		return ( m_psd.IsEmpty() ) ? NULL : (PSECURITY_DESCRIPTOR) m_psd->GetAbsolute();
	}
};

#endif	__WMI_SECURITY_ATTRIBUTES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_security.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_security.h
//
//	Abstract:
//
//					security wrapper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_SECURITY_H__
#define	__WMI_SECURITY_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#include <sddl.h>

class WmiSecurity
{
	DECLARE_NO_COPY ( WmiSecurity );

	public:

	// variables
	PSECURITY_DESCRIPTOR m_psd;
	PSECURITY_DESCRIPTOR m_AbsolutePsd;

	private:

	PACL  m_Absolute_Dacl ;
	PACL  m_Absolute_Sacl ;
	PSID  m_Absolute_Owner ;
	PSID  m_Absolute_PrimaryGroup ;

	public:

	// construction
	WmiSecurity ():
		m_psd ( NULL ) ,
		m_AbsolutePsd ( NULL ) ,
		m_Absolute_Dacl ( NULL ) ,
		m_Absolute_Sacl ( NULL ) ,
		m_Absolute_Owner ( NULL ) ,
		m_Absolute_PrimaryGroup ( NULL )
	{
		BOOL bInit = FALSE;

		try
		{
			if ( SUCCEEDED ( Initialize ( L"O:BAG:BAD:(A;NP;GA;;;BA)(A;NP;GA;;;LA)(A;NP;GA;;;SY)", &m_psd ) ) )
			{
				bInit = TRUE;

				PSECURITY_DESCRIPTOR psd = NULL;
				if ( SUCCEEDED ( Initialize ( L"O:BAG:BAD:(A;NP;GA;;;BA)(A;NP;GA;;;LA)(A;NP;GA;;;SY)(A;NP;GA;;;NS)(A;NP;GA;;;LS)", &psd ) ) )
				{
					if ( FAILED ( MakeAbsolute ( psd, &m_AbsolutePsd ) ) )
					{
						DestructAbsoluteSD ( m_AbsolutePsd );
					}

					LocalFree ( psd );
				}
			}
		}
		catch ( ... )
		{
		}

		if ( !bInit )
		{
			if ( m_psd )
			{
				LocalFree ( m_psd ) ;
				m_psd = NULL;
			}
		}
	}

	// destruction
	~WmiSecurity ()
	{
		if ( m_psd )
		{
			LocalFree ( m_psd ) ;
		}

		DestructAbsoluteSD ( m_AbsolutePsd );
	}

	// operator

	PSECURITY_DESCRIPTOR Get() const
	{
		return m_psd;
	}

	PSECURITY_DESCRIPTOR GetAbsolute() const
	{
		return m_AbsolutePsd;
	}

	private:

	HRESULT Initialize ( LPCWSTR wszSDDL, PSECURITY_DESCRIPTOR* ppsd )
	{
		HRESULT t_Result = S_OK ;

		if ( !ppsd || *ppsd )
		{
			t_Result = E_UNEXPECTED ;
		}
		else
		{
			BOOL t_Status = ConvertStringSecurityDescriptorToSecurityDescriptor (

				wszSDDL ,
				SDDL_REVISION_1 ,
				( PSECURITY_DESCRIPTOR * ) ppsd ,
				NULL 
			) ;

			if ( t_Status )
			{
			}
			else
			{
				t_Result = E_FAIL ;
			}
		}

		return t_Result ;
	}

	HRESULT MakeAbsolute ( PSECURITY_DESCRIPTOR psd, PSECURITY_DESCRIPTOR* ppsd )
	{
		HRESULT t_Result = S_OK ;

		if ( !psd || !ppsd || *ppsd )
		{
			t_Result = E_UNEXPECTED ;
		}
		else
		{
			DWORD t_DaclSize = 0 ;
			DWORD t_SaclSize = 0 ;
			DWORD t_OwnerSize = 0 ;
			DWORD t_PrimaryGroupSize = 0 ;
			DWORD t_SecurityDescriptorSize = 0 ;

			BOOL t_Status = MakeAbsoluteSD (

				psd ,
				*ppsd ,
				& t_SecurityDescriptorSize ,
				m_Absolute_Dacl,
				& t_DaclSize,
				m_Absolute_Sacl,
				& t_SaclSize,
				m_Absolute_Owner,
				& t_OwnerSize,
				m_Absolute_PrimaryGroup,
				& t_PrimaryGroupSize
			) ;

			if ( ( t_Status == FALSE ) && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
			{
				m_Absolute_Dacl = ( PACL ) new BYTE [ t_DaclSize ] ;
				m_Absolute_Sacl = ( PACL ) new BYTE [ t_SaclSize ] ;
				m_Absolute_Owner = ( PSID ) new BYTE [ t_OwnerSize ] ;
				m_Absolute_PrimaryGroup = ( PSID ) new BYTE [ t_PrimaryGroupSize ] ;

				*ppsd = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_SecurityDescriptorSize ] ;

				if ( *ppsd && m_Absolute_Dacl && m_Absolute_Sacl && m_Absolute_Owner && m_Absolute_PrimaryGroup )
				{
					t_Status = InitializeSecurityDescriptor ( *ppsd , SECURITY_DESCRIPTOR_REVISION ) ;
					if ( t_Status )
					{
						t_Status = MakeAbsoluteSD (

							psd ,
							*ppsd ,
							& t_SecurityDescriptorSize ,
							m_Absolute_Dacl,
							& t_DaclSize,
							m_Absolute_Sacl,
							& t_SaclSize,
							m_Absolute_Owner,
							& t_OwnerSize,
							m_Absolute_PrimaryGroup,
							& t_PrimaryGroupSize
						) ;

						if ( ! t_Status )
						{
							t_Result = E_FAIL ;
						}
					}
					else
					{
						t_Result = E_FAIL ;
					}
				}
				else
				{
					t_Result = E_OUTOFMEMORY ;
				}
			}
			else
			{
				if ( ERROR_SUCCESS != GetLastError () )
				{
					t_Result = E_FAIL ;
				}
			}
		}

		return t_Result ;
	}

	void DestructAbsoluteSD ( PSECURITY_DESCRIPTOR psd )
	{
		if (  m_Absolute_Dacl )
		{
			delete [] ( BYTE * )  m_Absolute_Dacl ;
				m_Absolute_Dacl = NULL ;
		}

		if (  m_Absolute_Sacl )
		{
			delete [] ( BYTE * )  m_Absolute_Sacl ;
				m_Absolute_Sacl = NULL ;
		}

		if (  m_Absolute_Owner )
		{
			delete [] ( BYTE * )  m_Absolute_Owner ;
				m_Absolute_Owner = NULL ;
		}

		if (  m_Absolute_PrimaryGroup )
		{
			delete [] ( BYTE * )  m_Absolute_PrimaryGroup ;
				m_Absolute_PrimaryGroup = NULL ;
		}

		if ( m_AbsolutePsd )
		{
			delete [] ( BYTE * ) m_AbsolutePsd ;
			m_AbsolutePsd = NULL ;
		}
	}
};

#endif	__WMI_SECURITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__common_convert.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__Common_Convert.h
//
//	Abstract:
//
//					convertion routines used anywhere
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// CommonConvert ///////////////////////////////////

#ifndef	__COMMON_CONVERT__
#define	__COMMON_CONVERT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

//////////////////////////////////////////////////////////////////////////////////////////////
// class for string operations
//////////////////////////////////////////////////////////////////////////////////////////////

class __String
{
	__String ( __String& )					{}
	__String& operator= ( const __String& )	{}

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	__String ()
	{
	}

	~__String ()
	{
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	static void SetStringCopy ( LPWSTR& wszDest, LPCWSTR& wsz )
	{
		___ASSERT( wszDest == NULL );

		if ( wsz )
		{
			try
			{
				DWORD cchSize = lstrlenW ( wsz ) + 1;
				if ( ( wszDest = new WCHAR[ cchSize ] ) != NULL )
				{
					StringCchCopyW ( wszDest, cchSize, wsz );
				}
			}
			catch ( ... )
			{
				if ( wszDest )
				{
					delete wszDest;
					wszDest = NULL;
				}
			}
		}
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for string release
//////////////////////////////////////////////////////////////////////////////////////////////

class __Release
{
	__Release ( __Release& )					{}
	__Release& operator= ( const __Release& )	{}

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	__Release ()
	{
	}

	~__Release ()
	{
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	static HRESULT Release ( void** ppsz )
	{
		if ( ppsz && (*ppsz) )
		{
			delete [] (*ppsz);
			(*ppsz) = NULL;

			return S_OK;
		}

		return S_FALSE;
	}

	static HRESULT Release ( void*** ppsz, DWORD* dwsz )
	{
		if ( ppsz && (*ppsz) )
		{
			if ( dwsz )
			{
				for ( DWORD dwIndex = 0; dwIndex < (*dwsz); dwIndex++ )
				{
					delete (*ppsz)[dwIndex];
					(*ppsz)[dwIndex] = NULL;
				}

				(*dwsz) = NULL;
			}

			delete [] (*ppsz);
			(*ppsz) = NULL;

			return S_OK;
		}

		return S_FALSE;
	}

	static HRESULT Release ( SAFEARRAY* psa )
	{
		if ( psa )
		{
			::SafeArrayDestroy ( psa );
			psa = NULL;

			return S_OK;
		}

		return S_FALSE;
	}

};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for string converion handling
//////////////////////////////////////////////////////////////////////////////////////////////

class __StringConvert
{
	__StringConvert ( __StringConvert& )					{}
	__StringConvert& operator= ( const __StringConvert& )	{}

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	__StringConvert ()
	{
	}

	~__StringConvert ()
	{
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	// SAFEARRAY (BSTR) -> LPWSTR*
	inline static HRESULT ConvertSafeArrayToLPWSTRArray ( SAFEARRAY * psa, LPWSTR** pppsz, DWORD* pdwsz )
	{
		HRESULT hr = S_OK;

		if ( ! psa )
		return E_INVALIDARG;

		if ( ! pppsz || ! pdwsz )
		return E_POINTER;

		(*pppsz)	= NULL;
		(*pdwsz)	= NULL;

		// allocate enough memory
		try
		{
			long u = 0;
			long l = 0;

			hr = ::SafeArrayGetUBound( psa, 1, &u );
			hr = ::SafeArrayGetLBound( psa, 1, &l );

			(*pdwsz) = u-l + 1;

			if ( (*pdwsz) )
			{
				if ( ( (*pppsz) = (LPWSTR*) new LPWSTR[ (*pdwsz) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				// clear everything
				for ( LONG lIndex = 0; lIndex < (LONG) (*pdwsz); lIndex++ )
				{
					(*pppsz)[lIndex] = NULL;
				}

				BSTR * pbstr;

				if SUCCEEDED( hr = ::SafeArrayAccessData ( psa, (void**) &pbstr ) )
				{
					for ( LONG lIndex = 0; lIndex < (LONG) (*pdwsz); lIndex++ )
					{
						if ( pbstr[lIndex] )
						{
							DWORD cchSize = ::SysStringLen(pbstr[lIndex]) + 1;
							if ( ( (*pppsz)[lIndex] = (LPWSTR) new WCHAR[ cchSize ] ) == NULL )
							{
								return E_OUTOFMEMORY;
							}

							StringCchCopyW ( (*pppsz)[lIndex], cchSize, pbstr[lIndex] );
						}
					}
				}
				else
				return hr;

				::SafeArrayUnaccessData ( psa );
			}
			else
			return S_FALSE;
		}
		catch ( ... )
		{
			__Release::Release ( (void***)pppsz, pdwsz );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// LPWSTR* -> SAFEARRAY ( BSTR )
	inline static HRESULT ConvertLPWSTRArrayToSafeArray (  LPWSTR* ppsz, DWORD dwsz ,SAFEARRAY ** ppsa )
	{
		if ( ! ppsz )
		return E_INVALIDARG;

		if ( ! ppsa )
		return E_POINTER;

		(*ppsa)	= NULL;

		try
		{
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= dwsz;

			if ( ( (*ppsa) = ::SafeArrayCreate ( VT_BSTR, 1, rgsabound ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			for ( DWORD dwIndex = 0; dwIndex < dwsz; dwIndex++ )
			{
				BSTR bstr = NULL;
				bstr = ::SysAllocString( ppsz[ dwIndex ] );

				if ( bstr )
				{
					::SafeArrayPutElement ( (*ppsa), (LONG*) &dwIndex, &bstr );
					::SysFreeString ( bstr );
				}
			}
		}
		catch ( ... )
		{
			__Release::Release ( (*ppsa) );
			return E_UNEXPECTED;
		}

		return S_OK;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// macros
//////////////////////////////////////////////////////////////////////////////////////////////

#define	RELEASE_ARRAY( ppwsz )\
__Release::Release( ( void** ) &ppwsz )

#define	RELEASE_DOUBLEARRAY( ppwsz, dwsz )\
__Release::Release( ( void*** ) &ppwsz, &dwsz )

#define	RELEASE_SAFEARRAY( psa )\
__Release::Release( psa )

#define	SAFEARRAY_TO_LPWSTRARRAY( psa, pppsz, pdwsz )\
__StringConvert::ConvertSafeArrayToLPWSTRArray( psa, pppsz, pdwsz )

#define	LPWSTRARRAY_TO_SAFEARRAY( ppsz, dwsz, ppsa )\
__StringConvert::ConvertLPWSTRArrayToSafeArray( ppsz, dwsz, ppsa )


// HRESULT -> WIN32
#define HRESULT_TO_WIN32(hres) ((HRESULT_FACILITY(hres) == FACILITY_WIN32) ? HRESULT_CODE(hres) : (hres))

#endif	__COMMON_CONVERT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__common_smartptr.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__Common_SmartPTR.h
//
//	Abstract:
//
//					smart pointers, handles, cs, ...
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// smart pointers ///////////////////////////////////

#ifndef	__SMART_POINTERS__
#define	__SMART_POINTERS__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// need common
#ifndef	__COMMON_CONVERT__
#include "__Common_Convert.h"
#endif	__COMMON_CONVERT__

// need assert macro
#ifndef	__ASSERT_VERIFY__
#include "__macro_assert.h"
#endif	__ASSERT_VERIFY__

//
// static critsec
//
#include <statsync.h>

//////////////////////////////////////////////////////////////////////////////////////////////
// class for smart CRITICAL SECTION
//////////////////////////////////////////////////////////////////////////////////////////////

class __Smart_CRITICAL_SECTION
{
	__Smart_CRITICAL_SECTION  ( __Smart_CRITICAL_SECTION& )					{};
	__Smart_CRITICAL_SECTION& operator= ( const __Smart_CRITICAL_SECTION& )	{};

	CRITICAL_SECTION*	m_cs;

	public:

	// construction
	__Smart_CRITICAL_SECTION( const LPCRITICAL_SECTION cs ) :
	m_cs ( NULL )
	{
		try
		{
			if ( ( m_cs = cs ) != NULL )
			{
				::EnterCriticalSection ( m_cs );

				ATLTRACE (	L"\n=============================================================\n"
							L" smart CS entered %x \n"
							L"=============================================================\n",
							::GetCurrentThreadId()
						 );
			}
		}
		catch ( ... )
		{
			m_cs = NULL;
		}
	}

	// destruction
	~__Smart_CRITICAL_SECTION ( )
	{
		if ( m_cs )
		{
			::LeaveCriticalSection ( m_cs );

			ATLTRACE (	L"\n=============================================================\n"
						L" smart CS leaved  %x \n"
						L"=============================================================\n",
						::GetCurrentThreadId()
					 );
		}

		m_cs = NULL;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for smart HANDLE
//////////////////////////////////////////////////////////////////////////////////////////////

class __SmartHANDLE;
class __SmartServiceHANDLE;

template < class CLASS >
class __HANDLE
{
	__HANDLE	( __HANDLE& )					{}
	__HANDLE&	operator= ( const __HANDLE& h )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = h.GetHANDLE();

		return (*this);
	}

	friend class __SmartHANDLE;
	friend class __SmartServiceHANDLE;

	CLASS m_handle;

	public:

	__HANDLE() : m_handle ( NULL )
	{
	}

	virtual ~__HANDLE()
	{
		m_handle = NULL;
	}

	// operators

	operator CLASS() const
	{
		return m_handle;
	}

	CLASS& operator = ( const CLASS& handle )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = handle;
	}

	// accessors

	void SetHANDLE ( CLASS handle )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = handle;
	}

	CLASS GetHANDLE ( ) const
	{
		return m_handle;
	}

	// functions
	void CloseHandle ()
	{
		if ( m_handle )
		{
			::CloseHandle ( m_handle );
			m_handle = NULL;
		}
	}

	void Attach ( CLASS handle )
	{
		m_handle = handle;
	}

	CLASS Detach()
	{
		CLASS handle = NULL;

		handle = m_handle;
		m_handle = NULL;

		return handle;
	}
};

class __SmartHANDLE : public __HANDLE < HANDLE >
{
	__SmartHANDLE	( __SmartHANDLE& )					{}
	__SmartHANDLE&	operator= ( const __SmartHANDLE& )	{}

	public:

	__SmartHANDLE ( ) : __HANDLE < HANDLE > ( )
	{
	}

	__SmartHANDLE ( HANDLE handle ) : __HANDLE < HANDLE > ( )
	{
		m_handle = handle;
	}

	virtual ~__SmartHANDLE ()
	{
		if ( m_handle )
		{
			::CloseHandle ( m_handle );
		}
	}

	__SmartHANDLE& operator = ( const HANDLE& handle )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = handle;

		return (*this);
	}
};

class __SmartServiceHANDLE : public __HANDLE < SC_HANDLE >
{
	__SmartServiceHANDLE	( __SmartServiceHANDLE& )					{}
	__SmartServiceHANDLE&	operator= ( const __SmartServiceHANDLE& )	{}

	public:

	__SmartServiceHANDLE ( ) : __HANDLE < SC_HANDLE > ( )
	{
	}

	__SmartServiceHANDLE ( SC_HANDLE handle ) : __HANDLE < SC_HANDLE > ( )
	{
		m_handle = handle;
	}

	virtual ~__SmartServiceHANDLE ()
	{
		if ( m_handle )
		{
			::CloseServiceHandle ( m_handle );
		}
	}

	__SmartServiceHANDLE& operator = ( const SC_HANDLE& handle )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = handle;

		return (*this);
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for smart pointers
//////////////////////////////////////////////////////////////////////////////////////////////

template< class TYPE > class __WrapperPtr;
template< class TYPE > class __WrapperExt;
template< class TYPE > class __WrapperARRAY;

template < class BASE >
class __Wrapper
{
	__Wrapper	( __Wrapper& )					{}
	__Wrapper&	operator= ( const __Wrapper& )	{}

	// variables

	BASE* m_p;

	friend class __WrapperPtr < BASE >;
	friend class __WrapperExt < BASE >;
	friend class __WrapperARRAY < BASE >;

	public:

	// construction & destruction

	__Wrapper ( BASE* p = NULL ) :	m_p ( NULL )
	{
		m_p = p;
	}

	virtual ~ __Wrapper()
	{
		if ( m_p )
		{
			delete m_p;
			m_p = NULL;
		}
	}

	virtual void SetData ( BASE* p)
	{
		___ASSERT ( m_p == NULL );
		m_p = p;
	}

	BOOL IsEmpty ()
	{
		return (m_p == NULL ) ? TRUE : FALSE;
	}

	// operators BOOL
	BOOL operator! () const
	{
		return ( m_p == NULL );
	}

	BOOL operator== (BASE* p) const
	{
		return ( m_p == p );
	}

	// operators CASTING

	operator BASE*() const
	{
		return (BASE*)m_p;
	}
	BASE& operator*() const
	{
		return *m_p;
	}

	BASE** operator&()
	{
		___ASSERT ( m_p == NULL );
		return &m_p;
	}

	// pointer operations
	BASE* Detach()
	{
		BASE* p = m_p;
		m_p = NULL;

		return p;
	}

	void Attach ( BASE* p )
	{
		___ASSERT ( m_p == NULL );
		m_p = p;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for exposing -> operator
//////////////////////////////////////////////////////////////////////////////////////////////

template < class BASE >
class __WrapperPtr : public __Wrapper< BASE > 
{
	__WrapperPtr	( __WrapperPtr& )					{}
	__WrapperPtr&	operator= ( const __WrapperPtr& )	{}

	public:

	// construction & destruction

	__WrapperPtr ( BASE* p = NULL ) :	__Wrapper< BASE > ( p )
	{
	}

	BASE* operator->() const
	{
		return m_p;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class changig inner variable
//////////////////////////////////////////////////////////////////////////////////////////////

template < class BASE >
class __WrapperExt : public __Wrapper< BASE > 
{
	__WrapperExt	( __WrapperExt& )					{}
	__WrapperExt&	operator= ( const __WrapperExt& )	{}

	public:

	// construction & destruction

	__WrapperExt ( BASE* p = NULL ) :	__Wrapper< BASE > ( p )
	{
	}

	BASE** operator&()
	{
		return &m_p;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for wraping ARRAY
//////////////////////////////////////////////////////////////////////////////////////////////

template < class BASE >
class __WrapperARRAY : public __Wrapper<BASE>
{
	DWORD	m_dw;

	__WrapperARRAY  ( __WrapperARRAY & )
	{
	}

	__WrapperARRAY & operator= ( const __WrapperARRAY & )
	{
	}

	public:

	// construction & destruction
	__WrapperARRAY () : m_dw ( NULL )
	{
	}

	__WrapperARRAY ( BASE* p, DWORD dw ) : __Wrapper<BASE>( p ) ,
	m_dw ( NULL )
	{
		m_dw= dw;
	}

	virtual ~__WrapperARRAY ()
	{
		if ( m_p )
		{
			for ( DWORD dwIndex = 0; dwIndex < m_dw; dwIndex++ )
			{
				delete m_p[dwIndex];
				m_p[dwIndex] = NULL;
			}

			delete [] m_p;
		}

		m_p = NULL;
		m_dw = NULL;
	}

	// accessors
	void SetAt ( DWORD dwIndex, BASE data = NULL )
	{
		___ASSERT ( m_p );
		m_p[dwIndex] = data;
	}

	BASE&	GetAt ( DWORD dwIndex ) const
	{
		___ASSERT ( m_p );
		return m_p[dwIndex];
	}

	// adding data
	HRESULT DataAdd ( BASE item )
	{
		BASE* p = NULL;

		try
		{
			if ( ( p = new BASE[m_dw + 1] ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			if ( p )
			{
				if ( m_p )
				{
					for ( DWORD dw = 0; dw < m_dw; dw++ )
					{
						p[dw] = m_p[dw];
					}

					p[dw] = item;

					delete [] m_p;
					m_p = NULL;
				}
				else
				{
					p[m_dw] = item;
				}

				m_p = p;
				m_dw++;
			}
		}
		catch ( ... )
		{
			if ( p )
			{
				delete [] p;
				p = NULL;
			}

			return E_FAIL;
		}

		return S_OK;
	}

	// delete by index
	HRESULT DataDelete ( DWORD dwIndex )
	{
		if ( dwIndex < m_dw )
		{
			try
			{
				delete m_p[dwIndex];
			}
			catch ( ... )
			{
			}

			for ( DWORD dw = dwIndex; dw < m_dw - 1; dw++ )
			{
				m_p[dw] = m_p[dw+1];
			}

			m_dw--;
			return S_OK;
		}

		return E_INVALIDARG;
	}

	// delete by value
	HRESULT DataDelete ( BASE data )
	{
		if ( date )
		{
			for ( DWORD dw = 0; dw < m_dw; dw++ )
			{
				if ( m_p[dw] == data )
				{
					return DataDelete ( dw );
				}
			}

			return S_OK;
		}

		return S_FALSE;
	}

	// helpers
	void SetData ( BASE* p, DWORD dw )
	{
		if ( p )
		{
			__Wrapper<BASE>::SetData ( p );
		}

		m_dw = dw;
	}

	// aditional operators

	operator DWORD() const	// for return size of array
	{
		return m_dw;
	}

	operator DWORD*()		// for set size of array
	{
		return &m_dw;
	}

	const BASE& operator[] (DWORD dwIndex) const
	{
		return m_p[dwIndex];
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for wraping SAFEARRAY
//////////////////////////////////////////////////////////////////////////////////////////////

class __WrapperSAFEARRAY
{
	__WrapperSAFEARRAY ( __WrapperSAFEARRAY& )
	{
	}

	__WrapperSAFEARRAY& operator= ( const __WrapperSAFEARRAY& )
	{
	}

	SAFEARRAY * m_p;

	public:

	// constructor & destructor
	__WrapperSAFEARRAY( ) : m_p ( NULL )
	{
	}

	__WrapperSAFEARRAY( tagSAFEARRAY* psa ) : m_p ( NULL )
	{
		m_p = psa;
	}

	~__WrapperSAFEARRAY()
	{
		RELEASE_SAFEARRAY ( m_p );
		m_p = NULL;
	}

	// operators CASTING

	operator SAFEARRAY*() const
	{
		return (SAFEARRAY*)m_p;
	}

	SAFEARRAY** operator&()
	{
		___ASSERT ( m_p == NULL );
		return &m_p;
	}
};

#endif	__SMART_POINTERS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__macro_loadstring.h ===
///////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_loadstring.h
//
//	Abstract:
//
//					load string from resources helper
//
//	History:
//
//					initial		a-marius
//
///////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// Resource Strings ///////////////////////////////////

#ifndef	__RESOURCE_STR__
#define	__RESOURCE_STR__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// inline helper
inline LPWSTR LoadStringHelper ( LPWSTR sz, DWORD cchSize, LPWSTR szSource )
{
	if ( sz )
	{
		StringCchCopyW ( sz, cchSize, szSource );
	}

	delete ( szSource );
	szSource = NULL;

	return sz;
}

inline LPWSTR LoadStringSystem ( HINSTANCE hInst, UINT nID )
{
	WCHAR sz[_MAX_PATH] = { L'\0' };
	DWORD lenght = 0;

	if ( ( lenght = ::LoadStringW ( hInst, nID, sz, _MAX_PATH ) ) != 0 )
	{
		LPWSTR psz = NULL;

		if ( ( psz = reinterpret_cast<LPWSTR>( new WCHAR [ lenght + 1 ] ) ) != NULL )
		{
			StringCchCopyW ( psz, lenght + 1, sz );
		}

		return psz;
	}

	return NULL;
}

// macro
#ifndef	___LOADSTRING

#define	___LOADSTRINGDATA LPWSTR psz = NULL; DWORD dwSize = NULL;
#define	___LOADSTRING( hInst, nID ) \
( \
	( \
		( ! hInst ) ? NULL : \
		( \
			psz  = LoadStringSystem ( hInst, nID ), \
			size = ( \
						( ( ! psz ) ? NULL : ( ( lstrlenW ( psz ) + 1 ) ) * sizeof ( WCHAR ) ) \
				   ), \
\
			LoadStringHelper ( ( LPWSTR ) alloca ( size ), size / sizeof ( WCHAR ), psz ) \
		) \
	) \
)

#endif	___LOADSTRING

#endif	__RESOURCE_STR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__macro_assert.h ===
///////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_assert.h
//
//	Abstract:
//
//					assertion and verify macros and helpers
//
//	History:
//
//					initial		a-marius
//
///////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// Assert/Verify Macros ///////////////////////////////////

#ifndef	__ASSERT_VERIFY__
#define	__ASSERT_VERIFY__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// set behaviour of macros
#ifdef	_DEBUG
//#define	__SHOW_MSGBOX
//#define	__DEBUG_BREAK
#endif	_DEBUG

///////////////////////////////////////////////////////////////////////////////////////////
// macros
///////////////////////////////////////////////////////////////////////////////////////////

// call DebugBreak if in debug mode
#ifdef	_DEBUG
inline void ForceDebugBreak ( void )
{
	#ifdef	__DEBUG_BREAK
	__try
	{ 
		DebugBreak(); 
	}
	__except(UnhandledExceptionFilter(GetExceptionInformation()))
	{
	}
	#endif	__DEBUG_BREAK
}
#else	_DEBUG
#define ForceDebugBreak()
#endif	_DEBUG

// show error and throw break

#ifdef	__SHOW_MSGBOX
#define ___FAIL(szMSG, szTitle)\
(\
	MessageBoxW(GetActiveWindow(), (szMSG) ? szMSG : L"", (szTitle) ? szTitle : L"", MB_OK | MB_ICONERROR),\
	ForceDebugBreak()\
)
#else	__SHOW_MSGBOX
#define ___FAIL(szMSG, szTitle)\
(\
	ForceDebugBreak()\
)
#endif	__SHOW_MSGBOX

// Put up an assertion failure
#define ___ASSERTFAIL(file,line,expr,title)\
{\
	WCHAR sz[256] = { L'\0' };\
	StringCchPrintfW(sz, 256, L"File %hs, line %d : %hs", file, line, expr);\
	___FAIL(sz, title);\
}

// Assert in debug builds, but don't remove the code in retail builds.

#ifdef	_DEBUG
#define ___ASSERT(x) if (!(x)) ___ASSERTFAIL(__FILE__, __LINE__, #x, L"Assert Failed")
#else	_DEBUG
#define ___ASSERT(x)
#endif	_DEBUG

#ifdef	_DEBUG
#define ___ASSERT_DESC(x, desc) if (!(x)) ___ASSERTFAIL(__FILE__, __LINE__, #desc, L"Assert Failed")
#else	_DEBUG
#define ___ASSERT_DESC(x, desc)
#endif	_DEBUG

#ifdef	_DEBUG
#define	___VERIFY(x) ___ASSERT(x)
#else	_DEBUG
#define	___VERIFY(x) (x)
#endif	_DEBUG

#endif	__ASSERT_VERIFY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__macro_nocopy.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_nocopy.h
//
//	Abstract:
//
//					dissallow creation of copy of instantied object
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////


#ifndef	__NO_COPY_H__
#define	__NO_COPY_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#define DECLARE_NO_COPY( T ) \
private:\
	T(const T&);\
	T& operator=(const T&);

#endif	__NO_COPY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__macro_err.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_err.h
//
//	Abstract:
//
//					error handling helpers and macros
//
//	History:
//
//					initial		a-marius
//
///////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// error & trace Macros ///////////////////////////////////

#ifndef	__WMI_PERF_ERR__
#define	__WMI_PERF_ERR__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// need atl wrappers
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

// need macros :)))
#ifndef	__ASSERT_VERIFY__
#include <__macro_assert.h>
#endif	__ASSERT_VERIFY__

// trace description
#ifdef	_DEBUG
#define	___TRACE( x )\
(\
	AtlTrace( _TEXT( "\n error ... %hs(%d)" ), __FILE__, __LINE__ ),\
	AtlTrace( _TEXT( "\n DESCRIPTION : %s" ), x ),\
	AtlTrace( _TEXT( "\n" ) )\
)
#else	_DEBUG
#define	___TRACE( x )
#endif	_DEBUG

#ifdef	_DEBUG
#define	___TRACE_ERROR( x,err )\
(\
	AtlTrace( _TEXT( "\n error ... %hs(%d)" ), __FILE__, __LINE__ ),\
	AtlTrace( _TEXT( "\n DESCRIPTION  : %s" ), x ),\
	AtlTrace( _TEXT( "\n ERROR NUMBER : 0x%x" ), err ),\
	AtlTrace( _TEXT( "\n" ) )\
)
#else	_DEBUG
#define	___TRACE_ERROR( x, err )
#endif	_DEBUG

inline LPWSTR	GetErrorMessageSystem ( void );
inline LPWSTR	GetErrorMessageSystem ( DWORD dwError );

inline LPWSTR	GetErrorMessageModule ( DWORD dwError, HMODULE handle = NULL );

// stack allocation
inline LPWSTR	GetErrorMessage ( LPWSTR sz, DWORD cchSize, LPWSTR szSource )
{
	if ( sz && szSource )
	{
		StringCchCopyW ( sz, cchSize, szSource );

		delete ( szSource );
		szSource = NULL;

		return sz;
	}

	return NULL;
}

inline LPWSTR	GetErrorMessage ( LPWSTR sz, DWORD cchSize, DWORD err )
{
	StringCchPrintfW ( sz, cchSize, L"unspecified error : 0x%x", err );
	return sz;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// macros
//////////////////////////////////////////////////////////////////////////////////////////////
#pragma warning( disable : 4003 )

#ifdef	_DEBUG
#define	ERRORMESSAGE_DEFINITION	LPWSTR szErrorMessage = NULL; DWORD cchSizeErrorMessage = NULL;
#else	! _DEBUG
#define	ERRORMESSAGE_DEFINITION
#endif	_DEBUG

#ifdef	_DEBUG

// system
#define ERRORMESSAGE(dwError)\
szErrorMessage = GetErrorMessageSystem(dwError),\
(\
	( !szErrorMessage ) ? \
	(\
		___TRACE_ERROR ( L"unresolved error was occured !", dwError ),\
		___FAIL (	GetErrorMessage	(\
										(LPWSTR) alloca ( 43 * sizeof ( WCHAR ) ),\
										43,\
										dwError\
									),\
					L"Error occured"\
				)\
	)\
	:\
	(\
		___TRACE ( szErrorMessage ),\
		( cchSizeErrorMessage = lstrlenW ( szErrorMessage ) + 1 ),\
		___FAIL (	GetErrorMessage	(\
										(LPWSTR) alloca ( cchSizeErrorMessage ) * sizeof ( WCHAR ) ),\
										cchSizeErrorMessage,\
										szErrorMessage\
									),\
					L"Error occured"\
				)\
	)\
),\
delete [] szErrorMessage,\
szErrorMessage = NULL

// module
#define ERRORMESSAGE1(dwError, handle)\
szErrorMessage = GetErrorMessageModule(dwError, handle),\
(\
	( !szErrorMessage ) ? \
	(\
		___TRACE_ERROR ( L"unresolved error was occured !", dwError ),\
		___FAIL (	GetErrorMessage	(\
										(LPWSTR) alloca ( 43 * sizeof ( WCHAR ) ),\
										43,\
										dwError\
									),\
					L"Error occured"\
				)\
	)\
	:\
	(\
		___TRACE ( szErrorMessage ),\
		( cchSizeErrorMessage = lstrlenW ( szErrorMessage ) + 1 ),\
		___FAIL (	GetErrorMessage	(\
										(LPWSTR) alloca ( cchSizeErrorMessage ) * sizeof ( WCHAR ) ),\
										cchSizeErrorMessage,\
										szErrorMessage\
									),\
					L"Error occured"\
				)\
	)\
),\
delete [] szErrorMessage,\
szErrorMessage = NULL


#else	!_DEBUG
#define	ERRORMESSAGE(dwError)
#define	ERRORMESSAGE1(dwError, handle)
#endif	_DEBUG

#define	ERRORMESSAGE_RETURN(dwError)\
{\
	ERRORMESSAGE( dwError );\
	return dwError;\
}

#define	ERRORMESSAGE_EXIT(dwError)\
{\
	ERRORMESSAGE( dwError );\
	return;\
}

#define	ERRORMESSAGE1_RETURN(dwError, handle)\
{\
	ERRORMESSAGE1( dwError, handle );\
	return dwError;\
}

#define	ERRORMESSAGE1_EXIT(dwError, handle)\
{\
	ERRORMESSAGE1( dwError, handle );\
	return;\
}

//////////////////////////////////////////////////////////////////////////////////////////////
// class for wrapping error handling
//////////////////////////////////////////////////////////////////////////////////////////////

class __Error
{
	__Error ( __Error& )					{}
	__Error& operator= ( const __Error& )	{}

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	__Error ()
	{
	}

	virtual ~__Error ()
	{
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////
	// Function name	: GetMessageFromError
	// Description		: returns resolved error message or NULL
	// Return type		: LPWSTR 
	// Argument			: DWORD
	// Note				: user has to free returned string

	inline static LPWSTR GetMessageFromError( DWORD dwError )
	{
		LPVOID		lpMsgBuf = NULL;
		LPWSTR		szResult = NULL;

		try
		{
			DWORD cchSize = 
			FormatMessageW(	FORMAT_MESSAGE_ALLOCATE_BUFFER | 
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_IGNORE_INSERTS,
							NULL,
							dwError,
							MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
							(LPWSTR) &lpMsgBuf,
							0,
							NULL );

			if( cchSize && lpMsgBuf )
			{
				if ( ( szResult = (LPWSTR) new WCHAR[ cchSize + 1 ] ) != NULL )
				{
					StringCchCopyW( szResult, cchSize + 1, (LPWSTR)lpMsgBuf );
				}

				LocalFree( lpMsgBuf );
			}
		}
		catch ( ... )
		{
			if ( lpMsgBuf )
			{
				LocalFree( lpMsgBuf );
			}
		}

		return szResult;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// Function name	: GetMessageFromModule
	// Description		: returns resolved error message or NULL
	// Return type		: LPWSTR 
	// Argument			: DWORD
	// Note				: user has to free returned string

	inline static LPWSTR GetMessageFromModule( DWORD dwError, HMODULE handle = NULL )
	{
		LPVOID		lpMsgBuf = NULL;
		LPWSTR		szResult = NULL;

		try
		{
			DWORD cchSize = 
			FormatMessageW(	FORMAT_MESSAGE_ALLOCATE_BUFFER | 
							FORMAT_MESSAGE_FROM_HMODULE |
							FORMAT_MESSAGE_IGNORE_INSERTS,
							(LPCVOID)handle,
							dwError,
							MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
							(LPWSTR) &lpMsgBuf,
							0,
							NULL );

			if( cchSize && lpMsgBuf )
			{
				if ( ( szResult = (LPWSTR) new WCHAR[ cchSize + 1 ] ) != NULL )
				{
					StringCchCopyW( szResult, cchSize + 1, (LPWSTR)lpMsgBuf );
				}

				LocalFree( lpMsgBuf );
			}
		}
		catch ( ... )
		{
			if ( lpMsgBuf )
			{
				LocalFree( lpMsgBuf );
			}
		}

		return szResult;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// Function name	: GetMessageFromErrorInfo
	// Description		: returns resolved error message or NULL
	// Return type		: LPWSTR 
	// Argument			: void
	// Note				: user has to free returned string

	inline static LPWSTR GetMessageFromErrorInfo( void )
	{
		CComPtr< IErrorInfo >	pError;
		LPWSTR					szResult = NULL;

		if ( ( ::GetErrorInfo ( NULL, &pError ) == S_OK ) && pError )
		{
			CComBSTR	bstrSource;
			CComBSTR	bstrDescription;

			pError->GetSource ( &bstrSource );
			pError->GetDescription ( &bstrDescription );

			CComBSTR	bstrResult;

			if ( bstrSource.Length() )
			{
				bstrResult	+= L" ProgID : ";
				bstrResult	+= bstrSource;
			}
			if ( bstrDescription.Length() )
			{
				bstrResult	+= L" Description : ";
				bstrResult	+= bstrDescription;
			}

			if ( bstrResult.Length() )
			{
				if ( ( szResult = (LPWSTR) new WCHAR[ bstrResult.Length() + 1 ] ) != NULL )
				{
					StringCchCopyW( szResult, bstrResult.Length() + 1, bstrResult );
				}
			}
		}

		return szResult;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// helpers
//////////////////////////////////////////////////////////////////////////////////////////////

inline LPWSTR	GetErrorMessageModule ( DWORD dwError, HMODULE handle )
{
	return __Error::GetMessageFromModule ( dwError, handle );
}

inline LPWSTR	GetErrorMessageSystem ( DWORD dwError )
{
	return __Error::GetMessageFromError ( dwError );
}

inline LPWSTR	GetErrorMessageSystem ( void )
{
	return __Error::GetMessageFromErrorInfo();
}

#endif	__WMI_PERF_ERR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter\common.inc ===
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

WMI_PERFORMANCE_INC = $(ADAPTERS)\WmiReversePerformanceMonitor\Include

WMI_PERFORMANCE_REFRESH_INC = $(ADAPTERS)\WmiReversePerformanceMonitor\WMIAdapter_Refresh
WMI_PERFORMANCE_REFRESH_LIB = $(ADAPTERS)\WmiReversePerformanceMonitor\System\$(O)\WmiApRef.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pokus.rc
//
#define IDS_PROJNAME			100

#define IDS_NAME				110
#define IDS_DESCRIPTION			111

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__macro_pragma.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_pragma.h
//
//	Abstract:
//
//					pragma message helper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////// Pragma //////////////////////////////////////

#ifndef	__PRAGMA__
#define	__PRAGMA__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// When the compiler sees a line like this:
// #pragma ___PRAGMA_MSG(Fix this later)
//
// it outputs a line like this:
// C:\Document\AdvWin\Code\Sysinfo.06\..\CmnHdr.H(296):Fix this later
//
// You can easily jump directly to this line and examine the surrounding code.

#define ___STR(x)			#x
#define ___STRING(x)		___STR(x)
#define ___PRAGMA_MSG(desc)	message(__FILE__ "(" ___STRING(__LINE__) ") : " #desc)

#endif	__PRAGMA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_messages\common.inc ===
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

WMI_PERFORMANCE_INC = ..\Include
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_messages\resource.h ===
#define IDS_cWMIOBJECTS_NAME			204
#define IDS_cWMIOBJECTS_COUNT_NAME		205
#define IDS_cWMIOBJECTS_VALIDITY_NAME	206

#define IDS_cWMIOBJECTS_HELP			207
#define IDS_cWMIOBJECTS_COUNT_HELP		208
#define IDS_cWMIOBJECTS_VALIDITY_HELP	209
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\common.inc ===
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

WMI_PERFORMANCE_INC = $(ADAPTERS)\WmiReversePerformanceMonitor\Include
WMI_PERFORMANCE_MESSAGES_INC = $(ADAPTERS)\WmiReversePerformanceMonitor\WMIAdapter_Messages
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_messages\wmiadapter_messages.cpp ===
// WMIAdapterMessages.cpp

#include "precomp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

////////////////////////////////////////////////////////////////////////////////////
// includes
////////////////////////////////////////////////////////////////////////////////////
#include "WMIAdapter_Messages.h"
#include "WMI_EventLog_Base.h"

// save instance
HMODULE g_hModule = NULL;

////////////////////////////////////////////////////////////////////////////////////
// dll main
////////////////////////////////////////////////////////////////////////////////////

BOOL APIENTRY DllMain( HANDLE hModule, DWORD  dwReason, LPVOID lpReserved )
{
    switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
		{
			if ( !lpReserved )
			{
				// loaded dynamic
			}
			else
			{
				// loaded static
			}

			// disable attach/detach of threads
			::DisableThreadLibraryCalls ( (HMODULE) hModule );

			g_hModule = ( HMODULE ) hModule;
		}
		break;

		case DLL_PROCESS_DETACH:
		{
			#ifdef	_DEBUG
			_CrtDumpMemoryLeaks();
			#endif	_DEBUG
		}
		break;

		// thread attaching is not used !!!
		case DLL_THREAD_ATTACH: break;
		case DLL_THREAD_DETACH: break;
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
// registration of message dll
////////////////////////////////////////////////////////////////////////////////////
HRESULT __stdcall  Register_Messages ( void )
{
	TCHAR szPath [ _MAX_PATH ];

	if ( ::GetModuleFileName ( g_hModule, szPath, _MAX_PATH - 1 ) )
	{
		szPath [ _MAX_PATH - 1 ] = L'\0';
		CPerformanceEventLogBase::Initialize ( _T("WmiAdapter"), szPath );
		return S_OK;
	}

	return HRESULT_FROM_WIN32 ( ::GetLastError () );
}

////////////////////////////////////////////////////////////////////////////////////
// unregistration of message dll
////////////////////////////////////////////////////////////////////////////////////
HRESULT __stdcall  Unregister_Messages ( void )
{
	CPerformanceEventLogBase::UnInitialize ( _T("WmiAdapter") );
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\precomp.h ===
#ifndef	__PRECOMP_H__
#define	__PRECOMP_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif	_WIN32_WINNT

#ifndef	WIN32_LEAN_AND_MEAN
#define	WIN32_LEAN_AND_MEAN
#endif	WIN32_LEAN_AND_MEAN

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <polarity.h>

// need atl wrappers
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

// need safe functions (after atl)
#include <strsafe.h>

///////////////////////////////////////////////////////////////////////////////
// macros
///////////////////////////////////////////////////////////////////////////////
#include <__macro_pragma.h>
#include <__macro_nocopy.h>
#include <__macro_loadstring.h>
#include <__macro_assert.h>
#include <__macro_err.h>

#include "__Common_Convert.h"
#include "__Common_SmartPTR.h"

///////////////////////////////////////////////////////////////////////////////
// wbem stuff
///////////////////////////////////////////////////////////////////////////////
#ifndef	__WBEMIDL_H_
#include <wbemidl.h>
#endif	__WBEMIDL_H_

#define UNICODE_SIGNATURE "\xff\xfe"

#endif	__PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\refresher.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					refresher.h
//
//	Abstract:
//
//					declaration of registry refresh exported functions
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REFRESHER_H__
#define	__REFRESHER_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// it is not thread safe
HRESULT	__stdcall DoReverseAdapterMaintenance ( BOOL bThrottle );

#endif	__REFRESHER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\refreshergenerate.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					refreshergenerate.h
//
//	Abstract:
//
//					declaration of helper enum
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REFRESHER_GENERATE_H__
#define	__REFRESHER_GENERATE_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

enum GenerateEnum
{
	Registration = -1,
	Normal,
	UnRegistration

};

HRESULT	__stdcall DoReverseAdapterMaintenanceInternal ( BOOL bThrottle, GenerateEnum generate = Normal );

#endif	__REFRESHER_GENERATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\refresher.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					Refresher.cpp
//
//	Abstract:
//
//					module for application stuff ( security, event logging ... )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "Refresher.h"
#include "RefresherStuff.h"

// security
#include "wmi_security.h"
#include "wmi_security_attributes.h"

/////////////////////////////////////////////////////////////////////////////
//
//	Helpers
//
/////////////////////////////////////////////////////////////////////////////

extern LONG				g_lRefCIM;			//	count of threads attached into CIMV2 namespace
extern LONG				g_lRefWMI;			//	count of threads attached into WMI namespace

extern __SmartHANDLE	g_hDoneWorkEvtCIM;	//	event to set when init/uninit is finished done		( nonsignaled )
extern BOOL				g_bWorkingCIM;		//	boolean used to tell if init/unit in progress

extern __SmartHANDLE	g_hDoneWorkEvtWMI;	//	event to set when init/uninit is finished done		( nonsignaled )
extern BOOL				g_bWorkingWMI;		//	boolean used to tell if init/unit in progress

/////////////////////////////////////////////////////////////////////////////
// MUTEX
/////////////////////////////////////////////////////////////////////////////

extern	LPCWSTR	g_szRefreshMutex;
__SmartHANDLE	g_hRefreshMutex		= NULL;

extern	LPCWSTR	g_szRefreshMutexLib;
__SmartHANDLE	g_hRefreshMutexLib	= NULL;

extern	LPCWSTR	g_szRefreshFlag;
__SmartHANDLE	g_hRefreshFlag		= NULL;

HRESULT	__stdcall WbemMaintenanceInitialize ( void )
{
	WmiSecurityAttributes RefresherSA;

	if ( RefresherSA.GetSecurityAttributtes() )
	{
		if ( ! g_hRefreshMutex )
		{
			if ( ( g_hRefreshMutex = ::CreateMutex	(
														RefresherSA.GetSecurityAttributtes(),
														FALSE,
														g_szRefreshMutex
													)
				 ) == NULL )
			{
				// this is really important to have

				DWORD dwError = 0L;
				dwError = ::GetLastError ();

				if ( dwError != ERROR_ALREADY_EXISTS )
				{
					return HRESULT_FROM_WIN32 ( dwError );
				}

				return E_OUTOFMEMORY;
			}
		}

		if ( ! g_hRefreshMutexLib )
		{
			if ( ( g_hRefreshMutexLib = ::CreateMutex	(
														RefresherSA.GetSecurityAttributtes(),
														FALSE,
														g_szRefreshMutexLib
													)
				 ) == NULL )
			{
				// this is really important to have

				DWORD dwError = 0L;
				dwError = ::GetLastError ();

				if ( dwError != ERROR_ALREADY_EXISTS )
				{
					return HRESULT_FROM_WIN32 ( dwError );
				}

				return E_OUTOFMEMORY;
			}
		}

		if ( ! g_hRefreshFlag )
		{
			if ( ( g_hRefreshFlag = ::CreateMutex	(
														RefresherSA.GetSecurityAttributtes(),
														FALSE,
														g_szRefreshFlag
													)
				 ) == NULL )
			{
				// this is really important to have

				DWORD dwError = 0L;
				dwError = ::GetLastError ();

				if ( dwError != ERROR_ALREADY_EXISTS )
				{
					return HRESULT_FROM_WIN32 ( dwError );
				}

				return E_OUTOFMEMORY;
			}
		}

		if ( ! g_hDoneWorkEvtCIM )
		{
			if ( ( g_hDoneWorkEvtCIM = ::CreateEvent ( NULL, TRUE, FALSE, NULL ) ) == NULL )
			{
				// this is really important to have

				DWORD dwError = 0L;
				dwError = ::GetLastError ();

				if ( dwError != ERROR_ALREADY_EXISTS )
				{
					return HRESULT_FROM_WIN32 ( dwError );
				}

				return E_OUTOFMEMORY;
			}
		}

		if ( ! g_hDoneWorkEvtWMI )
		{
			if ( ( g_hDoneWorkEvtWMI = ::CreateEvent ( NULL, TRUE, FALSE, NULL ) ) == NULL )
			{
				// this is really important to have

				DWORD dwError = 0L;
				dwError = ::GetLastError ();

				if ( dwError != ERROR_ALREADY_EXISTS )
				{
					return HRESULT_FROM_WIN32 ( dwError );
				}

				return E_OUTOFMEMORY;
			}
		}

		return S_OK;
	}

	return E_FAIL;
}

HRESULT	__stdcall WbemMaintenanceUninitialize ( void )
{
	return S_OK;
}

HRESULT	__stdcall DoReverseAdapterMaintenance ( BOOL bThrottle )
{
	return DoReverseAdapterMaintenanceInternal ( bThrottle );
}

HRESULT	__stdcall DoReverseAdapterMaintenanceInternal ( BOOL bThrottle, GenerateEnum generate )
{
	if ( CStaticCritSec::anyFailure () )
	{
		//
		// some critical section was not
		// initialized properly due to low memory
		//
		return WBEM_E_OUT_OF_MEMORY ;
	}

	HRESULT				hRes = S_OK;
	WmiRefresherStuff*	stuff= NULL;

	try
	{
		if ( ( stuff = new WmiRefresherStuff () ) == NULL )
		{
			hRes = E_OUTOFMEMORY;
		}
	}
	catch ( ... )
	{
		if ( stuff )
		{
			delete stuff;
			stuff = NULL;
		}

		hRes = E_UNEXPECTED;
	}

	if ( stuff )
	{
		if SUCCEEDED ( hRes = WbemMaintenanceInitialize () )
		{
			if ( generate == Normal )
			{
				hRes = stuff->Connect ();
			}

			if SUCCEEDED ( hRes )
			{
				try
				{
					hRes = stuff->Generate ( bThrottle, generate );
				}
				catch ( ... )
				{
					hRes = E_UNEXPECTED;
				}
			}

			if ( generate == Normal )
			{
				stuff->Disconnect ();
			}

			delete stuff;
			stuff = NULL;

			WbemMaintenanceUninitialize();
		}
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// GetWbem directory
///////////////////////////////////////////////////////////////////////////////

extern LPCWSTR	g_szWbem;
extern LPCWSTR	g_szDir;
extern LPCWSTR	g_szFolder;

LPWSTR __stdcall GetWbemDirectory( BOOL bIncludePerformance )
{
	CRegKey		rKey;
	LPWSTR		wszResult = NULL;

	// wbem directory
	if ( rKey.Open ( HKEY_LOCAL_MACHINE, g_szWbem, KEY_READ ) == ERROR_SUCCESS )
	{
		LPWSTR	tsz		= NULL;
		LPWSTR	tszFull	= NULL;

		DWORD	dwtsz	= 0;

		if ( rKey.QueryValue ( tsz, g_szDir, &dwtsz ) == ERROR_SUCCESS )
		{
			try
			{
				if ( ( tsz = new WCHAR[ dwtsz * sizeof ( WCHAR ) ] ) != NULL )
				{
					if ( rKey.QueryValue ( tsz, g_szDir, &dwtsz ) == ERROR_SUCCESS )
					{
						DWORD dw = 0L;
							
						if ( ( dw = ExpandEnvironmentStrings ( tsz, tszFull, 0 ) ) != 0 )
						{
							if ( ( tszFull = new WCHAR[ dw ] ) != NULL )
							{
								if ( ( dw = ExpandEnvironmentStrings ( tsz, tszFull, dw ) ) != 0 )
								{
									if ( bIncludePerformance )
									{
										DWORD cchSize = lstrlenW ( g_szFolder ) + dw + 1;
										if ( ( wszResult = new WCHAR [ cchSize ] ) != NULL )
										{
											StringCchCopyW ( wszResult, dw, tszFull );
											StringCchCatW ( wszResult, cchSize, g_szFolder );
										}
									}
									else
									{
										DWORD cchSize = dw + 1 + 1;
										if ( ( wszResult = new WCHAR [ cchSize ] ) != NULL )
										{
											StringCchCopyW ( wszResult, cchSize, tszFull );
											StringCchCatW ( wszResult, cchSize, L"\\" );
										}
									}
								}

								delete [] tszFull;
								tszFull = NULL;
							}
						}
					}

					delete [] tsz;
					tsz = NULL;
				}
			}
			catch ( ... )
			{
				if ( tsz )
				{
					delete [] tsz;
					tsz = NULL;
				}

				if ( tszFull )
				{
					delete [] tszFull;
					tszFull = NULL;
				}

				if ( wszResult )
				{
					delete [] wszResult;
					wszResult = NULL;
				}
			}
		}
	}

	return wszResult;
}

HMODULE	__stdcall GetResourceDll()
{
	LPWSTR	wszWbemPath = NULL;
	WCHAR	wszPath [ _MAX_PATH ];

	HMODULE hHandle = NULL;

	if ( NULL != ( wszWbemPath = GetWbemDirectory ( FALSE ) ) )
	{
		DWORD cchResource = lstrlenW ( L"WmiApRes.dll" );
		DWORD cchSize = lstrlenW ( wszWbemPath ) + cchResource + 1;
		if ( cchSize <= _MAX_PATH )
		{
			StringCchCopyW ( wszPath, cchSize,  wszWbemPath );
			StringCchCatW ( wszPath, cchSize, L"WmiApRes.dll" );

			hHandle = ::LoadLibraryW ( wszPath );
		}

		if ( wszWbemPath )
		{
			delete [] wszWbemPath;
			wszWbemPath = NULL;
		}
	}

	return hHandle;
}

/////////////////////////////////////////////////////////////////////////////
// registry helper functions
/////////////////////////////////////////////////////////////////////////////

HRESULT	__stdcall	SetRegistry		(	LPCWSTR wszKey,
										LPSECURITY_ATTRIBUTES pSA,
										CRegKey &reg
									)
{
	DWORD	regErr = HRESULT_TO_WIN32 ( E_FAIL );

	// create parent
	LPWSTR wszKeyParent = NULL;
	LPWSTR wszResult	= NULL;

	wszResult = wcsrchr ( wszKey, L'\\' );

	if ( wszResult )
	{
		size_t dwKeyParent = 0L;
		dwKeyParent = wszResult - wszKey;

		BOOL bContinue = FALSE;

		try
		{
			if ( ( wszKeyParent = new WCHAR [ dwKeyParent + 1 ] ) != NULL )
			{
				memcpy ( wszKeyParent, wszKey, sizeof ( WCHAR ) * dwKeyParent );
				wszKeyParent [ dwKeyParent ] = L'\0';

				bContinue = TRUE;
			}
		}
		catch ( ... )
		{
		}

		if ( bContinue )
		{
			regErr = reg.Create	(	HKEY_LOCAL_MACHINE,
									wszKeyParent,
									NULL,
									REG_OPTION_NON_VOLATILE,
									KEY_ALL_ACCESS,
									NULL
								);
		}
	}

	if ( wszKeyParent )
	{
		delete [] wszKeyParent;
		wszKeyParent = NULL;
	}

	if ( regErr == ERROR_SUCCESS )
	{
		// create ( open ) requested
		regErr = reg.Create	(	HKEY_LOCAL_MACHINE,
								wszKey,
								REG_NONE,
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								pSA
							);
	}

	return HRESULT_FROM_WIN32 ( regErr );
}

HRESULT	__stdcall	SetRegistry		(	LPCWSTR wszKey,
										LPCWSTR wszKeyValue,
										BYTE* pData,
										DWORD dwDataSize,
										LPSECURITY_ATTRIBUTES pSA
									)
{
	CRegKey reg;
	DWORD	regErr = ERROR_ACCESS_DENIED;

	regErr = reg.Open ( HKEY_LOCAL_MACHINE, wszKey, KEY_WRITE );
	if ( regErr != ERROR_SUCCESS && regErr != ERROR_ACCESS_DENIED )
	{
		if SUCCEEDED ( SetRegistry ( wszKey, pSA, reg ) )
		{
			regErr = ERROR_SUCCESS;
		}
	}

	if ( regErr == ERROR_SUCCESS )
	{
		regErr = RegSetValueEx	(	reg,
									wszKeyValue,
									NULL,
									REG_BINARY,
									pData,
									dwDataSize
								);
	}

	return HRESULT_FROM_WIN32 ( regErr );
}

HRESULT	__stdcall	SetRegistry		(	LPCWSTR wszKey,
										LPCWSTR wszKeyValue,
										DWORD dwValue,
										LPSECURITY_ATTRIBUTES pSA
									)
{
	CRegKey reg;
	DWORD	regErr = ERROR_ACCESS_DENIED;

	regErr = reg.Open ( HKEY_LOCAL_MACHINE, wszKey, KEY_WRITE );
	if ( regErr != ERROR_SUCCESS && regErr != ERROR_ACCESS_DENIED )
	{
		if SUCCEEDED ( SetRegistry ( wszKey, pSA, reg ) )
		{
			regErr = ERROR_SUCCESS;
		}
	}

	{
		regErr = RegSetValueEx	(	reg,
									wszKeyValue,
									NULL,
									REG_DWORD,
									reinterpret_cast < BYTE* > ( &dwValue ),
									sizeof ( DWORD )
								);
	}

	return HRESULT_FROM_WIN32 ( regErr );
}

// get internal registry bit
HRESULT	__stdcall GetRegistry ( LPCWSTR wszKey, LPCWSTR wszKeyValue, BYTE** pData )
{
	( * pData ) = NULL;

	// registry
	HKEY	reg = NULL;
	DWORD	regErr = ERROR_SUCCESS;

	if ( ( regErr = RegOpenKeyW ( HKEY_LOCAL_MACHINE, wszKey, &reg ) ) == ERROR_SUCCESS )
	{
		DWORD dwData = 0;

		if ( ( regErr = RegQueryValueExW ( reg, wszKeyValue, NULL, NULL, (*pData), &dwData ) ) == ERROR_SUCCESS )
		{
			if ( dwData )
			{
				try
				{
					if ( ( (*pData) = (BYTE*) new BYTE [ dwData ] ) != NULL )
					{
						if ((regErr = RegQueryValueExW ( reg, wszKeyValue, NULL, NULL, (*pData), &dwData )) != ERROR_SUCCESS)
						{
							delete [] ( *pData );
							(*pData) = NULL;
						}
					}
					else
					{
						regErr = static_cast < DWORD > ( HRESULT_TO_WIN32 ( E_OUTOFMEMORY ) );
					}
				}
				catch ( ... )
				{
					if (*pData)
					{
						delete [] ( *pData );
						(*pData) = NULL;
					}

					regErr = static_cast < DWORD > ( HRESULT_TO_WIN32 ( E_UNEXPECTED ) );
				}
			}
		}

		RegCloseKey ( reg );
	}

	return HRESULT_FROM_WIN32 ( regErr );
}

// get internal registry value
HRESULT	__stdcall GetRegistry ( LPCWSTR wszKey, LPCWSTR wszKeyValue, DWORD* pdwValue )
{
	// registry
	CRegKey reg;
	LONG	regErr = HRESULT_TO_WIN32 ( E_INVALIDARG );

	if ( wszKey && wszKeyValue )
	{
		if ( pdwValue )
		{
			(*pdwValue) = 0L;

			regErr = reg.Open ( HKEY_LOCAL_MACHINE, wszKey );
			if ( regErr == ERROR_SUCCESS )
			{
				regErr = reg.QueryValue ( (*pdwValue), wszKeyValue );
			}
		}
		else
		{
			regErr = HRESULT_TO_WIN32 ( E_POINTER );
		}
	}

	return HRESULT_FROM_WIN32 ( regErr );
}

// get internal registry value
HRESULT	__stdcall GetRegistrySame ( LPCWSTR wszKey, LPCWSTR wszKeyValue, DWORD* pdwValue )
{
	// registry
	static	CRegKey reg;
	LONG	regErr		= ERROR_SUCCESS;

	if ( pdwValue )
	{
		(*pdwValue) = 0L;

		if ( ! (HKEY)reg )
		{
			regErr = reg.Open ( HKEY_LOCAL_MACHINE, wszKey );
		}

		if ( regErr == ERROR_SUCCESS )
		{
			regErr = reg.QueryValue ( (*pdwValue), wszKeyValue );
		}
	}
	else
	{
		regErr = HRESULT_TO_WIN32 ( E_POINTER );
	}

	return HRESULT_FROM_WIN32 ( regErr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\stllock.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  STLLOCK.CPP
//
//  This implements the STL lockit class to avoid linking to msvcprt.dll
//
//***************************************************************************

#include "precomp.h"

static CStaticCritSec g_cs_STL;

#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP

std::_Lockit::_Lockit()
{
    g_cs_STL.Enter();
}

std::_Lockit::~_Lockit()
{
    g_cs_STL.Leave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\refresherutils.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					refresherUtils.h
//
//	Abstract:
//
//					declaration of registry refresh exported functions and utils
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REFRESHERUTILS_H__
#define	__REFRESHERUTILS_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#include <polarity.h>

// helpers
LPWSTR	__stdcall GetWbemDirectory( BOOL bIncludePerformance = TRUE );
HMODULE	__stdcall GetResourceDll();

// registry helpers
HRESULT	__stdcall	SetRegistry		(	LPCWSTR wszKey,
									LPCWSTR wszKeyValue,
									BYTE* pData,
									DWORD dwDataSize,
									LPSECURITY_ATTRIBUTES pSA = NULL
							);

HRESULT	__stdcall	SetRegistry		(	LPCWSTR wszKey,
									LPCWSTR wszKeyValue,
									DWORD dwValue,
									LPSECURITY_ATTRIBUTES pSA = NULL
							);

HRESULT	__stdcall	GetRegistry		( LPCWSTR wszKey, LPCWSTR wszKeyValue, BYTE** pData );
HRESULT	__stdcall	GetRegistry		( LPCWSTR wszKey, LPCWSTR wszKeyValue, DWORD * pdwValue );
HRESULT	__stdcall	GetRegistrySame ( LPCWSTR wszKey, LPCWSTR wszKeyValue, DWORD * pdwValue );

#endif	__REFRESHERUTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\refresherstuff.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					RefresherStuff.cpp
//
//	Abstract:
//
//					module for refresher stuff
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "RefresherUtils.h"
#include "RefresherStuff.h"

#include "wmi_perf_generate.h"

// wmi

#ifdef	_ASSERT
#undef	_ASSERT
#endif	__ASSERT

#include <wmicom.h>
#include <wmimof.h>

///////////////////////////////////////////////////////////////////////////////
// this call back is needed by the wdmlib function
///////////////////////////////////////////////////////////////////////////////
void WINAPI EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG_PTR Context)
{
	return;
}

/////////////////////////////////////////////////////////////////////////////
//
//	Helpers
//
/////////////////////////////////////////////////////////////////////////////

extern LPCWSTR	g_szKey;
extern LPCWSTR	g_szKeyValue;
extern LPCWSTR	g_szKeyRefresh;
extern LPCWSTR	g_szKeyRefreshed;

LONG				g_lRefCIM		= 0;			//	count of threads attached into CIMV2 namespace
LONG				g_lRefWMI		= 0;			//	count of threads attached into WMI namespace

__SmartHANDLE		g_hDoneWorkEvtCIM	= NULL;		//	event to set when init/uninit is finished done		( nonsignaled )
BOOL				g_bWorkingCIM		= FALSE;	//	boolean used to tell if init/unit in progress

__SmartHANDLE		g_hDoneWorkEvtWMI	= NULL;		//	event to set when init/uninit is finished done		( nonsignaled )
BOOL				g_bWorkingWMI		= FALSE;	//	boolean used to tell if init/unit in progress

extern	__SmartHANDLE	g_hRefreshMutex;
extern	__SmartHANDLE	g_hRefreshMutexLib;
extern	__SmartHANDLE	g_hRefreshFlag;

extern	LPCWSTR	g_szLibraryName;
extern	LPCWSTR	g_szQuery;

LONG			g_lGenerateCount = 0;

///////////////////////////////////////////////////////////////////////////////
// variables
///////////////////////////////////////////////////////////////////////////////
extern LPCWSTR	g_szNamespace1;
extern LPCWSTR	g_szNamespace2;

extern LPCWSTR	g_szWmiReverseAdapSetLodCtr		;
extern LPCWSTR	g_szWmiReverseAdapLodCtrDone	;

///////////////////////////////////////////////////////////////////////////////
// construction
///////////////////////////////////////////////////////////////////////////////
WmiRefresherStuff::WmiRefresherStuff() :

m_pServices_CIM ( NULL ),
m_pServices_WMI	( NULL ),

m_hLibHandle ( NULL ),
m_WMIHandle ( NULL ),

m_bConnected ( FALSE )

{
	WMIHandleInit ();
}

///////////////////////////////////////////////////////////////////////////////
// destruction
///////////////////////////////////////////////////////////////////////////////
WmiRefresherStuff::~WmiRefresherStuff()
{
	WMIHandleUninit ();
	Uninit ();
}

HRESULT	WmiRefresherStuff::Connect ()
{
	HRESULT hRes = S_FALSE;

	if SUCCEEDED ( hRes = ::CoInitializeEx ( NULL, COINIT_MULTITHREADED ) )
	{
		m_bConnected = TRUE;

		// locator stuff
		hRes =	::CoCreateInstance
		(
				__uuidof ( WbemLocator ),
				NULL,
				CLSCTX_INPROC_SERVER,
				__uuidof ( IWbemLocator ),
				(void**) & ( m_spLocator )
		);

		if SUCCEEDED ( hRes )
		{
			if SUCCEEDED (::CoSetProxyBlanket	(	m_spLocator, 
													RPC_C_AUTHN_WINNT,
													RPC_C_AUTHZ_NONE,
													NULL,
													RPC_C_AUTHN_LEVEL_CONNECT,
													RPC_C_IMP_LEVEL_IMPERSONATE,
													NULL,
													EOAC_NONE
												)
						 )
			{
				// IUnknown has to be secured too
				CComPtr < IUnknown >	pUnk;

				if ( SUCCEEDED( m_spLocator->QueryInterface( IID_IUnknown, (void**) &pUnk ) ) )
				{
					::CoSetProxyBlanket	(	pUnk,
											RPC_C_AUTHN_WINNT,
											RPC_C_AUTHZ_NONE,
											NULL,
											RPC_C_AUTHN_LEVEL_CONNECT,
											RPC_C_IMP_LEVEL_IMPERSONATE,
											NULL,
											EOAC_NONE
										);
				}	
			}
		}
	}

	return hRes;
}

HRESULT	WmiRefresherStuff::Disconnect ()
{
	HRESULT hRes = S_FALSE;

	if ( m_bConnected )
	{
		if ( m_spLocator.p != NULL )
		{
			m_spLocator.Release();
		}

		::CoUninitialize ( );
		hRes = S_OK;
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// init
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiRefresherStuff::Init ( )
{
	HRESULT hRes = E_UNEXPECTED;

	if ( ! m_spLocator == FALSE )
	{
		Init_CIM ();
		Init_WMI ();

		hRes = S_OK;
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// uninit
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiRefresherStuff::Uninit ( )
{
	Uninit_CIM();
	Uninit_WMI();

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// init namespace CIMV2
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiRefresherStuff::Init_CIM ( )
{
	///////////////////////////////////////////////////////////////////////////
	// variables
	///////////////////////////////////////////////////////////////////////////
	HRESULT	hRes = E_FAIL;
	BOOL bWait = TRUE;
	BOOL bDoWork = FALSE;


	while (bWait)
	{
		try
		{
			::EnterCriticalSection ( &m_csWMI );
		}
		catch ( ... )
		{
			return E_OUTOFMEMORY;
		}

		if ( g_lRefCIM == 0 )
		{
			bDoWork = TRUE;
			g_lRefCIM++;
			g_bWorkingCIM = TRUE;
			::ResetEvent(g_hDoneWorkEvtCIM);
			bWait = FALSE;
		}
		else
		{
			if ( g_bWorkingCIM )
			{
				::LeaveCriticalSection ( &m_csWMI );
				
				if ( WAIT_OBJECT_0 != ::WaitForSingleObject( g_hDoneWorkEvtCIM, INFINITE ) )
				{
					return  hRes;
				}
			}
			else
			{
				bWait = FALSE;
				g_lRefCIM++;
				hRes = S_OK;
			}
		}
	}

	::LeaveCriticalSection( &m_csWMI );

	if (bDoWork)
	{
		if ( m_spLocator.p != NULL && ! m_pServices_CIM )
		{
			///////////////////////////////////////////////////////////////////////
			// namespace for cimv2
			///////////////////////////////////////////////////////////////////////
			if SUCCEEDED ( hRes = m_spLocator ->ConnectServer(	CComBSTR ( g_szNamespace1 ) ,	// NameSpace Name
																NULL,							// UserName
																NULL,							// Password
																NULL,							// Locale
																0L,								// Security Flags
																NULL,							// Authority
																NULL,							// Wbem Context
																&m_pServices_CIM				// Namespace
															  )
					  )
			{
				// Before refreshing, we need to ensure that security is correctly set on the
				// namespace as the refresher will use those settings when it communicates with
				// WMI.  This is especially important in remoting scenarios.

				if SUCCEEDED (hRes = ::CoSetProxyBlanket	(	m_pServices_CIM, 
																RPC_C_AUTHN_WINNT,
																RPC_C_AUTHZ_NONE,
																NULL,
																RPC_C_AUTHN_LEVEL_CONNECT,
																RPC_C_IMP_LEVEL_IMPERSONATE,
																NULL,
																EOAC_NONE
															)
							 )
				{
					// IUnknown has to be secured too
					CComPtr < IUnknown >	pUnk;

					if ( SUCCEEDED(hRes = m_pServices_CIM->QueryInterface( IID_IUnknown, (void**) &pUnk ) ) )
					{
						hRes = ::CoSetProxyBlanket	(	pUnk,
														RPC_C_AUTHN_WINNT,
														RPC_C_AUTHZ_NONE,
														NULL,
														RPC_C_AUTHN_LEVEL_CONNECT,
														RPC_C_IMP_LEVEL_IMPERSONATE,
														NULL,
														EOAC_NONE
													);
					}	
				}

				if (FAILED(hRes))
				{
					m_pServices_CIM->Release();
					m_pServices_CIM = NULL;
				}
			}
		}
		else
		{
			IWbemServices* p = NULL;
			p = m_pServices_CIM;

			try
			{
				if ( p )
				{
					p->AddRef();
				}
			}
			catch ( ... )
			{
				hRes = E_UNEXPECTED;
			}
		}

		try
		{
			::EnterCriticalSection ( &m_csWMI );
		}
		catch (...)
		{
			//no choice have to give others a chance!
			if FAILED ( hRes )
			{
				g_lRefCIM--;
			}

			g_bWorkingCIM = FALSE;
			::SetEvent( g_hDoneWorkEvtCIM );

			return E_OUTOFMEMORY;
		}

		if FAILED ( hRes )
		{
			g_lRefCIM--;
		}

		g_bWorkingCIM = FALSE;
		::SetEvent ( g_hDoneWorkEvtCIM );
		::LeaveCriticalSection ( &m_csWMI );
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// uninit namespace CIMV2
///////////////////////////////////////////////////////////////////////////////
void	WmiRefresherStuff::Uninit_CIM ( )
{
	try
	{
		::EnterCriticalSection ( &m_csWMI );
	}
	catch ( ... )
	{
		return;
	}

	if ( g_lRefCIM == 1 )
	{
		IWbemServices * p = NULL;

		if ( m_pServices_CIM )
		{
			p = m_pServices_CIM;
			m_pServices_CIM = NULL;
		}

		try
		{
			if ( p )
			{
				p -> Release ();
				p = NULL;
			}
		}
		catch ( ... )
		{
		}
	}

	if ( g_lRefCIM )
	{
		g_lRefCIM--;
	}

	::LeaveCriticalSection( &m_csWMI );
}

///////////////////////////////////////////////////////////////////////////////
// init namespace WMI
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiRefresherStuff::Init_WMI ( )
{
	///////////////////////////////////////////////////////////////////////////
	// variables
	///////////////////////////////////////////////////////////////////////////
	HRESULT	hRes = E_FAIL;
	BOOL bWait = TRUE;
	BOOL bDoWork = FALSE;


	while (bWait)
	{
		try
		{
			::EnterCriticalSection ( &m_csWMI );
		}
		catch ( ... )
		{
			return E_OUTOFMEMORY;
		}

		if (g_lRefWMI  == 0 )
		{
			bDoWork = TRUE;
			g_lRefWMI++;
			g_bWorkingWMI = TRUE;
			::ResetEvent(g_hDoneWorkEvtWMI);
			bWait = FALSE;
		}
		else
		{
			if ( g_bWorkingWMI )
			{
				::LeaveCriticalSection ( &m_csWMI );
				
				if ( WAIT_OBJECT_0 != ::WaitForSingleObject( g_hDoneWorkEvtWMI, INFINITE ) )
				{
					return  hRes;
				}
			}
			else
			{
				bWait = FALSE;
				g_lRefWMI++;
				hRes = S_OK;
			}
		}
	}

	::LeaveCriticalSection( &m_csWMI );

	if (bDoWork)
	{
		if ( m_spLocator.p != NULL && ! m_pServices_WMI )
		{
			///////////////////////////////////////////////////////////////////////
			// namespace for cimv2
			///////////////////////////////////////////////////////////////////////
			if SUCCEEDED ( hRes = m_spLocator ->ConnectServer(	CComBSTR ( g_szNamespace2 ) ,	// NameSpace Name
																NULL,							// UserName
																NULL,							// Password
																NULL,							// Locale
																0L,								// Security Flags
																NULL,							// Authority
																NULL,							// Wbem Context
																&m_pServices_WMI				// Namespace
															  )
					  )
			{
				// Before refreshing, we need to ensure that security is correctly set on the
				// namespace as the refresher will use those settings when it communicates with
				// WMI.  This is especially important in remoting scenarios.

				if SUCCEEDED (hRes = ::CoSetProxyBlanket	(	m_pServices_WMI, 
																RPC_C_AUTHN_WINNT,
																RPC_C_AUTHZ_NONE,
																NULL,
																RPC_C_AUTHN_LEVEL_CONNECT,
																RPC_C_IMP_LEVEL_IMPERSONATE,
																NULL,
																EOAC_NONE
															)
							 )
				{
					// IUnknown has to be secured too
					CComPtr < IUnknown >	pUnk;

					if ( SUCCEEDED(hRes = m_pServices_WMI->QueryInterface( IID_IUnknown, (void**) &pUnk ) ) )
					{
						hRes = ::CoSetProxyBlanket	(	pUnk,
														RPC_C_AUTHN_WINNT,
														RPC_C_AUTHZ_NONE,
														NULL,
														RPC_C_AUTHN_LEVEL_CONNECT,
														RPC_C_IMP_LEVEL_IMPERSONATE,
														NULL,
														EOAC_NONE
													);
					}	
				}

				if (FAILED(hRes))
				{
					m_pServices_WMI->Release();
					m_pServices_WMI = NULL;
				}
			}
		}
		else
		{
			IWbemServices* p = NULL;
			p = m_pServices_WMI;

			try
			{
				if ( p )
				{
					p->AddRef();
				}
			}
			catch ( ... )
			{
				hRes = E_UNEXPECTED;
			}
		}

		try
		{
			::EnterCriticalSection ( &m_csWMI );
		}
		catch (...)
		{
			//no choice have to give others a chance!
			if FAILED ( hRes )
			{
				g_lRefWMI--;
			}

			g_bWorkingWMI = FALSE;
			::SetEvent( g_hDoneWorkEvtWMI );

			return E_OUTOFMEMORY;
		}

		if FAILED ( hRes )
		{
			g_lRefWMI--;
		}

		g_bWorkingWMI = FALSE;
		::SetEvent ( g_hDoneWorkEvtWMI );
		::LeaveCriticalSection ( &m_csWMI );
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// uninit namespace WMI
///////////////////////////////////////////////////////////////////////////////
void	WmiRefresherStuff::Uninit_WMI ( )
{
	try
	{
		::EnterCriticalSection ( &m_csWMI );
	}
	catch ( ... )
	{
		return;
	}

	if ( g_lRefWMI == 1 )
	{
		IWbemServices * p = NULL;

		if ( m_pServices_WMI )
		{
			p = m_pServices_WMI;
			m_pServices_WMI = NULL;
		}

		try
		{
			if ( p )
			{
				p -> Release ();
				p = NULL;
			}
		}
		catch ( ... )
		{
		}
	}

	if ( g_lRefWMI )
	{
		g_lRefWMI--;
	}

	::LeaveCriticalSection( &m_csWMI );

}

#include <loadperf.h>
extern LPCWSTR	g_szKeyCounter;

///////////////////////////////////////////////////////////////////////////////
// load/unload counter helper
///////////////////////////////////////////////////////////////////////////////
LONG WmiRefresherStuff::LodCtrUnlodCtr ( LPCWSTR wszName, BOOL bLodctr )
{
	LONG		lErr	= E_OUTOFMEMORY;

	if ( ! wszName )
	{
		lErr = E_INVALIDARG;
	}
	else
	{
		// synchronization
		BOOL	bContinue		= FALSE;
		BOOL	bSynchronize	= FALSE;

		DWORD	dwWaitResult	= 0L;

		__SmartHANDLE	hWmiReverseAdapSetLodCtr		;
		__SmartHANDLE	hWmiReverseAdapLodCtrDone		;

		hWmiReverseAdapSetLodCtr	= ::OpenEvent ( EVENT_MODIFY_STATE, FALSE, g_szWmiReverseAdapSetLodCtr );
		hWmiReverseAdapLodCtrDone	= ::OpenEvent ( SYNCHRONIZE, FALSE, g_szWmiReverseAdapLodCtrDone );

		if ( hWmiReverseAdapSetLodCtr.GetHANDLE () && hWmiReverseAdapLodCtrDone.GetHANDLE () )
		{
			bSynchronize = TRUE;
		}
		else
		{
			bContinue = TRUE;
		}

		if ( bSynchronize )
		{
			if ( ::SetEvent ( hWmiReverseAdapSetLodCtr ) == TRUE )
			{
				bContinue = TRUE;
			}
		}

		if ( bContinue )
		{
			if ( bLodctr )
			{
				CRegKey		rKey;

				// delete registry first
				if ( rKey.Open (	HKEY_LOCAL_MACHINE,
									g_szKeyCounter,
									KEY_SET_VALUE | DELETE
							   )

					 == ERROR_SUCCESS )
				{
					rKey.DeleteValue ( L"First Counter" );
					rKey.DeleteValue ( L"First Help" );
					rKey.DeleteValue ( L"Last Counter" );
					rKey.DeleteValue ( L"Last Help" );
				}

				rKey.Close();

				///////////////////////////////////////////////////////////////////////////
				// create path
				///////////////////////////////////////////////////////////////////////////
				LPWSTR	tsz		= NULL;

				if ( ( tsz = GetWbemDirectory ( ) ) != NULL )
				{
					WCHAR* szName = NULL;
					try
					{
						DWORD cchSize = 3 + lstrlenW ( tsz ) + lstrlenW ( wszName ) + 4 + 1;
						if ( ( szName = new WCHAR [ cchSize ] ) != NULL )
						{
							StringCchPrintfW ( szName, cchSize, L"xx %s%s.ini", tsz, wszName );

							if ( ( lErr = LoadPerfCounterTextStringsW ( szName, TRUE ) ) != ERROR_SUCCESS )
							{
								::SetLastError ( lErr );
							}
						}
					}
					catch ( ... )
					{
						lErr = E_UNEXPECTED;
					}

					if ( szName )
					{
						delete [] szName;
						szName = NULL;
					}

					delete [] tsz;
					tsz = NULL;
				}
			}
			else
			{
				WCHAR* szName = NULL;
				try
				{
					DWORD cchSize = 3 + lstrlenW ( wszName ) + 1;
					if ( ( szName = new WCHAR [ cchSize ] ) != NULL )
					{
						StringCchPrintfW ( szName, cchSize, L"xx %s", wszName );

						if ( ( lErr = UnloadPerfCounterTextStringsW ( szName, TRUE ) ) != ERROR_SUCCESS )
						{
							::SetLastError ( lErr );
						}
					}
				}
				catch ( ... )
				{
					lErr = E_UNEXPECTED;
				}

				if ( szName )
				{
					delete [] szName;
					szName = NULL;
				}
			}

			if ( bSynchronize )
			{
				// wait for ADAP to be done
				dwWaitResult = ::WaitForSingleObject ( hWmiReverseAdapLodCtrDone, 3000 );
				if ( dwWaitResult != WAIT_OBJECT_0 )
				{
					// something went wrong ?
					lErr = E_FAIL;
				}
			}
		}
		else
		{
			// we failed to synchronize so no action has taken
			lErr = E_FAIL;
		}
	}

	return lErr;
}

HRESULT WmiRefresherStuff::Generate ( BOOL bThrottle, GenerateEnum type )
{
	HRESULT	hRes			= E_FAIL;

	BOOL	bOwnMutex		= FALSE;
	BOOL	bLocked			= FALSE;
	DWORD	dwWaitResult	= 0L;

	DWORD	dwHandles	= 2;
	HANDLE	hHandles[]	=
	{
		g_hRefreshMutex,
		g_hRefreshMutexLib
	};

	dwWaitResult = ::WaitForMultipleObjects ( dwHandles, hHandles, TRUE, 0 );
	if ( dwWaitResult == WAIT_TIMEOUT )
	{
		bLocked = TRUE;
	}
	else
	{
		if ( dwWaitResult == WAIT_OBJECT_0 )
		{
			bOwnMutex	= TRUE;
			hRes		= S_FALSE;
		}
	}

	if ( bLocked )
	{
		dwWaitResult = ::WaitForSingleObject ( g_hRefreshFlag, 0 );
		if ( dwWaitResult == WAIT_OBJECT_0 )
		{
			hRes = SetRegistry ( g_szKey, g_szKeyRefresh, 1 );
			::ReleaseMutex ( g_hRefreshFlag );
		}
	}
	else
	{
		if SUCCEEDED ( hRes )
		{
			if ( type == Normal )
			{
				try
				{
					// connect to management
					Init();
				}
				catch ( ... )
				{
				}
			}

			try
			{
				hRes = GenerateInternal ( bThrottle, type );

				if SUCCEEDED ( hRes )
				{
					if ( type != UnRegistration )
					{
						// change flag to let them now we are done
						dwWaitResult = ::WaitForSingleObject ( g_hRefreshFlag, INFINITE );
						if ( dwWaitResult == WAIT_OBJECT_0 )
						{
							if ( type == Registration )
							{
								hRes = SetRegistry ( g_szKey, g_szKeyRefresh, 1 );
								hRes = SetRegistry ( g_szKey, g_szKeyRefreshed, 0 );
							}
							else
							{
								hRes = SetRegistry ( g_szKey, g_szKeyRefresh, 0 );
								hRes = SetRegistry ( g_szKey, g_szKeyRefreshed, 1 );
							}

							::ReleaseMutex ( g_hRefreshFlag );
						}
					}
				}
			}
			catch ( ... )
			{
				hRes = E_UNEXPECTED;
			}

			if ( type == Normal )
			{
				try
				{
					// disconnect from management
					Uninit();
				}
				catch ( ... )
				{
				}
			}
		}
	}

	if ( bOwnMutex )
	{
		::ReleaseMutex ( g_hRefreshMutex );
		::ReleaseMutex ( g_hRefreshMutexLib );
	}

	return hRes;
}

HRESULT WmiRefresherStuff::GenerateInternal ( BOOL bThrottle, GenerateEnum type )
{
	HRESULT	hRes = S_OK;

	if ( ::InterlockedCompareExchange ( &g_lGenerateCount, 1, 0 ) == 0 )
	{
		if ( type == UnRegistration )
		{
			// lodctr / unlodctr functionality
			LodCtrUnlodCtr ( g_szLibraryName, FALSE );
		}
		else
		{
			// generate wrapper
			CGenerate	generate;

			if ( type == Normal )
			{
				// generate for cimv2
				if ( m_pServices_CIM )
				{
					generate.Generate ( m_pServices_CIM, g_szQuery, g_szNamespace1, TRUE );

					if ( generate.m_dwlcid == 2 )
					{
						generate.Generate ( m_pServices_CIM, g_szQuery, g_szNamespace1, FALSE );
					}
				}

				// generate for wmi
				if ( m_pServices_WMI )
				{
					generate.Generate ( m_pServices_WMI, g_szQuery, g_szNamespace2, TRUE );

					if ( generate.m_dwlcid == 2 )
					{
						generate.Generate ( m_pServices_WMI, g_szQuery, g_szNamespace2, FALSE );
					}
				}
			}

			// generate appropriate h file
			if SUCCEEDED ( hRes = generate.GenerateFile_h		( g_szLibraryName, bThrottle, type ) )
			{
				// generate appropriate ini file
				if SUCCEEDED ( hRes = generate.GenerateFile_ini	( g_szLibraryName, bThrottle, type ) )
				{
					// lodctr / unlodctr functionality
					LodCtrUnlodCtr ( g_szLibraryName, FALSE );
					// lodctr / unlodctr functionality
					LodCtrUnlodCtr ( g_szLibraryName, TRUE );

					if ( type == Normal )
					{
						// generate appropriate registry
						if FAILED( hRes = generate.GenerateRegistry	( g_szKey, g_szKeyValue, bThrottle ) )
						{
							#ifdef	__SUPPORT_MSGBOX
							ERRORMESSAGE_DEFINITION;
							ERRORMESSAGE ( hRes );
							#else	__SUPPORT_MSGBOX
							___TRACE_ERROR( L"generate registry failed",hRes );
							#endif	__SUPPORT_MSGBOX
						}

						// call wdm lib function to take care of 
						CWMIBinMof wmi;
						if SUCCEEDED ( wmi.Initialize ( NULL,FALSE ) )
						{
							wmi.CopyWDMKeyToDredgeKey ();
						}
					}
				}
				else
				{
					#ifdef	__SUPPORT_MSGBOX
					ERRORMESSAGE_DEFINITION;
					ERRORMESSAGE ( hRes );
					#else	__SUPPORT_MSGBOX
					___TRACE_ERROR( L"generate ini failed",hRes );
					#endif	__SUPPORT_MSGBOX
				}
			}
			else
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"generate header failed",hRes );
				#endif	__SUPPORT_MSGBOX
			}

			// unitialize global resources used by generate
			generate.Uninitialize ();
		}

		::InterlockedDecrement ( &g_lGenerateCount );
	}

	return hRes;
}

#define	MAX_MODULES	1024

HRESULT	WmiRefresherStuff::WMIHandleInit ( void )
{
	HRESULT hRes = S_FALSE;

    if ( m_hLibHandle == NULL)
	{
		WCHAR szSystemDir [ _MAX_PATH + 1 ] = { L'\0' };
		DWORD cchSize = GetSystemDirectory ( szSystemDir, _MAX_PATH+1 );

		if ( cchSize > _MAX_PATH+1 )
		{
			hRes = E_UNEXPECTED;
		}
		else
		{
			WCHAR szPath [ _MAX_PATH + 1 ];
			if ( SUCCEEDED ( hRes = StringCchCopyW ( szPath, cchSize + 1, szSystemDir ) ) )
			{
				if ( szPath [ cchSize ] != L'\\' )
				{
					hRes = StringCchCatW ( szPath, _MAX_PATH + 1, L"\\" );
				}

				if ( SUCCEEDED ( hRes ) )
				{
					if ( SUCCEEDED ( hRes = StringCchCatW ( szPath, _MAX_PATH + 1, L"PSAPI.DLL" ) ) )
					{
						if ( ( m_hLibHandle = LoadLibraryW ( szPath ) ) == NULL )
						{
							hRes = HRESULT_FROM_WIN32 ( ERROR_DLL_NOT_FOUND );
						}
						else
						{
							m_pEnumProcesses	= (PSAPI_ENUM_PROCESSES)	GetProcAddress ( m_hLibHandle, "EnumProcesses" ) ;
							m_pEnumModules		= (PSAPI_ENUM_MODULES)		GetProcAddress ( m_hLibHandle, "EnumProcessModules" ) ;
							m_pGetModuleName	= (PSAPI_GET_MODULE_NAME)	GetProcAddress ( m_hLibHandle, "GetModuleBaseNameW" ) ;

							if	(	m_pEnumProcesses == NULL	||
									m_pEnumModules == NULL		||
									m_pGetModuleName == NULL
								)
							{
								hRes = HRESULT_FROM_WIN32 ( ERROR_PROC_NOT_FOUND );
							}
							else
							{
								hRes = S_OK;
							}
						}
					}
				}
			}
		}
	}

	return hRes;
}

void	WmiRefresherStuff::WMIHandleUninit ( void )
{
	if ( m_hLibHandle )
	{
		::FreeLibrary ( m_hLibHandle );
		m_hLibHandle = NULL;
	}
}

HRESULT	WmiRefresherStuff::WMIHandleOpen ( void )
{
	if (	! m_hLibHandle		||
			! m_pEnumProcesses	||
			! m_pEnumModules	||
			! m_pGetModuleName
	   )
	{
		return E_UNEXPECTED;
	}

	HRESULT hRes = E_OUTOFMEMORY;

	DWORD dw = 1;
	DWORD dwSize = dw * MAX_MODULES;
	DWORD dwNeed = 0;
	DWORD * pProcId = NULL;

	BOOL bContinue = TRUE;

	try
	{
		pProcId = new DWORD [ dwSize ];
	}
	catch ( ... )
	{
		if ( pProcId )
		{
			delete [] pProcId;
			pProcId = NULL;
		}

		hRes = E_UNEXPECTED;
	}

	if ( pProcId )
	{
		do
		{
			if ( m_pEnumProcesses ( pProcId, dwSize * sizeof ( DWORD ), &dwNeed ) == FALSE )
			{
				dw++;

				delete [] pProcId;
				pProcId = NULL;

				dwSize = dw * MAX_MODULES;

				if ( dw <= 4 )
				{
					try
					{
						pProcId = new DWORD [ dwSize ];
					}
					catch ( ... )
					{
						if ( pProcId )
						{
							delete [] pProcId;
							pProcId = NULL;
						}

						hRes = E_UNEXPECTED;
					}
				}
			}
			else
			{
				bContinue = FALSE;
			}
		}
		while ( pProcId && bContinue && dw <= 4 );

		if ( pProcId && bContinue == FALSE )
		{
			bContinue = TRUE;

			DWORD	dwSizeModules = MAX_MODULES;
			HMODULE * pModules = NULL;

			try
			{
				pModules = new HMODULE [ dwSizeModules ];
			}
			catch ( ... )
			{
				if ( pModules )
				{
					delete [] pModules;
					pModules = NULL;
				}

				hRes = E_UNEXPECTED;
			}

			if ( pModules )
			{
				hRes = E_FAIL;

				DWORD dwRetModules = 0L;
				dwNeed = dwNeed / sizeof ( DWORD );

				for ( DWORD i = 0; i < dwNeed && bContinue; i++ )
				{
					HANDLE hProcess = NULL;
					if ( ( hProcess = ::OpenProcess (	PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
														FALSE,
														pProcId [ i ]
													)
						 ) != NULL
					   )
					{
						if ( m_pEnumModules ( hProcess, pModules, dwSizeModules * sizeof ( DWORD ), &dwRetModules ) )
						{
							WCHAR ModuleName [ MAX_PATH ] = { L'\0' };

							if ( m_pGetModuleName (	hProcess,
													pModules[0], // first module is executable
													ModuleName,
													sizeof ( ModuleName ) / sizeof ( WCHAR )
												  )
							   )
							{					    
								if ( 0 == _wcsicmp ( L"svchost.exe", ModuleName ) )
								{
									for ( DWORD dwModuleIndex = 1; dwModuleIndex < dwRetModules && bContinue; dwModuleIndex++ )
									{
										if ( m_pGetModuleName (	hProcess,
																pModules[dwModuleIndex],
																ModuleName,
																sizeof ( ModuleName ) / sizeof ( WCHAR )
															  )
										   )
										{
											if ( 0 == _wcsicmp ( L"wmisvc.dll", ModuleName ) )
											{
												hRes = S_OK;
												bContinue = FALSE;
											}
										}
									}
								}
							}
						}

						if ( bContinue )
						{
							CloseHandle ( hProcess );
							hProcess = NULL;
						}
					}

					if ( hRes == S_OK )
					{
						m_WMIHandle = hProcess;
					}
				}

				delete [] pModules;
				pModules = NULL;
			}
		}

		delete [] pProcId;
		pProcId = NULL;
	}

	return hRes;
}

void	WmiRefresherStuff::WMIHandleClose ( void )
{
	if ( m_WMIHandle )
	{
		::CloseHandle ( m_WMIHandle );
		m_WMIHandle = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\refresherstuff.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					refresherstuff.h
//
//	Abstract:
//
//					declaration of stuff for refresh
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REFRESHER_STUFF_H__
#define	__REFRESHER_STUFF_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#include "refreshergenerate.h"
#include <psapi.h>

///////////////////////////////////////////////////////////////////////////////
// I would need to have this function
///////////////////////////////////////////////////////////////////////////////

typedef BOOL  (WINAPI *PSAPI_ENUM_PROCESSES) (DWORD    *pdwPIDList,        // Pointer to DWORD array
                                              DWORD     dwListSize,        // Size of array
                                              DWORD    *pdwByteCount) ;    // Bytes needed/returned

typedef BOOL  (WINAPI *PSAPI_ENUM_MODULES)   (HANDLE    hProcess,          // Process to query
                                              HMODULE  *pModuleList,       // Array of HMODULEs
                                              DWORD     dwListSize,        // Size of array
                                              DWORD    *pdwByteCount) ;    // Bytes needed/returned

typedef DWORD (WINAPI *PSAPI_GET_MODULE_NAME)(HANDLE    hProcess,          // Process to query
                                              HMODULE   hModule,           // Module to query
                                              LPWSTR     pszName,          // Pointer to name buffer
                                              DWORD     dwNameSize) ;      // Size of buffer

///////////////////////////////////////////////////////////////////////////////
// refresher stuff
///////////////////////////////////////////////////////////////////////////////
class WmiRefresherStuff
{
	DECLARE_NO_COPY ( WmiRefresherStuff );

	BOOL						m_bConnected;

	CStaticCritSec				m_csWMI;

	public:

	CComPtr < IWbemLocator >	m_spLocator;
	IWbemServices*				m_pServices_CIM;
	IWbemServices*				m_pServices_WMI;

	// construction & destruction
	WmiRefresherStuff();
	~WmiRefresherStuff();

	///////////////////////////////////////////////////////
	// construction & destruction helpers
	///////////////////////////////////////////////////////
	public:
	HRESULT Init ( void );
	HRESULT	Uninit ( void );

	HRESULT	Connect ( void );
	HRESULT Disconnect ( void );

	HRESULT Generate ( BOOL bThrottle, GenerateEnum type = Normal );

	private:

	HRESULT Init_CIM ( void );
	HRESULT Init_WMI ( void );

	void Uninit_CIM ( void );
	void Uninit_WMI ( void );

	///////////////////////////////////////////////////////
	// generate files & registry
	///////////////////////////////////////////////////////
	HRESULT GenerateInternal	( BOOL bThrottle, GenerateEnum type = Normal );
	LONG	LodCtrUnlodCtr		( LPCWSTR wszName, BOOL bLodctr );

	///////////////////////////////////////////////////////
	// process handle
	///////////////////////////////////////////////////////

	HINSTANCE				m_hLibHandle ;
	PSAPI_ENUM_PROCESSES    m_pEnumProcesses ;
	PSAPI_ENUM_MODULES	    m_pEnumModules ;
	PSAPI_GET_MODULE_NAME	m_pGetModuleName;

	// functions
	HRESULT	WMIHandleInit ();
	void	WMIHandleUninit ();

	HANDLE	m_WMIHandle;

	public:

	HRESULT	WMIHandleOpen ();
	void	WMIHandleClose ();

	HANDLE	GetWMI () const
	{
		return m_WMIHandle;
	}
};

#endif	__REFRESHER_STUFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_generate.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_generate.h
//
//	Abstract:
//
//					decalaration of generate everything wrapper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_GENERATE__
#define	__WMI_PERF_GENERATE__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#include "refreshergenerate.h"

#ifndef	__WMI_PERF_OBJECT_LOCALE__
#include "wmi_perf_object_global.h"
#endif	__WMI_PERF_OBJECT_LOCALE__

class CGenerate
{
	DECLARE_NO_COPY ( CGenerate );

	// generate object global arrays
	// contains generated hi-perfs for all namspaces

	CObjectGlobal	m_pNamespaces[2];
	DWORD			m_dwNamespaces;

	LCID			m_lcid[2];

	public:

	DWORD			m_dwlcid;

	// construction & destruction

	CGenerate() :
	m_hFile ( NULL ),
	m_dwNamespaces ( 0 )
	{
		m_lcid[0] = ::GetSystemDefaultLCID();
		m_lcid[1] = MAKELCID( MAKELANGID ( LANG_ENGLISH, SUBLANG_ENGLISH_US ), SORT_DEFAULT );

		if ( m_lcid[0] != m_lcid[1] )
		{
			m_dwlcid = 2;
		}
		else
		{
			m_dwlcid = 1;
		}
	}

	~CGenerate()
	{
	}

	HRESULT Generate ( IWbemServices* pServices, LPCWSTR szQuery, LPCWSTR szNamespace, BOOL bLocale = FALSE );

	// generate files
	HRESULT	GenerateFile_ini	( LPCWSTR wszModuleName, BOOL bThrottle, int type = Normal );
	HRESULT	GenerateFile_h		( LPCWSTR wszModuleName, BOOL bThrottle, int type = Normal );

	// generate registry
	HRESULT GenerateRegistry ( LPCWSTR wszKey, LPCWSTR wszValue, BOOL bThrottle );

	void	Uninitialize ( void );

	private:

	// helpers
	DWORD	GenerateIndexRegistry	( BOOL bInit = FALSE );
	LPWSTR	GenerateIndex			( void );
	LPWSTR	GenerateLanguage		( LCID lcid );
	LPWSTR	GenerateName			( LPCWSTR wszName, LCID lcid );
	LPWSTR	GenerateNameInd			( LPCWSTR wszName, DWORD dwObjIndex );

	HRESULT CreateObjectList ( BOOL bThrottle = FALSE );

	// string
	void	AppendString ( LPCWSTR src, DWORD dwSrcSize, DWORD& dwSrcSizeLeft );
	HRESULT	AppendString ( LPCWSTR src, BOOL bUnicode = TRUE );

	// handle to one of files
	__SmartHANDLE	m_hFile;

	// create files
	HRESULT FileCreate	( LPCWSTR lpwszFileName );
	HRESULT FileDelete	( LPCWSTR lpwszFileName );
	HRESULT FileMove	( LPCWSTR lpwszFileName, LPCWSTR lpwszFileNameNew );

	HRESULT	ContentWrite	( BOOL bUnicode = TRUE );
	void	ContentDelete	( );

	// write to file
	HRESULT	WriteToFile			( LPCWSTR wszContent );
	HRESULT	WriteToFileUnicode	( LPCWSTR wszContent );
};

#endif	__WMI_PERF_GENERATE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_common.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_common.cpp
//
//	Abstract:
//
//					declarations of common constants
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

LPCWSTR	g_szLibraryName		= L"WmiApRpl";

LPCWSTR	g_szRefreshMutex	= L"Global\\RefreshRA_Mutex";
LPCWSTR	g_szRefreshMutexLib	= L"Global\\RefreshRA_Mutex_Lib";
LPCWSTR	g_szRefreshFlag		= L"Global\\RefreshRA_Mutex_Flag";

LPCWSTR	g_szWmiReverseAdapSetLodCtr		= L"Global\\WMI_RevAdap_Set";
LPCWSTR	g_szWmiReverseAdapLodCtrDone	= L"Global\\WMI_RevAdap_ACK";

// namespaces
LPCWSTR	g_szNamespace1	= L"\\\\.\\root\\cimv2";
LPCWSTR	g_szNamespace2	= L"\\\\.\\root\\wmi";

// query language & queries
LPCWSTR	g_szQueryLang	= L"WQL";
LPCWSTR	g_szQuery		= L"select * from meta_class where __this isa \"Win32_PerfRawData\"";

LONG g_lFlag = WBEM_FLAG_FORWARD_ONLY;

// required qualifiers
LPCWSTR g_szFulFil[] = 
{
	L"provider",
	L"HiPerf"
};

// don't required qualifier
LPCWSTR g_szFulFilNot[] =
{
	L"abstract",
	L"generic",
	L"genericperfctr",
	L"cooked"
};

DWORD g_dwFulFil	= sizeof ( g_szFulFil ) / sizeof ( g_szFulFil[0] );
DWORD g_dwFulFilNot	= sizeof ( g_szFulFilNot ) / sizeof ( g_szFulFilNot[0] );

LONG g_lFlagProperties = WBEM_FLAG_LOCAL_ONLY | WBEM_FLAG_NONSYSTEM_ONLY;

// required qualifiers of property
LPCWSTR g_szPropNeed[] = 
{
	L"defaultscale",
	L"perfdetail"
};

// don't required qualifiers of property
LPCWSTR g_szPropNeedNot[];

DWORD	g_dwPropNeed	= sizeof ( g_szPropNeed ) / sizeof ( g_szPropNeed[0] );
DWORD	g_dwPropNeedNot	= 0;

// main filter for properties
LPCWSTR g_szPropFilter = L"countertype";

///////////////////////////////////////////////////////////////////////////////
// generate :))
///////////////////////////////////////////////////////////////////////////////

LPCWSTR	g_szWbem	= L"SOFTWARE\\Microsoft\\Wbem\\CIMOM";
LPCWSTR	g_szDir		= L"Working Directory";
LPCWSTR	g_szFolder	= L"\\Performance\\";

LPCWSTR	g_szKey				= L"SOFTWARE\\Microsoft\\WBEM\\PROVIDERS\\Performance";
LPCWSTR	g_szKeyValue		= L"Performance Data";
LPCWSTR	g_szKeyRefresh		= L"Performance Refresh";
LPCWSTR	g_szKeyRefreshed	= L"Performance Refreshed";

LPCWSTR	g_szKeyCounter	= L"SYSTEM\\CurrentControlSet\\Services\\WmiApRpl\\Performance";

// constants
LPCWSTR	cNEW		= L"\r\n";
LPCWSTR	cTAB		= L"\t";
LPCWSTR	cDEFINE		= L"#define	";

LPCWSTR	cDriverName	= L"drivername=";
LPCWSTR	cSymbolFile	= L"symbolfile=";

LPCWSTR	cSIGN		= L"=";

LPCWSTR	cinfo		= L"[info]\r\n";
LPCWSTR	cobjects	= L"[objects]\r\n";
LPCWSTR	clanguages	= L"[languages]\r\n";
LPCWSTR	ctext		= L"[text]\r\n";

LPCWSTR	cNAME		= L"NAME";
LPCWSTR	cHELP		= L"HELP";

LPCWSTR	cWMIOBJECTS				= L"WMI_Objects";
LPCWSTR	cWMIOBJECTS_COUNT		= L"HiPerf_Classes";
LPCWSTR	cWMIOBJECTS_VALIDITY	= L"HiPerf_Validity";

LPCWSTR	cWMIOBJECTS_NAME			= L"NAME=WMI Objects";
LPCWSTR	cWMIOBJECTS_COUNT_NAME		= L"NAME=HiPerf Classes";
LPCWSTR	cWMIOBJECTS_VALIDITY_NAME	= L"NAME=HiPerf Validity";

LPCWSTR	cWMIOBJECTS_HELP			= L"HELP=Number of WMI High Performance provider returned by WMI Adapter";
LPCWSTR	cWMIOBJECTS_COUNT_HELP		= L"HELP=Shows High Performance Classes";
LPCWSTR	cWMIOBJECTS_VALIDITY_HELP	= L"HELP=Shows if High Performance Classes are valid";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_generate_comment.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_generate_comment.cpp
//
//	Abstract:
//
//					declarations of comment helpers
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "wmi_perf_generate_comment.h"

HRESULT CGenerateComment::AddHeader ()
{
	HRESULT hr = S_OK;

	comment += L"//////////////////////////////////////////////////////////////////////////////////////////////\r\n";
	if ( ! comment )
	{
		hr = E_OUTOFMEMORY;
	}

	return hr;
}

HRESULT	CGenerateComment::AddFooter ()
{
	HRESULT hr = S_OK;

	if SUCCEEDED ( hr = AddHeader () )
	{
		if ( ! ( comment += L"\r\n" ) ) 
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}

HRESULT CGenerateComment::AddLine ( LPCWSTR szLine )
{
	HRESULT hr = S_OK;

	if ( ! szLine )
	{
		if ( ! ( comment += L"//\r\n" ) )
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		// test if line doesn't contain \n

		LPWSTR p = NULL;
		p = CharNextW ( szLine );

		while( p && p[0] != 0 )
		{
			p = CharNextW ( p );
			if ( p[0] == L'\n' )
			{
				hr = E_INVALIDARG;
			}
		}

		if SUCCEEDED ( hr )
		{
			if ( ! ( comment += L"// " ) )
			{
				hr = E_OUTOFMEMORY;
			}
			else
			if ( ! ( comment += szLine ) )
			{
				hr = E_OUTOFMEMORY;
			}
			else
			if ( ! ( comment += L"\r\n" ) )
			{
				hr = E_OUTOFMEMORY;
			}
		}
	}

	return hr;
}

HRESULT CGenerateComment::Add ( LPCWSTR szLine )
{
	HRESULT hr = S_OK;

	if ( ! szLine )
	{
		if ( ! ( comment += L"\r\n" ) )
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		if ( ! ( comment += szLine ) )
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_generate_comment.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_generate_comment.h
//
//	Abstract:
//
//					declaration of helpers for generate comment
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_GENERATE_COMMENT__
#define	__WMI_PERF_GENERATE_COMMENT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// need atlbase

#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

class CGenerateComment
{
	CComBSTR comment;

	CGenerateComment ( const CGenerateComment& )				{}
	CGenerateComment& operator= ( const CGenerateComment& )	{}

	public:

	// construction & destruction

	CGenerateComment()
	{
	}

	virtual ~CGenerateComment()
	{
	}

	// funtions

	HRESULT Add			( LPCWSTR szLine = NULL );
	HRESULT AddLine		( LPCWSTR szLine = NULL );

	HRESULT AddHeader	();
	HRESULT	AddFooter	();

	LPWSTR GetCommentCopy ( void )
	{
		LPWSTR res = NULL;
		try
		{
			if ( ( res = (LPWSTR) new WCHAR[ comment.Length() + 1 ] ) != NULL )
			{
				StringCchCopyW ( res, comment.Length() + 1, (LPWSTR)comment );
			}
		}
		catch ( ... )
		{
			if ( res )
			{
				delete [] res;
				res = NULL;
			}
		}

		return res;
	}

	LPWSTR GetComment( void ) const
	{
		return (LPWSTR)comment;
	}
};

#endif	__WMI_PERF_GENERATE_COMMENT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_generate_header.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_generate_header.cpp
//
//	Abstract:
//
//					implements generate functionality ( header file )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <throttle.h>

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// definitions
#include "wmi_perf_generate.h"
// generate comments
#include "wmi_perf_generate_comment.h"
// registry helpers
#include "wmi_perf_reg.h"

static DWORD	dwIndex = 0;

// constants
extern LPCWSTR	cNEW;
extern LPCWSTR	cTAB;
extern LPCWSTR	cDEFINE;

extern LPCWSTR	cWMIOBJECTS;
extern LPCWSTR	cWMIOBJECTS_COUNT;
extern LPCWSTR	cWMIOBJECTS_VALIDITY;

// generate index and its string represetation
LPWSTR	CGenerate::GenerateIndex ( )
{
	LPWSTR			wsz		= NULL;

	try
	{
		if ( ( wsz = new WCHAR [ 11 + 1 ] ) != NULL )
		{
			StringCchPrintfW ( wsz, 11 + 1, L"%d", ((dwIndex++)*2) );
		}
	}
	catch ( ... )
	{
		if ( wsz )
		{
			delete [] wsz;
			wsz = NULL;
		}
	}

	return wsz;
}

HRESULT CGenerate::GenerateFile_h( LPCWSTR wszModuleName, BOOL bThrottle, int type )
{
	HRESULT hRes		= S_FALSE;

	if ( ( wszModuleName == 0 || *wszModuleName == 0 ) || ( type == Normal && m_dwNamespaces == 0 ) )
	{
		hRes = E_UNEXPECTED;
	}
	else
	{
		LPWSTR	wszModule = NULL;

		try
		{
			#define EXT_NEW	L"_new.h"
			DWORD cchExtension = sizeof ( EXT_NEW ) / sizeof ( WCHAR );
			DWORD cchSize = lstrlenW ( wszModuleName ) + cchExtension + 1;
			if ( ( wszModule = new WCHAR [ cchSize ] ) == NULL )
			{
				hRes = E_OUTOFMEMORY;
			}
			else
			{
				if ( SUCCEEDED ( hRes = StringCchCopyW ( wszModule, cchSize, wszModuleName ) ) )
				{
					if ( SUCCEEDED ( hRes = StringCchCatW ( wszModule, cchSize, EXT_NEW ) ) )
					{
						if SUCCEEDED ( hRes = FileCreate ( wszModule ) )
						{
							// do comment stuff
							CGenerateComment comment;

							comment.AddHeader();
							comment.AddLine();
							comment.AddLine( L"Copyright (C) 2000 Microsoft Corporation" );
							comment.AddLine();
							comment.AddLine( L"Module Name:" );
							comment.AddLine( wszModuleName );
							comment.AddLine();
							comment.AddLine( L"Abstract:" );
							comment.AddLine();
							comment.AddLine( L"Include file for object and counters definitions." );
							comment.AddLine();
							comment.AddFooter();

							hRes = WriteToFile ( comment.GetComment() );
						}
					}
				}
			}
		}
		catch ( ... )
		{
			hRes = E_FAIL;
		}

		if SUCCEEDED ( hRes )
		{
			// generate pseudo counter data
			static LPCWSTR	sz0 = L"\t0";
			static LPCWSTR	sz2 = L"\t2";
			static LPCWSTR	sz4 = L"\t4";

			// generate pseudo counter name
			if SUCCEEDED ( hRes = AppendString ( cNEW, FALSE ) )
			{
				if SUCCEEDED ( hRes = AppendString ( cDEFINE, FALSE ) )
				{
					if SUCCEEDED ( hRes = AppendString ( cWMIOBJECTS, FALSE ) )
					{
						hRes = AppendString ( sz0, FALSE );
					}
				}
			}

			// generate first property of pseudo counter
			if ( SUCCEEDED ( hRes ) && SUCCEEDED ( hRes = AppendString ( cNEW, FALSE ) ) )
			{
				if SUCCEEDED ( hRes = AppendString ( cDEFINE, FALSE ) )
				{
					if SUCCEEDED ( hRes = AppendString ( cWMIOBJECTS_COUNT, FALSE ) )
					{
						hRes = AppendString ( sz2, FALSE );
					}
				}
			}

			// generate second property of pseudo counter
			if ( SUCCEEDED ( hRes ) && SUCCEEDED ( hRes = AppendString ( cNEW, FALSE ) ) )
			{
				if SUCCEEDED ( hRes = AppendString ( cDEFINE, FALSE ) )
				{
					if SUCCEEDED ( hRes = AppendString ( cWMIOBJECTS_VALIDITY, FALSE ) )
					{
						hRes = AppendString ( sz4, FALSE );
					}
				}
			}

			if SUCCEEDED ( hRes )
			{
				hRes = AppendString ( cNEW, FALSE );
			}

			if ( SUCCEEDED ( hRes ) && ( type != Registration ) )
			{

				// init helper variable
				dwIndex		= 3;
				DWORD	dwObjIndex	= 0;

				for (	DWORD dw = 0;
						dw < m_dwNamespaces && SUCCEEDED ( hRes );
						dw++
					)
				{
					if ( ! m_pNamespaces[dw].m_ppObjects.empty() )
					{
						DWORD dwIndexProp	= 0;
						try
						{
							// need to go accros object names
							for (	mapOBJECTit it = m_pNamespaces[dw].m_ppObjects.begin();
									it != m_pNamespaces[dw].m_ppObjects.end() && SUCCEEDED ( hRes );
									it++, dwObjIndex++
								)
							{
								if SUCCEEDED ( hRes = AppendString ( cNEW, FALSE ) )
								{
									if SUCCEEDED ( hRes = AppendString ( cDEFINE, FALSE ) )
									{
										LPWSTR	wszName = NULL;
										wszName = GenerateNameInd ( (*it).second->GetName(), dwObjIndex );

										if ( wszName )
										{
											hRes = AppendString ( wszName, FALSE );

											delete [] wszName;
											wszName = NULL;

											if SUCCEEDED ( hRes )
											{
												if SUCCEEDED ( hRes = AppendString ( cTAB, FALSE ) )
												{
													LPWSTR	szIndex = NULL;
													szIndex = GenerateIndex();

													if ( szIndex )
													{
														hRes = AppendString ( szIndex, FALSE );

														delete [] szIndex;
														szIndex = NULL;

														if SUCCEEDED( hRes )
														{
															if SUCCEEDED ( hRes = AppendString ( cNEW, FALSE ) )
															{
																// need to go accros properties names
																for (	dwIndexProp = 0;
																		dwIndexProp < (*it).second->GetArrayProperties() && SUCCEEDED ( hRes );
																		dwIndexProp++
																	)
																{
																	// do I have a locales for property ???
																	if ( !((*it).second->GetArrayProperties())[dwIndexProp]->GetArrayLocale().IsEmpty() )
																	{
																		// I have so this is not not hidden counter !!!
																		if SUCCEEDED ( hRes = AppendString ( cNEW, FALSE ) )
																		{
																			if SUCCEEDED ( hRes = AppendString ( cDEFINE, FALSE ) )
																			{
																				LPWSTR wszNameInd = NULL;
																				wszNameInd = GenerateNameInd ( ((*it).second->GetArrayProperties())[dwIndexProp]->GetName(), dwObjIndex );

																				if ( wszNameInd )
																				{
																					hRes = AppendString ( wszNameInd, FALSE );

																					if SUCCEEDED ( hRes )
																					{
																						if SUCCEEDED ( hRes = AppendString ( cTAB, FALSE) )
																						{
																							LPWSTR	szIndex = NULL;
																							szIndex = GenerateIndex();

																							if ( szIndex )
																							{
																								hRes = AppendString ( szIndex, FALSE );

																								delete [] szIndex;
																								szIndex = NULL;
																							}
																							else
																							{
																								hRes = E_OUTOFMEMORY;
																							}
																						}
																					}
																				}
																				else
																				{
																					hRes = E_OUTOFMEMORY;
																				}
																			}
																		}
																	}
																}

																if SUCCEEDED ( hRes )
																{
																	hRes = AppendString ( cNEW, FALSE );
																}
															}
														}
													}
													else
													{
														hRes = E_OUTOFMEMORY;
													}
												}
											}
										}
										else
										{
											hRes = E_OUTOFMEMORY;
										}
									}
								}

								if ( bThrottle && SUCCEEDED ( hRes ) )
								{
									Throttle	(
													THROTTLE_ALLOWED_FLAGS,
													1000,
													100,
													10,
													3000
												);
								}
							}
						}
						catch ( ... )
						{
							hRes =  E_UNEXPECTED;
						}
					}
				}
			}
		}

		if SUCCEEDED ( hRes )
		{
			// write changes if not done already
			if SUCCEEDED ( hRes = ContentWrite ( FALSE ) )
			{
				LPWSTR	wszModuleNew = NULL;

				try
				{
					#define EXT_HEADER L".h"
					DWORD cchExtension = sizeof ( EXT_HEADER ) / sizeof ( WCHAR );
					DWORD cchSize = lstrlenW ( wszModuleName ) + cchExtension + 1;
					if ( ( wszModuleNew = new WCHAR [ cchSize ] ) == NULL )
					{
						hRes = E_OUTOFMEMORY;
					}
					else
					{
						if ( SUCCEEDED ( hRes = StringCchCopyW ( wszModuleNew, cchSize, wszModuleName ) ) )
						{
							if ( SUCCEEDED ( hRes = StringCchCatW ( wszModuleNew, cchSize, EXT_HEADER ) ) )
							{
								// make changes
								hRes = FileMove ( wszModule, wszModuleNew );
							}
						}
					}
				}
				catch ( ... )
				{
					hRes = E_FAIL;
				}

				if ( wszModuleNew )
				{
					delete [] wszModuleNew;
					wszModuleNew = NULL;
				}
			}

			if FAILED ( hRes )
			{
				// revert changes
				ContentDelete ();
				FileDelete ( wszModule );
			}
		}
		else
		{
			// revert changes
			ContentDelete ();
			FileDelete ( wszModule );
		}

		if ( wszModule )
		{
			delete [] wszModule;
			wszModule = NULL;
		}
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_generate_ini.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_generate_ini.cpp
//
//	Abstract:
//
//					implements generate functionality ( generate ini file )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <throttle.h>

#include "refresherutils.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// definitions
#include "wmi_perf_generate.h"
// generate comments
#include "wmi_perf_generate_comment.h"
// registry helpers
#include "wmi_perf_reg.h"

// resources
#include "resource.h"
#include "__macro_Loadstring.h"

// constants
extern LPCWSTR	cDriverName;
extern LPCWSTR	cSymbolFile;

extern LPCWSTR	cSIGN;
extern LPCWSTR	cNEW;

extern LPCWSTR	cinfo;
extern LPCWSTR	clanguages;
extern LPCWSTR	cobjects;
extern LPCWSTR	ctext;

extern	LPCWSTR	cNAME;
extern	LPCWSTR	cHELP;

extern LPCWSTR	cWMIOBJECTS;
extern LPCWSTR	cWMIOBJECTS_COUNT;
extern LPCWSTR	cWMIOBJECTS_VALIDITY;

extern LPCWSTR	cWMIOBJECTS_NAME;
extern LPCWSTR	cWMIOBJECTS_COUNT_NAME;
extern LPCWSTR	cWMIOBJECTS_VALIDITY_NAME;

extern LPCWSTR	cWMIOBJECTS_HELP;
extern LPCWSTR	cWMIOBJECTS_COUNT_HELP;
extern LPCWSTR	cWMIOBJECTS_VALIDITY_HELP;

LPWSTR	CGenerate::GenerateLanguage ( LCID lcid )
{
	WCHAR szLanguage[256] = { L'\0' };
	GetLocaleInfoW ( lcid, LOCALE_SENGLANGUAGE, szLanguage, 256 );

	int		show	= PRIMARYLANGID(LANGIDFROMLCID(lcid));
	LPWSTR	sz		= NULL;

	try
	{
		DWORD cchSize = lstrlenW ( szLanguage ) + 3 + 3 + 1;
		if ( ( sz = new WCHAR [ cchSize ] ) != NULL )
		{
			StringCchPrintfW ( sz, cchSize, L"%03x=%s\r\n", show, szLanguage );
		}
	}
	catch ( ... )
	{
		if ( sz )
		{
			delete [] sz;
			sz = NULL;
		}
	}

	return sz;
}

LPWSTR	CGenerate::GenerateName ( LPCWSTR wszName, LCID lcid )
{
	int		show	= PRIMARYLANGID(LANGIDFROMLCID(lcid));
	LPWSTR	sz		= NULL;

	try
	{
		DWORD cchSize = lstrlenW ( wszName ) + 2 + 3 + 1;
		if ( ( sz = new WCHAR [ cchSize ] ) != NULL )
		{
			StringCchPrintfW ( sz, cchSize, L"%s_%03x_", wszName, show );
		}
	}
	catch ( ... )
	{
		if ( sz )
		{
			delete [] sz;
			sz = NULL;
		}
	}

	return sz;
}

HRESULT CGenerate::CreateObjectList ( BOOL bThrottle )
{
	HRESULT hRes = E_FAIL;

	// start with [objects]		... cobjects
	if SUCCEEDED ( hRes = AppendString ( cobjects ) )
	{
		// loop variable
		DWORD	dw			= 0L;
		DWORD	dwIndex		= 0L;
		DWORD	dwObjIndex	= 0L;

		LPWSTR wszName	= NULL;
		LPWSTR wsz		= NULL;

		try
		{
			// pseudo counter
			if ( m_dwlcid == 2 )
			{
				HMODULE hModule = NULL;
				hModule = GetResourceDll ( );

				if ( hModule )
				{
					wszName = GenerateName ( cWMIOBJECTS, m_lcid[dw] );
					if ( wszName != NULL )
					{

						if SUCCEEDED ( hRes = AppendString ( wszName ) )
						{
							if SUCCEEDED ( hRes = AppendString ( cNAME ) )
							{
								if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
								{
									wsz = LoadStringSystem ( hModule, IDS_cWMIOBJECTS_NAME );
									if ( wsz != NULL )
									{
										if SUCCEEDED ( hRes = AppendString ( wsz ) )
										{
											hRes = AppendString ( cNEW );
										}

										delete [] wsz;
										wsz = NULL;
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
							}
						}

						delete [] wszName;
						wszName = NULL;
					}
					else
					{
						hRes = E_OUTOFMEMORY;
					}

					// free resources cause we are done
					::FreeLibrary ( hModule );
				}
				else
				{
					hRes = E_FAIL;
				}

				dw++;
			}

			if SUCCEEDED ( hRes )
			{
				wszName = GenerateName ( cWMIOBJECTS, m_lcid[dw] );
				if ( wszName != NULL )
				{
					if SUCCEEDED ( hRes = AppendString ( wszName ) )
					{
						if SUCCEEDED ( hRes = AppendString ( cWMIOBJECTS_NAME ) )
						{
							hRes = AppendString ( cNEW );
						}
					}

					delete [] wszName;
					wszName = NULL;
				}
				else
				{
					hRes = E_OUTOFMEMORY;
				}
			}

			// real WMI objects
			for (	dw = 0;
					dw < m_dwNamespaces && SUCCEEDED ( hRes );
					dw++
				)
			{
				if ( ! m_pNamespaces[dw].m_ppObjects.empty() )
				{
					try
					{
						for (	mapOBJECTit it = m_pNamespaces[dw].m_ppObjects.begin();
								it != m_pNamespaces[dw].m_ppObjects.end() && SUCCEEDED ( hRes );
								it++, dwObjIndex++
							)
						{
							// resolve objects
							for (	dwIndex = 0;
									dwIndex < m_dwlcid && SUCCEEDED ( hRes );
									dwIndex++
								)
							{
								LPWSTR wszNameInd = NULL;
								wszNameInd = GenerateNameInd ( (*it).second->GetName(), dwObjIndex );

								if ( wszNameInd )
								{
									LPWSTR	szObject = NULL;
									szObject = GenerateName( wszNameInd, m_lcid[dwIndex] );

									delete [] wszNameInd;
									wszNameInd = NULL;

									if ( szObject )
									{
										if SUCCEEDED ( hRes = AppendString ( szObject ) )
										{
											if SUCCEEDED ( hRes = AppendString ( cNAME ) )
											{
												if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
												{
													if SUCCEEDED ( hRes = AppendString ( ((*it).second->GetArrayLocale())[dwIndex]->GetDisplayName() ) )
													{
														hRes = AppendString ( cNEW );
													}
												}
											}
										}

										delete [] szObject;
										szObject = NULL;
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
								else
								{
									hRes = E_OUTOFMEMORY;
								}
							}

							if ( bThrottle && SUCCEEDED ( hRes ) )
							{
								Throttle	(
												THROTTLE_ALLOWED_FLAGS,
												1000,
												100,
												10,
												3000
											);
							}
						}
					}
					catch ( ... )
					{
						hRes = E_UNEXPECTED;
					}
				}
			}
		}
		catch ( ... )
		{
			if ( wsz )
			{
				delete [] wsz;
				wsz = NULL;
			}

			if ( wszName )
			{
				delete [] wszName;
				wszName = NULL;
			}

			hRes = E_UNEXPECTED;
		}
	}

	// finish with [text]		... ctext
	if SUCCEEDED ( hRes )
	{
		hRes = AppendString ( cNEW );

		if SUCCEEDED ( hRes )
		{
			hRes = AppendString ( ctext );
		}
	}

	return hRes;
}

HRESULT CGenerate::GenerateFile_ini( LPCWSTR wszModuleName, BOOL bThrottle, int type )
{
	HRESULT hRes = E_UNEXPECTED;

	if ( ( wszModuleName != 0 && *wszModuleName != 0 ) && ( type != Normal || m_dwNamespaces != 0 ) )
	{
		LPWSTR	wszModule = NULL;

		try
		{
			#define EXT_NEW_INI L"_new.ini"
			DWORD cchExtension = sizeof ( EXT_NEW_INI ) / sizeof ( WCHAR );
			DWORD cchSize = lstrlenW ( wszModuleName ) + cchExtension + 1;
			if ( ( wszModule = new WCHAR [ cchSize ] ) == NULL )
			{
				hRes = E_OUTOFMEMORY;
			}
			else
			{
				if ( SUCCEEDED ( hRes = StringCchCopyW ( wszModule, cchSize, wszModuleName ) ) )
				{
					if ( SUCCEEDED ( hRes = StringCchCatW ( wszModule, cchSize, EXT_NEW_INI ) ) )
					{
						if SUCCEEDED ( hRes = FileCreate ( wszModule ) )
						{
							hRes			= E_FAIL;
							DWORD dwWritten = 0L;
							DWORD dwWrite	= lstrlenA ( UNICODE_SIGNATURE ) * sizeof ( char );

							if ( ::WriteFile	(	m_hFile,
													UNICODE_SIGNATURE,
													dwWrite,
													&dwWritten,
													NULL
												)
							)
							{
								if ( dwWrite == dwWritten )
								{
									hRes = S_OK;

									// do comment stuff
									CGenerateComment comment;

									comment.AddHeader();
									comment.AddLine();
									comment.AddLine( L"Copyright (C) 2000 Microsoft Corporation" );
									comment.AddLine();
									comment.AddLine( L"Module Name:" );
									comment.AddLine( wszModuleName );
									comment.AddLine();
									comment.AddLine( L"Abstract:" );
									comment.AddLine();
									comment.AddLine( L"Describes all the counters supported via WMI Hi-Performance providers" );
									comment.AddLine();
									comment.AddFooter();

									try
									{
										comment.Add ( );
										comment.Add ( cinfo );
										comment.Add ( cDriverName );
										comment.Add ( wszModuleName );
										comment.Add ( );
										comment.Add ( cSymbolFile );
										comment.Add ( wszModuleName );
										comment.Add ( L".h" );
										comment.Add ( );

										comment.Add ( );
										comment.Add ( clanguages );

										DWORD dwIndex = 0;

										for ( dwIndex = 0; dwIndex < m_dwlcid; dwIndex++ )
										{
											LPWSTR	lang = NULL;
											lang = GenerateLanguage ( m_lcid[dwIndex] );

											if ( lang )
											{
												comment.Add ( lang );

												delete [] lang;
												lang = NULL;
											}
											else
											{
												hRes = E_OUTOFMEMORY;
											}
										}

										comment.Add ( );
									}
									catch ( ... )
									{
										hRes = E_FAIL;
									}

									if SUCCEEDED ( hRes )
									{
										hRes = WriteToFileUnicode ( comment.GetComment() );

										if SUCCEEDED ( hRes )
										{
											hRes = CreateObjectList ( bThrottle );
										}
									}
								}
							}
						}
					}
				}
			}
		}
		catch ( ... )
		{
			hRes = E_FAIL;
		}

		if SUCCEEDED ( hRes )
		{
			// generate pseudo counter
			// which language am using
			DWORD dw = 0;

			if ( m_dwlcid == 2 )
			{
				HMODULE hModule = NULL;
				hModule = GetResourceDll ( );

				if ( hModule )
				{
					LPWSTR wszName = NULL;

					wszName = GenerateName ( cWMIOBJECTS, m_lcid[dw] );
					if ( wszName != NULL )
					{
						LPWSTR wsz = NULL;

						if SUCCEEDED ( hRes = AppendString ( wszName ) )
						{
							if SUCCEEDED ( hRes = AppendString ( cNAME ) )
							{
								if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
								{
									wsz = LoadStringSystem ( hModule, IDS_cWMIOBJECTS_NAME );
									if ( wsz != NULL )
									{
										if SUCCEEDED ( hRes = AppendString ( wsz ) )
										{
											hRes = AppendString ( cNEW );
										}

										delete [] wsz;
										wsz = NULL;
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
							}
						}

						if SUCCEEDED ( hRes )
						{
						if SUCCEEDED ( hRes = AppendString ( wszName ) )
						{
							if SUCCEEDED ( hRes = AppendString ( cHELP ) )
							{
								if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
								{
									wsz = LoadStringSystem ( hModule, IDS_cWMIOBJECTS_HELP );
									if ( wsz != NULL )
									{
										if SUCCEEDED ( hRes = AppendString ( wsz ) )
										{
											hRes = AppendString ( cNEW );
										}

										delete [] wsz;
										wsz = NULL;
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
							}
						}
						}
					}
					else
					{
						hRes = E_OUTOFMEMORY;
					}

					// free resources cause we are done
					::FreeLibrary ( hModule );
				}
				else
				{
					hRes = E_FAIL;
				}

				dw++;
			}

			if SUCCEEDED ( hRes )
			{
				LPWSTR wszName = NULL;

				wszName = GenerateName ( cWMIOBJECTS, m_lcid[dw] );
				if ( wszName != NULL )
				{
					if SUCCEEDED ( hRes = AppendString ( wszName ) )
					{
						if SUCCEEDED ( hRes = AppendString ( cWMIOBJECTS_NAME ) )
						{
							hRes = AppendString ( cNEW );
						}
					}

					if SUCCEEDED ( hRes )
					{
					if SUCCEEDED ( hRes = AppendString ( wszName ) )
					{
						if SUCCEEDED ( hRes = AppendString ( cWMIOBJECTS_HELP ) )
						{
							hRes = AppendString ( cNEW );
						}
					}
					}

					delete [] wszName;
					wszName = NULL;
				}
				else
				{
					hRes = E_OUTOFMEMORY;
				}
			}

			if SUCCEEDED ( hRes )
			{
				hRes = AppendString ( cNEW );
			}
		}

		// init helper variable
		DWORD dwIndex		= 0;
		DWORD dwIndexProp	= 0;

		DWORD	dwObjIndex		= 0;
		DWORD	dwObjIndexOld	= 0;

		if ( SUCCEEDED ( hRes ) && ( type != Registration ) )
		{
			for (	DWORD dw = 0;
					dw < m_dwNamespaces && SUCCEEDED ( hRes );
					dw++
				)
			{
				if ( ! m_pNamespaces[dw].m_ppObjects.empty() )
				{
					try
					{
						for (	mapOBJECTit it = m_pNamespaces[dw].m_ppObjects.begin();
								it != m_pNamespaces[dw].m_ppObjects.end() && SUCCEEDED ( hRes );
								it++, dwObjIndex++
							)
						{
							// resolve objects
							for (	dwIndex = 0;
									dwIndex < m_dwlcid && SUCCEEDED ( hRes );
									dwIndex++
								)
							{
								LPWSTR wszNameInd = NULL;
								wszNameInd = GenerateNameInd ( (*it).second->GetName(), dwObjIndex );

								if ( wszNameInd )
								{
									LPWSTR	szObject = NULL;
									szObject = GenerateName( wszNameInd, m_lcid[dwIndex] );

									delete [] wszNameInd;
									wszNameInd = NULL;

									if ( szObject )
									{
										if SUCCEEDED ( hRes = AppendString ( szObject ) )
										{
											if SUCCEEDED ( hRes = AppendString ( cNAME ) )
											{
												if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
												{
													if SUCCEEDED ( hRes = AppendString ( ((*it).second->GetArrayLocale())[dwIndex]->GetDisplayName() ) )
													{
														if SUCCEEDED ( hRes = AppendString ( cNEW ) )
														{
															if SUCCEEDED ( hRes = AppendString ( szObject ) )
															{
																if SUCCEEDED ( hRes = AppendString ( cHELP ) )
																{
																	if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
																	{
																		if SUCCEEDED ( hRes = AppendString ( ((*it).second->GetArrayLocale())[dwIndex]->GetDescription() ) )
																		{
																			hRes = AppendString ( cNEW );
																		}
																	}
																}
															}
														}
													}
												}
											}
										}

										delete [] szObject;
										szObject = NULL;
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
								else
								{
									hRes = E_OUTOFMEMORY;
								}
							}

							if SUCCEEDED ( hRes )
							{
								hRes = AppendString ( cNEW );
							}

							if ( bThrottle && SUCCEEDED ( hRes ) )
							{
								Throttle	(
												THROTTLE_ALLOWED_FLAGS,
												1000,
												100,
												10,
												3000
											);
							}
						}
					}
					catch ( ... )
					{
						hRes = E_UNEXPECTED;
					}
				}
			}
		}

		// generate pseudo counter properties
		if SUCCEEDED ( hRes )
		{
			// which language am using
			DWORD dw = 0;

			if ( m_dwlcid == 2 )
			{
				HMODULE hModule = NULL;
				hModule = GetResourceDll ( );

				if ( hModule )
				{
					LPWSTR wszName = NULL;

					wszName = GenerateName ( cWMIOBJECTS_COUNT, m_lcid[dw] );
					if ( wszName != NULL )
					{
						LPWSTR wsz = NULL;

						if SUCCEEDED ( hRes = AppendString ( wszName ) )
						{
							if SUCCEEDED ( hRes = AppendString ( cNAME ) )
							{
								if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
								{
									wsz = LoadStringSystem ( hModule, IDS_cWMIOBJECTS_COUNT_NAME );
									if ( wsz != NULL )
									{
										if SUCCEEDED ( hRes = AppendString ( wsz ) )
										{
											hRes = AppendString ( cNEW );
										}

										delete [] wsz;
										wsz = NULL;
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
							}
						}

						if SUCCEEDED ( hRes )
						{
						if SUCCEEDED ( hRes = AppendString ( wszName ) )
						{
							if SUCCEEDED ( hRes = AppendString ( cHELP ) )
							{
								if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
								{
									wsz = LoadStringSystem ( hModule, IDS_cWMIOBJECTS_COUNT_HELP );
									if ( wsz != NULL )
									{
										if SUCCEEDED ( hRes = AppendString ( wsz ) )
										{
											hRes = AppendString ( cNEW );
										}

										delete [] wsz;
										wsz = NULL;
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
							}
						}
						}
					}
					else
					{
						hRes = E_OUTOFMEMORY;
					}

					if SUCCEEDED ( hRes )
					{
						hRes = AppendString ( cNEW );
					}

					if SUCCEEDED ( hRes )
					{
						LPWSTR wszName = NULL;

						wszName = GenerateName ( cWMIOBJECTS_VALIDITY, m_lcid[dw] );
						if ( wszName != NULL )
						{
							LPWSTR wsz = NULL;

							if SUCCEEDED ( hRes = AppendString ( wszName ) )
							{
								if SUCCEEDED ( hRes = AppendString ( cNAME ) )
								{
									if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
									{
										wsz = LoadStringSystem ( hModule, IDS_cWMIOBJECTS_VALIDITY_NAME );
										if ( wsz != NULL )
										{
											if SUCCEEDED ( hRes = AppendString ( wsz ) )
											{
												hRes = AppendString ( cNEW );
											}

											delete [] wsz;
											wsz = NULL;
										}
										else
										{
											hRes = E_OUTOFMEMORY;
										}
									}
								}
							}

							if SUCCEEDED ( hRes )
							{
							if SUCCEEDED ( hRes = AppendString ( wszName ) )
							{
								if SUCCEEDED ( hRes = AppendString ( cHELP ) )
								{
									if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
									{
										wsz = LoadStringSystem ( hModule, IDS_cWMIOBJECTS_VALIDITY_HELP );
										if ( wsz != NULL )
										{
											if SUCCEEDED ( hRes = AppendString ( wsz ) )
											{
												hRes = AppendString ( cNEW );
											}

											delete [] wsz;
											wsz = NULL;
										}
										else
										{
											hRes = E_OUTOFMEMORY;
										}
									}
								}
							}
							}
						}
						else
						{
							hRes = E_OUTOFMEMORY;
						}
					}

					// free resources cause we are done
					::FreeLibrary ( hModule );
				}
				else
				{
					hRes = E_FAIL;
				}

				dw++;
			}

			if SUCCEEDED ( hRes )
			{
				LPWSTR wszName = NULL;

				wszName = GenerateName ( cWMIOBJECTS_COUNT, m_lcid[dw] );
				if ( wszName != NULL )
				{
					if SUCCEEDED ( hRes = AppendString ( wszName ) )
					{
						hRes = AppendString ( cWMIOBJECTS_COUNT_NAME );
					}

					if SUCCEEDED ( hRes )
					{
					if SUCCEEDED ( hRes = AppendString ( cNEW ) )
					{
						if SUCCEEDED ( hRes = AppendString ( wszName ) )
						{
							hRes = AppendString ( cWMIOBJECTS_COUNT_HELP );
						}
					}
					}

					delete [] wszName;
					wszName = NULL;
				}
				else
				{
					hRes = E_OUTOFMEMORY;
				}

				if SUCCEEDED ( hRes )
				{
					hRes = AppendString ( cNEW );
				}

				if SUCCEEDED ( hRes )
				{
					LPWSTR wszName = NULL;

					wszName = GenerateName ( cWMIOBJECTS_VALIDITY, m_lcid[dw] );
					if ( wszName != NULL )
					{
						if SUCCEEDED ( hRes = AppendString ( cNEW ) )
						{
							if SUCCEEDED ( hRes = AppendString ( wszName ) )
							{
								hRes = AppendString ( cWMIOBJECTS_VALIDITY_NAME );
							}
						}

						if SUCCEEDED ( hRes )
						{
						if SUCCEEDED ( hRes = AppendString ( cNEW ) )
						{
							if SUCCEEDED ( hRes = AppendString ( wszName ) )
							{
								hRes = AppendString ( cWMIOBJECTS_VALIDITY_HELP );
							}
						}
						}

						delete [] wszName;
						wszName = NULL;
					}
					else
					{
						hRes = E_OUTOFMEMORY;
					}
				}
			}
		}

		if ( SUCCEEDED ( hRes ) && ( type != Registration ) )
		{
			hRes		= AppendString ( cNEW );
			dwObjIndex	= dwObjIndexOld;

			for (	DWORD dw = 0;
					dw < m_dwNamespaces && SUCCEEDED ( hRes );
					dw++
				)
			{
				if ( ! m_pNamespaces[dw].m_ppObjects.empty() )
				{
					try
					{
						if SUCCEEDED ( hRes )
						{
							hRes = AppendString ( cNEW );
						}

						for (	mapOBJECTit it = m_pNamespaces[dw].m_ppObjects.begin();
								it != m_pNamespaces[dw].m_ppObjects.end() && SUCCEEDED ( hRes );
								it++, dwObjIndex++
							)
						{
							// resolve counters
							for (	dwIndexProp = 0;
									dwIndexProp < (*it).second->GetArrayProperties() && SUCCEEDED ( hRes );
									dwIndexProp++
								)
							{
								// do I have a locales for property ???
								if ( !((*it).second->GetArrayProperties())[dwIndexProp]->GetArrayLocale().IsEmpty() )
								{
									// I have so this is not hidden counter !!!
									for (	dwIndex = 0;
											dwIndex < m_dwlcid && SUCCEEDED ( hRes );
											dwIndex++
										)
									{
										LPWSTR wszNameInd = NULL;
										wszNameInd = GenerateNameInd ( (*it).second->GetArrayProperties()[dwIndexProp]->GetName(), dwObjIndex );

										if ( wszNameInd )
										{
											LPWSTR	szObject = NULL;
											szObject = GenerateName( wszNameInd, m_lcid[dwIndex] );

											delete [] wszNameInd;
											wszNameInd = NULL;

											if ( szObject )
											{
												if SUCCEEDED ( hRes = AppendString ( szObject ) )
												{
													if SUCCEEDED ( hRes = AppendString ( cNAME ) )
													{
														if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
														{
															if SUCCEEDED ( hRes = AppendString ( ((*it).second->GetArrayProperties())[dwIndexProp]->GetArrayLocale()[dwIndex]->GetDisplayName() ) )
															{
																if SUCCEEDED ( hRes = AppendString ( cNEW ) )
																{
																	if SUCCEEDED ( hRes = AppendString ( szObject ) )
																	{
																		if SUCCEEDED ( hRes = AppendString ( cHELP ) )
																		{
																			if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
																			{
																				if SUCCEEDED ( hRes = AppendString ( ((*it).second->GetArrayProperties())[dwIndexProp]->GetArrayLocale()[dwIndex]->GetDescription() ) )
																				{
																					hRes = AppendString ( cNEW );
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}

												delete [] szObject;
												szObject = NULL;
											}
											else
											{
												hRes = E_OUTOFMEMORY;
											}
										}
										else
										{
											hRes = E_OUTOFMEMORY;
										}
									}

									if SUCCEEDED ( hRes )
									{
										hRes = AppendString ( cNEW );
									}
								}
							}

							if ( bThrottle && SUCCEEDED ( hRes ) )
							{
								Throttle	(
												THROTTLE_ALLOWED_FLAGS,
												1000,
												100,
												10,
												3000
											);
							}
						}
					}
					catch ( ... )
					{
						hRes = E_UNEXPECTED;
					}
				}
			}
		}

		if SUCCEEDED ( hRes )
		{
			if SUCCEEDED ( hRes = ContentWrite () )
			{
				LPWSTR	wszModuleNew = NULL;

				try
				{
					#define EXT_INI L".ini"
					DWORD cchExtension = sizeof ( EXT_INI ) / sizeof ( WCHAR );
					DWORD cchSize = lstrlenW ( wszModuleName ) + cchExtension + 1;
					if ( ( wszModuleNew = new WCHAR [ cchSize ] ) == NULL )
					{
						hRes = E_OUTOFMEMORY;
					}
					else
					{
						if ( SUCCEEDED ( hRes = StringCchCopyW ( wszModuleNew, cchSize, wszModuleName ) ) )
						{
							if ( SUCCEEDED ( hRes = StringCchCatW ( wszModuleNew, cchSize, EXT_INI ) ) )
							{
								// make changes
								hRes = FileMove ( wszModule, wszModuleNew );
							}
						}
					}
				}
				catch ( ... )
				{
					hRes = E_FAIL;
				}

				if ( wszModuleNew )
				{
					delete [] wszModuleNew;
					wszModuleNew = NULL;
				}
			}

			if FAILED ( hRes )
			{
				// revert changes
				ContentDelete ( );
				FileDelete ( wszModule );
			}
		}
		else
		{
			// revert changes
			ContentDelete ( );
			FileDelete ( wszModule );
		}

		if ( wszModule )
		{
			delete [] wszModule;
			wszModule = NULL;
		}
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_generate_registry.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_generate_registry.cpp
//
//	Abstract:
//
//					implements generate functionality ( generate registry )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "refresherUtils.h"
#include <throttle.h>

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// definitions
#include "wmi_perf_generate.h"

// registry helpers
#include "wmi_perf_reg.h"

// I need admin attributes to create registry
#include "..\\Include\\wmi_security_attributes.h"

////////////////////////////////////////////////////////////////////////////////////
// implementation
////////////////////////////////////////////////////////////////////////////////////

// registry helper
DWORD CGenerate::GenerateIndexRegistry( BOOL bInit )
{
	static	DWORD	dwIndex = 0;
	return ( ( bInit ) ? ( dwIndex = 0 ), 0 : ( ( dwIndex++ ) *2 ) );
}

// registry helper
HRESULT CGenerate::GenerateRegistry ( LPCWSTR wszKey, LPCWSTR wszKeyValue, BOOL bThrottle )
{
	HRESULT hRes = S_FALSE;

	try
	{
		__PERFORMANCE p ( 0 );
		if ( ! p.IsEmpty() )
		{
			// init helper static variable
			GenerateIndexRegistry ( TRUE );

			for (	DWORD dw = 0;
					dw < m_dwNamespaces && SUCCEEDED ( hRes );
					dw++
				)
			{
				if ( ! m_pNamespaces[dw].m_ppObjects.empty() )
				{
					hRes = S_OK;

					// create namespace
					try
					{
						__NAMESPACE n ( m_pNamespaces[dw].m_wszNamespace, dw );
						if ( ! n.IsEmpty() )
						{
							DWORD dwIndex = 0;
							for (	mapOBJECTit it = m_pNamespaces[dw].m_ppObjects.begin();
									it != m_pNamespaces[dw].m_ppObjects.end() && SUCCEEDED ( hRes );
									it++
								)
							{
								// create object
								try
								{
									dwIndex = GenerateIndexRegistry();

									__OBJECT o ( (*it).second->GetName(), dwIndex );
									if ( ! o.IsEmpty() )
									{
										if ( ! ( (*it).second->GetArrayKeys().IsEmpty() ) )
										{
											for (	DWORD dwInst = 0;
													dwInst < (*it).second->GetArrayKeys() && SUCCEEDED ( hRes );
													dwInst++
												)
											{
												// have an instance
												PWMI_PERF_INSTANCE pInst = NULL;

												try
												{
													DWORD dwNameLength	= ( ::lstrlenW( (*it).second->GetArrayKeys()[dwInst] ) + 1 ) * sizeof ( WCHAR );

													DWORD dwAlignName	= 0L;
													if ( dwNameLength % 8 )
													{
														dwAlignName = 8 - ( dwNameLength % 8 );
													}

													DWORD dwAlignStruct	= 0L;
													if ( sizeof ( WMI_PERF_INSTANCE ) % 8 )
													{
														dwAlignStruct = 8 - ( sizeof ( WMI_PERF_INSTANCE ) % 8 );
													}

													DWORD dwLength		=	dwAlignName + dwNameLength + 
																			dwAlignStruct + sizeof ( WMI_PERF_INSTANCE );

													if ( ( pInst = (PWMI_PERF_INSTANCE) malloc ( dwLength ) ) != NULL )
													{
														// copy string into structure
														::CopyMemory ( &(pInst->dwName), (*it).second->GetArrayKeys()[dwInst], dwNameLength );

														pInst->dwNameLength	= dwNameLength;
														pInst->dwLength		= dwLength;

														// copy instance into object
														try
														{
															if ( (PWMI_PERF_OBJECT)o && 
															   ( o = (PWMI_PERF_OBJECT) _RA_realloc ( (PWMI_PERF_OBJECT)o, ((PWMI_PERF_OBJECT)o)->dwTotalLength + pInst->dwLength ) ) != NULL )
															{
																::CopyMemory (
																				( LPVOID ) ( reinterpret_cast<PBYTE>( (PWMI_PERF_OBJECT)o ) + ((PWMI_PERF_OBJECT)o)->dwTotalLength ),
																				pInst,
																				pInst->dwLength );

																((PWMI_PERF_OBJECT)o)->dwTotalLength += pInst->dwLength;
															}
															else
															{
																hRes = E_OUTOFMEMORY;
															}
														}
														catch ( ... )
														{
															hRes = E_FAIL;
														}

														free ( pInst );
													}
													else
													{
														hRes = E_OUTOFMEMORY;
													}
												}
												catch ( ... )
												{
													hRes = E_FAIL;
												}

												// helper for property index
												DWORD dwIndex = 0;

												// make all properties
												for (	DWORD dwProp = 0;
														dwProp < (*it).second->GetArrayProperties() && SUCCEEDED ( hRes );
														dwProp++
													)
												{
													if (!((*it).second->GetArrayProperties())[dwProp]->GetArrayLocale().IsEmpty())
													{
														dwIndex = GenerateIndexRegistry();
														__PROPERTY p ( (*it).second->GetArrayProperties()[dwProp]->GetName(), dwIndex );

														if ( ! p.IsEmpty() )
														{
															// fill structure
															((PWMI_PERF_PROPERTY)p)->dwDefaultScale	= (*it).second->GetArrayProperties()[dwProp]->dwDefaultScale;
															((PWMI_PERF_PROPERTY)p)->dwDetailLevel	= (*it).second->GetArrayProperties()[dwProp]->dwDetailLevel;
															((PWMI_PERF_PROPERTY)p)->dwCounterType	= (*it).second->GetArrayProperties()[dwProp]->dwCounterType;

															((PWMI_PERF_PROPERTY)p)->dwTYPE		= (*it).second->GetArrayProperties()[dwProp]->GetType();
															((PWMI_PERF_PROPERTY)p)->dwParentID	= ((PWMI_PERF_OBJECT)o)->dwID;

															// append into parent one
															hRes = o.AppendAlloc( p );
														}
														else
														{
															hRes = E_OUTOFMEMORY;
														}
													}
													else
													{
														__PROPERTY p ( (*it).second->GetArrayProperties()[dwProp]->GetName(), 0 );

														if ( ! p.IsEmpty() )
														{
															// fill structure
															((PWMI_PERF_PROPERTY)p)->dwDefaultScale	= (*it).second->GetArrayProperties()[dwProp]->dwDefaultScale;
															((PWMI_PERF_PROPERTY)p)->dwDetailLevel	= (*it).second->GetArrayProperties()[dwProp]->dwDetailLevel;
															((PWMI_PERF_PROPERTY)p)->dwCounterType	= (*it).second->GetArrayProperties()[dwProp]->dwCounterType;

															((PWMI_PERF_PROPERTY)p)->dwTYPE		= (*it).second->GetArrayProperties()[dwProp]->GetType();
															((PWMI_PERF_PROPERTY)p)->dwParentID = ((PWMI_PERF_OBJECT)o)->dwID;

															// append into parent one
															hRes = o.AppendAlloc( p );
														}
														else
														{
															hRes = E_OUTOFMEMORY;
														}
													}
												}

												// fill parent structure
												if ( SUCCEEDED ( hRes ) && dwIndex )
												{
													((PWMI_PERF_OBJECT)o)->dwLastID = dwIndex;
												}
											}

											if SUCCEEDED ( hRes )
											{
												// I'm not singleton ( have dwInst instances )
												((PWMI_PERF_OBJECT)o)->dwSingleton	= dwInst;
											}
										}
										else
										{
											// helper for property index
											DWORD dwIndex = 0;

											// make all properties
											for (	DWORD dwProp = 0;
													dwProp < (*it).second->GetArrayProperties() && SUCCEEDED ( hRes );
													dwProp++
												)
											{
												if (!((*it).second->GetArrayProperties())[dwProp]->GetArrayLocale().IsEmpty())
												{
													dwIndex = GenerateIndexRegistry();

													__PROPERTY p ( (*it).second->GetArrayProperties()[dwProp]->GetName(), dwIndex );
													if ( ! p.IsEmpty() )
													{
														// fill structure
														((PWMI_PERF_PROPERTY)p)->dwDefaultScale	= (*it).second->GetArrayProperties()[dwProp]->dwDefaultScale;
														((PWMI_PERF_PROPERTY)p)->dwDetailLevel	= (*it).second->GetArrayProperties()[dwProp]->dwDetailLevel;
														((PWMI_PERF_PROPERTY)p)->dwCounterType	= (*it).second->GetArrayProperties()[dwProp]->dwCounterType;

														((PWMI_PERF_PROPERTY)p)->dwTYPE		= (*it).second->GetArrayProperties()[dwProp]->GetType();
														((PWMI_PERF_PROPERTY)p)->dwParentID = ((PWMI_PERF_OBJECT)o)->dwID;

														// append into parent one
														hRes = o.AppendAlloc( p );
													}
													else
													{
														hRes = E_OUTOFMEMORY;
													}
												}
												else
												{
													__PROPERTY p ( (*it).second->GetArrayProperties()[dwProp]->GetName(), 0 );
													if ( ! p.IsEmpty() )
													{
														// fill structure
														((PWMI_PERF_PROPERTY)p)->dwDefaultScale	= (*it).second->GetArrayProperties()[dwProp]->dwDefaultScale;
														((PWMI_PERF_PROPERTY)p)->dwDetailLevel	= (*it).second->GetArrayProperties()[dwProp]->dwDetailLevel;
														((PWMI_PERF_PROPERTY)p)->dwCounterType	= (*it).second->GetArrayProperties()[dwProp]->dwCounterType;

														((PWMI_PERF_PROPERTY)p)->dwTYPE		= (*it).second->GetArrayProperties()[dwProp]->GetType();
														((PWMI_PERF_PROPERTY)p)->dwParentID = ((PWMI_PERF_OBJECT)o)->dwID;

														// append into parent one
														hRes = o.AppendAlloc( p );
													}
													else
													{
														hRes = E_OUTOFMEMORY;
													}
												}
											}

											// fill parent structure
											if ( SUCCEEDED ( hRes ) && dwIndex )
											{
												((PWMI_PERF_OBJECT)o)->dwLastID = dwIndex;
											}
										}

										if SUCCEEDED ( hRes )
										{
											// fill structure
											((PWMI_PERF_OBJECT)o)->dwDetailLevel = (*it).second->dwDetailLevel;
											((PWMI_PERF_OBJECT)o)->dwParentID = ((PWMI_PERF_NAMESPACE)n)->dwID;

											// append into parent one
											hRes = n.AppendAlloc ( o );
										}
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
								catch ( ... )
								{
									hRes = E_FAIL;
								}

								if ( bThrottle && SUCCEEDED ( hRes ) )
								{
									Throttle	(
													THROTTLE_ALLOWED_FLAGS,
													1000,
													100,
													10,
													3000
												);
								}
							}

							if SUCCEEDED ( hRes )
							{
								// fill structure
								((PWMI_PERF_NAMESPACE)n)->dwLastID		= dwIndex;
								((PWMI_PERF_NAMESPACE)n)->dwParentID	= dw;

								// append into parent one
								hRes = p.AppendAlloc ( n );
							}
						}
						else
						{
							hRes = E_OUTOFMEMORY;
						}
					}
					catch ( ... )
					{
						hRes = E_FAIL;
					}
				}
			}

			WmiSecurityAttributes sa;
			if ( sa.GetSecurityAttributtes () )
			{
				if ( hRes == S_OK )
				{
					hRes = SetRegistry( wszKey, wszKeyValue, (BYTE*) (PWMI_PERFORMANCE)p, ((PWMI_PERFORMANCE)p)->dwTotalLength, sa.GetSecurityAttributtes() );
				}
				else
				{
					if ( hRes == S_FALSE )
					{
						hRes = SetRegistry( wszKey, wszKeyValue, (BYTE*) NULL, 0, sa.GetSecurityAttributtes() );
					}
				}
			}
			else
			{
				hRes =  E_FAIL;
			}
		}
		else
		{
			hRes = E_OUTOFMEMORY;
		}
	}
	catch ( ... )
	{
		hRes =  E_FAIL;
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_generate.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_generate.cpp
//
//	Abstract:
//
//					implements generate functionality ( generate registry and files )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "refresherUtils.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// definitions
#include "wmi_perf_generate.h"

HRESULT CGenerate::Generate ( IWbemServices* pServices, LPCWSTR szQuery, LPCWSTR szNamespace, BOOL bLocale )
{
	HRESULT hRes = S_OK;

	try
	{
		if ( bLocale )
		{
			__String::SetStringCopy ( m_pNamespaces[m_dwNamespaces].m_wszNamespace, szNamespace );
			__String::SetStringCopy ( m_pNamespaces[m_dwNamespaces].m_wszQuery, szQuery );

			if FAILED ( hRes = m_pNamespaces[m_dwNamespaces].GenerateObjects( pServices, szQuery, bLocale ) )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"generate namespace failed",hRes );
				#endif	__SUPPORT_MSGBOX
			}

			m_dwNamespaces++;
		}
		else
		{
			if FAILED ( hRes = m_pNamespaces[m_dwNamespaces-1].GenerateObjects( pServices, szQuery, bLocale ) )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"generate namespace failed",hRes );
				#endif	__SUPPORT_MSGBOX
			}
		}
	}
	catch ( ... )
	{
		hRes = E_FAIL;
	}

	return hRes;
}

LPWSTR	CGenerate::GenerateNameInd ( LPCWSTR wszName, DWORD dwObjIndex )
{
	LPWSTR			wsz		= NULL;

	try
	{
		DWORD cchSize = lstrlenW ( wszName ) + 1 + 5 + 1;
		if ( ( wsz = new WCHAR [ cchSize ] ) != NULL )
		{
			StringCchPrintfW ( wsz, cchSize, L"%s_%05x", wszName, dwObjIndex );
		}
	}
	catch ( ... )
	{
		if ( wsz )
		{
			delete [] wsz;
			wsz = NULL;
		}
	}

	return wsz;
}

static	LPWSTR	wszContent	= NULL;
static	DWORD	dwSize		= 4096;
static	DWORD	dwSizeLeft	= dwSize;

void	CGenerate::Uninitialize ( void )
{
	if ( wszContent )
	{
		delete [] wszContent;
		wszContent = NULL;
	}
}

void	CGenerate::ContentDelete ( void )
{
	if ( wszContent )
	{
		wszContent [ 0 ] = L'\0';
		dwSizeLeft = dwSize;
	}
}

HRESULT	CGenerate::ContentWrite ( BOOL bUnicode )
{
	HRESULT hRes = S_FALSE;

	if ( wszContent )
	{
		if ( dwSizeLeft != dwSize )
		{
			wszContent [ dwSize - dwSizeLeft ] = L'\0';

			//write to file now
			if ( bUnicode )
			{
				hRes = WriteToFileUnicode ( wszContent );
			}
			else
			{
				hRes = WriteToFile ( wszContent );
			}
		}

		ContentDelete ();
	}
	else
	{
		hRes = E_UNEXPECTED;
	}

	return hRes;
}

void CGenerate::AppendString ( LPCWSTR src, DWORD dwSrcSize, DWORD& dwSrcSizeLeft )
{
	if ( ( dwSizeLeft - 1 ) <= dwSrcSize )
	{
		memcpy ( ( wszContent + ( dwSize - dwSizeLeft ) ), src, ( dwSizeLeft - 1 ) * sizeof ( WCHAR ) );
		dwSrcSizeLeft	= dwSrcSize - ( dwSizeLeft - 1 );
		dwSizeLeft		= 0;

		wszContent [ dwSize - 1 ] = L'\0';
	}
	else
	{
		memcpy ( ( wszContent + ( dwSize - dwSizeLeft ) ), src, dwSrcSize * sizeof ( WCHAR ) );
		dwSrcSizeLeft	= 0;
		dwSizeLeft		= dwSizeLeft - dwSrcSize;

		wszContent [ dwSize - dwSizeLeft ] = L'\0';
	}
}

HRESULT CGenerate::AppendString ( LPCWSTR src, BOOL bUnicode )
{
	HRESULT hRes			= S_FALSE;

	DWORD	dwSrcSize		= 0L;
	DWORD	dwSrcSizeLeft	= 0L;
	LPCWSTR	wsz				= NULL;

	if ( ! wszContent )
	{
		hRes = E_OUTOFMEMORY;

		try
		{
			if ( ( wszContent = new WCHAR [ dwSize ] ) != NULL )
			{
				hRes = S_OK;
			}
		}
		catch ( ... )
		{
			if ( wszContent )
			{
				delete [] wszContent;
				wszContent = NULL;
			}

			hRes = E_FAIL;
		}
	}

	if SUCCEEDED ( hRes )
	{
		// append string
		if ( ( wsz = src ) != NULL )
		{
			do
			{
				dwSrcSize = lstrlenW ( wsz );

				AppendString ( wsz, dwSrcSize, dwSrcSizeLeft );
				if ( ! dwSizeLeft )
				{
					//write to file now
					if ( bUnicode )
					{
						hRes = WriteToFileUnicode ( wszContent );
					}
					else
					{
						hRes = WriteToFile ( wszContent );
					}

					if SUCCEEDED ( hRes )
					{
						dwSizeLeft = dwSize;
					}
				}
				else
				{
					hRes = S_OK;
				}

				if ( dwSrcSizeLeft )
				{
					DWORD dwOffset	= 0L;
					dwOffset = dwSrcSize - dwSrcSizeLeft;

					wsz = wsz + dwOffset;
				}
			}
			while ( dwSrcSizeLeft && SUCCEEDED ( hRes ) );
		}
		else
		{
			hRes = E_INVALIDARG;
		}
	}

	return hRes;
}

// need atl conversions
#ifndef	__ATLCONV_H__
#include <atlconv.h>
#endif	__ATLCONV_H__

HRESULT	CGenerate::WriteToFile ( LPCWSTR wszContent )
{
	HRESULT hRes = S_OK;

	if ( m_hFile && ( m_hFile != INVALID_HANDLE_VALUE ) && wszContent )
	{
		DWORD dwWritten = 0L;
		DWORD dwWrite	= lstrlenW ( wszContent ) * sizeof ( char );
		USES_CONVERSION;

		try
		{
			if ( ! ::WriteFile	(	m_hFile,
									W2A ( wszContent ),
									dwWrite,
									&dwWritten,
									NULL
								)
			   )
			{
				hRes = HRESULT_FROM_WIN32 ( ::GetLastError () );
			}
			else
			{
				if ( dwWrite != dwWritten )
				{
					hRes = E_FAIL;
				}
			}
		}
		catch ( ... )
		{
			hRes = E_UNEXPECTED;
		}
	}
	else
	{
		hRes = E_INVALIDARG;
	}

	return hRes;
}

HRESULT	CGenerate::WriteToFileUnicode ( LPCWSTR wszContent )
{
	HRESULT hRes = S_OK;

	if ( m_hFile && ( m_hFile != INVALID_HANDLE_VALUE ) && wszContent )
	{
		DWORD dwWritten	= 0L;
		DWORD dwWrite	= lstrlenW ( wszContent ) * sizeof ( WCHAR );

		try
		{
			if ( ! ::WriteFile	(	m_hFile,
									wszContent,
									dwWrite,
									&dwWritten,
									NULL
								)
			   )
			{
				hRes = HRESULT_FROM_WIN32 ( ::GetLastError () );
			}
			else
			{
				if ( dwWrite != dwWritten )
				{
					hRes = E_FAIL;
				}
			}
		}
		catch ( ... )
		{
			hRes = E_UNEXPECTED;
		}
	}
	else
	{
		hRes = E_INVALIDARG;
	}

	return hRes;
}

HRESULT CGenerate::FileCreate ( LPCWSTR lpwszFileName )
{
	HRESULT		hRes	= E_OUTOFMEMORY;
	LPWSTR		path	= NULL;
	LPWSTR		tpath	= NULL;

	if ( lpwszFileName )
	{
		// get wbem directory
		if ( ( tpath = GetWbemDirectory() ) != NULL )
		{
			try
			{
				DWORD cchPath = lstrlenW ( tpath );
				DWORD cchSize = cchPath + lstrlenW ( lpwszFileName ) + 1; 
				if ( ( path = new WCHAR [ cchSize  ] ) != NULL )
				{
					if ( SUCCEEDED ( hRes = StringCchCopyW ( path, cchPath + 1, tpath ) ) )
					{
						if ( SUCCEEDED ( hRes = StringCchCatW ( path, cchSize, lpwszFileName ) ) )
						{
							hRes = S_FALSE;
						}
					}
				}
			}
			catch ( ... )
			{
				hRes = E_FAIL;
			}

			if SUCCEEDED ( hRes )
			{
				if ( ! ( ::CreateDirectoryW ( tpath, NULL ) ) )
				{
					if ( ERROR_ALREADY_EXISTS != ::GetLastError() )
					{
						hRes = HRESULT_FROM_WIN32( ::GetLastError() );
					}
					else
					{
						hRes = S_FALSE;
					}
				}

				if SUCCEEDED ( hRes )
				{
					if ( ( m_hFile = ::CreateFileW	(	path,
														GENERIC_WRITE,
														FILE_SHARE_READ,
														NULL,
														CREATE_ALWAYS,
														FILE_ATTRIBUTE_NORMAL | SECURITY_ANONYMOUS,
														NULL
													)
						 ) == INVALID_HANDLE_VALUE )
					{
						hRes = HRESULT_FROM_WIN32 ( ::GetLastError () );
					}
					else
					{
						hRes = S_OK;
					}
				}
			}

			if ( path )
			{
				delete [] path;
				path = NULL;
			}

			delete [] tpath;
			tpath = NULL;
		}
	}
	else
	{
		hRes = E_INVALIDARG;
	}

	return hRes;
}

HRESULT CGenerate::FileDelete ( LPCWSTR lpwszFileName )
{
	HRESULT		hRes	= E_OUTOFMEMORY;
	LPWSTR		path	= NULL;
	LPWSTR		tpath	= NULL;

	m_hFile.CloseHandle();

	if ( lpwszFileName )
	{
		// get wbem directory
		if ( ( tpath = GetWbemDirectory() ) != NULL )
		{
			try
			{
				DWORD cchPath = lstrlenW ( tpath );
				DWORD cchSize = cchPath + lstrlenW ( lpwszFileName ) + 1; 
				if ( ( path = new WCHAR [ cchSize  ] ) != NULL )
				{
					if ( SUCCEEDED ( hRes = StringCchCopyW ( path, cchPath + 1, tpath ) ) )
					{
						if ( SUCCEEDED ( hRes = StringCchCatW ( path, cchSize, lpwszFileName ) ) )
						{
							hRes = S_FALSE;
						}
					}
				}
			}
			catch ( ... )
			{
				hRes = E_FAIL;
			}

			if SUCCEEDED ( hRes )
			{
				if ( ! DeleteFile ( path ) )
				{
					hRes = HRESULT_FROM_WIN32 ( ::GetLastError () );
				}
				else
				{
					hRes = S_OK;
				}
			}

			if ( path )
			{
				delete [] path;
				path = NULL;
			}

			delete [] tpath;
			tpath = NULL;
		}
	}
	else
	{
		hRes = E_INVALIDARG;
	}

	return hRes;
}

HRESULT CGenerate::FileMove ( LPCWSTR lpwszFileName, LPCWSTR lpwszFileNameNew )
{
	HRESULT		hRes	= E_OUTOFMEMORY;
	LPWSTR		path1	= NULL;
	LPWSTR		path2	= NULL;
	LPWSTR		tpath	= NULL;

	if ( m_hFile )
	{
		::CloseHandle ( m_hFile );
		m_hFile = NULL;
	}

	if ( lpwszFileName && lpwszFileNameNew )
	{
		// get wbem directory
		if ( ( tpath = GetWbemDirectory() ) != NULL )
		{
			try
			{
				DWORD cchPath = lstrlenW ( tpath );
				DWORD cchSize = cchPath + lstrlenW ( lpwszFileName ) + 1; 
				if ( ( path1 = new WCHAR [ cchSize  ] ) != NULL )
				{
					if ( SUCCEEDED ( hRes = StringCchCopyW ( path1, cchPath + 1, tpath ) ) )
					{
						if ( SUCCEEDED ( hRes = StringCchCatW ( path1, cchSize, lpwszFileName ) ) )
						{
							hRes = S_FALSE;
						}
					}
				}
			}
			catch ( ... )
			{
				hRes = E_FAIL;
			}

			if SUCCEEDED ( hRes )
			{
				try
				{
					DWORD cchPath2 = lstrlenW ( tpath );
					DWORD cchSize2 = cchPath2 + lstrlenW ( lpwszFileNameNew ) + 1; 
					if ( ( path2 = new WCHAR [ cchSize2  ] ) != NULL )
					{
						if ( SUCCEEDED ( hRes = StringCchCopyW ( path2, cchPath2 + 1, tpath ) ) )
						{
							if ( SUCCEEDED ( hRes = StringCchCatW ( path2, cchSize2, lpwszFileNameNew ) ) )
							{
								hRes = S_FALSE;
							}
						}
					}
					else
					{
						hRes = E_OUTOFMEMORY;
					}
				}
				catch ( ... )
				{
					hRes = E_FAIL;
				}

				if SUCCEEDED ( hRes )
				{
					// try to delete old one
					DeleteFile ( path2 );

					if ( ! MoveFileEx ( path1, path2, MOVEFILE_REPLACE_EXISTING ) )
					{
						hRes = HRESULT_FROM_WIN32 ( ::GetLastError () );
					}
					else
					{
						hRes = S_OK;
					}
				}
			}

			if ( path2 )
			{
				delete [] path2;
				path2 = NULL;
			}

			if ( path1 )
			{
				delete [] path1;
				path1 = NULL;
			}

			delete [] tpath;
			tpath = NULL;
		}
	}
	else
	{
		hRes = E_INVALIDARG;
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object.h
//
//	Abstract:
//
//					declaration of object structure
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_OBJECT__
#define	__WMI_PERF_OBJECT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// wbem
#ifndef	__WBEMIDL_H_
#include <wbemidl.h>
#endif	__WBEMIDL_H_

class CPerformanceObject
{
	DECLARE_NO_COPY ( CPerformanceObject );

	IWbemClassObject*	m_pObject;
	BOOL				m_bCopy;

	IWbemQualifierSet*	m_pObjectQualifierSet;

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	CPerformanceObject ( IWbemClassObject * pObject, BOOL bCopy = FALSE ) :
	m_bCopy ( bCopy ),
	m_pObject ( NULL ),
	m_pObjectQualifierSet ( NULL )
	{
		if (pObject )
		{
			if ( m_bCopy )
			{
				( m_pObject = pObject ) -> AddRef ();
			}
			else
			{
				( m_pObject = pObject );
			}
		}
	}

	virtual ~CPerformanceObject ()
	{
		if ( m_bCopy && m_pObject )
		{
			m_pObject -> Release ();
		}

		m_pObject = NULL;

		if ( m_pObjectQualifierSet )
		{
			m_pObjectQualifierSet -> Release ();
		}

		m_pObjectQualifierSet = NULL;
	}

	// helpers for IWbemClassObject instances :))
	IWbemClassObject* GetObjectClass() const
	{
		return m_pObject;
	}

	IWbemClassObject* GetObjectClassCopy()
	{
		if ( m_pObject )
		{
			m_pObject->AddRef();
		}

		return m_pObject;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// methods
	//////////////////////////////////////////////////////////////////////////////////////////

	// resolve if object has all required qualifiers and don't have exactly specified not reqired set
	HRESULT IsCorrectObject ( LPCWSTR* lptszFulFil, DWORD dwFulFil, LPCWSTR* lptszFulFilNot, DWORD dwFulFilNot );

	HRESULT	GetNames	(	DWORD*		pdwPropNames,
							LPWSTR**	ppPropNames,
							CIMTYPE**	ppTypes,
							DWORD**		ppScales,
							DWORD**		ppLevels,
							DWORD**		ppCounters,
							LONG		lFlags,
							LPCWSTR*	lptszPropNeed,
							DWORD		dwPropNeed,
							LPCWSTR*	lptszPropNeedNot,
							DWORD		dwPropNeedNot,
							LPCWSTR		lpwszQualifier = NULL
						);

	HRESULT	GetPropertyValue	( LPCWSTR wszPropName, LPWSTR* pwsz );

	HRESULT	GetQualifierValue	( LPCWSTR wszPropName, LPCWSTR wszQualifierName, LPWSTR* psz );
	HRESULT	GetQualifierValue	( LPCWSTR wszQualifierName, LPWSTR* psz );

	private:

	//////////////////////////////////////////////////////////////////////////////////////////
	// helpers
	//////////////////////////////////////////////////////////////////////////////////////////

	HRESULT	GetQualifierValue	( IWbemQualifierSet* pSet, LPCWSTR wszQualifierName, LPWSTR* psz );

	HRESULT	GetQualifierType	( LPCWSTR wszPropName, CIMTYPE* type );

	HRESULT	IsCorrect ( IWbemQualifierSet* pSet,
						LPCWSTR* lptszPropNeed,
						DWORD	dwPropNeed,
						LPCWSTR*	lptszPropNeedNot,
						DWORD	dwPropNeedNot
					  );
};

#endif	__WMI_PERF_OBJECT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object_enum.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object_enum.cpp
//
//	Abstract:
//
//					implements enumeration of objects from WMI
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <throttle.h>

// definitions
#include "wmi_perf_object_enum.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

//////////////////////////////////////////////////////////////////////////////////////////////
// methods
//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT	CPerformanceObjectEnum::ExecQuery ( LPCWSTR szQueryLang, LPCWSTR szQuery, LONG lFlag )
{
	if ( ! m_pServices )
	{
		return E_UNEXPECTED;
	}

	if ( ( ! szQueryLang ) || ( ! szQuery ) )
	{
		return E_INVALIDARG;
	}

	CComBSTR	bstrQueryLang	= szQueryLang;
	CComBSTR	bstrQuery		= szQuery;

	if ( m_pEnum )
	{
		m_pEnum->Release();
		m_pEnum = NULL;
	}

	return m_pServices->ExecQuery	(	bstrQueryLang,
										bstrQuery,
										lFlag,
										NULL,
										&m_pEnum
									);
}

HRESULT	CPerformanceObjectEnum::NextObject	(	LPCWSTR* lpwszNeed,
												DWORD	dwNeed,
												LPCWSTR*	lpwszNeedNot,
												DWORD	dwNeedNot,
												CPerformanceObject** ppObject
											)
{
	HRESULT hRes = S_OK;

	if ( ! m_pEnum )
	{
		hRes = E_UNEXPECTED;
	}

	if ( ! ppObject )
	{
		hRes = E_POINTER;
	}
	else
	{
		(*ppObject) = NULL;
	}

	CComPtr<IWbemClassObject>	pObj;
	ULONG						uReturn = 0;

	while ( SUCCEEDED ( hRes ) &&
		  ( hRes = m_pEnum->Next ( WBEM_INFINITE, 1, &pObj, &uReturn ) ) == S_OK )
	{
		CPerformanceObject* obj = NULL;

		try
		{
			if ( ( obj = new CPerformanceObject( pObj, TRUE ) ) != NULL )
			{
				if ( ( hRes = obj->IsCorrectObject ( lpwszNeed, dwNeed, lpwszNeedNot, dwNeedNot ) ) == S_OK )
				{
					// object is correct ( has all qualifiers )
					(*ppObject) = obj;
					break;
				}
				else
				{
					// avoid leaks :)))
					pObj.Release();

					// destroy old performance object
					if ( obj )
					{
						delete obj;
						obj = NULL;
					}
				}
			}
			else
			{
				hRes =  E_OUTOFMEMORY;
			}
		}
		catch ( ... )
		{
			// avoid leaks :)))
			pObj.Release();

			if ( obj )
			{
				delete obj;
				obj = NULL;
			}

			hRes = E_UNEXPECTED;
		}
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object.cpp
//
//	Abstract:
//
//					implements object helper functionality
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// definitions
#include "wmi_perf_object.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

//////////////////////////////////////////////////////////////////////////////////////////////
// methods
//////////////////////////////////////////////////////////////////////////////////////////////

// return S_OK when correct
// return S_FALSE when not correct

HRESULT CPerformanceObject::IsCorrect ( IWbemQualifierSet* pSet,
										LPCWSTR* lptszNeed,
										DWORD	dwNeed,
										LPCWSTR*	lptszNeedNot,
										DWORD	dwNeedNot
									  )
{
	HRESULT	hRes	= S_OK;
	DWORD	dwIndex	= 0;

	// resolve all requested to be fulfiled with
	if ( lptszNeed && dwNeed )
	{
		for ( dwIndex = 0; dwIndex < dwNeed; dwIndex++ )
		{
			hRes = pSet->Get( lptszNeed[dwIndex], NULL, NULL, NULL );

			// there is no requested qualifier
			if ( hRes == WBEM_E_NOT_FOUND )
			{
				return S_FALSE;
			}

			if FAILED( hRes )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE_RETURN ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"find out if object is correct failed",hRes );
				return hRes;
				#endif	__SUPPORT_MSGBOX
			}
		}
	}

	// resolve all don't requested qualifiers

	if ( lptszNeedNot && dwNeedNot )
	{
		for ( dwIndex = 0; dwIndex < dwNeedNot; dwIndex++)
		{
			hRes = pSet->Get( lptszNeedNot[dwIndex], NULL, NULL, NULL );

			// there is found not requested qualifier
			if ( hRes == WBEM_S_NO_ERROR )
			{
				return S_FALSE;
			}

			if ( hRes != WBEM_E_NOT_FOUND )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE_RETURN ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"find out if object is correct failed",hRes );
				return hRes;
				#endif	__SUPPORT_MSGBOX
			}

			hRes = WBEM_S_NO_ERROR;
		}
	}

	return hRes;
}

HRESULT CPerformanceObject::IsCorrectObject ( LPCWSTR* lptszFulFil, DWORD dwFulFil, LPCWSTR* lptszFulFilNot, DWORD dwFulFilNot )
{
	HRESULT	hRes	= S_OK;

	// have no object ???
	if ( ! m_pObject )
	{
		hRes = E_UNEXPECTED;
	}

	if SUCCEEDED ( hRes )
	{
		if ( ! m_pObjectQualifierSet )
		{
			if FAILED ( hRes = m_pObject->GetQualifierSet ( &m_pObjectQualifierSet ) )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"get qualifiers of object failed",hRes );
				#endif	__SUPPORT_MSGBOX
			}
		}

		if SUCCEEDED ( hRes )
		{
			hRes = IsCorrect ( m_pObjectQualifierSet, lptszFulFil, dwFulFil, lptszFulFilNot, dwFulFilNot);
		}
	}

	return hRes;
}

HRESULT	CPerformanceObject::GetNames	(	DWORD*		pdwPropNames,
											LPWSTR**	ppPropNames,
											CIMTYPE**	ppTypes,
											DWORD**		ppScales,
											DWORD**		ppLevels,
											DWORD**		ppCounters,
											LONG		lFlags,
											LPCWSTR*	lptszPropNeed,
											DWORD		dwPropNeed,
											LPCWSTR*	lptszPropNeedNot,
											DWORD		dwPropNeedNot,
											LPCWSTR		lpwszQualifier
										)
{
	HRESULT	hRes	= S_OK;
	DWORD	dwIndex	= 0;

	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	if ( !pdwPropNames )
	{
		return E_INVALIDARG;
	}

	// smart pointer for safearrays
	__WrapperSAFEARRAY saNames;

	if FAILED ( hRes = m_pObject->GetNames ( lpwszQualifier, lFlags, NULL, &saNames ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"find out names of object's properties failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	// init all variables
	if ( ppPropNames )
	{
		(*ppPropNames)	= NULL;
	}

	if ( ppTypes )
	{
		(*ppTypes)		= NULL;
	}

	if ( ppScales )
	{
		(*ppScales)		= NULL;
	}

	if ( ppLevels )
	{
		(*ppLevels)		= NULL;
	}

	if ( ppCounters )
	{
		(*ppCounters)		= NULL;
	}

	// let's do something
	if ( lptszPropNeed || lptszPropNeedNot )
	{
		if ( ppPropNames )
		{
			// I need find out required properties only ( use qualifier array )

			__WrapperARRAY < LPWSTR >	help;

			if SUCCEEDED( SAFEARRAY_TO_LPWSTRARRAY ( saNames, &help, help ) )
			{
				for ( dwIndex = 0; dwIndex < help; dwIndex++ )
				{
					CIMTYPE type = CIM_EMPTY;

					if FAILED ( hRes = GetQualifierType ( help[dwIndex], &type ) )
					{
						return hRes;
					}

					switch ( type )
					{
						case CIM_SINT32:
						case CIM_UINT32:
						case CIM_SINT64:
						case CIM_UINT64:
						{
							break;
						}
						default:
						{
							// bad property type :))

							try
							{
								delete help.GetAt ( dwIndex );
								help.SetAt ( dwIndex );
							}
							catch ( ... )
							{
							}

							continue;
						}
					}

					// test if it has proper qualifier set
					CComPtr<IWbemQualifierSet> pSet;

					if SUCCEEDED ( hRes = m_pObject->GetPropertyQualifierSet ( help[dwIndex], &pSet ) )
					{
						if SUCCEEDED( hRes = IsCorrect	(	pSet,
															lptszPropNeed,
															dwPropNeed,
															lptszPropNeedNot,
															dwPropNeedNot
														)
									)
						{
							// is not correct clear this name
							if ( hRes == S_FALSE )
							{
								try
								{
									delete help.GetAt ( dwIndex );
									help.SetAt ( dwIndex );
								}
								catch ( ... )
								{
								}
							}
						}
						else
						{
							#ifdef	__SUPPORT_MSGBOX
							ERRORMESSAGE_DEFINITION;
							ERRORMESSAGE_RETURN ( hRes );
							#else	__SUPPORT_MSGBOX
							___TRACE_ERROR( L"IsCorrect failed",hRes );
							return hRes;
							#endif	__SUPPORT_MSGBOX
						}
					}
					else
					{
						#ifdef	__SUPPORT_MSGBOX
						ERRORMESSAGE_DEFINITION;
						ERRORMESSAGE_RETURN ( hRes );
						#else	__SUPPORT_MSGBOX
						___TRACE_ERROR( L"GetPropertyQualifierSet failed",hRes );
						return hRes;
						#endif	__SUPPORT_MSGBOX
					}
				}

				for ( dwIndex = 0; dwIndex < help; dwIndex++ )
				{
					if ( help[dwIndex] )
					{
						(*pdwPropNames)++;
					}
				}

				try
				{
					if ( *pdwPropNames )
					{
						if ( ( (*ppPropNames) = (LPWSTR*) new LPWSTR[ (*pdwPropNames) ] ) == NULL )
						{
							hRes =  E_OUTOFMEMORY;
						}

						if ( SUCCEEDED ( hRes ) )
						{
							// clear them all
							for ( dwIndex = 0; dwIndex < (*pdwPropNames); dwIndex++ )
							{
								(*ppPropNames)[dwIndex] = NULL;
							}

							DWORD dw = 0;

							for ( dwIndex = 0; dwIndex < help && SUCCEEDED ( hRes ); dwIndex++ )
							{
								if ( help[dwIndex] )
								{
									DWORD cchSize = lstrlenW(help[dwIndex]) + 1;
									if ( ( (*ppPropNames)[dw] = (LPWSTR) new WCHAR[ cchSize ] ) == NULL )
									{
										RELEASE_DOUBLEARRAY ( (*ppPropNames), (*pdwPropNames) );
										hRes =  E_OUTOFMEMORY;
									}

									if ( SUCCEEDED ( hRes ) )
									{
										StringCchCopyW ( (*ppPropNames)[dw], cchSize, help[dwIndex] );
									}

									// increment internal index
									dw++;
								}
							}
						}
					}
				}
				catch ( ... )
				{
					RELEASE_DOUBLEARRAY ( (*ppPropNames), (*pdwPropNames) );
					hRes =  E_UNEXPECTED;
				}
			}
			else
			{
				hRes = S_FALSE;
			}
		}
	}
	else
	{
		if ( ppPropNames )
		{
			// I don't need find out anything so all properties are returned
			if FAILED ( hRes = SAFEARRAY_TO_LPWSTRARRAY ( saNames, ppPropNames, pdwPropNames ) )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE_RETURN ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"SAFEARRAY_TO_LPWSTRARRAY failed",hRes );
				return hRes;
				#endif	__SUPPORT_MSGBOX
			}
		}
	}

	if ( SUCCEEDED ( hRes ) )
	{
		if ( ppTypes )
		{
			try
			{
				if ( ( ( *ppTypes ) = new CIMTYPE[(*pdwPropNames)] ) == NULL )
				{
					hRes =  E_OUTOFMEMORY;
					goto myCleanup;
				}

			}
			catch ( ... )
			{
				hRes =  E_FAIL;
				goto myCleanup;
			}
		}

		// allocate all scales :))
		if ( ppScales )
		{
			try
			{
				if ( ( ( *ppScales ) = new DWORD[(*pdwPropNames)] ) == NULL )
				{
					hRes =  E_OUTOFMEMORY;
					goto myCleanup;
				}

			}
			catch ( ... )
			{
				hRes =  E_FAIL;
				goto myCleanup;
			}
		}

		// allocate all levels
		if ( ppLevels )
		{
			try
			{
				if ( ( ( *ppLevels ) = new DWORD[(*pdwPropNames)] ) == NULL )
				{
					hRes =  E_OUTOFMEMORY;
					goto myCleanup;
				}

			}
			catch ( ... )
			{
				hRes =  E_FAIL;
				goto myCleanup;
			}
		}

		// allocate all counter types
		if ( ppCounters )
		{
			try
			{
				if ( ( ( *ppCounters ) = new DWORD[(*pdwPropNames)] ) == NULL )
				{
					hRes =  E_OUTOFMEMORY;
					goto myCleanup;
				}

			}
			catch ( ... )
			{
				hRes =  E_FAIL;
				goto myCleanup;
			}
		}

		for ( dwIndex = 0; dwIndex < (*pdwPropNames); dwIndex++ )
		{
			CIMTYPE type = CIM_EMPTY;

			if FAILED ( hRes = GetQualifierType ( (*ppPropNames)[dwIndex], &type ) )
			{
				goto myCleanup;
			}

			switch ( type )
			{
				case CIM_SINT32:
				case CIM_UINT32:
				case CIM_SINT64:
				case CIM_UINT64:
				{
					if ( ppTypes )
					{
						(*ppTypes)[dwIndex] = type;
					}

					break;
				}
				default:
				{
					if ( ppTypes )
					{
						(*ppTypes)[dwIndex] = CIM_EMPTY;
					}

					break;
				}
			}

			LPWSTR szScale   = NULL;
			LPWSTR szLevel   = NULL;
			LPWSTR szCounter = NULL;

			if ( ppScales )
			{
				GetQualifierValue ( (*ppPropNames)[dwIndex], L"defaultscale", &szScale );

				if ( szScale )
				{
					( *ppScales)[dwIndex] = _wtol ( szScale );
					delete szScale;
				}
				else
				{
					( *ppScales)[dwIndex] = 0L;
				}
			}

			if ( ppLevels )
			{
				GetQualifierValue ( (*ppPropNames)[dwIndex], L"perfdetail", &szLevel );

				if ( szLevel )
				{
					( *ppLevels)[dwIndex] = _wtol ( szLevel );
					delete szLevel;
				}
				else
				{
					( *ppLevels)[dwIndex] = 0L;
				}
			}

			if ( ppCounters )
			{
				GetQualifierValue ( (*ppPropNames)[dwIndex], L"countertype", &szCounter );

				if ( szCounter )
				{
					( *ppCounters)[dwIndex] = _wtol ( szCounter );
					delete szCounter;
				}
				else
				{
					( *ppCounters)[dwIndex] = 0L;
				}
			}
		}
	}

	return hRes;

	myCleanup:

	if ( ppTypes )
	{
		delete [] (*ppTypes);
		(*ppTypes) = NULL;
	}

	if ( ppScales )
	{
		delete [] (*ppScales);
		(*ppScales) = NULL;
	}

	if ( ppLevels )
	{
		delete [] (*ppLevels);
		(*ppLevels) = NULL;
	}

	if ( ppCounters )
	{
		delete [] (*ppCounters);
		(*ppCounters) = NULL;
	}

	return hRes;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// helpers
//////////////////////////////////////////////////////////////////////////////////////////////

// qualifier type for specified property
HRESULT CPerformanceObject::GetQualifierType ( LPCWSTR wszPropName, CIMTYPE* type )
{
	HRESULT	hRes	= S_OK;

	( *type ) = NULL;

	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	if FAILED ( hRes = m_pObject->Get ( wszPropName, NULL, NULL, type, NULL ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"Get method on object failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	return hRes;
}

// qualifier value for main object
HRESULT CPerformanceObject::GetQualifierValue ( LPCWSTR wszQualifierName, LPWSTR* psz )
{
	HRESULT	hRes	= S_OK;

	( *psz ) = NULL;

	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	if ( ! m_pObjectQualifierSet )
	{
		CComPtr<IWbemQualifierSet> pQualifiers;

		if FAILED ( hRes = m_pObject->GetQualifierSet ( &pQualifiers ) )
		{
			#ifdef	__SUPPORT_MSGBOX
			ERRORMESSAGE_DEFINITION;
			ERRORMESSAGE_RETURN ( hRes );
			#else	__SUPPORT_MSGBOX
			___TRACE_ERROR( L"GetQualifierSet on object failed",hRes );
			return hRes;
			#endif	__SUPPORT_MSGBOX
		}

		( m_pObjectQualifierSet = pQualifiers ) -> AddRef ();
	}

	return GetQualifierValue ( m_pObjectQualifierSet, wszQualifierName, psz );
}

// qualifier value for specified property
HRESULT CPerformanceObject::GetQualifierValue ( LPCWSTR wszPropName, LPCWSTR wszQualifierName, LPWSTR* psz )
{
	HRESULT	hRes	= S_OK;

	( *psz ) = NULL;

	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	CComPtr<IWbemQualifierSet> pQualifiers;

	if FAILED ( hRes = m_pObject->GetPropertyQualifierSet ( wszPropName, &pQualifiers ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"GetPropertyQualifierSet on object failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	return GetQualifierValue ( pQualifiers, wszQualifierName, psz );
}

// return qualifier value in string representation ( helper )
HRESULT CPerformanceObject::GetQualifierValue ( IWbemQualifierSet * pSet, LPCWSTR wszQualifierName, LPWSTR * psz )
{
	(*psz) = NULL;

	CComVariant var;
	CComVariant varDest;

	HRESULT hRes = S_OK;

	CComBSTR bstrQualifierName = wszQualifierName;
	if FAILED ( hRes = pSet->Get ( bstrQualifierName, NULL, &var, NULL ) )
	{
		return hRes;
	}

	try
	{
		if SUCCEEDED ( ::VariantChangeType ( &varDest, &var, VARIANT_NOVALUEPROP , VT_BSTR) )
		{
			try
			{
				DWORD cchSize = ::SysStringLen( V_BSTR(&varDest) ) + 1;
				if ( ( (*psz) = (LPWSTR) new WCHAR[ cchSize ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				StringCchCopyW ( (*psz), cchSize, V_BSTR( &varDest ) );
			}
			catch ( ... )
			{
				delete (*psz);
				(*psz) = NULL;

				return E_UNEXPECTED;
			}
		}
	}
	catch ( ... )
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}

HRESULT CPerformanceObject::GetPropertyValue ( LPCWSTR wszPropertyName, LPWSTR * psz )
{
	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	(*psz) = NULL;

	CComVariant var;
	CComVariant varDest;

	HRESULT hRes = S_OK;

	CComBSTR bstrPropertyName = wszPropertyName;
	if FAILED ( hRes = m_pObject->Get ( bstrPropertyName, NULL, &var, NULL, NULL ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"Get method on object failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	try
	{
		if SUCCEEDED ( ::VariantChangeType ( &varDest, &var, VARIANT_NOVALUEPROP , VT_BSTR) )
		{
			try
			{
				DWORD cchSize = ::SysStringLen( V_BSTR(&varDest) ) + 1;
				if ( ( (*psz) = (LPWSTR) new WCHAR[ cchSize ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				StringCchCopyW ( (*psz), cchSize, V_BSTR( &varDest ) );
			}
			catch ( ... )
			{
				delete (*psz);
				(*psz) = NULL;

				return E_UNEXPECTED;
			}
		}
	}
	catch ( ... )
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmireverseadapter\common.inc ===
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

WMI_PERFORMANCE_INC = $(ADAPTERS)\WmiReversePerformanceMonitor\Include

WMI_PERFORMANCE_REFRESH_INC = $(ADAPTERS)\WmiReversePerformanceMonitor\WMIAdapter_Refresh
WMI_PERFORMANCE_REFRESH_LIB = $(ADAPTERS)\WmiReversePerformanceMonitor\System\$(O)\WmiApRef.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object_enum.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object_enum.h
//
//	Abstract:
//
//					declaration of enumerate providers helpers
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_ENUM_OBJECT__
#define	__WMI_PERF_ENUM_OBJECT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// wbem
#ifndef	__WBEMIDL_H_
#include <wbemidl.h>
#endif	__WBEMIDL_H_

#include "wmi_perf_object.h"

class CPerformanceObjectEnum
{
	DECLARE_NO_COPY ( CPerformanceObjectEnum );

	IWbemServices*	m_pServices;
	BOOL			m_bCopy;

	IEnumWbemClassObject * m_pEnum;

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	CPerformanceObjectEnum ( IWbemServices* pServices, BOOL bCopy = FALSE ) :
		m_pEnum ( NULL ),
		m_pServices ( NULL ),
		m_bCopy ( bCopy )
	{
		if ( pServices )
		{
			if ( m_bCopy )
			{
				(m_pServices = pServices)->AddRef();
			}
			else
			{
				(m_pServices = pServices);
			}
		}
	}

	virtual ~CPerformanceObjectEnum ()
	{
		if ( m_pEnum )
		{
			m_pEnum->Release();
		}

		if ( m_bCopy && m_pServices )
		{
			m_pServices->Release();
		}

		m_pServices	= NULL;
		m_pEnum		= NULL;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	// execute query to get all objects
	HRESULT ExecQuery ( LPCWSTR szQueryLang, LPCWSTR szQuery, LONG lFlag );

	// get next object from enum ( S_FALSE if there is no more )
	HRESULT	NextObject	(	LPCWSTR* lpwszNeed,
							DWORD	dwNeed,
							LPCWSTR*	lpwszNeedNot,
							DWORD	dwNeedNot,
							CPerformanceObject** ppObject
						);
};

#endif	__WMI_PERF_ENUM_OBJECT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object_global.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000-2002, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object_global.cpp
//
//	Abstract:
//
//					definitions of global object structure
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// definitions
#include "wmi_perf_object_global.h"
// enum hiperfs
#include "wmi_perf_object_enum.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// extern constant
extern	LPCWSTR	g_szPropFilter;
extern	LPCWSTR	g_szPropNeed[];
extern	LPCWSTR	g_szPropNeedNot[];

extern	DWORD	g_dwPropNeed;
extern	DWORD	g_dwPropNeedNot;

extern	LONG	g_lFlagProperties;

extern	LPCWSTR	g_szQueryLang;

extern	LPCWSTR	g_szFulFil[];
extern	LPCWSTR	g_szFulFilNot[];

extern	DWORD	g_dwFulFil;
extern	DWORD	g_dwFulFilNot;

extern	LONG	g_lFlag;

HRESULT CObjectGlobal::GenerateObjects ( IWbemServices * pService, LPCWSTR szQuery, BOOL bAmended )
{
	HRESULT					hRes = S_OK;
	CPerformanceObjectEnum	myEnum(pService);

	LONG lFlag = g_lFlag;

	if ( bAmended )
	{
		lFlag |= WBEM_FLAG_USE_AMENDED_QUALIFIERS;
	}

	if FAILED ( hRes = myEnum.ExecQuery ( g_szQueryLang, szQuery, lFlag ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"Exec query for providers failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	while ( hRes == WBEM_S_NO_ERROR )
	{
		__WrapperPtr<CPerformanceObject> obj;

		if ( ( hRes = myEnum.NextObject (	g_szFulFil,
											g_dwFulFil,
											g_szFulFilNot,
											g_dwFulFilNot,
											&obj
										)
			 ) == S_OK
		   )
		{
			if ( bAmended )
			{
				// I have all clasess for main namespace with amended qualifiers

				// get class name of object !!!
				__Wrapper<WCHAR> wszObjName = NULL;

				if FAILED ( hRes = obj->GetPropertyValue( L"__CLASS", &wszObjName) )
				{
					return hRes;
				}

				// get all properties of object !!!
				LPWSTR*		pwszProperties	= NULL;
				CIMTYPE*	pTypes			= NULL;
				DWORD*		pScales			= NULL;
				DWORD*		pLevels			= NULL;
				DWORD*		pCounters		= NULL;

				DWORD	dwProperties	= 0;

				LPWSTR*	pwszKeys	= NULL;
				DWORD	dwKeys		= 0;

				hRes = obj->GetNames (	&dwProperties,
										&pwszProperties,
										&pTypes,
										&pScales,
										&pLevels,
										&pCounters,
										g_lFlagProperties | WBEM_FLAG_ONLY_IF_TRUE,
										g_szPropNeed,
										g_dwPropNeed,
										NULL,
										NULL,
										g_szPropFilter
									 );

				if ( SUCCEEDED ( hRes ) )
				{
					hRes = obj->GetNames (	&dwKeys,
											&pwszKeys,
											NULL,
											NULL,
											NULL,
											NULL,
											g_lFlagProperties | WBEM_FLAG_KEYS_ONLY ,
											NULL,
											NULL,
											NULL,
											NULL
										 );

					if ( SUCCEEDED ( hRes ) )
					{
						// create object wrapper
						CObject* pGenObject = NULL;

						try
						{
							if ( ( pGenObject = new CObject() ) != NULL )
							{
								// set name of object
								pGenObject->SetName ( wszObjName.Detach() );

								if ( dwKeys && pwszKeys && *pwszKeys )
								{
									// set keys of object
									pGenObject->SetArrayKeys ( pwszKeys, dwKeys );
								}

								// set detail level for objects
								LPWSTR szDetailLevel = NULL;
								obj->GetQualifierValue ( L"perfdetail", &szDetailLevel );

								if ( szDetailLevel )
								{
									pGenObject->dwDetailLevel = _wtol ( szDetailLevel );
									delete szDetailLevel;
								}
								else
								{
									pGenObject->dwDetailLevel = 0;
								}

								// set properties
								if FAILED ( hRes = pGenObject->SetProperties (	obj,
																				pwszProperties,
																				pTypes,
																				pScales,
																				pLevels,
																				pCounters,
																				dwProperties ) )
								{
									// just trace we have failure
									___TRACE_ERROR( L"set properties to object failed",hRes );

									// clear stuff
									delete pGenObject;
									pGenObject = NULL;
								}
							}
							else
							{
								hRes = E_OUTOFMEMORY;
							}
						}
						catch ( ... )
						{
							if ( pGenObject )
							{
								delete pGenObject;
								pGenObject = NULL;
							}

							hRes = E_UNEXPECTED;
						}

						delete [] pTypes;
						delete [] pScales;
						delete [] pLevels;
						delete [] pCounters;

						RELEASE_DOUBLEARRAY ( pwszProperties, dwProperties );

						if SUCCEEDED ( hRes )
						{
							// add object into array
							if SUCCEEDED ( hRes = AddObject ( pGenObject ) )
							{
								// I'm amended ( fill apropriate locale information )
								if FAILED ( hRes = ResolveLocale ( pGenObject, obj ) )
								{
									// just trace we have failure
									___TRACE_ERROR( L"resolve object locale failed",hRes );
								}
							}
							else
							{
								if ( pGenObject )
								{
									delete pGenObject;
									pGenObject = NULL;
								}

								// just trace we have failure
								___TRACE_ERROR( L"add object description to list failed",hRes );
							}
						}
						else
						{
							RELEASE_DOUBLEARRAY ( pwszKeys, dwKeys );
						}
					}
					else
					{
						delete [] pTypes;
						delete [] pScales;
						delete [] pLevels;
						delete [] pCounters;

						RELEASE_DOUBLEARRAY ( pwszProperties, dwProperties );
						RELEASE_DOUBLEARRAY ( pwszKeys, dwKeys );
					}
				}
				else
				{
					delete [] pTypes;
					delete [] pScales;
					delete [] pLevels;
					delete [] pCounters;

					RELEASE_DOUBLEARRAY ( pwszProperties, dwProperties );
					RELEASE_DOUBLEARRAY ( pwszKeys, dwKeys );
				}

				if ( hRes == S_FALSE )
				{
					hRes = WBEM_S_NO_ERROR;
				}
			}
			else
			{
				// I have all classes from another namespace :))

				// get class name of object !!!
				__Wrapper<WCHAR> wszObjName = NULL;

				if SUCCEEDED ( hRes = obj->GetPropertyValue( L"__CLASS", &wszObjName) )
				{
					// try to find
					try
					{
						mapOBJECTit it = m_ppObjects.find ( wszObjName );

						if ( it != m_ppObjects.end() )
						{
							// founded :)))
							if FAILED ( hRes = ResolveLocale ( (*it).second, obj ) )
							{
								// just trace we have failure
								___TRACE_ERROR( L"resolve object locale failed",hRes );
							}
						}
					}
					catch ( ... )
					{
						hRes = E_FAIL;
					}
				}
			}
		}
	}

	return hRes;
}

HRESULT	CObjectGlobal::ResolveLocale ( CObject* pGenObj, CPerformanceObject* obj )
{
	__WrapperPtr<CLocale> pLocale;

	try
	{
		if ( pLocale.SetData ( new CLocale() ),
			 pLocale == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// resolve apropriate display name
		__Wrapper< WCHAR >	szDisplayName;
		obj->GetQualifierValue(L"displayname", &szDisplayName);

		// get size of name
		DWORD cchSize = lstrlenW ( pGenObj->GetName() ) + 1;

		if ( ! szDisplayName )
		{
			try
			{
				if ( szDisplayName.SetData( new WCHAR[ cchSize ] ), 
					 szDisplayName == NULL )
				{
					return E_OUTOFMEMORY;
				}

				StringCchCopyW ( szDisplayName, cchSize, pGenObj->GetName() );
			}
			catch ( ... )
			{
				return E_UNEXPECTED;
			}
		}

		// set display name
		pLocale->SetDisplayName( szDisplayName.Detach() );

		// resolve apropriate description
		__Wrapper< WCHAR >	szDescription;
		obj->GetQualifierValue(L"description", &szDescription);

		if ( ! szDescription )
		{
			try
			{
				if ( szDescription.SetData( new WCHAR[ cchSize ] ), 
					 szDescription == NULL )
				{
					return E_OUTOFMEMORY;
				}

				StringCchCopyW ( szDescription, cchSize, pGenObj->GetName() );
			}
			catch ( ... )
			{
				return E_UNEXPECTED;
			}
		}

		// set description name
		pLocale->SetDescription( szDescription.Detach() );
	}
	catch ( ... )
	{
		return E_FAIL;
	}

	// have a locale information about object
	pGenObj->GetArrayLocale().DataAdd ( pLocale.Detach() );

	// resolve display names & descriptions of properties

	for ( DWORD dw = 0; dw <pGenObj->GetArrayProperties() ; dw++)
	{
		__Wrapper<WCHAR> wszShow;

		// take property and resolve
		obj->GetQualifierValue( pGenObj->GetArrayProperties()[dw]->GetName(), L"show", &wszShow );
		if ( ! wszShow.IsEmpty() )
		{
			if ( ! lstrcmpiW ( wszShow, L"false" ) )
			{
				// don't show counter
				continue;
			}
		}

		__WrapperPtr<CLocale> pLocale;

		try
		{
			if ( pLocale.SetData ( new CLocale() ),
				 pLocale == NULL )
			{
				return E_OUTOFMEMORY;
			}

			// resolve apropriate display name
			__Wrapper< WCHAR >	szDisplayName;
			obj->GetQualifierValue(pGenObj->GetArrayProperties()[dw]->GetName(), L"displayname", &szDisplayName);

			// get size of property name
			DWORD cchProperty = lstrlenW ( pGenObj->GetArrayProperties()[dw]->GetName() ) + 1;

			if ( ! szDisplayName )
			{
				try
				{
					if ( szDisplayName.SetData( new WCHAR[ cchProperty ] ), 
						 szDisplayName == NULL )
					{
						return E_OUTOFMEMORY;
					}

					StringCchCopyW ( szDisplayName, cchProperty, pGenObj->GetArrayProperties()[dw]->GetName() );
				}
				catch ( ... )
				{
					return E_UNEXPECTED;
				}
			}

			// set display name
			pLocale->SetDisplayName( szDisplayName.Detach() );

			// resolve apropriate description
			__Wrapper< WCHAR >	szDescription;
			obj->GetQualifierValue(pGenObj->GetArrayProperties()[dw]->GetName(), L"description", &szDescription);

			if ( ! szDescription )
			{
				try
				{
					if ( szDescription.SetData( new WCHAR[ cchProperty ] ), 
						 szDescription == NULL )
					{
						return E_OUTOFMEMORY;
					}

					StringCchCopyW ( szDescription, cchProperty, pGenObj->GetArrayProperties()[dw]->GetName() );
				}
				catch ( ... )
				{
					return E_UNEXPECTED;
				}
			}

			// set description name
			pLocale->SetDescription( szDescription.Detach() );
		}
		catch ( ... )
		{
			return E_FAIL;
		}

		// have a locale information about property
		pGenObj->GetArrayProperties()[dw]->GetArrayLocale().DataAdd ( pLocale.Detach() );
	}

	return S_OK;
}

// object helpers

void CObjectGlobal::DeleteAll ( void )
{
	if ( !m_ppObjects.empty() )
	{
		for ( mapOBJECTit it = m_ppObjects.begin(); it != m_ppObjects.end(); it++ )
		{
			if ( (*it).second )
			{
				delete (*it).second;
				(*it).second = NULL;
			}
		}

		m_ppObjects.clear();
	}
}

HRESULT CObjectGlobal::AddObject ( CObject* pObject )
{
	if ( ! pObject )
	{
		return E_INVALIDARG;
	}

	try
	{
		m_ppObjects.insert ( mapOBJECT::value_type ( pObject->GetName(), pObject ) );
	}
	catch ( ... )
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object_global.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object_global.h
//
//	Abstract:
//
//					structure global aspect of generated internal objects
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_OBJECT_GLOBAL__
#define	__WMI_PERF_OBJECT_GLOBAL__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifndef	__WMI_PERF_OBJECT_LOCALE__
#include "wmi_perf_object_locale.h"
#endif	__WMI_PERF_OBJECT_LOCALE__

#ifndef	__WMI_PERF_OBJECT__
#include "wmi_perf_object.h"
#endif	__WMI_PERF_OBJECT__

#ifndef	__COMMON__
#include "__common.h"
#endif	__COMMON__

typedef	map< LPWSTR, CObject*, __CompareLPWSTR < LPWSTR >, RA_allocator < CObject* > >	mapOBJECT;
typedef	mapOBJECT::iterator																mapOBJECTit;

class CObjectGlobal
{
	DECLARE_NO_COPY ( CObjectGlobal );

	LPWSTR				m_wszNamespace;
	LPWSTR				m_wszQuery;

	mapOBJECT			m_ppObjects;

	friend class CGenerate;

	public:

	// construction & destruction

	CObjectGlobal() :
	m_wszNamespace ( NULL ),
	m_wszQuery ( NULL )
	{
	}

	virtual ~CObjectGlobal()
	{
		if ( m_wszNamespace )
		{
			delete m_wszNamespace;
			m_wszNamespace = NULL;
		}

		if ( m_wszQuery )
		{
			delete m_wszQuery;
			m_wszQuery = NULL;
		}

		DeleteAll();
	}

	HRESULT GenerateObjects ( IWbemServices * pService, LPCWSTR szQuery, BOOL bAmended = TRUE );

	// accessors
	mapOBJECT* GetObjects ( )
	{
		return &m_ppObjects;
	}

	LPWSTR	GetNamespace ( ) const
	{
		return m_wszNamespace;
	}
	LPWSTR	GetQuery ( ) const
	{
		return m_wszQuery;
	}

	private:
	// delete all object
	void	DeleteAll ( void );

	// add generate object at the end
	HRESULT AddObject ( CObject* pObject );
	// resolve locale stuff for object
	HRESULT	ResolveLocale ( CObject* pGenObj, CPerformanceObject* obj );
};

#endif	__WMI_PERF_OBJECT_GLOBAL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object_locale.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object_locale.cpp
//
//	Abstract:
//
//					definitions of locale ( not local ) object
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#include "wmi_perf_object_locale.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

HRESULT CObject::SetProperties (	LPWSTR wsz,
									CIMTYPE type,
									DWORD dwScale,
									DWORD dwLevel,
									DWORD dwCounter,
									DWORD dw )
{
	__WrapperPtr<CObjectProperty> pProperty;

	try
	{
		if ( pProperty.SetData ( new CObjectProperty() ),
			 pProperty == NULL )
		{
			return E_OUTOFMEMORY;
		}

		LPWSTR sz = NULL;
		__String::SetStringCopy ( sz, wsz );

		pProperty->SetName ( sz );
		pProperty->SetType ( type );

		pProperty->dwDefaultScale	= dwScale;
		pProperty->dwDetailLevel	= dwLevel;
		pProperty->dwCounterType	= dwCounter;
	}
	catch ( ... )
	{
		return E_FAIL;
	}

	m_properties.SetAt ( dw, pProperty.Detach() );
	return S_OK;
}

HRESULT CObject::SetProperties (	CPerformanceObject* obj,
									LPWSTR* pp,
									CIMTYPE* pTypes,
									DWORD*	pScales,	
									DWORD*	pLevels,	
									DWORD*	pCounters,	
									DWORD dwpp )
{
	HRESULT hRes = S_OK;

	DWORD dwBase = 0;
	DWORD dw	 = 0;

	for ( dw = 0, dwBase = 0; dw < dwpp; dw ++ )
	{
		__Wrapper<WCHAR> wszBase;

		// take property and resolve
		obj->GetQualifierValue( pp[dw], L"base", &wszBase );
		if ( ! wszBase.IsEmpty() )
		{
			dwBase++;
		}
	}

	___ASSERT ( m_properties.IsEmpty() );

	try
	{
		typedef CObjectProperty* pCObjectProperty;
		if ( m_properties.SetData ( (new pCObjectProperty[ dwpp + dwBase ]), dwpp + dwBase ),
			 m_properties.IsEmpty() )
		{
			return E_OUTOFMEMORY;
		}
	}
	catch ( ... )
	{
		return E_UNEXPECTED;
	}

	for ( dw = 0, dwBase = 0; dw < dwpp; dw ++ )
	{
		if FAILED ( hRes = SetProperties ( pp[dw],
					( (pTypes != NULL) ? pTypes[dw] : CIM_EMPTY ),
					( (pScales != NULL) ? pScales[dw] : 0 ),
					( (pLevels != NULL) ? pLevels[dw] : PERF_DETAIL_NOVICE ),
					( (pCounters != NULL) ? pCounters[dw] : PERF_SIZE_ZERO ),
					dw + dwBase ) )
		{
			return hRes;
		}

		__Wrapper<WCHAR> wszBase;

		// take property and resolve
		obj->GetQualifierValue( pp[dw], L"base", &wszBase );
		if ( ! wszBase.IsEmpty() )
		{
			dwBase++;

			if FAILED ( hRes = SetProperties ( pp[dw],
						( (pTypes != NULL) ? pTypes[dw] : CIM_EMPTY ),
						( (pScales != NULL) ? pScales[dw] : 0 ),
						( (pLevels != NULL ) ? pLevels[dw] : PERF_DETAIL_NOVICE ),
						( (pCounters != NULL ) ? pCounters[dw] : PERF_SIZE_ZERO ),
						dw + dwBase ) )
			{
				return hRes;
			}

		}
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object_locale.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object_locale.h
//
//	Abstract:
//
//					structure containing properties of object in locale
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_OBJECT_LOCALE__
#define	__WMI_PERF_OBJECT_LOCALE__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// class contains locale strings !!!
class CLocale
{
	DECLARE_NO_COPY ( CLocale );

	LPWSTR	m_wszLocaleDisplayName;
	LPWSTR	m_wszLocaleDescription;

	public:

	CLocale ():
	m_wszLocaleDisplayName ( NULL ),
	m_wszLocaleDescription ( NULL )
	{
	}

	virtual ~CLocale ()
	{
		if ( m_wszLocaleDisplayName )
		{
			delete m_wszLocaleDisplayName;
			m_wszLocaleDisplayName = NULL;
		}

		if ( m_wszLocaleDescription )
		{
			delete m_wszLocaleDescription;
			m_wszLocaleDescription = NULL;
		}
	}

	// accessors

	void SetDisplayName ( LPWSTR wsz )
	{
		___ASSERT ( m_wszLocaleDisplayName == NULL );
		m_wszLocaleDisplayName = wsz;
	}

	void SetDescription ( LPWSTR wsz )
	{
		___ASSERT ( m_wszLocaleDescription == NULL );
		m_wszLocaleDescription = wsz;
	}

	LPWSTR GetDisplayName () const
	{
		return m_wszLocaleDisplayName;
	}

	LPWSTR GetDescription () const
	{
		return m_wszLocaleDescription;
	}
};

#include <winperf.h>

// class contains description of property
class CObjectProperty
{
	DECLARE_NO_COPY ( CObjectProperty );

	LPWSTR						m_wszName;	// system name of property
	CIMTYPE						m_type;

	__WrapperARRAY< CLocale* >	m_locale;	// locale information

	public:

	DWORD						dwDefaultScale;
	DWORD						dwDetailLevel;
	DWORD						dwCounterType;

	CObjectProperty () :
	m_wszName ( NULL ),
	m_type ( CIM_EMPTY )
	{
		dwDefaultScale	= 0;
		dwDetailLevel	= PERF_DETAIL_NOVICE;
		dwCounterType	= PERF_SIZE_ZERO;
	}

	virtual ~CObjectProperty ()
	{
		if ( m_wszName )
		{
			delete m_wszName;
			m_wszName = NULL;
		}
	}

	// accessors
	void	SetName ( LPWSTR wsz )
	{
		___ASSERT ( m_wszName == NULL );
		m_wszName = wsz;
	}

	LPWSTR	GetName ( ) const
	{
		return m_wszName;
	}

	void	SetType ( CIMTYPE type )
	{
		___ASSERT ( m_type == CIM_EMPTY );
		m_type = type;
	}

	CIMTYPE	GetType ( ) const
	{
		return m_type;
	}

	// locale :))

	void						SetArrayLocale ( CLocale** loc, DWORD dw )
	{
		___ASSERT ( m_locale.IsEmpty() );

		try
		{
			m_locale.SetData ( loc, dw );
		}
		catch ( ... )
		{
		}
	}

	__WrapperARRAY< CLocale* >&	GetArrayLocale ( )
	{
		return m_locale;
	}
};

#ifndef	__WMI_PERF_OBJECT__
#include "wmi_perf_object.h"
#endif	__WMI_PERF_OBJECT__

class CObject
{
	DECLARE_NO_COPY ( CObject );

	LPWSTR								m_wszName;		// system name of object

	__WrapperARRAY< CLocale* >			m_locale;		// locale information
	__WrapperARRAY< CObjectProperty* >	m_properties;	// properties and theirs locale

	__WrapperARRAY< LPWSTR >			m_keys;

	public:

	DWORD								dwDetailLevel;

	CObject () :
	m_wszName ( NULL )
	{
		dwDetailLevel = PERF_DETAIL_NOVICE;
	}

	virtual ~CObject ()
	{
		if ( m_wszName )
		{
			delete m_wszName;
			m_wszName = NULL;
		}
	}

	// accessors
	void	SetName ( LPWSTR wsz )
	{
		___ASSERT ( m_wszName == NULL );
		m_wszName = wsz;
	}

	LPWSTR	GetName ( ) const
	{
		return m_wszName;
	}

	// locale :))
	void						SetArrayLocale ( CLocale** loc, DWORD dw )
	{
		___ASSERT ( m_locale.IsEmpty() );

		try
		{
			m_locale.SetData ( loc, dw );
		}
		catch ( ... )
		{
		}
	}

	__WrapperARRAY< CLocale* >&	GetArrayLocale ( )
	{
		return m_locale;
	}

	// properties :))
	void						SetArrayProperties ( CObjectProperty** prop, DWORD dw )
	{
		___ASSERT ( m_properties.IsEmpty() );

		try
		{
			m_properties.SetData ( prop, dw );
		}
		catch ( ... )
		{
		}
	}

	__WrapperARRAY< CObjectProperty* >&	GetArrayProperties ( )
	{
		return m_properties;
	}

	// keys :))
	void						SetArrayKeys ( LPWSTR* keys, DWORD dw )
	{
		___ASSERT ( m_keys.IsEmpty() );

		try
		{
			m_keys.SetData ( keys, dw );
		}
		catch ( ... )
		{
		}
	}

	__WrapperARRAY< LPWSTR >&	GetArrayKeys ( )
	{
		return m_keys;
	}

	// helper
	HRESULT	SetProperties ( CPerformanceObject* obj,	// object
							LPWSTR*		props,			// its properties
							CIMTYPE*	pTypes,			// its properties types
							DWORD*		pScales,		// its properties scales
							DWORD*		pLevels,		// its properties levels
							DWORD*		pCounters,		// its properties counter types
							DWORD		dw );

	private:

	HRESULT SetProperties ( LPWSTR wsz,
							CIMTYPE type,
							DWORD dwScale,
							DWORD dwLevel,
							DWORD dwCounter,
							DWORD dw );
};

#endif	__WMI_PERF_OBJECT_LOCALE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\__common.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__common.h
//
//	Abstract:
//
//					stl compare common functions
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__COMMON__
#define	__COMMON__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifdef	NEW
#undef	NEW
#undef	new
#endif	NEW

#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP

// stl headers
#include <map>

using namespace std;

//////////////////////////////////////////////////////////////////////////
// compare function
//////////////////////////////////////////////////////////////////////////

template<class _LPWSTR>
struct __CompareLPWSTR : public binary_function<_LPWSTR, _LPWSTR, bool>
{
	bool operator()(const _LPWSTR& x, const _LPWSTR& y) const
	{
		return ( lstrcmpW ( x, y ) < 0 ) ? true : false;
	}
};

//////////////////////////////////////////////////////////////////////////
// ALLOCATOR
//////////////////////////////////////////////////////////////////////////

#include <memory>

template<class _Ty>
class RA_allocator
{
	public:

	typedef _SIZT size_type;
	typedef _PDFT difference_type;
	typedef _Ty _FARQ *pointer;
	typedef const _Ty _FARQ *const_pointer;
	typedef _Ty _FARQ &reference;
	typedef const _Ty _FARQ &const_reference;
	typedef _Ty value_type;

	pointer address(reference _X) const
	{
		return (&_X);
	}
	const_pointer address(const_reference _X) const
	{
		return (&_X);
	}
	char _FARQ *_Charalloc(size_type _N)
	{
		char _FARQ * pRet = ((char _FARQ *)operator new((_SIZT)_N * sizeof (_Ty)));

		if ( NULL == pRet )
		{
			throw E_OUTOFMEMORY;
		}

		return pRet; 
	}
	pointer allocate(size_type _N, const void *)
	{
		_Ty _FARQ * pRet = ((_Ty _FARQ *)operator new((_SIZT)_N * sizeof (_Ty)));

		if ( NULL == pRet )
		{
			throw E_OUTOFMEMORY;
		}

		return pRet;
	}
	void deallocate(void *_P, size_type)
	{
		operator delete(_P);
	}
	void construct(pointer _P, const _Ty& _V)
	{
		std::_Construct(_P, _V);
	}
	void destroy(pointer _P)
	{
		std::_Destroy(_P);
	}
	_SIZT max_size() const
	{
		_SIZT _N = (_SIZT)(-1) / sizeof (_Ty);
		return (0 < _N ? _N : 1);
	}
};

// return that all specializations of this allocator are interchangeable
//
// Note: we need these operator bacause they are called by swap friend function
//
template <class T1, class T2>
bool operator== (const RA_allocator<T1>&,
	const RA_allocator<T2>&){
	return true;
}
template <class T1, class T2>
bool operator!= (const RA_allocator<T1>&,
	const RA_allocator<T2>&){
	return false;
}

#endif	__COMMON__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\allocator.cpp ===
#ifndef __ALLOCATOR_CPP
#define __ALLOCATOR_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <Allocator.h>

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAllocator :: WmiAllocator () : 

	m_Heap ( NULL ) , 
	m_Options ( e_DefaultAllocation ) ,
	m_InitialSize ( 0 ) ,
	m_MaximumSize ( 0 ) ,
	m_ReferenceCount ( 0 )
{
	m_Heap = GetProcessHeap () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
	
WmiAllocator :: WmiAllocator ( 

	AllocationOptions a_Option , 
	size_t a_InitialSize , 
	size_t a_MaximumSize
) : 
	m_Heap ( NULL ) , 
	m_Options ( a_Option ) ,
	m_InitialSize ( a_InitialSize ) ,
	m_MaximumSize ( a_MaximumSize ) ,
	m_ReferenceCount ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAllocator :: ~WmiAllocator ()
{
	UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG WmiAllocator :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG WmiAllocator :: Release () 
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: Win32ToApi () 
{
	WmiStatusCode t_Status = e_StatusCode_Success ;

	DWORD t_LastError = GetLastError () ;
	switch ( t_LastError )
	{
		case STATUS_NO_MEMORY:
		{
			t_Status = e_StatusCode_OutOfMemory ;
		}
		break ;

		default:
		{
			t_Status = e_StatusCode_Unknown ;
		}
		break ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Heap == NULL )
	{
		m_Heap = HeapCreate ( 

			m_Options ,
			m_InitialSize ,
			m_MaximumSize
		) ;

		if ( m_Heap == NULL )
		{
			t_StatusCode = Win32ToApi () ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Heap )
	{
		if ( m_Heap != GetProcessHeap () )
		{		
			BOOL t_Status = HeapDestroy ( m_Heap ) ;
			if ( t_Status ) 
			{
				m_Heap = NULL ;
			}
			else
			{
				t_Status = Win32ToApi () ;
			}
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: New ( 

	void **a_Allocation , 
	size_t a_Size
)
{
	return New ( 

		( AllocationOptions ) ( ( m_Options & ( e_GenerateException | e_NoSerialize ) ) | e_ZeroMemory ) ,
		a_Allocation , 
		a_Size
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: New ( 

	AllocationOptions a_Option , 
	void **a_Allocation , 
	size_t a_Size
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Heap )
	{
		*a_Allocation = HeapAlloc (

			m_Heap ,	
			a_Option ,
			a_Size 
		) ;

		if ( ! *a_Allocation )
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: ReAlloc ( 

	void *a_Allocation , 
	void **a_ReAllocation , 
	size_t a_Size
)
{
	return ReAlloc ( 

		( AllocationOptions ) ( ( m_Options & ( e_GenerateException | e_NoSerialize ) ) ) , 
		a_Allocation , 
		a_ReAllocation , 
		a_Size
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: ReAlloc ( 

	AllocationOptions a_Option , 
	void *a_Allocation , 
	void **a_ReAllocation , 
	size_t a_Size
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Heap )
	{
		*a_ReAllocation = HeapReAlloc (

			m_Heap ,	
			a_Option ,
			a_Allocation ,
			a_Size 
		) ;

		if ( ! *a_ReAllocation )
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: Delete (

	void *a_Allocation
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Heap )
	{
		BOOL t_Status = HeapFree ( 

			m_Heap , 
			0 , 
			a_Allocation
		) ;

		if ( ! t_Status )
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: Size ( 

	void *a_Allocation ,
	size_t &a_Size
) 
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Heap )
	{
		a_Size = HeapSize ( 

			m_Heap ,
			m_Options & e_NoSerialize ,
			a_Allocation
		) ;

		if ( a_Size == -1 )
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_AlreadyInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: Compact ( 

	size_t &a_LargestFreeBlock
) 
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Heap )
	{
		a_LargestFreeBlock = HeapCompact ( 

			m_Heap ,
			m_Options & e_NoSerialize 
		) ;

		if ( a_LargestFreeBlock == 0 && GetLastError () != 0 )
		{
			t_StatusCode = Win32ToApi () ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_AlreadyInitialized ;
	}

	return t_StatusCode ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiAllocator :: Validate ( LPCVOID a_Location ) 
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	BOOL t_Status = HeapValidate (

		m_Heap,
		m_Options & e_NoSerialize ,
		a_Location
	) ;

	if ( ! t_Status )
	{
		t_StatusCode = e_StatusCode_InvalidHeap ;
	}

	return t_StatusCode ;
}

#endif __ALLOCATOR_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\algorithms.cpp ===
#ifndef __ALGORITHMS_CPP
#define __ALGORITHMS_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#include <Stack.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#ifdef WMI_CONTAINER_PERFORMANCE_TESTING
extern ULONG g_Compare ;
#endif

template <class WmiElement>
LONG CompareElement ( const WmiElement &a_Arg1 , const WmiElement &a_Arg2 )
{
#ifdef WMI_CONTAINER_PERFORMANCE_TESTING
	g_Compare ++ ;
#endif

	if ( a_Arg1 == a_Arg2 )
	{
		return 0 ;
	}
	else if ( a_Arg1 < a_Arg2 )
	{
		return -1 ;
	}

	return 1 ;	
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class StackElement
{
public:

	ULONG m_Lower ;
	ULONG m_Upper ;

	StackElement () {;}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode Flat_QuickSort ( WmiElement *a_Array , ULONG a_Size )
{
	if ( a_Size )
	{
		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiStack <StackElement,8> t_Stack ( t_Allocator ) ;

			StackElement t_Element ;
			t_Element.m_Lower = 1 ;
			t_Element.m_Upper = a_Size - 1 ;

			t_Stack.Push ( t_Element ) ;

			while ( t_Stack.Size () )
			{
				StackElement t_Top ;

				WmiStatusCode t_StatusCode = t_Stack.Top ( t_Top ) ;
				t_StatusCode = t_Stack.Pop () ;

				if ( t_StatusCode == e_StatusCode_Success )
				{
					if ( t_Top.m_Lower <= t_Top.m_Upper )
					{
						ULONG t_LeftIndex = t_Top.m_Lower  ; 
						ULONG t_RightIndex = t_Top.m_Upper ; 

						while ( true )
						{
							while ( ( t_LeftIndex < t_RightIndex ) && ( CompareElement ( a_Array [ t_LeftIndex ]  , a_Array [ t_Top.m_Lower - 1 ] ) <= 0 ) )
							{
								t_LeftIndex ++ ;
							}

							while ( ( t_LeftIndex < t_RightIndex ) && ( CompareElement ( a_Array [ t_Top.m_Lower - 1 ]  , a_Array [ t_RightIndex ] ) <= 0 ) )
							{
								t_RightIndex -- ;
							}

							if ( t_LeftIndex < t_RightIndex ) 
							{
								WmiElement t_Temp = a_Array [ t_LeftIndex ] ;
								a_Array [ t_LeftIndex ] = a_Array [ t_RightIndex ] ;
								a_Array [ t_RightIndex ] = t_Temp ;
							}
							else
							{
								break ;
							}
						}

						LONG t_Compare = CompareElement ( a_Array [ t_LeftIndex ] , a_Array [ t_Top.m_Lower - 1 ] ) ;
						if ( t_Compare < 0 )
						{
							WmiElement t_Temp = a_Array [ t_LeftIndex ] ;
							a_Array [ t_LeftIndex ] = a_Array [ t_Top.m_Lower - 1 ] ;
							a_Array [ t_Top.m_Lower - 1 ] = t_Temp ;
						}

						StackElement t_Element ;
						t_Element.m_Lower = t_Top.m_Lower ;
						t_Element.m_Upper = t_LeftIndex - 1  ;

						t_StatusCode = t_Stack.Push ( t_Element ) ;

						t_Element.m_Lower = t_LeftIndex + 1 ;
						t_Element.m_Upper = t_Top.m_Upper ;

						t_StatusCode = t_Stack.Push ( t_Element ) ;
					}
				}
			}
		}
	}

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
void RecursiveQuickSort ( WmiElement *a_Array , ULONG a_Lower , ULONG a_Upper )
{
	if ( a_Lower <= a_Upper )
	{
		ULONG t_LeftIndex = a_Lower ; 
		ULONG t_RightIndex = a_Upper ;

		while ( true )
		{
			while ( ( t_LeftIndex < t_RightIndex ) && ( CompareElement ( a_Array [ t_LeftIndex ]  , a_Array [ a_Lower - 1 ] ) <= 0 ) )
			{
				t_LeftIndex ++ ;
			}

			while ( ( t_LeftIndex < t_RightIndex ) && ( CompareElement ( a_Array [ a_Lower - 1 ]  , a_Array [ t_RightIndex ] ) <= 0 ) )
			{
				t_RightIndex -- ;
			}

			if ( t_LeftIndex < t_RightIndex ) 
			{
				WmiElement t_Temp = a_Array [ t_LeftIndex ] ;
				a_Array [ t_LeftIndex ] = a_Array [ t_RightIndex ] ;
				a_Array [ t_RightIndex ] = t_Temp ;
			}
			else
			{
				break ;
			}
		}

		LONG t_Compare = CompareElement ( a_Array [ t_LeftIndex ] , a_Array [ a_Lower - 1 ] ) ;
		if ( t_Compare < 0 )
		{
			WmiElement t_Temp = a_Array [ t_LeftIndex ] ;
			a_Array [ t_LeftIndex ] = a_Array [ a_Lower - 1 ] ;
			a_Array [ a_Lower - 1 ] = t_Temp ;
		}

		RecursiveQuickSort ( 

			a_Array , 
			a_Lower , 
			t_LeftIndex - 1 
		) ;

 		RecursiveQuickSort ( 

			a_Array  , 
			t_LeftIndex + 1 , 
			a_Upper
		) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement>
WmiStatusCode QuickSort ( WmiElement *a_Array , ULONG a_Size )
{
	RecursiveQuickSort ( a_Array , 1 , a_Size - 1 ) ;

	return e_StatusCode_Success ;
}

#endif __ALGORITHMS_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\avltree.cpp ===
#ifndef _AVLTREE_CPP
#define _AVLTREE_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <AvlTree.h>

#endif

#if 1
#define INLINE_COMPARE 
#endif
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiAvlTree <WmiKey,WmiElement> :: WmiAvlTree <WmiKey,WmiElement> ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Size ( 0 ) ,
	m_Root ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiAvlTree <WmiKey,WmiElement> :: ~WmiAvlTree <WmiKey,WmiElement> ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		t_StatusCode = RecursiveUnInitialize ( m_Root ) ;
		m_Root = NULL;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: RecursiveUnInitialize ( WmiAvlNode *a_Node )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAvlNode *t_Left = a_Node->m_Left ;
	if ( t_Left )
	{
		t_StatusCode = RecursiveUnInitialize ( t_Left ) ;

		t_Left->~WmiAvlNode () ;

		WmiStatusCode t_TempStatusCode = m_Allocator.Delete (

			( void * ) t_Left
		) ;

		t_Left = NULL ;
	}

	WmiAvlNode *t_Right = a_Node->m_Right ;
	if ( t_Right )
	{
		t_StatusCode = RecursiveUnInitialize ( t_Right ) ;

		t_Right->~WmiAvlNode () ;

		WmiStatusCode t_TempStatusCode = m_Allocator.Delete (

			( void * ) t_Right
		) ;

		t_Right = NULL ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Insert ( 

	const WmiKey &a_Key ,
	const WmiElement &a_Element ,
	Iterator &a_Iterator 
)
{
	if ( m_Root ) 
	{
		bool t_Increased ;

		WmiAvlNode *t_Node = m_Root ;
		while ( t_Node )
		{
#ifdef INLINE_COMPARE
			LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
			if ( t_Compare == 0 )
#else
			if ( a_Key == t_Node->m_Key )
#endif
			{
				return e_StatusCode_AlreadyExists ;
			}
			else 
			{
#ifdef INLINE_COMPARE
				if ( t_Compare < 0 )
#else
				if ( a_Key < t_Node->m_Key )
#endif
				{
					if ( t_Node->m_Left )
					{
						t_Node = t_Node->m_Left ;
					}
					else
					{
						WmiAvlNode *t_AllocNode ;
						WmiStatusCode t_StatusCode = m_Allocator.New (

							( void ** ) & t_AllocNode ,
							sizeof ( WmiAvlNode ) 
						) ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							::  new ( ( void* ) t_AllocNode ) WmiAvlNode () ;

							try
							{
								t_AllocNode->m_Element = a_Element ;
								t_AllocNode->m_Key = a_Key ;
							}
							catch ( Wmi_Heap_Exception &a_Exception )
							{
								t_AllocNode->~WmiAvlNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_OutOfMemory ;
							}
							catch ( ... )
							{
								t_AllocNode->~WmiAvlNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_Unknown ;
							}

							a_Iterator = Iterator ( t_AllocNode ) ;

							m_Size ++ ;

							t_Increased = true ;

							t_AllocNode->m_Parent = t_Node ;
							t_Node->m_Left = t_AllocNode ;

							t_StatusCode = Insert_LeftBalance ( 

								t_Node ,
								t_Node->m_Left ,
								t_Increased 
							) ;

							while ( t_Increased )
							{
								WmiAvlNode *t_ParentNode = t_Node->m_Parent ;
								if ( t_ParentNode )
								{
									if ( t_ParentNode->m_Left == t_Node )
									{
										t_StatusCode = Insert_LeftBalance ( 

											t_ParentNode ,
											t_Node ,
											t_Increased 
										) ;
									}
									else
									{
										t_StatusCode = Insert_RightBalance ( 

											t_ParentNode ,
											t_Node ,
											t_Increased 
										) ;
									}

									t_Node = t_Node->m_Parent ;
								}
								else
								{
									return e_StatusCode_Success ;
								}
							}

							return e_StatusCode_Success ;
						}
						else
						{
							return t_StatusCode ;
						}
					}
				}
				else
				{
					if ( t_Node->m_Right )
					{
						t_Node = t_Node->m_Right ;
					}
					else
					{

						WmiAvlNode *t_AllocNode ;
						WmiStatusCode t_StatusCode = m_Allocator.New (

							( void ** ) & t_AllocNode ,
							sizeof ( WmiAvlNode ) 
						) ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							::  new ( ( void* ) t_AllocNode ) WmiAvlNode () ;

							try
							{
								t_AllocNode->m_Element = a_Element ;
								t_AllocNode->m_Key = a_Key ;
							}
							catch ( Wmi_Heap_Exception &a_Exception )
							{
								t_AllocNode->~WmiAvlNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_OutOfMemory ;
							}
							catch ( ... )
							{
								t_AllocNode->~WmiAvlNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_Unknown ;
							}

							a_Iterator = Iterator ( t_AllocNode ) ;
					
							m_Size ++ ;

							t_Increased = true ;

							t_AllocNode->m_Parent = t_Node ;
							t_Node->m_Right = t_AllocNode ;

							t_StatusCode = Insert_RightBalance ( 

								t_Node ,
								t_Node->m_Right ,
								t_Increased 
							) ;

							while ( t_Increased )
							{
								WmiAvlNode *t_ParentNode = t_Node->m_Parent ;
								if ( t_ParentNode )
								{
									if ( t_ParentNode->m_Left == t_Node )
									{
										t_StatusCode = Insert_LeftBalance ( 

											t_ParentNode ,
											t_Node ,
											t_Increased 
										) ;
									}
									else
									{
										t_StatusCode = Insert_RightBalance ( 

											t_ParentNode ,
											t_Node ,
											t_Increased 
										) ;
									}

									t_Node = t_ParentNode ;
								}
								else
								{
									return e_StatusCode_Success ;
								}
							}

							return e_StatusCode_Success ;
						}
						else
						{
							return t_StatusCode ;
						}
					}
				}
			}
		}

		return e_StatusCode_Failed ;
	}
	else
	{
		WmiAvlNode *t_AllocNode ;
		WmiStatusCode t_StatusCode = m_Allocator.New (

			( void ** ) & t_AllocNode ,
			sizeof ( WmiAvlNode ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			::  new ( ( void* ) t_AllocNode ) WmiAvlNode () ;

			try
			{
				t_AllocNode->m_Element = a_Element ;
				t_AllocNode->m_Key = a_Key ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_AllocNode->~WmiAvlNode () ;

				WmiStatusCode t_StatusCode = m_Allocator.Delete (

					( void * ) t_AllocNode
				) ;

				return e_StatusCode_OutOfMemory ;
			}
			catch ( ... )
			{
				t_AllocNode->~WmiAvlNode () ;

				WmiStatusCode t_StatusCode = m_Allocator.Delete (

					( void * ) t_AllocNode
				) ;

				return e_StatusCode_Unknown ;
			}

			a_Iterator = Iterator ( t_AllocNode ) ;

			m_Root = t_AllocNode ;

			m_Size ++ ;
		}

		return t_StatusCode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Delete ( 

	const WmiKey &a_Key
)
{
	if ( m_Root ) 
	{
		bool t_Decreased ;

		WmiAvlNode *t_Node = m_Root ;
		while ( t_Node )
		{
#ifdef INLINE_COMPARE
			LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
			if ( t_Compare == 0 )
#else
			if ( a_Key == t_Node->m_Key )
#endif
			{
				WmiAvlNode *t_ParentNode = t_Node->m_Parent ;
				if ( t_ParentNode )
				{
					bool t_LeftSide = t_ParentNode->m_Left == t_Node ? true : false ;

					WmiStatusCode t_StatusCode = DeleteFixup ( t_Node , t_Decreased ) ;

					m_Size -- ;

					while ( t_Decreased )
					{
						if ( t_ParentNode )
						{
							if ( t_LeftSide )
							{
								t_StatusCode = Delete_LeftBalance ( 

									t_ParentNode ,
									t_ParentNode->m_Right ,
									t_Decreased 
								) ;
							}
							else
							{
								t_StatusCode = Delete_RightBalance ( 

									t_ParentNode ,
									t_ParentNode->m_Left ,
									t_Decreased 
								) ;
							}

							t_Node = t_ParentNode ;
							t_ParentNode = t_Node->m_Parent ;
							if ( t_ParentNode )
							{
								t_LeftSide = t_ParentNode->m_Left == t_Node ? true : false ;
							}
						}
						else
						{
							return e_StatusCode_Success ;
						}
					}

					return e_StatusCode_Success ;
				}
				else
				{
					m_Size -- ;

					return DeleteFixup ( t_Node , t_Decreased ) ;
				}
			}
			else 
			{
#ifdef INLINE_COMPARE
				if ( t_Compare < 0 )
#else
				if ( a_Key < t_Node->m_Key )
#endif
				{
					if ( t_Node->m_Left )
					{
						t_Node = t_Node->m_Left ;
					}
					else
					{
						return e_StatusCode_NotFound  ;
					}
				}
				else
				{
					if ( t_Node->m_Right )
					{
						t_Node = t_Node->m_Right ;
					}
					else
					{
						return e_StatusCode_NotFound  ;
					}
				}
			}
		}

		return e_StatusCode_Failed ;
	}
	else
	{
		return e_StatusCode_NotFound  ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Find (

	const WmiKey &a_Key ,
	Iterator &a_Iterator
)
{
	WmiAvlNode *t_Node = m_Root ;
	while ( t_Node )
	{
#ifdef INLINE_COMPARE
		LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
		if ( t_Compare == 0 )
#else
		if ( a_Key == t_Node->m_Key )
#endif
		{
			a_Iterator = Iterator ( t_Node ) ;
			return e_StatusCode_Success ;
		}
		else 
		{
#ifdef INLINE_COMPARE
			if ( t_Compare < 0 )
#else
			if ( a_Key < t_Node->m_Key )
#endif
			{
				t_Node = t_Node->m_Left ;
			}
			else
			{
				t_Node = t_Node->m_Right ;
			}
		}
	}
	
	return e_StatusCode_NotFound ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: FindNext (

	const WmiKey &a_Key ,
	Iterator &a_Iterator
)
{
	WmiAvlNode *t_Node = m_Root ;
	while ( t_Node )
	{
#ifdef INLINE_COMPARE
		LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
		if ( t_Compare == 0 )
#else
		if ( a_Key == t_Node->m_Key )
#endif
		{
			a_Iterator = Iterator ( t_Node ).Increment () ;

			return a_Iterator.Null () ? e_StatusCode_NotFound : e_StatusCode_Success ;
		}
		else 
		{
#ifdef INLINE_COMPARE
			if ( t_Compare < 0 )
#else
			if ( a_Key < t_Node->m_Key )
#endif
			{
				if ( t_Node->m_Left )
				{
					t_Node = t_Node->m_Left ;
				}
				else
				{
					a_Iterator = Iterator ( t_Node ) ;
					
					return e_StatusCode_Success ;
				}
			}
			else
			{
				if ( t_Node->m_Right )
				{
					t_Node = t_Node->m_Right ;
				}
				else
				{
					a_Iterator = Iterator ( t_Node ).Increment () ;

					return a_Iterator.Null () ? e_StatusCode_NotFound : e_StatusCode_Success ;
				}
			}
		}
	}
	
	return e_StatusCode_NotFound ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Check ( ULONG & a_MaxHeight )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

#if 0
	printf ( "\nStart Check ( %ld )" , m_Size ) ;
#endif
	if ( m_Root )
	{
		if ( m_Root->m_Parent == NULL )
		{
			ULONG t_Count = 1 ;
			ULONG t_Height = 0 ;
			a_MaxHeight = 0 ;
			t_StatusCode = RecursiveCheck ( m_Root , t_Count , t_Height , a_MaxHeight ) ;
			if ( t_StatusCode == e_StatusCode_Success )
			{
				if ( t_Count != m_Size )
				{
					t_StatusCode = e_StatusCode_Failed ;
				}
			}
		}
		else
		{
			t_StatusCode = e_StatusCode_Failed ;
		}
	}

#if 0
	printf ( "\nEnd Check" ) ;
#endif

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Insert_LeftBalance ( 

	WmiAvlNode *&A , 
	WmiAvlNode *B , 
	bool &a_Increased
)
{	
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_Increased )
	{
		switch ( A->m_State ) 
		{
			case WmiAvlNode :: e_Equal:
			{
				A->m_State = WmiAvlNode :: e_LeftHigher ;
			}
			break ;

			case WmiAvlNode :: e_RightHigher:
			{
				A->m_State = WmiAvlNode :: e_Equal ;
				a_Increased = false ;
			}
			break ;

			case WmiAvlNode :: e_LeftHigher:
			{
				a_Increased = false ;
				switch ( B->m_State )	
				{
					case WmiAvlNode :: e_Equal:
					{
					}
					break ;

					case WmiAvlNode :: e_LeftHigher:
					{
						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Right )
						{
							B->m_Right->m_Parent = A ;
						}

						A->m_State = WmiAvlNode :: e_Equal ;
						A->m_Left = B->m_Right ;
						A->m_Parent = B ;

						B->m_State = WmiAvlNode :: e_Equal ;
						B->m_Right = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiAvlNode :: e_RightHigher:
					{
						WmiAvlNode *C = A->m_Left->m_Right ;

						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = C ;
							}
							else
							{
								t_Parent->m_Right = C ;
							}
						}
						else
						{
							m_Root = C ;
						}

						A->m_Parent = C ;
						B->m_Parent = C ;

						if ( C->m_Left )
						{
							C->m_Left->m_Parent = B ;
						}

						if ( C->m_Right )
						{
							C->m_Right->m_Parent = A ;
						}

						A->m_Left = C->m_Right ;
						B->m_Right = C->m_Left ;

						C->m_Left = B ;
						C->m_Right = A ;
						C->m_Parent = t_Parent ;

						switch ( C->m_State )
						{
							case WmiAvlNode :: e_LeftHigher:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_RightHigher ;
							}
							break ;

							case WmiAvlNode :: e_RightHigher:
							{
								B->m_State = WmiAvlNode :: e_LeftHigher ;
								A->m_State = WmiAvlNode :: e_Equal ;
							}
							break ;

							case WmiAvlNode :: e_Equal:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_Equal ;
							}
							break ;

							default:
							{
								t_StatusCode = e_StatusCode_Unknown ;
							}
							break ;
						}

						C->m_State = WmiAvlNode :: e_Equal ;

						A = C ;
					}
					break ;

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;
					}
					break ;
				}
			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Insert_RightBalance ( 

	WmiAvlNode *&A , 
	WmiAvlNode *B , 
	bool &a_Increased
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_Increased )
	{
		switch ( A->m_State ) 
		{
			case WmiAvlNode :: e_Equal:
			{
				A->m_State = WmiAvlNode :: e_RightHigher ;
			}
			break ;

			case WmiAvlNode :: e_LeftHigher:
			{
				A->m_State = WmiAvlNode :: e_Equal ;
				a_Increased = false ;
			}
			break ;

			case WmiAvlNode :: e_RightHigher:
			{
				a_Increased = false ;
				switch ( B->m_State )	
				{
					case WmiAvlNode :: e_Equal:
					{
					}
					break ;

					case WmiAvlNode :: e_RightHigher:
					{
						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Left )
						{
							B->m_Left->m_Parent = A ;
						}

						A->m_State = WmiAvlNode :: e_Equal ;
						A->m_Right = B->m_Left ;
						A->m_Parent = B ;

						B->m_State = WmiAvlNode :: e_Equal ;
						B->m_Left = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiAvlNode :: e_LeftHigher:
					{
						WmiAvlNode *C = A->m_Right->m_Left ;

						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = C ;
							}
							else
							{
								t_Parent->m_Right = C ;
							}
						}
						else
						{
							m_Root = C ;
						}

						A->m_Parent = C ;
						B->m_Parent = C ;

						if ( C->m_Right )
						{
							C->m_Right->m_Parent = B ;
						}

						if ( C->m_Left )
						{
							C->m_Left->m_Parent = A ;
						}

						B->m_Left = C->m_Right ;
						A->m_Right = C->m_Left ;

						C->m_Right = B ;
						C->m_Left = A ;
						C->m_Parent = t_Parent ;

						switch ( C->m_State )
						{
							case WmiAvlNode :: e_LeftHigher:
							{
								B->m_State = WmiAvlNode :: e_RightHigher ;
								A->m_State = WmiAvlNode :: e_Equal ;
							}
							break ;

							case WmiAvlNode :: e_RightHigher:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_LeftHigher ;
							}
							break ;

							case WmiAvlNode :: e_Equal:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_Equal ;
							}
							break ;

							default:
							{
								t_StatusCode = e_StatusCode_Unknown ;		
							}
							break ;
						}

						C->m_State = WmiAvlNode :: e_Equal ;

						A = C ;
					}
					break ;

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;
					}
					break ;
				}
			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Delete_LeftBalance ( 

	WmiAvlNode *&A , 
	WmiAvlNode *B , 
	bool &a_Decreased
)
{	
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_Decreased )
	{
		switch ( A->m_State ) 
		{
			case WmiAvlNode :: e_Equal:
			{
				A->m_State = WmiAvlNode :: e_RightHigher ;
				a_Decreased = false ;
			}
			break ;

			case WmiAvlNode :: e_LeftHigher:
			{
				A->m_State = WmiAvlNode :: e_Equal ;
			}
			break ;

			case WmiAvlNode :: e_RightHigher:
			{
				switch ( B->m_State )	
				{
					case WmiAvlNode :: e_Equal:
					{
						a_Decreased = false ;

						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Left )
						{
							B->m_Left->m_Parent = A ;
						}

						A->m_State = WmiAvlNode :: e_RightHigher ;
						A->m_Right = B->m_Left ;
						A->m_Parent = B ;

						B->m_State = WmiAvlNode :: e_LeftHigher ;
						B->m_Left = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiAvlNode :: e_RightHigher:
					{
						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Left )
						{
							B->m_Left->m_Parent = A ;
						}

						A->m_State = WmiAvlNode :: e_Equal ;
						A->m_Right = B->m_Left ;
						A->m_Parent = B ;

						B->m_State = WmiAvlNode :: e_Equal ;
						B->m_Left = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiAvlNode :: e_LeftHigher:
					{
						WmiAvlNode *C = A->m_Right->m_Left ;

						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = C ;
							}
							else
							{
								t_Parent->m_Right = C ;
							}
						}
						else
						{
							m_Root = C ;
						}

						A->m_Parent = C ;
						B->m_Parent = C ;

						if ( C->m_Left )
						{
							C->m_Left->m_Parent = A ;
						}

						if ( C->m_Right )
						{
							C->m_Right->m_Parent = B ;
						}

						A->m_Right = C->m_Left ;
						B->m_Left = C->m_Right ;

						C->m_Left = A ;
						C->m_Right = B ;
						C->m_Parent = t_Parent ;

						switch ( C->m_State )
						{
							case WmiAvlNode :: e_LeftHigher:
							{
								A->m_State = WmiAvlNode :: e_Equal ;
								B->m_State = WmiAvlNode :: e_RightHigher ;
							}
							break ;

							case WmiAvlNode :: e_RightHigher:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_LeftHigher ;
							}
							break ;

							case WmiAvlNode :: e_Equal:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_Equal ;
							}
							break ;

							default:
							{
								t_StatusCode = e_StatusCode_Unknown ;
							}
							break ;
						}

						C->m_State = WmiAvlNode :: e_Equal ;

						A = C ;
					}
					break ;

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;
					}
					break ;
				}
			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Delete_RightBalance ( 

	WmiAvlNode *&A , 
	WmiAvlNode *B , 
	bool &a_Decreased
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( a_Decreased )
	{
		switch ( A->m_State ) 
		{
			case WmiAvlNode :: e_Equal:
			{
				A->m_State = WmiAvlNode :: e_LeftHigher ;
				a_Decreased = false ;
			}
			break ;

			case WmiAvlNode :: e_RightHigher:
			{
				A->m_State = WmiAvlNode :: e_Equal ;
			}
			break ;

			case WmiAvlNode :: e_LeftHigher:
			{
				switch ( B->m_State )	
				{
					case WmiAvlNode :: e_Equal:
					{
						a_Decreased = false ;

						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Right )
						{
							B->m_Right->m_Parent = A ;
						}

						A->m_State = WmiAvlNode :: e_LeftHigher ;
						A->m_Left = B->m_Right ;
						A->m_Parent = B ;

						B->m_State = WmiAvlNode :: e_RightHigher ;
						B->m_Right = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiAvlNode :: e_LeftHigher:
					{
						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = B ;
							}
							else
							{
								t_Parent->m_Right = B ;
							}
						}
						else
						{
							m_Root = B ;
						}

						if ( B->m_Right )
						{
							B->m_Right->m_Parent = A ;
						}

						A->m_State = WmiAvlNode :: e_Equal ;
						A->m_Left = B->m_Right ;
						A->m_Parent = B ;

						B->m_State = WmiAvlNode :: e_Equal ;
						B->m_Right = A ;
						B->m_Parent = t_Parent ;

						A = B ;
					}
					break ;

					case WmiAvlNode :: e_RightHigher:
					{
						WmiAvlNode *C = A->m_Left->m_Right ;

						WmiAvlNode *t_Parent = A->m_Parent ;
						if ( t_Parent ) 
						{
							if ( t_Parent->m_Left == A ) 
							{
								t_Parent->m_Left = C ;
							}
							else
							{
								t_Parent->m_Right = C ;
							}
						}
						else
						{
							m_Root = C ;
						}

						A->m_Parent = C ;
						B->m_Parent = C ;

						if ( C->m_Left )
						{
							C->m_Left->m_Parent = B ;
						}

						if ( C->m_Right )
						{
							C->m_Right->m_Parent = A ;
						}

						A->m_Left = C->m_Right ;
						B->m_Right = C->m_Left ;

						C->m_Left = B ;
						C->m_Right = A ;
						C->m_Parent = t_Parent ;

						switch ( C->m_State )
						{
							case WmiAvlNode :: e_LeftHigher:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_RightHigher ;
							}
							break ;

							case WmiAvlNode :: e_RightHigher:
							{
								A->m_State = WmiAvlNode :: e_Equal ;
								B->m_State = WmiAvlNode :: e_LeftHigher ;
							}
							break ;

							case WmiAvlNode :: e_Equal:
							{
								B->m_State = WmiAvlNode :: e_Equal ;
								A->m_State = WmiAvlNode :: e_Equal ;
							}
							break ;

							default:
							{
								t_StatusCode = e_StatusCode_Unknown ;
							}
							break ;
						}

						C->m_State = WmiAvlNode :: e_Equal ;

						A = C ;
					}
					break ;

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;
					}
					break ;
				}
			}
			break ;

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: RecursiveCheck ( 

	WmiAvlNode *a_Node ,
	ULONG &a_Count ,
	ULONG a_Height ,
	ULONG &a_MaxHeight
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Height ++ ;

#if 0
	printf ( "\n" ) ;
	for ( ULONG t_TabIndex = 0 ; t_TabIndex < a_Height ; t_TabIndex ++ ) 
	{
		printf ( "++++" ) ;
	}

	printf ( "%ld" , a_Node->m_Key ) ;

	switch ( a_Node->m_State )
	{
		case WmiAvlNode :: e_LeftHigher:
		{
			printf ( "\t LH" ) ;
		}
		break ;

		case WmiAvlNode :: e_RightHigher:
		{
			printf ( "\t RH" ) ;
		}
		break ;

		case WmiAvlNode :: e_Equal:
		{
			printf ( "\t E" ) ;
		}
		break ;
	}

#endif

	if ( t_StatusCode == e_StatusCode_Success )
	{
		ULONG t_LeftHeight = a_Height ;

		WmiAvlNode *t_Left = a_Node->m_Left ;
		if ( t_Left )
		{
			if ( t_Left->m_Parent == a_Node )
			{
				a_Count ++ ;
				t_StatusCode = RecursiveCheck ( t_Left , a_Count , a_Height , t_LeftHeight ) ;
			}
			else
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
		else
		{
#if 0
			printf ( "\n" ) ;
			for ( ULONG t_TabIndex = 0 ; t_TabIndex <= a_Height ; t_TabIndex ++ ) 
			{
				printf ( "++++" ) ;
			}

			printf ( "NULL" ) ;
			printf ( "\t E" ) ;
#endif
		}
	
		ULONG t_RightHeight = a_Height ;

		WmiAvlNode *t_Right = a_Node->m_Right ;
		if ( t_Right )
		{
			if ( t_Right->m_Parent == a_Node )
			{
				a_Count ++ ;
				t_StatusCode = RecursiveCheck ( t_Right , a_Count , a_Height , t_RightHeight ) ;
			}
			else
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
		else
		{
#if 0
			printf ( "\n" ) ;
			for ( ULONG t_TabIndex = 0 ; t_TabIndex <= a_Height ; t_TabIndex ++ ) 
			{
				printf ( "++++" ) ;
			}

			printf ( "NULL" ) ;
			printf ( "\t E" ) ;
#endif
		}

		switch ( a_Node->m_State )
		{
			case WmiAvlNode :: e_LeftHigher:
			{
				if ( t_LeftHeight <= t_RightHeight )
				{
					t_StatusCode = e_StatusCode_Failed ;
				}
			}
			break ;

			case WmiAvlNode :: e_RightHigher:
			{
				if ( t_LeftHeight >= t_RightHeight )
				{
					t_StatusCode = e_StatusCode_Failed ;
				}
			}
			break ;

			case WmiAvlNode :: e_Equal:
			{
				if ( t_LeftHeight != t_RightHeight )
				{
					t_StatusCode = e_StatusCode_Failed ;
				}
			}
			break ;
		}

		if ( t_LeftHeight < t_RightHeight )
		{
			a_MaxHeight = t_RightHeight ;
		}
		else
		{
			a_MaxHeight = t_LeftHeight ;
		}
	}

	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( a_Node->m_State == WmiAvlNode :: e_Equal )
		{
			if ( ( ( a_Node->m_Left == 0 ) && ( a_Node->m_Right == 0 ) ) )
			{
			}
			else if ( ! ( a_Node->m_Left && a_Node->m_Right ) )
			{
				t_StatusCode = e_StatusCode_Failed ;
			} 
		}

		if ( a_Node->m_State == WmiAvlNode :: e_LeftHigher )
		{
			if ( a_Node->m_Left == NULL )
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}

		if ( a_Node->m_State == WmiAvlNode :: e_RightHigher )
		{
			if ( a_Node->m_Right == NULL )
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
	}
 	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *		case 1:
 *
 *						 N					     A
 *						/ \
 *					   A                 ->	
 *			
 *					Parent Decreased,on side based on recursion step
 *
 *		case 2:
 *
 *						 N						A
 *						/ \
 *					       A			->
 *
 *				Parent Decreased,on side based on recursion step
 *
 *		case 3:
 *						 N						B
 *						/ \					   / \
 *					   A   B            ->    A	  Y
 *                        / \
 *                           Y
 *
 *				B decreased on Right
 *
 *		case 4:
 *
 *						 N						B
 *						/ \					   / \
 *					   A   C			->	  A	  C	
 *						  / \                    / \
 *						 B 	 Y                  X   Y 
 *                        \
 *                         X
 *
 *				C decreased on Left, Apply LeftBalance on C
 *				Apply RightBalance on B
 * 
 *						 N						D
 *						/ \					   / \
 *					   A   C			->	  A	  C	
 *						  / \                    / \
 *						 B 	 Y                  B   Y 
 *                      / \                    / \
 *                     D   X                  E   X
 *                      \
 *                       E
 *
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: DeleteFixup ( WmiAvlNode *a_Node , bool &a_Decreased )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Decreased = true ;

	WmiAvlNode *t_Left = a_Node->m_Left ;
	WmiAvlNode *t_Right = a_Node->m_Right ;
	WmiAvlNode *t_Parent = a_Node->m_Parent ;

	if ( t_Left && t_Right ) 
	{
		Iterator t_Iterator ( a_Node ) ;
		t_Iterator.Increment () ;

		WmiAvlNode *t_Successor = t_Iterator.m_Node ;

		t_Successor->m_State = a_Node->m_State ;

		if ( t_Parent ) 
		{
			if ( t_Parent->m_Left == a_Node )
			{
				t_Parent->m_Left = t_Successor ;
			}
			else
			{
				t_Parent->m_Right = t_Successor;
			}
		}
		else
		{
			m_Root = t_Successor ;
		}

		if ( t_Successor->m_Parent != a_Node )
		{
/* case 4 */

			if ( a_Node->m_Left )
			{
				a_Node->m_Left->m_Parent = t_Successor ;
			}

			if ( a_Node->m_Right )
			{
				a_Node->m_Right->m_Parent = t_Successor ;
			}

			WmiAvlNode *t_Node = t_Successor->m_Parent ;
			t_Successor->m_Parent->m_Left = t_Successor->m_Right ;
			if ( t_Successor->m_Left )
			{
				t_Successor->m_Left->m_Parent = t_Successor->m_Parent ;
			}

			if ( t_Successor->m_Right )
			{
				t_Successor->m_Right->m_Parent = t_Successor->m_Parent ;
			}

			t_Successor->m_Left = a_Node->m_Left ;
			t_Successor->m_Right = a_Node->m_Right ;
			t_Successor->m_Parent = a_Node->m_Parent ;
 
			do
			{
				t_StatusCode = Delete_LeftBalance ( t_Node , t_Node->m_Right , a_Decreased ) ;

#if 0
				ULONG t_Count = 1 ;
				ULONG t_Height = 0 ;
				ULONG t_MaxHeight = 0 ;
				t_StatusCode = RecursiveCheck ( t_Node , t_Count , t_Height , t_MaxHeight ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
				}
#endif

				t_Node = t_Node->m_Parent ;
			}
			while ( ( t_StatusCode == e_StatusCode_Success ) && ( t_Node != t_Successor ) ) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				t_StatusCode = Delete_RightBalance ( t_Node , t_Node->m_Left , a_Decreased ) ;

#if 0
				ULONG t_Count = 1 ;
				ULONG t_Height = 0 ;
				ULONG t_MaxHeight = 0 ;
				t_StatusCode = RecursiveCheck ( t_Node , t_Count , t_Height , t_MaxHeight ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
				}
#endif
			}
		}
		else
		{
/* case 3 */

			if ( a_Node->m_Left )
			{
				a_Node->m_Left->m_Parent = t_Successor ;
			}

			if ( a_Node->m_Right )
			{
				a_Node->m_Right->m_Parent = t_Successor ;
			}

			t_Successor->m_Left = a_Node->m_Left ;
			t_Successor->m_Parent = a_Node->m_Parent ;

			t_StatusCode = Delete_RightBalance ( t_Successor , t_Successor->m_Left , a_Decreased ) ;
		}
	}
	else
	{
		if ( t_Parent ) 
		{
			if ( t_Parent->m_Left == a_Node )
			{
				t_Parent->m_Left = t_Left ? t_Left : t_Right ;
			}
			else
			{
				t_Parent->m_Right = t_Left ? t_Left : t_Right ;
			}
		}
		else
		{
			m_Root = a_Node->m_Left ? a_Node->m_Left : a_Node->m_Right ;
		}

		if ( t_Left )
		{
/* case 1 */

			t_Left->m_Parent = a_Node->m_Parent ;
			t_Left->m_State = a_Node->m_State ;

			t_StatusCode = Delete_LeftBalance ( t_Left , t_Left->m_Right , a_Decreased ) ;
		}
		else if ( t_Right )
		{
/* case 2 */

			t_Right->m_Parent = a_Node->m_Parent ;
			t_Right->m_State = a_Node->m_State ;

			t_StatusCode = Delete_RightBalance ( t_Right , t_Right->m_Left , a_Decreased ) ;
		}
	}

	a_Node->~WmiAvlNode () ;

	t_StatusCode = m_Allocator.Delete (

		 ( void * ) a_Node 
	) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Merge ( 

	WmiAvlTree <WmiKey,WmiElement> &a_Tree
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	Iterator t_Iterator = a_Tree.Root ();

	while ( ( ! t_Iterator.Null () ) && ( t_StatusCode == e_StatusCode_Success ) )
	{
		Iterator t_InsertIterator ;
		t_StatusCode = Insert ( t_Iterator.GetKey () , t_Iterator.GetElement () , t_InsertIterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = a_Tree.Delete ( t_Iterator.GetKey () ) ;
		}

		t_Iterator = a_Tree.Root () ;
	}

	return t_StatusCode ;
}


#if 0
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Insert ( 

	const WmiKey &a_Key ,
	const WmiElement &a_Element ,
	Iterator &a_Iterator 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAvlNode *t_AllocNode = NULL ;

	t_StatusCode = m_Allocator.New (

		( void ** ) & t_AllocNode ,
		sizeof ( WmiAvlNode ) 
	) ;

	if ( t_StatusCode == e_StatusCode_Success )
	{
		::  new ( ( void* ) t_AllocNode ) WmiAvlNode () ;

		try
		{
			t_AllocNode->m_Element = a_Element ;
			t_AllocNode->m_Key = a_Key ;
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			t_AllocNode->~WmiAvlNode () ;

			WmiStatusCode t_StatusCode = m_Allocator.Delete (

				( void * ) t_AllocNode
			) ;

			return e_StatusCode_OutOfMemory ;
		}
		catch ( ... )
		{
			t_AllocNode->~WmiAvlNode () ;

			WmiStatusCode t_StatusCode = m_Allocator.Delete (

				( void * ) t_AllocNode
			) ;

			return e_StatusCode_Unknown
		}

		a_Iterator = Iterator ( t_Node ) ;

		if ( m_Root ) 
		{
			bool a_Increased ;

			t_StatusCode = RecursiveInsert ( 

				m_Root ,
				t_AllocNode ,
				a_Increased 
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				m_Size ++ ;
			}
			else
			{
				t_AllocNode->~WmiAvlNode () ;

				WmiStatusCode t_StatusCode = m_Allocator.Delete (

					( void * ) t_AllocNode
				) ;
			}
		}
		else
		{
			m_Root = t_Node ;

			m_Size ++ ;
		}
	}
	else
	{
		a_Iterator = Iterator () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: RecursiveInsert ( 

	WmiAvlNode *a_Node , 
	WmiAvlNode *a_Element ,
	bool &a_Increased 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Increased = false ;

#ifdef INLINE_COMPARE
	LONG t_Compare = CompareElement ( a_Element->m_Key  , a_Node->m_Key ) ;
	if ( t_Compare == 0 )
#else
	if ( a_Key == t_Node->m_Key )
#endif
	{
		t_StatusCode = e_StatusCode_AlreadyExists ;
	}
	else 
	{
#ifdef INLINE_COMPARE
		if ( t_Compare < 0 )
#else
		if ( a_Key < t_Node->m_Key )
#endif

		{
			if ( a_Node->m_Left )
			{
				t_StatusCode = RecursiveInsert ( a_Node->m_Left , a_Element , a_Increased ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					t_StatusCode = Insert_LeftBalance ( 

						a_Node ,
						a_Node->m_Left ,
						a_Increased 
					) ;
				}
			}
			else
			{
				a_Increased = true ;

				a_Element->m_Parent = a_Node ;
				a_Node->m_Left = a_Element ;

				t_StatusCode = Insert_LeftBalance ( 

					a_Node ,
					a_Node->m_Left ,
					a_Increased 
				) ;
			}
		}
		else
		{
			if ( a_Node->m_Right )
			{
				t_StatusCode = RecursiveInsert ( a_Node->m_Right , a_Element , a_Increased ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					t_StatusCode = Insert_RightBalance ( 

						a_Node ,
						a_Node->m_Right ,
						a_Increased 
					) ;
				}
			}
			else
			{
				a_Increased = true ;

				a_Element->m_Parent = a_Node ;
				a_Node->m_Right = a_Element ;

				t_StatusCode = Insert_RightBalance ( 

					a_Node ,
					a_Node->m_Right ,
					a_Increased 
				) ;
			}
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: Delete ( 

	const WmiKey &a_Key
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		bool t_Decreased = false ;
		t_StatusCode = RecursiveDelete ( m_Root , a_Key , t_Decreased ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			m_Size -- ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotFound ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiAvlTree <WmiKey,WmiElement> :: RecursiveDelete ( 

	WmiAvlNode *a_Node , 
	const WmiKey &a_Key ,
	bool &a_Decreased 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_NotFound ;

#ifdef INLINE_COMPARE
	LONG t_Compare = CompareElement ( a_Key , a_Node->m_Key ) ;
	if ( t_Compare == 0 )
#else
	if ( a_Key == t_Node->m_Key )
#endif
	{
		t_StatusCode = DeleteFixup ( a_Node , a_Decreased ) ;
	}
	else 
	{
#ifdef INLINE_COMPARE
		if ( t_Compare < 0 )
#else
		if ( a_Key < t_Node->m_Key )
#endif
		{
			if ( a_Node->m_Left )
			{
				t_StatusCode = RecursiveDelete ( a_Node->m_Left , a_Key , a_Decreased ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					t_StatusCode = Delete_LeftBalance ( a_Node , a_Node->m_Right , a_Decreased ) ;
				}
			}
		}
		else
		{
			if ( a_Node->m_Right )
			{
				t_StatusCode = RecursiveDelete ( a_Node->m_Right , a_Key , a_Decreased ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					t_StatusCode = Delete_RightBalance ( a_Node , a_Node->m_Left , a_Decreased ) ;
				}
			}
		}
	}

	return t_StatusCode ;
}

#endif

#endif _AVLTREE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\basictree.cpp ===
#ifndef __BasicTREE_CPP
#define __BasicTREE_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <BasicTree.h>

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiBasicTree <WmiKey,WmiElement> :: WmiBasicTree <WmiKey,WmiElement> ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Size ( 0 ) ,
	m_Root ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiBasicTree <WmiKey,WmiElement> :: ~WmiBasicTree <WmiKey,WmiElement> ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Root )
	{
		t_StatusCode = RecursiveUnInitialize ( m_Root ) ;
		m_Root = NULL ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: RecursiveUnInitialize ( WmiBasicNode *a_Node )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiBasicNode *t_Left = a_Node->m_Left ;
	if ( t_Left )
	{
		t_StatusCode = RecursiveUnInitialize ( t_Left ) ;

		t_Left->~WmiBasicNode () ;

		WmiStatusCode t_TempStatusCode = m_Allocator.Delete (

			( void * ) t_Left
		) ;

		t_Left = NULL ;
	}

	WmiBasicNode *t_Right = a_Node->m_Right ;
	if ( t_Right )
	{
		t_StatusCode = RecursiveUnInitialize ( t_Right ) ;

		t_Right->~WmiBasicNode () ;

		WmiStatusCode t_TempStatusCode = m_Allocator.Delete (

			( void * ) t_Right
		) ;

		t_Right = NULL ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: Insert ( 

	const WmiKey &a_Key ,
	const WmiElement &a_Element ,
	Iterator &a_Iterator 
)
{
	if ( m_Root )
	{
		WmiBasicNode *t_Node = m_Root ;
		while ( t_Node )
		{
			LONG t_Compare = CompareElement ( a_Key  , t_Node->m_Key ) ;
			if ( t_Compare == 0 )
			{
				return e_StatusCode_AlreadyExists ;
			}
			else 
			{
				if ( t_Compare < 0 )
				{
					if ( t_Node->m_Left )
					{
						t_Node = t_Node->m_Left ;
					}
					else
					{
						WmiBasicNode *t_AllocNode ;

						WmiStatusCode t_StatusCode = m_Allocator.New (

							( void ** ) & t_AllocNode ,
							sizeof ( WmiBasicNode ) 
						) ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							::  new ( ( void* ) t_AllocNode ) WmiBasicNode () ;

							try
							{
								t_AllocNode->m_Element = a_Element ;
								t_AllocNode->m_Key = a_Key ;
							}
							catch ( Wmi_Heap_Exception &a_Exception )
							{
								t_AllocNode->~WmiBasicNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_OutOfMemory ;
							}
							catch ( ... )
							{
								t_AllocNode->~WmiBasicNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_Unknown ;
							}

							a_Iterator = Iterator ( t_AllocNode ) ;

							t_AllocNode->m_Parent = t_Node ;
							t_Node->m_Left = t_AllocNode ;

							m_Size ++ ;
						}

						return t_StatusCode ;
					}
				}
				else
				{
					if ( t_Node->m_Right )
					{
						t_Node = t_Node->m_Right ;
					}
					else
					{
						WmiBasicNode *t_AllocNode ;

						WmiStatusCode t_StatusCode = m_Allocator.New (

							( void ** ) & t_AllocNode ,
							sizeof ( WmiBasicNode ) 
						) ;

						if ( t_StatusCode == e_StatusCode_Success )
						{
							::  new ( ( void* ) t_AllocNode ) WmiBasicNode () ;

							try
							{
								t_AllocNode->m_Element = a_Element ;
								t_AllocNode->m_Key = a_Key ;
							}
							catch ( Wmi_Heap_Exception &a_Exception )
							{
								t_AllocNode->~WmiBasicNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_OutOfMemory ;
							}
							catch ( ... )
							{
								t_AllocNode->~WmiBasicNode () ;

								WmiStatusCode t_StatusCode = m_Allocator.Delete (

									( void * ) t_AllocNode
								) ;

								return e_StatusCode_Unknown ;
							}

							a_Iterator = Iterator ( t_AllocNode ) ;

							t_AllocNode->m_Parent = t_Node ;
							t_Node->m_Right = t_AllocNode ;

							m_Size ++ ;
						}

						return t_StatusCode ;
					}
				}
			}
		}
		
		return e_StatusCode_Failed ;
	}
	else
	{
		WmiBasicNode *t_AllocNode ;

		WmiStatusCode t_StatusCode = m_Allocator.New (

			( void ** ) & t_AllocNode ,
			sizeof ( WmiBasicNode ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			::  new ( ( void* ) t_AllocNode ) WmiBasicNode () ;

			try
			{
				t_AllocNode->m_Element = a_Element ;
				t_AllocNode->m_Key = a_Key ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				t_AllocNode->~WmiBasicNode () ;

				WmiStatusCode t_StatusCode = m_Allocator.Delete (

					( void * ) t_AllocNode
				) ;

				return e_StatusCode_OutOfMemory ;
			}
			catch ( ... )
			{
				t_AllocNode->~WmiBasicNode () ;

				WmiStatusCode t_StatusCode = m_Allocator.Delete (

					( void * ) t_AllocNode
				) ;

				return e_StatusCode_Unknown ;
			}

			a_Iterator = Iterator ( t_AllocNode ) ;

			m_Root = t_AllocNode ;

			m_Size ++ ;
		}

		return t_StatusCode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: Delete ( 

	const WmiKey &a_Key
)
{
	WmiBasicNode *t_Node = m_Root ;
	while ( t_Node )
	{
		LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
		if ( t_Compare == 0 )
		{
			m_Size -- ;
			return DeleteFixup ( t_Node ) ;
		}
		else 
		{
			if ( t_Compare < 0 )
			{
				t_Node = t_Node->m_Left ;
			}
			else
			{
				t_Node = t_Node->m_Right ;
			}
		}
	}
	
	return e_StatusCode_NotFound ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: Find (

	const WmiKey &a_Key ,
	Iterator &a_Iterator
)
{
	WmiBasicNode *t_Node = m_Root ;
	while ( t_Node )
	{
		LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
		if ( t_Compare == 0 )
		{
			a_Iterator = Iterator ( t_Node ) ;
			return e_StatusCode_Success ;
		}
		else 
		{
			if ( t_Compare < 0 )
			{
				t_Node = t_Node->m_Left ;
			}
			else
			{
				t_Node = t_Node->m_Right ;
			}
		}
	}
	
	return e_StatusCode_NotFound ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: FindNext (

	const WmiKey &a_Key ,
	Iterator &a_Iterator
)
{
	WmiBasicNode *t_Node = m_Root ;
	while ( t_Node )
	{
		LONG t_Compare = CompareElement ( a_Key , t_Node->m_Key ) ;
		if ( t_Compare == 0 )
		{
			a_Iterator = Iterator ( t_Node ).Increment () ;
			return a_Iterator.Null () ? e_StatusCode_NotFound : e_StatusCode_Success ; ;
		}
		else 
		{
			if ( t_Compare < 0 )
			{
				if ( t_Node->m_Left )
				{
					t_Node = t_Node->m_Left ;
				}
				else
				{
					a_Iterator = Iterator ( t_Node ) ;
					
					return e_StatusCode_Success ;
				}
			}
			else
			{
				if ( t_Node->m_Right )
				{
					t_Node = t_Node->m_Right ;
				}
				else
				{
					a_Iterator = Iterator ( t_Node ).Increment () ;
					return a_Iterator.Null () ? e_StatusCode_NotFound : e_StatusCode_Success ;
				}
			}
		}
	}
	
	return e_StatusCode_NotFound ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: DeleteFixup ( WmiBasicNode *a_Node )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiBasicNode *t_Left = a_Node->m_Left ;
	WmiBasicNode *t_Right = a_Node->m_Right ;
	WmiBasicNode *t_Parent = a_Node->m_Parent ;

	if ( t_Left && t_Right ) 
	{
		Iterator t_Iterator ( a_Node ) ;
		t_Iterator.Increment () ;

		WmiBasicNode *t_Successor = t_Iterator.m_Node ;

		if ( t_Parent ) 
		{
			if ( t_Parent->m_Left == a_Node )
			{
				t_Parent->m_Left = t_Successor ;
			}
			else
			{
				t_Parent->m_Right = t_Successor;
			}
		}
		else
		{
			m_Root = t_Successor ;
		}

		if ( t_Successor->m_Parent != a_Node )
		{
			if ( a_Node->m_Left )
			{
				a_Node->m_Left->m_Parent = t_Successor ;
			}

			if ( a_Node->m_Right )
			{
				a_Node->m_Right->m_Parent = t_Successor ;
			}

			WmiBasicNode *t_Node = t_Successor->m_Parent ;
			t_Successor->m_Parent->m_Left = t_Successor->m_Right ;
			if ( t_Successor->m_Left )
			{
				t_Successor->m_Left->m_Parent = t_Successor->m_Parent ;
			}

			if ( t_Successor->m_Right )
			{
				t_Successor->m_Right->m_Parent = t_Successor->m_Parent ;
			}

			t_Successor->m_Left = a_Node->m_Left ;
			t_Successor->m_Right = a_Node->m_Right ;
			t_Successor->m_Parent = a_Node->m_Parent ;
		}
		else
		{
			if ( a_Node->m_Left )
			{
				a_Node->m_Left->m_Parent = t_Successor ;
			}

			if ( a_Node->m_Right )
			{
				a_Node->m_Right->m_Parent = t_Successor ;
			}

			t_Successor->m_Left = a_Node->m_Left ;
			t_Successor->m_Parent = a_Node->m_Parent ;
		}
	}
	else
	{
		if ( t_Left )
		{
			t_Left->m_Parent = a_Node->m_Parent ;
		}
		else if ( t_Right )
		{
			t_Right->m_Parent = a_Node->m_Parent ;
		}

		if ( t_Parent ) 
		{
			if ( t_Parent->m_Left == a_Node )
			{
				t_Parent->m_Left = t_Left ? t_Left : t_Right ;
			}
			else
			{
				t_Parent->m_Right = t_Left ? t_Left : t_Right ;
			}
		}
		else
		{
			m_Root = a_Node->m_Left ? a_Node->m_Left : a_Node->m_Right ;
		}
	}

	a_Node->~WmiBasicNode () ;

	t_StatusCode = m_Allocator.Delete (

		 ( void * ) a_Node 
	) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiBasicTree <WmiKey,WmiElement> :: Merge ( 

	WmiBasicTree <WmiKey,WmiElement> &a_Tree
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	Iterator t_Iterator = a_Tree.Root ();

	while ( ( ! t_Iterator.Null () ) && ( t_StatusCode == e_StatusCode_Success ) )
	{
		Iterator t_InsertIterator ;
		t_StatusCode = Insert ( t_Iterator.GetKey () , t_Iterator.GetElement () , t_InsertIterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = a_Tree.Delete ( t_Iterator.GetKey () ) ;
		}

		t_Iterator = a_Tree.Root () ;
	}

	return t_StatusCode ;
}


#endif __BasicTREE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\cache.cpp ===
#ifndef __CACHE_CPP
#define __CACHE_CPP

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Thread.cpp

Abstract:

	Enhancements to current functionality: 

		Timeout mechanism should track across waits.
		AddRef/Release on task when scheduling.
		Enhancement Ticker logic.

History:

--*/

#include <HelperFuncs.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#if 0
	//
	// The template argument for the below two operator functions
	// can never be deduced so I'm moving them to class WmiUniqueTimeout
	// 
	// [TGani]
	//
template <class WmiKey>
bool operator == ( const typename WmiCacheController <WmiKey> :: WmiUniqueTimeout &a_Arg1 , const typename WmiCacheController <WmiKey> :: WmiUniqueTimeout &a_Arg2 ) 
{
	LONG t_Compare ;
	if ( ( t_Compare = a_Arg1.GetTicks () - a_Arg2.GetTicks () ) == 0 )
	{
		t_Compare = a_Arg1.GetCounter () - a_Arg2.GetCounter () ;
	}

	return t_Compare == 0 ? true : false ;
}

template <class WmiKey>
bool operator < ( const typename WmiCacheController <WmiKey> :: WmiUniqueTimeout &a_Arg1 , const typename WmiCacheController <WmiKey> :: WmiUniqueTimeout &a_Arg2 ) 
{
	LONG t_Compare ;
	if ( ( t_Compare = a_Arg1.GetTicks () - a_Arg2.GetTicks () ) == 0 )
	{
		t_Compare = a_Arg1.GetCounter () - a_Arg2.GetCounter () ;
	}

	return t_Compare < 0 ? true : false ;
}
#endif //0

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiCacheController <WmiKey> :: WmiCacheController (

	WmiAllocator &a_Allocator

) : m_Allocator ( a_Allocator ) ,
	m_Cache ( a_Allocator ) ,
	m_CacheDecay ( a_Allocator ) ,
	m_ReferenceCount ( 0 ) ,
	m_Counter ( 0 ),
	m_CriticalSection(NOTHROW_LOCK)
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiCacheController <WmiKey> :: ~WmiCacheController () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
STDMETHODIMP_( ULONG ) WmiCacheController <WmiKey> :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
STDMETHODIMP_( ULONG ) WmiCacheController <WmiKey> :: Release () 
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
STDMETHODIMP WmiCacheController <WmiKey> :: QueryInterface ( REFIID , LPVOID FAR * ) 
{
	return E_NOINTERFACE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Initialize () 
{
	WmiStatusCode t_StatusCode = m_Cache.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_StatusCode = m_CacheDecay.Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: UnInitialize () 
{
	WmiStatusCode t_StatusCode = m_Cache.UnInitialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_StatusCode = m_CacheDecay.UnInitialize () ;
	}

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;

	return t_StatusCode ;
}	

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Insert ( 

	WmiCacheElement &a_Element ,
	Cache_Iterator &a_Iterator 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	Lock () ;

	Cache_Iterator t_Iterator ;
	t_StatusCode = m_Cache.Insert ( a_Element.GetKey () , & a_Element , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Element.InternalAddRef () ;
		a_Element.SetCached ( TRUE ) ;
	}

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Delete ( 

	const WmiKey &a_Key
)
{
	Lock () ;

	WmiStatusCode t_StatusCode = m_Cache.Delete ( a_Key ) ;

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Find ( 

	const WmiKey &a_Key , 
	Cache_Iterator &a_Iterator
)
{
	Lock () ;

	WmiStatusCode t_StatusCode = m_Cache.Find ( a_Key , a_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Iterator.GetElement ()->AddRef ( ) ;
	}

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Lock ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: UnLock ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Shutdown ()
{
	Lock () ;

	ULONG t_Index = 0 ;
	while ( true )
	{
		WmiUniqueTimeout t_Key ;
		WmiCacheElement *t_Element = NULL ;

		WmiStatusCode t_StatusCode = m_CacheDecay.Top ( t_Key , t_Element ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_Index ++ ;

			t_StatusCode = m_CacheDecay.DeQueue () ;
		}
		else
		{
			break ;
		}
	}

	ULONG t_ElementCount = m_Cache.Size () ;

	WmiCacheElement **t_Elements = NULL ;
	WmiStatusCode t_StatusCode = m_Allocator.New (

		( void ** ) & t_Elements ,
		sizeof ( WmiCacheElement )  * t_ElementCount 
	) ;

	if ( t_StatusCode == e_StatusCode_Success )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_ElementCount ; t_Index ++ )
		{
			t_Elements [ t_Index ] = NULL ;
		}

		ULONG t_ElementIndex = 0 ;

		Cache_Iterator t_Iterator = m_Cache.Root ();
		while ( ! t_Iterator.Null () )
		{
			if ( t_Iterator.GetElement ()->GetDecayed () == FALSE )
			{
				WmiCacheElement *t_Element = t_Iterator.GetElement () ;
				t_Elements [ t_ElementIndex ] = t_Element ;

				t_Element->SetDecayed ( TRUE ) ;
				t_Element->SetDecaying ( FALSE ) ;
				t_Element->SetCached ( FALSE ) ;

				m_Cache.Delete ( t_Iterator.GetKey () ) ;
			}
			else
			{
				m_Cache.Delete ( t_Iterator.GetKey () ) ;
			}

			t_ElementIndex ++ ;

			t_Iterator = m_Cache.Root () ;
		}
	}

	UnLock () ;

	if ( t_Elements )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_ElementCount ; t_Index ++ )
		{
			if ( t_Elements [ t_Index ] )
			{
				t_Elements [ t_Index ]->InternalRelease () ;
			}
		}

		m_Allocator.Delete ( t_Elements ) ;
	}

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Shutdown ( const WmiKey &a_Key )
{
	Lock () ;

	Cache_Iterator t_Iterator ;
	WmiStatusCode t_StatusCode = m_Cache.Find ( a_Key , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( t_Iterator.GetElement ()->GetDecayed () == FALSE )
		{
			CacheDecay_Iterator t_QueueIterator = m_CacheDecay.Begin () ;
			while ( ! t_QueueIterator.Null () ) 
			{
				WmiCacheElement *t_Element = t_QueueIterator.GetElement () ;
				if ( t_Element == t_Iterator.GetElement () )
				{
					m_CacheDecay.Delete ( t_QueueIterator.GetKey () ) ;
					break ;
				}

				t_QueueIterator.Increment () ;
			}

			WmiCacheElement *t_Element = t_Iterator.GetElement () ;
			t_Element->SetDecayed ( TRUE ) ;
			t_Element->SetDecaying ( FALSE ) ;
			t_Element->SetCached ( FALSE ) ;

			m_Cache.Delete ( a_Key ) ;

			UnLock () ;

			t_Element->InternalRelease () ;
		}
		else
		{
			m_Cache.Delete ( a_Key ) ;

			UnLock () ;
		}
	}
	else
	{
		UnLock () ;
	}

	return e_StatusCode_Success ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: StrobeBegin ( const ULONG &a_Timeout )
{
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Strobe ( ULONG &a_NextStrobeDelta )
{
	while ( true )
	{
		Lock () ;

		WmiUniqueTimeout t_Key ;
		WmiCacheElement *t_Element = NULL ;

		WmiStatusCode t_StatusCode = m_CacheDecay.Top ( t_Key , t_Element ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			a_NextStrobeDelta = ( a_NextStrobeDelta < t_Element->GetPeriod () ) ? a_NextStrobeDelta : t_Element->GetPeriod () ;

			ULONG t_Ticks = GetTickCount () ;

#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - Checking ( %lx , %lx ) " , t_Ticks , t_Element , t_Key.GetTicks () ) ;
OutputDebugString ( t_Buffer ) ;
#endif

			if ( t_Ticks >= t_Key.GetTicks () ) 
			{
				if ( t_Element->GetDecaying () )
				{
#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - Strobe ( %lx , %lx ) " , t_Ticks , t_Element , t_Key.GetTicks () ) ;
OutputDebugString ( t_Buffer ) ;
#endif

					t_Element->SetDecaying ( FALSE ) ;
					t_Element->SetDecayed ( TRUE ) ; 

					t_StatusCode = m_CacheDecay.DeQueue () ;

					UnLock () ;

					t_Element->InternalRelease () ;
				}
				else
				{
					t_StatusCode = m_CacheDecay.DeQueue () ;

					UnLock () ;
				}
			}
			else
			{
				UnLock () ;
				break ;
			}
		}
		else
		{
			UnLock () ;
			break ;
		}
	}

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiCacheController <WmiKey> :: Decay ( 

	WmiCacheElement &a_Element
)
{
	Lock () ;

	ULONG t_Size = m_CacheDecay.Size () ;

	Cache_Iterator t_Iterator ;
	WmiStatusCode t_StatusCode = m_Cache.Find ( a_Element.GetKey () , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		BOOL t_Found = FALSE ;
		CacheDecay_Iterator t_QueueIterator = m_CacheDecay.Begin () ;
		while ( ! t_QueueIterator.Null () ) 
		{
			WmiCacheElement *t_Element = t_QueueIterator.GetElement () ;
			if ( t_Element == & a_Element )
			{
				m_CacheDecay.Delete ( t_QueueIterator.GetKey () ) ;
				break ;
			}

			t_QueueIterator.Increment () ;
		}

		ULONG t_Ticks = GetTickCount () ;
		WmiUniqueTimeout t_Key (

			t_Ticks + a_Element.GetPeriod () , 
			InterlockedIncrement ( & m_Counter )
		) ;

#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - Decaying ( %lx , %lx , %lx ) " , t_Ticks , & a_Element , t_Ticks + a_Element.GetPeriod () , a_Element.GetPeriod () ) ;
OutputDebugString ( t_Buffer ) ;
#endif

		t_StatusCode = m_CacheDecay.EnQueue ( 
	
			t_Key , 
			t_Iterator.GetElement ()
		) ;

		UnLock () ;

		if ( t_Size == 0 )
		{
			StrobeBegin ( a_Element.GetPeriod () ) ;
		}

		if ( t_StatusCode != e_StatusCode_Success )
		{
			a_Element.InternalRelease () ;
		}
	}
	else
	{
		UnLock () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiContainerController <WmiKey> :: WmiContainerController (

	WmiAllocator &a_Allocator

) : m_Container ( a_Allocator ) ,
	m_ReferenceCount ( 0 ),
	m_CriticalSection(NOTHROW_LOCK)
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiContainerController <WmiKey> :: ~WmiContainerController () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
STDMETHODIMP_( ULONG ) WmiContainerController <WmiKey> :: AddRef () 
{
	return  InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
STDMETHODIMP_( ULONG ) WmiContainerController <WmiKey> :: Release () 
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
STDMETHODIMP WmiContainerController <WmiKey> :: QueryInterface ( REFIID , LPVOID FAR * ) 
{
	return E_NOINTERFACE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: Initialize () 
{
	WmiStatusCode t_StatusCode = m_Container.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: UnInitialize () 
{
	WmiStatusCode t_StatusCode = m_Container.UnInitialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_StatusCode = WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;
	}

	return t_StatusCode ;
}	

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: Insert ( 

	WmiContainerElement &a_Element ,
	Container_Iterator &a_Iterator 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	Lock () ;

	Container_Iterator t_Iterator ;
	t_StatusCode = m_Container.Insert ( a_Element.GetKey () , & a_Element , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Element.InternalAddRef () ;
		a_Element.SetCached ( TRUE ) ;
	}

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: Delete ( 

	const WmiKey &a_Key
)
{
	Lock () ;

	WmiStatusCode t_StatusCode = m_Container.Delete ( a_Key ) ;

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: Find ( 

	const WmiKey &a_Key , 
	Container_Iterator &a_Iterator
)
{
	Lock () ;

	WmiStatusCode t_StatusCode = m_Container.Find ( a_Key , a_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Iterator.GetElement ()->AddRef ( ) ;
	}

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: Lock ()
{
	return WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: UnLock ()
{
	WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: Shutdown ()
{
	Lock () ;

	Container_Iterator t_Iterator = m_Container.Root ();

	while ( ! t_Iterator.Null () )
	{
		m_Container.Delete ( t_Iterator.GetKey () ) ;

		t_Iterator = m_Container.Root () ;
	}

	UnLock () ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiContainerController <WmiKey> :: Strobe ( ULONG &a_NextStrobeDelta )
{
	return e_StatusCode_Success ;
}

#endif __CACHE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\hashtable.cpp ===
#ifndef __HASHTABLE_CPP
#define __HASHTABLE_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <HashTable.h>

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG HashSize>
WmiHashTable <WmiKey,WmiElement,HashSize> :: WmiHashTable ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) , m_Buckets ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG HashSize>
WmiHashTable <WmiKey,WmiElement,HashSize> :: ~WmiHashTable ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG HashSize>
WmiStatusCode WmiHashTable <WmiKey,WmiElement,HashSize> :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( ! m_Buckets )
	{
		t_StatusCode = m_Allocator.New (

			( void ** ) & m_Buckets ,
			sizeof ( WmiBasicTree <WmiKey,WmiElement> ) * HashSize
		) ;
		
		if ( t_StatusCode == e_StatusCode_Success )
		{
			for ( ULONG t_Index = 0 ; t_Index < HashSize ; t_Index ++ )
			{
				:: new ( ( void * ) & m_Buckets [ t_Index ] ) WmiBasicTree <WmiKey,WmiElement> ( m_Allocator ) ;
			}
		}
		else
		{
			m_Buckets = NULL ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG HashSize>
WmiStatusCode WmiHashTable <WmiKey,WmiElement,HashSize> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Buckets )
	{
		for ( ULONG t_Index = 0 ; t_Index < HashSize ; t_Index ++ )
		{
			m_Buckets [ t_Index ].WmiBasicTree <WmiKey,WmiElement> :: ~WmiBasicTree <WmiKey,WmiElement> () ;
		}

		t_StatusCode = m_Allocator.Delete (

			( void * ) m_Buckets
		) ;

		m_Buckets = NULL;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG HashSize>
WmiStatusCode WmiHashTable <WmiKey,WmiElement,HashSize> :: Insert ( 

	const WmiKey &a_Key ,
	const WmiElement &a_Element
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Buckets )
	{
		ULONG t_Hash = Hash ( a_Key ) % HashSize ;

		WmiBasicTree <WmiKey,WmiElement> *t_Tree = &m_Buckets [ t_Hash ] ;

		WmiBasicTree <WmiKey,WmiElement> :: Iterator t_Iterator ;
		t_StatusCode = t_Tree->Insert ( a_Key , a_Element ,t_Iterator ) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG HashSize>
WmiStatusCode WmiHashTable <WmiKey,WmiElement,HashSize> :: Delete ( 

	const WmiKey &a_Key
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Buckets )
	{
		ULONG t_Hash = Hash ( a_Key ) % HashSize ;

		WmiBasicTree <WmiKey,WmiElement> *t_Tree = &m_Buckets [ t_Hash ] ;
		t_StatusCode = t_Tree->Delete ( a_Key ) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement,ULONG HashSize>
WmiStatusCode WmiHashTable <WmiKey,WmiElement,HashSize> :: Find (

	const WmiKey &a_Key ,
	WmiElement &a_Element 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Buckets )
	{
		ULONG t_Hash = Hash ( a_Key ) % HashSize ;

		WmiBasicTree <WmiKey,WmiElement> *t_Tree = &m_Buckets [ t_Hash ] ;

		WmiBasicTree <WmiKey,WmiElement> :: Iterator a_Iterator ;		
		t_StatusCode = t_Tree->Find ( a_Key , a_Iterator ) ;
		a_Element = a_Iterator.GetElement () ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}
	
	return t_StatusCode ;
}

#endif __HASHTABLE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\logging.cpp ===
//***************************************************************************

//

//  PROVLOG.CPP

//

//  Module: OLE MS PROVIDER FRAMEWORK

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include <stdio.h>
#include <string.h>
#include <Allocator.h>
#include <Algorithms.h>
#include <Logging.h>
#include <scopeguard.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define LOG_KEY				    L"Software\\Microsoft\\WBEM\\CIMOM\\Logging"
#define LOG_KEY_SLASH           L"Software\\Microsoft\\WBEM\\CIMOM\\Logging\\"
#define LOGGING_ON				L"Logging"
#define BACKSLASH_STRING		L"\\"
#define DEFAULT_FILE_EXT		L".log"
#define LOGGING_DIR_VALUE		L"Logging Directory"
#define LOGGING_DIR_KEY			L"Software\\Microsoft\\WBEM\\CIMOM"
#define DEFAULT_PATH			L"C:\\"
#define DEFAULT_FILE_SIZE		0x100000
#define MIN_FILE_SIZE			1024
#define MAX_MESSAGE_SIZE		1024

#define LOG_FILE_NAME               L"File"
#define LOG_LEVEL_NAME				L"Level"
#define LOG_FILE_SIZE				L"MaxFileSize"
#define LOG_TYPE_NAME               L"Type"
#define LOG_TYPE_FILE_STRING		L"File"
#define LOG_TYPE_DEBUG_STRING		L"Debugger"

long WmiDebugLog :: s_ReferenceCount = 0 ;

typedef WmiBasicTree <WmiDebugLog *,WmiDebugLog *> LogContainer ;
typedef WmiBasicTree <WmiDebugLog *,WmiDebugLog *> :: Iterator LogContainerIterator ;

LogContainer *g_LogContainer = NULL ;

CriticalSection g_WmiDebugLogMapCriticalSection(NOTHROW_LOCK) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiDebugTaskObject : public WmiTask <ULONG>
{
private:

	HKEY m_LogKey ;

protected:
public:

	WmiDebugTaskObject ( WmiAllocator &a_Allocator ) ;
	~WmiDebugTaskObject () ;

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;

	void SetRegistryNotification () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugTaskObject :: WmiDebugTaskObject (

	WmiAllocator &a_Allocator 

) : WmiTask <ULONG> ( a_Allocator ) , 
	m_LogKey ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugTaskObject :: ~WmiDebugTaskObject ()
{
	if ( m_LogKey )
		RegCloseKey ( m_LogKey ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiDebugTaskObject :: Process ( WmiThread <ULONG> &a_Thread )
{
	WmiDebugLog *t_WmiDebugLog = NULL ;

	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( &g_WmiDebugLogMapCriticalSection ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		try
		{
			LogContainerIterator t_Iterator = g_LogContainer->Begin () ;
			while ( ! t_Iterator.Null () )
			{
				t_Iterator.GetElement ()->LoadRegistry () ;
				t_Iterator.GetElement ()->SetRegistry () ;

				t_Iterator.Increment () ;
			}
		}
		catch(Wmi_Heap_Exception&)
		{
			// ignore it
		}

		WmiHelper :: LeaveCriticalSection ( &g_WmiDebugLogMapCriticalSection ) ;
	}

	SetRegistryNotification () ;

	Complete () ;

	return e_StatusCode_EnQueue ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef LONG ( *FuncRegNotifyChangeKeyValue ) (

	HKEY hKey,
	BOOL bWatchSubtree,
	DWORD dwNotifyFilter,
	HANDLE hEvent,
	BOOL fAsynchronous
) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugTaskObject :: SetRegistryNotification ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( &g_WmiDebugLogMapCriticalSection ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( m_LogKey )
		{
			RegCloseKey ( m_LogKey ) ;
			m_LogKey = NULL ;
		}

		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			LOGGING_DIR_KEY , 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&m_LogKey, 
			NULL
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			OSVERSIONINFO t_OS;
			t_OS.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
			if ( ! GetVersionEx ( & t_OS ) )
			{
				WmiHelper :: LeaveCriticalSection ( &g_WmiDebugLogMapCriticalSection ) ;
				return ;
			}

			if ( ! ( t_OS.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && t_OS.dwMinorVersion == 0 ) )
			{
					t_Status = RegNotifyChangeKeyValue ( 

						m_LogKey , 
						TRUE , 
						REG_NOTIFY_CHANGE_LAST_SET , 
						GetEvent () , 
						TRUE 
					) ; 

					if ( t_Status == ERROR_SUCCESS )
					{
					}
			}
		}

		WmiHelper :: LeaveCriticalSection ( &g_WmiDebugLogMapCriticalSection ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiDebugThreadObject : public WmiThread <ULONG> 
{
private:

	WmiDebugTaskObject *m_WmiDebugTaskObject ;
	WmiAllocator &m_Allocator ;
		
public:

	WmiDebugThreadObject ( WmiAllocator &a_Allocator , const wchar_t *a_Thread ) ;
	~WmiDebugThreadObject () ;

	WmiStatusCode Initialize () ;

	WmiDebugTaskObject *GetTaskObject () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugThreadObject *g_WmiDebugLogThread = NULL ;

WmiDebugLog *WmiDebugLog :: s_WmiDebugLog = NULL ;
BOOL WmiDebugLog :: s_Initialised = FALSE ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugThreadObject :: WmiDebugThreadObject (

	WmiAllocator &a_Allocator , 
	const wchar_t *a_Thread

) :	WmiThread <ULONG> ( a_Allocator , a_Thread ) ,
	m_WmiDebugTaskObject ( NULL ) ,
	m_Allocator ( a_Allocator ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugThreadObject :: ~WmiDebugThreadObject ()
{
	delete WmiDebugLog :: s_WmiDebugLog ;
	WmiDebugLog :: s_WmiDebugLog = NULL ;

	if ( m_WmiDebugTaskObject )
	{
		delete m_WmiDebugTaskObject ;
	}

	WmiHelper :: DeleteCriticalSection ( & g_WmiDebugLogMapCriticalSection ) ;

	delete g_LogContainer ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiDebugThreadObject :: Initialize ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & g_WmiDebugLogMapCriticalSection ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		g_LogContainer = new LogContainer ( m_Allocator ) ; 
		if ( g_LogContainer )
		{
			m_WmiDebugTaskObject = new WmiDebugTaskObject ( m_Allocator ) ;
			if ( m_WmiDebugTaskObject )
			{
				WmiDebugLog :: s_WmiDebugLog = new WmiDebugLog ( m_Allocator ) ;
				if ( WmiDebugLog :: s_WmiDebugLog )
				{
					t_StatusCode = WmiDebugLog :: s_WmiDebugLog->Initialize ( L"ProviderSubSystem" ) ;
					if ( t_StatusCode == e_StatusCode_Success )
					{
						EnQueueAlertable ( GetTickCount () , *m_WmiDebugTaskObject ) ;
						m_WmiDebugTaskObject->Exec () ;
					}
					else
					{
						delete WmiDebugLog :: s_WmiDebugLog ;
						WmiDebugLog :: s_WmiDebugLog = NULL ;

						delete m_WmiDebugTaskObject ;
						m_WmiDebugTaskObject = NULL ;

						delete g_LogContainer ;
						g_LogContainer = NULL ;

						t_StatusCode = e_StatusCode_OutOfMemory ;
					}
				}
				else
				{
					delete m_WmiDebugTaskObject ;
					m_WmiDebugTaskObject = NULL ;

					delete g_LogContainer ;
					g_LogContainer = NULL ;

					t_StatusCode = e_StatusCode_OutOfMemory ;
				}
			}
			else
			{
				delete g_LogContainer ;
				g_LogContainer = NULL ;

				t_StatusCode = e_StatusCode_OutOfMemory ;
			}
		}
		else
		{
			t_StatusCode = e_StatusCode_OutOfMemory ;
		}

		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = WmiThread <ULONG> :: Initialize () ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugTaskObject *WmiDebugThreadObject :: GetTaskObject ()
{
	return m_WmiDebugTaskObject ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugLog :: WmiDebugLog ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Logging ( FALSE ) ,
	m_Verbose ( FALSE ) ,
	m_DebugLevel ( 0 ) ,
	m_DebugFileSize ( DEFAULT_FILE_SIZE ),
	m_DebugContext ( WmiDebugContext :: FILE ) ,
	m_DebugFile ( NULL ) ,
	m_DebugFileHandle (  INVALID_HANDLE_VALUE ) ,
	m_DebugComponent ( NULL ) ,
	m_CriticalSection(NOTHROW_LOCK)
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiDebugLog :: Initialize ( const wchar_t *a_DebugComponent )
{
	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		LogContainerIterator t_Iterator ;

		t_StatusCode = WmiHelper :: EnterCriticalSection ( & g_WmiDebugLogMapCriticalSection ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = g_LogContainer->Insert ( this , this , t_Iterator ) ;

			WmiHelper :: LeaveCriticalSection ( &g_WmiDebugLogMapCriticalSection ) ;
		}

		if ( a_DebugComponent )
		{
			m_DebugComponent = _wcsdup ( a_DebugComponent ) ;
			if ( m_DebugComponent == NULL )
			{
				t_StatusCode = e_StatusCode_OutOfMemory ;
			}
		}

		LoadRegistry () ;
		SetRegistry () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiDebugLog :: ~WmiDebugLog ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( &g_WmiDebugLogMapCriticalSection ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_StatusCode = g_LogContainer->Delete ( this ) ;

		WmiHelper :: LeaveCriticalSection ( & g_WmiDebugLogMapCriticalSection ) ;
	}

	CloseOutput () ;

	if ( m_DebugComponent )
	{
		free ( m_DebugComponent ) ;
	}

	if ( m_DebugFile )
	{
		free ( m_DebugFile ) ;
	}

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetDefaultFile ( )
{
	HKEY hkey;
	LONG result =  RegOpenKeyEx(HKEY_LOCAL_MACHINE,
								LOGGING_DIR_KEY, 0, KEY_READ, &hkey);

	if (result == ERROR_SUCCESS)
	{
		wchar_t t_path [MAX_PATH + 1];
		DWORD t_ValueType = REG_SZ;
		DWORD t_ValueLength = ( MAX_PATH + 1 ) * sizeof ( wchar_t ) ;

		result = RegQueryValueEx( 

			hkey , 
			LOGGING_DIR_VALUE , 
			0, 
			&t_ValueType ,
			( LPBYTE ) t_path , 
			&t_ValueLength 
		) ;

		if ((result == ERROR_SUCCESS) && (t_ValueType == REG_SZ || t_ValueType == REG_EXPAND_SZ))
		{
			int len = wcslen(t_path);
			if (len>0 && *(t_path+len-1)!=L'\\')
				StringCchCatW(t_path,MAX_PATH + 1,  BACKSLASH_STRING);
			StringCchCatW(t_path, MAX_PATH + 1, m_DebugComponent);
			StringCchCatW(t_path, MAX_PATH + 1, DEFAULT_FILE_EXT);
			SetFile (t_path);
		}

		RegCloseKey(hkey);
	}

	if (m_DebugFile == NULL)
	{
		wchar_t path[MAX_PATH + 1];
		StringCchPrintfW(path, MAX_PATH + 1, L"%s%s%s", DEFAULT_PATH, m_DebugComponent, DEFAULT_FILE_EXT);
		SetFile (path);
	}
	
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SwapFileOver()
{
	Flush();
	CloseOutput();
	size_t buffLength = wcslen(m_DebugFile) + 2;
	//prepend a character to the log file name
	wchar_t* buff = new wchar_t[buffLength];
	if (buff==0)
		return;


	//find the last occurrence of \ for dir
	wchar_t* tmp = wcsrchr(m_DebugFile, '\\');

	if (tmp != NULL)
	{
		tmp++;
		wcsncpy(buff, m_DebugFile, wcslen(m_DebugFile) - wcslen(tmp));
		buff[wcslen(m_DebugFile) - wcslen(tmp)] = L'\0';
		StringCchCatW(buff,buffLength, L"~");
		StringCchCatW(buff,buffLength,tmp); 
	}
	else
	{
		StringCchCopyW(buff,buffLength, L"~");
		StringCchCatW(buff, buffLength, m_DebugFile);
	}

	//move the file and reopen...
	if (!MoveFileEx(m_DebugFile, buff, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH))
	{
		//try deleting the file and then moving it
		DeleteFile(buff);
		MoveFileEx(m_DebugFile, buff, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);
		DeleteFile(m_DebugFile);
	}

	//open file regardless of whether move file worked...
	OpenOutput();
	delete [] buff;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: WriteOutput ( const wchar_t *a_OutputDebugString )
{
	switch ( m_DebugContext )
	{
		case FILE:
		{
			if ( m_DebugFileHandle == INVALID_HANDLE_VALUE )
			{
				CloseOutput();
				OpenOutput();
			}

			if ( m_DebugFileHandle != INVALID_HANDLE_VALUE )
			{
				DWORD dwToWrite = sizeof ( wchar_t ) * ( wcslen ( a_OutputDebugString ) );
				LPCVOID thisWrite = ( LPCVOID ) a_OutputDebugString;
				BOOL t_Status = TRUE;

				while ((dwToWrite != 0) && (t_Status))
				{
					DWORD dwSize;
					dwSize = SetFilePointer ( m_DebugFileHandle , 0 , NULL , FILE_END ); 

					//if the file is too big swap it...
#ifdef _UNICODE
					//only whole (2byte) characters written to file
					if ((m_DebugFileSize > 0) && (dwSize >= (m_DebugFileSize - 1)))
#else
					if ((m_DebugFileSize > 0) && (dwSize >= m_DebugFileSize))
#endif
					{
						SwapFileOver();

						if ( m_DebugFileHandle == INVALID_HANDLE_VALUE )
						{
							break;
						}

						if (m_DebugFileSize > 0)
						{
							dwSize = SetFilePointer ( m_DebugFileHandle , 0 , NULL , FILE_END );  
						}
					}

					if (dwSize ==  0xFFFFFFFF)
					{
						break;
					}

					DWORD t_BytesWritten = 0 ;
					DWORD dwThisWrite;

					if ((m_DebugFileSize > 0) && (dwToWrite + dwSize > m_DebugFileSize))
					{
						dwThisWrite = m_DebugFileSize - dwSize;
#ifdef _UNICODE
						if ((dwThisWrite > 1) && (dwThisWrite%2))
						{
							dwThisWrite--;
						}
#endif
					}
					else
					{
						dwThisWrite = dwToWrite;
					}

					t_Status = WriteFile ( 
			
						m_DebugFileHandle ,
						thisWrite ,
						dwThisWrite ,
						& t_BytesWritten ,
						NULL 
					) ;

					//get ready for next write...
					dwToWrite -= t_BytesWritten;
					thisWrite = (LPCVOID)((UCHAR*)thisWrite + t_BytesWritten);
				}
			}
		}
		break ;

		case DEBUG:
		{
			OutputDebugString ( a_OutputDebugString ) ;
		}
		break ;

		default:
		{
		}
		break ;
	}

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: OpenFileForOutput ()
{
	if ( m_DebugFile )
	{
		m_DebugFileHandle = CreateFile (
			
			m_DebugFile ,
			GENERIC_WRITE ,
#ifdef _UNICODE 
			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
#else
			FILE_SHARE_READ | FILE_SHARE_WRITE,
#endif
			NULL ,
			OPEN_EXISTING ,
			FILE_ATTRIBUTE_NORMAL ,
			NULL 
		) ;

		if ( m_DebugFileHandle == INVALID_HANDLE_VALUE )
		{
			m_DebugFileHandle = CreateFile (

				m_DebugFile ,
				GENERIC_WRITE ,
#ifdef _UNICODE 
				FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
#else
				FILE_SHARE_READ | FILE_SHARE_WRITE,
#endif
				NULL ,
				OPEN_ALWAYS ,
				FILE_ATTRIBUTE_NORMAL ,
				NULL 
			) ;

#ifdef _UNICODE 

			if ( m_DebugFileHandle != INVALID_HANDLE_VALUE )
			{
				UCHAR t_UnicodeBytes [ 2 ] ;
				t_UnicodeBytes [ 0 ] = 0xFF ;
				t_UnicodeBytes [ 1 ] = 0xFE ;

				DWORD t_BytesWritten = 0 ;
				WriteFile ( 
			
					m_DebugFileHandle ,
					( LPCVOID ) & t_UnicodeBytes ,
					sizeof ( t_UnicodeBytes ) ,
					& t_BytesWritten ,
					NULL 
				) ;
			}
#endif

		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: OpenOutput ()
{
	switch ( m_DebugContext )
	{
		case FILE:
		{
			OpenFileForOutput () ;
		}
		break ;

		case DEBUG:
		default:
		{
		}
		break ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: FlushOutput ()
{
	switch ( m_DebugContext )
	{
		case FILE:
		{
			if ( m_DebugFileHandle != INVALID_HANDLE_VALUE )
			{
				FlushFileBuffers ( m_DebugFileHandle ) ;
			}
		}
		break ;

		case DEBUG:
		default:
		{
		}
		break ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: CloseOutput ()
{
	switch ( m_DebugContext )
	{
		case FILE:
		{
			if ( m_DebugFileHandle != INVALID_HANDLE_VALUE ) 
			{
				CloseHandle ( m_DebugFileHandle ) ;
				m_DebugFileHandle =  INVALID_HANDLE_VALUE ;
			}
		}
		break ;

		case DEBUG:
		default:
		{
		}
		break ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: Write ( const wchar_t *a_DebugFormatString , ... )
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( m_Logging )
		{
			wchar_t t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;
			va_list t_VarArgList ;

			va_start(t_VarArgList,a_DebugFormatString);
			
			StringCchVPrintfW (t_OutputDebugString , MAX_MESSAGE_SIZE , a_DebugFormatString , t_VarArgList );
			va_end(t_VarArgList);

			WriteOutput ( t_OutputDebugString ) ;
		}

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: Write ( const wchar_t *a_File , const ULONG a_Line , const wchar_t *a_DebugFormatString , ... )
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( m_Logging )
		{
			wchar_t t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;

			WriteOutput ( L"\r\n") ;

			va_list t_VarArgList ;
			va_start(t_VarArgList,a_DebugFormatString);
			int t_Length = StringCchVPrintfW (t_OutputDebugString , MAX_MESSAGE_SIZE , a_DebugFormatString , t_VarArgList );
			va_end(t_VarArgList);

			WriteOutput ( t_OutputDebugString ) ;
		}

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: Flush ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		FlushOutput () ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetLogging ( BOOL a_Logging )
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_Logging = a_Logging ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetLevel ( const DWORD &a_DebugLevel ) 
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_DebugLevel = a_DebugLevel ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetContext ( const enum WmiDebugContext &a_DebugContext ) 
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_DebugContext = a_DebugContext ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum WmiDebugLog :: WmiDebugContext WmiDebugLog :: GetContext () 
{
	WmiDebugContext t_Context = m_DebugContext ;

	return t_Context ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog ::CommitContext ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		CloseOutput () ;
		OpenOutput () ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog ::SetFile ( const wchar_t *a_File )
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		if (m_DebugFile)
		{
			free ( m_DebugFile ) ;
		}

		m_DebugFile = _wcsdup ( a_File ) ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: LoadRegistry()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		LoadRegistry_Logging  () ;
		LoadRegistry_Level () ;
		LoadRegistry_File () ;
		LoadRegistry_Type () ;
		LoadRegistry_FileSize ();
		CommitContext () ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: LoadRegistry_Logging ()
{
	HKEY t_LogKey = NULL ;

	LONG t_Status = RegCreateKeyEx (
	
		HKEY_LOCAL_MACHINE, 
		LOGGING_DIR_KEY, 
		0, 
		NULL, 
		REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 
		NULL, 
		&t_LogKey, 
		NULL
	) ;

	if ( t_Status == ERROR_SUCCESS )
	{
		DWORD t_ValueType = REG_SZ ;
		wchar_t t_ValueString [ 2 ] ;
		DWORD t_ValueLength = sizeof ( t_ValueString ) ;

		ZeroMemory ( t_ValueString , t_ValueLength ) ;

		t_Status = RegQueryValueEx ( 

			t_LogKey , 
			LOGGING_ON , 
			0, 
			&t_ValueType ,
			( LPBYTE ) t_ValueString , 
			&t_ValueLength 
		) ;

		if ( t_Status == ERROR_SUCCESS )
		{
			switch ( t_ValueString [ 0 ] )
			{
				case L'0':
				{
					m_Logging = FALSE ;
				}
				break ;

				case L'1':
				{
					m_Logging = TRUE ;
					m_Verbose = FALSE ;
				}
				break ;

				case L'2':
				{
					m_Verbose = TRUE ;
					m_Logging = TRUE ;
				}
				break ;
			}
		}

		RegCloseKey ( t_LogKey ) ;
	}
}


LONG GetDebugKey(const wchar_t * debugComponent , HKEY * LogKey)
{
	size_t bufferLen = wcslen ( LOG_KEY_SLASH ) + wcslen ( debugComponent ) + 1;
	wchar_t *t_ComponentKeyString = new  wchar_t[bufferLen];
	if (t_ComponentKeyString == NULL)
	{
		throw Wmi_Heap_Exception(Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
	}

	StringCchCopyW( t_ComponentKeyString , bufferLen, LOG_KEY_SLASH ) ;
	StringCchCatW( t_ComponentKeyString , bufferLen,debugComponent ) ;
	*LogKey = NULL ;

	LONG t_Status = RegCreateKeyEx (
	
			HKEY_LOCAL_MACHINE, 
			t_ComponentKeyString, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			LogKey, 
			NULL
		) ;
	delete [] t_ComponentKeyString;
	return t_Status;
}





/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: LoadRegistry_FileSize ()
{
	if ( m_DebugComponent )
	{
		HKEY t_LogKey = NULL ;

		LONG t_Status = GetDebugKey(m_DebugComponent, &t_LogKey);

		if ( t_Status == ERROR_SUCCESS )
		{
			DWORD t_Size ;
			DWORD t_ValueType = REG_DWORD ;
			DWORD t_ValueLength = sizeof ( DWORD ) ;
			t_Status = RegQueryValueEx( 

				t_LogKey , 
				LOG_FILE_SIZE , 
				0, 
				&t_ValueType ,
				( LPBYTE ) &t_Size , 
				&t_ValueLength 
			) ;

			if ( t_Status == ERROR_SUCCESS )
			{
				m_DebugFileSize = t_Size ;

				if (m_DebugFileSize < MIN_FILE_SIZE)
				{
					m_DebugFileSize = MIN_FILE_SIZE ;
				}
			}

			RegCloseKey ( t_LogKey ) ;
		}

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: LoadRegistry_Level ()
{
	if ( m_DebugComponent )
	{
		HKEY t_LogKey = NULL ;

		LONG t_Status = GetDebugKey(m_DebugComponent, &t_LogKey);

		if ( t_Status == ERROR_SUCCESS )
		{
			DWORD t_Level ;
			DWORD t_ValueType = REG_DWORD ;
			DWORD t_ValueLength = sizeof ( DWORD ) ;
			t_Status = RegQueryValueEx( 

				t_LogKey , 
				LOG_LEVEL_NAME , 
				0, 
				&t_ValueType ,
				( LPBYTE ) &t_Level , 
				&t_ValueLength 
			) ;

			if ( t_Status == ERROR_SUCCESS )
			{
				m_DebugLevel = t_Level ;
			}

			RegCloseKey ( t_LogKey ) ;
		}

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: LoadRegistry_File ()
{
	if ( m_DebugComponent )
	{
		HKEY t_LogKey = NULL ;

		LONG t_Status = GetDebugKey(m_DebugComponent, &t_LogKey);

		if ( t_Status == ERROR_SUCCESS )
		{
			ON_BLOCK_EXIT(RegCloseKey, t_LogKey);
			wchar_t *t_File = NULL ;
			DWORD t_ValueType = REG_SZ ;
			DWORD t_ValueLength = 0 ;

			t_Status = RegQueryValueEx( 

				t_LogKey , 
				LOG_FILE_NAME , 
				0, 
				&t_ValueType ,
				( LPBYTE ) t_File , 
				&t_ValueLength 
			) ;

			if ( t_Status == ERROR_SUCCESS )
			{
				t_File = new wchar_t [ t_ValueLength ] ;

				if ( t_File )
				{
					t_Status = RegQueryValueEx( 

						t_LogKey , 
						LOG_FILE_NAME , 
						0, 
						&t_ValueType ,
						( LPBYTE ) t_File , 
						&t_ValueLength 
					) ;
				}
				else
				{
					t_Status = E_OUTOFMEMORY ;
				}

				if ( (t_Status == ERROR_SUCCESS) && t_File && (*t_File != L'\0' ) )
				{
					SetFile ( t_File ) ;
				}
				else
				{
					SetDefaultFile();
				}
				delete [] t_File;
			}
			else
			{
				SetDefaultFile();
			}

		}

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: LoadRegistry_Type ()
{
	if ( m_DebugComponent )
	{
		HKEY t_LogKey = NULL ;

		LONG t_Status = GetDebugKey(m_DebugComponent, &t_LogKey);

		if ( t_Status == ERROR_SUCCESS )
		{
			ON_BLOCK_EXIT(RegCloseKey, t_LogKey);
			wchar_t *t_Type = NULL ;
			DWORD t_ValueType = REG_SZ ;
			DWORD t_ValueLength = 0 ;

			t_Status = RegQueryValueEx( 

				t_LogKey , 
				LOG_TYPE_NAME , 
				0, 
				&t_ValueType ,
				( LPBYTE ) t_Type , 
				&t_ValueLength 
			) ;

			if ( t_Status == ERROR_SUCCESS )
			{
			
				t_Type = new wchar_t [ t_ValueLength ] ;
				if ( t_Type )
				{
					t_Status = RegQueryValueEx( 

						t_LogKey , 
						LOG_TYPE_NAME , 
						0, 
						&t_ValueType ,
						( LPBYTE ) t_Type , 
						&t_ValueLength 
					) ;
				}
				else
				{
					t_Status = E_OUTOFMEMORY ;
				}

				if ( t_Status == ERROR_SUCCESS )
				{
					if ( wcscmp ( t_Type , LOG_TYPE_DEBUG_STRING ) == 0 )
					{
						SetContext ( DEBUG ) ;
					}
					else
					{
						SetContext ( FILE ) ;
					}
				}

				delete [] t_Type;
			}

		}

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetRegistry()
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection(&m_CriticalSection) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		SetRegistry_Logging  () ;
		SetRegistry_Level () ;
		SetRegistry_File () ;
		SetRegistry_FileSize () ;
		SetRegistry_Type () ;

		WmiHelper :: LeaveCriticalSection(&m_CriticalSection) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetRegistry_Logging ()
{
	HKEY t_LogKey = NULL ;

	LONG t_Status = RegCreateKeyEx (
	
		HKEY_LOCAL_MACHINE, 
		LOGGING_DIR_KEY, 
		0, 
		NULL, 
		REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 
		NULL, 
		&t_LogKey, 
		NULL
	) ;
			
	if ( t_Status == ERROR_SUCCESS )
	{
		wchar_t t_ValueString [ 2 ] ;
		DWORD t_ValueLength = sizeof ( t_ValueString ) ;
		DWORD t_ValueType = REG_SZ ;

		t_ValueString [ 1 ] = 0 ;

		if ( m_Logging ) 
		{
			if ( m_Verbose )
			{
				t_ValueString [ 0 ] = L'2' ;
			}
			else
			{
				t_ValueString [ 0 ] = L'1' ;
			}
		}
		else
		{
			t_ValueString [ 0 ] = L'0' ;
		}

		t_Status = RegSetValueEx ( 

			t_LogKey , 
			LOGGING_ON , 
			0, 
			t_ValueType ,
			( LPBYTE ) t_ValueString , 
			t_ValueLength 
		) ;

		RegCloseKey ( t_LogKey ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetRegistry_FileSize ()
{
	if ( m_DebugComponent )
	{
		HKEY t_LogKey = NULL ;

		LONG t_Status = GetDebugKey(m_DebugComponent, &t_LogKey);

		if ( t_Status == ERROR_SUCCESS )
		{
			DWORD t_Level = m_DebugFileSize ;
			DWORD t_ValueType = REG_DWORD ;
			DWORD t_ValueLength = sizeof ( DWORD ) ;
			t_Status = RegSetValueEx( 

				t_LogKey , 
				LOG_FILE_SIZE , 
				0, 
				t_ValueType ,
				( LPBYTE ) &t_Level , 
				t_ValueLength 
			) ;

			RegCloseKey ( t_LogKey ) ;
		}

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetRegistry_Level ()
{
	if ( m_DebugComponent )
	{
		HKEY t_LogKey = NULL ;

		LONG t_Status = GetDebugKey(m_DebugComponent, &t_LogKey);

		if ( t_Status == ERROR_SUCCESS )
		{
			DWORD t_Level = m_DebugLevel ;
			DWORD t_ValueType = REG_DWORD ;
			DWORD t_ValueLength = sizeof ( DWORD ) ;
			t_Status = RegSetValueEx( 

				t_LogKey , 
				LOG_LEVEL_NAME , 
				0, 
				t_ValueType ,
				( LPBYTE ) &t_Level , 
				t_ValueLength 
			) ;

			RegCloseKey ( t_LogKey ) ;
		}

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetRegistry_File ()
{
	if ( m_DebugComponent )
	{

		HKEY t_LogKey = NULL ;

		LONG t_Status = GetDebugKey(m_DebugComponent, &t_LogKey);

		if ( t_Status == ERROR_SUCCESS )
		{
			if ( m_DebugFile )
			{
				wchar_t *t_File = m_DebugFile ;
				DWORD t_ValueType = REG_SZ ;
				DWORD t_ValueLength = ( wcslen ( t_File ) + 1 ) * sizeof ( wchar_t ) ;

				t_Status = RegSetValueEx( 

					t_LogKey , 
					LOG_FILE_NAME , 
					0, 
					t_ValueType ,
					( LPBYTE ) t_File , 
					t_ValueLength 
				) ;
			}

			RegCloseKey ( t_LogKey ) ;
		}

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetRegistry_Type ()
{
	if ( m_DebugComponent )
	{
		HKEY t_LogKey = NULL ;

		LONG t_Status = GetDebugKey(m_DebugComponent, &t_LogKey);

		if ( t_Status == ERROR_SUCCESS )
		{
			wchar_t *t_Debugger = LOG_TYPE_DEBUG_STRING ;
			wchar_t *t_File = LOG_TYPE_FILE_STRING ;
			wchar_t *t_Type = ( m_DebugContext == DEBUG ) ? t_Debugger : t_File ; 
			DWORD t_ValueType = REG_SZ ;
			DWORD t_ValueLength = ( wcslen ( t_Type ) + 1 ) * sizeof ( wchar_t ) ;

			t_Status = RegSetValueEx( 

				t_LogKey , 
				LOG_TYPE_NAME , 
				0, 
				t_ValueType ,
				( LPBYTE ) t_Type , 
				t_ValueLength 
			) ;

			RegCloseKey ( t_LogKey ) ;
		}

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiDebugLog :: SetEventNotification ()
{
	g_WmiDebugLogThread->GetTaskObject ()->SetRegistryNotification () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiDebugLog :: Initialize ( WmiAllocator &a_Allocator )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( InterlockedIncrement ( & s_ReferenceCount ) == 1 )
	{
		if ( ! s_Initialised )
		{
#if DBG
			t_StatusCode =  WmiThread <ULONG> :: Static_Initialize ( a_Allocator ) ;

			g_WmiDebugLogThread = new WmiDebugThreadObject ( a_Allocator , L"WmiDebugLogThread" ) ;
			if ( g_WmiDebugLogThread )
			{
				g_WmiDebugLogThread->AddRef () ;

				t_StatusCode = g_WmiDebugLogThread->Initialize () ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					SetEventNotification () ;

					s_Initialised = TRUE ;
				}
				else
				{
					g_WmiDebugLogThread->Release () ;
					g_WmiDebugLogThread = NULL ;
				}
			}
			else
			{
				t_StatusCode = e_StatusCode_OutOfMemory ;
			}
#else
			s_Initialised = TRUE ;
#endif
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiDebugLog :: UnInitialize ( WmiAllocator &a_Allocator )
{
	if ( InterlockedDecrement ( & s_ReferenceCount ) == 0 )
	{
#if DBG
		HANDLE t_ThreadHandle = NULL ; 

		BOOL t_Status = DuplicateHandle ( 

			GetCurrentProcess () ,
			g_WmiDebugLogThread->GetHandle () ,
			GetCurrentProcess () ,
			& t_ThreadHandle, 
			0 , 
			FALSE , 
			DUPLICATE_SAME_ACCESS
		) ;

		if ( t_Status )
		{
			g_WmiDebugLogThread->Release () ;
	
			WaitForSingleObject ( t_ThreadHandle , INFINITE ) ;

			CloseHandle ( t_ThreadHandle ) ;

			WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( a_Allocator );

			s_Initialised = FALSE ;
		}
#else
		s_Initialised = FALSE ;
#endif
	}

	return e_StatusCode_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\queue.cpp ===
#ifndef __QUEUE_CPP
#define __QUEUE_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiQueue <WmiElement,ElementSize> :: WmiQueue <WmiElement,ElementSize> ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Size ( 0 ) ,
	m_Top ( NULL ) ,
	m_Tail ( NULL ) ,
	m_TopIndex ( NULL ) ,
	m_TailIndex ( NULL ) ,
	m_AllocatedSize ( 0 )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiQueue <WmiElement,ElementSize > :: ~WmiQueue <WmiElement,ElementSize> ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( ElementSize < 31 )
	{
		t_StatusCode = Grow_ElementDir () ;
	}
	else
	{
		t_StatusCode = e_StatusCode_InvalidArgs ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_AllocatedSize )
	{
		t_StatusCode = UnInitialize_ElementDir ( m_AllocatedSize ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: EnQueue ( 

	const WmiElement &a_Element
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( ! m_AllocatedSize )
	{
		t_StatusCode = Initialize () ;
	}

	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_TailIndex ++ ;

		if ( m_TailIndex == ( QUEUE_ELEMENT_DIR_SIZE ) )
		{
			WmiElementDir *t_Tail = m_Tail ;
			ULONG t_TailIndex = m_TailIndex ;

			t_StatusCode = Grow_ElementDir () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				m_TailIndex -- ;
			}
			else
			{
				try
				{
					t_Tail->m_Block [ t_TailIndex - 1 ] = a_Element ;
					m_Size ++ ;
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					m_TailIndex -- ;

					return e_StatusCode_OutOfMemory ;
				}
				catch ( ... )
				{
					m_TailIndex -- ;

					return e_StatusCode_Unknown ;
				}
			}
		}
		else
		{	
			try
			{
				m_Tail->m_Block [ m_TailIndex - 1 ] = a_Element ;
				m_Size ++ ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				m_TailIndex -- ;

				return e_StatusCode_OutOfMemory ;
			}
			catch ( ... )
			{
				m_TailIndex -- ;

				return e_StatusCode_Unknown ;
			}
		}
	}

	return t_StatusCode ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: Top ( WmiElement &a_Element )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( ! ( ( m_Top == m_Tail ) && ( m_TopIndex == m_TailIndex ) ) )
	{
		try
		{
			a_Element = m_Top->m_Block [ m_TopIndex ] ;
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			return e_StatusCode_OutOfMemory ;
		}
		catch ( ... )
		{
			return e_StatusCode_Unknown ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: DeQueue ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( ! ( ( m_Top == m_Tail ) && ( m_TopIndex == m_TailIndex ) ) )
	{
		m_TopIndex ++ ;

		if ( m_TopIndex == ( QUEUE_ELEMENT_DIR_SIZE ) )
		{
			t_StatusCode = Shrink_ElementDir () ;
			m_TopIndex = 0 ;
		}

		m_Size -- ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: UnInitialize_ElementDir ( 

	ULONG a_Size
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiElementDir *t_Current = m_Tail ;

	while ( t_Current )
	{
		WmiElementDir *t_Next = t_Current->m_Next ;

		t_Current->~WmiElementDir () ;

		t_StatusCode = m_Allocator.Delete (

			( void * ) t_Current 
		) ;

		t_Current = t_Next ;
	}

	m_Size = m_AllocatedSize = 0 ;
	m_Top = m_Tail = NULL ;
	m_TopIndex = m_TailIndex = 0 ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: Grow_ElementDir ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiElementDir *t_Tail = NULL ;

	t_StatusCode = m_Allocator.New (

		( void ** ) & t_Tail ,
		sizeof ( WmiElementDir ) 
	) ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		:: new ( ( void * ) t_Tail ) WmiElementDir ;

		if ( m_Tail )
		{
			m_Tail->m_Next = t_Tail ;
		}
		else
		{
			m_Top = t_Tail ;
		}

		m_Tail = t_Tail ;

		m_TailIndex = 0 ;

		m_AllocatedSize = m_AllocatedSize + ( QUEUE_ELEMENT_DIR_SIZE ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiQueue <WmiElement,ElementSize > :: Shrink_ElementDir ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Top )
	{
		WmiElementDir *t_Next = m_Top->m_Next ;

		m_Top->~WmiElementDir () ;

		t_StatusCode = m_Allocator.Delete (

			( void * ) m_Top
		) ;

		m_Top = t_Next ;

		m_AllocatedSize = m_AllocatedSize - ( QUEUE_ELEMENT_DIR_SIZE ) ;
	}

	return t_StatusCode ;
}

#endif __QUEUE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\helperfuncs.cpp ===
#ifndef __HELPERFUNCS_CPP
#define __HELPERFUNCS_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#include <Windows.h>
#include <assert.h>
#include <Allocator.h>
#include <pssException.h>
#include <HelperFuncs.h>
#include <strsafe.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
#if 0
WmiStatusCode WmiHelper :: InitializeCriticalSection ( CRITICAL_SECTION *a_CriticalSection )
{
	SetStructuredExceptionHandler t_StructuredException ;

	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	try
	{
		:: InitializeCriticalSection ( a_CriticalSection ) ;
	}
	catch ( Structured_Exception & t_StructuredException )
	{
		if ( t_StructuredException.GetExceptionCode () == STATUS_NO_MEMORY )
		{
			t_StatusCode = e_StatusCode_OutOfMemory ;
		}
		else
		{
			t_StatusCode = e_StatusCode_Unknown ;
#ifdef DBG
			assert ( FALSE ) ; 
#endif
		}
	}
	catch ( ... )
	{
		t_StatusCode = e_StatusCode_Unknown ;
#ifdef DBG
		assert ( FALSE ) ; 
#endif
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: DeleteCriticalSection ( CRITICAL_SECTION *a_CriticalSection )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	:: DeleteCriticalSection ( a_CriticalSection ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: EnterCriticalSection ( CRITICAL_SECTION *a_CriticalSection , BOOL a_WaitCritical )
{
	SetStructuredExceptionHandler t_StructuredException ;

	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	BOOL t_Do ;

	do 
	{
		try
		{
			:: EnterCriticalSection ( a_CriticalSection ) ;

			t_Do = FALSE ;
		}
		catch ( Structured_Exception & t_StructuredException )
		{
			t_Do = a_WaitCritical ;

			if ( t_Do )
			{
				Sleep ( 1000 ) ;
			}

			if ( t_StructuredException.GetExceptionCode () == STATUS_NO_MEMORY )
			{
				t_StatusCode = e_StatusCode_OutOfMemory ;
			}
			else
			{
				t_StatusCode = e_StatusCode_Unknown ;
#ifdef DBG
				assert ( FALSE ) ; 
#endif
				t_Do = FALSE ;
			}
		}
		catch ( ... )
		{
#ifdef DBG
			assert ( FALSE ) ; 
#endif
			t_Do = FALSE ;

			t_StatusCode = e_StatusCode_Unknown ;
		}
	}
	while ( t_Do ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: LeaveCriticalSection ( CRITICAL_SECTION *a_CriticalSection )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	:: LeaveCriticalSection ( a_CriticalSection ) ;

	return t_StatusCode ;
}

#endif

WmiStatusCode WmiHelper :: InitializeCriticalSection ( CriticalSection *a_CriticalSection )
{
	return a_CriticalSection->valid() ? e_StatusCode_Success : e_StatusCode_OutOfMemory;
}

WmiStatusCode WmiHelper :: DeleteCriticalSection ( CriticalSection *a_CriticalSection )
{
	return e_StatusCode_Success ;
}

WmiStatusCode WmiHelper :: EnterCriticalSection ( CriticalSection *a_CriticalSection,  BOOL a_WaitCritical  )
{
	if (a_CriticalSection->valid())
		{
		if (a_CriticalSection->acquire())
			return e_StatusCode_Success;
		if (a_WaitCritical == FALSE )
			return e_StatusCode_OutOfMemory;
		while (!a_CriticalSection->acquire())
			Sleep(1000);
		return e_StatusCode_Success;
		}
	else
		return e_StatusCode_OutOfMemory  ;
}

WmiStatusCode WmiHelper :: LeaveCriticalSection ( CriticalSection *a_CriticalSection )
{
	a_CriticalSection->release();
	return e_StatusCode_Success ;
}



/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: DuplicateString ( WmiAllocator &a_Allocator , const wchar_t *a_String , wchar_t *&a_DuplicatedString ) 
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	if ( a_String )
	{
		t_StatusCode = a_Allocator.New ( 
			( void ** ) & a_DuplicatedString , 
			sizeof ( wchar_t ) * ( wcslen ( a_String ) + 1)
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			StringCbCopyW ( a_DuplicatedString , sizeof ( wchar_t ) * ( wcslen ( a_String ) + 1) , a_String ) ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: CreateUnNamedEvent ( HANDLE &a_Event , BOOL a_ManualReset , BOOL a_InitialState ) 
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Event = CreateEvent ( NULL , a_ManualReset , a_InitialState , NULL ) ;
	if ( ! a_Event )		
	{
		t_StatusCode = e_StatusCode_OutOfResources ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: CreateNamedEvent ( wchar_t *a_Name , HANDLE &a_Event , BOOL a_ManualReset , BOOL a_InitialState ) 
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Event = CreateEvent (

			NULL ,
			a_ManualReset ,
			a_InitialState ,
			a_Name 
		) ;

		if ( a_Event == NULL )
		{
			if ( GetLastError () == ERROR_ALREADY_EXISTS )
			{
				a_Event = OpenEvent (

					EVENT_ALL_ACCESS ,
					FALSE , 
					a_Name
				) ;

				if ( a_Event == NULL )
				{
					t_StatusCode = e_StatusCode_Unknown ;
				}
			}
			else
			{
				t_StatusCode = e_StatusCode_OutOfResources ;
			}
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: DuplicateHandle ( HANDLE a_Handle , HANDLE &a_DuplicatedHandle ) 
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	HANDLE t_ProcessHandle = GetCurrentProcess ();

	BOOL t_Status = :: DuplicateHandle ( 

		t_ProcessHandle ,
		a_Handle ,
		t_ProcessHandle ,
		& a_DuplicatedHandle ,
		0 ,
		FALSE ,
		DUPLICATE_SAME_ACCESS
	) ;

	if ( ! t_Status )		
	{
		t_StatusCode = e_StatusCode_OutOfResources ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: ConcatenateStrings ( ULONG a_ArgCount , BSTR *a_AllocatedString , ... )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	va_list t_VarArgList ;
	va_start ( t_VarArgList , a_AllocatedString );

	ULONG t_AllocatedStringLength = 0 ;
	ULONG t_ArgIndex = 0 ;
	while ( t_ArgIndex < a_ArgCount )
	{
		LPWSTR t_CurrentArg = va_arg ( t_VarArgList , LPWSTR ) ;
		if ( t_CurrentArg )
		{
			t_AllocatedStringLength = t_AllocatedStringLength + wcslen ( t_CurrentArg ) ;
		}

		t_ArgIndex ++ ;
	}

	va_end ( t_VarArgList ) ;
	va_start ( t_VarArgList , a_AllocatedString );

	*a_AllocatedString = SysAllocStringLen ( NULL , t_AllocatedStringLength + 1 ) ;
	size_t allocatedBufferSize = t_AllocatedStringLength + 1;
	if ( *a_AllocatedString )
	{
		t_ArgIndex = 0 ;
		t_AllocatedStringLength = 0 ;
		while ( t_ArgIndex < a_ArgCount )
		{
			LPWSTR t_CurrentArg = va_arg ( t_VarArgList , LPWSTR ) ;
			if ( t_CurrentArg )
			{
				HRESULT hr = StringCchCopyW ( & ( ( * a_AllocatedString ) [ t_AllocatedStringLength ] ) , allocatedBufferSize -t_AllocatedStringLength, t_CurrentArg ) ;
				t_AllocatedStringLength = t_AllocatedStringLength + wcslen ( t_CurrentArg ) ;
			}

			t_ArgIndex ++ ;
		}
		( ( *a_AllocatedString ) [ t_AllocatedStringLength ] ) = NULL ;
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfMemory ;
	}

	va_end ( t_VarArgList ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode WmiHelper :: ConcatenateStrings_Wchar ( ULONG a_ArgCount , wchar_t **a_AllocatedString , ... )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	va_list t_VarArgList ;
	va_start ( t_VarArgList , a_AllocatedString );

	ULONG t_AllocatedStringLength = 0 ;
	ULONG t_ArgIndex = 0 ;
	while ( t_ArgIndex < a_ArgCount )
	{
		LPWSTR t_CurrentArg = va_arg ( t_VarArgList , LPWSTR ) ;
		if ( t_CurrentArg )
		{
			t_AllocatedStringLength = t_AllocatedStringLength + wcslen ( t_CurrentArg ) ;
		}

		t_ArgIndex ++ ;
	}

	va_end ( t_VarArgList ) ;
	va_start ( t_VarArgList , a_AllocatedString );

	*a_AllocatedString = new wchar_t [ t_AllocatedStringLength + 1 ] ;
	size_t allocatedBufferSize = t_AllocatedStringLength + 1;	
	if ( *a_AllocatedString )
	{
		t_ArgIndex = 0 ;
		t_AllocatedStringLength = 0 ;
		while ( t_ArgIndex < a_ArgCount )
		{
			LPWSTR t_CurrentArg = va_arg ( t_VarArgList , LPWSTR ) ;
			if ( t_CurrentArg )
			{
				HRESULT hr = StringCchCopyW ( & ( ( * a_AllocatedString ) [ t_AllocatedStringLength ] ) , allocatedBufferSize -t_AllocatedStringLength, t_CurrentArg ) ;

				t_AllocatedStringLength = t_AllocatedStringLength + wcslen ( t_CurrentArg ) ;
				
			}

			t_ArgIndex ++ ;
		}

		( ( *a_AllocatedString ) [ t_AllocatedStringLength ] ) = NULL ;
	}
	else
	{
		t_StatusCode = e_StatusCode_OutOfMemory ;
	}

	va_end ( t_VarArgList ) ;

	return t_StatusCode ;
}
#endif __HELPERFUNCS_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\include\algorithms.h ===
#ifndef _ALGORITHMS_H
#define _ALGORITHMS_H

#include "Allocator.h"
#include "Stack.h"

template <class WmiElement>
LONG CompareElement ( const WmiElement &a_Arg1 , const WmiElement &a_Arg2 ) ;

template <class WmiElement>
WmiStatusCode QuickSort ( WmiElement *a_Array , ULONG a_Size ) ;

#include <Algorithms.cpp>

#endif _ALGORITHMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\tpqueue.cpp ===
#ifndef __TREEPRIORITYQUEUE_CPP
#define __TREEPRIORITYQUEUE_CPP

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <TPQueue.h>

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiTreePriorityQueue <WmiKey,WmiElement> :: WmiTreePriorityQueue ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Tree ( a_Allocator )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiTreePriorityQueue <WmiKey,WmiElement> :: ~WmiTreePriorityQueue ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	t_StatusCode = m_Tree.Initialize () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	t_StatusCode = m_Tree.UnInitialize () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: EnQueue ( 

	const WmiKey &a_Key , 
	const WmiElement &a_Element
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiBasicTree <WmiKey,WmiElement> :: Iterator t_Iterator ;

	t_StatusCode = m_Tree.Insert ( a_Key , a_Element , t_Iterator ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: Top (

	Iterator &a_Iterator
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Tree.Size () )
	{
		a_Iterator = m_Tree.Begin () ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: Top (

	WmiKey &a_Key , 
	WmiElement &a_Element
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Tree.Size () )
	{
		WmiBasicTree <WmiKey,WmiElement> :: Iterator t_Iterator ;

		t_Iterator = m_Tree.Begin () ;

		try
		{
			a_Key = t_Iterator.GetKey () ;
			a_Element = t_Iterator.GetElement () ;
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			return e_StatusCode_OutOfMemory ;
		}
		catch ( ... )
		{
			return e_StatusCode_Unknown ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: DeQueue ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Tree.Size () )
	{
		WmiBasicTree <WmiKey,WmiElement> :: Iterator t_Iterator ;
		t_Iterator = m_Tree.Begin () ;

		t_StatusCode = m_Tree.Delete ( t_Iterator.GetKey () ) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: Delete ( 

	const WmiKey &a_Key
)
{
	WmiStatusCode t_StatusCode = m_Tree.Delete ( a_Key ) ;
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey,class WmiElement>
WmiStatusCode WmiTreePriorityQueue <WmiKey,WmiElement> :: Merge (

	WmiTreePriorityQueue <WmiKey,WmiElement> &a_Queue
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	t_StatusCode = m_Tree.Merge ( a_Queue.m_Tree ) ;

	return t_StatusCode ;
}


#endif __TREEPRIORITYQUEUE_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\stack.cpp ===
#ifndef __STACK_CPP
#define __STACK_CPP
/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#if 0

#include <precomp.h>
#include <windows.h>
#include <stdio.h>

#include <Allocator.h>
#include <Stack.h>

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStack <WmiElement,ElementSize > :: WmiStack <WmiElement,ElementSize > ( 

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator ) ,
	m_Size ( 0xFFFFFFFF ) ,
	m_AllocatedSize ( 0 ) ,
	m_Top ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStack <WmiElement,ElementSize > :: ~WmiStack <WmiElement,ElementSize > ()
{
	WmiStatusCode t_StatusCode = UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( ElementSize < 31 )
	{
		t_StatusCode = Grow_ElementDir () ;
	}
	else
	{
		t_StatusCode = e_StatusCode_InvalidArgs ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_AllocatedSize )
	{
		t_StatusCode = UnInitialize_ElementDir ( m_AllocatedSize ) ;

		m_Size = 0 ;
		m_AllocatedSize = 0 ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: Top ( WmiElement &a_Element )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size != 0xFFFFFFFF )
	{
		ULONG t_Index = ( m_Size ) & ( STACK_ELEMENT_DIR_MASK ) ;

		try
		{
			a_Element = m_Top->m_Block [ t_Index ] ;
		}
		catch ( Wmi_Heap_Exception &a_Exception )
		{
			return e_StatusCode_OutOfMemory ;
		}
		catch ( ... )
		{
			return e_StatusCode_Unknown ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: Push ( 

	const WmiElement &a_Element
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( ! m_AllocatedSize )
	{
		t_StatusCode = Initialize () ;
	}

	if ( t_StatusCode == e_StatusCode_Success )
	{
		m_Size ++ ;

		if ( m_Size == m_AllocatedSize )
		{
			t_StatusCode = Grow_ElementDir () ;
		}

		if ( t_StatusCode == e_StatusCode_Success )
		{
			ULONG t_Index = ( m_Size ) & ( STACK_ELEMENT_DIR_MASK ) ;

			try
			{
				m_Top->m_Block [ t_Index ] = a_Element ;
			}
			catch ( Wmi_Heap_Exception &a_Exception )
			{
				m_Size -- ;

				return e_StatusCode_OutOfMemory ;
			}
			catch ( ... )
			{
				m_Size -- ;

				return e_StatusCode_Unknown ;
			}
		}
		else
		{
			m_Size -- ;
		}
	}

	return t_StatusCode ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: Pop ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Size != 0xFFFFFFFF )
	{
		if ( ( ( m_Size ) & ( STACK_ELEMENT_DIR_MASK ) ) == 0 )
		{
			t_StatusCode = Shrink_ElementDir () ;
		}

		m_Size -- ;

	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: UnInitialize_ElementDir ( 

	ULONG a_Size
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	bool t_RoundUp = ( a_Size & STACK_ELEMENT_DIR_MASK ) != 0 ;

	ULONG t_Size = ( a_Size >> STACK_ELEMENT_DIR_BIT_SIZE ) + ( t_RoundUp ? 1 : 0 ) ;

	WmiElementDir *t_Previous = NULL ;

	for ( ULONG t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
	{
		if ( m_Top )
		{
			t_Previous = m_Top->m_Previous ;

			t_StatusCode = m_Allocator.Delete (

				( void * ) m_Top 
			) ;

			m_Top = t_Previous ;
		}
		else
		{
			break ;
		}
	}

	m_AllocatedSize = 0 ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: Grow_ElementDir ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiElementDir *t_Top = NULL ;

	t_StatusCode = m_Allocator.New (

		( void ** ) & t_Top ,
		sizeof ( WmiElementDir ) 
	) ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		:: new ( ( void * ) t_Top ) WmiElementDir ;

		t_Top->m_Previous = m_Top ;

		m_Top = t_Top ;

		m_AllocatedSize = m_AllocatedSize + ( STACK_ELEMENT_DIR_SIZE ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiElement, ULONG ElementSize>
WmiStatusCode WmiStack <WmiElement,ElementSize > :: Shrink_ElementDir ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_Top )
	{
		WmiElementDir *t_Previous = m_Top->m_Previous ;

		m_Top->~WmiElementDir () ;

		t_StatusCode = m_Allocator.Delete (

			( void * ) m_Top 
		) ;

		m_Top = t_Previous ;

		m_AllocatedSize = m_AllocatedSize - ( STACK_ELEMENT_DIR_SIZE ) ;
	}

	return t_StatusCode ;
}

#endif __STACK_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\thread.cpp ===
#ifndef __THREAD_CPP
#define __THREAD_CPP

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Thread.cpp

Abstract:

	Enhancements to current functionality: 

		Timeout mechanism should track across waits.
		AddRef/Release on task when scheduling.
		Enhancement Ticker logic.

History:

--*/

#include <HelperFuncs.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
__TYPENAME WmiThread <WmiKey> :: ThreadContainer *WmiThread <WmiKey> :: s_ThreadContainer = NULL ;

template <class WmiKey>
__TYPENAME WmiThread <WmiKey> :: TaskContainer *WmiThread <WmiKey> :: s_TaskContainer = NULL ;

template <class WmiKey>
CriticalSection WmiThread <WmiKey> :: s_CriticalSection(FALSE) ;

template <class WmiKey>
LONG WmiThread <WmiKey> :: s_InitializeReferenceCount = 0 ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_Initialize ( WmiAllocator &a_Allocator )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( InterlockedIncrement ( & s_InitializeReferenceCount ) == 1 )
	{
		t_StatusCode = WmiHelper :: InitializeCriticalSection ( & s_CriticalSection ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			if ( s_ThreadContainer == NULL )
			{
				t_StatusCode = a_Allocator.New ( 

					( void ** ) & s_ThreadContainer ,
					sizeof ( ThreadContainer ) 
				) ;

				if ( t_StatusCode == e_StatusCode_Success )
				{
					:: new ( ( void * ) s_ThreadContainer ) WmiThread <WmiKey> :: ThreadContainer ( a_Allocator ) ;
				}
			}
			else
			{
			}

			if ( s_TaskContainer == NULL )
			{
				t_StatusCode = a_Allocator.New ( 

					( void ** ) & s_TaskContainer ,
					sizeof ( TaskContainer ) 
				) ;

				if ( t_StatusCode == e_StatusCode_Success )
				{
					:: new ( ( void * ) s_TaskContainer ) WmiThread <WmiKey> :: TaskContainer ( a_Allocator ) ;
				}
			}
			else
			{
			}
		}
	}

	return t_StatusCode	;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_UnInitialize ( WmiAllocator &a_Allocator )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( InterlockedDecrement ( & s_InitializeReferenceCount ) == 0 )
	{
		if ( s_ThreadContainer )
		{
			s_ThreadContainer->~WmiBasicTree () ;

			t_StatusCode = a_Allocator.Delete ( 

				( void * ) s_ThreadContainer 
			) ;

			s_ThreadContainer = NULL ;
		}

		if ( s_TaskContainer )
		{
			s_TaskContainer->~WmiBasicTree () ;

			t_StatusCode = a_Allocator.Delete ( 

				( void * ) s_TaskContainer 
			) ;

			s_TaskContainer = NULL ;
		}

		WmiHelper :: DeleteCriticalSection ( & s_CriticalSection );
	}

	return t_StatusCode	;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
ULONG WmiTask <WmiKey> :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
ULONG WmiTask <WmiKey> :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiTask <WmiKey> :: WmiTask ( 

	WmiAllocator &a_Allocator ,
	const wchar_t *a_Name ,
	const wchar_t *a_CompletionName

) : m_Allocator ( a_Allocator ) ,
	m_ReferenceCount ( 0 ) ,
	m_Event ( NULL ) ,
	m_CompletionEvent ( NULL ) ,
	m_Name ( NULL ) ,
	m_CompletionName ( NULL ) ,
	m_InitializationStatusCode ( e_StatusCode_Success ) ,
	m_TaskState ( e_WmiTask_UnInitialized )
{
	if ( a_Name ) 
	{
		m_InitializationStatusCode = WmiHelper :: DuplicateString ( m_Allocator , a_Name , m_Name ) ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success )
	{
		if ( a_CompletionName ) 
		{
			m_InitializationStatusCode = WmiHelper :: DuplicateString ( m_Allocator , a_CompletionName , m_CompletionName ) ;
		}
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = WmiHelper :: CreateNamedEvent ( m_Name , m_Event ) ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = WmiHelper :: CreateNamedEvent ( m_CompletionName , m_CompletionEvent ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiTask <WmiKey> :: WmiTask ( 

	WmiAllocator &a_Allocator ,
	HANDLE a_Event ,
	HANDLE a_CompletionEvent ,
	const wchar_t *a_Name ,
	const wchar_t *a_CompletionName

) : m_Allocator ( a_Allocator ) ,
	m_ReferenceCount ( 0 ) ,
	m_Event ( NULL ) ,
	m_CompletionEvent ( NULL ) ,
	m_Name ( NULL ) ,
	m_CompletionName ( NULL ) ,
	m_InitializationStatusCode ( e_StatusCode_Success ) ,
	m_TaskState ( e_WmiTask_UnInitialized )
{
	if ( a_Name )
	{
		m_InitializationStatusCode = WmiHelper :: DuplicateString ( m_Allocator , a_Name , m_Name ) ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success )
	{
		if ( a_CompletionName )
		{
			m_InitializationStatusCode = WmiHelper :: DuplicateString ( m_Allocator , a_CompletionName , m_CompletionName ) ;
		}
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		if ( a_Event ) 
		{
			m_InitializationStatusCode = WmiHelper :: DuplicateHandle ( a_Event , m_Event ) ;
		}
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		if ( a_CompletionEvent ) 
		{
			m_InitializationStatusCode = WmiHelper :: DuplicateHandle ( a_CompletionEvent , m_CompletionEvent ) ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiTask <WmiKey> :: ~WmiTask ()
{
	if ( m_Name )
	{
		m_Allocator.Delete ( ( void * ) m_Name ) ;
	}

	if ( m_CompletionName )
	{
		m_Allocator.Delete ( ( void * ) m_CompletionName ) ;
	}

	if ( m_Event ) 
	{
		CloseHandle ( m_Event ) ;
	}

	if ( m_CompletionEvent )
	{
		CloseHandle ( m_CompletionEvent ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: Initialize ()
{
	m_TaskState = e_WmiTask_Initialized ;

	return m_InitializationStatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: Process ( WmiThread <WmiKey> &a_Thread )
{
	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		return Complete () ;
	}

	return e_StatusCode_NotInitialized ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: Exec ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		if ( m_Event ) 
		{
			BOOL t_Status = SetEvent ( m_Event ) ;
			if ( ! t_Status )
			{
				t_StatusCode = e_StatusCode_Unknown ;		

			}
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: Complete ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		BOOL t_Status = SetEvent ( m_CompletionEvent ) ;
		if ( ! t_Status )
		{
			t_StatusCode = e_StatusCode_Unknown ;		
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: Wait ( const ULONG &a_Timeout )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = WmiThread <WmiKey> :: Static_Dispatch ( 

			*this ,
			a_Timeout
		) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

// call static GetEvents on WmiThread to determine list of tasks to execute.

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: WaitAlertable ( const ULONG &a_Timeout )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = WmiThread <WmiKey> :: Static_AlertableDispatch ( 

			*this ,
			a_Timeout 
		) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiTask <WmiKey> :: WaitInterruptable ( const ULONG &a_Timeout )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = WmiThread <WmiKey> :: Static_InterruptableDispatch ( 

			*this ,
			a_Timeout 
		) ;
	}
	else
	{
		t_StatusCode = e_StatusCode_NotInitialized ;
	}

	return t_StatusCode ;
}

#if 0
	
	"WmiKey" below is non-deducible because the actual supplied
	is a nested type [ISO 14.8.2.4 para 4]. I'm moving these operator
	functions to class WmiThread<WmiKey>::QueueKey itself.

	[TGani]



/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
bool operator == ( const typename WmiThread <WmiKey> :: QueueKey &a_Arg1 , const typename WmiThread <WmiKey> :: QueueKey &a_Arg2 ) 
{
	LONG t_Compare ;
	if ( ( t_Compare = CompareElement ( a_Arg1.m_Key , a_Arg2.m_Key ) ) == 0 )
	{
		t_Compare = CompareElement ( a_Arg1.m_Tick , a_Arg2.m_Tick ) ;
	}

	return t_Compare == 0 ? true : false ;
}

template <class WmiKey>
bool operator < ( const typename WmiThread <WmiKey> :: QueueKey &a_Arg1 , const typename WmiThread <WmiKey> :: QueueKey &a_Arg2 ) 
{
	LONG t_Compare ;
	if ( ( t_Compare = CompareElement ( a_Arg1.m_Key , a_Arg2.m_Key ) ) == 0 )
	{
		t_Compare = CompareElement ( a_Arg1.m_Tick , a_Arg2.m_Tick ) ;
	}

	return t_Compare < 0 ? true : false ;
}
#endif //0


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: PostShutdown ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	SetEvent ( m_Terminate ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
ULONG WmiThread <WmiKey> :: ThreadProc ( void *a_Thread )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThread *t_Thread = ( WmiThread * ) a_Thread ;

	if ( t_Thread )
	{
		t_StatusCode = t_Thread->Initialize_Callback () ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			SetEvent ( t_Thread->m_Initialized ) ;

			t_StatusCode = t_Thread->ThreadDispatch () ;
		}

		WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

		t_StatusCode = t_Thread->UnInitialize_Callback () ;

		t_Thread->InternalRelease () ;

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
	}

	return ( ULONG ) t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
ULONG WmiThread <WmiKey> :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 1 )
	{
		InternalAddRef () ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
ULONG WmiThread <WmiKey> :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		CallBackRelease () ;

		PostShutdown () ;

		return InternalRelease () ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
ULONG WmiThread <WmiKey> :: InternalAddRef ()
{
	return InterlockedIncrement ( & m_InternalReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
ULONG WmiThread <WmiKey> :: InternalRelease ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		WmiStatusCode t_StatusCode = s_ThreadContainer->Delete ( m_Identifier ) ;

		delete this ;

		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: CreateThread ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	InternalAddRef () ;

	m_Thread = :: CreateThread (

	  NULL ,
	  m_StackSize ,
	  ( LPTHREAD_START_ROUTINE ) ThreadProc ,
	  ( void * ) this ,
	  0 ,
	  & m_Identifier 
	) ;

	if ( m_Thread )
	{
		ThreadContainerIterator t_Iterator ;

		WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

		if ( ( t_StatusCode = s_ThreadContainer->Insert ( m_Identifier , this , t_Iterator ) ) == e_StatusCode_Success )
		{
		}

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
	}
	else
	{
		InternalRelease () ;

		t_StatusCode = e_StatusCode_OutOfResources ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiThread <WmiKey> :: WmiThread ( 

	WmiAllocator &a_Allocator ,
	const wchar_t *a_Name ,
	ULONG a_Timeout ,
	DWORD a_StackSize 

) : m_Allocator ( a_Allocator ) ,
	m_TaskQueue ( a_Allocator ) ,
	m_AlertableTaskQueue ( a_Allocator ) ,
	m_InterruptableTaskQueue ( a_Allocator ) ,
	m_Thread ( NULL ) ,
	m_Initialized ( NULL ) ,
	m_Terminate ( NULL ) ,
	m_QueueChange ( NULL ) ,
	m_Identifier ( 0 ) ,
	m_Name ( NULL ) ,
	m_Timeout ( a_Timeout ) ,
	m_StackSize ( a_StackSize ) ,
	m_ReferenceCount ( 0 ) ,
	m_InternalReferenceCount ( 0 ) ,
	m_InitializationStatusCode ( e_StatusCode_Success ),
	m_CriticalSection(NOTHROW_LOCK)
{
	m_InitializationStatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = m_TaskQueue.Initialize () ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = m_InterruptableTaskQueue.Initialize () ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = m_AlertableTaskQueue.Initialize () ;
	}

	if ( a_Name ) 
	{
		m_InitializationStatusCode = WmiHelper :: DuplicateString ( m_Allocator , a_Name , m_Name ) ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = WmiHelper :: CreateUnNamedEvent ( m_Terminate ) ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = WmiHelper :: CreateUnNamedEvent ( m_Initialized ) ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = WmiHelper :: CreateUnNamedEvent ( m_QueueChange ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiThread <WmiKey> :: ~WmiThread ()
{
	if ( m_Name )
	{
		m_Allocator.Delete ( ( void * ) m_Name ) ;
	}

	if ( m_Initialized )
	{
		CloseHandle ( m_Initialized ) ;
	}

	if ( m_Terminate )
	{
		CloseHandle ( m_Terminate ) ;
	}

	if ( m_QueueChange )
	{
		CloseHandle ( m_QueueChange ) ;
	}

	if ( m_Thread ) 
	{
		CloseHandle ( m_Thread ) ;
	}

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Initialize ( const ULONG &a_Timeout )
{
	if ( m_InitializationStatusCode == e_StatusCode_Success ) 
	{
		m_InitializationStatusCode = CreateThread () ;
	}

	if ( m_InitializationStatusCode == e_StatusCode_Success )
	{
		ULONG t_Status = WaitForSingleObject ( m_Initialized , a_Timeout ) ;
		switch ( t_Status )
		{
			case WAIT_TIMEOUT:
			{
				m_InitializationStatusCode = e_StatusCode_Success_Timeout ;
			}
			break ;

			case WAIT_OBJECT_0:
			{
				m_InitializationStatusCode = e_StatusCode_Success ;
			}
			break ;

			default :
			{
				m_InitializationStatusCode = e_StatusCode_Unknown ;
			}
			break ;
		}
	}

	return m_InitializationStatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	t_StatusCode = m_TaskQueue.UnInitialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = m_InterruptableTaskQueue.UnInitialize () ;
	}

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = m_AlertableTaskQueue.UnInitialize () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: TimedOut ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

// Queue a task to be executed immediately, a thread that calls a task procedure that
// executes a Wait or MsgWait will receive an indication in Queue status will not execute
// newly queued tasks.

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: EnQueue ( 

	const WmiKey &a_Key ,
	WmiTask <WmiKey> &a_Task
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

	TaskContainerIterator t_Iterator ;
	if ( ( t_StatusCode = s_TaskContainer->Insert ( &a_Task , this , t_Iterator ) ) == e_StatusCode_Success )
	{

		a_Task.SetTaskState ( WmiTask < WmiKey > :: e_WmiTask_EnQueued ) ;

		a_Task.AddRef () ;

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		QueueKey t_QueueKey ( m_Key++ , a_Key ) ;
		t_StatusCode = m_TaskQueue.EnQueue ( t_QueueKey , & a_Task ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{

			a_Task.EnqueueAs ( WmiTask <WmiKey> :: e_WmiTask_Enqueue ) ;

			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
			BOOL t_Status = SetEvent ( m_QueueChange ) ;
			if ( ! t_Status ) 
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
		else
		{
			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

			WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

			t_StatusCode = s_TaskContainer->Delete ( &a_Task ) ;

			WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

			a_Task.Release () ;
		}
	}
	else
	{
		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: EnQueueAlertable ( 

	const WmiKey &a_Key ,
	WmiTask <WmiKey> &a_Task
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	
	WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

	TaskContainerIterator t_Iterator ;
	if ( ( t_StatusCode = s_TaskContainer->Insert ( &a_Task , this , t_Iterator ) ) == e_StatusCode_Success )
	{

		a_Task.SetTaskState ( WmiTask < WmiKey > :: e_WmiTask_EnQueued ) ;
		
		a_Task.AddRef () ;

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		QueueKey t_QueueKey ( m_Key++ , a_Key ) ;
		t_StatusCode = m_AlertableTaskQueue.EnQueue ( t_QueueKey , & a_Task ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{

			a_Task.EnqueueAs ( WmiTask <WmiKey> :: e_WmiTask_EnqueueAlertable ) ;

			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
			BOOL t_Status = SetEvent ( m_QueueChange ) ;
			if ( ! t_Status ) 
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
		else
		{
			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

			WmiHelper :: EnterCriticalSection ( & s_CriticalSection , TRUE ) ;

			t_StatusCode = s_TaskContainer->Delete ( &a_Task ) ;

			WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

			a_Task.Release () ;
		}
	}
	else
	{
		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

// Queue a task to be executed immediately, a thread that calls a task procedure that
// executes a Wait or MsgWait will receive an indication of Queue status change will execute
// newly queued tasks. This is used for STA based execution where we need to interrupt the wait
// to execute a dependant request.
// 

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: EnQueueInterruptable ( 

	const WmiKey &a_Key ,
	WmiTask <WmiKey> &a_Task
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	
	WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

	TaskContainerIterator t_Iterator ;
	if ( ( t_StatusCode = s_TaskContainer->Insert ( &a_Task , this , t_Iterator ) ) == e_StatusCode_Success )
	{

		a_Task.SetTaskState ( WmiTask < WmiKey > :: e_WmiTask_EnQueued ) ;

		a_Task.AddRef () ;

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		QueueKey t_QueueKey ( m_Key++ , a_Key ) ;
		t_StatusCode = m_InterruptableTaskQueue.EnQueue ( t_QueueKey , & a_Task ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{

			a_Task.EnqueueAs ( WmiTask <WmiKey> :: e_WmiTask_EnqueueInterruptable ) ;

			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
			BOOL t_Status = SetEvent ( m_QueueChange ) ;
			if ( ! t_Status ) 
			{
				t_StatusCode = e_StatusCode_Failed ;
			}
		}
		else
		{
			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

			WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

			t_StatusCode = s_TaskContainer->Delete ( &a_Task ) ;

			WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

			a_Task.Release () ;
		}
	}
	else
	{
		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: DeQueue ( 

	const WmiKey &a_Key ,
	WmiTask <WmiKey> &a_Task
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Task.SetTaskState ( WmiTask < WmiKey > :: e_WmiTask_DeQueued ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: DeQueueAlertable ( 

	const WmiKey &a_Key ,
	WmiTask <WmiKey> &a_Task
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Task.SetTaskState ( WmiTask < WmiKey > :: e_WmiTask_DeQueued ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: DeQueueInterruptable ( 

	const WmiKey &a_Key ,
	WmiTask <WmiKey> &a_Task
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_Task.SetTaskState ( WmiTask < WmiKey > :: e_WmiTask_DeQueued ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiThread <WmiKey> *WmiThread <WmiKey> :: GetThread ()
{
	WmiThread *t_Thread = NULL ;

	ULONG t_CurrentThreadId = GetCurrentThreadId () ;

	ThreadContainerIterator	t_Iterator ;

	WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

	WmiStatusCode t_StatusCode = s_ThreadContainer->Find ( t_CurrentThreadId , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_Thread = t_Iterator.GetElement () ;
	}

	WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

	return t_Thread ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiThread <WmiKey> *WmiThread <WmiKey> :: GetServicingThread ( WmiTask <WmiKey> &a_Task )
{
	WmiThread *t_Thread = NULL ;

	TaskContainerIterator t_Iterator ;

	WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

	WmiStatusCode t_StatusCode = s_TaskContainer->Find ( &a_Task, t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_Thread = t_Iterator.GetElement () ;
	}

	WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

	return t_Thread ;
}

/*

	Scheduling Action

Task None

	Dispatch nothing 

	On Thread

		Wait on Completion
		Wait on Thread Termination

		Wait on Servicing Thread Termination


	Off Thread

		Wait on Completion

		Wait on Servicing Thread Termination


Task Altertable	

	Dispatch Alertable Queue

	On Thread

		MsgWait on Completion
		MsgWait on Thread Termination

		MsgWait on Servicing Thread Termination

	Off Thread

		MsgWait on Completion

		MsgWait on Servicing Thread Termination

Task Interruptable	

	Dispatch Alertable Queue

	Dispatch Normal Queue

	On Thread

		MsgWait on Completion
		MsgWait on Thread Termination

		MsgWait on Servicing Thread Termination
		MsgWait on Alertables

	Off Thread

		MsgWait on Completion

		MsgWait on Servicing Thread Termination

Thread	Alertable

	Dispatch Alertable Queue

	Dispatch Normal Queue

	MsgWait on Thread Termination

	MsgWait on Alertables

*/

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_Dispatch (

	WmiTask <WmiKey> &a_Task ,
	WmiThread <WmiKey> &a_Thread ,
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	HANDLE t_Handles [ 3 ] ;
	t_Handles [ 0 ] = a_Task.GetCompletionEvent () ;
	t_Handles [ 1 ] = a_Thread.GetHandle () ;
	t_Handles [ 2 ] = a_Thread.GetTerminationEvent () ;

	ULONG t_Event = WaitForMultipleObjects (

		3 ,
		t_Handles ,
		FALSE ,
		a_Timeout 
	) ;	

	switch ( t_Event )
	{
		case WAIT_TIMEOUT:
		{
			t_StatusCode = e_StatusCode_Success_Timeout ;
		}
		break ;

		case WAIT_OBJECT_0:
		{
			t_StatusCode = e_StatusCode_Success ;
		}
		break ;

		case WAIT_OBJECT_0+1:
		case WAIT_OBJECT_0+2:
		{
			t_StatusCode = e_StatusCode_ServicingThreadTerminated ;

#if DBG
		DebugBreak();
#endif
		}
		break ;
		case WAIT_FAILED:
			{
			if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
				{
				t_StatusCode = e_StatusCode_OutOfMemory;
				break;
				}
			}
		default:
		{
			
			t_StatusCode = e_StatusCode_Unknown ;
#if DBG
			DebugBreak();
#endif
		}
		break ;
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_Dispatch (

	WmiTask <WmiKey> &a_Task ,
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThread *t_Thread = GetThread () ;
	if ( t_Thread )
	{
		t_StatusCode = t_Thread->Dispatch ( a_Task , a_Timeout ) ;
	}
	else
	{
		WmiThread *t_ServicingThread = GetServicingThread ( a_Task ) ;
		if ( t_ServicingThread )
		{
			t_StatusCode = Static_Dispatch ( a_Task , *t_ServicingThread , a_Timeout ) ;
		}
		else	
		{
			t_StatusCode = e_StatusCode_Success ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Dispatch (

	WmiTask <WmiKey> &a_Task , 
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	do
	{
	}
	while ( ( t_StatusCode = Wait ( a_Task , a_Timeout ) ) == e_StatusCode_Success ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Wait (

	WmiTask <WmiKey> &a_Task ,
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThread *t_ServicingThread = GetServicingThread ( a_Task ) ;
	if ( t_ServicingThread )
	{
		HANDLE t_Handles [ 4 ] ;
		t_Handles [ 0 ] = a_Task.GetCompletionEvent () ;
		t_Handles [ 1 ] = GetTerminationEvent () ;
		t_Handles [ 2 ] = t_ServicingThread->GetHandle () ;
		t_Handles [ 3 ] = t_ServicingThread->GetTerminationEvent () ;

		ULONG t_Event = WaitForMultipleObjects (

			4 ,
			t_Handles ,
			FALSE ,
			a_Timeout 
		) ;	

		switch ( t_Event )
		{
			case WAIT_TIMEOUT:
			{
				t_StatusCode = e_StatusCode_Success_Timeout ;
			}
			break ;

			case WAIT_OBJECT_0:
			{
				t_StatusCode = e_StatusCode_Success ;
			}
			break ;

			case WAIT_OBJECT_0+1:
			{
				t_StatusCode = e_StatusCode_HostingThreadTerminated ;
#if DBG
				DebugBreak();
#endif

			}
			break ;

			case WAIT_OBJECT_0+2:
			case WAIT_OBJECT_0+3:
			{
				t_StatusCode = e_StatusCode_ServicingThreadTerminated ;
#if DBG
				DebugBreak();
#endif

			}
			break ;
			case WAIT_FAILED:
				{
				if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
					{
					t_StatusCode = e_StatusCode_OutOfMemory;
					break;
					}
				}

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
#if DBG
				DebugBreak();
#endif

			}
			break ;
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_Success ;
	}	

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_InterruptableDispatch (

	WmiTask <WmiKey> &a_Task ,
	WmiThread <WmiKey> &a_Thread ,
	const ULONG &a_Timeout
)
{
	int sleep_duration = 0;
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	HANDLE t_Handles [ 3 ] ;
	t_Handles [ 0 ] = a_Task.GetCompletionEvent () ;
	t_Handles [ 1 ] = a_Thread.GetHandle () ;
	t_Handles [ 2 ] = a_Thread.GetTerminationEvent () ;

	bool t_Continuing = true ;

	while ( t_Continuing && t_StatusCode == e_StatusCode_Success ) 
	{
		ULONG t_Event = MsgWaitForMultipleObjects (

			3 ,
			t_Handles ,
			FALSE ,
			a_Timeout ,
			QS_ALLINPUT
		) ;	

		switch ( t_Event )
		{
			case WAIT_TIMEOUT:
			{
				t_StatusCode = e_StatusCode_Success_Timeout ;
			}
			break ;

			case WAIT_OBJECT_0:
			{
				t_StatusCode = e_StatusCode_Success ;
				t_Continuing = false ;
			}
			break ;

			case WAIT_OBJECT_0+1:
			case WAIT_OBJECT_0+2:
			{
				t_StatusCode = e_StatusCode_ServicingThreadTerminated ;
#if DBG
				DebugBreak();
#endif

			}
			break ;

			case WAIT_OBJECT_0+3:
			{
				BOOL t_DispatchStatus ;
				MSG t_Msg ;

				while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
				{
					if ( ( t_DispatchStatus = GetMessage ( & t_Msg , NULL , 0 , 0 ) ) == TRUE )
					{
						TranslateMessage ( & t_Msg ) ;
						DispatchMessage ( & t_Msg ) ;
					}
				}

				ULONG t_Event = WaitForMultipleObjects (

					3 ,
					t_Handles ,
					FALSE ,
					0
				) ;

				switch ( t_Event )
				{
					case WAIT_TIMEOUT:
					{
						t_StatusCode = e_StatusCode_Success_Timeout ;
					}
					break ;

					case WAIT_OBJECT_0:
					{
						t_StatusCode = e_StatusCode_Success ;
						t_Continuing = true ;
					}
					break ;

					case WAIT_OBJECT_0+1:
					case WAIT_OBJECT_0+2:
					{
						t_StatusCode = e_StatusCode_ServicingThreadTerminated ;
#if DBG
						DebugBreak();
#endif

					}
					break ;
					case WAIT_FAILED:
					{
						if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
							{
							  Sleep(sleep_duration?10:0);
							  sleep_duration^=1;
							  continue;
							}
					}

					default:
					{
						t_StatusCode = e_StatusCode_Unknown ;
#if DBG
						DebugBreak();
#endif
					}
					break ;
				}
			}
			break ;
			case WAIT_FAILED:
			{
				if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
					{
					  Sleep(sleep_duration?10:0);
					  sleep_duration^=1;
					  continue;
					}
			}

			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
#if DBG
				DebugBreak();
#endif

			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_InterruptableDispatch (

	WmiTask <WmiKey> &a_Task ,
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThread *t_Thread = GetThread () ;
	if ( t_Thread )
	{
		t_StatusCode = t_Thread->InterruptableDispatch ( a_Task , a_Timeout ) ;
	}
	else
	{
		WmiThread *t_ServicingThread = GetServicingThread ( a_Task ) ;
		if ( t_ServicingThread )
		{
			t_StatusCode = Static_InterruptableDispatch ( a_Task , *t_ServicingThread , a_Timeout ) ;
		}
		else	
		{
			t_StatusCode = e_StatusCode_Success ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: InterruptableDispatch (

	WmiTask <WmiKey> &a_Task , 
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	QueueContainer t_EnQueue ( m_Allocator ) ;
	t_StatusCode = t_EnQueue.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		do
		{
			do
			{
				t_StatusCode = Execute ( m_InterruptableTaskQueue , t_EnQueue ) ;

			} while ( t_StatusCode == e_StatusCode_Success ) ;

			if ( t_StatusCode == e_StatusCode_NotInitialized )
			{
				WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

				t_StatusCode = m_InterruptableTaskQueue.Merge ( t_EnQueue ) ;

				WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					t_StatusCode = InterruptableWait ( a_Task , a_Timeout ) ;
				}
			}
		}
		while ( t_StatusCode == e_StatusCode_Success || t_StatusCode == e_StatusCode_Change ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: InterruptableWait (

	WmiTask <WmiKey> &a_Task ,
	const ULONG &a_Timeout
)
{
	int sleep_duration = 0;
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThread *t_ServicingThread = GetServicingThread ( a_Task ) ;
	if ( t_ServicingThread )
	{
		HANDLE t_Handles [ 5 ] ;
		t_Handles [ 0 ] = a_Task.GetCompletionEvent () ;
		t_Handles [ 1 ] = GetTerminationEvent () ;
		t_Handles [ 2 ] = t_ServicingThread->GetHandle () ;
		t_Handles [ 3 ] = t_ServicingThread->GetTerminationEvent () ;
		t_Handles [ 4 ] = t_ServicingThread->GetQueueChangeEvent () ;

		bool t_Continuing = true ;

		while ( t_Continuing && t_StatusCode == e_StatusCode_Success ) 
		{
			ULONG t_Event = MsgWaitForMultipleObjects (

				5 ,
				t_Handles ,
				FALSE ,
				a_Timeout ,
				QS_ALLINPUT
			) ;	

			switch ( t_Event )
			{
				case WAIT_TIMEOUT:
				{
					t_StatusCode = e_StatusCode_Success_Timeout ;
				}
				break ;

				case WAIT_OBJECT_0:
				{
					t_StatusCode = e_StatusCode_Success ;
					t_Continuing = false ;
				}
				break ;

				case WAIT_OBJECT_0+1:
				{
					t_StatusCode = e_StatusCode_HostingThreadTerminated ;
#if DBG
					DebugBreak();
#endif

				}
				break ;

				case WAIT_OBJECT_0+2:
				case WAIT_OBJECT_0+3:
				{
					t_StatusCode = e_StatusCode_ServicingThreadTerminated ;
#if DBG
					DebugBreak();
#endif

				}
				break ;

				case WAIT_OBJECT_0+4:
				{
					t_StatusCode = e_StatusCode_Change ;
				}
				break ;

				case WAIT_OBJECT_0+5:
				{
					BOOL t_DispatchStatus ;
					MSG t_Msg ;

					while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
					{
						if ( ( t_DispatchStatus = GetMessage ( & t_Msg , NULL , 0 , 0 ) ) == TRUE )
						{
							TranslateMessage ( & t_Msg ) ;
							DispatchMessage ( & t_Msg ) ;
						}
					}

					ULONG t_Event = WaitForMultipleObjects (

						5 ,
						t_Handles ,
						FALSE ,
						0
					) ;

					switch ( t_Event )
					{
						case WAIT_TIMEOUT:
						{
							t_StatusCode = e_StatusCode_Success_Timeout ;
						}
						break ;

						case WAIT_OBJECT_0:
						{
							t_StatusCode = e_StatusCode_Success ;
							t_Continuing = false ;
						}
						break ;

						case WAIT_OBJECT_0+1:
						{
							t_StatusCode = e_StatusCode_HostingThreadTerminated ;

#if DBG
							DebugBreak();
#endif

						}
						break ;

						case WAIT_OBJECT_0+2:
						case WAIT_OBJECT_0+3:
						{
							t_StatusCode = e_StatusCode_ServicingThreadTerminated ;
#if DBG
							DebugBreak();
#endif

						}
						break ;

						case WAIT_OBJECT_0+4:
						{
							t_StatusCode = e_StatusCode_Change ;
						}
						break ;

						case WAIT_FAILED:
						{
							if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
								{
								  Sleep(sleep_duration?10:0);
								  sleep_duration^=1;
								  continue;
								}
						}
							
						default:
						{
			
							t_StatusCode = e_StatusCode_Unknown ;
#if DBG
							DebugBreak();
#endif

						}
						break ;
					}
				}
				break ;
				case WAIT_FAILED:
				{
					if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
						{
						  Sleep(sleep_duration?10:0);
						  sleep_duration^=1;
						  continue;
						}
				}

				default:
				{
					t_StatusCode = e_StatusCode_Unknown ;
#if DBG
					DebugBreak();
#endif

				}
				break ;
			}
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_Success ;
	}	
		
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_AlertableDispatch (

	WmiTask <WmiKey> &a_Task ,
	WmiThread <WmiKey> &a_Thread ,
	const ULONG &a_Timeout
)
{
	int sleep_duration = 0;
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	HANDLE t_Handles [ 3 ] ;
	t_Handles [ 0 ] = a_Task.GetCompletionEvent () ;
	t_Handles [ 1 ] = a_Thread.GetHandle () ;
	t_Handles [ 2 ] = a_Thread.GetTerminationEvent () ;

	bool t_Continuing = true ;

	while ( t_StatusCode == e_StatusCode_Success && t_Continuing ) 
	{
		ULONG t_Event = MsgWaitForMultipleObjects (

			3 ,
			t_Handles ,
			FALSE ,
			a_Timeout ,
			QS_ALLINPUT
		) ;	

		switch ( t_Event )
		{
			case WAIT_TIMEOUT:
			{
				t_StatusCode = e_StatusCode_Success_Timeout ;
			}
			break ;

			case WAIT_OBJECT_0:
			{
				t_StatusCode = e_StatusCode_Success ;
				t_Continuing = false ;
			}
			break ;

			case WAIT_OBJECT_0+1:
			case WAIT_OBJECT_0+2:
			{
				t_StatusCode = e_StatusCode_HostingThreadTerminated ;
#if DBG
				DebugBreak();
#endif

			}
			break ;

			case WAIT_OBJECT_0+3:
			{
				BOOL t_DispatchStatus ;
				MSG t_Msg ;

				while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
				{
					if ( ( t_DispatchStatus = GetMessage ( & t_Msg , NULL , 0 , 0 ) ) == TRUE )
					{
						TranslateMessage ( & t_Msg ) ;
						DispatchMessage ( & t_Msg ) ;
					}
				}

				ULONG t_Event = WaitForMultipleObjects (

					3 ,
					t_Handles ,
					FALSE ,
					0
				) ;

				switch ( t_Event )
				{
					case WAIT_TIMEOUT:
					{
						t_StatusCode = e_StatusCode_Success_Timeout ;
					}
					break ;

					case WAIT_OBJECT_0:
					{
						t_StatusCode = e_StatusCode_Success ;
						t_Continuing = false ;
					}
					break ;

					case WAIT_OBJECT_0+1:
					case WAIT_OBJECT_0+2:
					{
						t_StatusCode = e_StatusCode_ServicingThreadTerminated ;
					}
					break ;
					case WAIT_FAILED:
					{
						if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
							{
							  Sleep(sleep_duration?10:0);
							  sleep_duration^=1;
							  continue;
							}
					}

					default:
					{
						
						t_StatusCode = e_StatusCode_Unknown ;
#if DBG
						DebugBreak();
#endif

					}
					break ;
				}
			}
			break ;

			case WAIT_FAILED:
			{
				if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
					{
					  Sleep(sleep_duration?10:0);
					  sleep_duration^=1;
					  continue;
					}
			}
			default:
			{
				t_StatusCode = e_StatusCode_Unknown ;
#if DBG
				DebugBreak();
#endif

			}
			break ;
		}
	}
	
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Static_AlertableDispatch (

	WmiTask <WmiKey> &a_Task ,
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThread *t_Thread = GetThread () ;
	if ( t_Thread )
	{
		t_StatusCode = t_Thread->AlertableDispatch ( a_Task , a_Timeout ) ;
	}
	else
	{
		WmiThread *t_ServicingThread = GetServicingThread ( a_Task ) ;
		if ( t_ServicingThread )
		{
			t_StatusCode = Static_AlertableDispatch ( a_Task , *t_ServicingThread , a_Timeout ) ;
		}
		else	
		{
			t_StatusCode = e_StatusCode_Success ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: AlertableDispatch (

	WmiTask <WmiKey> &a_Task , 
	const ULONG &a_Timeout
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	QueueContainer t_EnQueue ( m_Allocator ) ;
	t_StatusCode = t_EnQueue.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		do
		{
			do
			{
				t_StatusCode = Execute ( m_InterruptableTaskQueue , t_EnQueue ) ;

			} while ( t_StatusCode == e_StatusCode_Success ) ;

			if ( t_StatusCode == e_StatusCode_NotInitialized )
			{
				WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

				t_StatusCode = m_InterruptableTaskQueue.Merge ( t_EnQueue ) ;

				WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					do
					{
						t_StatusCode = Execute ( m_TaskQueue , t_EnQueue ) ;
		
					} while ( t_StatusCode == e_StatusCode_Success ) ;
				}
			}

			if ( t_StatusCode == e_StatusCode_NotInitialized )
			{
				WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

				t_StatusCode = m_TaskQueue.Merge ( t_EnQueue ) ;

				WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					t_StatusCode = AlertableWait ( a_Task , a_Timeout ) ;
				}
			}
		}
		while ( t_StatusCode == e_StatusCode_Success || t_StatusCode == e_StatusCode_Change ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: Execute ( QueueContainer &a_Queue , QueueContainer &a_EnQueue )
{
	QueueKey t_TopKey ;
	WmiTask < WmiKey > *t_TopTask ;

	WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

	WmiStatusCode t_StatusCode = a_Queue.Top ( t_TopKey , t_TopTask  ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = a_Queue.DeQueue () ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

			if ( t_TopTask->TaskState () == WmiTask < WmiKey > :: e_WmiTask_EnQueued )
			{
				t_StatusCode = t_TopTask->Process ( *this ) ;
				if ( t_StatusCode != e_StatusCode_EnQueue ) 
				{
					WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

					if ( ( t_StatusCode = s_TaskContainer->Delete ( t_TopTask ) ) == e_StatusCode_NotFound ) 
					{
						WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

						t_StatusCode = e_StatusCode_Success ;
					}
					else
					{
						WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

						t_TopTask->Release () ;
					}
				}
				else
				{
					WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

					switch ( t_TopTask->EnqueuedAs () )
					{
						case WmiTask <WmiKey> :: e_WmiTask_Enqueue:
						{
							t_StatusCode = a_EnQueue.EnQueue ( t_TopKey , t_TopTask ) ;
						}
						break ;

						case WmiTask <WmiKey> :: e_WmiTask_EnqueueAlertable:
						{
							t_StatusCode = m_AlertableTaskQueue.EnQueue ( t_TopKey , t_TopTask ) ;
						}
						break ;

						case WmiTask <WmiKey> :: e_WmiTask_EnqueueInterruptable:
						{
							t_StatusCode = m_InterruptableTaskQueue.EnQueue ( t_TopKey , t_TopTask ) ;
						}
						break ;

						default:
						{
						}
						break ;
					}

					WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

					SetEvent ( m_QueueChange ) ;
				}
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

				if ( ( t_StatusCode = s_TaskContainer->Delete ( t_TopTask ) ) == e_StatusCode_NotFound ) 
				{
					WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

					t_StatusCode = e_StatusCode_Success ;
				}
				else
				{
					WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
				}

				t_TopTask->Complete () ;
				t_TopTask->Release () ;
			}
		}
		else
		{
			WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
		}
	}
	else
	{
		WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: ShuffleTask (

	const HANDLE &a_Event
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
	
	WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

	ULONG t_Index = m_AlertableTaskQueue.Size () ;

	while ( ( t_StatusCode == e_StatusCode_Success ) && ( t_Index ) )
	{
		QueueKey t_TopKey ;
		WmiTask < WmiKey > *t_TopTask ;

		t_StatusCode = m_AlertableTaskQueue.Top ( t_TopKey , t_TopTask  ) ;
		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			t_StatusCode = m_AlertableTaskQueue.DeQueue () ;
			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				if ( t_TopTask->GetEvent () == a_Event )
				{
					if ( t_TopTask->TaskState () == WmiTask < WmiKey > :: e_WmiTask_EnQueued )
					{
						t_StatusCode = m_TaskQueue.EnQueue ( t_TopKey , t_TopTask ) ;
						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							SetEvent ( m_QueueChange ) ;

							break ;
						}
					}
					else
					{
						WmiHelper :: EnterCriticalSection ( & s_CriticalSection ) ;

						if ( ( t_StatusCode = s_TaskContainer->Delete ( t_TopTask ) ) == e_StatusCode_NotFound ) 
						{
							WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

							t_StatusCode = e_StatusCode_Success ;
						}
						else
						{
							WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
						}

						t_TopTask->Complete () ;
						t_TopTask->Release () ; 
					}
				}
				else
				{
					t_TopKey.SetTick ( m_Key++ ) ;
					t_StatusCode = m_AlertableTaskQueue.EnQueue ( t_TopKey , t_TopTask ) ;
					if ( t_StatusCode == e_StatusCode_Success ) 
					{
					}
				}
			}
		}

		t_Index -- ;
	}

	WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: FillHandleTable (

	HANDLE *a_HandleTable , 
	ULONG &a_Capacity
)
{
	ULONG t_Index = 0 ;

	WmiStatusCode t_StatusCode = e_StatusCode_Success  ;
	
	WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

	QueueContainerIterator t_Iterator ;
	t_Iterator = m_AlertableTaskQueue.End () ;

	while ( ( t_StatusCode == e_StatusCode_Success ) && ( t_Index < a_Capacity ) && ! t_Iterator.Null () )
	{
		if ( t_Iterator.GetElement ()->GetEvent () )
		{
			a_HandleTable [ t_Index ] = t_Iterator.GetElement ()->GetEvent () ;
		}
		else
		{
			t_StatusCode = e_StatusCode_InvalidArgs ;
		}

		t_Iterator.Decrement () ;

		t_Index ++ ;
	}

	if ( t_StatusCode == e_StatusCode_NotInitialized )
	{
		t_StatusCode = e_StatusCode_Success ;
	}

	a_Capacity = t_Index ;

	WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: AlertableWait (

	WmiTask <WmiKey> &a_Task ,
	const ULONG &a_Timeout
)
{
	int sleep_duration = 0;
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiThread *t_ServicingThread = GetServicingThread ( a_Task ) ;
	if ( t_ServicingThread )
	{
		HANDLE t_Handles [ MAXIMUM_WAIT_OBJECTS - 1 ] ;
		t_Handles [ 0 ] = a_Task.GetCompletionEvent () ;
		t_Handles [ 1 ] = GetTerminationEvent () ;
		t_Handles [ 2 ] = t_ServicingThread->GetHandle () ;
		t_Handles [ 3 ] = t_ServicingThread->GetTerminationEvent () ;
		t_Handles [ 4 ] = t_ServicingThread->GetQueueChangeEvent () ;

		ULONG t_Capacity = MAXIMUM_WAIT_OBJECTS - 6 ;
		t_StatusCode = FillHandleTable ( & t_Handles [ 5 ] , t_Capacity ) ;

		bool t_Continuing = true ;

		while ( t_Continuing && t_StatusCode == e_StatusCode_Success ) 
		{
			ULONG t_Event = MsgWaitForMultipleObjects (

				5 + t_Capacity ,
				t_Handles ,
				FALSE ,
				a_Timeout ,
				QS_ALLINPUT
			) ;	

			switch ( t_Event )
			{
				case WAIT_TIMEOUT:
				{
					t_StatusCode = e_StatusCode_Success_Timeout ;
				}
				break ;

				case WAIT_OBJECT_0:
				{
					t_StatusCode = e_StatusCode_Success ;
					t_Continuing = false ;
				}
				break ;

				case WAIT_OBJECT_0+1:
				{
					t_StatusCode = e_StatusCode_HostingThreadTerminated ;
#if DBG
					DebugBreak();
#endif

				}
				break ;

				case WAIT_OBJECT_0+2:
				case WAIT_OBJECT_0+3:
				{
					t_StatusCode = e_StatusCode_ServicingThreadTerminated ;
#if DBG
					DebugBreak();
#endif

				}
				break ;

				case WAIT_OBJECT_0+4:
				{
					t_StatusCode = e_StatusCode_Change ;
				}
				break ;
				case WAIT_FAILED:
				{
					if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
						{
						  Sleep(sleep_duration?10:0);
						  sleep_duration^=1;
						  continue;
						}
				}

				default:
				{
					if ( t_Event == t_Capacity + 5 )
					{
						BOOL t_DispatchStatus ;
						MSG t_Msg ;

						while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
						{
							if ( ( t_DispatchStatus = GetMessage ( & t_Msg , NULL , 0 , 0 ) ) == TRUE )
							{
								TranslateMessage ( & t_Msg ) ;
								DispatchMessage ( & t_Msg ) ;
							}
						}

						ULONG t_Event = WaitForMultipleObjects (

							5 + t_Capacity ,
							t_Handles ,
							FALSE ,
							0
						) ;

						switch ( t_Event )
						{
							case WAIT_TIMEOUT:
							{
								t_StatusCode = e_StatusCode_Success_Timeout ;
							}
							break ;

							case WAIT_OBJECT_0:
							{
								t_StatusCode = e_StatusCode_Success ;
								t_Continuing = false ;
							}
							break ;

							case WAIT_OBJECT_0+1:
							{
								t_StatusCode = e_StatusCode_HostingThreadTerminated ;

#if DBG
								DebugBreak();
#endif

							}
							break ;

							case WAIT_OBJECT_0+2:
							case WAIT_OBJECT_0+3:
							{
								t_StatusCode = e_StatusCode_ServicingThreadTerminated ;

#if DBG
								DebugBreak();
#endif

							}
							break ;

							case WAIT_OBJECT_0+4:
							{
								t_StatusCode = e_StatusCode_Change ;
							}
							break ;

							case WAIT_FAILED:
							{
								if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
									{
									  Sleep(sleep_duration?10:0);
									  sleep_duration^=1;
									  continue;
									}
							}
							default:
							{
								if ( t_Event < t_Capacity + 5 )
								{
									t_StatusCode = ShuffleTask ( t_Handles [ t_Event ] ) ;
								}
								else
								{
									t_StatusCode = e_StatusCode_InvalidArgs ;

#if DBG
									DebugBreak();
#endif

								}
							}
						}
					}
					else if ( t_Event < t_Capacity + 5 )
					{
						t_StatusCode = ShuffleTask ( t_Handles [ t_Event ] ) ;
					}
					else
					{
						t_StatusCode = e_StatusCode_InvalidArgs ;
#if DBG
						DebugBreak();
#endif

					}
				}
				break ;
			}
		}
	}
	else
	{
		t_StatusCode = e_StatusCode_Success ;
	}	
		
	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: ThreadDispatch ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	QueueContainer t_EnQueue ( m_Allocator ) ;
	t_StatusCode = t_EnQueue.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		do
		{
			do
			{
				t_StatusCode = Execute ( m_InterruptableTaskQueue , t_EnQueue  ) ;

			} while ( t_StatusCode == e_StatusCode_Success ) ;

			if ( t_StatusCode == e_StatusCode_NotInitialized )
			{
				WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

				t_StatusCode = m_InterruptableTaskQueue.Merge ( t_EnQueue ) ;

				WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					do
					{
						t_StatusCode = Execute ( m_TaskQueue , t_EnQueue ) ;

					} while ( t_StatusCode == e_StatusCode_Success ) ;
				}
			}

			if ( t_StatusCode == e_StatusCode_NotInitialized )
			{
				WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

				t_StatusCode = m_TaskQueue.Merge ( t_EnQueue ) ;

				WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					t_StatusCode = ThreadWait () ;
				}
			}
		}
		while ( t_StatusCode == e_StatusCode_Success || t_StatusCode == e_StatusCode_Change ) ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
WmiStatusCode WmiThread <WmiKey> :: ThreadWait ()
{
	int sleep_duration = 0;
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	HANDLE t_Handles [ MAXIMUM_WAIT_OBJECTS - 1 ] ;

	t_Handles [ 0 ] = GetTerminationEvent () ;
	t_Handles [ 1 ] = GetQueueChangeEvent () ;

	ULONG t_Capacity = MAXIMUM_WAIT_OBJECTS - 3 ;
	t_StatusCode = FillHandleTable ( & t_Handles [ 2 ] , t_Capacity ) ;

	bool t_Continuing = true ;

	while ( t_Continuing && t_StatusCode == e_StatusCode_Success ) 
	{
		ULONG t_Event = MsgWaitForMultipleObjectsEx (

			2 + t_Capacity ,
			t_Handles ,
			m_Timeout ,
			QS_ALLINPUT ,
			MWMO_ALERTABLE
		) ;	

		switch ( t_Event )
		{
			case WAIT_TIMEOUT:
			{
				t_StatusCode = TimedOut () ;
			}
			break ;

			case WAIT_OBJECT_0:
			{
				t_StatusCode = e_StatusCode_HostingThreadTerminated ;

#if DBG
				OutputDebugStringA ("\nWmiThread - Thread Terminating") ;
#endif
			}
			break ;

			case WAIT_OBJECT_0+1:
			{
				t_StatusCode = e_StatusCode_Change ;
			}
			break ;

			case WAIT_IO_COMPLETION:
			{
				t_StatusCode = e_StatusCode_Success;
			}
			break ;

			case WAIT_FAILED:
			{
				if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
					{
					  Sleep(sleep_duration?10:0);
					  sleep_duration^=1;
					  continue;
					}
			}
			default:
			{
				if ( t_Event == t_Capacity + 2 )
				{
					BOOL t_DispatchStatus ;
					MSG t_Msg ;

					while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
					{
						if ( ( t_DispatchStatus = GetMessage ( & t_Msg , NULL , 0 , 0 ) ) == TRUE )
						{
							TranslateMessage ( & t_Msg ) ;
							DispatchMessage ( & t_Msg ) ;
						}
					}

					ULONG t_Event = WaitForMultipleObjects (

						2 + t_Capacity ,
						t_Handles ,
						FALSE ,
						0
					) ;

					switch ( t_Event )
					{
						case WAIT_TIMEOUT:
						{
							t_StatusCode = TimedOut () ;
						}
						break ;

						case WAIT_OBJECT_0:
						{
							t_StatusCode = e_StatusCode_HostingThreadTerminated ;


#if DBG
							OutputDebugStringA ( "\nWmiThread - Thread Terminating") ;
#endif
						}
						break ;

						case WAIT_OBJECT_0+1:
						{
							t_StatusCode = e_StatusCode_Change ;
						}
						break ;

						case WAIT_FAILED:
						{
							if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
								{
								  Sleep(sleep_duration?10:0);
								  sleep_duration^=1;
								  continue;
								}
						}
						
						default:
						{
							if ( t_Event < t_Capacity + 2 )
							{
								t_StatusCode = ShuffleTask ( t_Handles [ t_Event ] ) ;
							}
							else
							{
								t_StatusCode = e_StatusCode_InvalidArgs ;

#if DBG
								DebugBreak();
#endif

							}
						}
					}
				}
				else if ( t_Event < t_Capacity + 2 )
				{
					t_StatusCode = ShuffleTask ( t_Handles [ t_Event ] ) ;
				}
				else
				{
					t_StatusCode = e_StatusCode_InvalidArgs ;

#if DBG
					DebugBreak();
#endif

				}
			}
			break ;
		}
	}
		
	return t_StatusCode ;
}

#endif __THREAD_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\include\allocator.h ===
#ifndef __Allocator_H
#define __Allocator_H

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

enum WmiStatusCode
{
	e_StatusCode_Success = 0 ,
	e_StatusCode_Success_Timeout ,
	e_StatusCode_EnQueue,
	e_StatusCode_OutOfMemory = 0x80000000 ,
	e_StatusCode_OutOfResources ,
	e_StatusCode_NotInitialized ,
	e_StatusCode_AlreadyInitialized ,
	e_StatusCode_InvalidArgs ,
	e_StatusCode_OutOfBounds ,
	e_StatusCode_OutOfQuota ,
	e_StatusCode_Unknown ,
	e_StatusCode_NotFound ,
	e_StatusCode_AlreadyExists ,
	e_StatusCode_Failed ,
	e_StatusCode_ServicingThreadTerminated ,
	e_StatusCode_HostingThreadTerminated ,
	e_StatusCode_Change ,
	e_StatusCode_InvalidHeap
} ;

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new ( size_t a_Size , void *a_Ptr ) { return a_Ptr ; }
inline void __cdecl operator delete ( void * , void * ) { ; }
#endif

/* 
 *	Class:
 *
 *		WmiAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiAllocator
{
public:

	enum AllocationOptions 
	{
		e_GenerateException = HEAP_GENERATE_EXCEPTIONS ,
		e_NoSerialize = HEAP_NO_SERIALIZE ,
		e_ZeroMemory = HEAP_ZERO_MEMORY ,
		e_ReallocInPlace = HEAP_REALLOC_IN_PLACE_ONLY ,
		e_DefaultAllocation = 0 
	} ;

private:


	LONG m_ReferenceCount ;

	HANDLE m_Heap ;
	AllocationOptions m_Options ;
	size_t m_InitialSize ;
	size_t m_MaximumSize ;

	WmiStatusCode Win32ToApi () ;

public:

	WmiAllocator () ;
		
	WmiAllocator ( 

		AllocationOptions a_Option , 
		size_t a_InitialSize , 
		size_t a_MaximumSize

	) ;

	~WmiAllocator () ;

	ULONG AddRef () ;

	ULONG Release () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode New ( 

		void **a_Allocation , 
		size_t a_Size
	) ;

	WmiStatusCode New ( 

		AllocationOptions a_Option , 
		void **a_Allocation , 
		size_t a_Size
	) ;

	WmiStatusCode ReAlloc ( 

		void *a_Allocation , 
		void **a_ReAllocation , 
		size_t a_Size
	) ;

	WmiStatusCode ReAlloc ( 

		AllocationOptions a_Option , 
		void *a_Allocation , 
		void **a_ReAllocation , 
		size_t a_Size
	) ;

	WmiStatusCode Delete (

		void *a_Allocation
	) ;

	WmiStatusCode Size ( 

		void *a_Allocation ,
		size_t &a_Size
	) ;

	WmiStatusCode Compact ( 

		size_t &a_LargestFreeBlock
	) ;

	WmiStatusCode Validate (

		LPCVOID a_Location = NULL 
	) ;

} ;

#endif // __Allocator_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\include\hashtable.h ===
#ifndef _HASHTABLE_H
#define _HASHTABLE_H

#include "Allocator.h"
#include "BasicTree.h"

template <class WmiKey,class WmiElement,ULONG HashSize>
class WmiHashTable
{
private:

	WmiBasicTree <WmiKey,WmiElement> *m_Buckets ;

	WmiAllocator &m_Allocator ;

public:

	WmiHashTable ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiHashTable () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode Insert ( 

		const WmiKey &a_Key ,
		const WmiElement &a_Element
	) ;

	WmiStatusCode Delete ( 

		const WmiKey &a_Key
	) ;

	WmiStatusCode Find (

		const WmiKey &a_Key	,
		WmiElement &a_Element 
	) ;
	
	ULONG Size () { return m_Root.Size () ; } ;
	
} ;

#include <HashTable.cpp>

#endif _HASHTABLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\include\helperfuncs.h ===
#ifndef _HELPERFUNCS_H
#define _HELPERFUNCS_H

#include <Allocator.H>
#include <lockst.h>
class WmiHelper
{
public:

	static WmiStatusCode DuplicateString ( 

		WmiAllocator &a_Allocator , 
		const wchar_t *a_String , 
		wchar_t *&a_DuplicatedString
	) ;

	static WmiStatusCode CreateUnNamedEvent (

		HANDLE &a_Event , 
		BOOL a_ManualReset = FALSE ,
		BOOL a_InitialState = FALSE 
	) ;

	static WmiStatusCode CreateNamedEvent (

		wchar_t *a_Name , 
		HANDLE &a_Event , 
		BOOL a_ManualReset = FALSE ,
		BOOL a_InitialState = FALSE 
	) ;

	static WmiStatusCode DuplicateHandle (

		HANDLE a_Handle , 
		HANDLE &a_DuplicatedHandle
	) ;


	static WmiStatusCode ConcatenateStrings (

		ULONG a_ArgCount , 
		BSTR *a_AllocatedString ,
		...
	) ;

	static WmiStatusCode ConcatenateStrings_Wchar (

		ULONG a_ArgCount , 
		wchar_t **a_AllocatedString ,
		...
	) ;

	static WmiStatusCode InitializeCriticalSection ( 
	
		CRITICAL_SECTION *a_CriticalSection
	) ;

	static WmiStatusCode DeleteCriticalSection ( 
	
		CRITICAL_SECTION *a_CriticalSection
	) ;

	static WmiStatusCode EnterCriticalSection ( 
	
		CRITICAL_SECTION *a_CriticalSection ,
		BOOL a_WaitCritical = TRUE
	) ;

	static WmiStatusCode LeaveCriticalSection ( 
	
		CRITICAL_SECTION *a_CriticalSection
	) ;

	static WmiStatusCode EnterCriticalSection ( 
	
		CriticalSection* a_CriticalSection ,
		BOOL a_WaitCritical = TRUE
	) ;

	static WmiStatusCode LeaveCriticalSection ( 
	
		CriticalSection *a_CriticalSection
	) ;
	static WmiStatusCode InitializeCriticalSection ( 
	
		CriticalSection *a_CriticalSection
	) ;

	static WmiStatusCode DeleteCriticalSection ( 
		CriticalSection *a_CriticalSection
	) ;
	

} ;

#endif _HELPERFUNCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\include\avltree.h ===
#ifndef _AVLTREE_H
#define _AVLTREE_H

#include "PssException.h"
#include "Allocator.h"
#include "Algorithms.h"
#include "AvlTree.h"

template <class WmiKey,class WmiElement>
class WmiAvlTree
{
public:

	class WmiAvlNode
	{
	public:

		enum WmAvlState
		{
			e_Equal,
			e_LeftHigher ,
			e_RightHigher
		} ;

		WmiKey m_Key ;

		WmiAvlNode *m_Left ;
		WmiAvlNode *m_Right ;
		WmiAvlNode *m_Parent ;

		WmAvlState m_State ;

		WmiElement m_Element ;

		WmiAvlNode () 
		{
			m_Left = m_Right = m_Parent = NULL ;
			m_State = e_Equal ;
		} ;
	} ;

public:

	class Iterator ;
	typedef WmiStatusCode ( * IteratorFunction ) ( void *a_Void , typename WmiAvlTree :: Iterator &a_Iterator ) ;

	class Iterator
	{
	friend WmiAvlTree <WmiKey,WmiElement>;
	private:

		WmiAvlNode *m_Node ;

		WmiAvlNode *LeftMost ( WmiAvlNode *a_Node ) 
		{
			WmiAvlNode *t_Node = a_Node ;
			if ( t_Node )
			{
				while ( t_Node->m_Left )
				{
					t_Node = t_Node->m_Left ;
				}
			}

			return t_Node ;
		}

		WmiAvlNode *RightMost ( WmiAvlNode *a_Node )
		{
			WmiAvlNode *t_Node = a_Node ;
			if ( t_Node )
			{
				while ( t_Node->m_Right )
				{
					t_Node = t_Node->m_Right ;
				}
			}

			return t_Node ;
		}

	public:

		Iterator () : m_Node ( NULL ) { ; }
		Iterator ( WmiAvlNode *a_Node ) { m_Node = a_Node ; }
		Iterator ( const Iterator &a_Iterator ) { m_Node = a_Iterator.m_Node ; }

		Iterator &Left () { m_Node = m_Node ? m_Node->m_Left : NULL ; return *this ; }
		Iterator &Right () { m_Node = m_Node ? m_Node->m_Right : NULL ; return *this ; }
		Iterator &Parent () { m_Node = m_Node ? m_Node->m_Parent : NULL ; return *this ; }

		Iterator &LeftMost () 
		{
			m_Node = LeftMost ( m_Node ) ;
			return *this ;
		}

		Iterator &RightMost () 
		{
			m_Node = RightMost ( m_Node ) ;
			return *this ;
		}

		Iterator &Decrement ()
		{
			WmiAvlNode *t_Node = m_Node ;
			if ( t_Node )
			{
				if ( t_Node->m_Left )
				{
					t_Node = RightMost ( t_Node->m_Left ) ;
				}
				else
				{
					WmiAvlNode *t_Parent  ;
					while ( ( t_Parent = t_Node->m_Parent ) && ( t_Node->m_Parent->m_Left == t_Node ) )
					{
						t_Node = t_Parent ;
					}

					t_Node = t_Parent ;
				}
			}

			m_Node = t_Node ;

			return *this ;
		}

		Iterator &Increment () 
		{
			WmiAvlNode *t_Node = m_Node ;
			if ( t_Node )
			{
				if ( t_Node->m_Right )
				{
					t_Node = LeftMost ( t_Node->m_Right ) ;
				}
				else
				{
					WmiAvlNode *t_Parent  ;
					while ( ( t_Parent = t_Node->m_Parent ) && ( t_Node->m_Parent->m_Right == t_Node ) )
					{
						t_Node = t_Parent ;
					}

					t_Node = t_Parent ;
				}
			}

			m_Node = t_Node ;

			return *this ;
		}

		bool Null () { return m_Node == NULL ; }

		WmiKey &GetKey () { return m_Node->m_Key ; }
		WmiElement &GetElement () { return m_Node->m_Element ; }

		WmiStatusCode PreOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode InOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode PostOrder ( void *a_Void , IteratorFunction a_Function ) ;
	} ;

protected:

	WmiAvlNode *m_Root ;

	ULONG m_Size ;

	WmiAllocator &m_Allocator ;

	WmiStatusCode DeleteFixup ( WmiAvlNode *a_Node , bool &a_Decreased ) ;

	WmiStatusCode RecursiveCheck ( WmiAvlNode *a_Root , ULONG &a_Count , ULONG a_Height , ULONG &a_MaxHeight ) ;

	WmiStatusCode RecursiveUnInitialize ( WmiAvlNode *a_Node ) ;

	WmiStatusCode Insert_LeftBalance ( 

		WmiAvlNode *&a_Node , 
		WmiAvlNode *a_Left , 
		bool &a_Increased
	) ;

	WmiStatusCode Insert_RightBalance ( 

		WmiAvlNode *&a_Node , 
		WmiAvlNode *a_Right , 
		bool &a_Increased
	) ;

	WmiStatusCode Delete_LeftBalance ( 

		WmiAvlNode *&a_Node , 
		WmiAvlNode *a_Left , 
		bool &a_Increased
	) ;

	WmiStatusCode Delete_RightBalance ( 

		WmiAvlNode *&a_Node , 
		WmiAvlNode *a_Right , 
		bool &a_Increased
	) ;

#if 0
	WmiStatusCode RecursiveDelete ( WmiAvlNode *a_Root , const WmiKey &a_Key , 	bool &a_Decreased ) ;

	WmiStatusCode RecursiveInsert ( WmiAvlNode *a_Root , WmiAvlNode *a_Node , bool &a_Increased ) ;
#endif

public:

	WmiAvlTree ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiAvlTree () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode Insert ( 

		const WmiKey &a_Key ,
		const WmiElement &a_Element ,
		Iterator &a_Iterator 
	) ;

	WmiStatusCode Delete ( 

		const WmiKey &a_Key
	) ;

	WmiStatusCode Find (
	
		const WmiKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode FindNext (
	
		const WmiKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode Merge (

		WmiAvlTree <WmiKey,WmiElement> &a_Tree
	) ;

	WmiStatusCode Check ( ULONG &a_MaxHeight ) ;
	
	ULONG Size () { return m_Size ; } ;

	Iterator Begin () { return Iterator ( m_Root ).LeftMost () ; };
	Iterator End () { return Iterator ( m_Root ).RightMost () ; }
	Iterator Root () { return Iterator ( m_Root ) ; }
} ;

#include <AvlTree.cpp>

#endif _AVLTREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\include\cache.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Cache.H

Abstract:


History:

--*/

#ifndef _Cache_H
#define _Cache_H

#include <Allocator.h>
#include <Algorithms.h>
#include <TPQueue.h>
#include <AvlTree.h>
#include <lockst.h>


template<typename T>
class AutoLockGuard
{
	T& m_lock;
	int m_lockCount;
public:
	AutoLockGuard(T& target);
	~AutoLockGuard();
	void Lock();
	void UnLock();
};

template<typename T>
AutoLockGuard<T>::AutoLockGuard(T& target): m_lock(target), m_lockCount(0)
{
	Lock();
}

template<typename T>
AutoLockGuard<T>::~AutoLockGuard()
{
	if (m_lockCount) UnLock();
}

template<typename T>
void AutoLockGuard<T>::Lock()
{
	_DBG_ASSERT(m_lockCount == 0);
	m_lock.Lock();
	m_lockCount++;
}

template<typename T>
void AutoLockGuard<T>::UnLock()
{
	_DBG_ASSERT(m_lockCount > 0);
	m_lock.UnLock();
	m_lockCount--;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
class WmiCacheController : public IUnknown
{
public:

	class WmiUniqueTimeout
	{
	private:

		ULONG m_Ticks ;
		LONG m_Counter ;

	public:

		WmiUniqueTimeout () : m_Ticks ( 0 ) , m_Counter ( 0 ) { ; }
		WmiUniqueTimeout (

			const ULONG &a_Ticks ,
			const LONG &a_Counter

		) : m_Ticks ( a_Ticks ) , 
			m_Counter ( a_Counter )
		{ ; }

		ULONG GetTicks () const { return m_Ticks ; }
		LONG GetCounter () const { return m_Counter ; }

		friend bool operator == ( const WmiUniqueTimeout &a_Arg1 , const WmiUniqueTimeout &a_Arg2 ) 
		{
			LONG t_Compare ;
			if ( ( t_Compare = a_Arg1.GetTicks () - a_Arg2.GetTicks () ) == 0 )
			{
				t_Compare = a_Arg1.GetCounter () - a_Arg2.GetCounter () ;
			}

			return t_Compare == 0 ? true : false ;
		}

		friend bool operator < ( const WmiUniqueTimeout &a_Arg1 , const WmiUniqueTimeout &a_Arg2 ) 
		{
			LONG t_Compare ;
			if ( ( t_Compare = a_Arg1.GetTicks () - a_Arg2.GetTicks () ) == 0 )
			{
				t_Compare = a_Arg1.GetCounter () - a_Arg2.GetCounter () ;
			}

			return t_Compare < 0 ? true : false ;
		}

	} ;

	class WmiCacheElement : public IUnknown
	{
	private:

		LONG m_ReferenceCount ;
		LONG m_InternalReferenceCount ;
		LONG m_NonCylicReferenceCount ;
		BOOL m_Decaying ;
		BOOL m_Cached ;
		BOOL m_Decayed ;
		ULONG m_CallBackInternalRelease ;

		WmiCacheController <WmiKey> *m_Controller ;
		WmiKey m_Key ;
		ULONG m_Period ;

	public:

		WmiCacheElement () :
								m_ReferenceCount ( 0 ) ,
								m_InternalReferenceCount ( 0 ) ,
								m_NonCylicReferenceCount ( 0 ) ,
								m_Controller ( NULL ) ,
								m_Period ( 0 ) ,
								m_Decaying ( FALSE ) ,
								m_Decayed ( FALSE ) ,
								m_Cached ( FALSE ) ,
								m_CallBackInternalRelease ( 1 ) 
		{
		}

		WmiCacheElement ( 

			WmiCacheController <WmiKey> *a_Controller ,
			const WmiKey &a_Key , 
			const ULONG &a_Period

		) :	m_ReferenceCount ( 0 ) ,
			m_InternalReferenceCount ( 0 ) ,
			m_NonCylicReferenceCount ( 0 ) ,
			m_Controller ( a_Controller ) ,
			m_Period ( a_Period ) ,
			m_Decaying ( FALSE ) ,
			m_Decayed ( FALSE ) ,
			m_Cached ( FALSE ) ,
			m_CallBackInternalRelease ( 1 ) 
		{
			m_Key = a_Key ;
			if ( m_Controller )
			{
				m_Controller->AddRef () ;
			}
		}

		virtual ~WmiCacheElement ()
		{
#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - ~WmiCacheElement ( %lx ) " , GetTickCount () , this ) ;
OutputDebugString ( t_Buffer ) ;
#endif
		
#ifdef DBG
			if ( m_ReferenceCount != 0 )
			{
				DebugBreak () ;
			}

			if ( m_InternalReferenceCount != 0 )
			{
				DebugBreak () ;
			}

			if ( m_NonCylicReferenceCount != 0 )
			{
				DebugBreak () ;
			}
#endif

			if ( m_Controller )
			{
				m_Controller->Release () ;
			}
		}

		virtual void CallBackRelease () {} ;
		virtual void CallBackInternalRelease () {} ;

		virtual STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) 
		{
			return E_NOINTERFACE ;
		}

		virtual STDMETHODIMP_( ULONG ) AddRef ()
		{
			if ( m_Controller ) 
			{
				m_Controller->Lock () ;
			}

			ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
			if ( t_ReferenceCount == 1 )
			{
				InternalAddRef () ;

				SetDecaying ( FALSE ) ; 
			}

			if ( m_Controller ) 
			{
				m_Controller->UnLock () ;
			}
			
			return t_ReferenceCount ;
		}

		virtual STDMETHODIMP_( ULONG ) Release ()
		{
			if ( m_Controller )
			{
				m_Controller->Lock () ;
			}

			LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				CallBackRelease () ;

				if ( m_Controller )
				{
					if ( GetCached () )
					{
						if ( GetDecayed () == FALSE )
						{
							if ( GetDecaying () == FALSE ) 
							{
								WmiStatusCode t_StatusCode = m_Controller->Decay ( *this ) ;

								if ( t_StatusCode == e_StatusCode_Success )
								{
									SetDecaying ( TRUE ) ;
								}
							}
						}

						t_ReferenceCount = UnLockedInternalRelease () ;
					}
					else
					{
						t_ReferenceCount = UnLockedInternalRelease () ;
					}
				}
				else
				{
					t_ReferenceCount = UnLockedInternalRelease () ;
				}
			}
			else 
			{
#ifdef DBG
				if ( t_ReferenceCount < 0 )
				{
					DebugBreak () ;
				}
#endif

				if ( m_Controller )
				{
					m_Controller->UnLock () ;
				}
			}

			return t_ReferenceCount ;
		}

		STDMETHODIMP_( ULONG ) InternalAddRef ()
		{
			ULONG t_ReferenceCount = InterlockedIncrement ( & m_InternalReferenceCount ) ;
			if ( t_ReferenceCount == 1 )
			{
				NonCyclicAddRef () ;
			}

			return t_ReferenceCount ;
		}

		STDMETHODIMP_( ULONG ) UnLockedInternalRelease ()
		{
			LONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				BOOL t_DoCallBack = m_CallBackInternalRelease  ;
				m_CallBackInternalRelease = 0xbabab1ac ;

				if ( GetCached () )
				{
					m_Controller->Delete ( m_Key ) ;

					SetCached ( FALSE ) ;
				}

				if ( m_Controller )
				{
					m_Controller->UnLock () ;
				}

				if ( t_DoCallBack == 1 )
				{
					CallBackInternalRelease () ;
				}
				else
				{
#ifdef DBG
					DebugBreak () ;
#endif
				}

				NonCyclicRelease () ;
			}
			else
			{
#ifdef DBG
				if ( t_ReferenceCount < 0 )
				{
					DebugBreak () ;
				}
#endif
				if ( m_Controller )
				{
					m_Controller->UnLock () ;
				}
			}

			return t_ReferenceCount ;
		}

		STDMETHODIMP_( ULONG ) InternalRelease ()
		{
			if ( m_Controller )
			{
				m_Controller->Lock () ;
			}

			LONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				BOOL t_DoCallBack = m_CallBackInternalRelease  ;
				m_CallBackInternalRelease = 0xbabab1ac ;

				BOOL t_Cached = GetCached () ;
				if ( t_Cached )
				{
					m_Controller->Delete ( m_Key ) ;
					SetCached ( FALSE ) ;
				}

				if ( m_Controller )
				{
					m_Controller->UnLock () ;
				}

				if ( t_DoCallBack == 1 )
				{
					CallBackInternalRelease () ;
				}
				else
				{
#ifdef DBG
					DebugBreak () ;
#endif
				}

				NonCyclicRelease () ;
			}
			else
			{
#ifdef DBG
				if ( t_ReferenceCount < 0 )
				{
					DebugBreak () ;
				}
#endif

				if ( m_Controller )
				{
					m_Controller->UnLock () ;
				}
			}

			return t_ReferenceCount ;
		}

		STDMETHODIMP_( ULONG ) NonCyclicAddRef ()
		{
			return InterlockedIncrement ( & m_NonCylicReferenceCount ) ;
		}

		STDMETHODIMP_( ULONG ) NonCyclicRelease ()
		{
			ULONG t_ReferenceCount = InterlockedDecrement ( & m_NonCylicReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				delete this ;
			}

			return t_ReferenceCount ;
		}

		ULONG GetPeriod ()
		{
			return m_Period ;
		}

		void SetPeriod ( const ULONG &a_Period )
		{
			m_Period = a_Period ;
		}

		WmiKey &GetKey ()
		{
			return m_Key ;
		}

		void SetKey ( const WmiKey &a_Key )
		{
			m_Key = a_Key ;
		}

		BOOL GetDecaying ()
		{
			return m_Decaying ;
		}
	
		BOOL GetDecayed () 
		{
			return m_Decayed ;
		}

		BOOL GetCached () 
		{
			return m_Cached ;
		}

		void SetDecayed ( BOOL a_Decayed )
		{	
			m_Decayed = a_Decayed ;
		}

		void SetDecaying ( BOOL a_Decay )
		{	
			m_Decaying = a_Decay ;
		}

		void SetCached ( BOOL a_Cached ) 
		{
			m_Cached = a_Cached ;
		}

		void SetController ( WmiCacheController <WmiKey> *a_Controller )
		{
			if ( m_Controller )
			{
				m_Controller->Release () ;
			}

			m_Controller = a_Controller ;
			if ( m_Controller )
			{
				m_Controller->AddRef () ;
			}
		}

		WmiCacheController <WmiKey> *GetController ()
		{
			return m_Controller ;
		}
	} ;

typedef WmiAvlTree	<WmiKey,WmiCacheElement *>	Cache ;
typedef typename Cache :: Iterator Cache_Iterator ;

private:

typedef WmiTreePriorityQueue <WmiUniqueTimeout,WmiCacheElement *> CacheDecay ;
typedef typename CacheDecay :: Iterator CacheDecay_Iterator ;

	WmiAllocator &m_Allocator ;
	CriticalSection m_CriticalSection ;

	LONG m_ReferenceCount ;

	Cache m_Cache ;
	CacheDecay m_CacheDecay ;
	LONG m_Counter ;

protected:
public:

	WmiCacheController ( WmiAllocator &a_Allocator ) ;
	virtual ~WmiCacheController () ;

	virtual STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;

	virtual STDMETHODIMP_( ULONG ) AddRef () ;

	virtual STDMETHODIMP_( ULONG ) Release () ;

	virtual WmiStatusCode Initialize () ;

	virtual WmiStatusCode UnInitialize () ;

	virtual WmiStatusCode Lock () ;

	virtual WmiStatusCode UnLock () ;

	virtual WmiStatusCode Insert (

		WmiCacheElement &a_Element , 
		Cache_Iterator &a_Iterator
	) ;

	virtual WmiStatusCode Find ( const WmiKey &a_Key , Cache_Iterator &a_Iterator ) ;

	virtual WmiStatusCode Shutdown () ;

	virtual WmiStatusCode Shutdown ( const WmiKey &a_Key ) ;

	virtual WmiStatusCode StrobeBegin ( const ULONG &a_Timeout ) ;

	virtual WmiStatusCode Strobe ( ULONG &a_NextStrobeDelta ) ;

	virtual WmiStatusCode Delete ( const WmiKey &a_Key ) ;

	virtual WmiStatusCode Decay (

		WmiCacheElement &a_Element
	) ;

	WmiStatusCode GetCache ( Cache *&a_Cache )
	{
		a_Cache = & m_Cache ;
		return e_StatusCode_Success ;
	}

	CriticalSection* GetCriticalSection ()
	{
		return &m_CriticalSection ;
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class WmiKey>
class WmiContainerController : public IUnknown
{
public:

	class WmiContainerElement : public IUnknown
	{
	private:

		LONG m_ReferenceCount ;
		LONG m_InternalReferenceCount ;
		LONG m_NonCylicReferenceCount ;
		BOOL m_Cached ;

		WmiContainerController <WmiKey> *m_Controller ;
		WmiKey m_Key ;
		ULONG m_CallBackInternalRelease ;

	public:

		WmiContainerElement () :
								m_ReferenceCount ( 0 ) ,
								m_InternalReferenceCount ( 0 ) ,
								m_NonCylicReferenceCount ( 0 ) ,
								m_Cached ( FALSE ) ,
								m_Controller ( NULL ) ,
								m_CallBackInternalRelease ( 1 )
		{
		}

		WmiContainerElement ( 

			WmiContainerController <WmiKey> *a_Controller ,
			const WmiKey &a_Key 

		) :	m_ReferenceCount ( 0 ) ,
			m_InternalReferenceCount ( 0 ) ,
			m_NonCylicReferenceCount ( 0 ) ,
			m_Cached ( FALSE ) ,
			m_Controller ( a_Controller ) ,
			m_Key ( a_Key ) ,
			m_CallBackInternalRelease ( 1 )
		{
			if ( m_Controller ) 
			{
				m_Controller->AddRef () ;
			}
		}

		virtual ~WmiContainerElement ()
		{
#ifdef DBG
			if ( m_ReferenceCount != 0 )
			{
				DebugBreak () ;
			}

			if ( m_InternalReferenceCount != 0 )
			{
				DebugBreak () ;
			}

			if ( m_NonCylicReferenceCount != 0 )
			{
				DebugBreak () ;
			}
#endif

			if ( m_Controller )
			{
				m_Controller->Release () ;
			}
		}

		virtual void CallBackRelease () {} ;
		virtual void CallBackInternalRelease () {} ;

		virtual STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) 
		{
			return E_NOINTERFACE ;
		}

		virtual STDMETHODIMP_( ULONG ) AddRef ()
		{
			ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
			if ( t_ReferenceCount == 1 )
			{
				InternalAddRef () ;
			}

			return t_ReferenceCount ;
		}

		virtual STDMETHODIMP_( ULONG ) Release ()
		{
			if ( m_Controller ) 
			{
				m_Controller->Lock () ;
			}

			LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				CallBackRelease () ;

				if ( GetCached () )
				{
					LONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
				}

				UnLockedInternalRelease () ;
			}
			else
			{
#ifdef DBG
				if ( t_ReferenceCount < 0 )
				{
					DebugBreak () ;
				}
#endif
				if ( m_Controller ) 
				{
					m_Controller->UnLock () ;
				}
			}

			return t_ReferenceCount ;
		}

		virtual STDMETHODIMP_( ULONG ) InternalAddRef ()
		{
			ULONG t_ReferenceCount = InterlockedIncrement ( & m_InternalReferenceCount ) ;
			if ( t_ReferenceCount == 1 )
			{
				NonCyclicAddRef () ;
			}

			return t_ReferenceCount ;
		}

		virtual STDMETHODIMP_( ULONG ) UnLockedInternalRelease ()
		{
			LONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				BOOL t_DoCallBack = m_CallBackInternalRelease  ;
				m_CallBackInternalRelease = 0xbabab1ac ;

				if ( m_Controller )
				{
					m_Controller->Delete ( m_Key ) ;

					m_Controller->UnLock () ;
				}

				if ( t_DoCallBack == 1 )
				{
					CallBackInternalRelease () ;
				}

				NonCyclicRelease () ;
			}
			else
			{
#ifdef DBG
				if ( t_ReferenceCount < 0 )
				{
					DebugBreak () ;
				}
#endif

				if ( m_Controller ) 
				{
					m_Controller->UnLock () ;
				}
			}

			return t_ReferenceCount ;
		}

		virtual STDMETHODIMP_( ULONG ) InternalRelease ()
		{
			if ( m_Controller ) 
			{
				m_Controller->Lock () ;
			}

			LONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				BOOL t_DoCallBack = m_CallBackInternalRelease  ;
				m_CallBackInternalRelease = 0xbabab1ac ;

				if ( m_Controller )
				{
					m_Controller->Delete ( m_Key ) ;

					m_Controller->UnLock () ;
				}

				if ( t_DoCallBack == 1 )
				{
					CallBackInternalRelease () ;
				}
				else
				{
#ifdef DBG
					DebugBreak () ;
#endif
				}

				NonCyclicRelease () ;
			}
			else
			{
#ifdef DBG
				if ( t_ReferenceCount < 0 )
				{
					DebugBreak () ;
				}
#endif

				if ( m_Controller ) 
				{
					m_Controller->UnLock () ;
				}
			}

			return t_ReferenceCount ;
		}

		virtual STDMETHODIMP_( ULONG ) NonCyclicAddRef ()
		{
			return InterlockedIncrement ( & m_NonCylicReferenceCount ) ;
		}

		virtual STDMETHODIMP_( ULONG ) NonCyclicRelease ()
		{
			ULONG t_ReferenceCount = InterlockedDecrement ( & m_NonCylicReferenceCount ) ;
			if ( t_ReferenceCount == 0 )
			{
				delete this ;
			}
			
			return t_ReferenceCount ;
		}

		BOOL GetCached () 
		{
			return m_Cached ;
		}

		void SetCached ( BOOL a_Cached ) 
		{
			m_Cached = a_Cached ;
		}

		WmiKey &GetKey ()
		{
			return m_Key ;
		}

		void SetKey ( const WmiKey &a_Key )
		{
			m_Key = a_Key ;
		}

		void SetController ( WmiContainerController <WmiKey> *a_Controller )
		{
			if ( m_Controller )
			{
				m_Controller->Release () ;
			}

			m_Controller = a_Controller ;
			if ( m_Controller )
			{
				m_Controller->AddRef () ;
			}
		}

		WmiContainerController <WmiKey> *GetController ()
		{
			return m_Controller ;
		}

	} ;

typedef WmiAvlTree	<WmiKey,WmiContainerElement *> Container ;
typedef typename Container :: Iterator Container_Iterator ;

private:

	LONG m_ReferenceCount ;

	CriticalSection m_CriticalSection ;

	Container m_Container ;

protected:
public:

	WmiContainerController ( WmiAllocator &a_Allocator ) ;
	virtual ~WmiContainerController () ;

	virtual STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;

	virtual STDMETHODIMP_( ULONG ) AddRef () ;

	virtual STDMETHODIMP_( ULONG ) Release () ;

	virtual WmiStatusCode Initialize () ;

	virtual WmiStatusCode UnInitialize () ;

	virtual WmiStatusCode Lock () ;

	virtual WmiStatusCode UnLock () ;

	virtual WmiStatusCode Insert (

		WmiContainerElement &a_Element , 
		Container_Iterator &a_Iterator
	) ;

	virtual WmiStatusCode Find ( const WmiKey &a_Key , Container_Iterator &a_Iterator ) ;

	virtual WmiStatusCode Shutdown () ;

	virtual WmiStatusCode Delete ( const WmiKey &a_Key ) ;

	virtual WmiStatusCode Strobe ( ULONG &a_NextStrobeDelta ) ;

	WmiStatusCode GetContainer ( Container *&a_Container )
	{
		a_Container = & m_Container ;
		return e_StatusCode_Success ;
	}

	CriticalSection* GetCriticalSection ()
	{
		return &m_CriticalSection ;
	}

} ;

#include <Cache.cpp>

#endif _Cache_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\include\basictree.h ===
#ifndef _BasicTree_H
#define _BasicTree_H

#include "PssException.h"
#include "Allocator.h"
#include "Algorithms.h"
#include "BasicTree.h"

template <class WmiKey,class WmiElement>
class WmiBasicTree
{
protected:

	class WmiBasicNode
	{
	public:

		WmiElement m_Element ;
		WmiKey m_Key ;

		WmiBasicNode *m_Left ;
		WmiBasicNode *m_Right ;
		WmiBasicNode *m_Parent ;

		WmiBasicNode () 
		{
			m_Left = m_Right = m_Parent = NULL ;
		} ;
	} ;

public:

	class Iterator ;
	typedef WmiStatusCode ( * IteratorFunction ) ( void *a_Void , typename WmiBasicTree :: Iterator &a_Iterator ) ;

	class Iterator
	{
	friend WmiBasicTree <WmiKey,WmiElement>;
	private:

		WmiBasicNode *m_Node ;

		WmiBasicNode *LeftMost ( WmiBasicNode *a_Node ) 
		{
			WmiBasicNode *t_Node = a_Node ;
			if ( t_Node )
			{
				while ( t_Node->m_Left )
				{
					t_Node = t_Node->m_Left ;
				}
			}

			return t_Node ;
		}

		WmiBasicNode *RightMost ( WmiBasicNode *a_Node )
		{
			WmiBasicNode *t_Node = a_Node ;
			if ( t_Node )
			{
				while ( t_Node->m_Right )
				{
					t_Node = t_Node->m_Right ;
				}
			}

			return t_Node ;
		}

	public:

		Iterator () : m_Node ( NULL ) { ; }
		Iterator ( WmiBasicNode *a_Node ) { m_Node = a_Node ; }
		Iterator ( const Iterator &a_Iterator ) { m_Node = a_Iterator.m_Node ; }

		Iterator &Left () { m_Node = m_Node ? m_Node->m_Left : NULL ; return *this ; }
		Iterator &Right () { m_Node = m_Node ? m_Node->m_Right : NULL ; return *this ; }
		Iterator &Parent () { m_Node = m_Node ? m_Node->m_Parent : NULL ; return *this ; }

		Iterator &LeftMost () 
		{
			m_Node = LeftMost ( m_Node ) ;
			return *this ;
		}

		Iterator &RightMost () 
		{
			m_Node = RightMost ( m_Node ) ;
			return *this ;
		}

		Iterator &Decrement ()
		{
			WmiBasicNode *t_Node = m_Node ;
			if ( t_Node )
			{
				if ( t_Node->m_Left )
				{
					t_Node = RightMost ( t_Node->m_Left ) ;
				}
				else
				{
					WmiBasicNode *t_Parent  ;
					while ( ( t_Parent = t_Node->m_Parent ) && ( t_Node->m_Parent->m_Left == t_Node ) )
					{
						t_Node = t_Parent ;
					}

					t_Node = t_Parent ;
				}
			}

			m_Node = t_Node ;

			return *this ;
		}

		Iterator &Increment () 
		{
			WmiBasicNode *t_Node = m_Node ;
			if ( t_Node )
			{
				if ( t_Node->m_Right )
				{
					t_Node = LeftMost ( t_Node->m_Right ) ;
				}
				else
				{
					WmiBasicNode *t_Parent  ;
					while ( ( t_Parent = t_Node->m_Parent ) && ( t_Node->m_Parent->m_Right == t_Node ) )
					{
						t_Node = t_Parent ;
					}

					t_Node = t_Parent ;
				}
			}

			m_Node = t_Node ;

			return *this ;
		}

		bool Null () { return m_Node == NULL ; }

		WmiKey &GetKey () { return m_Node->m_Key ; }
		WmiElement &GetElement () { return m_Node->m_Element ; }

		WmiStatusCode PreOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode InOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode PostOrder ( void *a_Void , IteratorFunction a_Function ) ;
	} ;

protected:

	WmiBasicNode *m_Root ;

	ULONG m_Size ;

	WmiAllocator &m_Allocator ;

	WmiStatusCode DeleteFixup ( WmiBasicNode *a_Node ) ;

	WmiStatusCode RecursiveUnInitialize ( WmiBasicNode *a_Node ) ;

public:

	WmiBasicTree ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiBasicTree () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode Insert ( 

		const WmiKey &a_Key ,
		const WmiElement &a_Element ,
		Iterator &a_Iterator 
	) ;

	WmiStatusCode Delete ( 

		const WmiKey &a_Key
	) ;

	WmiStatusCode Find (
	
		const WmiKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode FindNext (
	
		const WmiKey &a_Key ,
		Iterator &a_Iterator
	) ;

	WmiStatusCode Merge (

		WmiBasicTree <WmiKey,WmiElement> &a_Tree
	) ;
	
	ULONG Size () { return m_Size ; } ;

	Iterator Begin () { return Iterator ( m_Root ).LeftMost () ; };
	Iterator End () { return Iterator ( m_Root ).RightMost () ; }
	Iterator Root () { return Iterator ( m_Root ) ; }
} ;

#include <BasicTree.cpp>

#endif _BasicTree_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\include\logging.h ===
/* 
 *	Class:
 *
 *		WmiDebugLog
 *
 *	Description:
 *
 *		
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */



#ifndef __WMILOG_H
#define __WMILOG_H

#include <locks.h>
#if 0
#ifdef LOGGINGDEBUG_INIT
class __declspec ( dllexport ) WmiDebugLog
#else
class __declspec ( dllimport ) WmiDebugLog
#endif
#else
class WmiDebugLog
#endif
{
public:

	enum WmiDebugContext
	{
		FILE = 0 ,
		DEBUG = 1 
	} ;

private:

	CriticalSection m_CriticalSection ;

	static long s_ReferenceCount ;

	WmiAllocator &m_Allocator ;
	enum WmiDebugContext m_DebugContext ;
	BOOL m_Logging ;
	BOOL m_Verbose ;
	DWORD m_DebugLevel ;
	DWORD m_DebugFileSize;
	wchar_t *m_DebugComponent ;
	wchar_t *m_DebugFile ;
	HANDLE m_DebugFileHandle ;
	static BOOL s_Initialised ;

	static void SetEventNotification () ;

	void LoadRegistry_Logging  () ;
	void LoadRegistry_Level () ;
	void LoadRegistry_File () ;
	void LoadRegistry_FileSize () ;
	void LoadRegistry_Type () ;

	void SetRegistry_Logging  () ;
	void SetRegistry_Level () ;
	void SetRegistry_File () ;
	void SetRegistry_FileSize () ;
	void SetRegistry_Type () ;
	void SetDefaultFile () ;

	void OpenFileForOutput () ;
	void OpenOutput () ;
	void CloseOutput () ;
	void FlushOutput () ;
	void SwapFileOver () ;
	void WriteOutput ( const WCHAR *a_DebugOutput ) ;

protected:
public:

	WmiDebugLog ( WmiAllocator &a_Allocator ) ;
	virtual ~WmiDebugLog () ;

	WmiStatusCode Initialize ( const wchar_t *a_DebugComponent ) ;

	/*************************************************************************
	* There are 3 functions to write to a log file, which may be used in accordance with the following rules:
	*
	*	1. The user always knows whether he is writing to an ANSI file or a Unicode file, and he
	*		has to make sure this holds good in the rules 2, 3 and 4 below. This will be changed later to
	*		make it more flowxible to the user.
	*	2. Write() takes wchar_t arguments and the function will write and ANSI or Unicode string
	*		to the log file depending on what wchar_t maps to, in the compilation.
	*	3. WriteW() takes WCHAR arguments only, and expects that the file being written to is a Unicode file.
	*	4. WriteA() takes char arguments only, and expects that the file being written to is an ANSI file.
	*
	****************************************************************/
	void Write ( const wchar_t *a_DebugFormatString , ... ) ;
	void Write ( const wchar_t *a_File , const ULONG a_Line , const wchar_t *a_DebugFormatString , ... ) ;
	void Flush () ;

	void LoadRegistry () ;
	void SetRegistry () ;

	void SetLevel ( const DWORD &a_DebugLevel ) ;
	DWORD GetLevel () ;

	void SetContext ( const enum WmiDebugContext &a_DebugContext ) ;
	enum WmiDebugContext GetContext () ;

	void SetFile ( const wchar_t *a_File ) ;
	wchar_t *GetFile () ;

	void SetLogging ( BOOL a_Logging = TRUE ) ;
	BOOL GetLogging () ;

	void SetVerbose ( BOOL a_Verbose = TRUE ) ;
	BOOL GetVerbose () ;

	void CommitContext () ;

	static WmiDebugLog *s_WmiDebugLog ;

	static WmiStatusCode Initialize ( WmiAllocator &a_Allocator ) ;
	static WmiStatusCode UnInitialize ( WmiAllocator &a_Allocator ) ;

public:

} ;

inline DWORD WmiDebugLog :: GetLevel ()
{
	DWORD t_Level = m_DebugLevel ;
	return t_Level ;
}

inline wchar_t *WmiDebugLog :: GetFile ()
{
	wchar_t *t_File = m_DebugFile ;
	return t_File ;
}

inline BOOL WmiDebugLog :: GetLogging () 
{
	return m_Logging ;
}

inline void WmiDebugLog :: SetVerbose ( BOOL a_Verbose ) 
{
	m_Verbose = a_Verbose ;
}

inline BOOL WmiDebugLog :: GetVerbose ()
{
	return m_Verbose ;
}

#ifdef DBG

#define DebugMacro3(a) { \
\
	if ( WmiDebugLog :: s_WmiDebugLog && WmiDebugLog :: s_WmiDebugLog->GetLogging () && ( WmiDebugLog :: s_WmiDebugLog->GetVerbose () || ( WmiDebugLog :: s_WmiDebugLog->GetLevel () & 8 ) ) ) \
	{ \
		{a ; } \
	} \
} 

#else

#define DebugMacro3(a)

#endif

#endif __WMILOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\include\pssexception.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _EXCEPTIONS_H
#define _EXCEPTIONS_H

#include <eh.h>
#include <Allocator.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Wmi_Structured_Exception
{
private:

    UINT m_ExceptionCode ;
	EXCEPTION_POINTERS *m_ExceptionInformation ;

public:

    Wmi_Structured_Exception () {}

    Wmi_Structured_Exception ( 

		UINT a_ExceptionCode , 
		EXCEPTION_POINTERS *a_ExceptionInformation

	) : m_ExceptionCode ( a_ExceptionCode ) , 
		m_ExceptionInformation ( a_ExceptionInformation ) 
	{}

    ~Wmi_Structured_Exception () {}

    UINT GetExceptionCode () 
	{
		return m_ExceptionCode ;
	}

	EXCEPTION_POINTERS *GetExtendedInformation () 
	{
		return m_ExceptionInformation ;
	}
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Wmi_SetStructuredExceptionHandler
{
private:

	_se_translator_function m_PrevFunc;

public:

	static void __cdecl s_Trans_Func ( 

		UINT a_ExceptionNumber , 
		EXCEPTION_POINTERS *a_ExceptionInformation
	)
	{
		throw Wmi_Structured_Exception ( a_ExceptionNumber , a_ExceptionInformation ) ;
	}

	Wmi_SetStructuredExceptionHandler () : m_PrevFunc ( NULL )
	{
		m_PrevFunc = _set_se_translator ( s_Trans_Func ) ;
	}

	~Wmi_SetStructuredExceptionHandler ()
	{
		_set_se_translator ( m_PrevFunc ) ;
	}
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Wmi_Heap_Exception
{
public:
	
	enum HEAP_ERROR
	{
		E_ALLOCATION_ERROR = 0 ,
		E_FREE_ERROR
	};

private:

	HEAP_ERROR m_Error ;

public:

	Wmi_Heap_Exception ( HEAP_ERROR a_Error ) : m_Error ( a_Error ) {}

	~Wmi_Heap_Exception () {}

	HEAP_ERROR GetError ()
	{
		return m_Error;
	}
};


#endif // _EXCEPTIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\include\queue.h ===
#ifndef _QUEUE_H
#define _QUEUE_H

#include "PssException.h"
#include "Allocator.h"

#define QUEUE_ELEMENT_DIR_BIT_SIZE	ElementSize
#define QUEUE_ELEMENT_DIR_SIZE		1 << QUEUE_ELEMENT_DIR_BIT_SIZE 
#define QUEUE_ELEMENT_DIR_MASK		0xFFFFFFFF >> ( 32 - QUEUE_ELEMENT_DIR_BIT_SIZE )

template <class WmiElement, ULONG ElementSize >
class WmiQueue
{
private:

	class WmiElementDir 
	{
	public:

		WmiElementDir *m_Next ;

		WmiElement m_Block [ QUEUE_ELEMENT_DIR_SIZE ] ;

		WmiElementDir () { m_Next = NULL ; } ;
		~WmiElementDir () { ; } ;
	} ;

	WmiElementDir *m_Top ;
	WmiElementDir *m_Tail ;

	ULONG m_TopIndex ;
	ULONG m_TailIndex ;

	ULONG m_Size ;
	ULONG m_AllocatedSize ;

	WmiAllocator &m_Allocator ;

	WmiStatusCode UnInitialize_ElementDir ( ULONG a_Size ) ;
	WmiStatusCode Grow_ElementDir () ;
	WmiStatusCode Shrink_ElementDir () ;

public:

	WmiQueue ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiQueue () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode EnQueue ( 

		const WmiElement &a_Element
	) ;

	WmiStatusCode Top ( 

		WmiElement &a_Element
	) ;

	WmiStatusCode DeQueue () ;
	
	ULONG Size () { return m_Size ; } ;
	
} ;

#include <Queue.cpp>

#endif _QUEUE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\idl\wbemidl.h ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    WBEMIDL.H

Abstract:

  Include file for all WBEM related interface definitions. To be included
  in projects that use any WBEM interfaces.

History:

--*/

#ifndef __WBEMIDL_H_
#define __WBEMIDL_H_

#include <wbemcli.h>
#include <wbemprov.h>
#include <wbemtran.h>
#include <wbemdisp.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\include\stack.h ===
#ifndef _STACK_H
#define _STACK_H

#include "PssException.h"
#include "Allocator.h"

#define STACK_ELEMENT_DIR_BIT_SIZE	ElementSize
#define STACK_ELEMENT_DIR_SIZE		1 << STACK_ELEMENT_DIR_BIT_SIZE 
#define STACK_ELEMENT_DIR_MASK		0xFFFFFFFF >> ( 32 - STACK_ELEMENT_DIR_BIT_SIZE )

template <class WmiElement, ULONG ElementSize >
class WmiStack
{
private:

	class WmiElementDir 
	{
	public:

		WmiElementDir *m_Previous ;
		WmiElement m_Block [ STACK_ELEMENT_DIR_SIZE ] ;

		WmiElementDir () { m_Previous = NULL ; } ;
		~WmiElementDir () { ; } ;
	} ;

	WmiElementDir *m_Top ;
	ULONG m_Size ;
	ULONG m_AllocatedSize ;

	WmiAllocator &m_Allocator ;

	WmiStatusCode UnInitialize_ElementDir ( ULONG a_Size ) ;
	WmiStatusCode Grow_ElementDir () ;
	WmiStatusCode Shrink_ElementDir () ;

public:

	WmiStack ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiStack () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode Push ( 

		const WmiElement &a_Element
	) ;

	WmiStatusCode Top ( 

		WmiElement &a_Element
	) ;

	WmiStatusCode Pop () ;
	
	ULONG Size () { return m_Size + 1 ; } ;
	
} ;

#include "..\Stack.cpp"

#endif _STACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\idl\dlldata2.c ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    DLLDATA2.C

Abstract:

    Replacement for MIDL generated file

History:

--*/

/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/
//

#define PROXY_DELEGATION
#include <rpcproxy.h>
#include <strsafe.h>
#include <stdio.h>

void ReadCurrentValue(char* szGuid, char * cCurrValue)
{
    long lLen = MAX_PATH;
	char	szKey[MAX_PATH];
	StringCchPrintfA( szKey, MAX_PATH, "interface\\%s\\ProxyStubCLSID32", szGuid );
    RegQueryValue(HKEY_CLASSES_ROOT, szKey, cCurrValue, &lLen);
}

void RestoreCurrentValue(char* szGuid, char * cCurrValue)
{
	char	szKey[MAX_PATH];
	StringCchPrintfA( szKey, MAX_PATH, "interface\\%s\\ProxyStubCLSID32", szGuid );
    if(lstrlen(cCurrValue))
    {
        RegSetValue(HKEY_CLASSES_ROOT, szKey, REG_SZ, cCurrValue, lstrlen(cCurrValue));
    }
}


#define DLLDATA_ROUTINES2(pProxyFileList,pClsID )    \
    CLSID_PSFACTORYBUFFER \
    CStdPSFactoryBuffer       gPFactory = {0,0,0,0};  \
    DLLDATA_GETPROXYDLLINFO(pProxyFileList,pClsID) \
    DLLGETCLASSOBJECTROUTINE(pProxyFileList,pClsID,&gPFactory)    \
    DLLCANUNLOADNOW(&gPFactory)   \
    CSTDSTUBBUFFERRELEASE(&gPFactory)   \
    CSTDSTUBBUFFER2RELEASE(&gPFactory) \
    DLLDUMMYPURECALL    \
//    REGISTER_PROXY_DLL_ROUTINES2(pProxyFileList, pClsID) \


#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( wbemcli )
EXTERN_PROXY_FILE( wbemint )
EXTERN_PROXY_FILE( wbemprov )
EXTERN_PROXY_FILE( wbemtran )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( wbemcli ),
  REFERENCE_PROXY_FILE( wbemint ),
  REFERENCE_PROXY_FILE( wbemprov ),
  REFERENCE_PROXY_FILE( wbemtran ),
/* End of list */
PROXYFILE_LIST_END

#define IWBEMOBJECTSINK_GUID		"{7c857801-7381-11cf-884d-00aa004b2e24}"
#define	IENUMWBEMCLASSOBJECT_GUID	"{027947E1-D731-11CE-A357-000000000001}"
#define IWBEMUNBOUNDOBJECTSINK_GUID "{E246107B-B06E-11D0-AD61-00C04FD8FDFF}"
#define IWBEMMULTITARGET_GUID		"{755F9DA6-7508-11D1-AD94-00C04FD8FDFF}"
#define IWBEMSERVICES_GUID			"{9556dc99-828c-11cf-a37e-00aa003240c7}"

DLLDATA_ROUTINES2( aProxyFileList, GET_DLL_CLSID )


    HINSTANCE hProxyDll = 0; 
    
    /*DllMain saves the DLL module handle for later use by DllRegisterServer */ \
    BOOL WINAPI DLLMAIN_ENTRY( 
        HINSTANCE  hinstDLL, 
        DWORD  fdwReason, 
        LPVOID  lpvReserved) 
    { 
        if(fdwReason == DLL_PROCESS_ATTACH) 
            hProxyDll = hinstDLL; 
        return TRUE; 
    } 
    
    /* DllRegisterServer registers the interfaces contained in the proxy DLL. */ \

    HRESULT STDAPICALLTYPE DLLREGISTERSERVER_ENTRY() 
    { 
        HRESULT hRes;
        char cCurrValueSink[MAX_PATH] = {0};
        char cCurrValueEnum[MAX_PATH] = {0};
        char cCurrValueUnboundSink[MAX_PATH] = {0};
		char cCurrValueMultiTarget[MAX_PATH] = {0};
		char cCurrValueServices[MAX_PATH] = {0};
        ReadCurrentValue( IWBEMOBJECTSINK_GUID, cCurrValueSink );
        ReadCurrentValue( IENUMWBEMCLASSOBJECT_GUID, cCurrValueEnum );
        ReadCurrentValue( IWBEMUNBOUNDOBJECTSINK_GUID, cCurrValueUnboundSink );
        ReadCurrentValue( IWBEMMULTITARGET_GUID, cCurrValueMultiTarget );
        ReadCurrentValue( IWBEMSERVICES_GUID, cCurrValueServices );
        hRes = NdrDllRegisterProxy(hProxyDll, aProxyFileList, GET_DLL_CLSID); 
        RestoreCurrentValue( IWBEMOBJECTSINK_GUID, cCurrValueSink );
        RestoreCurrentValue( IENUMWBEMCLASSOBJECT_GUID, cCurrValueEnum );
        RestoreCurrentValue( IWBEMUNBOUNDOBJECTSINK_GUID, cCurrValueUnboundSink );
        RestoreCurrentValue( IWBEMMULTITARGET_GUID, cCurrValueMultiTarget );
        RestoreCurrentValue( IWBEMSERVICES_GUID, cCurrValueServices );
        return hRes;
    }  
    
    /* DllUnregisterServer unregisters the interfaces contained in the proxy DLL. */ \
    HRESULT STDAPICALLTYPE DLLUNREGISTERSERVER_ENTRY() 
    { 
        HRESULT hRes;
        char cCurrValueSink[MAX_PATH] = {0};
        char cCurrValueEnum[MAX_PATH] = {0};
        char cCurrValueUnboundSink[MAX_PATH] = {0};
		char cCurrValueMultiTarget[MAX_PATH] = {0};
		char cCurrValueServices[MAX_PATH] = {0};		
        ReadCurrentValue( IWBEMOBJECTSINK_GUID, cCurrValueSink );
        ReadCurrentValue( IENUMWBEMCLASSOBJECT_GUID, cCurrValueEnum );
        ReadCurrentValue( IWBEMUNBOUNDOBJECTSINK_GUID, cCurrValueUnboundSink );
        ReadCurrentValue( IWBEMMULTITARGET_GUID, cCurrValueMultiTarget );
        ReadCurrentValue( IWBEMSERVICES_GUID, cCurrValueServices );        
        hRes = NdrDllUnregisterProxy(hProxyDll, aProxyFileList, GET_DLL_CLSID                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ); 
        RestoreCurrentValue( IWBEMOBJECTSINK_GUID, cCurrValueSink );
        RestoreCurrentValue( IENUMWBEMCLASSOBJECT_GUID, cCurrValueEnum );
        RestoreCurrentValue( IWBEMUNBOUNDOBJECTSINK_GUID, cCurrValueUnboundSink );
        RestoreCurrentValue( IWBEMMULTITARGET_GUID, cCurrValueMultiTarget );
        RestoreCurrentValue( IWBEMSERVICES_GUID, cCurrValueServices );        
        return hRes;
    }




#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\idl\wbemdc\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\include\tpqueue.h ===
#ifndef _TPQUEUE_H
#define _TPQUEUE_H

#include "PssException.h"
#include "Allocator.h"
#include "BasicTree.h"

template <class WmiKey,class WmiElement>
class WmiTreePriorityQueue
{
private:

	WmiBasicTree <WmiKey,WmiElement> m_Tree ;

	WmiAllocator &m_Allocator ;

public:

	class Iterator ;
	typedef WmiStatusCode ( * IteratorFunction ) ( void *a_Void , typename WmiTreePriorityQueue :: Iterator &a_Iterator ) ;

friend Iterator ;
	class Iterator
	{
	private:

		typename WmiBasicTree <WmiKey,WmiElement> :: Iterator m_Iterator ;

	public:

		Iterator () { ; }
		Iterator ( typename WmiBasicTree <WmiKey,WmiElement> :: Iterator &a_Iterator ) { m_Iterator = a_Iterator ; }
		Iterator ( const Iterator &a_Iterator ) { m_Iterator = a_Iterator.m_Iterator ; }

		Iterator &Left () { m_Iterator.Left () ; return *this ; }
		Iterator &Right () { m_Iterator.Right () ; return *this ; }
		Iterator &Parent () { m_Iterator.Parent () ; return *this ; }

		Iterator &LeftMost () 
		{
			m_Iterator.LeftMost () ;
			return *this ;
		}

		Iterator &RightMost () 
		{
			m_Iterator.RightMost () ;
			return *this ;
		}

		Iterator &Decrement ()
		{
			m_Iterator.Decrement () ;
			return *this ;
		}

		Iterator &Increment () 
		{
			m_Iterator.Increment () ;
			return *this ;
		}

		bool Null () { return m_Iterator.Null () ; }

		WmiKey &GetKey () { return m_Iterator.GetKey () ; }
		WmiElement &GetElement () { return m_Iterator.GetElement () ; }

		WmiStatusCode PreOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode InOrder ( void *a_Void , IteratorFunction a_Function ) ;
		WmiStatusCode PostOrder ( void *a_Void , IteratorFunction a_Function ) ;
	} ;

public:

	WmiTreePriorityQueue ( 

		WmiAllocator &a_Allocator
	) ;

	~WmiTreePriorityQueue () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	WmiStatusCode EnQueue ( 

		const WmiKey &a_Key ,
		const WmiElement &a_Element
	) ;

	WmiStatusCode Top ( 

		WmiKey &a_Key ,
		WmiElement &a_Element
	) ;

	WmiStatusCode Top ( 

		Iterator &a_Iterator 
	) ;

	WmiStatusCode DeQueue () ;

	WmiStatusCode Delete ( 

		const WmiKey &a_Key
	) ;
	
	WmiStatusCode Merge (

		WmiTreePriorityQueue <WmiKey,WmiElement> &a_Queue
	) ;

	ULONG Size () { return m_Tree.Size () ; } ;

	Iterator Begin () { return Iterator ( m_Tree.Begin () ) ; }
	Iterator End () { return Iterator ( m_Tree.End () ) ; }
	Iterator Root () { return Iterator ( m_Tree.Root () )  ; }
	
} ;

#include <TPQueue.cpp>

#endif _TPQUEUE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\idl\wbemsvcw2k\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\containers\include\thread.h ===
#ifndef __THREAD_H
#define __THREAD_H

#include "Allocator.h"
#include "TPQueue.h"
#include "BasicTree.h"
#include <lockst.h>
/* 
 *	Forwards:
 *
 *		WmiTask
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

template <class WmiKey> class WmiTask ;
template <class WmiKey> class WmiThread ;

/* 
 *	Class:
 *
 *		WmiTask
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

template <class WmiKey> 
class WmiTask
{
friend WmiThread <WmiKey>;

public:

	enum WmiTaskEnqueueType 
	{
		e_WmiTask_Enqueue ,
		e_WmiTask_EnqueueAlertable ,
		e_WmiTask_EnqueueInterruptable 
	} ;

	enum WmiTaskState
	{
		e_WmiTask_UnInitialized ,
		e_WmiTask_Initialized ,
		e_WmiTask_EnQueued ,
		e_WmiTask_DeQueued 
	} ;

private:

	LONG m_ReferenceCount ;

	WmiAllocator &m_Allocator ;

	wchar_t *m_Name ;
	wchar_t *m_CompletionName ;

	HANDLE m_Event ;
	HANDLE m_CompletionEvent ;

	WmiStatusCode m_InitializationStatusCode ;

	WmiTaskEnqueueType m_EnqueueType ;
	WmiTaskState m_TaskState ;

private:

	void SetTaskState ( WmiTaskState a_TaskState ) { m_TaskState = a_TaskState ; }

public:

	WmiTask ( 

		WmiAllocator &a_Allocator ,
		const wchar_t *a_Name = NULL ,
		const wchar_t *a_CompletionName = NULL
	) ;

	WmiTask ( 

		WmiAllocator &a_Allocator ,
		HANDLE a_Event ,
		HANDLE a_CompletionEvent ,
		const wchar_t *a_Name = NULL ,
		const wchar_t *a_CompletionName = NULL 
	) ;

	virtual ~WmiTask () ;

	virtual ULONG STDMETHODCALLTYPE AddRef () ;

	virtual ULONG STDMETHODCALLTYPE Release () ;

	virtual WmiStatusCode Initialize () ;

	virtual WmiStatusCode UnInitialize () ;

	virtual WmiStatusCode Process ( WmiThread <WmiKey> &a_Thread ) ;

	virtual WmiStatusCode Exec () ;

	virtual WmiStatusCode Complete () ;

	virtual WmiStatusCode Wait ( const ULONG &a_Timeout = INFINITE ) ;

	virtual WmiStatusCode WaitInterruptable ( const ULONG &a_Timeout = INFINITE ) ;

	virtual WmiStatusCode WaitAlertable ( const ULONG &a_Timeout = INFINITE ) ;

	wchar_t *GetName () { return m_Name ; }
	wchar_t *GetCompletionName () { return m_CompletionName ; }

	HANDLE GetEvent () { return m_Event ; }
	HANDLE GetCompletionEvent () { return m_CompletionEvent ; }

	WmiAllocator &GetAllocator () { return m_Allocator ; } 

	WmiTaskState TaskState () { return m_TaskState ; }

	WmiTaskEnqueueType EnqueuedAs () { return m_EnqueueType ; }
	void EnqueueAs ( WmiTaskEnqueueType a_EnqueueType ) { m_EnqueueType = a_EnqueueType ; }
} ;

/* 
 *	Class:
 *
 *		WmiThread
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

template <class WmiKey>
class WmiThread
{
friend class WmiTask <WmiKey> ;
public:

	class QueueKey
	{
	public:

		WmiKey m_Key ;
		INT64 m_Tick ;

		QueueKey () { ; } ;

		QueueKey ( const INT64 &a_Tick , const WmiKey &a_Key ) :

			m_Key ( a_Key ) ,
			m_Tick ( a_Tick ) 
		{
			
		}

		~QueueKey () { ; }

		INT64 GetTick () { return m_Tick ; }
		void SetTick ( const INT64 &a_Tick ) { m_Tick = a_Tick ; }
		WmiKey &GetKey () { return m_Key ; }

		friend bool operator == ( const QueueKey &a_Arg1 , const QueueKey &a_Arg2 ) 
		{
			LONG t_Compare ;
			if ( ( t_Compare = CompareElement ( a_Arg1.m_Key , a_Arg2.m_Key ) ) == 0 )
			{
				t_Compare = CompareElement ( a_Arg1.m_Tick , a_Arg2.m_Tick ) ;
			}
			return t_Compare == 0 ? true : false ;
		}

		friend bool operator < ( const QueueKey &a_Arg1 , const QueueKey &a_Arg2 ) 
		{
			LONG t_Compare ;
			if ( ( t_Compare = CompareElement ( a_Arg1.m_Key , a_Arg2.m_Key ) ) == 0 )
			{
				t_Compare = CompareElement ( a_Arg1.m_Tick , a_Arg2.m_Tick ) ;
			}
			return t_Compare < 0 ? true : false ;
		}		
	} ;

typedef WmiBasicTree <WmiTask <WmiKey> * , WmiThread <WmiKey> *> TaskContainer ;
typedef typename TaskContainer :: Iterator TaskContainerIterator ;
typedef WmiBasicTree <ULONG , WmiThread <WmiKey> *> ThreadContainer ;
typedef typename ThreadContainer :: Iterator ThreadContainerIterator ;
typedef WmiTreePriorityQueue <QueueKey,WmiTask <WmiKey> *> QueueContainer ;
typedef typename WmiTreePriorityQueue <QueueKey,WmiTask <WmiKey> *> :: Iterator QueueContainerIterator ;

private:

	static ULONG ThreadProc ( void *a_Thread ) ;

	static ThreadContainer *s_ThreadContainer ;
	static TaskContainer *s_TaskContainer ;
	static CriticalSection s_CriticalSection ;
	static LONG s_InitializeReferenceCount ;

	INT64 m_Key;
	LONG m_ReferenceCount ;
	LONG m_InternalReferenceCount ;
	
	CriticalSection m_CriticalSection ;

	WmiStatusCode m_InitializationStatusCode ;

// Determine change in queue state.

	HANDLE m_Initialized ;

	HANDLE m_QueueChange ;
	
	HANDLE m_Terminate ;

// All allocations done via allocator

	WmiAllocator &m_Allocator ;

// Useful debug information

	wchar_t *m_Name ;
	HANDLE m_Thread ;
	ULONG m_Identifier ;

// Timeout period for internal event dispatch

	ULONG m_Timeout ;

// Stack Size

	DWORD m_StackSize ;

// All runnable tasks are placed in the queue in priority order,
// as task are executed, task can re-schedule itself, otherwise it is discarded.
// Priority is based on key compounded with insertion order ( ticks ), this implies
// tasks with same key are scheduled in FIFO order.

	 WmiTreePriorityQueue <QueueKey,WmiTask <WmiKey> *> m_TaskQueue ;

// All runnable tasks are placed in the queue in priority order,
// as task are executed, task can re-schedule itself, otherwise it is discarded.
// Priority is based on key compounded with insertion order ( ticks ), this implies
// tasks with same key are scheduled in FIFO order.

	 WmiTreePriorityQueue <QueueKey,WmiTask <WmiKey> *> m_InterruptableTaskQueue ;

// Alertable events are placed on the queue, as event is signalled they are transferred onto
// the regular queue where they are priority dispatched based on priority as inserted.

	 WmiTreePriorityQueue <QueueKey,WmiTask <WmiKey> *> m_AlertableTaskQueue ;

// a_EventCount [in] = Number of Predefined Dispatchable Events 

	static WmiStatusCode Static_Dispatch ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;

	static WmiStatusCode Static_Dispatch ( WmiTask <WmiKey> &a_Task , WmiThread <WmiKey> &a_Thread , const ULONG &a_Timeout ) ;

	WmiStatusCode Dispatch ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;

	WmiStatusCode Wait ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;


	static WmiStatusCode Static_InterruptableDispatch ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;

	static WmiStatusCode Static_InterruptableDispatch ( WmiTask <WmiKey> &a_Task , WmiThread <WmiKey> &a_Thread , const ULONG &a_Timeout ) ;

	WmiStatusCode InterruptableDispatch ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;

	WmiStatusCode InterruptableWait ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;


	WmiStatusCode Execute ( QueueContainer &a_Queue , QueueContainer &t_EnQueue ) ;

	WmiStatusCode ShuffleTask (

		const HANDLE &a_Event
	) ;

	WmiStatusCode FillHandleTable (

		HANDLE *a_HandleTable , 
		ULONG &a_Capacity
	) ;

	static WmiStatusCode Static_AlertableDispatch ( WmiTask <WmiKey> &a_Task  , const ULONG &a_Timeout ) ;

	static WmiStatusCode Static_AlertableDispatch ( WmiTask <WmiKey> &a_Task , WmiThread <WmiKey> &a_Thread , const ULONG &a_Timeout ) ;

	WmiStatusCode AlertableDispatch ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;

	WmiStatusCode AlertableWait ( WmiTask <WmiKey> &a_Task , const ULONG &a_Timeout ) ;

// Dispatch code

	WmiStatusCode ThreadDispatch () ;
	WmiStatusCode ThreadWait () ;

	WmiStatusCode CreateThread () ;

	static WmiThread *GetThread () ;

	static WmiThread *GetServicingThread ( WmiTask <WmiKey> &a_Task ) ;

	HANDLE GetTerminateHandle () ;

public:

	WmiThread ( 

		WmiAllocator &a_Allocator ,
		const wchar_t *a_Name = NULL ,
		ULONG a_Timeout = INFINITE ,
		DWORD a_StackSize = 0 
	) ;

	virtual ~WmiThread () ;

	virtual ULONG STDMETHODCALLTYPE AddRef () ;

	virtual ULONG STDMETHODCALLTYPE Release () ;

	virtual ULONG STDMETHODCALLTYPE InternalAddRef () ;

	virtual ULONG STDMETHODCALLTYPE InternalRelease () ;

	virtual WmiStatusCode Initialize_Callback () { return e_StatusCode_Success ; } ;

	virtual WmiStatusCode UnInitialize_Callback () { return e_StatusCode_Success ; } ;

	virtual void CallBackRelease () {} ;

	virtual WmiStatusCode Initialize ( const ULONG &a_Timeout = INFINITE ) ;

	virtual WmiStatusCode UnInitialize () ;

	virtual WmiStatusCode PostShutdown () ;

	virtual WmiStatusCode TimedOut () ;

// Queue a task to be executed immediately, a thread that calls a task procedure that
// executes a Wait or MsgWait will receive an indication in Queue status will not execute
// newly queued tasks.

	virtual WmiStatusCode EnQueue ( 

		const WmiKey &a_Key ,
		WmiTask <WmiKey> &a_Task
	) ;

	virtual WmiStatusCode EnQueueAlertable ( 

		const WmiKey &a_Key ,
		WmiTask <WmiKey> &a_Task
	) ;

// Queue a task to be executed immediately, a thread that calls a task procedure that
// executes a Wait or MsgWait will receive an indication of Queue status change will execute
// newly queued tasks. This is used for STA based execution where we need to interrupt the wait
// to execute a dependant request.
// 

	virtual WmiStatusCode EnQueueInterruptable ( 

		const WmiKey &a_Key ,
		WmiTask <WmiKey> &a_Task
	) ;

	virtual WmiStatusCode DeQueue ( 

		const WmiKey &a_Key ,
		WmiTask <WmiKey> &a_Task
	) ;

	virtual WmiStatusCode DeQueueAlertable ( 

		const WmiKey &a_Key ,
		WmiTask <WmiKey> &a_Task
	) ;

	virtual WmiStatusCode DeQueueInterruptable ( 

		const WmiKey &a_Key ,
		WmiTask <WmiKey> &a_Task
	) ;

	wchar_t *GetName () { return m_Name ; }
	ULONG GetIdentifier () { return m_Identifier ; }
	HANDLE GetHandle () { return m_Thread ; }
	ULONG GetTimeout () { return m_Timeout ; }
	DWORD GetStackSize () { return m_StackSize ; }

	void SetTimeout ( const ULONG &a_Timeout ) { m_Timeout = a_Timeout ; }
	void SetStackSize ( const DWORD &a_StackSize ) { m_StackSize = a_StackSize ; }

	HANDLE GetTerminationEvent () { return m_Terminate ; }
	HANDLE GetQueueChangeEvent () { return m_QueueChange ; }

	WmiAllocator &GetAllocator () { return m_Allocator ; } 

	static WmiStatusCode Static_Initialize ( WmiAllocator &a_Allocator ) ;
	static WmiStatusCode Static_UnInitialize ( WmiAllocator &a_Allocator ) ;

} ;

#include <Thread.cpp>
#include <tpwrap.h>

#endif __THREAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\idl\reposit\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\idl\wbemuuid\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\idl\wbemint\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\idl\wbemdc\sources.inc ===
############################################################################
#
#   Copyright  Microsoft Corporation.  All rights reserved.
#
############################################################################

!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

# The TARGETLIBS macro specifies additional libraries to link against your target
# image. Each library path specification should contain an asterisk (*)
# where the machine-specific subdirectory name should go.
TARGETLIBS= \
	$(WMIIDL_LIB) \
	$(SDK_LIB_PATH)\rpcrt4.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\kernel32.lib


# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(WMIIDL_SRC_INC)

# The developer defines the SOURCES macro. It contains a list of all the
# source files for this component. Specify each source file on a separate
# line using the line-continuation character. This minimizes merge
# conflicts if two developers are adding source files to the same component.

SOURCES= \
	..\wbemdc.idl \
	$(O)\wbemdc_p.c \
	$(O)\wbemdc_i.c \
	$(O)\dlldata.c \
	..\ver.rc

# Next, specify options for the compiler using C_DEFINES.
C_DEFINES=$(C_DEFINES) /DREGISTER_PROXY_DLL
MIDL_NO_ROBUST=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\newthrow\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\newthrow\newthrow.cpp ===
//***************************************************************************

//

//  NewThrow.CPP

//

//  Module: Common new/delete w/throw

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 
//
//***************************************************************************

#include <windows.h>
#include <malloc.h>
#include <provexce.h>

void* __cdecl operator new( size_t n)
{
    void *ptr = malloc( n );

    if (!ptr)
    {
        throw CHeap_Exception(CHeap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

    return ptr;
}

void* __cdecl operator new[]( size_t n)
{
    void *ptr = malloc( n );

    if (!ptr)
    {
        throw CHeap_Exception(CHeap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

    return ptr;
}

void __cdecl operator delete( void *ptr )
{
    if (ptr)
    {
        free( ptr );
    }
}

void __cdecl operator delete[]( void *ptr )
{
    if (ptr)
    {
        free( ptr );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\newthrow\newthrow.h ===
//***************************************************************************

//

//	NewThrow.H

//

//  Module: Common new/delete w/throw

//

// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 
//
//***************************************************************************

#pragma once

#include <eh.h>

void * __cdecl operator new( size_t n);
void* __cdecl operator new[]( size_t n);
void __cdecl operator delete( void *ptr );
void __cdecl operator delete[]( void *ptr );

//taken from new.h
#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
        {return (_P); }
#if     _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void *)
	{return; }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\autoptr.h ===
#ifndef __SMART_PTR_H__
#define __SMART_PTR_H__
#include <xmemory>
namespace wmilib
{
// TEMPLATE CLASS auto_ptr
template<class _Ty>
	class auto_ptr {
			// TEMPLATE CLASS auto_ptr_ref
	template<class _U>
		struct auto_ptr_ref {
		auto_ptr_ref(auto_ptr<_U>& _Y)
			: _Ref(_Y) {}
		auto_ptr<_U>& _Ref;
		};
public:
	typedef _Ty element_type;
	explicit auto_ptr(_Ty *_P = 0) _THROW0()
		: _Ptr(_P) {}
	auto_ptr(auto_ptr<_Ty>& _Y) _THROW0()
		: _Ptr(_Y.release()) {}
	auto_ptr(auto_ptr_ref<_Ty> _Y) _THROW0()
		: _Ptr(_Y._Ref.release()) {}
	template<class _U>
		operator auto_ptr<_U>() _THROW0()
		{return (auto_ptr<_U>(*this)); }
	template<class _U>
		operator auto_ptr_ref<_U>() _THROW0()
		{return (auto_ptr_ref<_U>(*this)); }
	auto_ptr<_Ty>& operator=(auto_ptr<_Ty>& _Y) _THROW0()
		{reset(_Y.release());
		return (*this); }
	~auto_ptr()
		{delete _Ptr; }
	_Ty& operator*() const _THROW0()
		{return (*get()); }
	_Ty *operator->() const _THROW0()
		{return (get()); }
	_Ty *get() const _THROW0()
		{return (_Ptr); }
	_Ty *release() _THROW0()
		{_Ty *_Tmp = _Ptr;
		_Ptr = 0;
		return (_Tmp); }
	void reset(_Ty* _P = 0)
		{if (_P != _Ptr)
			delete _Ptr;
		_Ptr = _P; }
private:
	_Ty *_Ptr;
	};

template<class _Ty>
	class auto_buffer {
			// TEMPLATE CLASS auto_ptr_ref
	template<class _U>
		struct auto_buffer_ref {
		auto_buffer_ref(auto_buffer<_U>& _Y)
			: _Ref(_Y) {}
		auto_buffer<_U>& _Ref;
		};
public:
	typedef _Ty element_type;
	explicit auto_buffer(_Ty *_P = 0, size_t val = -1) _THROW0()
		: _size(val),_Ptr(_P) {}
	auto_buffer(auto_buffer<_Ty>& _Y) _THROW0()
		: _size(_Y.size()), _Ptr(_Y.release()) {}
	auto_buffer(auto_buffer_ref<_Ty> _Y) _THROW0()
		: _size(_Y._Ref.size()),_Ptr(_Y._Ref.release()) {}
	template<class _U>
		operator auto_buffer<_U>() _THROW0()
		{return (auto_buffer<_U>(*this)); }
	template<class _U>
		operator auto_buffer_ref<_U>() _THROW0()
		{return (auto_buffer_ref<_U>(*this)); }
	auto_buffer<_Ty>& operator=(auto_buffer<_Ty>& _Y) _THROW0()
		{ size_t tmp = _Y.size();
		  reset(_Y.release());
		  size(tmp);
		return (*this); }
	~auto_buffer()
		{delete[] _Ptr; }
	_Ty& operator*() const _THROW0()
		{return (*get()); }
	_Ty& operator[](size_t index) const _THROW0()
		{return (*(get()+index));}
	_Ty *operator->() const _THROW0()
		{return (get()); }
	_Ty *get() const _THROW0()
		{return (_Ptr); }
	_Ty *release() _THROW0()
		{_Ty *_Tmp = _Ptr;
		_Ptr = 0;
		_size = -1;
		return (_Tmp); }
	void reset(_Ty* _P = 0)
		{if (_P != _Ptr){
			delete[] _Ptr;
			_size = -1;
		      }
		_Ptr = _P; }
	void size(size_t val) _THROW0()
		{ _size = val;}
	size_t size(void) _THROW0()
		{ return _size;}
private:
  	size_t _size;
	_Ty *_Ptr;
      };
};

#endif //__SMART_PTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\autobstr.h ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    autobstr.H

Author:
    dpravat

History:

--*/


#ifndef _AUTOBSTR_H_
#define _AUTOBSTR_H_

#include <algorithm>
#include <corex.h>

class auto_bstr
{
public:
  explicit auto_bstr (BSTR str = 0) ;
  auto_bstr (auto_bstr& ) ;

  ~auto_bstr();

  BSTR release();
  BSTR get() const ;
  size_t len() const { return SysStringLen (bstr_);};
  auto_bstr& operator=(auto_bstr&);

private:
  BSTR	bstr_;
};

inline
auto_bstr::auto_bstr (auto_bstr& other)
{ 
  bstr_ = other.release();
};

inline
auto_bstr::auto_bstr (BSTR str)
{
  bstr_ = str;
};

inline
auto_bstr::~auto_bstr()
{ SysFreeString (bstr_);};

inline BSTR
auto_bstr::release()
{ BSTR _tmp = bstr_;
  bstr_ = 0;
  return _tmp; };

inline BSTR
auto_bstr::get() const
{ return bstr_; };

inline 
auto_bstr& auto_bstr::operator=(auto_bstr& src)
{
  auto_bstr tmp(src); 
  std::swap(bstr_, tmp.bstr_);
  return *this;
};

inline auto_bstr clone(LPCWSTR str = NULL)
{
  BSTR bstr = SysAllocString(str);
  if (bstr == 0 && str != 0)
    throw CX_MemoryException();
  return auto_bstr (bstr);
}

#endif /*_AUTOBSTR_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\corex.h ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    COREX.H

Abstract:

    WMI Core Services Exceptions

History:

--*/

#ifndef __COREX_H_
#define __COREX_H_

class CX_Exception {};

class CX_MemoryException : public CX_Exception {};

class CX_VarVectorException : public CX_Exception {};

class CX_ContextMarshalException : public CX_Exception {};

class Logic_Error : public CX_Exception {};

class Bad_Handle : public Logic_Error {};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\cominit.h ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    COMINIT.H

Abstract:

    WMI COM helpers

History:

--*/

#ifndef _COMINIT_H_
#define _COMINIT_H_

HRESULT WINAPI InitializeCom();

#ifdef _WIN32_WINNT
HRESULT WINAPI InitializeSecurity(
			PSECURITY_DESCRIPTOR         pSecDesc,
            LONG                         cAuthSvc,
            SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
            void                        *pReserved1,
            DWORD                        dwAuthnLevel,
            DWORD                        dwImpLevel,
            void                        *pReserved2,
            DWORD                        dwCapabilities,
            void                        *pReserved3);
#endif /* _WIN32_WINNT  */

BOOL WINAPI IsDcomEnabled();
BOOL WINAPI IsKerberosAvailable(void);
DWORD WINAPI WbemWaitForSingleObject(HANDLE hHandle, DWORD dwMilli);
DWORD WINAPI WbemWaitForMultipleObjects(DWORD nCount, HANDLE* ahHandles,DWORD dwMilli);
HRESULT WINAPI WbemCoCreateInstance(REFCLSID rclsid, IUnknown* pUnkOuter, 
                            DWORD dwClsContext, REFIID riid, void** ppv);
HRESULT WINAPI WbemCoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, 
                            COSERVERINFO* pServerInfo, REFIID riid, void** ppv);
HRESULT WINAPI WbemCoGetCallContext(REFIID riid, void** ppv);

HRESULT WINAPI WbemCoQueryClientBlanket( 
            /* [out] */ DWORD __RPC_FAR *pAuthnSvc,
            /* [out] */ DWORD __RPC_FAR *pAuthzSvc,
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *pServerPrincName,
            /* [out] */ DWORD __RPC_FAR *pAuthnLevel,
            /* [out] */ DWORD __RPC_FAR *pImpLevel,
            /* [out] */ void __RPC_FAR *__RPC_FAR *pPrivs,
            /* [out] */ DWORD __RPC_FAR *pCapabilities);
HRESULT WINAPI WbemCoImpersonateClient( void);
bool WINAPI WbemIsImpersonating(void);
HRESULT WINAPI WbemCoRevertToSelf( void);
HRESULT WINAPI WbemSetProxyBlanket(
    IUnknown                 *pInterface,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    OLECHAR                  *pServerPrincName,
    DWORD                     dwAuthLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities,
	bool						fIgnoreUnk = false );

HRESULT WINAPI WbemCoSwitchCallContext( IUnknown *pNewObject, IUnknown **ppOldObject );


#ifndef _COMINIT_CPP_
#define COMINITEXTRN extern
#else
#define COMINITEXTRN
#endif
// a couple of functions we need for DCOM that will not exist when
// the OS is not DCOM enabled.
// ===============================================================

SCODE WINAPI GetAuthImp(IUnknown * pFrom, DWORD * pdwAuthLevel, DWORD * pdwImpLevel);
void GetCurrentValue(IUnknown * pFrom,DWORD & dwAuthenticationArg, DWORD & dwAuthorizationArg);

SCODE WINAPI DetermineLoginType(BSTR & AuthArg, BSTR & UserArg,
	                                               BSTR Authority,BSTR User);
SCODE WINAPI DetermineLoginTypeEx(BSTR & AuthArg, BSTR & UserArg,BSTR & PrincipalArg,
	                                                  BSTR Authority,BSTR User);

HRESULT WINAPI SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pDomain, LPWSTR pUser, LPWSTR pPassword, IUnknown * pFrom, bool bAuthArg=true);
HRESULT WINAPI SetInterfaceSecurityAuth(IUnknown * pInterface, COAUTHIDENTITY * pauthident, bool bAuthenticate = true);
HRESULT WINAPI SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pDomain, LPWSTR pUser, LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel, DWORD dwCapabilities = 0);

// Extended functions that maintain credential and principal information
HRESULT WINAPI SetInterfaceSecurityEx(IUnknown * pInterface, 
                                      LPWSTR pDomain, 
                                      LPWSTR pUser, 
                                      LPWSTR pPassword, 
                                      DWORD dwAuthLevel, 
                                      DWORD dwImpLevel, 
                                      DWORD dwCapabilities,
                                      COAUTHIDENTITY** ppAuthIdent, 
                                      BSTR* ppPrinciple, 
                                      bool GetInfoFirst = true );
HRESULT WINAPI SetInterfaceSecurityEx(IUnknown * pInterface, 
                                      COAUTHIDENTITY* pAuthIdent, 
                                      BSTR pPrincipal,
                                      DWORD dwAuthLevel, 
                                      DWORD dwImpLevel, 
                                      DWORD dwCapabilities = 0, 
                                      bool GetInfoFirst = true);

HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pUser, LPCWSTR pPassword, LPCWSTR pDomain, COAUTHIDENTITY** pAuthIdent );
HRESULT WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY* pAuthIdent );

BOOL WINAPI DoesContainCredentials( COAUTHIDENTITY* pAuthIdent );

// NOP functions
HRESULT WINAPI SetInterfaceSecurityEncrypt(IUnknown * pInterface, LPWSTR pDomain, LPWSTR pUser, LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel, DWORD dwCapabilities,
							   COAUTHIDENTITY** ppAuthIdent, BSTR* ppPrinciple, bool GetInfoFirst=false );
HRESULT WINAPI SetInterfaceSecurityDecrypt(IUnknown * pInterface, COAUTHIDENTITY* pAuthIdent, BSTR pPrincipal,
											  DWORD dwAuthLevel, DWORD dwImpLevel, 
                                              DWORD dwCapabilities = 0, bool GetInfoFirst=true);

HRESULT WINAPI EncryptCredentials( COAUTHIDENTITY* pAuthIdent );

HRESULT WINAPI DecryptCredentials( COAUTHIDENTITY* pAuthIdent );

#endif // _COMINIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\cominit.cpp ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    COMINIT.CPP

Abstract:

    WMI COM Helper functions

History:

--*/

#include "precomp.h"
#include <wbemidl.h>

#define _COMINIT_CPP_
#include "cominit.h"
#include "autobstr.h"


BOOL WINAPI DoesContainCredentials( COAUTHIDENTITY* pAuthIdentity )
{
    try
    {
        if ( NULL != pAuthIdentity && COLE_DEFAULT_AUTHINFO != pAuthIdentity)
        {
            return ( pAuthIdentity->UserLength != 0 || pAuthIdentity->PasswordLength != 0 );
        }

        return FALSE;
    }
    catch(...)
    {
        return FALSE;
    }

}

HRESULT WINAPI WbemSetProxyBlanket(
    IUnknown                 *pInterface,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    OLECHAR                  *pServerPrincName,
    DWORD                     dwAuthLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities,
    bool                        fIgnoreUnk )
{
    IUnknown * pUnk = NULL;
    IClientSecurity * pCliSec = NULL;
    HRESULT sc = pInterface->QueryInterface(IID_IUnknown, (void **) &pUnk);
    if(sc != S_OK)
        return sc;
    sc = pInterface->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
    if(sc != S_OK)
    {
        pUnk->Release();
        return sc;
    }

    /*
     * Can't set pAuthInfo if cloaking requested, as cloaking implies
     * that the current proxy identity in the impersonated thread (rather
     * than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
     * is to be used.
     * See MSDN info on CoSetProxyBlanket for more details.
     */
    if (dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING))
        pAuthInfo = NULL;

    sc = pCliSec->SetBlanket(pInterface, dwAuthnSvc, dwAuthzSvc, pServerPrincName,
        dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities);
    pCliSec->Release();
    pCliSec = NULL;

    // If we are not explicitly told to ignore the IUnknown, then we should
    // check the auth identity structure.  This performs a heuristic which
    // assumes a COAUTHIDENTITY structure.  If the structure is not one, we're
    // wrapped with a try/catch in case we AV (this should be benign since
    // we're not writing to memory).

    if ( !fIgnoreUnk && DoesContainCredentials( (COAUTHIDENTITY*) pAuthInfo ) )
    {
        sc = pUnk->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
        if(sc == S_OK)
        {
            sc = pCliSec->SetBlanket(pUnk, dwAuthnSvc, dwAuthzSvc, pServerPrincName,
                dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities);
            pCliSec->Release();
        }
        else if (sc == 0x80004002)
            sc = S_OK;
    }

    pUnk->Release();
    return sc;
}


BOOL WINAPI IsDcomEnabled()
{
    return TRUE;
}

HRESULT WINAPI InitializeCom()
{
    return CoInitializeEx(0, COINIT_MULTITHREADED);
}


HRESULT WINAPI InitializeSecurity(
            PSECURITY_DESCRIPTOR         pSecDesc,
            LONG                         cAuthSvc,
            SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
            void                        *pReserved1,
            DWORD                        dwAuthnLevel,
            DWORD                        dwImpLevel,
            void                        *pReserved2,
            DWORD                        dwCapabilities,
            void                        *pReserved3)
{
    // Initialize security
    return CoInitializeSecurity(pSecDesc,
            cAuthSvc,
            asAuthSvc,
            pReserved1,
            dwAuthnLevel,
            dwImpLevel,
            pReserved2,
            dwCapabilities,
            pReserved3);
}

DWORD WINAPI WbemWaitForMultipleObjects(DWORD nCount, HANDLE* ahHandles, DWORD dwMilli)
{
    MSG msg;
    DWORD dwRet;
    while(1)
    {
        dwRet = MsgWaitForMultipleObjects(nCount, ahHandles, FALSE, dwMilli,
                                            QS_SENDMESSAGE);
        if(dwRet == (WAIT_OBJECT_0 + nCount)) 
        {
            while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                DispatchMessage(&msg);
            }
            continue;
        }
        else
        {
            break;
        }
    }

    return dwRet;
}


DWORD WINAPI WbemWaitForSingleObject(HANDLE hHandle, DWORD dwMilli)
{
    return WbemWaitForMultipleObjects(1, &hHandle, dwMilli);
}


HRESULT WINAPI WbemCoCreateInstance(REFCLSID rclsid, IUnknown* pUnkOuter, 
                            DWORD dwClsContext, REFIID riid, void** ppv)
{
    if(!IsDcomEnabled())
    {
        dwClsContext &= ~CLSCTX_REMOTE_SERVER;
    }
    return CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv);
}

HRESULT WINAPI WbemCoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, 
                            COSERVERINFO* pServerInfo, REFIID riid, void** ppv)
{
    if(!IsDcomEnabled())
    {
        dwClsContext &= ~CLSCTX_REMOTE_SERVER;
    }
    return CoGetClassObject(rclsid, dwClsContext, pServerInfo, riid, ppv);
}

HRESULT WINAPI WbemCoGetCallContext(REFIID riid, void** ppv)
{
    return CoGetCallContext(riid, ppv);
}

HRESULT WINAPI WbemCoSwitchCallContext( IUnknown *pNewObject, IUnknown **ppOldObject )
{
    return CoSwitchCallContext(pNewObject, ppOldObject);
}
//***************************************************************************
//
//  SCODE DetermineLoginType
//
//  DESCRIPTION:
//
//  Examines the Authority and User argument and determines the authentication
//  type and possibly extracts the domain name from the user arugment in the 
//  NTLM case.  For NTLM, the domain can be at the end of the authentication
//  string, or in the front of the user name, ex;  "redmond\a-davj"
//
//  PARAMETERS:
//
//  AuthArg             Output, contains the domain name
//  UserArg             Output, user name
//  Authority           Input
//  User                Input
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE WINAPI DetermineLoginType(BSTR & AuthArg_out, BSTR & UserArg_out,
                                                      BSTR Authority,BSTR User)
{

    // Determine the connection type by examining the Authority string

    auto_bstr AuthArg(NULL);
    auto_bstr UserArg(NULL);

    if(!(Authority == NULL || wcslen(Authority) == 0 || !wbem_wcsnicmp(Authority, L"NTLMDOMAIN:",11)))
        return WBEM_E_INVALID_PARAMETER;

    // The ntlm case is more complex.  There are four cases
    // 1)  Authority = NTLMDOMAIN:name" and User = "User"
    // 2)  Authority = NULL and User = "User"
    // 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
    // 4)  Authority = NULL and User = "domain\user"

    // first step is to determine if there is a backslash in the user name somewhere between the
    // second and second to last character

    WCHAR * pSlashInUser = NULL;
    if(User)
    {
        WCHAR * pEnd = User + wcslen(User) - 1;
        for(pSlashInUser = User; pSlashInUser <= pEnd; pSlashInUser++)
            if(*pSlashInUser == L'\\')      // dont think forward slash is allowed!
                break;
        if(pSlashInUser > pEnd)
            pSlashInUser = NULL;
    }

    if(Authority && wcslen(Authority) > 11) 
    {
        if(pSlashInUser)
            return WBEM_E_INVALID_PARAMETER;

        AuthArg = auto_bstr(SysAllocString(Authority + 11));
        if (NULL == AuthArg.get()) return WBEM_E_OUT_OF_MEMORY;
        if(User) 
        { 
            UserArg = auto_bstr(SysAllocString(User));
            if (NULL == UserArg.get()) return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else if(pSlashInUser)
    {
        DWORD_PTR iDomLen = pSlashInUser-User;
        AuthArg = auto_bstr(SysAllocStringLen(User,iDomLen));
        if (NULL == AuthArg.get()) return WBEM_E_OUT_OF_MEMORY;
        if(wcslen(pSlashInUser+1))
        {
            UserArg = auto_bstr(SysAllocString(pSlashInUser+1));
            if (NULL == UserArg.get()) return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        if(User) 
        {
            UserArg = auto_bstr(SysAllocString(User));
            if (NULL == UserArg.get()) return WBEM_E_OUT_OF_MEMORY;            
        }
    }

    AuthArg_out = AuthArg.release();
    UserArg_out = UserArg.release();
        
    return S_OK;
}

//***************************************************************************
//
//  SCODE DetermineLoginTypeEx
//
//  DESCRIPTION:
//
//  Extended version that supports Kerberos.  To do so, the authority string
//  must start with Kerberos:  and the other parts be compatible with the normal
//  login.  Ie, user should be domain\user.
//
//  PARAMETERS:
//
//  AuthArg             Output, contains the domain name
//  UserArg             Output, user name
//  PrincipalArg        Output, user name
//  Authority           Input
//  User                Input
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE WINAPI DetermineLoginTypeEx(BSTR & AuthArg, BSTR & UserArg,BSTR & PrincipalArg_out,
                                                          BSTR Authority,BSTR User)
{

    // Normal case, just let existing code handle it
    PrincipalArg_out = NULL;
    if(Authority == NULL || wbem_wcsnicmp(Authority, L"KERBEROS:",9))
        return DetermineLoginType(AuthArg, UserArg, Authority, User);
        
    if(!IsKerberosAvailable())
        return WBEM_E_INVALID_PARAMETER;

    auto_bstr PrincipalArg( SysAllocString(&Authority[9]));
    if (NULL == PrincipalArg.get()) return WBEM_E_OUT_OF_MEMORY;
    SCODE sc =  DetermineLoginType(AuthArg, UserArg, NULL, User);
    if (S_OK == sc)
    {
        PrincipalArg_out = PrincipalArg.release();
    }
    return sc;
}

//***************************************************************************
//
//  bool bIsNT
//
//  DESCRIPTION:
//
//  Returns true if running windows NT.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

bool WINAPI bIsNT(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwPlatformId == VER_PLATFORM_WIN32_NT;
}

//***************************************************************************
//
//  bool IsKeberosAvailable
//
//  DESCRIPTION:
//
//  Returns true if Kerberos is available.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

BOOL WINAPI IsKerberosAvailable(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

    // IMPORTANT!! This will need to be chanted if Kerberos is ever ported to 98
    return ( os.dwPlatformId == VER_PLATFORM_WIN32_NT ) && ( os.dwMajorVersion >= 5 ) ;
}


//***************************************************************************
//
//  bool IsAuthenticated
//
//  DESCRIPTION:
//
//  This routine is used by clients in check if an interface pointer is using 
//  authentication.
//
//  PARAMETERS:
//
//  pFrom               the interface to be tested.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

bool WINAPI IsAuthenticated(IUnknown * pFrom)
{
    bool bAuthenticate = true;
    if(pFrom == NULL)
        return true;
    IClientSecurity * pFromSec = NULL;
    SCODE sc = pFrom->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);
    if(sc == S_OK)
    {
        DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCapabilities;
        sc = pFromSec->QueryBlanket(pFrom, &dwAuthnSvc, &dwAuthzSvc, 
                                            NULL,
                                            &dwAuthnLevel, &dwImpLevel,
                                            NULL, &dwCapabilities);

        if (sc == 0x800706d2 || (sc == S_OK && dwAuthnLevel == RPC_C_AUTHN_LEVEL_NONE))
            bAuthenticate = false;
        pFromSec->Release();
    }
    return bAuthenticate;
}

//***************************************************************************
//
//  SCODE GetAuthImp
//
//  DESCRIPTION:
//
//  Gets the authentication and impersonation levels for a current interface.
//
//  PARAMETERS:
//
//  pFrom               the interface to be tested.
//  pdwAuthLevel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE WINAPI GetAuthImp(IUnknown * pFrom, DWORD * pdwAuthLevel, DWORD * pdwImpLevel)
{

    if(pFrom == NULL || pdwAuthLevel == NULL || pdwImpLevel == NULL)
        return WBEM_E_INVALID_PARAMETER;

    IClientSecurity * pFromSec = NULL;
    SCODE sc = pFrom->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);
    if(sc == S_OK)
    {
        DWORD dwAuthnSvc, dwAuthzSvc, dwCapabilities;
        sc = pFromSec->QueryBlanket(pFrom, &dwAuthnSvc, &dwAuthzSvc, 
                                            NULL,
                                            pdwAuthLevel, pdwImpLevel,
                                            NULL, &dwCapabilities);

        // Special case of going to a win9x share level box

        if (sc == 0x800706d2)
        {
            *pdwAuthLevel = RPC_C_AUTHN_LEVEL_NONE;
            *pdwImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
            sc = S_OK;
        }
        pFromSec->Release();
    }
    return sc;
}


void GetCurrentValue(IUnknown * pFrom,DWORD & dwAuthnSvc, DWORD & dwAuthzSvc)
{
    if(pFrom == NULL)
        return;
    IClientSecurity * pFromSec = NULL;
    SCODE sc = pFrom->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);
    if(sc == S_OK)
    {
        sc = pFromSec->QueryBlanket(pFrom, 
                                                      &dwAuthnSvc, 
                                                      &dwAuthzSvc, 
                                                      NULL,NULL, NULL,NULL, NULL);
        pFromSec->Release();
    }
}

//***************************************************************************
//
//  SCODE SetInterfaceSecurity
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pDomain             Input, domain
//  pUser               Input, user name
//  pPassword           Input, password.
//  pFrom               Input, if not NULL, then the authentication level of this interface
//                      is used
//  bAuthArg            If pFrom is NULL, then this is the authentication level
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT WINAPI SetInterfaceSecurity(IUnknown * pInterface, 
                                                        LPWSTR pAuthority, LPWSTR pUser, LPWSTR pPassword, 
                                                        IUnknown * pFrom, bool bAuthArg /*=true*/)
{
    
    SCODE sc;
    
    if(pInterface == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Check the source pointer to determine if we are running in a non authenticated mode which
    // would be the case when connected to a Win9X box which is using share level security

    bool bAuthenticate = true;

    if(pFrom)
        bAuthenticate = IsAuthenticated(pFrom);
    else
        bAuthenticate = bAuthArg;

    // If we are doing trivial case, just pass in a null authenication structure which is used
    // if the current logged in user's credentials are OK.

    if((pAuthority == NULL || wcslen(pAuthority) < 1) && 
        (pUser == NULL || wcslen(pUser) < 1) && 
        (pPassword == NULL || wcslen(pPassword) < 1))
        return SetInterfaceSecurityAuth(pInterface, NULL, bAuthenticate);

    // If user, or Authority was passed in, the we need to create an authority argument for the login
    

    BSTR AuthArg = NULL, UserArg = NULL;
    BSTR bstrPrincipal = NULL;
    sc = DetermineLoginTypeEx(AuthArg, UserArg, bstrPrincipal, pAuthority, pUser);
    if(sc != S_OK)
        return sc;

    COAUTHIDENTITY  authident;
    memset((void *)&authident,0,sizeof(COAUTHIDENTITY));

    if(UserArg)
    {
        authident.UserLength = wcslen(UserArg);
        authident.User = (LPWSTR)UserArg;
    }
    if(AuthArg)
    {
        authident.DomainLength = wcslen(AuthArg);
        authident.Domain = (LPWSTR)AuthArg;
    }
    if(pPassword)
    {
        authident.PasswordLength = wcslen(pPassword);
        authident.Password = (LPWSTR)pPassword;
    }
    authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    sc = SetInterfaceSecurityAuth(pInterface, &authident, bAuthenticate);

    SysFreeString(UserArg);
    SysFreeString(AuthArg);
    SysFreeString(bstrPrincipal);
    return sc;
}



//***************************************************************************
//
//  SCODE SetInterfaceSecurity
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//
//  PARAMETERS:
//
//  pInterface           Interface to be set
//  pAuthority           Authentication Authority
//  pDomain             Input, domain
//  pUser                  Input, user name
//  pPassword           Input, password.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT WINAPI SetInterfaceSecurity(IUnknown * pInterface, 
                                                        LPWSTR pAuthority, LPWSTR pUser, LPWSTR pPassword, 
                                                        DWORD dwAuthLevel, DWORD dwImpLevel, DWORD dwCapabilities)
{
    
    SCODE sc;

    if(pInterface == NULL)
        return WBEM_E_INVALID_PARAMETER;

    DWORD AuthnSvc = RPC_C_AUTHN_WINNT;
    DWORD AuthzSvc = RPC_C_AUTHZ_NONE;
    GetCurrentValue(pInterface,AuthnSvc,AuthzSvc);

    // If we are doing trivial case, just pass in a null authenication structure which is used
    // if the current logged in user's credentials are OK.

    if((pAuthority == NULL || wcslen(pAuthority) < 1) && 
        (pUser == NULL || wcslen(pUser) < 1) && 
        (pPassword == NULL || wcslen(pPassword) < 1))
    {
        sc = WbemSetProxyBlanket(pInterface, 
                                                  AuthnSvc , 
                                                  RPC_C_AUTHZ_NONE, NULL,
                                                  dwAuthLevel, dwImpLevel, 
                                                  NULL,
                                                  dwCapabilities);
        return sc;
    }

    // If user, or Authority was passed in, the we need to create an authority argument for the login
    BSTR AuthArg = NULL;
    BSTR UserArg = NULL;
    BSTR PrincipalArg = NULL;
    sc = DetermineLoginTypeEx(AuthArg, UserArg, PrincipalArg, pAuthority, pUser);
    if(sc != S_OK)
        return sc;

    COAUTHIDENTITY  authident;
    memset((void *)&authident,0,sizeof(COAUTHIDENTITY));    
    if(UserArg)
    {
        authident.UserLength = wcslen(UserArg);
        authident.User = (LPWSTR)UserArg;
    }
    if(AuthArg)
    {
        authident.DomainLength = wcslen(AuthArg);
        authident.Domain = (LPWSTR)AuthArg;
    }
    if(pPassword)
    {
        authident.PasswordLength = wcslen(pPassword);
        authident.Password = (LPWSTR)pPassword;
    }
    authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    sc = WbemSetProxyBlanket(pInterface, 
        (PrincipalArg) ? RPC_C_AUTHN_GSS_KERBEROS : AuthnSvc, 
        RPC_C_AUTHZ_NONE, 
        PrincipalArg,
        dwAuthLevel, dwImpLevel, 
        ((dwAuthLevel == RPC_C_AUTHN_LEVEL_DEFAULT) || 
          (dwAuthLevel >= RPC_C_AUTHN_LEVEL_CONNECT)) ? &authident : NULL,
        dwCapabilities);

    SysFreeString(UserArg);
    SysFreeString(AuthArg);
    SysFreeString(PrincipalArg);

    return sc;
}

//***************************************************************************
//
//  SCODE SetInterfaceSecurity
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pauthident          Structure with the identity info already set.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


HRESULT WINAPI SetInterfaceSecurityAuth(IUnknown * pInterface, COAUTHIDENTITY * pauthident, bool bAuthenticate)
{
    return SetInterfaceSecurityEx(pInterface,(bAuthenticate) ? pauthident : NULL, 
                                                NULL,
                                                (bAuthenticate) ? RPC_C_AUTHN_LEVEL_DEFAULT : RPC_C_AUTHN_LEVEL_NONE,
                                                RPC_C_IMP_LEVEL_IDENTIFY, 
                                                EOAC_NONE);
}


//***************************************************************************
//
//  SCODE SetInterfaceSecurityEx
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pAuthority          Input, authority
//  pUser               Input, user name
//  pPassword           Input, password.
//  dwAuthLevel         Input, Authorization Level
//  dwImpLevel          Input, Impersonation Level
//  dwCapabilities      Input, Capability settings
//  ppAuthIdent         Output, Allocated AuthIdentity if applicable, caller must free
//                      manually (can use the FreeAuthInfo function).
//  pPrincipal          Output, Principal calculated from supplied data  Caller must
//                      free using SysFreeString.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT WINAPI SetInterfaceSecurityEx(IUnknown * pInterface, LPWSTR pAuthority, LPWSTR pUser, LPWSTR pPassword,
                               DWORD dwAuthLevel, DWORD dwImpLevel, DWORD dwCapabilities,
                               COAUTHIDENTITY** ppAuthIdent, BSTR* pPrincipal, bool GetInfoFirst)
{
    
    SCODE sc;
    DWORD dwAuthenticationArg = RPC_C_AUTHN_GSS_NEGOTIATE;
    DWORD dwAuthorizationArg = RPC_C_AUTHZ_NONE;
 
    if( pInterface == NULL || NULL == ppAuthIdent || NULL == pPrincipal )
        return WBEM_E_INVALID_PARAMETER;

    if(GetInfoFirst)
        GetCurrentValue(pInterface, dwAuthenticationArg, dwAuthorizationArg);

    // If we are doing trivial case, just pass in a null authenication structure which is used
    // if the current logged in user's credentials are OK.

    if((pAuthority == NULL || wcslen(pAuthority) < 1) && 
        (pUser == NULL || wcslen(pUser) < 1) && 
        (pPassword == NULL || wcslen(pPassword) < 1))
    {

        DWORD dwCorrectedAuth = (RPC_C_AUTHN_GSS_KERBEROS == dwAuthenticationArg)?RPC_C_AUTHN_GSS_NEGOTIATE:dwAuthenticationArg;

        sc = WbemSetProxyBlanket(pInterface, 
                                                  dwCorrectedAuth, 
                                                  dwAuthorizationArg, 
                                                  NULL,  // no principal, 
                                                  dwAuthLevel, 
                                                  dwImpLevel, 
                                                  NULL,
                                                  dwCapabilities);
        return sc;
    }

    // If user, or Authority was passed in, the we need to create an authority argument for the login
    

    BSTR AuthArg = NULL, UserArg = NULL, PrincipalArg = NULL;
    sc = DetermineLoginTypeEx(AuthArg, UserArg, PrincipalArg, pAuthority, pUser);
    if(sc != S_OK)
    {
        return sc;
    }

    // Handle an allocation failure
    COAUTHIDENTITY*  pAuthIdent = NULL;
    
    // We will only need this structure if we are not cloaking and we want at least
    // connect level authorization

    if ( !( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) )
        && ((RPC_C_AUTHN_LEVEL_DEFAULT == dwAuthLevel) || (dwAuthLevel >= RPC_C_AUTHN_LEVEL_CONNECT)) )
    {
        sc = WbemAllocAuthIdentity( UserArg, pPassword, AuthArg, &pAuthIdent );
    }

    if ( SUCCEEDED( sc ) )
    {

        DWORD dwCorrectedAuth = (PrincipalArg) ? RPC_C_AUTHN_GSS_KERBEROS : dwAuthenticationArg;
        dwCorrectedAuth = (NULL == PrincipalArg && RPC_C_AUTHN_GSS_KERBEROS == dwCorrectedAuth)?RPC_C_AUTHN_GSS_NEGOTIATE:dwCorrectedAuth;        
                
        sc = WbemSetProxyBlanket(pInterface, 
            dwCorrectedAuth, 
            dwAuthorizationArg, 
            PrincipalArg,
            dwAuthLevel, dwImpLevel, 
            pAuthIdent,
            dwCapabilities);

        // We will store relevant values as necessary
        if ( SUCCEEDED( sc ) )
        {
            *ppAuthIdent = pAuthIdent;
            *pPrincipal = PrincipalArg;
            PrincipalArg = NULL;
        }
        else
        {
            WbemFreeAuthIdentity( pAuthIdent );
        }
    }

    SysFreeString(UserArg);
    SysFreeString(AuthArg); 
    SysFreeString(PrincipalArg);
 
    return sc;
}

//***************************************************************************
//
//  SCODE SetInterfaceSecurityEx
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pAuthIdent          Input, Preset COAUTHIDENTITY structure pointer.
//  pPrincipal          Input, Preset principal argument
//  dwAuthLevel         Input, Authorization Level
//  dwImpLevel          Input, Impersonation Level
//  dwCapabilities      Input, Capability settings
//  GetInfoFirst        if true, the authentication and authorization are retrived via
//                      QueryBlanket.
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT WINAPI SetInterfaceSecurityEx(IUnknown * pInterface, COAUTHIDENTITY* pAuthIdent, BSTR pPrincipal,
                                              DWORD dwAuthLevel, DWORD dwImpLevel, 
                                              DWORD dwCapabilities, bool GetInfoFirst)
{
    DWORD dwAuthenticationArg = RPC_C_AUTHN_GSS_NEGOTIATE;
    DWORD dwAuthorizationArg = RPC_C_AUTHZ_NONE;
 
    if(pInterface == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if(GetInfoFirst)
        GetCurrentValue(pInterface, dwAuthenticationArg, dwAuthorizationArg);
    
    // The complicated values should have already been precalced.
    // Note : For auth level, we have to check for the 'RPC_C_AUTHN_LEVEL_DEFAULT' (=0) value as well,
    //        as after negotiation with the server it might result in something high that does need 
    //        the identity structure !!

    DWORD dwCorrectedAuth = (pPrincipal) ? RPC_C_AUTHN_GSS_KERBEROS : dwAuthenticationArg;
    dwCorrectedAuth = (NULL == pPrincipal && RPC_C_AUTHN_GSS_KERBEROS == dwCorrectedAuth)?RPC_C_AUTHN_GSS_NEGOTIATE:dwCorrectedAuth;
    
    return WbemSetProxyBlanket(pInterface,
                                               dwCorrectedAuth,
                                               dwAuthorizationArg,
                                               pPrincipal,
                                               dwAuthLevel,
                                               dwImpLevel, 
                                              ((dwAuthLevel == RPC_C_AUTHN_LEVEL_DEFAULT) || 
                                               (dwAuthLevel >= RPC_C_AUTHN_LEVEL_CONNECT)) ? pAuthIdent : NULL,
                                               dwCapabilities);

}

//***************************************************************************
//
//  HRESULT WbemAllocAuthIdentity
//
//  DESCRIPTION:
//
//  Walks a COAUTHIDENTITY structure and CoTaskMemAllocs the member data and the
//  structure.
//
//  PARAMETERS:
//
//  pUser       Input
//  pPassword   Input
//  pDomain     Input
//  ppAuthInfo  Output, Newly allocated structure
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pUser, LPCWSTR pPassword, LPCWSTR pDomain, 
                                                              COAUTHIDENTITY** ppAuthIdent )
{
    if ( NULL == ppAuthIdent )  return WBEM_E_INVALID_PARAMETER;

    // Handle an allocation failure
    COAUTHIDENTITY*  pAuthIdent = (COAUTHIDENTITY*) CoTaskMemAlloc( sizeof(COAUTHIDENTITY) );
    if (NULL == pAuthIdent)   return WBEM_E_OUT_OF_MEMORY;
    OnDeleteIf<PVOID,void(*)(PVOID),CoTaskMemFree> fmAuth(pAuthIdent);

    memset((void *)pAuthIdent,0,sizeof(COAUTHIDENTITY));
    
    WCHAR * pCopyUser = NULL;
    WCHAR * pCopyDomain = NULL;    
    WCHAR * pCopyPassword = NULL;        
    
    // Allocate needed memory and copy in data.  Cleanup if anything goes wrong
    if ( pUser )
    {
        size_t cchTmp = wcslen(pUser) + 1;
        pCopyUser = (WCHAR *) CoTaskMemAlloc( cchTmp * sizeof( WCHAR ) );
        if ( NULL == pCopyUser )  return WBEM_E_OUT_OF_MEMORY;

        StringCchCopyW(pCopyUser,cchTmp, pUser );
        pAuthIdent->UserLength = cchTmp -1;
    }
    OnDeleteIf<PVOID,void(*)(PVOID),CoTaskMemFree> fmUser(pCopyUser);    


    if ( pDomain )
    {
        size_t cchTmp = wcslen(pDomain) + 1;
        pCopyDomain = (WCHAR *) CoTaskMemAlloc( cchTmp * sizeof( WCHAR ) );
        if ( NULL == pCopyDomain )  return WBEM_E_OUT_OF_MEMORY;

        StringCchCopyW(pCopyDomain,cchTmp, pDomain );
        pAuthIdent->DomainLength = cchTmp -1;
    }
    OnDeleteIf<PVOID,void(*)(PVOID),CoTaskMemFree> fmDomain(pCopyDomain);    

    if ( pPassword )
    {
        size_t cchTmp = wcslen(pPassword) + 1;
        pCopyPassword = (WCHAR *) CoTaskMemAlloc( cchTmp * sizeof( WCHAR ) );
        if ( NULL == pCopyPassword )  return WBEM_E_OUT_OF_MEMORY;

        StringCchCopyW(pCopyPassword,cchTmp, pPassword );
        pAuthIdent->PasswordLength = cchTmp -1;
    }
    OnDeleteIf<PVOID,void(*)(PVOID),CoTaskMemFree> fmPassword(pCopyPassword);    

    fmUser.dismiss();
    pAuthIdent->User = pCopyUser;
    fmDomain.dismiss();
    pAuthIdent->Domain = pCopyDomain;
    fmPassword.dismiss();
    pAuthIdent->Password = pCopyPassword;
    
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    fmAuth.dismiss();
    *ppAuthIdent = pAuthIdent;
    return S_OK;
}

//***************************************************************************
//
//  HRESULT WbemFreeAuthIdentity
//
//  DESCRIPTION:
//
//  Walks a COAUTHIDENTITY structure and CoTaskMemFrees the member data and the
//  structure.
//
//  PARAMETERS:
//
//  pAuthInfo   Structure to free
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY* pAuthIdentity )
{
    if ( pAuthIdentity )
    {
        CoTaskMemFree( pAuthIdentity->Password );
        CoTaskMemFree( pAuthIdentity->Domain );
        CoTaskMemFree( pAuthIdentity->User );        
        CoTaskMemFree( pAuthIdentity );
    }

    return S_OK;
}

//***************************************************************************
//
//  HRESULT WbemCoQueryClientBlanket
//  HRESULT WbemCoImpersonateClient( void)
//  HRESULT WbemCoRevertToSelf( void)
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pauthident          Structure with the identity info already set.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT WINAPI WbemCoQueryClientBlanket( 
            /* [out] */ DWORD __RPC_FAR *pAuthnSvc,
            /* [out] */ DWORD __RPC_FAR *pAuthzSvc,
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *pServerPrincName,
            /* [out] */ DWORD __RPC_FAR *pAuthnLevel,
            /* [out] */ DWORD __RPC_FAR *pImpLevel,
            /* [out] */ void __RPC_FAR *__RPC_FAR *pPrivs,
            /* [out] */ DWORD __RPC_FAR *pCapabilities)
{
    IServerSecurity * pss = NULL;
    SCODE sc = CoGetCallContext(IID_IServerSecurity, (void**)&pss);
    if(S_OK == sc)
    {
        sc = pss->QueryBlanket(pAuthnSvc, pAuthzSvc, pServerPrincName, 
                pAuthnLevel, pImpLevel, pPrivs, pCapabilities);
        pss->Release();
    }
    return sc;

}

HRESULT WINAPI WbemCoImpersonateClient( void)
{
    IServerSecurity * pss = NULL;
    SCODE sc = CoGetCallContext(IID_IServerSecurity, (void**)&pss);
    if(S_OK == sc)
    {
        sc = pss->ImpersonateClient();    
        pss->Release();
    }
    return sc;
}

bool WINAPI WbemIsImpersonating(void)
{
    bool bRet = false;
    IServerSecurity * pss = NULL;
    SCODE sc = CoGetCallContext(IID_IServerSecurity, (void**)&pss);
    if(S_OK == sc)
    {
        bRet = (pss->IsImpersonating() == TRUE);    
        pss->Release();
    }
    return bRet;
}

HRESULT WINAPI WbemCoRevertToSelf( void)
{
    IServerSecurity * pss = NULL;
    SCODE sc = CoGetCallContext(IID_IServerSecurity, (void**)&pss);
    if(S_OK == sc)
    {
        sc = pss->RevertToSelf();    
        pss->Release();
    }
    return sc;
}

//***************************************************************************
//
//***************************************************************************
HRESULT WINAPI EncryptCredentials( COAUTHIDENTITY* pAuthIdent )
{
    // nop iplementation
    return S_OK;
}

//***************************************************************************
//
//***************************************************************************

HRESULT WINAPI DecryptCredentials( COAUTHIDENTITY* pAuthIdent )
{
    // nop iplementation
    return S_OK;
}

//***************************************************************************
//
//  SCODE SetInterfaceSecurityEncrypt
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//  The returned AuthIdentity structure will be encrypted before returning.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pAuthority          Input, authority
//  pUser               Input, user name
//  pPassword           Input, password.
//  dwAuthLevel         Input, Authorization Level
//  dwImpLevel          Input, Impersonation Level
//  dwCapabilities      Input, Capability settings
//  ppAuthIdent         Output, Allocated AuthIdentity if applicable, caller must free
//                      manually (can use the FreeAuthInfo function).
//  pPrincipal          Output, Principal calculated from supplied data  Caller must
//                      free using SysFreeString.
//  GetInfoFirst        if true, the authentication and authorization are retrived via
//                      QueryBlanket.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************
HRESULT WINAPI SetInterfaceSecurityEncrypt(IUnknown * pInterface, LPWSTR pDomain, LPWSTR pUser, LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel, DWORD dwCapabilities,
                               COAUTHIDENTITY** ppAuthIdent, BSTR* ppPrinciple, bool GetInfoFirst )
{
    //_DBG_ASSERT(FALSE);
    
    HRESULT hr = SetInterfaceSecurityEx( pInterface, pDomain, pUser, pPassword, dwAuthLevel, dwImpLevel, dwCapabilities,
                                        ppAuthIdent, ppPrinciple, GetInfoFirst );

    if ( SUCCEEDED( hr ) )
    {
        if ( NULL != ppAuthIdent )
        {
            hr = EncryptCredentials( *ppAuthIdent );
        }
    }

    return hr;
}

//***************************************************************************
//
//  SCODE SetInterfaceSecurityDecrypt
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//  It will unencrypt and reencrypt the auth identity structure in place.
//
//  PARAMETERS:
//
//  pInterface          Interface to be set
//  pAuthIdent          Input, Preset COAUTHIDENTITY structure pointer.
//  pPrincipal          Input, Preset principal argument
//  dwAuthLevel         Input, Authorization Level
//  dwImpLevel          Input, Impersonation Level
//  dwCapabilities      Input, Capability settings
//  GetInfoFirst        if true, the authentication and authorization are retrived via
//                      QueryBlanket.
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

HRESULT WINAPI SetInterfaceSecurityDecrypt(IUnknown * pInterface, COAUTHIDENTITY* pAuthIdent, BSTR pPrincipal,
                                              DWORD dwAuthLevel, DWORD dwImpLevel, 
                                              DWORD dwCapabilities, bool GetInfoFirst )
{
    //_DBG_ASSERT(FALSE);
    // Decrypt first
    HRESULT hr = DecryptCredentials( pAuthIdent );
        
    if ( SUCCEEDED( hr ) )
    {


        hr = SetInterfaceSecurityEx( pInterface, pAuthIdent, pPrincipal, dwAuthLevel, dwImpLevel,
                                        dwCapabilities, GetInfoFirst );

        hr = EncryptCredentials( pAuthIdent );

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\genlex.cpp ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    GENLEX.CPP

Abstract:

    Generic lexer framework classes.

History:

--*/

#include "precomp.h"

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0, m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
    SetLastError(m_pTokenBuf == 0 ? ERROR_NOT_ENOUGH_MEMORY : ERROR_SUCCESS);
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;

    BOOL bEOF = FALSE;

    if (m_pTokenBuf == 0)
        return 0;

    *m_pTokenBuf = 0;

    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    m_nCurBufSize += 256;
                    wchar_t * resizedBuffer = (wchar_t *) HeapReAlloc(GetProcessHeap(), 0, m_pTokenBuf,
                        m_nCurBufSize * 2);
                    if (resizedBuffer == 0)
					{
						//
						// we need to revert the size back to the 
						// original one, otherwise we may access
						// memory that doesn't belong to buffer
						//
						m_nCurBufSize -= 256 ;

                        return 0; // out of memory
					}

					m_pTokenBuf = resizedBuffer;
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;

                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\genlex.h ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    GENLEX.H

Abstract:

    Generic lexer framework classes.

History:

--*/

#ifndef _GENLEX_H_
#define _GENLEX_H_

#include <Polarity.h>

class CGenLexSource
{
public:
    virtual wchar_t NextChar() = 0;
        // Return 0 on end-of-input
    virtual void Pushback(wchar_t) = 0;
    virtual void Reset() = 0;
};

class CTextLexSource : public CGenLexSource
{
    const wchar_t *m_pSrcBuf;
    const wchar_t *m_pStart;

public:
    CTextLexSource(const wchar_t *pSrc) { SetString(pSrc); }
        // Binds directly to <pSrc> buffer, but doesn't delete it.

    wchar_t NextChar()
    {
        if (!m_pSrcBuf)
            return 0;
        else
            return *m_pSrcBuf++ ? m_pSrcBuf[-1] : 0;
    }

    void Pushback(wchar_t)
    {
        if (m_pSrcBuf)
            --m_pSrcBuf;
    }

    void Reset() { m_pSrcBuf = m_pStart; }
    void SetString (const wchar_t *pSrc) { m_pSrcBuf = m_pStart = pSrc; }
};


#pragma pack(2)
struct LexEl
{
    wchar_t cFirst, cLast;
    WORD wGotoState;
    WORD wReturnTok;
    WORD wInstructions;
};
#pragma pack()


// Lexer driver instructions

#define GLEX_ACCEPT      0x1            // Add the char to the token
#define GLEX_CONSUME     0x2            // Consume the char without adding to token
#define GLEX_PUSHBACK    0x4            // Place the char back in the source buffer for next token
#define GLEX_NOT         0x8            // A match occurs if the char is NOT the one specified
#define GLEX_LINEFEED    0x10               // Increase the source linecount
#define GLEX_RETURN      0x20               // Return the indicated token to caller
#define GLEX_ANY         wchar_t(0xFFFF)    // Any character
#define GLEX_EMPTY       wchar_t(0xFFFE)    // When subrange is not specified

class CGenLexer
{
    wchar_t    *m_pTokenBuf;
    int         m_nCurrentLine;
    int         m_nCurBufSize;
    CGenLexSource   *m_pSrc;
    LexEl           *m_pTable;
    
public:
    CGenLexer(LexEl *pTbl, CGenLexSource *pSrc);
    
   ~CGenLexer(); 
    int NextToken();
        // Returns 0 on end of input.

    wchar_t* GetTokenText() { return m_pTokenBuf; }
    int GetLineNum() { return m_nCurrentLine; }
    void Reset();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\helper.h ===
#ifndef __HELPER_H__
#define __HELPER_H__

#include <windows.h>
#include <ole2.h>
#include <comdef.h>

#ifndef LENGTH_OF
    #define LENGTH_OF(a) (sizeof(a)/sizeof(a[0]))
#endif

#ifndef _DBG_ASSERT
  #ifdef DBG
    #define _DBG_ASSERT(X) { if (!(X)) { DebugBreak(); } }
  #else
    #define _DBG_ASSERT(X)
  #endif
#endif


inline void RM(IUnknown * p){
	p->Release();
};

template <typename FT, FT F> class OnDelete0
{
public:
	OnDelete0(){};
	~OnDelete0(){ F(); };
};

template <typename FT, FT F> class OnDeleteIf0
{
private:
	bool bDismiss_;      		
public:
	OnDeleteIf0():bDismiss_(false){};
	void dismiss(bool b = true){ bDismiss_ = b; };		
	~OnDeleteIf0(){ if (!bDismiss_) F(); };
};


template <typename T, typename FT, FT F> class OnDelete 
{
private:
	T Val_;
public:
	OnDelete(T Val):Val_(Val){};
	~OnDelete(){ F(Val_); };
};

template <typename T1, typename T2, typename FT, FT F> class OnDelete2
{
private:
	T1 Val1_;
	T2 Val2_;	
public:
	OnDelete2(T1 Val1,T2 Val2):Val1_(Val1),Val2_(Val2){};
	~OnDelete2(){ F(Val1_,Val2_); };
};


template <typename T1, typename T2, typename T3, typename FT, FT F> class OnDelete3
{
private:
	T1 Val1_;
	T2 Val2_;
        T3 Val3_;
public:
	OnDelete3(T1 Val1,T2 Val2,T3 Val3):Val1_(Val1),Val2_(Val2),Val3_(Val3){};
	~OnDelete3(){ F(Val1_,Val2_,Val3_); };
};

template <typename T1, typename T2, typename T3, typename FT, FT F> class OnDeleteIf3
{
private:
	T1 Val1_;
	T2 Val2_;
        T3 Val3_;
	bool bDismiss_;        
public:
	OnDeleteIf3(T1 Val1,T2 Val2,T3 Val3):Val1_(Val1),Val2_(Val2),Val3_(Val3),bDismiss_(false){};
	void dismiss(bool b = true){ bDismiss_ = b; };	
	~OnDeleteIf3(){ if (!bDismiss_) F(Val1_,Val2_,Val3_); };
};

template <typename T1, typename T2, typename FT, FT F> class OnDeleteIf2
{
private:
	T1 Val1_;
	T2 Val2_;
	bool bDismiss_;        
public:
	OnDeleteIf2(T1 Val1,T2 Val2):Val1_(Val1),Val2_(Val2),bDismiss_(false){};
	void dismiss(bool b = true){ bDismiss_ = b; };	
	~OnDeleteIf2(){ if (!bDismiss_) F(Val1_,Val2_); };
};


template <typename T, typename FT, FT F> class OnDeleteIf 
{
private:
	T Val_;
	bool bDismiss_;
public:
	OnDeleteIf(T Val):Val_(Val),bDismiss_(false){};
	void dismiss(bool b = true){ bDismiss_ = b; };
	~OnDeleteIf(){ if (!bDismiss_) F(Val_); };
};

template <typename C, typename FT, FT F> class OnDeleteObj0
{
private:
	C * pObj_;
public:
	OnDeleteObj0(C * pObj):pObj_(pObj){};
	~OnDeleteObj0(){ (pObj_->*F)();};
};

template <typename C, typename FT, FT F> class OnDeleteObjIf0
{
private:
	C * pObj_;
    bool bDismiss_;
public:
	OnDeleteObjIf0(C * pObj):pObj_(pObj),bDismiss_(false){};
	void dismiss(bool b = true){ bDismiss_ = b; };
	~OnDeleteObjIf0(){ if (!bDismiss_) { (pObj_->*F)(); }; };
};

template <typename T, typename C, typename FT, FT F> class OnDeleteObj
{
private:
	C * pObj_;
	T Val_;
public:
	OnDeleteObj(C * pObj,T Val):pObj_(pObj),Val_(Val){};
	~OnDeleteObj(){ (pObj_->*F)(Val_);};
};

template <typename T1, typename T2, typename C, typename FT, FT F> class OnDeleteObj2
{
private:
	C * pObj_;
	T1 Val1_;
    T2 Val2_;
public:
	OnDeleteObj2(C * pObj,T1 Val1, T2 Val2):pObj_(pObj),Val1_(Val1),Val2_(Val2){};
	~OnDeleteObj2(){ (pObj_->*F)(Val1_,Val2_);};
};

template <typename T, typename C, typename FT, FT F> class OnDeleteObjIf
{
private:
	C * pObj_;
	T Val_;
    bool bDismiss_;	
public:
	OnDeleteObjIf(C * pObj,T Val):pObj_(pObj),Val_(Val),bDismiss_(false){};
	void dismiss(bool b = true){ bDismiss_ = b; };	
	~OnDeleteObjIf(){ if (!bDismiss_){ (pObj_->*F)(Val_);};};
};


#define RETURN_ON_FALSE( a ) \
{ BOOL bDoNotReuse = ( a ); if (!bDoNotReuse) return MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,GetLastError()); } 

#define RETURN_ON_ERR( a ) \
{ HRESULT hrDoNotReuse = ( a ); if (FAILED(hrDoNotReuse)) return hrDoNotReuse; } 

#define THROW_ON_ERR( a ) \
{ HRESULT hrDoNotReuse = ( a ); if (FAILED(hrDoNotReuse)) _com_issue_error(hrDoNotReuse); }

#define THROW_ON_RES( a ) \
{ LONG lResDoNotReuse = ( a ); if (ERROR_SUCCESS != lResDoNotReuse) _com_issue_error(MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,lResDoNotReuse)); }

typedef void (__stdcall  *issue_error)(HRESULT);


#endif /*_HELPER_H__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\objpath.cpp ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

  OBJPATH.CPP

Abstract:

  Object path parser.

History:

--*/

#include "precomp.h"

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

inline LPWSTR Macro_CloneLPWSTR(LPCWSTR x)
{
    if (0 == x) return 0;
    size_t cchTmp = wcslen(x) + 1;
    LPWSTR szTemp = new wchar_t[cchTmp];
    if (szTemp) memcpy(szTemp,x,cchTmp*sizeof(WCHAR));
    return szTemp;
}

bool inline CloneFailed(LPCWSTR p1, LPCWSTR p2)
{
	if (0 == p1 && 0 == p2 ) return false;
    if (p1 && p2) return false;
	return true;
}


ParsedObjectPath::ParsedObjectPath()
{
    m_pServer = 0;                  // NULL if no server
    m_dwNumNamespaces = 0;          // 0 if no namespaces

    m_dwAllocNamespaces = 2;

	m_paNamespaces = new LPWSTR[m_dwAllocNamespaces];
    if(m_paNamespaces)
		for (unsigned i = 0; i < m_dwAllocNamespaces; i++)
			m_paNamespaces[i] = 0;

    m_pClass = 0;                   // Class name
    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_bSingletonObj = FALSE;
    m_dwAllocKeys = 2;

    m_paKeys = new KeyRef *[m_dwAllocKeys];
	if (m_paKeys)
		for (unsigned i = 0; i < m_dwAllocKeys; i++)
			m_paKeys[i] = NULL;
}

ParsedObjectPath::~ParsedObjectPath()
{
    if (m_pServer)
        delete m_pServer;

    if (m_paNamespaces)
    {
        for (DWORD dwIx = 0; dwIx < m_dwNumNamespaces; dwIx++)
			if (m_paNamespaces[dwIx])
				delete m_paNamespaces[dwIx];
        delete m_paNamespaces;
    }

    if (m_pClass)
        delete m_pClass;

    if (m_paKeys)
    {
        for (DWORD dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
			if (m_paKeys[dwIx])
				delete m_paKeys[dwIx];
        delete m_paKeys;
    }
}

BOOL ParsedObjectPath::SetClassName(LPCWSTR wszClassName)
{
    if (m_pClass)
        delete [] m_pClass;

    if(wszClassName == NULL)
    {
        m_pClass = NULL;
    }
    else
    {
        m_pClass = Macro_CloneLPWSTR(wszClassName);
        if (CloneFailed(m_pClass,wszClassName))
            return FALSE;
    }

    return TRUE;
}

BOOL ParsedObjectPath::IsClass()
{
    if(!IsObject())
        return FALSE;

    return (m_dwNumKeys == 0 && !m_bSingletonObj);
}

BOOL ParsedObjectPath::IsInstance()
{
    return IsObject() && !IsClass();
}

BOOL ParsedObjectPath::IsObject()
{
    if(m_pClass == NULL)
        return FALSE;

    if(m_pServer)
    {
        return (m_dwNumNamespaces > 0);
    }
    else
    {
        return (m_dwNumNamespaces == 0);
    }
}

BOOL ParsedObjectPath::AddNamespace(LPCWSTR wszNamespace)
{
    if(m_dwNumNamespaces == m_dwAllocNamespaces)
    {
        DWORD dwNewAllocNamespaces = m_dwAllocNamespaces * 2;
        LPWSTR* paNewNamespaces = new LPWSTR[dwNewAllocNamespaces];
        if(paNewNamespaces == NULL) return FALSE;
        memcpy(paNewNamespaces, m_paNamespaces,
            sizeof(LPWSTR) * m_dwAllocNamespaces);
        delete [] m_paNamespaces;
        m_paNamespaces = paNewNamespaces;
        m_dwAllocNamespaces = dwNewAllocNamespaces;
    }
	LPWSTR p = Macro_CloneLPWSTR(wszNamespace);
	if (p)
	{
        m_paNamespaces[m_dwNumNamespaces++] = p;
        return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL ParsedObjectPath::AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue )
{
    BOOL bStatus = TRUE ;
    BOOL bFound = FALSE ;
    BOOL bUnNamed = FALSE ;

    for ( ULONG dwIndex = 0 ; dwIndex < m_dwNumKeys ; dwIndex ++ )
    {
        if ( ( m_paKeys [ dwIndex ]->m_pName ) && wszKeyName )
        {
            if ( wbem_wcsicmp ( m_paKeys [ dwIndex ]->m_pName , wszKeyName )
                                                                        == 0 )
            {
                bFound = TRUE ;
                break ;
            }
        }
        else
        {
            if ( ( ( m_paKeys [ dwIndex ]->m_pName ) == 0 ) )
            {
                bUnNamed = TRUE ;
                if ( ( wszKeyName == 0 ) )
                {
                    bFound = TRUE ;
                    break ;
                }
            }
        }
    }

    if ( ! wszKeyName )
    {
        /* Remove all existing keys */

        for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                                                            dwDeleteIndex ++ )
        {
            delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
            m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
            VariantClear ( &  ( m_paKeys [ dwDeleteIndex ]->m_vValue ) ) ;
        }

        if (S_OK == VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) , ( VARIANT * ) pvValue ))
        {
	        m_dwNumKeys = 1 ;
        }
        else
        {
            bStatus = FALSE;
        }
    }
    else
    {
        if ( bFound )
        {
            /*
             *    If key already exists then just replace the value
             */

            if ( wszKeyName )
            {
                size_t cchTmp = wcslen ( wszKeyName ) + 1;
                m_paKeys[dwIndex]->m_pName = new wchar_t [cchTmp];
                if (m_paKeys[dwIndex]->m_pName)
                {
                    StringCchCopyW(m_paKeys[dwIndex]->m_pName,cchTmp,wszKeyName);
                }
                else
                {
                    bStatus = FALSE;
                    goto error;
                }
            }

            VariantClear ( & ( m_paKeys [ dwIndex ]->m_vValue ) ) ;
            if (S_OK != VariantCopy ( & ( m_paKeys [ dwIndex ]->m_vValue ) ,
                                      ( VARIANT * ) pvValue ))
            {
                bStatus = FALSE;
            }
        }
        else
        {
            if ( bUnNamed )
            {
                /* Add an un named key */

                for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                        dwDeleteIndex ++ )
                {
                    delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
                    m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
                    VariantClear (& ( m_paKeys [ dwDeleteIndex ]->m_vValue ) );
                }

                size_t cchTmp = wcslen ( wszKeyName ) + 1;
                m_paKeys[0]->m_pName = new wchar_t[cchTmp];
                if (m_paKeys[0]->m_pName)
                {
	                StringCchCopyW(m_paKeys [0]->m_pName,cchTmp, wszKeyName ) ;

	                if (S_OK == VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) ,
        	                    ( VARIANT * ) pvValue ))
        	        {
		                m_dwNumKeys = 1;
	                }
	                else
	                {
	                    bStatus = FALSE;
	                }
                }
                else
                {
                    bStatus = FALSE;
                }
            }
            else
            {
                /* Add a Named Key */

                bStatus = AddKeyRef(wszKeyName, pvValue);
            }
        }
    }
error:
    return bStatus;
}

void ParsedObjectPath::ClearKeys ()
{
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
            dwDeleteIndex ++ )
    {
        delete m_paKeys [ dwDeleteIndex ] ;
        m_paKeys [ dwDeleteIndex ] = NULL ;
    }

    delete [] m_paKeys ;
    m_paKeys = NULL ;

    m_dwNumKeys = 0;                // 0 if no keys (just a class name)

    m_paKeys = new KeyRef *[2];
    if (m_paKeys)
        m_dwAllocKeys = 2;
}

BOOL ParsedObjectPath::AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        if (!paNewKeys)
            return FALSE;

        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

	if(m_paKeys == NULL)
		return FALSE;
    m_paKeys[m_dwNumKeys] = new KeyRef(wszKeyName, pvValue);
    if (!m_paKeys[m_dwNumKeys] || !m_paKeys[m_dwNumKeys]->IsValid())
        return FALSE;

    m_dwNumKeys++;
    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRef(KeyRef* pAcquireRef)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        if(paNewKeys == NULL)return FALSE;
        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }
    m_paKeys[m_dwNumKeys] = pAcquireRef;
    m_dwNumKeys++;
    return TRUE;
}

KeyRef::KeyRef()
{
    m_pName = 0;
    VariantInit(&m_vValue);
    m_hRes = S_OK;
}

KeyRef::KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    m_pName = Macro_CloneLPWSTR(wszKeyName);
    VariantInit(&m_vValue);
    m_hRes = VariantCopy(&m_vValue, (VARIANT*)pvValue);
}

KeyRef::~KeyRef()
{
    delete m_pName;
    VariantClear(&m_vValue);
}




int WINAPI CObjectPathParser::Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath)
{
    if(pInput->m_pClass == NULL)
    {
        return CObjectPathParser::InvalidParameter;
    }

    // Allocate enough space
    // =====================

    int nSpace = wcslen(pInput->m_pClass);
    nSpace += 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];
        if(pKey->m_pName)
            nSpace += wcslen(pKey->m_pName);
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(    V_VT(&pKey->m_vValue) == VT_I4
                ||  V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            nSpace += 30;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I2
                ||  V_VT(&pKey->m_vValue) == VT_UI2 )

        {
            nSpace += 15;
        }
        else if (   V_VT(&pKey->m_vValue) == VT_I1
                ||  V_VT(&pKey->m_vValue) == VT_UI1 )

        {
            nSpace += 8;
        }
    }
    if(pInput->m_bSingletonObj)
        nSpace +=2;

    WCHAR wszTemp[30];
    LPWSTR wszPath = new WCHAR[nSpace];

    if (!wszPath)
        return OutOfMemory;

    StringCchCopyW(wszPath,nSpace, pInput->m_pClass);


    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];

        // We dont want to put a '.' if there isnt a key name,
        // for example, Myclass="value"
        if(dwIx == 0)
        {
            if((pKey->m_pName && (0 < wcslen(pKey->m_pName))) || pInput->m_dwNumKeys > 1)
                StringCchCatW(wszPath,nSpace, L".");
        }
        else
        {
            StringCchCatW(wszPath,nSpace, L",");
        }
        if(pKey->m_pName)
            StringCchCatW(wszPath,nSpace, pKey->m_pName);
        StringCchCatW(wszPath,nSpace, L"=");

        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            StringCchCatW(wszPath,nSpace, L"\"");
            WCHAR* pwc = V_BSTR(&pKey->m_vValue);
            WCHAR str[2];
            str[1] = 0;
            while(*pwc)
            {
                if(*pwc == '\\' || *pwc == '"')
                {
                    StringCchCatW(wszPath,nSpace, L"\\");
                }
                str[0] = *pwc;
                StringCchCatW(wszPath,nSpace, str);
                pwc++;
            }

            StringCchCatW(wszPath,nSpace, L"\"");
        }
        else if( V_VT(&pKey->m_vValue) == VT_I4 )
        {
            StringCchPrintfW(wszTemp,LENGTH_OF(wszTemp), L"%d", V_I4(&pKey->m_vValue));
            StringCchCatW(wszPath,nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            StringCchPrintfW(wszTemp,LENGTH_OF(wszTemp), L"%u", V_UI4(&pKey->m_vValue));
            StringCchCatW(wszPath,nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I2 )
        {
            StringCchPrintfW(wszTemp,LENGTH_OF(wszTemp), L"%hd", V_I2(&pKey->m_vValue));
            StringCchCatW(wszPath,nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI2 )
        {
            StringCchPrintfW(wszTemp,LENGTH_OF(wszTemp), L"%hu", V_UI2(&pKey->m_vValue));
            StringCchCatW(wszPath,nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I1 )
        {
            StringCchPrintfW(wszTemp,LENGTH_OF(wszTemp), L"%d", V_I1(&pKey->m_vValue));
            StringCchCatW(wszPath,nSpace, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI1 )
        {
            StringCchPrintfW(wszTemp,LENGTH_OF(wszTemp), L"%u", V_UI1(&pKey->m_vValue));
            StringCchCatW(wszPath,nSpace, wszTemp);
        }
    }

    // Take care of the singleton case.  This is a path of the form
    // MyClass=@  and represents a single instance of a class with no
    // keys.

    if(pInput->m_bSingletonObj && pInput->m_dwNumKeys == 0)
        StringCchCatW(wszPath,nSpace, L"=@");


    *pwszPath = wszPath;

    return NoError;
}


LPWSTR WINAPI CObjectPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    LPWSTR wsz = wcschr(wszFullPath, L':');
    if(wsz)
        return wsz + 1;
    else
        return NULL;
}





void CObjectPathParser::Zero()
{
    m_nCurrentToken = 0;
    m_pLexer = 0;
    m_pInitialIdent = 0;
    m_pOutput = 0;
    m_pTmpKeyRef = 0;
}

CObjectPathParser::CObjectPathParser(ObjectParserFlags eFlags)
    : m_eFlags(eFlags)
{
    Zero();
}

void CObjectPathParser::Empty()
{
    delete m_pLexer;
    delete m_pInitialIdent;
    delete m_pTmpKeyRef;
    // m_pOutput is intentionally left alone,
    // since all code paths delete this already on error, or
    // else the user acquired the pointer.
}

CObjectPathParser::~CObjectPathParser()
{
    Empty();
}

int CObjectPathParser::Parse(
    LPCWSTR pRawPath,
    ParsedObjectPath **pOutput
    )
{
    if (pOutput == 0 || pRawPath == 0 || wcslen(pRawPath) == 0)
        return CObjectPathParser::InvalidParameter;

    // Check for leading / trailing ws.
    // ================================

    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0]))
        return InvalidParameter;

     // These are required for multiple calls to Parse().
    // ==================================================
    Empty();
    Zero();

    // Set default return to NULL initially until we have some output.
    // ===============================================================
    *pOutput = 0;

    m_pOutput = new ParsedObjectPath;
    if (!m_pOutput) 
        return OutOfMemory;
	if (!m_pOutput->IsValid())
	{
		delete m_pOutput;
		m_pOutput = NULL;

		return OutOfMemory;
	}

    // Parse the server name (if there is one) manually
    // ================================================

    if ( (pRawPath[0] == '\\' && pRawPath[1] == '\\') ||
         (pRawPath[0] == '/' && pRawPath[1] == '/'))
    {
        const WCHAR* pwcStart = pRawPath + 2;

        // Find the next backslash --- it's the end of the server name
        // ===========================================================

        const WCHAR* pwcEnd = pwcStart;
        while (*pwcEnd != L'\0' && *pwcEnd != L'\\' && *pwcEnd != L'/')
        {
            pwcEnd++;
        }

        if (*pwcEnd == L'\0')
        {
            // If we have already exhausted the object path string,
            // a lone server name was all there was.
            // ====================================================

            if (m_eFlags != e_ParserAcceptAll)
            {
                delete m_pOutput;
                return SyntaxError;
            }
            else    // A lone server name is legal.
            {
                size_t cchTmp = wcslen(pwcStart)+1;
                m_pOutput->m_pServer = new WCHAR[cchTmp];

                if (!m_pOutput->m_pServer)
                {
                    delete m_pOutput;
                    return OutOfMemory;
                }

                StringCchCopyW(m_pOutput->m_pServer,cchTmp, pwcStart);

                *pOutput = m_pOutput;
                m_pOutput = 0;

                return NoError;
            }
        }

        if (pwcEnd == pwcStart)
        {
            // No name at all.
            // ===============
            delete m_pOutput;
            return SyntaxError;
        }

        m_pOutput->m_pServer = new WCHAR[pwcEnd-pwcStart+1];
        if (!m_pOutput->m_pServer)
        {
            delete m_pOutput;
            return OutOfMemory;
        }

        wcsncpy(m_pOutput->m_pServer, pwcStart, pwcEnd-pwcStart);
        m_pOutput->m_pServer[pwcEnd-pwcStart] = 0;

        pRawPath = pwcEnd;
    }

    // Point the lexer at the source.
    // ==============================

    CTextLexSource src(pRawPath);
    m_pLexer = new CGenLexer(OPath_LexTable, &src);
    if (!m_pLexer)
    {
        delete m_pOutput;
        return OutOfMemory;
    }

    // Go.
    // ===

    int nRes = begin_parse();
    if (nRes)
    {
        delete m_pOutput;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EOF)
    {
        delete m_pOutput;
        return SyntaxError;
    }

    if (m_pOutput->m_dwNumNamespaces > 0 && m_pOutput->m_pServer == NULL)
    {
        if (m_eFlags != e_ParserAcceptRelativeNamespace && m_eFlags != e_ParserAcceptAll)
        {
            delete m_pOutput;
            return SyntaxError;
        }
        else
        {
            // Local namespace --- set server to "."
            // =====================================
            m_pOutput->m_pServer = new WCHAR[2];
            if (!m_pOutput->m_pServer)
            {
                delete m_pOutput;
                return OutOfMemory;
            }

            StringCchCopyW(m_pOutput->m_pServer,2, L".");
        }
    }

    // Sort the key refs lexically. If there is only
    // one key, there is nothing to sort anyway.
    // =============================================

    if (m_pOutput->m_dwNumKeys > 1)
    {
        BOOL bChanges = TRUE;
        while (bChanges)
        {
            bChanges = FALSE;
            for (DWORD dwIx = 0; dwIx < m_pOutput->m_dwNumKeys - 1; dwIx++)
            {
                if (wbem_wcsicmp(m_pOutput->m_paKeys[dwIx]->m_pName,
                    m_pOutput->m_paKeys[dwIx+1]->m_pName) > 0)
                {
                    KeyRef *pTmp = m_pOutput->m_paKeys[dwIx];
                    m_pOutput->m_paKeys[dwIx] = m_pOutput->m_paKeys[dwIx + 1];
                    m_pOutput->m_paKeys[dwIx + 1] = pTmp;
                    bChanges = TRUE;
                }
            }
        }
    }


    // Add in key refs.
    // ================
    *pOutput = m_pOutput;
    m_pOutput = 0;
    return NoError;
}

BOOL CObjectPathParser::NextToken()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == OPATH_TOK_ERROR)
        return FALSE;
    return TRUE;
}


void CObjectPathParser::Free(ParsedObjectPath *pOutput)
{
    delete pOutput;
}

void CObjectPathParser::Free( LPWSTR wszUnparsedPath )
{
    delete wszUnparsedPath;
}

//
//  <Parse> ::= BACKSLASH <ns_or_server>;
//  <Parse> ::= IDENT <ns_or_class>;
//  <Parse> ::= COLON <objref>;
//
int CObjectPathParser::begin_parse()
{
    if (!NextToken())
        return SyntaxError;

    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_or_server();
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pInitialIdent = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
        if (CloneFailed(m_pInitialIdent,m_pLexer->GetTokenText()))
            return OutOfMemory;
        if (!NextToken())
            return SyntaxError;

        // Copy the token and put it in a temporary holding place
        // until we figure out whether it is a namespace or a class name.
        // ==============================================================

        return ns_or_class();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // If here, we had a bad starter token.
    // ====================================

    return SyntaxError;
}

//
//  <ns_or_server> ::= BACKSLASH <dot_or_ident> BACKSLASH <ns_list> <optional_objref>;
//  <ns_or_server> ::= <ns_list> <optional_objref>;
//
//  <dot_or_ident> is embedded.
//
int CObjectPathParser::ns_or_server()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        // Actually, server names have been take care of, so this is a failure
        // ===================================================================

        return SyntaxError;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        int nRes = ns_list();
        if (nRes)
            return nRes;
        return optional_objref();
    }
    else
        if (m_nCurrentToken == OPATH_TOK_EOF)
            return NoError;

    return SyntaxError;
}

//
//  <optional_objref> ::= COLON <objref>;
//  <optional_objref> ::= <>;
//
int CObjectPathParser::optional_objref()
{
    if (m_nCurrentToken == OPATH_TOK_EOF)
        return NoError;

    if (m_nCurrentToken != OPATH_TOK_COLON)
        return SyntaxError;
    if (!NextToken())
        return SyntaxError;
    return objref();
}


//
//  <ns_or_class> ::= COLON <ident_becomes_ns> <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list> COLON <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list>;
//
int CObjectPathParser::ns_or_class()
{
    if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        return objref();
    }
    else if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        int nRes = ns_list();
        if (nRes)
            return nRes;
        if (m_nCurrentToken == OPATH_TOK_EOF)    // ns only
            return NoError;

        if (m_nCurrentToken != OPATH_TOK_COLON)
            return SyntaxError;
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // Else
    // ====
    ident_becomes_class();
    return objref_rest();
}

//
//  <objref> ::= IDENT <objref_rest>;  // IDENT is classname
//
int CObjectPathParser::objref()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
    if (CloneFailed(m_pOutput->m_pClass,m_pLexer->GetTokenText()))
        return OutOfMemory;

    if (!NextToken())
        return SyntaxError;

    return objref_rest();
}

//
// <ns_list> ::= IDENT <ns_list_rest>;
//
int CObjectPathParser::ns_list()
{
    if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pOutput->AddNamespace(m_pLexer->GetTokenText());

        if (!NextToken())
            return SyntaxError;
        return ns_list_rest();
    }

    return SyntaxError;
}

//
//  <ident_becomes_ns> ::= <>;      // <initial_ident> becomes a namespace
//
int CObjectPathParser::ident_becomes_ns()
{
    m_pOutput->AddNamespace(m_pInitialIdent);

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <ident_becomes_class> ::= <>;   // <initial_ident> becomes the class
//
int CObjectPathParser::ident_becomes_class()
{
    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pInitialIdent);
    if (CloneFailed(m_pOutput->m_pClass,m_pInitialIdent))
        return OutOfMemory;
    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <objref_rest> ::= EQUALS <key_const>;
//  <objref_rest> ::= EQUALS *;
//  <objref_rest> ::= DOT <keyref_list>;
//  <objref_rest> ::= <>;
//
int CObjectPathParser::objref_rest()
{
    if (m_nCurrentToken == OPATH_TOK_EQ)
    {
        if (!NextToken())
            return SyntaxError;

        // Take care of the singleton case.  This is a path of the form
        // MyClass=@  and represents a singleton instance of a class with no
        // keys.


        if(m_nCurrentToken == OPATH_TOK_SINGLETON_SYM)
        {
            if(NextToken() && m_nCurrentToken != OPATH_TOK_EOF)
                return SyntaxError;
            m_pOutput->m_bSingletonObj = TRUE;
            return NoError;

        }

        m_pTmpKeyRef = new KeyRef; // no IsValid here
        if (!m_pTmpKeyRef)
            return OutOfMemory;

        int nRes = key_const();
        if (nRes)
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return nRes;
        }

        if (!m_pOutput->AddKeyRef(m_pTmpKeyRef))
		{
			delete m_pTmpKeyRef;
			m_pTmpKeyRef = 0;
            return OutOfMemory;
		}
		m_pTmpKeyRef = 0;        
    }
    else if (m_nCurrentToken == OPATH_TOK_DOT)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
//  <ns_list_rest> ::= BACKSLASH <ns_list>;
//  <ns_list_rest> ::= <>;
//
int CObjectPathParser::ns_list_rest()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_list();
    }
    return NoError;
}

//
//  <key_const> ::= STRING_CONST;
//  <key_const> ::= INTEGRAL_CONST;
//  <key_const> ::= REAL_CONST;
//  <key_const> ::= IDENT;      // Where IDENT is "OBJECT" for singleton classes
//
int CObjectPathParser::key_const()
{
    // If here, we have a key constant.
    // We may or may not have the property name
    // associated with it.
    // ========================================

    if (m_nCurrentToken == OPATH_TOK_QSTRING)
    {
        
        BSTR bStr = SysAllocString(m_pLexer->GetTokenText());
        if (bStr)
        {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_BSTR;
            V_BSTR(&m_pTmpKeyRef->m_vValue) = bStr;
        }
        else
            return OutOfMemory;
    }
    else if (m_nCurrentToken == OPATH_TOK_INT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        StringCchPrintfA(buf,LENGTH_OF(buf), "%S", m_pLexer->GetTokenText());
        V_I4(&m_pTmpKeyRef->m_vValue) = atol(buf);
    }
    else if (m_nCurrentToken == OPATH_TOK_HEXINT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        StringCchPrintfA(buf,LENGTH_OF(buf), "%S", m_pLexer->GetTokenText());
        long l;
        sscanf(buf, "%x", &l);
        V_I4(&m_pTmpKeyRef->m_vValue) = l;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
       if (wbem_wcsicmp(m_pLexer->GetTokenText(), L"TRUE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 1;
          }
       else if (wbem_wcsicmp(m_pLexer->GetTokenText(), L"FALSE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 0;
       }
       else
            return SyntaxError;
    }
    else return SyntaxError;

    if (!NextToken())
        return SyntaxError;

    return NoError;
}

//
// <keyref_list> ::= <keyref> <keyref_term>;
//
int CObjectPathParser::keyref_list()
{
    int nRes = keyref();
    if (nRes)
        return nRes;
    return keyref_term();
}

//
// <keyref> ::= <propname> EQUALS <key_const>;
//
int CObjectPathParser::keyref()
{
    m_pTmpKeyRef = new KeyRef; // no IsValid here

    if (!m_pTmpKeyRef)
        return OutOfMemory;

    int nRes = propname();

    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EQ)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    nRes = key_const();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (!m_pOutput->AddKeyRef(m_pTmpKeyRef))
	{
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return OutOfMemory;
	}
    m_pTmpKeyRef = 0;

    return NoError;
}

//
//  <keyref_term> ::= COMMA <keyref_list>;      // Used for compound keys
//  <keyref_term> ::= <>;
//
int CObjectPathParser::keyref_term()
{
    if (m_nCurrentToken == OPATH_TOK_COMMA)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
// <propname>  ::= IDENT;
//
int CObjectPathParser::propname()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pTmpKeyRef->m_pName = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
    if (CloneFailed(m_pTmpKeyRef->m_pName,m_pLexer->GetTokenText()))
        return OutOfMemory;

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    return NoError;
}

//***************************************************************************
//
//  ParsedObjectPath::GetKeyString
//
//  Returns the db-engine compatible key string for the object.
//  The format will likely change after the Alpha PDK Release.
//
//  Return value:
//  NULL on error or for pure classes.  Otherwise returns a pointer to
//  a newly allocated string which must be deallocated with operator
//  delete.
//
//***************************************************************************
LPWSTR ParsedObjectPath::GetKeyString()
{
    if (m_dwNumKeys == 0 && !m_bSingletonObj)
    {
        if (m_pClass == 0 || wcslen(m_pClass) == 0)
            return 0;

        size_t cchTmp = wcslen(m_pClass) + 1;
        LPWSTR pTmp = new wchar_t[cchTmp];
        
        if (pTmp) StringCchCopyW(pTmp,cchTmp, m_pClass);

        return pTmp;
    }

    // Allocate enough space
    // =====================

    int nSpace = 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = m_paKeys[dwIx];
        nSpace += 2; // for the |
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(V_VT(&pKey->m_vValue) == VT_I4)
        {
            nSpace += 30;
        }
    }
    if(m_bSingletonObj)
        nSpace +=20;


    LPWSTR pRetVal = new wchar_t[nSpace];
    wchar_t Tmp[32];
    long nVal;

    if (!pRetVal)
        return NULL;

    *pRetVal = 0;
    BOOL bFirst = TRUE;

    // The key are already sorted lexically.
    // =====================================

    WCHAR wszSeparator[2];
    wszSeparator[0] = 0xFFFF;
    wszSeparator[1] = 0;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (!bFirst)
            StringCchCatW(pRetVal,nSpace, wszSeparator);
        bFirst = FALSE;

        KeyRef *pKeyRef = m_paKeys[i];
        VARIANT *pv = &pKeyRef->m_vValue;

        int nType = V_VT(pv);
        switch (nType)
        {
            case VT_LPWSTR:
            case VT_BSTR:
                StringCchCatW(pRetVal,nSpace, V_BSTR(pv));
                break;

            case VT_I4:
                nVal = V_I4(pv);
                StringCchPrintfW(Tmp,LENGTH_OF(Tmp), L"%d", nVal);
                StringCchCatW(pRetVal,nSpace, Tmp);
                break;

            case VT_I2:
                nVal = V_I2(pv);
                StringCchPrintfW(Tmp,LENGTH_OF(Tmp), L"%d", nVal);
                StringCchCatW(pRetVal,nSpace, Tmp);
                break;

            case VT_UI1:
                nVal = V_UI1(pv);
                StringCchPrintfW(Tmp,LENGTH_OF(Tmp), L"%d", nVal);
                StringCchCatW(pRetVal,nSpace, Tmp);
                break;

            case VT_BOOL:
                nVal = V_BOOL(pv);
                StringCchPrintfW(Tmp,LENGTH_OF(Tmp), L"%d", (nVal?1:0));
                StringCchCatW(pRetVal,nSpace, Tmp);
                break;

            default:
                StringCchCatW(pRetVal,nSpace, L"NULL");
        }
    }

    if (wcslen(pRetVal) == 0)
    {
        if(m_bSingletonObj)
        {
            StringCchCopyW(pRetVal,nSpace, L"@");
        }
    }
    return pRetVal;     // This may not be NULL
}

LPWSTR ParsedObjectPath::GetNamespacePart()
{
    if (m_dwNumNamespaces == 0)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];

    if (!wszOut)
        return NULL;

    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces; i++)
    {
        if(i != 0) StringCchCatW(wszOut,nSpace + 1, L"\\");
        StringCchCatW(wszOut,nSpace + 1, m_paNamespaces[i]);
    }

    return wszOut;
}

LPWSTR ParsedObjectPath::GetParentNamespacePart()
{
    if(m_dwNumNamespaces < 2)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces - 1; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    if(wszOut == NULL)return NULL;
    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces - 1; i++)
    {
        if(i != 0) StringCchCatW(wszOut,nSpace + 1, L"\\");
        StringCchCatW(wszOut,nSpace + 1, m_paNamespaces[i]);
    }

    return wszOut;
}

BOOL ParsedObjectPath::IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace)
{
    if(!IsLocal(wszMachine))
        return FALSE;

    if(m_dwNumNamespaces == 0)
        return TRUE;

    size_t cchTmp = wcslen(wszNamespace) + 1;
    LPWSTR wszCopy = new wchar_t[cchTmp];
    if(wszCopy == NULL)return FALSE;
    StringCchCopyW(wszCopy,cchTmp, wszNamespace);
    LPWSTR wszLeft = wszCopy;
    BOOL bFailed = FALSE;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
    {
        unsigned int nLen = wcslen(m_paNamespaces[i]);
        if(nLen > wcslen(wszLeft))
        {
            bFailed = TRUE;
            break;
        }
        if(i == m_dwNumNamespaces - 1 && wszLeft[nLen] != 0)
        {
            bFailed = TRUE;
            break;
        }
        if(i != m_dwNumNamespaces - 1 && wszLeft[nLen] != L'\\')
        {
            bFailed = TRUE;
            break;
        }

        wszLeft[nLen] = 0;
        if(wbem_wcsicmp(wszLeft, m_paNamespaces[i]))
        {
            bFailed = TRUE;
            break;
        }
        wszLeft += nLen+1;
    }
    delete [] wszCopy;
    return !bFailed;
}

BOOL ParsedObjectPath::IsLocal(LPCWSTR wszMachine)
{
    return (m_pServer == NULL || !wbem_wcsicmp(m_pServer, L".") ||
        !wbem_wcsicmp(m_pServer, wszMachine));
}


////////////////////////////////////////////////////////
//
// Test object path parser by parsing all objects
// in the input file (one object path per line).
// 
////////////////////////////////////////////////////////

#ifdef TEST
void xmain(int argc, char **argv)
{
    printf("Object Path Test\n");
    if (argc < 2 || strchr(argv[1], '?') != NULL)
    {
        printf("Usage: objpath input-file\n");
        return;
    }

    int nLine = 1;
    char buf[2048];
    FILE *f = fopen(argv[1], "rt");
    if (f == NULL)
    {
        printf("Usage: objpath input-file\nError: cannot open file %s!\n", argv[1]);
        return;
    }

    while (fgets(buf, 2048, f) != NULL)
    {
        // Get rid of newline and trailing spaces.
        // =======================================

        char* ptr = strchr(buf, '\n');
        if (ptr != NULL)
        {
            *ptr = ' ';
            while (ptr >= buf && *ptr == ' ')
            {
                *ptr = '\0'; 
                ptr--;
            }
        }

        // Get rid of leading spaces.
        // ==========================

        ptr = buf;
        while (*ptr == ' ')
        {
            ptr++;
        }

        // Convert to wide char and parse.  Ignore blank lines.
        // ====================================================

        if (*ptr != '\0')
        {
            wchar_t buf2[2048];
            MultiByteToWideChar(CP_ACP, 0, ptr, -1, buf2, 2048);

            printf("----Object path----\n");
            printf("%S\n", buf2);

            ParsedObjectPath* pOutput = 0;
            CObjectPathParser p(e_ParserAcceptAll);
            int nStatus = p.Parse(buf2,  &pOutput);

            if (nStatus != 0)
            {
                printf("ERROR: return code is %d\n", nStatus);
                continue;
            }
            printf("No errors.\n");

            printf("------Output------\n");

            LPWSTR pKey = pOutput->GetKeyString();
            printf("Key String = <%S>\n", pKey);
            delete pKey;

            printf("Server = %S\n", pOutput->m_pServer);
            printf("Namespace Part = %S\n", pOutput->GetNamespacePart());
            printf("Parent Part    = %S\n", pOutput->GetParentNamespacePart());

            for (DWORD dwIx = 0; dwIx < pOutput->m_dwNumNamespaces; dwIx++)
            {
                printf("Namespace = <%S>\n", pOutput->m_paNamespaces[dwIx]);
            }

            printf("Class = <%S>\n", pOutput->m_pClass);

            // If here, the key ref is complete.
            // =================================

            for (dwIx = 0; dwIx < pOutput->m_dwNumKeys; dwIx++)
            {
                KeyRef *pTmp = pOutput->m_paKeys[dwIx];
                printf("*** KeyRef contents:\n");
                printf("    Name = %S   Value=", pTmp->m_pName);
                switch (V_VT(&pTmp->m_vValue))
                {
                    case VT_I4: printf("%d", V_I4(&pTmp->m_vValue)); break;
                    case VT_R8: printf("%f", V_R8(&pTmp->m_vValue)); break;
                    case VT_BSTR: printf("<%S>", V_BSTR(&pTmp->m_vValue)); break;
                    default:
                        printf("BAD KEY REF\n");
                }
                printf("\n");
            }

            p.Free(pOutput);
        }
    }
}

void main(int argc, char **argv)
{
        xmain(argc, argv);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\objpath.h ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    OBJPATH.H

Abstract:

    object path parser

History:

--*/

#ifndef _OBJPATH_H_
#define _OBJPATH_H_

#include <opathlex.h>

#define DELETE_ME

struct KeyRef
{
    LPWSTR  m_pName;
    VARIANT m_vValue;
    HRESULT m_hRes;

    KeyRef();
    KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
   ~KeyRef();
    BOOL IsValid(){  return (m_pName && (S_OK == m_hRes)); };
};

struct ParsedObjectPath
{
    LPWSTR      m_pServer;              // NULL if no server
    DWORD       m_dwNumNamespaces;      // 0 if no namespaces
    DWORD       m_dwAllocNamespaces;    // size of m_paNamespaces
    LPWSTR     *m_paNamespaces;         // NULL if no namespaces
    LPWSTR      m_pClass;               // Class name
    DWORD       m_dwNumKeys;            // 0 if no keys (just a class name)
    DWORD       m_dwAllocKeys;          // size of m_paKeys
    KeyRef    **m_paKeys;               // NULL if no keys specified
    BOOL        m_bSingletonObj;        // true if object of class with no keys
    ParsedObjectPath();
   ~ParsedObjectPath();

public:
    BOOL SetClassName(LPCWSTR wszClassName);
    BOOL AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddKeyRef(KeyRef* pAcquireRef);
    BOOL AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddNamespace(LPCWSTR wszNamespace);
    LPWSTR GetKeyString();
    LPWSTR GetNamespacePart();
    LPWSTR GetParentNamespacePart();
    void ClearKeys () ;
    BOOL IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace);
    BOOL IsLocal(LPCWSTR wszMachine);
    BOOL IsClass();
    BOOL IsInstance();
    BOOL IsObject();
    BOOL IsValid()
    {
	    return (m_paNamespaces && m_paKeys);
    };
    
};

// NOTE:
// The m_vValue in the KeyRef may not be of the expected type, i.e., the parser
// cannot distinguish 16 bit integers from 32 bit integers if they fall within the
// legal subrange of a 16 bit value.  Therefore, the parser only uses the following
// types for keys:
//      VT_I4, VT_R8, VT_BSTR
// If the underlying type is different, the user of this parser must do appropriate
// type conversion.
//  
typedef enum
{
    e_ParserAcceptRelativeNamespace,    // Allow a relative namespace
    e_ParserAbsoluteNamespaceOnly,      // Require a full object path
    e_ParserAcceptAll                   // Accept any recognizable subset of a path
} ObjectParserFlags;

class CObjectPathParser
{
    LPWSTR m_pInitialIdent;
    int m_nCurrentToken;
    CGenLexer *m_pLexer;
    ParsedObjectPath *m_pOutput;
    KeyRef *m_pTmpKeyRef;
    
    ObjectParserFlags m_eFlags;

private:
    void Zero();
    void Empty();

    int begin_parse();

    int ns_or_server();
    int ns_or_class();
    int objref();
    int ns_list();
    int ident_becomes_ns();
    int ident_becomes_class();
    int objref_rest();
    int ns_list_rest();
    int key_const();
    int keyref_list();
    int keyref();
    int keyref_term();
    int propname();    
    int optional_objref();

    int NextToken();

public:
    enum { NoError, SyntaxError, InvalidParameter, OutOfMemory };

    CObjectPathParser(ObjectParserFlags eFlags = e_ParserAbsoluteNamespaceOnly);
   ~CObjectPathParser();

    int Parse(
        LPCWSTR RawPath,
        ParsedObjectPath **pOutput
        );
    static int WINAPI Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath);

    static LPWSTR WINAPI GetRelativePath(LPWSTR wszFullPath);

    void Free(ParsedObjectPath *pOutput);
    void Free( LPWSTR wszUnparsedPath );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\opathlex.cpp ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

  OPATHLEX.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  24-Jun-95       Created.
  14-Apr-98       Radical update for singly quoted strings, remove
                  unused tokens, add hex constants, etc.

--*/

#include "precomp.h"

#include <genlex.h>
#include <opathlex.h>             


#define ST_IDENT            22
#define ST_NUMERIC          28
#define ST_DECIMAL          30
#define ST_HEX              32
#define ST_SQ_STRING        36
#define ST_DQ_STRING        40
#define ST_DQ_STRING_ESC    43



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,

    // All remaining unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 22 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 23 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 24 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 27 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 28 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 29 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 30 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 32 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 33 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 34 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 36 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 37 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 38 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 39 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 40 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 41 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 42 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 43  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 44  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 45  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\precomp.h ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    precomp.h

Abstract:

History:

--*/
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#include <comdef.h>
#include <strsafe.h>

#include <strutils.h>

#include <stdio.h>
#include <helper.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\opathlex.h ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    OPATHLEX.H

Abstract:

    Object Path DFA Tokens

History:

--*/

#ifndef _OPATHLEX_H_

#define OPATH_TOK_EOF       0
#define OPATH_TOK_ERROR     1

#define OPATH_TOK_IDENT         100
#define OPATH_TOK_QSTRING       101
#define OPATH_TOK_INT           102
#define OPATH_TOK_HEXINT        103
#define OPATH_TOK_EQ            104

#define OPATH_TOK_DOT           105
#define OPATH_TOK_OPEN_PAREN    106
#define OPATH_TOK_CLOSE_PAREN   107
#define OPATH_TOK_SINGLETON_SYM 108
#define OPATH_TOK_COMMA         109

#define OPATH_TOK_BACKSLASH     110
#define OPATH_TOK_COLON         111

#define OPATH_SINGLETON_STRING  L"@"

extern LexEl OPath_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\sources.inc ===
############################################################################
#
#   Copyright  Microsoft Corporation.  All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=stdlibrary

TARGETPATH=obj
TARGETTYPE=LIBRARY

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	 $(STDLIBRARY_INC); \
         $(WBEMCOMN_INC)

# The developer defines the SOURCES macro. It contains a list of all the
# source files for this component. Specify each source file on a separate
# line using the line-continuation character. This minimizes merge
# conflicts if two developers are adding source files to the same component.
SOURCES= \
	..\cominit.cpp \
	..\genlex.cpp \
	..\objpath.cpp \
	..\opathlex.cpp \
	..\sqllex.cpp \
	..\sql_1.cpp

# Next, specify options for the compiler using C_DEFINES. 
C_DEFINES=$(C_DEFINES) /D__WINNT_BUILD__
WIN32_WINNT_VERSION=0x0400
USE_NATIVE_EH=1
USE_MSVCRT=1
USE_STL=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\scopeguard.h ===
//  
//  file: scopeguard.h
//  Used with permission from
//  Andrei Alexandrescu and Petru Marginean
//

#ifndef SCOPEGUARD_H_
#define SCOPEGUARD_H_


template <class T>
class RefHolder
{
	T& ref_;
public:
	RefHolder(T& ref) : ref_(ref) {}
	operator T& () const 
	{
		return ref_;
	}
};

template <class T>
inline RefHolder<T> ByRef(T& t)
{
	return RefHolder<T>(t);
}

class ScopeGuardImplBase
{
	ScopeGuardImplBase& operator =(const ScopeGuardImplBase&);
protected:
	~ScopeGuardImplBase()
	{
	}
	ScopeGuardImplBase(const ScopeGuardImplBase& other) throw() 
		: dismissed_(other.dismissed_)
	{
		other.Dismiss();
	}
	template <typename J>
	static void SafeExecute(J& j) throw() 
	{
		if (!j.dismissed_)
			try
			{
				j.Execute();
			}
			catch(...)
			{
			}
	}
	
	mutable bool dismissed_;
public:
	ScopeGuardImplBase(bool active) throw() : dismissed_(!active) 
	{
	}
	void Dismiss() const throw() 
	{
		dismissed_ = true;
	}

};

typedef const ScopeGuardImplBase& ScopeGuard;

template <typename F>
class ScopeGuardImpl0 : public ScopeGuardImplBase
{
public:
	static ScopeGuardImpl0<F> MakeGuard(bool active, F fun)
	{
		return ScopeGuardImpl0<F>(active, fun);
	}
	~ScopeGuardImpl0() throw() 
	{
		SafeExecute(*this);
	}
	void Execute() 
	{
		fun_();
	}
protected:
	ScopeGuardImpl0(bool active, F fun) : ScopeGuardImplBase(active), fun_(fun) 
	{
	}
	F fun_;
};

template <typename F> 
inline ScopeGuardImpl0<F> MakeGuard(F fun)
{
	return ScopeGuardImpl0<F>::MakeGuard(true, fun);
}

template <typename F> 
inline ScopeGuardImpl0<F> MakeGuardIF(bool active, F fun)
{
	return ScopeGuardImpl0<F>::MakeGuard(active, fun);
}

template <typename F, typename P1>
class ScopeGuardImpl1 : public ScopeGuardImplBase
{
public:
	static ScopeGuardImpl1<F, P1> MakeGuard(bool active, F fun, P1 p1)
	{
		return ScopeGuardImpl1<F, P1>(active, fun, p1);
	}
	~ScopeGuardImpl1() throw() 
	{
		SafeExecute(*this);
	}
	void Execute()
	{
		fun_(p1_);
	}
protected:
	ScopeGuardImpl1(bool active, F fun, P1 p1) : ScopeGuardImplBase(active), fun_(fun), p1_(p1) 
	{
	}
	F fun_;
	const P1 p1_;
};

template <typename F, typename P1> 
inline ScopeGuardImpl1<F, P1> MakeGuard(F fun, P1 p1)
{
	return ScopeGuardImpl1<F, P1>::MakeGuard(true, fun, p1);
}

template <typename F, typename P1> 
inline ScopeGuardImpl1<F, P1> MakeGuardIF(bool active, F fun, P1 p1)
{
	return ScopeGuardImpl1<F, P1>::MakeGuard(active, fun, p1);
}

template <typename F, typename P1, typename P2>
class ScopeGuardImpl2: public ScopeGuardImplBase
{
public:
	static ScopeGuardImpl2<F, P1, P2> MakeGuard(bool active, F fun, P1 p1, P2 p2)
	{
		return ScopeGuardImpl2<F, P1, P2>(active, fun, p1, p2);
	}
	~ScopeGuardImpl2() throw() 
	{
		SafeExecute(*this);
	}
	void Execute()
	{
		fun_(p1_, p2_);
	}
protected:
	ScopeGuardImpl2(bool active, F fun, P1 p1, P2 p2) : ScopeGuardImplBase(active), fun_(fun), p1_(p1), p2_(p2) 
	{
	}
	F fun_;
	const P1 p1_;
	const P2 p2_;
};

template <typename F, typename P1, typename P2>
inline ScopeGuardImpl2<F, P1, P2> MakeGuard(F fun, P1 p1, P2 p2)
{
	return ScopeGuardImpl2<F, P1, P2>::MakeGuard(true, fun, p1, p2);
}

template <typename F, typename P1, typename P2>
inline ScopeGuardImpl2<F, P1, P2> MakeGuardIF(bool active, F fun, P1 p1, P2 p2)
{
	return ScopeGuardImpl2<F, P1, P2>::MakeGuard(active, fun, p1, p2);
}

template <typename F, typename P1, typename P2, typename P3>
class ScopeGuardImpl3 : public ScopeGuardImplBase
{
public:
	static ScopeGuardImpl3<F, P1, P2, P3> MakeGuard(bool active, F fun, P1 p1, P2 p2, P3 p3)
	{
		return ScopeGuardImpl3<F, P1, P2, P3>(active, fun, p1, p2, p3);
	}
	~ScopeGuardImpl3() throw() 
	{
		SafeExecute(*this);
	}
	void Execute()
	{
		fun_(p1_, p2_, p3_);
	}
protected:
	ScopeGuardImpl3(bool active, F fun, P1 p1, P2 p2, P3 p3) : ScopeGuardImplBase(active), fun_(fun), p1_(p1), p2_(p2), p3_(p3) 
	{
	}
	F fun_;
	const P1 p1_;
	const P2 p2_;
	const P3 p3_;
};

template <typename F, typename P1, typename P2, typename P3>
inline ScopeGuardImpl3<F, P1, P2, P3> MakeGuard(F fun, P1 p1, P2 p2, P3 p3)
{
	return ScopeGuardImpl3<F, P1, P2, P3>::MakeGuard(true, fun, p1, p2, p3);
}

template <typename F, typename P1, typename P2, typename P3>
inline ScopeGuardImpl3<F, P1, P2, P3> MakeGuardIF(bool active, F fun, P1 p1, P2 p2, P3 p3)
{
	return ScopeGuardImpl3<F, P1, P2, P3>::MakeGuard(active, fun, p1, p2, p3);
}

//************************************************************

template <class Obj, typename MemFun>
class ObjScopeGuardImpl0 : public ScopeGuardImplBase
{
public:
	static ObjScopeGuardImpl0<Obj, MemFun> MakeObjGuard(bool active, Obj& obj, MemFun memFun)
	{
		return ObjScopeGuardImpl0<Obj, MemFun>(active, obj, memFun);
	}
	~ObjScopeGuardImpl0() throw() 
	{
		SafeExecute(*this);
	}
	void Execute() 
	{
		(obj_.*memFun_)();
	}
protected:
	ObjScopeGuardImpl0(bool active, Obj& obj, MemFun memFun) 
		: ScopeGuardImplBase(active), obj_(obj), memFun_(memFun) {}
	Obj& obj_;
	MemFun memFun_;
};

template <class Obj, typename MemFun>
inline ObjScopeGuardImpl0<Obj, MemFun> MakeObjGuard(Obj& obj, MemFun memFun)
{
	return ObjScopeGuardImpl0<Obj, MemFun>::MakeObjGuard(true, obj, memFun);
}

template <class Obj, typename MemFun>
inline ObjScopeGuardImpl0<Obj, MemFun> MakeObjGuardIF(bool active, Obj& obj, MemFun memFun)
{
	return ObjScopeGuardImpl0<Obj, MemFun>::MakeObjGuard(active, obj, memFun);
}

template <class Obj, typename MemFun, typename P1>
class ObjScopeGuardImpl1 : public ScopeGuardImplBase
{
public:
	static ObjScopeGuardImpl1<Obj, MemFun, P1> MakeObjGuard(bool active, Obj& obj, MemFun memFun, P1 p1)
	{
		return ObjScopeGuardImpl1<Obj, MemFun, P1>(active, obj, memFun, p1);
	}
	~ObjScopeGuardImpl1() throw() 
	{
		SafeExecute(*this);
	}
	void Execute() 
	{
		(obj_.*memFun_)(p1_);
	}
protected:
	ObjScopeGuardImpl1(bool active, Obj& obj, MemFun memFun, P1 p1) 
		: ScopeGuardImplBase(active), obj_(obj), memFun_(memFun), p1_(p1) {}
	Obj& obj_;
	MemFun memFun_;
	const P1 p1_;
};

template <class Obj, typename MemFun, typename P1>
inline ObjScopeGuardImpl1<Obj, MemFun, P1> MakeObjGuard(Obj& obj, MemFun memFun, P1 p1)
{
	return ObjScopeGuardImpl1<Obj, MemFun, P1>::MakeObjGuard(true, obj, memFun, p1);
}

template <class Obj, typename MemFun, typename P1>
inline ObjScopeGuardImpl1<Obj, MemFun, P1> MakeObjGuardIF(bool active, Obj& obj, MemFun memFun, P1 p1)
{
	return ObjScopeGuardImpl1<Obj, MemFun, P1>::MakeObjGuard(active, obj, memFun, p1);
}

template <class Obj, typename MemFun, typename P1, typename P2>
class ObjScopeGuardImpl2 : public ScopeGuardImplBase
{
public:
	static ObjScopeGuardImpl2<Obj, MemFun, P1, P2> MakeObjGuard(bool active, Obj& obj, MemFun memFun, P1 p1, P2 p2)
	{
		return ObjScopeGuardImpl2<Obj, MemFun, P1, P2>(active, obj, memFun, p1, p2);
	}
	~ObjScopeGuardImpl2() throw() 
	{
		SafeExecute(*this);
	}
	void Execute() 
	{
		(obj_.*memFun_)(p1_, p2_);
	}
protected:
	ObjScopeGuardImpl2(bool active, Obj& obj, MemFun memFun, P1 p1, P2 p2) 
		: ScopeGuardImplBase(active), obj_(obj), memFun_(memFun), p1_(p1), p2_(p2) {}
	Obj& obj_;
	MemFun memFun_;
	const P1 p1_;
	const P2 p2_;
};

template <class Obj, typename MemFun, typename P1, typename P2>
inline ObjScopeGuardImpl2<Obj, MemFun, P1, P2> MakeObjGuard(Obj& obj, MemFun memFun, P1 p1, P2 p2)
{
	return ObjScopeGuardImpl2<Obj, MemFun, P1, P2>::MakeObjGuard(true, obj, memFun, p1, p2);
}
template <class Obj, typename MemFun, typename P1, typename P2>
inline ObjScopeGuardImpl2<Obj, MemFun, P1, P2> MakeObjGuardIF(bool active, Obj& obj, MemFun memFun, P1 p1, P2 p2)
{
	return ObjScopeGuardImpl2<Obj, MemFun, P1, P2>::MakeObjGuard(active, obj, memFun, p1, p2);
}

// Rollback helper functions
template<typename T>
void deletePtr(const T* p)
{
  delete p;
}

template<typename T>
void deleteArray(T* p)
{
  delete[] p;
}

#define CONCATENATE_DIRECT(s1, s2) s1##s2
#define CONCATENATE(s1, s2) CONCATENATE_DIRECT(s1, s2)
#define ANONYMOUS_VARIABLE(str) CONCATENATE(str, __LINE__)

#define ON_BLOCK_EXIT ScopeGuard ANONYMOUS_VARIABLE(scopeGuard) = MakeGuard
#define ON_BLOCK_EXIT_OBJ ScopeGuard ANONYMOUS_VARIABLE(scopeGuard) = MakeObjGuard

#define ON_BLOCK_EXIT_IF ScopeGuard ANONYMOUS_VARIABLE(scopeGuard) = MakeGuardIF
#define ON_BLOCK_EXIT_OBJ_IF ScopeGuard ANONYMOUS_VARIABLE(scopeGuard) = MakeObjGuardIF

#endif //SCOPEGUARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\sqllex.cpp ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    sqllex.cpp

Abstract:

    SQL Level 1 DFA Table

History:


--*/

#include "precomp.h"

#include <genlex.h>
#include <sqllex.h>             

#define ST_STRING   23
#define ST_IDENT    28
#define ST_GE       34
#define ST_LE       36
#define ST_NE       39
#define ST_NUMERIC  41
#define ST_REAL     44
#define ST_STRING2  50
#define ST_STRING_ESC 55
#define ST_STRING2_ESC 56

// DFA State Table for SQL Level 1 lexical symbols.
// ================================================

LexEl Sql_1_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,  SQL_1_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,  SQL_1_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, 0,  SQL_1_TOK_DOT,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,  SQL_1_TOK_ASTERISK,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,  SQL_1_TOK_EQ,          GLEX_ACCEPT,

/* 9 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 10 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 11 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 12 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 13 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 14 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 15 */ L'-',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,

    // Whitespace, newlines, etc.
/* 16 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 17 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 18 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 19 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 20 */ 0,      GLEX_EMPTY, 0,  SQL_1_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 21 */ L',',   GLEX_EMPTY, 0,  SQL_1_TOK_COMMA, GLEX_ACCEPT,

    // Unknown characters

/* 22 */ GLEX_ANY, GLEX_EMPTY, 0,        SQL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 23 */   L'\n', GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 24 */   L'\r', GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 25 */   L'"',  GLEX_EMPTY, 0,  SQL_1_TOK_QSTRING,  GLEX_CONSUME,
/* 26 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 27 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 28 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 29 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 30 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 31 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 32 */  0x80,   0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  GLEX_ANY, GLEX_EMPTY,  0,       SQL_1_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 34 */  L'=',   GLEX_EMPTY,  0,  SQL_1_TOK_GE,  GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY,  0,       SQL_1_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 36 */  L'=',   GLEX_EMPTY,      0,  SQL_1_TOK_LE,  GLEX_ACCEPT,
/* 37 */  L'>',   GLEX_EMPTY,      0,  SQL_1_TOK_NE,  GLEX_ACCEPT,
/* 38 */  GLEX_ANY, GLEX_EMPTY,    0,  SQL_1_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 39 */  L'=',   GLEX_EMPTY,      0,  SQL_1_TOK_NE,     GLEX_ACCEPT,
/* 40 */  GLEX_ANY,  GLEX_EMPTY,   0,  SQL_1_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 41 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 42 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 43 */  GLEX_ANY, GLEX_EMPTY, 0,          SQL_1_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 44 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 45 */  L'E',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 46 */  L'e',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 47 */  L'+',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 48 */  L'-',   GLEX_EMPTY,   ST_REAL,    0, GLEX_ACCEPT,
/* 49 */  GLEX_ANY,       GLEX_EMPTY,   0,     SQL_1_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 50 */   L'\n',  GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 51 */   L'\r',  GLEX_EMPTY, 0,  SQL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 52 */   L'\'',  GLEX_EMPTY, 0,  SQL_1_TOK_QSTRING,   GLEX_CONSUME,
/* 53 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 54 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 55 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

// ST_STRING2_ESC
/* 56 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\sqllex.h ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    sqllex.h

Abstract:

    SQL Level 1 DFA Table & Tokens

History:

--*/

#ifndef _SQLLEX_H_
#define _SQLLEX_H_

#define SQL_1_TOK_EOF           0
#define SQL_1_TOK_ERROR         1
#define SQL_1_TOK_IDENT         100
#define SQL_1_TOK_QSTRING       101
#define SQL_1_TOK_INT           102
#define SQL_1_TOK_REAL          103
#define SQL_1_TOK_CHAR          104
#define SQL_1_TOK_BOOL          105

#define SQL_1_TOK_LE            106
#define SQL_1_TOK_LT            107
#define SQL_1_TOK_GE            108
#define SQL_1_TOK_GT            109
#define SQL_1_TOK_EQ            110
#define SQL_1_TOK_NE            111

#define SQL_1_TOK_DOT           112
#define SQL_1_TOK_OPEN_PAREN    113
#define SQL_1_TOK_CLOSE_PAREN   114
#define SQL_1_TOK_ASTERISK      115
#define SQL_1_TOK_COMMA         116

#define SQL_1_TOK_SELECT        120
#define SQL_1_TOK_WHERE         121
#define SQL_1_TOK_FROM          122
#define SQL_1_TOK_LIKE          123
#define SQL_1_TOK_OR            124
#define SQL_1_TOK_AND           125
#define SQL_1_TOK_NOT           126
#define SQL_1_TOK_IS            127
#define SQL_1_TOK_NULL          128

extern LexEl Sql_1_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\sql_test.cpp ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    SQL_TEST.CPP

Abstract:

  Test driver for Level 1 Syntax QL Parser

  Takes the filename of a file containing one or more WQL queries (one per
  line).  Writes the output to the console.

History:

  23-Apr-99    Modified to improve output.

--*/

#include "precomp.h"

#include <genlex.h>
#include <sqllex.h>
#include <sql_1.h>

void xmain(int argc, char **argv)
{
    if (argc < 2 || strchr(argv[1], '?') != NULL)
    {
        printf("Usage: ql_test WQL-query-file\n");
        return;
    }

    int nLine = 1;
    char buf[2048];
    FILE *f = fopen(argv[1], "rt");
    if (f == NULL)
    {
        printf("Usage: ql_test WQL-query-file\nError: cannot open file %s!\n", argv[1]);
        return;
    }

    while (fgets(buf, 2048, f) != NULL)
    {
        // get rid of newline
        char* ptr;
        if ((ptr = strchr(buf, '\n')) != NULL)
        {
            *ptr = '\0';
        }

        // get start of text
        ptr = buf;
        while (*ptr == ' ')
        {
            ptr++;
        }

        // ignore blank lines
        if (*ptr != '\0')
        {
            wchar_t buf2[2048];
            MultiByteToWideChar(CP_ACP, 0, ptr, -1, buf2, 2048);

            CTextLexSource src(buf2);
            SQL1_Parser parser(&src);
            SQL_LEVEL_1_RPN_EXPRESSION *pExp = NULL;

            // get the class
            wchar_t classbuf[128];
            *classbuf = 0;
            printf("----GetQueryClass----\n");
            int nRes = parser.GetQueryClass(classbuf, 128);
            if (nRes)
            {
                printf("ERROR %d: line %d, token %S\n",
                    nRes,
                    parser.CurrentLine(),
                    parser.CurrentToken()
                    );
                goto ContinueRead;
            }
            printf("Query class is %S\n", classbuf);

            // parse the full query
            nRes = parser.Parse(&pExp);

            if (nRes)
            {
                printf("ERROR %d: line %d, token %S\n",
                    nRes,
                    parser.CurrentLine(),
                    parser.CurrentToken()
                    );
                //goto ContinueRead;
            }
            else
            {
                printf("No errors.\n");
            }

            // call Dump function to display the tokens
            if (pExp)
            {
                pExp->Dump("CON");
            }

ContinueRead:
            delete pExp;
            printf("%S\n", buf2);
            printf("=================================================EOL %d=======================================================\n", nLine);
        }
        nLine++;
    }

    if (ferror(f) != 0)
    {
        printf("\nError: line %d", nLine);
    }

    fclose(f);
}

void main(int argc, char **argv)
{
    xmain(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\sql_1.cpp ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    SQL_1.CPP

Abstract:

  Level 1 Syntax SQL Parser

  Implements the syntax described in SQL_1.BNF.  This translates the input
  into an RPN stream of tokens.

History:

  21-Jun-96       Created.

--*/

#include "precomp.h"

#include <genlex.h>
#include <sqllex.h>
#include <sql_1.h>
#include <autoptr.h>

class CX_Exception {};

class CX_MemoryException : public CX_Exception {};

#define trace(x)

static DWORD TranslateIntrinsic(LPWSTR pFuncName)
{
    if (wbem_wcsicmp(pFuncName, L"UPPER") == 0)
        return SQL_LEVEL_1_TOKEN::IFUNC_UPPER;
    if (wbem_wcsicmp(pFuncName, L"LOWER") == 0)
        return SQL_LEVEL_1_TOKEN::IFUNC_LOWER;
    return SQL_LEVEL_1_TOKEN::IFUNC_NONE;
}

SQL1_Parser::SQL1_Parser(CGenLexSource *pSrc)
{
    Init(pSrc);
}

SQL1_Parser::~SQL1_Parser()
{
    Cleanup();
}

void SQL1_Parser::Init(CGenLexSource *pSrc)
{
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;

    m_pExpression = 0;
    m_pLexer = 0;

    // Semantic transfer variables.
    // ============================
    m_nRelOp = 0;
    VariantInit(&m_vTypedConst);
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_pIdent = 0;
    m_pPropComp = 0;
    m_bConstIsStrNumeric = FALSE;

    if (pSrc)
    {
        wmilib::auto_ptr<CGenLexer> t_pLexer ( new CGenLexer(Sql_1_LexTable, pSrc) );
		if (! t_pLexer.get())
			throw CX_MemoryException();

        wmilib::auto_ptr<SQL_LEVEL_1_RPN_EXPRESSION> t_pExpression ( new SQL_LEVEL_1_RPN_EXPRESSION ) ;
		if (! t_pExpression.get())
			throw CX_MemoryException();

		m_pLexer = t_pLexer.release () ;
		m_pExpression = t_pExpression.release () ;
    }
}

void SQL1_Parser::Cleanup()
{
    VariantClear(&m_vTypedConst);
    delete m_pIdent;
    delete m_pPropComp;
    delete m_pLexer;
    delete m_pExpression;
}

void SQL1_Parser::SetSource(CGenLexSource *pSrc)
{
    Cleanup();
    Init(pSrc);
}

int SQL1_Parser::GetQueryClass(
    LPWSTR pDestBuf,
    int nBufLen
    )
{
    if ((!m_pLexer) || (!pDestBuf))
    {
        return FAILED;
    }

    // Scan until 'FROM' and then get the class name.
    // ==============================================

    for (;;)
    {
        m_nCurrentToken = m_pLexer->NextToken();

        if (m_nCurrentToken == SQL_1_TOK_EOF)
        {
            m_pLexer->Reset();
            return FAILED;
        }

        if (wbem_wcsicmp(m_pLexer->GetTokenText(), L"from") == 0)
        {
            m_nCurrentToken = m_pLexer->NextToken();
            if (m_nCurrentToken != SQL_1_TOK_IDENT)
            {
                m_pLexer->Reset();
                return FAILED;
            }

            // If here, we have the class name.
            // ================================
            if (wcslen(m_pLexer->GetTokenText()) >= (size_t)nBufLen)
            {
                m_pLexer->Reset();
                return BUFFER_TOO_SMALL;
            }

            StringCchCopyW(pDestBuf,nBufLen, m_pLexer->GetTokenText());
            break;
        }
    }

    // Reset the scanner.
    // ==================
    m_pLexer->Reset();

    return SUCCESS;
}

int SQL1_Parser::Parse(SQL_LEVEL_1_RPN_EXPRESSION **pOutput)
{
    if ((!m_pLexer) || (!pOutput))
    {
        return FAILED;
    }

    *pOutput = 0;

    int nRes = parse();
    if (nRes)
        return nRes;

    *pOutput = m_pExpression;
    m_pExpression = 0;

    return SUCCESS;
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

BOOL SQL1_Parser::Next()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == SQL_1_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == SQL_1_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check.
    // ==============

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        if (wbem_wcsicmp(m_pTokenText, L"select") == 0)
            m_nCurrentToken = SQL_1_TOK_SELECT;
        else if (wbem_wcsicmp(m_pTokenText, L"from") == 0)
            m_nCurrentToken = SQL_1_TOK_FROM;
        else if (wbem_wcsicmp(m_pTokenText, L"where") == 0)
            m_nCurrentToken = SQL_1_TOK_WHERE;
        else if (wbem_wcsicmp(m_pTokenText, L"like") == 0)
            m_nCurrentToken = SQL_1_TOK_LIKE;
        else if (wbem_wcsicmp(m_pTokenText, L"or") == 0)
            m_nCurrentToken = SQL_1_TOK_OR;
        else if (wbem_wcsicmp(m_pTokenText, L"and") == 0)
            m_nCurrentToken = SQL_1_TOK_AND;
        else if (wbem_wcsicmp(m_pTokenText, L"not") == 0)
            m_nCurrentToken = SQL_1_TOK_NOT;
        else if (wbem_wcsicmp(m_pTokenText, L"IS") == 0)
            m_nCurrentToken = SQL_1_TOK_IS;
        else if (wbem_wcsicmp(m_pTokenText, L"NULL") == 0)
            m_nCurrentToken = SQL_1_TOK_NULL;
        else if (wbem_wcsicmp(m_pTokenText, L"TRUE") == 0)
        {
            m_nCurrentToken = SQL_1_TOK_BOOL;
            m_pTokenText = L"65535";
        }
        else if (wbem_wcsicmp(m_pTokenText, L"FALSE") == 0)
        {
            m_nCurrentToken = SQL_1_TOK_BOOL;
            m_pTokenText = L"0";
        }
    }

    return TRUE;
}

//***************************************************************************
//
// <parse> ::= SELECT <prop_list> FROM <classname> WHERE <expr>;
//
//***************************************************************************
// ok

int SQL1_Parser::parse()
{
    int nRes;

    // SELECT
    // ======
    if (!Next())
        return LEXICAL_ERROR;
    if (m_nCurrentToken != SQL_1_TOK_SELECT)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // <prop_list>
    // ===========
    if (nRes = prop_list())
        return nRes;

    // FROM
    // ====
    if (m_nCurrentToken != SQL_1_TOK_FROM)
        return SYNTAX_ERROR;
    if (!Next())
        return LEXICAL_ERROR;

    // <classname>
    // ===========
    if (nRes = class_name())
        return nRes;

    // WHERE clause.
    // =============
    return opt_where();
}

//***************************************************************************
//
//  <opt_where> ::= WHERE <expr>;
//  <opt_where> ::= <>;
//
//***************************************************************************
int SQL1_Parser::opt_where()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_EOF)
    {
        trace(("No WHERE clause\n"));
        return SUCCESS;
    }

    if (m_nCurrentToken != SQL_1_TOK_WHERE)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    // <expr>
    // ======
    if (nRes = expr())
        return nRes;

    // Verify that the current token is SQL_1_TOK_EOF.
    // ===============================================
    if (m_nCurrentToken != SQL_1_TOK_EOF)
        return SYNTAX_ERROR;

    return SUCCESS;
}



//***************************************************************************
//
//  <prop_list> ::= <property_name> <prop_list_2>;
//
//***************************************************************************

int SQL1_Parser::prop_list()
{
    int nRes;

    if (m_nCurrentToken != SQL_1_TOK_ASTERISK &&
        m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (nRes = property_name())
        return nRes;

    if (!Next())
        return LEXICAL_ERROR;

    return prop_list_2();
}

//***************************************************************************
//
//  <prop_list_2> ::= COMMA <prop_list>;
//  <prop_list_2> ::= <>;
//
//***************************************************************************

int SQL1_Parser::prop_list_2()
{
    if (m_nCurrentToken == SQL_1_TOK_COMMA)
    {
        if (!Next())
            return LEXICAL_ERROR;
        return prop_list();
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <property_name> ::= PROPERTY_NAME_STRING;
//  <property_name> ::= ASTERISK;
//
//***************************************************************************

int SQL1_Parser::property_name()
{
    try
    {
        if (m_nCurrentToken == SQL_1_TOK_ASTERISK)
        {
            trace(("Asterisk\n"));

            // We need to clean up the expression so far.
            for (int i = 0; i < m_pExpression->nNumberOfProperties; i++)
                SysFreeString(m_pExpression->pbsRequestedPropertyNames[i]);

            m_pExpression->nNumberOfProperties = 0;
                // This signals 'all properties' to the evaluator
            return SUCCESS;
        }

        // Else a property name.
        // =====================

        trace(("Property name %S\n", m_pTokenText));

        m_pExpression->AddProperty(m_pTokenText);
    }
    catch (...)
    {
        return FAILED;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <classname> ::= CLASS_NAME_STRING;
//
//***************************************************************************

int SQL1_Parser::class_name()
{
    if (m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    trace(("Class name is %S\n", m_pTokenText));
    m_pExpression->bsClassName = SysAllocString(m_pTokenText);
	if ( ! m_pExpression->bsClassName )
	{
		throw CX_MemoryException();
	}

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr> ::= <term> <expr2>;
//
//***************************************************************************

int SQL1_Parser::expr()
{
    int nRes;

    if (nRes = term())
        return nRes;

    if (nRes = expr2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr2> ::= OR <term> <expr2>;
//  <expr2> ::= <>;
//
//  Entry: Assumes token OR already current.
//  Exit:  Advances a token
//
//***************************************************************************

int SQL1_Parser::expr2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == SQL_1_TOK_OR)
        {
            trace(("Token OR\n"));

            if (!Next())
                return LEXICAL_ERROR;

            if (nRes = term())
                return nRes;

            SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
			if ( ! pNewTok )
				throw CX_MemoryException();

            pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
            m_pExpression->AddToken(pNewTok);
        }
        else break;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <term> ::= <simple_expr> <term2>;
//
//***************************************************************************

int SQL1_Parser::term()
{
    int nRes;
    if (nRes = simple_expr())
        return nRes;

    if (nRes = term2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <term2> ::= AND <simple_expr> <term2>;
//  <term2> ::= <>;
//
//***************************************************************************

int SQL1_Parser::term2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == SQL_1_TOK_AND)
        {
            trace(("Token AND\n"));

            if (!Next())
                return LEXICAL_ERROR;

            if (nRes = simple_expr())
                return nRes;

            // Add the AND token.
            // ==================
            SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
			if ( ! pNewTok )
			{
				throw CX_MemoryException();
			}

            pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;
            m_pExpression->AddToken(pNewTok);
        }
        else break;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <simple_expr> ::= NOT <expr>;
//  <simple_expr> ::= OPEN_PAREN <expr> CLOSE_PAREN;
//  <simple_expr> ::= IDENTIFIER <leading_ident_expr> <finalize>;
//  <simple_expr> ::= VARIANT <rel_operator> <trailing_prop_expr> <finalize>;
//
//***************************************************************************
// ok
int SQL1_Parser::simple_expr()
{
    int nRes;

    // NOT <expr>
    // ==========
    if (m_nCurrentToken == SQL_1_TOK_NOT)
    {
        trace(("Operator NOT\n"));
        if (!Next())
            return LEXICAL_ERROR;
        if (nRes = simple_expr())
            return nRes;

        SQL_LEVEL_1_TOKEN *pNewTok = new SQL_LEVEL_1_TOKEN;
		if ( ! pNewTok )
		{
			throw CX_MemoryException();
		}

        pNewTok->nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_NOT;
        m_pExpression->AddToken(pNewTok);

        return SUCCESS;
    }

    // OPEN_PAREN <expr> CLOSE_PAREN
    // =============================
    else if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        trace(("Open Paren: Entering subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;
        if (expr())
            return SYNTAX_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        trace(("Close paren: Exiting subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    // IDENTIFIER <leading_ident_expr> <finalize>
    // ==========================================
    else if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        trace(("    Identifier <%S>\n", m_pTokenText));

        size_t cchTmp = wcslen(m_pTokenText) + 1;
        m_pIdent = new wchar_t[cchTmp];
		if ( ! m_pIdent )
		{
			throw CX_MemoryException();
		}

        StringCchCopyW(m_pIdent,cchTmp, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;

        if (nRes = leading_ident_expr())
            return SYNTAX_ERROR;

        return finalize();
    }

    // <typed_constant> <rel_operator> <trailing_prop_expr> <finalize>
    // ======================================================
    else if (m_nCurrentToken == SQL_1_TOK_INT ||
             m_nCurrentToken == SQL_1_TOK_REAL ||
             m_nCurrentToken == SQL_1_TOK_QSTRING
            )
    {
        if (nRes = typed_constant())
            return nRes;

        if (nRes = rel_operator())
            return nRes;

        if (nRes = trailing_prop_expr())
            return nRes;

        return finalize();
    }

    return SYNTAX_ERROR;
}


//***************************************************************************
//
//  <trailing_prop_expr> ::=  IDENTIFIER <trailing_prop_expr2>;
//
//***************************************************************************
// ok
int SQL1_Parser::trailing_prop_expr()
{
    if (m_nCurrentToken != SQL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (!m_pIdent)
    {
        size_t cchTmp = wcslen(m_pTokenText) + 1;
        m_pIdent = new wchar_t[cchTmp];
		if ( ! m_pIdent )
		{
			throw CX_MemoryException();
		}

        StringCchCopyW(m_pIdent,cchTmp, m_pTokenText);
    }
    else
    {
        size_t cchTmp = wcslen(m_pTokenText) + 1;
        m_pPropComp = new wchar_t[cchTmp];
		if ( ! m_pPropComp )
		{
			throw CX_MemoryException();
		}

        StringCchCopyW(m_pPropComp,cchTmp, m_pTokenText);
    }

    if (!Next())
        return LEXICAL_ERROR;

    return trailing_prop_expr2();
}

//***************************************************************************
//
//  <trailing_prop_expr2> ::= OPEN_PAREN IDENTIFIER CLOSE_PAREN;
//  <trailing_prop_expr2> ::= <>;
//
//***************************************************************************
// ok

int SQL1_Parser::trailing_prop_expr2()
{
    if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        if (!Next())
            return LEXICAL_ERROR;

        // If we got to this point, the string pointed to by m_pIdent
        // was an intrinsic function and not a property name, and we
        // are about to get the property name, so we have to translate
        // the function name to its correct code before overwriting it.
        // ============================================================
        trace(("Translating intrinsic function %S\n", m_pIdent));
        m_dwPropFunction = TranslateIntrinsic(m_pIdent);
        delete m_pIdent;

        size_t cchTmp = wcslen(m_pTokenText) + 1;
        m_pIdent = new wchar_t[cchTmp];
		if ( ! m_pIdent )
		{
			throw CX_MemoryException();
		}

        StringCchCopyW(m_pIdent,cchTmp, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;

        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;
    }

    trace(("Property name is %S\n", m_pIdent));
    return SUCCESS;
}


//***************************************************************************
//
//  <leading_ident_expr> ::= OPEN_PAREN <unknown_func_expr>;
//  <leading_ident_expr> ::= <comp_operator> <trailing_const_expr>;
//  <leading_ident_expr> ::= <equiv_operator> <trailing_or_null>;
//  <leading_ident_expr> ::= <is_operator> NULL;
//
//***************************************************************************
// ok
int SQL1_Parser::leading_ident_expr()
{
    int nRes;
    if (m_nCurrentToken == SQL_1_TOK_OPEN_PAREN)
    {
        if (!Next())
            return LEXICAL_ERROR;
        return unknown_func_expr();
    }
    if (SUCCESS ==  comp_operator() || SUCCESS == equiv_operator())
        return trailing_or_null();
    nRes = is_operator();
    if(nRes != SUCCESS)
        return nRes;
    if (m_nCurrentToken != SQL_1_TOK_NULL)
        return LEXICAL_ERROR;
    if (Next())
    {
        V_VT(&m_vTypedConst) = VT_NULL;
        return SUCCESS;
    }
    else
        return LEXICAL_ERROR;
}


//***************************************************************************
//
//  <unknown_func_expr> ::= IDENTIFIER CLOSE_PAREN
//                          <rel_operator> <trailing_const_expr>;
//
//  <unknown_func_expr> ::= <typed_constant> CLOSE_PAREN
//                          <rel_operator> <trailing_prop_expr>;
//
//***************************************************************************
// ok
int SQL1_Parser::unknown_func_expr()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        m_dwPropFunction = TranslateIntrinsic(m_pIdent);
        delete m_pIdent;
        size_t cchTmp = wcslen(m_pTokenText) + 1;
        m_pIdent = new wchar_t[cchTmp];
		if ( ! m_pIdent )
		{
			throw CX_MemoryException();
		}

        StringCchCopyW(m_pIdent,cchTmp, m_pTokenText);

        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;
        if (nRes = rel_operator())
            return nRes;
        return trailing_const_expr();
    }

    // Else the other production.
    // ==========================

    if (nRes = typed_constant())
        return nRes;

    // If here, we know that the leading ident was
    // an intrinsic function.
    // ===========================================

    m_dwConstFunction = TranslateIntrinsic(m_pIdent);
    delete m_pIdent;
    m_pIdent = 0;

    if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;
    if (nRes = rel_operator())
        return nRes;

    return trailing_prop_expr();
}

//***************************************************************************
//
//  <trailing_or_null> ::= NULL;
//  <trailing_or_null> ::= <trailing_const_expr>;
//  <trailing_or_null> ::= <trailing_prop_expr>;
//
//***************************************************************************

int SQL1_Parser::trailing_or_null()
{
    int nRes;
    if (m_nCurrentToken == SQL_1_TOK_NULL)
    {
        if (!Next())
            return LEXICAL_ERROR;
        else
        {
            V_VT(&m_vTypedConst) = VT_NULL;
            return SUCCESS;
        }
    }
    else if (!(nRes = trailing_const_expr()))
        return nRes;
    return trailing_prop_expr();
}

//***************************************************************************
//
//  <trailing_const_expr> ::= IDENTIFIER OPEN_PAREN
//                            <typed_constant> CLOSE_PAREN;
//  <trailing_const_expr> ::= <typed_constant>;
//
//***************************************************************************
// ok
int SQL1_Parser::trailing_const_expr()
{
    int nRes;

    if (m_nCurrentToken == SQL_1_TOK_IDENT)
    {
        trace(("Function applied to typed const = %S\n", m_pTokenText));

        m_dwConstFunction = TranslateIntrinsic(m_pTokenText);
        if (!m_dwConstFunction)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != SQL_1_TOK_OPEN_PAREN)
            return SYNTAX_ERROR;
    if (!Next())
            return LEXICAL_ERROR;

        if (nRes = typed_constant())
            return nRes;

        if (m_nCurrentToken != SQL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;

        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    return typed_constant();
}

//***************************************************************************
//
//  <finalize> ::= <>;
//
//  This composes the SQL_LEVEL_1_TOKEN for a simple relational expression,
//  complete with any associated intrinsic functions.  All of the other
//  parse functions help isolate the terms of the expression, but only
//  this function builds the token.
//
//  To build the token, the following member variables are used:
//      m_pPropName
//      m_vTypedConst
//      m_dwPropFunction
//      m_dwConstFunction
//      m_nRelOp;
//
//  After the token is built, these are cleared/deallocated as appropriate.
//  No tokens are consumed and the input is not advanced.
//
//***************************************************************************
int SQL1_Parser::finalize()
{
    // At this point, we have all the info needed for a token.
    // =======================================================

    wmilib :: auto_ptr<SQL_LEVEL_1_TOKEN> pNewTok ( new SQL_LEVEL_1_TOKEN ) ;
	if (! pNewTok.get())
		throw CX_MemoryException();

    pNewTok.get()->nTokenType = SQL_LEVEL_1_TOKEN::OP_EXPRESSION;
    pNewTok.get()->pPropertyName = SysAllocString(m_pIdent);
	if ( ! pNewTok.get()->pPropertyName )
	{
		throw CX_MemoryException();
	}

    if (m_pPropComp)
	{
        pNewTok.get()->pPropName2 = SysAllocString(m_pPropComp);
		if ( ! pNewTok.get()->pPropName2 )
		{
			throw CX_MemoryException();
		}
	}

    pNewTok.get()->nOperator = m_nRelOp;
    VariantInit(&pNewTok.get()->vConstValue);
    VariantCopy(&pNewTok.get()->vConstValue, &m_vTypedConst);
    pNewTok.get()->dwPropertyFunction = m_dwPropFunction;
    pNewTok.get()->dwConstFunction = m_dwConstFunction;
    pNewTok.get()->bConstIsStrNumeric = m_bConstIsStrNumeric;

    m_pExpression->AddToken(pNewTok.release ());

    // Cleanup.
    // ========
    VariantClear(&m_vTypedConst);
    delete m_pIdent;
    m_pIdent = 0;
    m_nRelOp = 0;
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_bConstIsStrNumeric = FALSE;

    return SUCCESS;
}

//***************************************************************************
//
//  <typed_constant> ::= VARIANT;
//
//  Ouput: m_vTypedConst is set to the value of the constant. The only
//         supported types are VT_I4, VT_R8 and VT_BSTR.
//
//***************************************************************************

int SQL1_Parser::typed_constant()
{
    trace(("    Typed constant <%S> ", m_pTokenText));
    VariantClear(&m_vTypedConst);
    m_bConstIsStrNumeric = FALSE;

    if (m_nCurrentToken == SQL_1_TOK_INT)
    {
        trace((" Integer\n"));
        DWORD x = wcslen(m_pTokenText);

        if (*m_pTokenText == L'-')
        {
            //negative

            if ((x < 11) ||
                ((x == 11) && (wcscmp(m_pTokenText, L"-2147483648") <= 0)))
            {
                V_VT(&m_vTypedConst) = VT_I4;
                V_I4(&m_vTypedConst) = _wtol(m_pTokenText);
            }
            else
            {
                trace((" Actually Integer String\n"));
                V_VT(&m_vTypedConst) = VT_BSTR;
                V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
				if ( V_BSTR(&m_vTypedConst) == NULL )
				{
					throw CX_MemoryException();
				}

                m_bConstIsStrNumeric = TRUE;
            }
        }
        else
        {
            //positive

            if ((x < 10) ||
                ((x == 10) && (wcscmp(m_pTokenText, L"2147483647") <= 0)))
            {
                V_VT(&m_vTypedConst) = VT_I4;
                V_I4(&m_vTypedConst) = _wtol(m_pTokenText);
            }
            else
            {
                trace((" Actually Integer String\n"));
                V_VT(&m_vTypedConst) = VT_BSTR;
                V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
				if ( V_BSTR(&m_vTypedConst) == NULL )
				{
					throw CX_MemoryException();
				}

                m_bConstIsStrNumeric = TRUE;
            }
        }

    }
    else if (m_nCurrentToken == SQL_1_TOK_QSTRING)
    {
        trace((" String\n"));
        V_VT(&m_vTypedConst) = VT_BSTR;
        V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
		if ( V_BSTR(&m_vTypedConst) == NULL )
		{
			throw CX_MemoryException();
		}
    }
    else if (m_nCurrentToken == SQL_1_TOK_REAL)
    {
        trace((" Real\n"));
        V_VT(&m_vTypedConst) = VT_R8;
        V_R8(&m_vTypedConst) = 0.0;

        if (m_pTokenText)
        {
            VARIANT varFrom;
            varFrom.vt = VT_BSTR;
            varFrom.bstrVal = SysAllocString(m_pTokenText);
            if(varFrom.bstrVal)
            {
                VariantClear(&m_vTypedConst);
                VariantInit(&m_vTypedConst);
                SCODE sc = VariantChangeTypeEx(&m_vTypedConst, &varFrom, 0, 0x409, VT_R8);
                VariantClear(&varFrom);

                if(sc != S_OK)
                {
                    VariantClear(&m_vTypedConst);
                    VariantInit(&m_vTypedConst);
                    return LEXICAL_ERROR;
                }
            }
			else
			{
				throw CX_MemoryException();
			}
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_BOOL)
    {
        trace((" Bool\n"));
        V_VT(&m_vTypedConst) = VT_BOOL;
        if (m_pTokenText && wbem_wcsicmp(m_pTokenText, L"65535") == 0)
        {
            V_BOOL(&m_vTypedConst) = VARIANT_TRUE;
        }
        else
            V_BOOL(&m_vTypedConst) = VARIANT_FALSE;
    }
    // Else, not a typed constant.
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <rel_operator> ::= <equiv_operator>;
//  <rel_operator> ::= <comp_operator>;
//
//***************************************************************************

int SQL1_Parser::rel_operator()
{
    if(SUCCESS == equiv_operator())
        return SUCCESS;
    else if (SUCCESS == comp_operator())
        return SUCCESS;
    else return LEXICAL_ERROR;
}

//***************************************************************************
//
//  <equiv_operator> ::= EQUIV_OPERATOR; // =, !=
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::equiv_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == SQL_1_TOK_EQ)
    {
        trace(("    REL OP =\n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUAL;
    }
    else if (m_nCurrentToken == SQL_1_TOK_NE)
    {
        trace(("    REL OP <> (!=) \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
    }
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <is_operator> ::= IS_OPERATOR; // is, isnot
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::is_operator()
{
    m_nRelOp = 0;
    if (m_nCurrentToken != SQL_1_TOK_IS)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == SQL_1_TOK_NOT)
    {
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        if (!Next())
            return LEXICAL_ERROR;

        trace(("    REL OP IS NOT \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        return SUCCESS;
    }
    else
    {
        trace(("    REL OP IS \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUAL;
        return SUCCESS;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <comp_operator> ::= COMP_OPERATOR; // <=, >=, <, >, like
//
//  Output: m_nRelOp is set to the correct operator for a SQL_LEVEL_1_TOKEN.
//
//***************************************************************************

int SQL1_Parser::comp_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == SQL_1_TOK_LE)
    {
        trace(("    REL OP <=\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
        }
        else
        {
            trace(("    REL OP changed to >=\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_LT)
    {
        trace(("    REL OP <\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LESSTHAN;
        }
        else
        {
            trace(("    REL OP changed to >\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_GREATERTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_GE)
    {
        trace(("    REL OP >=\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
        }
        else
        {
            trace(("    REL OP changed to <=\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_GT)
    {
        trace(("    REL OP >\n"));

        if (m_pIdent)
        {
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_GREATERTHAN;
        }
        else
        {
            trace(("    REL OP changed to <\n"));
            m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LESSTHAN;
        }
    }
    else if (m_nCurrentToken == SQL_1_TOK_LIKE)
    {
        trace(("    REL OP 'like' \n"));
        m_nRelOp = SQL_LEVEL_1_TOKEN::OP_LIKE;
    }
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  Expression and token structure methods.
//
//***************************************************************************

SQL_LEVEL_1_RPN_EXPRESSION::SQL_LEVEL_1_RPN_EXPRESSION()
{
    nNumTokens = 0;
    pArrayOfTokens = 0;
    bsClassName = 0;
    nNumberOfProperties = 0;
    pbsRequestedPropertyNames = 0;
    nCurSize = 32;
    nCurPropSize = 32;

    pArrayOfTokens = new SQL_LEVEL_1_TOKEN[nCurSize];
	if (! pArrayOfTokens)
		throw CX_MemoryException();

    pbsRequestedPropertyNames = new BSTR[nCurPropSize];
	if (! pbsRequestedPropertyNames)
		throw CX_MemoryException();
}

SQL_LEVEL_1_RPN_EXPRESSION::~SQL_LEVEL_1_RPN_EXPRESSION()
{
    delete [] pArrayOfTokens;
    if (bsClassName)
        SysFreeString(bsClassName);
    for (int i = 0; i < nNumberOfProperties; i++)
        SysFreeString(pbsRequestedPropertyNames[i]);
    delete pbsRequestedPropertyNames;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddToken(SQL_LEVEL_1_TOKEN *pTok)
{
	try
	{
	    AddToken(*pTok);
	}
	catch ( ... )
	{
		delete pTok;
		pTok = NULL;

		throw ;
	}

    delete pTok;
    pTok = NULL;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddToken(SQL_LEVEL_1_TOKEN &pTok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 32;
        SQL_LEVEL_1_TOKEN *pTemp = new SQL_LEVEL_1_TOKEN[nCurSize];
		if ( pTemp )
		{
			for (int i = 0; i < nNumTokens; i++)
				pTemp[i] = pArrayOfTokens[i];
			delete [] pArrayOfTokens;
			pArrayOfTokens = pTemp;
		}
		else
		{
			throw CX_MemoryException();
		}
    }

    pArrayOfTokens[nNumTokens++] = pTok;
}

void SQL_LEVEL_1_RPN_EXPRESSION::AddProperty (LPWSTR pProp)
{
    if (nCurPropSize == nNumberOfProperties)
    {
        nCurPropSize += 32;
        wmilib :: auto_ptr<BSTR> pTemp ( new BSTR[nCurPropSize] ) ;
        if (!pTemp.get())
            throw CX_MemoryException();

        if (pbsRequestedPropertyNames)
		{
            memcpy(pTemp.get(), pbsRequestedPropertyNames,
                sizeof(BSTR) * nNumberOfProperties);
		}
        else
        {
            throw CX_MemoryException();
        }

        delete pbsRequestedPropertyNames;
        pbsRequestedPropertyNames = pTemp.release();
    }

	BSTR pTemp = SysAllocString(pProp);
	if ( pTemp)
	{
		pbsRequestedPropertyNames[nNumberOfProperties++] = pTemp ;
	}
	else
	{
		throw CX_MemoryException();
	}

}

void SQL_LEVEL_1_RPN_EXPRESSION::Dump(const char *pszTextFile)
{
    FILE *f = fopen(pszTextFile, "wt");
    if (!f)
        return;

    fprintf(f, "----RPN Expression----\n");
    fprintf(f, "Class name = %S\n", bsClassName);
    fprintf(f, "Properties selected: ");

    if (!nNumberOfProperties)
    {
        fprintf(f, "* = all properties selected\n");
    }
    else for (int i = 0; i < nNumberOfProperties; i++)
    {
        fprintf(f, "%S ", pbsRequestedPropertyNames[i]);
    }
    fprintf(f, "\n------------------\n");
    fprintf(f, "Tokens:\n");

    for (int i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i].Dump(f);

    fprintf(f, "---end of expression---\n");
    fclose(f);
}

SQL_LEVEL_1_TOKEN::SQL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    pPropertyName = 0;
    pPropName2 = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bConstIsStrNumeric = FALSE;
}

SQL_LEVEL_1_TOKEN::SQL_LEVEL_1_TOKEN(SQL_LEVEL_1_TOKEN &Src)
{
    nTokenType = 0;
    pPropertyName = 0;
    pPropName2 = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bConstIsStrNumeric = FALSE;

    *this = Src;
}

SQL_LEVEL_1_TOKEN& SQL_LEVEL_1_TOKEN::operator =(SQL_LEVEL_1_TOKEN &Src)
{
    //first clear any old values...
    if (pPropertyName)
	{
        SysFreeString(pPropertyName);
		pPropertyName = NULL ;
	}

    if (pPropName2)
	{
        SysFreeString(pPropName2);
		pPropName2 = NULL ;
	}

    VariantClear(&vConstValue);

    nTokenType = Src.nTokenType;

	if ( Src.pPropertyName )
	{
		pPropertyName = SysAllocString(Src.pPropertyName);
		if ( ! pPropertyName )
		{
			throw CX_MemoryException();
		}
	}

    if (Src.pPropName2)
	{
		pPropName2 = SysAllocString(Src.pPropName2);
		if ( ! pPropName2 )
		{
			throw CX_MemoryException();
		}
	}

    nOperator = Src.nOperator;
    if ( FAILED ( VariantCopy(&vConstValue, &Src.vConstValue) ) )
	{
		throw CX_MemoryException();
	}

    dwPropertyFunction = Src.dwPropertyFunction;
    dwConstFunction = Src.dwConstFunction;
    bConstIsStrNumeric = Src.bConstIsStrNumeric;

    return *this;
}

SQL_LEVEL_1_TOKEN::~SQL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    if (pPropertyName)
        SysFreeString(pPropertyName);
    if (pPropName2)
        SysFreeString(pPropName2);

    nOperator = 0;
    VariantClear(&vConstValue);
}

void SQL_LEVEL_1_TOKEN::Dump(FILE *f)
{
    switch (nTokenType)
    {
        case OP_EXPRESSION:
            fprintf(f, "OP_EXPRESSION ");
            break;
        case TOKEN_AND:
            fprintf(f, "TOKEN_AND ");
            break;
        case TOKEN_OR:
            fprintf(f, "TOKEN_OR ");
            break;
        case TOKEN_NOT:
            fprintf(f, "TOKEN_NOT ");
            break;
        default:
            fprintf(f, "Error: no token type specified\n");
    }

    if (nTokenType == OP_EXPRESSION)
    {
        char *pOp = "<no op>";
        switch (nOperator)
        {
            case OP_EQUAL: pOp = "OP_EQUAL"; break;
            case OP_NOT_EQUAL: pOp = "OP_NOT_EQUAL"; break;
            case OP_EQUALorGREATERTHAN: pOp = "OP_EQUALorGREATERTHAN"; break;
            case OP_EQUALorLESSTHAN: pOp = "OP_EQUALorLESSTHAN"; break;
            case OP_LESSTHAN: pOp = "OP_LESSTHAN"; break;
            case OP_GREATERTHAN: pOp = "OP_GREATERTHAN"; break;
            case OP_LIKE: pOp = "OP_LIKE"; break;
        }

        fprintf(f, "    Property = %S\n", pPropertyName);
        fprintf(f, "    Operator = %s\n", pOp);
        fprintf(f, "    Value =    ");
        if (pPropName2)
            fprintf(f, "   <Property:%S\n", pPropName2);
        else
        {
            switch (V_VT(&vConstValue))
            {
                case VT_I4:
                    fprintf(f, "VT_I4 = %d\n", V_I4(&vConstValue));
                    break;
                case VT_BSTR:
                    fprintf(f, "VT_BSTR = %S\n", V_BSTR(&vConstValue));
                    break;
                case VT_R8:
                    fprintf(f, "VT_R8 = %f\n", V_R8(&vConstValue));
                    break;
                case VT_BOOL:
                    fprintf(f, "VT_BOOL = %d (%s)\n",
                        V_BOOL(&vConstValue),
                        V_BOOL(&vConstValue) == VARIANT_TRUE ? "VARIANT_TRUE" : "VARIANT_FALSE"
                        );
                    break;
                default:
                    fprintf(f, "<unknown>\n");
            }
        }

        switch (dwPropertyFunction)
        {
            case IFUNC_NONE:
                break;
            case IFUNC_LOWER:
                fprintf(f, "Intrinsic function LOWER() applied to property\n");
                break;
            case IFUNC_UPPER:
                fprintf(f, "Intrinsic function UPPER() applied to property\n");
                break;
        }
        switch (dwConstFunction)
        {
            case IFUNC_NONE:
                break;
            case IFUNC_LOWER:
                fprintf(f, "Intrinsic function LOWER() applied to const value\n");
                break;
            case IFUNC_UPPER:
                fprintf(f, "Intrinsic function UPPER() applied to const value\n");
                break;
        }

    }

    fprintf(f, " <end of token>\n");
}

/////////////////////////////////////////////////////////////////////////////
//
// Algorithm for evaluating the expression, assuming that it has been
// tokenized and translated to Reverse Polish.
//
// Starting point:  (a) An array of SQL tokens.
//                  (b) An empty boolean token stack.
//
// 1.  Read Next Token
//
// 2.  If a SIMPLE EXPRESSION, evaluate it to TRUE or FALSE, and
//     place this boolean result on the stack.  Go to 1.
//
// 3.  If an OR operator, then pop a boolean token into A,
//     pop another boolean token into B. If either A or B are TRUE,
//     stack TRUE.  Else stack FALSE.
//     Go to 1.
//
// 4.  If an AND operator, then pop a boolean token into A,
//     and pop another into B.  If both are TRUE, stack TRUE.
//     Else stack FALSE.
//     Go to 1.
//
// 5.  If a NOT operator, reverse the value of the top-of-stack boolean.
//     Go to 1.
//
// At end-of-input, the result is at top-of-stack.
//
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\sql_1.h ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    SQL_1.H

Abstract:

    Level 1 Syntax SQL Parser

History:

--*/

#ifndef _SQL_1_H_
#define _SQL_1_H_

struct SQL_LEVEL_1_TOKEN
{
    enum { OP_EXPRESSION = 1, TOKEN_AND, TOKEN_OR, TOKEN_NOT };
    enum { IFUNC_NONE = 0, IFUNC_UPPER = 1, IFUNC_LOWER = 2 };

    int nTokenType; //  OP_EXPRESSION,TOKEN_AND, TOKEN_OR, TOKEN_NOT
    

    // If the field is a OP_EXPRESSION, then the following are used.
    enum { OP_EQUAL = 1, OP_NOT_EQUAL, OP_EQUALorGREATERTHAN,
		       OP_EQUALorLESSTHAN, OP_LESSTHAN, OP_GREATERTHAN, OP_LIKE };
    
    BSTR    pPropertyName;		// Name of the property on which the operator is applied
    int     nOperator;			// Operator that is applied on property
    BOOL	bConstIsStrNumeric;	// True if the vConstValue is a BSTR and is a UINT32 or any 64bit number
	VARIANT vConstValue;		// Value applied by operator
    BSTR    pPropName2;         // Property compared to.

    DWORD   dwPropertyFunction; // 0=no instrinsic function applied
    DWORD   dwConstFunction;    // "
    
    SQL_LEVEL_1_TOKEN();
    SQL_LEVEL_1_TOKEN(SQL_LEVEL_1_TOKEN&);
   ~SQL_LEVEL_1_TOKEN(); 
    SQL_LEVEL_1_TOKEN& operator=(SQL_LEVEL_1_TOKEN &Src);
    
    void Dump(FILE *);
};


// Contains RPN version of expression.
// ===================================

struct SQL_LEVEL_1_RPN_EXPRESSION
{
    int nNumTokens;
    int nCurSize;
    SQL_LEVEL_1_TOKEN *pArrayOfTokens;
    BSTR bsClassName;

	int nNumberOfProperties;          // Zero means all properties selected
    int nCurPropSize;
	BSTR *pbsRequestedPropertyNames;  // Array of property names which values are to be returned if
    
    SQL_LEVEL_1_RPN_EXPRESSION();
   ~SQL_LEVEL_1_RPN_EXPRESSION();
   
   //Note: this method deletes the token it is passed as an argument
    void AddToken(SQL_LEVEL_1_TOKEN *pTok);
    void AddToken(SQL_LEVEL_1_TOKEN &pTok);
    void AddProperty(LPWSTR pProp);
    void Dump(const char *pszTextFile);
};


class SQL1_Parser
{
    CGenLexer *m_pLexer;
    int        m_nLine;
    wchar_t*   m_pTokenText;
    int        m_nCurrentToken;
    SQL_LEVEL_1_RPN_EXPRESSION* m_pExpression;

	//Cleanup used by d'tor and SetSource
	void Cleanup();

	//Init used by c'tor and SetSource
	void Init(CGenLexSource *pSrc);

    // Semantic transfer variables.
    // ============================
    VARIANT    m_vTypedConst;
    int        m_nRelOp;
    DWORD      m_dwConstFunction;
    DWORD      m_dwPropFunction;
    LPWSTR     m_pIdent;
    LPWSTR     m_pPropComp;
	BOOL       m_bConstIsStrNumeric;
        
    // Parsing functions.
    // ==================
    BOOL Next();
    
    int parse();

    int prop_list();
    int class_name();
    int opt_where();
    int expr();
    int property_name();
    int prop_list_2();
    int term();
    int expr2();
    int simple_expr();
    int term2();
    int leading_ident_expr();
    int finalize();
    int rel_operator();
    int equiv_operator();
    int comp_operator();
    int is_operator();
    int trailing_prop_expr();
    int trailing_prop_expr2();
    int trailing_or_null();
    int trailing_const_expr();
    int unknown_func_expr();
    int typed_constant();

public:
    enum { 
        SUCCESS,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL
        };

    SQL1_Parser(CGenLexSource *pSrc);
   ~SQL1_Parser();

    int GetQueryClass(LPWSTR pBuf, int nBufSize);
       
    int Parse(SQL_LEVEL_1_RPN_EXPRESSION **pOutput);
        // use operator delete on pOutput
            
    int CurrentLine() { return m_nLine; }
    LPWSTR CurrentToken() { return m_pTokenText; }
	void SetSource(CGenLexSource *pSrc);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\stdlibrary\test_par.cpp ===
/*++

Copyright  Microsoft Corporation.  All rights reserved.

Module Name:

    test_par.cpp

Abstract:

    Test program for CObjectPathParser objects

History:

--*/

#include "precomp.h"
#include "genlex.h"
#include "objpath.h"

BOOL bVerbose = FALSE;

void fatal(int n)
{
    printf("\n*** Test failed on source line %d ***\n", n);
    exit(1);
}

void DisplayVariant(VARIANT * pvar)
{
    SCODE sc;
    VARTYPE vSave;
    VARTYPE vtSimple = pvar->vt & ~VT_ARRAY & ~VT_BYREF;

    VARIANT vTemp;
    if(pvar->vt == VT_NULL)
    {
        printf(" data is NULL");
        return;
    }

     // keep in mind that our bstr are acutally WCHAR * in this context.

     if(vtSimple == VT_BSTR)
     {
         printf(" Type is 0x%x, value is %S", pvar->vt, pvar->bstrVal);
         return;
     }


    VariantInit(&vTemp);
    vSave = pvar->vt;
    pvar->vt = vtSimple;
    sc = VariantChangeTypeEx(&vTemp, pvar,0,0, VT_BSTR);
    pvar->vt = vSave;
    if(sc == S_OK)
    {
        printf(" Type is 0x%x, value is %S", pvar->vt, vTemp.bstrVal);
    }
    else
        printf(" Couldnt convert type 0x%x, error code 0x%x", pvar->vt, sc);
    VariantClear(&vTemp);
}

void DumpIt(WCHAR * pTest, ParsedObjectPath * pOutput)
{
    DWORD dwCnt;
    if(!bVerbose)
        return;
    printf("\n\nTesting -%S-", pTest);
    if(pOutput == NULL)
        return;
    printf("\nClass is, %S, Singleton is %d", pOutput->m_pClass, pOutput->m_bSingletonObj);
    printf("\nNumber of keys is %d", pOutput->m_dwNumKeys);
    for(dwCnt = 0; dwCnt < pOutput->m_dwNumKeys; dwCnt++)
    {
        printf(" -%S-", pOutput->m_paKeys[dwCnt]->m_pName);
        DisplayVariant((&pOutput->m_paKeys[dwCnt]->m_vValue));
    
    }
    printf("\nNumber of namespaces is %d", pOutput->m_dwNumNamespaces);
    for(dwCnt = 0; dwCnt < pOutput->m_dwNumNamespaces; dwCnt++)
        printf(" -%S-", pOutput->m_paNamespaces[dwCnt]);
}

// this tests a normal single key path

void test1()
{
    int iRet;
    ParsedObjectPath * pOutput;
    WCHAR * pTest = L"\\\\.\\root\\default:MyClass=\"a\"";
    WCHAR * pRet = NULL;
    CObjectPathParser p;
    iRet = p.Parse(pTest, &pOutput);
    if(iRet != CObjectPathParser::NoError)
        fatal(__LINE__);
    DumpIt(pTest, pOutput);
    if(_wcsicmp(pOutput->m_pClass,L"MyClass"))
        fatal(__LINE__);
    if(pOutput->m_dwNumKeys != 1)
        fatal(__LINE__);
    if(pOutput->m_bSingletonObj)
        fatal(__LINE__);
    p.Unparse(pOutput, &pRet);
    printf("\nUnparse -%S-", pRet);
//  if(_wcsicmp(pTest, pRet))
//      fatal(__LINE__);
    delete pRet;
    delete pOutput;
}


// this tests a singleton

void test2()
{
    int iRet;
    ParsedObjectPath * pOutput;
    CObjectPathParser p;
    WCHAR * pTest = L"\\\\.\\root\\default:MyClass=@";
    WCHAR * pRet = NULL;

    iRet = p.Parse(pTest, &pOutput);
    if(iRet != CObjectPathParser::NoError)
        fatal(__LINE__);
    DumpIt(pTest, pOutput);
    if(_wcsicmp(pOutput->m_pClass,L"MyClass"))
        fatal(__LINE__);
    if(pOutput->m_dwNumKeys != 0)
        fatal(__LINE__);
    if(!pOutput->m_bSingletonObj)
        fatal(__LINE__);
    p.Unparse(pOutput, &pRet);
    printf("\nUnparse -%S-", pRet);
//  if(_wcsicmp(pTest, pRet))
//      fatal(__LINE__);

    delete pRet;
    delete pOutput;
}

// this tests a multiple key path

void test3()
{
    int iRet;
    ParsedObjectPath * pOutput;
    CObjectPathParser p;
    WCHAR * pTest = L"\\\\.\\root\\default:MyClass.key=23,key2=\"xx\"";
    WCHAR * pRet = NULL;

    iRet = p.Parse(pTest, &pOutput);
    if(iRet != CObjectPathParser::NoError)
        fatal(__LINE__);
    DumpIt(pTest, pOutput);
    if(_wcsicmp(pOutput->m_pClass,L"MyClass"))
        fatal(__LINE__);
    if(pOutput->m_dwNumKeys != 2)
        fatal(__LINE__);
    if(pOutput->m_bSingletonObj)
        fatal(__LINE__);
    p.Unparse(pOutput, &pRet);
    printf("\nUnparse -%S-", pRet);
//  if(_wcsicmp(pTest, pRet))
//      fatal(__LINE__);
    delete pRet;
    delete pOutput;
}

// this tests an error in a single key path - missing closing quote

void test4()
{
    int iRet;
    ParsedObjectPath * pOutput;
    CObjectPathParser p;
    WCHAR * pTest = L"\\\\.\\root\\default:MyClass=\"hello";
    WCHAR * pRet = NULL;

    iRet = p.Parse(pTest, &pOutput);
    if(iRet == CObjectPathParser::NoError)
        fatal(__LINE__);
}

// this tests forward path slashes and a mix of slashes in the key

void test5()
{
    int iRet;
    ParsedObjectPath * pOutput;
    WCHAR * pTest = L"//./root/default:MyClass.key=\"ab/c\\\\def\"";    // it takes four '\'s within a quoted string to yield a single '\'
    WCHAR * pRet = NULL;
    CObjectPathParser p;
    iRet = p.Parse(pTest, &pOutput);
    if(iRet != CObjectPathParser::NoError)
        fatal(__LINE__);
    DumpIt(pTest, pOutput);
    if(_wcsicmp(pOutput->m_pClass,L"MyClass"))
        fatal(__LINE__);
    if(pOutput->m_dwNumKeys != 1)
        fatal(__LINE__);
    if(pOutput->m_bSingletonObj)
        fatal(__LINE__);
    p.Unparse(pOutput, &pRet);
    printf("\nUnparse -%S-", pRet);
//  if(_wcsicmp(pTest, pRet))
//      fatal(__LINE__);
    delete pRet;
    delete pOutput;
}

// This tests unicode

void test6()
{
    int iRet;
    ParsedObjectPath * pOutput;
    WCHAR * pTest = L"//./root/\x0100xde\231faul\xffef:MyClass.\x0100\231\xffef=\"\x0100\xffef\"";
    WCHAR * pRet = NULL;
    CObjectPathParser p;
    iRet = p.Parse(pTest, &pOutput);
    if(iRet != CObjectPathParser::NoError)
        fatal(__LINE__);

    // note that the dump will not output much information since printf doesnt like unicode

    DumpIt(pTest, pOutput);
    if(_wcsicmp(pOutput->m_pClass,L"MyClass"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paNamespaces[0],L"root"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paNamespaces[1],L"\x0100xde\231faul\xffef"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paKeys[0]->m_pName,L"\x0100\231\xffef"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paKeys[0]->m_vValue.bstrVal,L"\x0100\xffef"))
        fatal(__LINE__);

    if(pOutput->m_dwNumKeys != 1)
        fatal(__LINE__);
    if(pOutput->m_bSingletonObj)
        fatal(__LINE__);
    p.Unparse(pOutput, &pRet);
    printf("\nUnparse -%S-", pRet);
//  if(_wcsicmp(pTest, pRet))
//      fatal(__LINE__);
    delete pRet;
    delete pOutput;
}

// This tests association type paths

void test7()
{
    int iRet;
    ParsedObjectPath * pOutput;
    WCHAR * pTest = L"\\\\.\\root\\default:Win32Users.Ant=\"\\\\\\\\WKSTA\\\\root\\\\default:System.Name=\\\"WKSTA\\\"\",Dep=\"Win32User.Name=\\\".Default\\\"\"";
    WCHAR * pRet = NULL;
    CObjectPathParser p;
    iRet = p.Parse(pTest, &pOutput);
    if(iRet != CObjectPathParser::NoError)
        fatal(__LINE__);

    // note that the dump will not output much information since printf doesnt like unicode

    DumpIt(pTest, pOutput);
    if(_wcsicmp(pOutput->m_pClass,L"Win32Users"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paNamespaces[0],L"root"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paNamespaces[1],L"default"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paKeys[0]->m_pName,L"Ant"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paKeys[0]->m_vValue.bstrVal,
            L"\\\\WKSTA\\root\\default:System.Name=\"WKSTA\""))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paKeys[1]->m_pName,L"Dep"))
        fatal(__LINE__);
    if(_wcsicmp(pOutput->m_paKeys[1]->m_vValue.bstrVal,L"Win32User.Name=\".Default\""))
        fatal(__LINE__);


    if(pOutput->m_dwNumKeys != 2)
        fatal(__LINE__);
    if(pOutput->m_bSingletonObj)
        fatal(__LINE__);
    p.Unparse(pOutput, &pRet);
    printf("\nUnparse -%S-", pRet);
//  if(_wcsicmp(pTest, pRet))
//      fatal(__LINE__);
    delete pRet;
    delete pOutput;
}


int main(int argc, char **argv)
{
    int i;
    bVerbose = TRUE;
    for(i = 0; i< 1; i++)
    {
        printf("\ndoing test %d",i);
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\assertbreak.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  AssertBreak.cpp
//
//  Purpose: AssertBreak macro definition
//
//***************************************************************************

#include "precomp.h"

#if defined(_DEBUG) || defined(DEBUG)
#include <polarity.h>
#include <assertbreak.h>
#ifdef UTILLIB
#include <cregcls.h>
#endif
#include <chstring.h>
#include <malloc.h>

#include <cnvmacros.h>

////////////////////////////////////////////////////////////////////////
//
//  Function:   assert_break
//
//  Debug Helper function for displaying a message box
//
//  Inputs:     const char* pszReason - Reason for the  failure.
//              const char* pszFilename - Filename
//              int         nLine - Line Number
//
//  Outputs:    None.
//
//  Return:     None.
//
//  Comments:   None.
//
////////////////////////////////////////////////////////////////////////
void WINAPI assert_break( LPCWSTR pszReason, LPCWSTR pszFileName, int nLine )
{
    
    DWORD t_dwFlag = 0; //

#ifdef UTILLIB
    CRegistry   t_Reg;
    if(t_Reg.Open(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    KEY_READ) == ERROR_SUCCESS) 
    {

        // see if we can find the flag
        if((t_Reg.GetCurrentKeyValue(L"IgnoreAssert", t_dwFlag) != ERROR_SUCCESS))
        {
            t_dwFlag = 0;
        }
    }

#endif

    if (t_dwFlag == 0)
    {
        CHString    strAssert;

        strAssert.Format( L"Assert Failed\n\n[%s:%d]\n\n%s\n\nBreak into Debugger?", pszFileName, nLine, pszReason );

        // Set the MB flags correctly depending on which OS we are running on, since in NT we may
        // be running as a System Service, in which case we need to ensure we have the
        // MB_SERVICE_NOTIFICATION flag on, or the message box may not actually display.

        DWORD dwFlags = MB_YESNO | MB_ICONSTOP;
		dwFlags |= MB_SERVICE_NOTIFICATION;

        // Now display the message box.

        int iRet = MessageBoxW( NULL, strAssert, L"Assertion Failed!", dwFlags);
#ifdef DBG
        if (iRet == IDYES)
        {
            DebugBreak();
        }
#endif
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\analyser.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  analyser.cpp
//
//  Purpose: Performs query analysis
//
//***************************************************************************

#include "precomp.h"
#pragma warning( disable : 4290 ) 
#include <CHString.h>

#include "analyser.h"
#include <stack>
#include <vector>
#include <comdef.h>
#include <scopeguard.h>
#include <autoptr.h>

void AutoDestructStack(std::stack<SQL_LEVEL_1_RPN_EXPRESSION*>& X  ) 
{
        while(!X.empty())       
        {                       
            delete X.top();     
            X.pop();            
        }                       
}

HRESULT CQueryAnalyser::GetNecessaryQueryForProperty (

    IN SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
    IN LPCWSTR wszPropName,
    DELETE_ME SQL_LEVEL_1_RPN_EXPRESSION *&pNewExpr
)
{
    pNewExpr = NULL ;

    // Class name and selected properties are ignored; we look at tokens only
    // ======================================================================

    std::stack<SQL_LEVEL_1_RPN_EXPRESSION*> ExprStack;
	ScopeGuard clearStack = MakeGuard(AutoDestructStack, ByRef(ExprStack));
	
    HRESULT hres = WBEM_S_NO_ERROR;

    // "Evaluate" the query
    // ====================

    if(pExpr->nNumTokens == 0)
    {
        // Empty query --- no information
        // ==============================

        pNewExpr = new SQL_LEVEL_1_RPN_EXPRESSION;
        if ( ! pNewExpr )
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

        return WBEM_S_NO_ERROR;
    }

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        SQL_LEVEL_1_TOKEN &Token = pExpr->pArrayOfTokens[i];
        wmilib::auto_ptr<SQL_LEVEL_1_RPN_EXPRESSION> pNew(new SQL_LEVEL_1_RPN_EXPRESSION);
        if ( pNew.get() )
        {
            switch(Token.nTokenType)
            {
                case SQL_LEVEL_1_TOKEN::OP_EXPRESSION:
                {
                    if(IsTokenAboutProperty(Token, wszPropName))
                    {
                        wmilib::auto_ptr<SQL_LEVEL_1_TOKEN> pToken(new SQL_LEVEL_1_TOKEN(Token));
                        if ( pToken.get() )
                        {
                            pNew->AddToken(pToken.get());
                            pToken.release();
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }

                    ExprStack.push(pNew.get());
                    pNew.release();
                }
                break;

                case SQL_LEVEL_1_TOKEN::TOKEN_AND:
                {
                    if(ExprStack.size() < 2)
                    {
                        hres = WBEM_E_CRITICAL_ERROR;
                        break;
                    }

                    wmilib::auto_ptr<SQL_LEVEL_1_RPN_EXPRESSION> pFirst(ExprStack.top()); 
                    ExprStack.pop();

                    wmilib::auto_ptr<SQL_LEVEL_1_RPN_EXPRESSION> pSecond(ExprStack.top()); 
                    ExprStack.pop();

                    hres = AndQueryExpressions(pFirst.get(), pSecond.get(), pNew.get());

                    ExprStack.push(pNew.get());
                    pNew.release();
                }
                break;

                case SQL_LEVEL_1_TOKEN::TOKEN_OR:
                {
                    if(ExprStack.size() < 2)
                    {
                        hres = WBEM_E_CRITICAL_ERROR;
                        break;
                    }

                    wmilib::auto_ptr<SQL_LEVEL_1_RPN_EXPRESSION> pFirst(ExprStack.top()); 
                    ExprStack.pop();

                    wmilib::auto_ptr<SQL_LEVEL_1_RPN_EXPRESSION> pSecond(ExprStack.top()); 
                    ExprStack.pop();

                    hres = OrQueryExpressions(pFirst.get(), pSecond.get(), pNew.get());

                    ExprStack.push(pNew.get());
                    pNew.release();
                }
                break;

                case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
                {
                    if(ExprStack.size() < 1)
                    {
                        hres = WBEM_E_CRITICAL_ERROR;
                        break;
                    }

                    wmilib::auto_ptr<SQL_LEVEL_1_RPN_EXPRESSION> pFirst(ExprStack.top()); 
                    ExprStack.pop();

                    // No information

                    ExprStack.push(pNew.get());
                    pNew.release();
                }
                break;

                default:
                {
                    hres = WBEM_E_CRITICAL_ERROR;
                }
                break ;
            }

            if(FAILED(hres))
            {
                // An error occurred, break out of the loop
                // ========================================
                break;
            }
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
    
    if(SUCCEEDED(hres) && ExprStack.size() != 1)
    {
        hres = WBEM_E_CRITICAL_ERROR;
    }
        
    if(FAILED(hres))
    {
    	return hres;
    	// The guard will take care of stack
    	
    }

    // All is good
    // ===========
    pNewExpr = ExprStack.top();
    clearStack.Dismiss();

    return S_OK;
}

BOOL CQueryAnalyser::IsTokenAboutProperty (

   IN SQL_LEVEL_1_TOKEN &Token,
   IN LPCWSTR wszPropName
)
{
    return (wbem_wcsicmp(wszPropName, Token.pPropertyName) == 0);
}

void CQueryAnalyser::AppendQueryExpression (

    IN SQL_LEVEL_1_RPN_EXPRESSION *pDest,
    IN SQL_LEVEL_1_RPN_EXPRESSION *pSource
)
{
    for(int i = 0; i < pSource->nNumTokens; i++)
    {
        SQL_LEVEL_1_TOKEN *pToken = new SQL_LEVEL_1_TOKEN(pSource->pArrayOfTokens[i]);
        if ( pToken )
        {
            pDest->AddToken(pToken);
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
}

HRESULT CQueryAnalyser::AndQueryExpressions (

    IN SQL_LEVEL_1_RPN_EXPRESSION *pFirst,
    IN SQL_LEVEL_1_RPN_EXPRESSION *pSecond,
    OUT SQL_LEVEL_1_RPN_EXPRESSION *pNew
)
{
    // If either one is empty, take the other
    // ======================================

    if(pFirst->nNumTokens == 0)
    {
        AppendQueryExpression(pNew, pSecond);
        return WBEM_S_NO_ERROR;
    }

    if(pSecond->nNumTokens == 0)
    {
        AppendQueryExpression(pNew, pFirst);
        return WBEM_S_NO_ERROR;
    }

    // Both are there --- and together
    // ===============================

    AppendQueryExpression(pNew, pFirst);
    AppendQueryExpression(pNew, pSecond);

    SQL_LEVEL_1_TOKEN Token;
    Token.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_AND;
    SQL_LEVEL_1_TOKEN *pToken = new SQL_LEVEL_1_TOKEN(Token);
    if ( pToken )
    {
        pNew->AddToken(pToken);
    }
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::OrQueryExpressions (

    IN SQL_LEVEL_1_RPN_EXPRESSION *pFirst,
    IN SQL_LEVEL_1_RPN_EXPRESSION *pSecond,
    OUT SQL_LEVEL_1_RPN_EXPRESSION *pNew
)
{
    // If either one is empty, so is the result
    // ======================================

    if(pFirst->nNumTokens == 0 || pSecond->nNumTokens == 0)
    {
        return WBEM_S_NO_ERROR;
    }

    // Both are there --- or together
    // ==============================

    AppendQueryExpression(pNew, pFirst);
    AppendQueryExpression(pNew, pSecond);

    SQL_LEVEL_1_TOKEN Token;
    Token.nTokenType = SQL_LEVEL_1_TOKEN::TOKEN_OR;
    SQL_LEVEL_1_TOKEN *pToken = new SQL_LEVEL_1_TOKEN(Token);
    if ( pToken )
    {
        pNew->AddToken(pToken);
    }
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::GetValuesForProp (

    SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
    LPCWSTR wszPropName, 
    CHStringArray &awsVals
)
{
    awsVals.RemoveAll();

    // Get the necessary query
    // =======================

    SQL_LEVEL_1_RPN_EXPRESSION *pPropExpr = NULL ;
    HRESULT hres = CQueryAnalyser::GetNecessaryQueryForProperty (

        pExpr, 
        wszPropName, 
        pPropExpr
    );

    if(FAILED(hres))
    {
        return hres;
    }

    // See if there are any tokens
    // ===========================

    if(pPropExpr->nNumTokens == 0)
    {
        delete pPropExpr;
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }

    // Combine them all
    // ================

    for(int i = 0; i < pPropExpr->nNumTokens; i++)
    {
        SQL_LEVEL_1_TOKEN& Token = pPropExpr->pArrayOfTokens[i];
        switch ( Token.nTokenType )
        { 
            case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
            {
                delete pPropExpr;
                return WBEMESS_E_REGISTRATION_TOO_BROAD;
            }
            break ;

            case SQL_LEVEL_1_TOKEN::TOKEN_AND:
            case SQL_LEVEL_1_TOKEN::TOKEN_OR:
            {

            // We treat them all as ORs
            // ========================

            }
            break; 

            default:
            {
                // This is a token
                // ===============

                if(Token.nOperator != SQL_LEVEL_1_TOKEN::OP_EQUAL)
                {
                    delete pPropExpr;
                    return WBEMESS_E_REGISTRATION_TOO_BROAD;
                }

                // Skip NULLs, but report them.
                if (V_VT(&Token.vConstValue) == VT_NULL)
                {
                    hres = WBEM_S_PARTIAL_RESULTS;
                    continue;
                }

                if(V_VT(&Token.vConstValue) != VT_BSTR)
                {
                    delete pPropExpr;
                    return WBEM_E_TYPE_MISMATCH;
                }

                // This token is a string equality. Add the string to the list
                // ===========================================================

                awsVals.Add(CHString(V_BSTR(&Token.vConstValue)));
            }
            break ;
        }
    }

    delete pPropExpr;

    return hres;
}

HRESULT CQueryAnalyser::GetValuesForProp (

    SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
    LPCWSTR wszPropName, 
    std::vector<_bstr_t> &vectorVals
)
{
    vectorVals.erase(vectorVals.begin(),vectorVals.end());

    // Get the necessary query
    // =======================

    SQL_LEVEL_1_RPN_EXPRESSION *pPropExpr = NULL ;
    HRESULT hres = CQueryAnalyser::GetNecessaryQueryForProperty (

        pExpr, 
        wszPropName, 
        pPropExpr
    );

    if(FAILED(hres))
    {
        return hres;
    }

    // See if there are any tokens
    // ===========================

    if(pPropExpr->nNumTokens == 0)
    {
        delete pPropExpr;
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }

    // Combine them all
    // ================

    for(int i = 0; i < pPropExpr->nNumTokens; i++)
    {
        SQL_LEVEL_1_TOKEN& Token = pPropExpr->pArrayOfTokens[i];

        switch ( Token.nTokenType )
        {
            case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
            {
                delete pPropExpr;
                return WBEMESS_E_REGISTRATION_TOO_BROAD;
            }
            break ;

            case SQL_LEVEL_1_TOKEN::TOKEN_AND:
            case SQL_LEVEL_1_TOKEN::TOKEN_OR:
            {
            // We treat them all as ORs
            // ========================
            }
            break ;

            default:
            {
                // This is a token
                // ===============

                if(Token.nOperator != SQL_LEVEL_1_TOKEN::OP_EQUAL)
                {
                    delete pPropExpr;
                    return WBEMESS_E_REGISTRATION_TOO_BROAD;
                }

                // Skip NULLs, but report them.
                if (V_VT(&Token.vConstValue) == VT_NULL)
                {
                    hres = WBEM_S_PARTIAL_RESULTS;
                    continue;
                }

                if(V_VT(&Token.vConstValue) != VT_BSTR)
                {
                    delete pPropExpr;
                    return WBEM_E_INVALID_QUERY;
                }

                // This token is a string equality. Add the string to the list
                // ===========================================================

                vectorVals.push_back(_bstr_t(V_BSTR(&Token.vConstValue)));
            }   
            break ;
        }
    }

    delete pPropExpr;

    return hres;
}


HRESULT CQueryAnalyser::GetValuesForProp (

    SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
    LPCWSTR wszPropName, 
    std::vector<int> &vectorVals
)
{
    vectorVals.erase(vectorVals.begin(),vectorVals.end());

    // Get the necessary query
    // =======================

    SQL_LEVEL_1_RPN_EXPRESSION *pPropExpr = NULL ;
    HRESULT hres = CQueryAnalyser::GetNecessaryQueryForProperty (

        pExpr, 
        wszPropName, 
        pPropExpr
    );

    if(FAILED(hres))
    {
        return hres;
    }

    // See if there are any tokens
    // ===========================

    if(pPropExpr->nNumTokens == 0)
    {
        delete pPropExpr;
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }

    // Combine them all
    // ================

    for(int i = 0; i < pPropExpr->nNumTokens; i++)
    {
        SQL_LEVEL_1_TOKEN &Token = pPropExpr->pArrayOfTokens[i];
        switch ( Token.nTokenType )
        {
            case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
            {
                delete pPropExpr;
                return WBEMESS_E_REGISTRATION_TOO_BROAD;
            }
            break ;

            case SQL_LEVEL_1_TOKEN::TOKEN_AND:
            case SQL_LEVEL_1_TOKEN::TOKEN_OR:
            {
                // We treat them all as ORs
                // ========================
            }
            break ;

            default:
            {
                // This is a token
                // ===============

                if(Token.nOperator != SQL_LEVEL_1_TOKEN::OP_EQUAL)
                {
                    delete pPropExpr;
                    return WBEMESS_E_REGISTRATION_TOO_BROAD;
                }

                // Skip NULLs, but report them.
                if (V_VT(&Token.vConstValue) == VT_NULL)
                {
                    hres = WBEM_S_PARTIAL_RESULTS;
                    continue;
                }

                if(V_VT(&Token.vConstValue) != VT_I4)
                {
                    delete pPropExpr;
                    return WBEM_E_INVALID_QUERY;
                }

                // This token is an int equality. Add the string to the list
                // ===========================================================

                vectorVals.push_back(V_I4(&Token.vConstValue));
            }
            break ;
        }
    }

    delete pPropExpr;

    return hres;
}

HRESULT CQueryAnalyser::GetValuesForProp (

    SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
    LPCWSTR wszPropName, 
    std::vector<_variant_t> &vectorVals
)
{
    vectorVals.erase(vectorVals.begin(),vectorVals.end());

    // Get the necessary query
    // =======================

    SQL_LEVEL_1_RPN_EXPRESSION *pPropExpr = NULL ;
    HRESULT hres = CQueryAnalyser::GetNecessaryQueryForProperty (

        pExpr, 
        wszPropName, 
        pPropExpr
    );

    if(FAILED(hres))
    {
        return hres;
    }

    // See if there are any tokens
    // ===========================

    if(pPropExpr->nNumTokens == 0)
    {
        delete pPropExpr;
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }

    // Combine them all
    // ================

    for(int i = 0; i < pPropExpr->nNumTokens; i++)
    {
        SQL_LEVEL_1_TOKEN &Token = pPropExpr->pArrayOfTokens[i];
        switch ( Token.nTokenType )
        {
            case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
            {
                delete pPropExpr;
                return WBEMESS_E_REGISTRATION_TOO_BROAD;
            }
            break ;

            case SQL_LEVEL_1_TOKEN::TOKEN_AND:
            case SQL_LEVEL_1_TOKEN::TOKEN_OR:
            {
                // We treat them all as ORs
                // ========================
            }
            break ;

            default:
            {
                // This is a token
                // ===============

                if(Token.nOperator != SQL_LEVEL_1_TOKEN::OP_EQUAL)
                {
                    delete pPropExpr;
                    return WBEMESS_E_REGISTRATION_TOO_BROAD;
                }

                // This token is a string equality. Add the string to the list
                // ===========================================================

                vectorVals.push_back(_variant_t(Token.vConstValue));
            }
            break ;
        }
    }

    delete pPropExpr;

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\autoimprevert.cpp ===
//
// Copyright  Microsoft Corporation.  All rights reserved.
//
// CImpersonate class implementation
// Created:  6/3/2000
// Author: khughes

#include <precomp.h>
#include <chstring.h>
#include "AutoImpRevert.h"



CAutoImpRevert::CAutoImpRevert(
    BOOL fOpenAsSelf)
  : m_hOriginalUser(INVALID_HANDLE_VALUE),
    m_dwLastError(ERROR_SUCCESS)
{
    GetCurrentImpersonation(fOpenAsSelf);
}


CAutoImpRevert::~CAutoImpRevert()
{
    if(m_hOriginalUser != INVALID_HANDLE_VALUE)
    {
        Revert();
    }
}


bool CAutoImpRevert::GetCurrentImpersonation(
    BOOL fOpenAsSelf)
{
    bool fRet = false;
    ::SetLastError(ERROR_SUCCESS);
    m_dwLastError = ERROR_SUCCESS;

    // Store the current user's handle...
    if(::OpenThreadToken(
        ::GetCurrentThread(),
        TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
        fOpenAsSelf,
        &m_hOriginalUser))
    {
        fRet = true;
    }
    else
    {
        m_dwLastError = ::GetLastError();
        if(m_dwLastError == ERROR_NO_TOKEN)
        {
            ::SetLastError(ERROR_SUCCESS);
            if(::ImpersonateSelf(SecurityImpersonation))
            {
                if(::OpenThreadToken(
                    ::GetCurrentThread(),
                    TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
                    fOpenAsSelf,
                    &m_hOriginalUser))
                {
                    fRet = true;
                    m_dwLastError = ERROR_SUCCESS;
                }
                else
                {
                    m_dwLastError = ::GetLastError();
                }
            }
            else
            {
                m_dwLastError = ::GetLastError();
            }
        }
    }

    return fRet;
}



bool CAutoImpRevert::Revert()
{
    bool fRet = false;

    if(m_hOriginalUser != INVALID_HANDLE_VALUE)
    {
        if(::ImpersonateLoggedOnUser(m_hOriginalUser))
        {
            CloseHandle(m_hOriginalUser);
            m_hOriginalUser = INVALID_HANDLE_VALUE;
            fRet = true;
        }
        else
        {
            m_dwLastError = ::GetLastError();
        }    
    }
    
    return fRet;    
}

DWORD CAutoImpRevert::LastError() const
{
    return m_dwLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\chptrarr.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  chptrarr.cpp
//
//  Purpose: Non-MFC CPtrArray class implementation
//
//***************************************************************************

//=================================================================

// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.
//===============================================================

#include "precomp.h"
#pragma warning( disable : 4290 ) 
#include <CHString.h>
#include <chptrarr.h>
#include <AssertBreak.h>

CHPtrArray::CHPtrArray () : m_pData ( NULL ) ,
                            m_nSize ( 0 ) ,
                            m_nMaxSize ( 0 ) , 
                            m_nGrowBy ( 0 )
{
}

CHPtrArray::~CHPtrArray()
{
    if ( m_pData )
    {
        delete [] (BYTE*) m_pData ;
    }
}

void CHPtrArray::SetSize(int nNewSize, int nGrowBy)
{
    ASSERT_BREAK(nNewSize >= 0) ;

    if (nGrowBy != -1)
    {
        m_nGrowBy = nGrowBy ;  // set new size
    }

    if (nNewSize == 0)
    {
        // shrink to nothing

        delete[] (BYTE*)m_pData ;
        m_pData = NULL ;
        m_nSize = m_nMaxSize = 0 ;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size

        m_pData = (void**) new BYTE[nNewSize * sizeof(void*)] ;
        if ( m_pData )
        {
            memset(m_pData, 0, nNewSize * sizeof(void*)) ;  // zero fill

            m_nSize = m_nMaxSize = nNewSize ;
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits

        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*)) ;
        }

        m_nSize = nNewSize ;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy ;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8)) ;
        }

        int nNewMax ;
        if (nNewSize < m_nMaxSize + nGrowBy)
        {
            nNewMax = m_nMaxSize + nGrowBy ;  // granularity
        }
        else
        {
            nNewMax = nNewSize ;  // no slush
        }

        ASSERT_BREAK(nNewMax >= m_nMaxSize) ;  // no wrap around

        void** pNewData = (void**) new BYTE[nNewMax * sizeof(void*)] ;
        if ( pNewData )
        {
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(void*)) ;

            // construct remaining elements
            ASSERT_BREAK(nNewSize > m_nSize) ;

            memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*)) ;

            // get rid of old stuff (note: no destructors called)
            delete[] (BYTE*)m_pData ;
            m_pData = pNewData ;
            m_nSize = nNewSize ;
            m_nMaxSize = nNewMax ;
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
}

int CHPtrArray::Append(const CHPtrArray& src)
{
    ASSERT_BREAK(this != &src) ;   // cannot append to itself

    int nOldSize = m_nSize ;
    SetSize(m_nSize + src.m_nSize) ;

    memcpy(m_pData + nOldSize, src.m_pData, src.m_nSize * sizeof(void*)) ;

    return nOldSize ;
}

void CHPtrArray::Copy(const CHPtrArray& src)
{
    ASSERT_BREAK(this != &src) ;   // cannot append to itself

    SetSize(src.m_nSize) ;

    memcpy(m_pData, src.m_pData, src.m_nSize * sizeof(void*)) ;

}

void CHPtrArray::FreeExtra()
{
    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size

        void** pNewData = NULL ;
        if (m_nSize != 0)
        {
            pNewData = (void**) new BYTE[m_nSize * sizeof(void*)] ;
            if ( pNewData )
            {
                // copy new data from old   
                memcpy(pNewData, m_pData, m_nSize * sizeof(void*)) ;
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData ;
        m_pData = pNewData ;
        m_nMaxSize = m_nSize ;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CHPtrArray::SetAtGrow(int nIndex, void* newElement)
{
    ASSERT_BREAK(nIndex >= 0) ;

    if (nIndex >= m_nSize)
    {
        SetSize(nIndex+1) ;
    }

    m_pData[nIndex] = newElement ;
}

void CHPtrArray::InsertAt(int nIndex, void* newElement, int nCount)
{
    ASSERT_BREAK(nIndex >= 0) ;    // will expand to meet need
    ASSERT_BREAK(nCount > 0) ;     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount) ;  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize ;
        SetSize(m_nSize + nCount) ;  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(void*)) ;

        // re-init slots we copied from

        memset(&m_pData[nIndex], 0, nCount * sizeof(void*)) ;

    }

    // insert new value in the gap
    ASSERT_BREAK(nIndex + nCount <= m_nSize) ;
    while (nCount--)
    {
        m_pData[nIndex++] = newElement ;
    }
}

void CHPtrArray::RemoveAt(int nIndex, int nCount)
{
    ASSERT_BREAK(nIndex >= 0) ;
    ASSERT_BREAK(nCount >= 0) ;
    ASSERT_BREAK(nIndex + nCount <= m_nSize) ;

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount) ;

    if (nMoveCount)
    {
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(void*)) ;
    }

    m_nSize -= nCount ;
}

void CHPtrArray::InsertAt(int nStartIndex, CHPtrArray* pNewArray)
{
    ASSERT_BREAK(pNewArray != NULL) ;
    ASSERT_BREAK(nStartIndex >= 0) ;

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize()) ;
        for (int i = 0 ; i < pNewArray->GetSize() ; i++)
        {
            SetAt(nStartIndex + i, pNewArray->GetAt(i)) ;
        }
    }
}

// Inline functions (from CArray)
//===============================

inline int CHPtrArray::GetSize() const { 

    return m_nSize ; 
}

inline int CHPtrArray::GetUpperBound() const { 

    return m_nSize-1 ; 
}

inline void CHPtrArray::RemoveAll() { 

    SetSize(0, -1) ; 
    return ;
}

inline void *CHPtrArray::GetAt(int nIndex) const { 

    ASSERT_BREAK(nIndex >= 0 && nIndex < m_nSize) ;
    return m_pData[nIndex] ; 
}

inline void CHPtrArray::SetAt(int nIndex, void * newElement) {
 
    ASSERT_BREAK(nIndex >= 0 && nIndex < m_nSize) ;
    m_pData[nIndex] = newElement ; 
    return ;
}

inline void *&CHPtrArray::ElementAt(int nIndex) { 
    
    ASSERT_BREAK(nIndex >= 0 && nIndex < m_nSize) ;
    return m_pData[nIndex] ; 
}

inline const void **CHPtrArray::GetData() const { 

    return (const void **) m_pData ; 
}

inline void **CHPtrArray::GetData() { 

    return (void **) m_pData ; 
}

inline int CHPtrArray::Add(void *newElement) { 

    int nIndex = m_nSize ;
    SetAtGrow(nIndex, newElement) ;
    return nIndex ; 
}

inline void *CHPtrArray::operator[](int nIndex) const { 

    return GetAt(nIndex) ; 
}

inline void *&CHPtrArray::operator[](int nIndex) { 

    return ElementAt(nIndex) ; 
}

// Diagnostics
//============

#ifdef _DEBUG

void CHPtrArray::AssertValid() const
{
    if (m_pData == NULL)
    {
        ASSERT_BREAK(m_nSize == 0) ;
        ASSERT_BREAK(m_nMaxSize == 0) ;
    }
    else
    {
        ASSERT_BREAK(m_nSize >= 0) ;
        ASSERT_BREAK(m_nMaxSize >= 0) ;
        ASSERT_BREAK(m_nSize <= m_nMaxSize) ;
    }
}
#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\common.inc ===
#######################################################################
#
# Copyright  Microsoft Corporation.  All rights reserved.
#
# utillib Makefile
#
########################################################################

TARGET=utillib.lib

RELEASE=LIB\$(RELDIR)

CFLAGS=$(CFLAGS) -DUTILLIB -D_MBCS -D_DLL -DUSE_POLARITY -DBUILDING_DLL -DWIN32 -D_WINDOWS /YXwindows.h /Fp$(objdir)\utillib.pch /GF

CINC=$(CINC)\
	-I$(DEFDRIVE)$(DEFDIR)\INCLUDE \
	-I$(DEFDRIVE)$(DEFDIR)\IDL \
	-I$(DEFDRIVE)$(DEFDIR)\IDL\$(OBJDIR) \
	-I$(DEFDRIVE)$(DEFDIR)\StdLibrary \
    -I$(DEFDRIVE)$(DEFDIR)\Win32Provider\Framework\include \

CPPFILES=\
	CRegCls.CPP \
	analyser.cpp \
	assertbreak.cpp \
	CHPtrArr.cpp \
	CHStrarr.CPP \
	CHString.CPP \
	utils.cpp \
	WbemTime.CPP \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\chstrarr.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  ChStrArr.CPP
//
//  Purpose: utility library version of MFC CStringArray
//
//***************************************************************************

/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#pragma warning( disable : 4290 ) 
#include <chstring.h>
#include <chstrarr.h>              
#include <AssertBreak.h>

extern LPCWSTR afxPchNil;
extern const CHString& afxGetEmptyCHString();

#define afxEmptyCHString afxGetEmptyCHString()


/////////////////////////////////////////////////////////////////////////////
// Special implementations for CHStrings
// it is faster to bit-wise copy a CHString than to call an official
// constructor - since an empty CHString can be bit-wise copied
/////////////////////////////////////////////////////////////////////////////
static inline void ConstructElement(CHString* pNewData)
{
    memcpy(pNewData, &afxEmptyCHString, sizeof(CHString));
}

/////////////////////////////////////////////////////////////////////////////
static inline void DestructElement(CHString* pOldData)
{
    pOldData->~CHString();
}

/////////////////////////////////////////////////////////////////////////////
static inline void CopyElement(CHString* pSrc, CHString* pDest)
{
    *pSrc = *pDest;
}

/////////////////////////////////////////////////////////////////////////////
static void ConstructElements(CHString* pNewData, int nCount)
{
    ASSERT_BREAK(nCount >= 0);

    while (nCount--)
    {
        ConstructElement(pNewData);
        pNewData++;
    }
}

/////////////////////////////////////////////////////////////////////////////
static void DestructElements(CHString* pOldData, int nCount)
{
    ASSERT_BREAK(nCount >= 0);

    while (nCount--)
    {
        DestructElement(pOldData);
        pOldData++;
    }
}

/////////////////////////////////////////////////////////////////////////////
static void CopyElements(CHString* pDest, CHString* pSrc, int nCount)
{
    ASSERT_BREAK(nCount >= 0);

    while (nCount--)
    {
        *pDest = *pSrc;
        ++pDest;
        ++pSrc;
    }
}

/////////////////////////////////////////////////////////////////////////////
CHStringArray::CHStringArray() :    m_pData ( NULL ) ,
                                    m_nSize ( 0 ) ,
                                    m_nMaxSize ( 0 ) ,
                                    m_nGrowBy ( 0 )

{
}

/////////////////////////////////////////////////////////////////////////////
CHStringArray::~CHStringArray()
{
    DestructElements(m_pData, m_nSize);
    delete[] (BYTE*)m_pData;
}

/////////////////////////////////////////////////////////////////////////////
void CHStringArray::SetSize(int nNewSize, int nGrowBy)
{
    ASSERT_BREAK(nNewSize >= 0);

    if (nGrowBy != -1)
    {
        m_nGrowBy = nGrowBy;  // set new size
    }

    if (nNewSize == 0)
    {
        // shrink to nothing

        DestructElements(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
#ifdef SIZE_T_MAX
        ASSERT_BREAK(nNewSize <= SIZE_T_MAX/sizeof(CHString));    // no overflow
#endif

        // create one with exact size

        m_pData = (CHString*) new BYTE[nNewSize * sizeof(CHString)];
        if ( m_pData )
        {
            ConstructElements(m_pData, nNewSize);

            m_nSize = m_nMaxSize = nNewSize;
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            ConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);

        }
        else if (m_nSize > nNewSize)  // destroy the old elements
        {
            DestructElements(&m_pData[nNewSize], m_nSize-nNewSize);
        }

        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }

        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
        {
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        }
        else
        {
            nNewMax = nNewSize;  // no slush
        }

        ASSERT_BREAK(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
        ASSERT_BREAK(nNewMax <= SIZE_T_MAX/sizeof(CHString)); // no overflow
#endif

        CHString* pNewData = (CHString*) new BYTE[nNewMax * sizeof(CHString)];
        if ( pNewData )
        {
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(CHString));

            // construct remaining elements
            ASSERT_BREAK(nNewSize > m_nSize);

            ConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

            // get rid of old stuff (note: no destructors called)
            delete[] (BYTE*)m_pData;
            m_pData = pNewData;
            m_nSize = nNewSize;
            m_nMaxSize = nNewMax;
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
int CHStringArray::Append(const CHStringArray& src)
{
    ASSERT_BREAK(this != &src);   // cannot append to itself

    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);

    CopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);

    return nOldSize;
}

/////////////////////////////////////////////////////////////////////////////
void CHStringArray::Copy(const CHStringArray& src)
{
    ASSERT_BREAK(this != &src);   // cannot append to itself

    SetSize(src.m_nSize);

    CopyElements(m_pData, src.m_pData, src.m_nSize);

}

/////////////////////////////////////////////////////////////////////////////
void CHStringArray::FreeExtra()
{
    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size

#ifdef SIZE_T_MAX
        ASSERT_BREAK(m_nSize <= SIZE_T_MAX/sizeof(CHString)); // no overflow
#endif

        CHString* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (CHString*) new BYTE[m_nSize * sizeof(CHString)];
            if ( pNewData )
            {
                // copy new data from old
                memcpy(pNewData, m_pData, m_nSize * sizeof(CHString));
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////
void CHStringArray::SetAtGrow(int nIndex, LPCWSTR newElement)
{
    ASSERT_BREAK(nIndex >= 0);

    if (nIndex >= m_nSize)
    {
        SetSize(nIndex+1);
    }

    m_pData[nIndex] = newElement;
}

/////////////////////////////////////////////////////////////////////////////
void CHStringArray::InsertAt(int nIndex, LPCWSTR newElement, int nCount)
{
    ASSERT_BREAK(nIndex >= 0);    // will expand to meet need
    ASSERT_BREAK(nCount > 0);     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount);  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(CHString));

        // re-init slots we copied from

        ConstructElements(&m_pData[nIndex], nCount);

    }

    // insert new value in the gap
    ASSERT_BREAK(nIndex + nCount <= m_nSize);
    while (nCount--)
    {
        m_pData[nIndex++] = newElement;
    }
}

/////////////////////////////////////////////////////////////////////////////
void CHStringArray::RemoveAt(int nIndex, int nCount)
{
    ASSERT_BREAK(nIndex >= 0);
    ASSERT_BREAK(nCount >= 0);
    ASSERT_BREAK(nIndex + nCount <= m_nSize);

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);

    DestructElements(&m_pData[nIndex], nCount);

    if (nMoveCount)
    {
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(CHString));
    }

    m_nSize -= nCount;
}

/////////////////////////////////////////////////////////////////////////////
void CHStringArray::InsertAt(int nStartIndex, CHStringArray* pNewArray)
{
    ASSERT_BREAK(pNewArray != NULL);
    ASSERT_BREAK(nStartIndex >= 0);

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
        {
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
        }
    }
}

#if (defined DEBUG || defined _DEBUG)
CHString CHStringArray::GetAt(int nIndex) const
{ 
    ASSERT_BREAK(nIndex >= 0 && nIndex < m_nSize);
    return m_pData[nIndex]; 
}

void CHStringArray::SetAt(int nIndex, LPCWSTR newElement)
{ 
    ASSERT_BREAK(nIndex >= 0 && nIndex < m_nSize);
    m_pData[nIndex] = newElement; 
}

CHString& CHStringArray::ElementAt(int nIndex)  
{ 
    ASSERT_BREAK(nIndex >= 0 && nIndex < m_nSize);
    return m_pData[nIndex]; 
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\chstring.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  CHSTRING.CPP
//
//  Purpose: utility library version of MFC CString
//
//***************************************************************************

#include "precomp.h"
#pragma warning( disable : 4290 ) 
#include <chstring.h>
#include <stdio.h>
#include <comdef.h>
#include <AssertBreak.h>
#include <ScopeGuard.h>
#define _wcsinc(_pc)    ((_pc)+1)

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

#define DEPRECATED 0

const CHString& afxGetEmptyCHString();

#define afxEmptyCHString afxGetEmptyCHString()

// Global data used for LoadString.
#if 0
HINSTANCE g_hModule = GetModuleHandle(NULL); // Default to use the process module.
#endif

#ifdef FRAMEWORK_ALLOW_DEPRECATED
void WINAPI SetCHStringResourceHandle(HINSTANCE handle)
{
    ASSERT_BREAK(DEPRECATED);
#if 0
    g_hModule = handle;
#endif
}
#endif

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines
/////////////////////////////////////////////////////////////////////////////
WCHAR afxChNil = '\0';

static DWORD GetPlatformID(void)
{
    OSVERSIONINFO version;

    version.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;
    GetVersionEx(&version);

    return version.dwPlatformId;
}

static DWORD s_dwPlatformID = GetPlatformID();

/////////////////////////////////////////////////////////////////////////////
// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
/////////////////////////////////////////////////////////////////////////////
static int rgInitData[] = { -1, 0, 0, 0 };
static CHStringData* afxDataNil = (CHStringData*)&rgInitData;
LPCWSTR afxPchNil = (LPCWSTR)(((BYTE*)&rgInitData)+sizeof(CHStringData));
/////////////////////////////////////////////////////////////////////////////
// special function to make EmptyString work even during initialization
/////////////////////////////////////////////////////////////////////////////
// special function to make afxEmptyString work even during initialization
const CHString& afxGetEmptyCHString()
{
    return *(CHString*)&afxPchNil; 
}


///////////////////////////////////////////////////////////////////////////////
// CHString conversion helpers (these use the current system locale)
///////////////////////////////////////////////////////////////////////////////
int  _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
    if (count == 0 && mbstr != NULL)
    {
        return 0;
    }

    int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1, mbstr, count, NULL, NULL);
    ASSERT_BREAK(mbstr != NULL || result <= (int)count);

    if (result > 0)
    {
        mbstr[result-1] = 0;
    }

    return result;
}

///////////////////////////////////////////////////////////////////////////////
int _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
    if (count == 0 && wcstr != NULL)
    {
        return 0;
    }

    int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,wcstr, count);
    ASSERT_BREAK(wcstr != NULL || result <= (int)count);
    
    if (result > 0)
    {
        wcstr[result-1] = 0;
    }

    return result;
}

///////////////////////////////////////////////////////////////////////////////
//*************************************************************************
//
//  THE CHSTRING CLASS:   PROTECTED MEMBER FUNCTIONS
//
//*************************************************************************
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// implementation helpers
///////////////////////////////////////////////////////////////////////////////
CHStringData* CHString::GetData() const
{
    if( m_pchData == (WCHAR*)*(&afxPchNil)) 
    {
        return (CHStringData *)afxDataNil;
    }

    return ((CHStringData*)m_pchData)-1; 
}

//////////////////////////////////////////////////////////////////////////////
//
//  Function:       Init
//
//  Description:    This function initializes the data ptr
//
///////////////////////////////////////////////////////////////////////////////
void CHString::Init()
{
    m_pchData = (WCHAR*)*(&afxPchNil);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Function:       AllocCopy
//
//  Description:    This function will clone the data attached to this 
//                  string allocating 'nExtraLen' characters, it places
//                  results in uninitialized string 'dest' and will copy
//                  the part or all of original data to start of new string
//
//////////////////////////////////////////////////////////////////////////////
void CHString::AllocCopy( CHString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const
{
    int nNewLen = nCopyLen + nExtraLen;
    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(WCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Function:       AllocBuffer
//
//  Description:    Always allocate one extra character for '\0' 
//                  termination.  assumes [optimistically] that 
//                  data length will equal allocation length
//
//////////////////////////////////////////////////////////////////////////////
void CHString::AllocBuffer(int nLen)
{
    ASSERT_BREAK(nLen >= 0);
    ASSERT_BREAK(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

    if (nLen == 0)
    {
        Init();
    }
    else
    {
        CHStringData* pData = (CHStringData*)new BYTE[sizeof(CHStringData) + (nLen+1)*sizeof(WCHAR)];
        if ( pData )
        {
            pData->nRefs = 1;
            pData->data()[nLen] = '\0';
            pData->nDataLength = nLen;
            pData->nAllocLength = nLen;
            m_pchData = pData->data();
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Function:       AssignCopy
//
//  Description:    Assigns a copy of the string to the current data ptr
//                  
//
//////////////////////////////////////////////////////////////////////////////
void CHString::AssignCopy(int nSrcLen, LPCWSTR lpszSrcData)
{
    // Call this first, it will release the buffer if it has
    // already been allocated and no one is using it
    AllocBeforeWrite(nSrcLen);

    // Now, check to see if the nSrcLen is > 0, if it is, then
    // continue, otherwise, go ahead and return
    if( nSrcLen > 0 )
    {
        memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(WCHAR));
        GetData()->nDataLength = nSrcLen;
        m_pchData[nSrcLen] = '\0';
    }
    else
    {
        Release();
    }        
}

//////////////////////////////////////////////////////////////////////////////
// 
//  ConcatCopy
//
//  Description:    This is the master concatenation routine
//                  Concatenates two sources, and assumes
//                  that 'this' is a new CHString object
//
//////////////////////////////////////////////////////////////////////////////
void CHString::ConcatCopy( int nSrc1Len, LPCWSTR lpszSrc1Data,
                           int nSrc2Len, LPCWSTR lpszSrc2Data)
{
    int nNewLen = nSrc1Len + nSrc2Len;
    if (nNewLen != 0)
    {
        AllocBuffer(nNewLen);
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(WCHAR));
        memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(WCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// 
//  ConcatInPlace
//
//  Description:        The main routine for += operators
//
//////////////////////////////////////////////////////////////////////////////
void CHString::ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData)
{
    // concatenating an empty string is a no-op!
    if (nSrcLen == 0)
    {
        return;
    }

    //  if the buffer is too small, or we have a width mis-match, just
    //  allocate a new buffer (slow but sure)
    if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength) 
    {
        // we have to grow the buffer, use the ConcatCopy routine
        CHStringData* pOldData = GetData();
        ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
        ASSERT_BREAK(pOldData != NULL);
        CHString::Release(pOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(WCHAR));
        GetData()->nDataLength += nSrcLen;
        ASSERT_BREAK(GetData()->nDataLength <= GetData()->nAllocLength);
        m_pchData[GetData()->nDataLength] = '\0';
    }
}

//////////////////////////////////////////////////////////////////////////////
// 
//  FormatV
//
//  Description:        Formats the variable arg list
//
//////////////////////////////////////////////////////////////////////////////
void CHString::FormatV(LPCWSTR lpszFormat, va_list argList)
{
    ASSERT_BREAK(lpszFormat!=NULL);

    va_list argListSave = argList;

    // make a guess at the maximum length of the resulting string
    int nMaxLen = 0;
    for (LPCWSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _wcsinc(lpsz)){
        // handle '%' character, but watch out for '%%'
        if (*lpsz != '%' || *(lpsz = _wcsinc(lpsz)) == '%'){
            nMaxLen += wcslen(lpsz);
            continue;
        }

        int nItemLen = 0;

        // handle '%' character with format
        int nWidth = 0;
        for (; *lpsz != '\0'; lpsz = _wcsinc(lpsz)){
            // check for valid flags
            if (*lpsz == '#')
                nMaxLen += 2;   // for '0x'
            else if (*lpsz == '*')
                nWidth = va_arg(argList, int);
            else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                *lpsz == ' ')
                ;
            else // hit non-flag character
                break;
        }
        // get width and skip it
        if (nWidth == 0){
            // width indicated by
            nWidth = _wtoi(lpsz);
            for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _wcsinc(lpsz))
                ;
        }
        ASSERT_BREAK(nWidth >= 0);

        int nPrecision = 0;
        if (*lpsz == '.'){
            // skip past '.' separator (width.precision)
            lpsz = _wcsinc(lpsz);

            // get precision and skip it
            if (*lpsz == '*'){
                nPrecision = va_arg(argList, int);
                lpsz = _wcsinc(lpsz);
            }
            else{
                nPrecision = _wtoi(lpsz);
                for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _wcsinc(lpsz))
                    ;
            }
            ASSERT_BREAK(nPrecision >= 0);
        }

        // should be on type modifier or specifier
        int nModifier = 0;
        switch (*lpsz){
            // modifiers that affect size
            case 'h':
                nModifier = FORCE_ANSI;
                lpsz = _wcsinc(lpsz);
                break;
            case 'l':
                nModifier = FORCE_UNICODE;
                lpsz = _wcsinc(lpsz);
                break;

            // modifiers that do not affect size
            case 'F':
            case 'N':
            case 'L':
                lpsz = _wcsinc(lpsz);
                break;
        }

        // now should be on specifier
        switch (*lpsz | nModifier){
            // single characters
            case 'c':
            case 'C':
                nItemLen = 2;
                va_arg(argList, TCHAR_ARG);
                break;
            case 'c'|FORCE_ANSI:
            case 'C'|FORCE_ANSI:
                nItemLen = 2;
                va_arg(argList, CHAR_ARG);
                break;
            case 'c'|FORCE_UNICODE:
            case 'C'|FORCE_UNICODE:
                nItemLen = 2;
                va_arg(argList, WCHAR_ARG);
                break;

            // strings
            case 's':
                nItemLen = wcslen(va_arg(argList, LPCWSTR));
                nItemLen = max(1, nItemLen);
                break;

            case 'S':
                nItemLen = strlen(va_arg(argList, LPCSTR));
                nItemLen = max(1, nItemLen);
                break;

            case 's'|FORCE_ANSI:
            case 'S'|FORCE_ANSI:
                nItemLen = strlen(va_arg(argList, LPCSTR));
                nItemLen = max(1, nItemLen);
                break;
    #ifndef _MAC
            case 's'|FORCE_UNICODE:
            case 'S'|FORCE_UNICODE:
                nItemLen = wcslen(va_arg(argList, LPWSTR));
                nItemLen = max(1, nItemLen);
                break;
    #endif
        }

        // adjust nItemLen for strings
        if (nItemLen != 0){
            nItemLen = max(nItemLen, nWidth);
            if (nPrecision != 0)
                nItemLen = min(nItemLen, nPrecision);
        }
        else{
            switch (*lpsz){
                // integers
                case 'd':
                case 'i':
                case 'u':
                case 'x':
                case 'X':
                case 'o':
                    va_arg(argList, int);
                    nItemLen = 32;
                    nItemLen = max(nItemLen, nWidth+nPrecision);
                    break;

                case 'e':
                case 'f':
                case 'g':
                case 'G':
                    va_arg(argList, DOUBLE_ARG);
                    nItemLen = 128;
                    nItemLen = max(nItemLen, nWidth+nPrecision);
                    break;

                case 'p':
                    va_arg(argList, void*);
                    nItemLen = 32;
                    nItemLen = max(nItemLen, nWidth+nPrecision);
                    break;

                // no output
                case 'n':
                    va_arg(argList, int*);
                    break;

                default:
                    ASSERT_BREAK(FALSE);  // unknown formatting option
            }
         }

         // adjust nMaxLen for output nItemLen
         nMaxLen += nItemLen;
    }

    GetBuffer(nMaxLen);
    int iSize = vswprintf(m_pchData, lpszFormat, argListSave); //<= GetAllocLength();
    ASSERT_BREAK(iSize <= nMaxLen);

    ReleaseBuffer();

    va_end(argListSave);
}

//////////////////////////////////////////////////////////////////////////////
//
//  CopyBeforeWrite
//
//  Description:
//
//////////////////////////////////////////////////////////////////////////////
void CHString::CopyBeforeWrite()
{
    if (GetData()->nRefs > 1)
    {
        CHStringData* pData = GetData();
        Release();
        AllocBuffer(pData->nDataLength);
        memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(WCHAR));
    }

    ASSERT_BREAK(GetData()->nRefs <= 1);
}

//////////////////////////////////////////////////////////////////////////////
//
//  AllocBeforeWrite
//
//  Description:
//
//////////////////////////////////////////////////////////////////////////////
void CHString::AllocBeforeWrite(int nLen)
{
    if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
    {
        Release();
        AllocBuffer(nLen);
    }

    ASSERT_BREAK(GetData()->nRefs <= 1);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Release
//
//  Description:    Deallocate data
//
//////////////////////////////////////////////////////////////////////////////
void CHString::Release()
{
    if (GetData() != afxDataNil)
    {
        ASSERT_BREAK(GetData()->nRefs != 0);
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
        {
            delete[] (BYTE*)GetData();
        }

        Init();
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Release
//
//  Description:    Deallocate data
//
//////////////////////////////////////////////////////////////////////////////
void CHString::Release(CHStringData* pData)
{
    if (pData != afxDataNil)
    {
        ASSERT_BREAK(pData->nRefs != 0);
        if (InterlockedDecrement(&pData->nRefs) <= 0)
        {
            delete[] (BYTE*)pData;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction
///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
CHString::CHString()
{
    Init();
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
CHString::CHString(WCHAR ch, int nLength)
{
    ASSERT_BREAK(!_istlead(ch));    // can't create a lead byte string

    Init();
    if (nLength >= 1)
    {
        AllocBuffer(nLength);
        for (int i = 0; i < nLength; i++)
        {
            m_pchData[i] = ch;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
CHString::CHString(LPCWSTR lpch, int nLength)
{
    Init();
    if (nLength != 0)
    {
        ASSERT_BREAK(lpch!=NULL);

        AllocBuffer(nLength);
        memcpy(m_pchData, lpch, nLength*sizeof(WCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
//#ifdef _UNICODE
CHString::CHString(LPCSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? strlen(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen);
        _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        ReleaseBuffer();
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
//#else //_UNICODE
#if 0
CHString::CHString(LPCWSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    if (nSrcLen != 0){
        AllocBuffer(nSrcLen*2);
        _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
        ReleaseBuffer();
    }
}
#endif 

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
CHString::CHString(LPCWSTR lpsz)
{
    Init();
//  if (lpsz != NULL && HIWORD(lpsz) == NULL)
//  {
        //??
//  }
//  else
//  {
        int nLen = SafeStrlen(lpsz);
        if (nLen != 0)
        {
            AllocBuffer(nLen);
            memcpy(m_pchData, lpsz, nLen*sizeof(WCHAR));
        }
//  }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
CHString::CHString(const CHString& stringSrc)
{
    ASSERT_BREAK(stringSrc.GetData()->nRefs != 0);

    if (stringSrc.GetData()->nRefs >= 0)
    {
        ASSERT_BREAK(stringSrc.GetData() != afxDataNil);
        m_pchData = stringSrc.m_pchData;
        InterlockedIncrement(&GetData()->nRefs);
    }
    else
    {
        Init();
        *this = stringSrc.m_pchData;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
void CHString::Empty()
{
    if (GetData()->nDataLength == 0)
    {
        return;
    }

    if (GetData()->nRefs >= 0)
    {
        Release();
    }
    else
    {
        *this = &afxChNil;
    }

    ASSERT_BREAK(GetData()->nDataLength == 0);
    ASSERT_BREAK(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
CHString::~CHString()
{
    if (GetData() != afxDataNil)
    {   
//  free any attached data

        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
        {
            delete[] (BYTE*)GetData();
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
//////////////////////////////////////////////////////////////////////////////
void CHString::SetAt(int nIndex, WCHAR ch)
{
    ASSERT_BREAK(nIndex >= 0);
    ASSERT_BREAK(nIndex < GetData()->nDataLength);

    CopyBeforeWrite();
    m_pchData[nIndex] = ch;
}

//////////////////////////////////////////////////////////////////////////////
//
//  Description:  
//
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CHString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//
/////////////////////////////////////////////////////////////////////////
const CHString& CHString::operator=(const CHString& stringSrc)
{
    if (m_pchData != stringSrc.m_pchData)
    {
        if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
            stringSrc.GetData()->nRefs < 0)
        {
            // actual copy necessary since one of the strings is locked
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
        }
        else
        {
            // can just copy references around
            Release();
            ASSERT_BREAK(stringSrc.GetData() != afxDataNil);
            m_pchData = stringSrc.m_pchData;
            InterlockedIncrement(&GetData()->nRefs);
        }
    }

    return *this;

/*  if (m_pchData != stringSrc.m_pchData){

        // can just copy references around
        Release();
        if( stringSrc.GetData() != afxDataNil) {
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
            InterlockedIncrement(&GetData()->nRefs);
        }
    }
    return *this;*/
} 

/////////////////////////////////////////////////////////////////////////////
const CHString& CHString::operator=(LPCWSTR lpsz)
{
    ASSERT_BREAK(lpsz != NULL);

    AssignCopy(SafeStrlen(lpsz), lpsz);

    return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

//#ifdef _UNICODE
const CHString& CHString::operator=(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? strlen(lpsz) : 0 ;
    
    AllocBeforeWrite( nSrcLen ) ;
    
    if( nSrcLen )
    {
        _mbstowcsz( m_pchData, lpsz, nSrcLen + 1 ) ;
        ReleaseBuffer() ;
    }
    else
    {
        Release() ;
    }
    
    return *this;
}

/////////////////////////////////////////////////////////////////////////////
//#else //!_UNICODE
#if 0
const CHString& CHString::operator=(LPCWSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0 ;

    AllocBeforeWrite( nSrcLen * 2 ) ;
    
    if( nSrcLen )
    {
        _wcstombsz(m_pchData, lpsz, (nSrcLen * 2) + 1 ) ;
        ReleaseBuffer();
    }
    else
    {
        Release() ;
    }

    return *this;
}
#endif

//////////////////////////////////////////////////////////////////////////////
const CHString& CHString::operator=(WCHAR ch)
{
    ASSERT_BREAK(!_istlead(ch));    // can't set single lead byte

    AssignCopy(1, &ch);

    return *this;
}

/////////////////////////////////////////////////////////////////////////////
// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CHString + CHString
// and for ? = WCHAR, LPCWSTR
//          CHString + ?
//          ? + CHString
/////////////////////////////////////////////////////////////////////////////

CHString WINAPI operator+(const CHString& string1, const CHString& string2)
{
    CHString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
        string2.GetData()->nDataLength, string2.m_pchData);

    return s;
}

/////////////////////////////////////////////////////////////////////////////
CHString WINAPI operator+(const CHString& string, LPCWSTR lpsz)
{
    ASSERT_BREAK(lpsz != NULL );

    CHString s;
    s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
        CHString::SafeStrlen(lpsz), lpsz);

    return s;
}
/////////////////////////////////////////////////////////////////////////////
CHString WINAPI operator+(LPCWSTR lpsz, const CHString& string)
{
    ASSERT_BREAK(lpsz != NULL );

    CHString s;
    s.ConcatCopy(CHString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
        string.m_pchData);

    return s;
}

/////////////////////////////////////////////////////////////////////////////
CHString WINAPI operator+(const CHString& string1, WCHAR ch)
{
    CHString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);

    return s;
}

/////////////////////////////////////////////////////////////////////////////
CHString WINAPI operator+(WCHAR ch, const CHString& string)
{
    CHString s;
    s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);

    return s;
}

/////////////////////////////////////////////////////////////////////////////
const CHString& CHString::operator+=(LPCWSTR lpsz)
{
    ASSERT_BREAK(lpsz != NULL );

    ConcatInPlace(SafeStrlen(lpsz), lpsz);

    return *this;
}

/////////////////////////////////////////////////////////////////////////////
const CHString& CHString::operator+=(WCHAR ch)
{
    ConcatInPlace(1, &ch);

    return *this;
}

/////////////////////////////////////////////////////////////////////////////
const CHString& CHString::operator+=(const CHString& string)
{
    ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);

    return *this;
}

///////////////////////////////////////////////////////////////////////////////
int CHString::Compare(LPCWSTR lpsz ) const 
{   
    ASSERT_BREAK( lpsz!=NULL );
    ASSERT_BREAK( m_pchData != NULL );

    return wcscmp(m_pchData, lpsz);  // MBCS/Unicode aware   strcmp

}   

///////////////////////////////////////////////////////////////////////////////
//
//
//  Description: Advanced direct buffer access
//
///////////////////////////////////////////////////////////////////////////////
LPWSTR CHString::GetBuffer(int nMinBufLength)
{
    ASSERT_BREAK(nMinBufLength >= 0);

    if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
    {
        // we have to grow the buffer
        CHStringData* pOldData = GetData();
        int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
        if (nMinBufLength < nOldLen)
        {
            nMinBufLength = nOldLen;
        }

        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(WCHAR));
        GetData()->nDataLength = nOldLen;
        CHString::Release(pOldData);
    }

    ASSERT_BREAK(GetData()->nRefs <= 1);

    // return a pointer to the character storage for this string
    ASSERT_BREAK(m_pchData != NULL);

    return m_pchData;
}

///////////////////////////////////////////////////////////////////////////////
void CHString::ReleaseBuffer(int nNewLength)
{
    CopyBeforeWrite();  // just in case GetBuffer was not called

    if (nNewLength == -1)
    {
        nNewLength = wcslen(m_pchData); // zero terminated
    }

    ASSERT_BREAK(nNewLength <= GetData()->nAllocLength);

    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
}

///////////////////////////////////////////////////////////////////////////////
LPWSTR CHString::GetBufferSetLength(int nNewLength)
{
    ASSERT_BREAK(nNewLength >= 0);

    GetBuffer(nNewLength);
    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';

    return m_pchData;
}

///////////////////////////////////////////////////////////////////////////////
void CHString::FreeExtra()
{
    ASSERT_BREAK(GetData()->nDataLength <= GetData()->nAllocLength);
    if (GetData()->nDataLength != GetData()->nAllocLength)
    {
        CHStringData* pOldData = GetData();
        AllocBuffer(GetData()->nDataLength);
        memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(WCHAR));

        ASSERT_BREAK(m_pchData[GetData()->nDataLength] == '\0');

        CHString::Release(pOldData);
    }

    ASSERT_BREAK(GetData() != NULL);
}

///////////////////////////////////////////////////////////////////////////////
LPWSTR CHString::LockBuffer()
{
    LPWSTR lpsz = GetBuffer(0);
    GetData()->nRefs = -1;

    return lpsz;
}

///////////////////////////////////////////////////////////////////////////////
void CHString::UnlockBuffer()
{
    ASSERT_BREAK(GetData()->nRefs == -1);

    if (GetData() != afxDataNil)
    {
        GetData()->nRefs = 1;
    }
}

///////////////////////////////////////////////////////////////////////////////
int CHString::Find(WCHAR ch) const
{
    // find first single character
    LPWSTR lpsz = wcschr(m_pchData, ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
int CHString::FindOneOf(LPCWSTR lpszCharSet) const
{
    ASSERT_BREAK(lpszCharSet!=0);

    LPWSTR lpsz = wcspbrk(m_pchData, lpszCharSet);

    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
int CHString::ReverseFind(WCHAR ch) const
{
    // find last single character
    LPWSTR lpsz = wcsrchr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// find a sub-string (like strstr)
int CHString::Find(LPCWSTR lpszSub) const
{
    ASSERT_BREAK(lpszSub!=NULL);

    // find first matching substring
    LPWSTR lpsz = wcsstr(m_pchData, lpszSub);

    // return -1 for not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
void CHString::MakeUpper()
{
    CopyBeforeWrite();
    ::_wcsupr(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
void CHString::MakeLower()
{
    CopyBeforeWrite();
    ::_wcslwr(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
void CHString::MakeReverse()
{
    CopyBeforeWrite();
    _wcsrev(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
//#ifndef _UNICODE
//void CHString::AnsiToOem()
//{
//  CopyBeforeWrite();
//  ::AnsiToOemW(m_pchData, m_pchData);
//}
//void CHString::OemToAnsi()
//{
//  CopyBeforeWrite();
//  ::OemToAnsi(m_pchData, m_pchData);
//}
//#endif

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CHString CHString::Mid(int nFirst) const
{
    return Mid(nFirst, GetData()->nDataLength - nFirst);
}

//////////////////////////////////////////////////////////////////////////////
CHString CHString::Mid(int nFirst, int nCount) const
{
    // out-of-bounds requests return sensible things
    if (nFirst < 0)
    {
        nFirst = 0;
    }

    if (nCount < 0)
    {
        nCount = 0;
    }

    if (nFirst + nCount > GetData()->nDataLength)
    {
        nCount = GetData()->nDataLength - nFirst;
    }

    if (nFirst > GetData()->nDataLength)
    {
        nCount = 0;
    }

    CHString dest;
    AllocCopy(dest, nCount, nFirst, 0);

    return dest;
}

//////////////////////////////////////////////////////////////////////////////
CHString CHString::Right(int nCount) const
{
    if (nCount < 0)
    {
        nCount = 0;
    }
    else if (nCount > GetData()->nDataLength)
    {
        nCount = GetData()->nDataLength;
    }

    CHString dest;
    AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);

    return dest;
}

//////////////////////////////////////////////////////////////////////////////
CHString CHString::Left(int nCount) const
{
    if (nCount < 0)
    {
        nCount = 0;
    }
    else if (nCount > GetData()->nDataLength)
    {
        nCount = GetData()->nDataLength;
    }

    CHString dest;
    AllocCopy(dest, nCount, 0, 0);

    return dest;
}

//////////////////////////////////////////////////////////////////////////////
// strspn equivalent
CHString CHString::SpanIncluding(LPCWSTR lpszCharSet) const
{
    ASSERT_BREAK(lpszCharSet != NULL);

    return Left(wcsspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// strcspn equivalent
CHString CHString::SpanExcluding(LPCWSTR lpszCharSet) const
{
    ASSERT_BREAK(lpszCharSet != NULL);

    return Left(wcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
void CHString::TrimRight()
{
    CopyBeforeWrite();

    // find beginning of trailing spaces by starting at beginning (DBCS aware)

    LPWSTR lpsz = m_pchData;
    LPWSTR lpszLast = NULL;
    while (*lpsz != '\0')
    {
        if (_istspace(*lpsz))
        {
            if (lpszLast == NULL)
            {
                lpszLast = lpsz;
            }
        }
        else
        {
            lpszLast = NULL;
        }

        lpsz = _wcsinc(lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at trailing space start

        *lpszLast = '\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

//////////////////////////////////////////////////////////////////////////////
void CHString::TrimLeft()
{
    CopyBeforeWrite();

    // find first non-space character

    LPCWSTR lpsz = m_pchData;
    while (_istspace(*lpsz))
    {
        lpsz = _wcsinc(lpsz);
    }

    // fix up data and length

    int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(WCHAR));
    GetData()->nDataLength = nDataLength;
}

//////////////////////////////////////////////////////////////////////////////
// formatting (using wsprintf style formatting)
void __cdecl CHString::Format(LPCWSTR lpszFormat, ...)
{
    ASSERT_BREAK(lpszFormat!=NULL);

    va_list argList;
    va_start(argList, lpszFormat);
    FormatV(lpszFormat, argList);
    va_end(argList);
}

#ifdef FRAMEWORK_ALLOW_DEPRECATED
void __cdecl CHString::Format(UINT nFormatID, ...)
{
    ASSERT_BREAK(DEPRECATED);
#if 0
    CHString strFormat;
    
    strFormat.LoadStringW(nFormatID);

    va_list argList;
    va_start(argList, nFormatID);
    FormatV(strFormat, argList);
    va_end(argList);
#endif
}
#endif

class auto_va_list
{
  va_list& argList_;
public:
  auto_va_list(va_list& arg):argList_(arg){ };
  ~auto_va_list(){va_end(argList_);}
};

//////////////////////////////////////////////////////////////////////////////
// formatting (using FormatMessage style formatting)
void __cdecl CHString::FormatMessageW(LPCWSTR lpszFormat, ...)
{
    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    
    auto_va_list _arg(argList);

    if (s_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        LPWSTR lpszTemp = 0;

        if (::FormatMessageW(
            FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            lpszFormat, 
            0, 
            0, 
            (LPWSTR) &lpszTemp, 
            0, 
            &argList) == 0 || lpszTemp == 0)
	    throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR);
	
	ScopeGuard _1 = MakeGuard (LocalFree, lpszTemp);
        ASSERT_BREAK(lpszTemp != NULL);

        // assign lpszTemp into the resulting string and free the temporary
        *this = lpszTemp;
    }
    else
    {
        LPSTR lpszTemp = 0;

        if (::FormatMessageA(
            FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            (LPCTSTR) bstr_t(lpszFormat), 
            0, 
            0, 
            (LPSTR) &lpszTemp, 
            0, 
            &argList)==0 || lpszTemp == 0)
	  throw CHeap_Exception (CHeap_Exception::E_ALLOCATION_ERROR);
	
	ScopeGuard _1 = MakeGuard (LocalFree, lpszTemp);
        ASSERT_BREAK(lpszTemp != NULL);

        // assign lpszTemp into the resulting string and free the temporary
        *this = lpszTemp;
    }
}

#ifdef FRAMEWORK_ALLOW_DEPRECATED
void __cdecl CHString::FormatMessageW(UINT nFormatID, ...)
{
    ASSERT_BREAK(DEPRECATED);
#if 0
    // get format string from string table
    CHString strFormat;
    
    strFormat.LoadStringW(nFormatID);

    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, nFormatID);
    auto_va_list _arg(argList);

    if (s_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        LPWSTR lpszTemp = 0;

        if (::FormatMessageW(
            FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            (LPCWSTR) strFormat, 
            0, 
            0, 
            (LPWSTR) &lpszTemp, 
            0, 
            &argList) == 0 || lpszTemp == NULL)
        {
            // Should throw memory exception here.  Now we do.
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        };
	ScopeGuard _1 = MakeGuard (LocalFree, lpszTemp);
	  // assign lpszTemp into the resulting string and free lpszTemp
          *this = lpszTemp;
    }
    else
    {
        LPSTR lpszTemp = 0;

        if (::FormatMessageA(
            FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            (LPCSTR) bstr_t(strFormat), 
            0, 
            0, 
            (LPSTR) &lpszTemp, 
            0, 
            &argList) == 0 || lpszTemp == NULL)
        {
            // Should throw memory exception here.  Now we do.
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
	ScopeGuard _1 = MakeGuard (LocalFree, lpszTemp);
            // assign lpszTemp into the resulting string and free lpszTemp
            *this = lpszTemp;
        }
    }
#endif

}
#endif

///////////////////////////////////////////////////////////////////////////////
BSTR CHString::AllocSysString() const
{

    BSTR bstr;
    bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
    if ( ! bstr )
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    ASSERT_BREAK(bstr!=NULL);

    return bstr;
}

///////////////////////////////////////////////////////////////////////////////
// CHString support for template collections
void ConstructElements(CHString* pElements, int nCount)
{
    ASSERT_BREAK(nCount != 0 || pElements != NULL );

    for (; nCount--; ++pElements)
    {
        memcpy(pElements, &afxPchNil, sizeof(*pElements));
    }
}

void DestructElements(CHString* pElements, int nCount)
{
    ASSERT_BREAK(nCount != 0 || pElements != NULL);

    for (; nCount--; ++pElements)
    {
        pElements->~CHString();
    }
}

void  CopyElements(CHString* pDest, const CHString* pSrc, int nCount)
{
    ASSERT_BREAK(nCount != 0 || pDest != NULL );
    ASSERT_BREAK(nCount != 0 || pSrc != NULL );

    for (; nCount--; ++pDest, ++pSrc)
    {
        *pDest = *pSrc;
    }
}

UINT  HashKey(LPCWSTR key)
{
    UINT nHash = 0;
    while (*key)
    {
        nHash = (nHash<<5) + nHash + *key++;
    }

    return nHash;
}

/////////////////////////////////////////////////////////////////////////////
// Windows extensions to strings
#ifdef _UNICODE
#define CHAR_FUDGE 1    // one WCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

#define STR_BLK_SIZE 256 

#ifdef FRAMEWORK_ALLOW_DEPRECATED
BOOL CHString::LoadStringW(UINT nID)
{
    ASSERT_BREAK(DEPRECATED);
#if 0
    // try fixed buffer first (to avoid wasting space in the heap)
    WCHAR szTemp[ STR_BLK_SIZE ];

    int nLen = LoadStringW(nID, szTemp, STR_BLK_SIZE);
    
    if (STR_BLK_SIZE - nLen > CHAR_FUDGE)
    {
        *this = szTemp;
    }
    else
    {
        // try buffer size of 512, then larger size until entire string is retrieved
        int nSize = STR_BLK_SIZE;

        do
        {
            nSize += STR_BLK_SIZE;
            nLen = LoadStringW(nID, GetBuffer(nSize-1), nSize);

        } 
        while (nSize - nLen <= CHAR_FUDGE);

        ReleaseBuffer();
    }

    return nLen > 0;
#endif
    return FALSE;
}
#endif

#ifdef FRAMEWORK_ALLOW_DEPRECATED
int CHString::LoadStringW(UINT nID, LPWSTR lpszBuf, UINT nMaxBuf)
{
    ASSERT_BREAK(DEPRECATED);
#if 0
    int nLen;

    if (s_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        nLen = ::LoadStringW(g_hModule, nID, lpszBuf, nMaxBuf);
        if (nLen == 0)
        {
            lpszBuf[0] = '\0';
        }
    }
    else
    {
        char *pszBuf = new char[nMaxBuf];
        if ( pszBuf )
        {
            nLen = ::LoadStringA(g_hModule, nID, pszBuf, nMaxBuf);
            if (nLen == 0)
            {
                lpszBuf[0] = '\0';
            }
            else
            {
                nLen = ::MultiByteToWideChar(CP_ACP, 0, pszBuf, nLen + 1, 
                            lpszBuf, nMaxBuf); 
                
                // Truncate to requested size  
                if (nLen > 0)
                {
                    // nLen doesn't include the '\0'.
                    nLen = min(nMaxBuf - 1, (UINT) nLen - 1); 
                }
                
                lpszBuf[nLen] = '\0'; 
            }
            
            delete pszBuf;
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }

    return nLen; // excluding terminator
#endif
    return 0;
}
#endif

#if (defined DEBUG || defined _DEBUG)
WCHAR CHString::GetAt(int nIndex) const
{ 
    ASSERT_BREAK(nIndex >= 0);
    ASSERT_BREAK(nIndex < GetData()->nDataLength);

    return m_pchData[nIndex]; 
}

WCHAR CHString::operator[](int nIndex) const
{   
    ASSERT_BREAK(nIndex >= 0);
    ASSERT_BREAK(nIndex < GetData()->nDataLength);

    return m_pchData[nIndex]; 
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\precomp.h ===
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#include <strutils.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\sources.inc ===
############################################################################
#
#   Copyright  Microsoft Corporation.  All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=utillib

TARGETPATH=obj
TARGETTYPE=LIBRARY

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(UTILLIB_INC); \
	$(WMIIDL_INC); \
	$(STDLIBRARY_INC); \
        $(WBEMCOMN_INC)

SOURCES= \
	..\CRegCls.CPP \
	..\analyser.cpp \
	..\assertbreak.cpp \
	..\CHPtrArr.cpp \
	..\CHStrarr.CPP \
	..\CHString.CPP \
	..\wbemtime.cpp \
	..\utils.cpp \
	..\AutoImpRevert.cpp

C_DEFINES=$(C_DEFINES) /DUTILLIB /D_DLL /DUSE_POLARITY /DBUILDING_DLL /DFRAMEWORK_ALLOW_DEPRECATED=0
USE_NATIVE_EH=ASYNC
USE_STL=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\cregcls.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  cregcls.cpp
//
//  Purpose: registry wrapper class
//
//***************************************************************************

#include "precomp.h"
#pragma warning( disable : 4290 ) 
#include <CHString.h>

#include <strsafe.h>
#include <stdio.h>
#include "CRegCls.h"
#include <malloc.h>
#include <cnvmacros.h>


DWORD CRegistry::s_dwPlatform = CRegistry::GetPlatformID () ;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
CRegistry::CRegistry()
 : m_fFromCurrentUser(false)
{
  
// Set the key to null so that if the caller does not open the key
// but still tries to use it we can return an error

    hKey = (HKEY)NULL;
    hSubKey = (HKEY)NULL;
    hRootKey = (HKEY)NULL;

// To prevent garbage values being returned if they try to get
// some information before they open the class

    SetDefaultValues();
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
CRegistry::~CRegistry()
{
    Close();
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void CRegistry::SetDefaultValues()
{
    // Information inited here rather than constructor so that this instance
    // can be reused

    ClassName[0] = '\0';
    dwcClassLen = MAX_PATH;         // Length of class string.
    dwcSubKeys = NULL_DWORD;        // Number of sub keys.
    dwcMaxSubKey = NULL_DWORD;      // Longest sub key size.
    dwcMaxClass = NULL_DWORD;       // Longest class string.
    dwcValues = NULL_DWORD;         // Number of values for this key.
    dwcMaxValueName = NULL_DWORD;   // Longest Value name.
    dwcMaxValueData = NULL_DWORD;   // Longest Value data.
    RewindSubKeys();                // Rewind the index to zero
  
    RootKeyPath.Empty();
}

////////////////////////////////////////////////////////////////
//  Function:       EnumerateAndGetValues
//  Description:    This function enumerates the values under the
//                  specified key and gets the value, keeps on
//                  going and going... until there aren't any more
//                  values to get.  The first call must set the
//                  value index to 0, this indicates for the function
//                  to start over;
//
//
//  NOTE!!!!    The USER has the responsibility of deleting the 
//              allocated memory for pValueName and pValueData
//
//
//  Arguments:
//  Returns:    Standard return value from registry open function
//  Inputs:
//  Outputs:
//  Caveats:
//  Raid:
////////////////////////////////////////////////////////////////
LONG CRegistry::EnumerateAndGetValues (

    DWORD &dwIndexOfValue,
    WCHAR *&pValueName,
    BYTE *&pValueData
)
{
    DWORD dwIndex = dwIndexOfValue, dwType;
    DWORD dwValueNameSize = dwcMaxValueName + 2;  // add extra for null
    DWORD dwValueDataSize = dwcMaxValueData + 2;  // add extra for null

    // If this is the first time we have come thru, then we
    // need to get the max size of things.

    pValueName = new WCHAR[dwValueNameSize + 2];
    if ( ! pValueName )
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    // We have to use WCHAR's since for 9x, we'll be converting the
    // data from chars to WCHARs.
    pValueData = (LPBYTE) new WCHAR[dwValueDataSize + 2];
    if ( ! pValueData )
    {
        delete [] pValueName ;
		pValueName = NULL;
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    LONG lRc = ERROR_SUCCESS ;

    try 
    {
        lRc = myRegEnumValue (

            hKey,               // handle of key to query 
            dwIndex,            // index of value to query 
            pValueName,         // address of buffer for value string 
            &dwValueNameSize,   // address for size of value buffer 
            0,                  // reserved 
            &dwType,            // address of buffer for type code 
            pValueData,         // address of buffer for value data 
            &dwValueDataSize 
        ) ;

        dwIndexOfValue = dwIndex;

        if ( lRc != ERROR_SUCCESS )
        {
            delete[] pValueName;
            pValueName = NULL ;

            delete[] pValueData;
            pValueData = NULL ;
        }
    }
    catch ( ... )
    {
        delete[] pValueName;
        pValueName = NULL ;

        delete[] pValueData;
        pValueData = NULL ;

        throw ;                 // throw the exception up
    }

    return lRc ;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  LONG CRegistry::OpenCurrentUser(LPCWSTR lpszSubKey, REGSAM samDesired)  
 Description:
 Arguments:
 Returns:   Standard return value from registry open function
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

DWORD CRegistry::OpenCurrentUser (
    LPCWSTR lpszSubKey,      // address of name of subkey to open 
    REGSAM samDesired)       // Access mask
{
    LONG RetValue = ERROR_SUCCESS; 

    // If we have a key value, we are open, so lets cleanup the previous
    // use of this instance
    PrepareToReOpen();
 
    RetValue = ::RegOpenCurrentUser(
        samDesired,
        &hRootKey);

    m_fFromCurrentUser = true;
        
    if(RetValue == ERROR_SUCCESS)
    {
        // Just return the value and the hKey value never gets changed from NULL
        //======================================================================

        RetValue = myRegOpenKeyEx (

            hRootKey, 
            lpszSubKey,     // address of name of subkey to open 
            (DWORD) 0,      // reserved 
            samDesired,     // security access mask 
            (PHKEY)&hKey    // address of handle of open key 

        ); 

        // If we are not successful, then return the registry error
        //=========================================================

        if(RetValue == ERROR_SUCCESS) 
        {
            dwcClassLen = sizeof(ClassName);

            // Get the key information now, so it's available
            // this is not critical, so we won't fail the open if this fails
            //===============================================

            myRegQueryInfoKey (

                hKey,               // Key handle.
                ClassName,          // Buffer for class name.
                &dwcClassLen,       // Length of class string.
                NULL,               // Reserved.
                &dwcSubKeys,        // Number of sub keys.
                &dwcMaxSubKey,      // Longest sub key size.
                &dwcMaxClass,       // Longest class string.
                &dwcValues,         // Number of values for this key.
                &dwcMaxValueName,   // Longest Value name.
                &dwcMaxValueData,   // Longest Value data.
                &dwcSecDesc,        // Security descriptor.
                &ftLastWriteTime    // Last write time.

            ); 
  
            RootKeyPath = lpszSubKey;    // Assign 
        }
    }

    return RetValue;
}



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  LONG CRegistry::Open(HKEY hKey, LPCWSTR lpszSubKey, REGSAM samDesired)  
 Description:
 Arguments:
 Returns:   Standard return value from registry open function
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
LONG CRegistry::Open(

    HKEY hInRootKey, 
    LPCWSTR lpszSubKey, 
    REGSAM samDesired
)
{
    LONG RetValue; 

    // If we have a key value, we are open, so lets cleanup the previous
    // use of this instance

    if(hKey != NULL) 
    {
        PrepareToReOpen();
    }
 
    hRootKey = hInRootKey;

    // Just return the value and the hKey value never gets changed from NULL
    //======================================================================

    RetValue = myRegOpenKeyEx (

        hRootKey, 
        lpszSubKey,     // address of name of subkey to open 
        (DWORD) 0,      // reserved 
        samDesired,     // security access mask 
        (PHKEY)&hKey    // address of handle of open key 

    ); 

    // If we are not successful, then return the registry error
    //=========================================================

    if(RetValue != ERROR_SUCCESS) 
    {
        return RetValue;
    }

    dwcClassLen = sizeof(ClassName);

    // Get the key information now, so it's available
    // this is not critical, so we won't fail the open if this fails
    //===============================================

    myRegQueryInfoKey (

        hKey,               // Key handle.
        ClassName,          // Buffer for class name.
        &dwcClassLen,       // Length of class string.
        NULL,               // Reserved.
        &dwcSubKeys,        // Number of sub keys.
        &dwcMaxSubKey,      // Longest sub key size.
        &dwcMaxClass,       // Longest class string.
        &dwcValues,         // Number of values for this key.
        &dwcMaxValueName,   // Longest Value name.
        &dwcMaxValueData,   // Longest Value data.
        &dwcSecDesc,        // Security descriptor.
        &ftLastWriteTime    // Last write time.

    ); 
  
    RootKeyPath = lpszSubKey;    // Assign 

    return RetValue;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  LONG CRegistry::CreateOpen(HKEY hInRootKey, 
                           LPCWSTR lpszSubKey,
                           LPSTR lpClass = NULL, 
                           DWORD dwOptions = REG_OPTION_NON_VOLATILE, 
                           REGSAM samDesired = KEY_ALL_ACCESS,
                           LPSECURITY_ATTRIBUTES lpSecurityAttrib = NULL
                           LPDWORD pdwDisposition = NULL ); 
 Description:
 Arguments: lpClass, dwOptions, samDesired and lpSecurityAttrib have signature defaults
 Returns:   Standard return value from registry RegCreateKeyEx function
 Inputs:
 Outputs:
 Caveats:
 Raid:
 History:                   a-peterc  28-Jul-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
LONG CRegistry::CreateOpen (

    HKEY hInRootKey, 
    LPCWSTR lpszSubKey,
    LPWSTR lpClass, 
    DWORD dwOptions, 
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttrib,
    LPDWORD pdwDisposition 
)
{
    LONG RetValue; 
    DWORD dwDisposition;

    // If we have a key value, we are open, so lets cleanup the previous
    // use of this instance
    if(hKey != NULL) 
    {
        PrepareToReOpen();
    }
 
    hRootKey = hInRootKey;

    // Just return the value and the hKey value never gets changed from NULL
    //======================================================================
    RetValue = myRegCreateKeyEx (

        hRootKey, 
        lpszSubKey,         // address of name of subkey to open 
        (DWORD) 0,          // reserved
        lpClass,            // address of the object class string
        dwOptions,          // special options flag
        samDesired,         // security access mask
        lpSecurityAttrib,   // address of the key security structure 
        (PHKEY)&hKey,       // address of handle of open key
        &dwDisposition      // address of the disposition value buffer   
    );  
  
    // If we are not successful, then return the registry error
    //=========================================================

    if(RetValue != ERROR_SUCCESS) 
    {
        return RetValue;
    }

    if( pdwDisposition )
    {
        *pdwDisposition = dwDisposition;
    }

    // Get the key information now, so it's available
    // this is not critical, so we won't fail the open if this fails
    //===============================================

    myRegQueryInfoKey (

        hKey,               // Key handle.
        ClassName,          // Buffer for class name.
        &dwcClassLen,       // Length of class string.
        NULL,               // Reserved.
        &dwcSubKeys,        // Number of sub keys.
        &dwcMaxSubKey,      // Longest sub key size.
        &dwcMaxClass,       // Longest class string.
        &dwcValues,         // Number of values for this key.
        &dwcMaxValueName,   // Longest Value name.
        &dwcMaxValueData,   // Longest Value data.
        &dwcSecDesc,        // Security descriptor.
        &ftLastWriteTime    // Last write time.
    ); 
  
    RootKeyPath = lpszSubKey;    // Assign 

    return RetValue;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:      DWORD CRegistry::DeleteKey( CHString* pchsSubKeyPath = NULL )   

 Description:   deletes the specified subkey or the Rootkey specified in the open

 Arguments:     pchsSubKeyPath has signature default of NULL, 
                    specifying the RootKeyPath by default 

 Returns:       Standard return value from registry RegDeleteKey function       
 Inputs:
 Outputs:
 Caveats:       A deleted key is not removed until the last handle to it has been closed.
                Subkeys and values cannot be created under a deleted key.               
 Raid:
 History:                   a-peterc  28-Jul-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
LONG CRegistry::DeleteKey( CHString* pchsSubKeyPath )
{ 
    CHString* pSubKey = pchsSubKeyPath ? pchsSubKeyPath : &RootKeyPath;

    return myRegDeleteKey( hKey, pSubKey->GetBuffer(0) );
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:      DWORD CRegistry::DeleteValue( LPCWSTR pValueName )  

 Description:   deletes the specified value in the createopen

 Arguments:     pValueName to be deleted

 Returns:       Standard return value from registry RegDeleteValue function     
 Inputs:
 Outputs:
 Caveats:                   
 Raid:
 History:                   a-peterc  30-Sep-1998     Created
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
LONG CRegistry::DeleteValue( LPCWSTR pValueName )
{ 
    return myRegDeleteValue( hKey, pValueName );
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  LONG CRegistry::OpenAndEnumerateSubKeys(HKEY hKey, LPCWSTR lpszSubKey, REGSAM samDesired)   
 Description:
 Arguments:
 Returns:   Standard return value from registry open function
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
LONG CRegistry::OpenAndEnumerateSubKeys (

    HKEY hInRootKey, 
    LPCWSTR lpszSubKey, 
    REGSAM samDesired
)
{
    return (Open( hInRootKey,  lpszSubKey,  samDesired | KEY_ENUMERATE_SUB_KEYS));
}


/////////////////////////////////////////////////////////////////////
//
//  This function opens and enumerates a key, then gets the requested
//  value
//
/////////////////////////////////////////////////////////////////////
LONG CRegistry::OpenLocalMachineKeyAndReadValue(

    LPCWSTR lpszSubKey, 
    LPCWSTR pValueName, 
    CHString &DestValue
)
{ 
    LONG lRc;

    //===============================================
    //  Open the key.  Note, if it is already in use
    //  the current key will be closed and everything
    //  reinitilized by the Open call
    //===============================================

    lRc = Open( HKEY_LOCAL_MACHINE,lpszSubKey,KEY_READ );
    if( lRc != ERROR_SUCCESS )
    {
        return lRc;
    }

    //===============================================
    // Get the value
    //===============================================
    return( GetCurrentKeyValue( pValueName, DestValue ));
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentRawKeyValue (

    HKEY UseKey, 
    LPCWSTR pValueName, 
    void *pDestValue,
    LPDWORD pValueType, 
    LPDWORD pSizeOfDestValue
)
{
    DWORD RetValue;


// If subkey is open then get value
// ================================

    RetValue = myRegQueryValueEx( 

        UseKey,                     // handle of key to query 
        pValueName,                 // address of name of value to query 
        NULL,                       // reserved 
        pValueType,                 // address of buffer for value type 
        (LPBYTE) pDestValue,        // address of data buffer 
        (LPDWORD)pSizeOfDestValue   // address of data buffer size 
    );  

    return RetValue;
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentKeyValue (

    HKEY UseKey, 
    LPCWSTR pValueName, 
    CHString &DestValue
)
{
    DWORD SizeOfValue = 0L;
    DWORD TypeOfValue;
    LPBYTE pValue = NULL ;      // Pointer to buffer for value

    DestValue = L"";

    LONG t_Status = myRegQueryValueEx( 

        UseKey,                     // handle of key to query 
        pValueName,                 // address of name of value to query 
        NULL,                       // reserved 
        (LPDWORD)&TypeOfValue,      // address of buffer for value type 
        (LPBYTE) NULL,              // address of data buffer NULL to force size being returned 
        (LPDWORD)&SizeOfValue       // Get the size of the buffer we need 
    ) ;
                                            
    if( t_Status != ERROR_SUCCESS )
    {
        return (DWORD) REGDB_E_INVALIDVALUE;
    }
 
    /////////////////////////////////////////////////////////////
    if( SizeOfValue <= 0 )
    {
        return (DWORD) REGDB_E_INVALIDVALUE;
    }

    // Allow extra room for strings -- query doesn't include room for NULLs
    //      a-jmoon 8/19/97
    //=====================================================================

    if(TypeOfValue == REG_SZ        ||
       TypeOfValue == REG_EXPAND_SZ ||    
       TypeOfValue == REG_MULTI_SZ) 
    {
        SizeOfValue += 2 ;
    }

    pValue = new BYTE[SizeOfValue];
    if( ! pValue )
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try
    {
        ///////////////////////////////////////////////////////////////////
        // Get the value in its RAW format
        ///////////////////////////////////////////////////////////////////
        if( GetCurrentRawKeyValue(UseKey, pValueName, pValue, (LPDWORD)&TypeOfValue, (LPDWORD)&SizeOfValue) != ERROR_SUCCESS )
        {
            delete []pValue;
			pValue = NULL;
            return (DWORD) REGDB_E_INVALIDVALUE;
        }  

        // If the type is a null termiated string
        // then assign it to the CHString
        // ======================================

        switch(TypeOfValue)
        {
            case REG_SZ:
            case REG_EXPAND_SZ:
            {
                DestValue = (LPCWSTR)pValue;  // Move string in
            }
            break;

            case REG_MULTI_SZ:
            {
                WCHAR *ptemp = (WCHAR *) pValue;
                int stringlength;
                stringlength = wcslen((LPCWSTR)ptemp);
                while(stringlength) 
                {
                    DestValue += (LPCWSTR)ptemp;  // Move string in
                    DestValue += L"\n";            // Linefeed as separator
                    ptemp += stringlength+1;
                    stringlength = wcslen((LPCWSTR)ptemp);
                }
            }       
            break;

            case REG_DWORD:
            {
                LPWSTR pTemp = new WCHAR[MAX_SUBKEY_BUFFERSIZE];
                if(pTemp) 
                {
                    try
                    {
                        StringCchPrintfW( pTemp, 
                                          MAX_SUBKEY_BUFFERSIZE, 
                                          L"%ld", 
                                          *((DWORD*)pValue) );
                        DestValue = pTemp;
                        delete []pTemp;
						pTemp = NULL;
                    }
                    catch ( ... )
                    {
                        delete [] pTemp ;
						pTemp = NULL;
                        throw ;
                    }
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }     
            break;

            case REG_BINARY:
            {
               DestValue.Empty();
              
               // copy into DestValue, Creating a byte buffer wide enough. 
               // Note: SizeOfValue is in bytes, while GetBuffer() returns wide char allocation.
               
               DWORD t_dwResidual = ( SizeOfValue % 2 ) ;
               DWORD t_dwWideSize = ( SizeOfValue / 2 ) + t_dwResidual ;

               memcpy( DestValue.GetBuffer( t_dwWideSize ), pValue, SizeOfValue );
               
               // cap the byte blob  
               if( t_dwResidual )
               {
                    *( (LPBYTE)((LPCWSTR) DestValue) + SizeOfValue ) = NULL;
               }
               
               DestValue.GetBufferSetLength( t_dwWideSize ) ;
            }
            break;

            default:
            {
                delete []pValue;
				pValue = NULL;
                return (DWORD) REGDB_E_INVALIDVALUE;
            }
        }
    }
    catch ( ... )
    {
        delete []pValue;
		pValue = NULL;
		throw;
    }

    /////////////////////////////////////////////////////////////
    delete []pValue;

    return (DWORD)ERROR_SUCCESS;
}
 
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentKeyValue(LPCWSTR pValueName, CHString &DestValue)
{
    return( GetCurrentKeyValue(hKey,  pValueName,  DestValue));
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentKeyValue(HKEY UseKey, LPCWSTR pValueName, CHStringArray &DestValue)
{
    DWORD SizeOfValue = 0L;
    DWORD TypeOfValue;
    LPBYTE pValue;      // Pointer to buffer for value

    DestValue.RemoveAll();

    // Get the size of the buffer we need 

    LONG t_Status = myRegQueryValueEx( 

        UseKey,                 // handle of key to query 
        pValueName,             // address of name of value to query 
        NULL,                   // reserved 
        (LPDWORD)&TypeOfValue,  // address of buffer for value type 
        (LPBYTE) NULL,          // address of data buffer NULL to force size being returned 
        (LPDWORD)&SizeOfValue 
    ) ;

    if( t_Status != ERROR_SUCCESS )
    {
        return (DWORD) REGDB_E_INVALIDVALUE;
    }
 
    /////////////////////////////////////////////////////////////
    if (( SizeOfValue <= 0 ) || (TypeOfValue != REG_MULTI_SZ)) 
    {
        return (DWORD) REGDB_E_INVALIDVALUE;
    }

    SizeOfValue += 2 ;

    pValue = new BYTE[SizeOfValue];
    if( !pValue )
    {
        return (DWORD) REGDB_E_INVALIDVALUE;
    }

    ///////////////////////////////////////////////////////////////////
    // Get the value in its RAW format
    ///////////////////////////////////////////////////////////////////

    try {

        if( GetCurrentRawKeyValue(UseKey, pValueName, pValue, (LPDWORD)&TypeOfValue, (LPDWORD)&SizeOfValue) != ERROR_SUCCESS )
        {
            delete []pValue;
			pValue = NULL;
            return (DWORD) REGDB_E_INVALIDVALUE;
        }  

        // If the type is a null termiated string
        // then assign it to the CHString
        // ======================================

        switch(TypeOfValue)
        {
            case REG_MULTI_SZ:
            {
                LPCWSTR ptemp = (LPCWSTR)pValue;
                int stringlength;
                stringlength = wcslen(ptemp);
                while(stringlength) 
                {
                    DestValue.Add(ptemp);  // Move string in
                    ptemp += stringlength+1;
                    stringlength = wcslen(ptemp);
                }
            }       
            break;

            default:
            {
                delete [] pValue;
				pValue = NULL;
                return (DWORD) REGDB_E_INVALIDVALUE;
            }
        }
    }
    catch ( ... )
    {
        delete [] pValue ;
		pValue = NULL;
        throw ;
    }
    
    delete [] pValue;
	pValue = NULL;
    return (DWORD)ERROR_SUCCESS;
}
 
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentKeyValue (

    LPCWSTR pValueName, 
    CHStringArray &DestValue
)
{
    return GetCurrentKeyValue (

        hKey,  
        pValueName,  
        DestValue
    );
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentKeyValue (

    HKEY UseKey, 
    LPCWSTR pValueName, 
    DWORD &DestValue
)
{
    DWORD SizeOfValue = MAX_SUBKEY_BUFFERSIZE;
    long RetValue;
    DWORD TypeOfValue;
    LPBYTE pValue;      // Pointer to buffer for value
  
    pValue = new BYTE[MAX_SUBKEY_BUFFERSIZE];
    if(pValue) 
    {
        try 
        {
            // Get the value in its RAW format
            // ===============================
            RetValue = GetCurrentRawKeyValue (

                UseKey, 
                pValueName, 
                pValue, 
                (LPDWORD)&TypeOfValue, 
                (LPDWORD)&SizeOfValue
            );

            if( ERROR_SUCCESS == RetValue )
            {
                // If the type is a null termiated string
                // then assign it to the CHString
                // ======================================
                switch(TypeOfValue)
                {
                    case REG_SZ:
                    {
                        DestValue = atol((LPSTR)pValue);
                    }
                    break;

                    case REG_DWORD:
                    {
                        DestValue = *((DWORD*)(pValue));
                    }
                    break;

                    default:
                    {
                        DestValue = (DWORD)0L;
                        RetValue = REGDB_E_INVALIDVALUE; // Invalid value
                    }
                    break;
                }
            }
            delete[] pValue;
			pValue = NULL;
        }
        catch ( ... )
        {
            delete [] pValue ;
			pValue = NULL;
            throw ;
        }
    }
    else
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    return RetValue;
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentKeyValue (

    LPCWSTR pValueName, 
    DWORD &DestValue
)
{
    return( GetCurrentKeyValue(hKey,  pValueName,  DestValue));
}

 //////////////////////////////////////////////////////////////////////
 //  Added support for Binary Type
 //////////////////////////////////////////////////////////////////////
 
DWORD CRegistry::GetCurrentBinaryKeyValue (

    LPCWSTR pValueName, 
    CHString &chsDest
)
{
    DWORD dwType = REG_BINARY;
    DWORD dwRc;
    WCHAR szDest[_MAX_PATH+2], ByteBuf[_MAX_PATH];
    BYTE bRevision[_MAX_PATH+2]; 
    DWORD dwSize = _MAX_PATH;

    dwRc = GetCurrentRawKeyValue (

        hKey, 
        pValueName, 
        bRevision, 
        &dwType, 
        &dwSize
    );

    if( dwRc != ERROR_SUCCESS )
    {
        return dwRc;
    }

    StringCchCopyW( szDest, sizeof( szDest ) / sizeof( WCHAR ), QUOTE );

    for( DWORD i=0; i<dwSize; i++ )
    {
        StringCchPrintfW( ByteBuf, 
                          sizeof( ByteBuf ) / sizeof( WCHAR ),
                          L"%02x", 
                          bRevision[i] );
        
        StringCchCatW( szDest, sizeof( szDest ) / sizeof( WCHAR ), ByteBuf );
    }

    StringCchCatW( szDest, sizeof( szDest ) / sizeof( WCHAR ), QUOTE );
    chsDest = szDest;

    return dwRc;
}

DWORD CRegistry::GetCurrentBinaryKeyValue (

    LPCWSTR pValueName, 
    LPBYTE  pbDest,
    LPDWORD pSizeOfDestValue 
)
{
    DWORD dwType = 0 ;

    return GetCurrentRawKeyValue (

        hKey, 
        pValueName, 
        pbDest, 
        &dwType, 
        &(*pSizeOfDestValue) 
    ) ;
}

DWORD CRegistry::GetCurrentBinaryKeyValue (  
                                HKEY UseKey , 
                                LPCWSTR pValueName , 
                                LPBYTE pbDest , 
                                LPDWORD pSizeOfDestValue )
{
    DWORD dwType = 0 ;

    return GetCurrentRawKeyValue (

        UseKey, 
        pValueName, 
        pbDest, 
        &dwType, 
        &(*pSizeOfDestValue) 
    ) ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentSubKeyName (

    CHString &DestSubKeyName
)
{
    WCHAR KeyName[MAX_SUBKEY_BUFFERSIZE];
    DWORD RetValue;

    // and don't bother having RegEnumKey error out
    if(CurrentSubKeyIndex >= dwcSubKeys) 
    {
    // If we have exceeded the number of subkeys available tell the caller
        return( ERROR_NO_MORE_ITEMS );
    }         

    RetValue = myRegEnumKey (

        hKey, 
        CurrentSubKeyIndex, 
        KeyName,
        MAX_SUBKEY_BUFFERSIZE
    );

    // If we are successfull reading the name
    //=======================================  
    if(ERROR_SUCCESS == RetValue) 
    {
        DestSubKeyName = KeyName;
    }
    else 
    {
    // Otherwise clear the string so we don't leave garbage
    //=====================================================

        DestSubKeyName.Empty();  
    }  

    return RetValue;         // In either event, return the value RegEnumKey returned
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentSubKeyPath (

    CHString &DestSubKeyPath
)
{
    CHString TempName;
    DWORD dwRet;

    dwRet = GetCurrentSubKeyName(TempName);
    if (dwRet == ERROR_SUCCESS) 
    {
        DestSubKeyPath = RootKeyPath+"\\";
        DestSubKeyPath += TempName; 
    }
    else 
    {
        DestSubKeyPath.Empty();
    }

    return dwRet;
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void CRegistry::Close(void)
{   
    if(hSubKey != NULL) 
    {
        RegCloseKey(hSubKey) ;
        hSubKey = NULL ;
    }

    if(hKey != NULL)
    { 
        RegCloseKey(hKey); 
        hKey = NULL;
    }

    if(hRootKey != NULL && m_fFromCurrentUser)
    {
        RegCloseKey(hRootKey); 
        hRootKey = NULL;   
    }

    SetDefaultValues();     // Reset all the member vars for next
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::OpenSubKey(void)
{
    CHString SubKeyPath;
    LONG RetValue;

    // If they try and open the same subkey again then
    // leave things alone, otherwise open the subkey

    if(hSubKey) 
    {
        return ERROR_SUCCESS;
    }

    // Get the current subkey path
    //============================
    GetCurrentSubKeyPath(SubKeyPath);


    // Just return the value and the hKey value never gets changed from NULL
    //======================================================================

    RetValue = myRegOpenKeyEx (

        hRootKey, 
        (LPCWSTR)SubKeyPath,    // address of name of subkey to open 
        (DWORD) 0,              // reserved 
        KEY_READ,               // security access mask 
        (PHKEY)&hSubKey         // address of handle of open key 
    ); 

    return RetValue;
}


 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void CRegistry::RewindSubKeys(void)
{
    CurrentSubKeyIndex = 0;
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void CRegistry::CloseSubKey(void)
{
    if(hSubKey != NULL) 
    {
        RegCloseKey(hSubKey); 
    }

    hSubKey = NULL; // Only Close once
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentRawSubKeyValue (

    LPCWSTR pValueName, 
    void *pDestValue,
    LPDWORD pValueType, 
    LPDWORD pSizeOfDestValue
)
{
    // Try and open subkey
    // and set hSubKey variable
    // ======================== 
    DWORD RetValue = OpenSubKey();

    // If subkey is open then get value
    // ================================
    if(ERROR_SUCCESS == RetValue) 
    {
        RetValue = GetCurrentRawKeyValue (

            hSubKey, 
            pValueName, 
            pDestValue, 
            pValueType,  
            pSizeOfDestValue
        );
    }

    return RetValue;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentSubKeyValue (

    LPCWSTR pValueName, 
    void *pDestValue,
    LPDWORD pSizeOfDestValue
)
{
    DWORD RetValue;

    // Try and open subkey
    // and set hSubKey variable
    // ======================== 
    RetValue = OpenSubKey();

    // If subkey is open then get value
    // ================================
    if(ERROR_SUCCESS == RetValue) 
    {
        RetValue = GetCurrentRawSubKeyValue (

            pValueName, 
            pDestValue, 
            NULL, 
            pSizeOfDestValue
        );
    }

    return RetValue;
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentSubKeyValue (

    LPCWSTR pValueName, 
    CHString &DestValue
)
{
    DWORD RetValue;

    // Try and open subkey
    // and set hSubKey variable
    // ======================== 
    RetValue = OpenSubKey();

    // If subkey is open then get value
    // ================================
    if(ERROR_SUCCESS == RetValue) 
    {
        RetValue = GetCurrentKeyValue (

            hSubKey, 
            pValueName,
            DestValue
        );
    }

    return RetValue;
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::GetCurrentSubKeyValue (

    LPCWSTR pValueName, 
    DWORD &DestValue
)
{
    DWORD RetValue;

// Try and open subkey
// and set hSubKey variable
// ======================== 
    RetValue = OpenSubKey();

// If subkey is open then get value
// ================================
    if(ERROR_SUCCESS == RetValue) 
    {
        RetValue = GetCurrentKeyValue (

            hSubKey, 
            pValueName,
            DestValue
        );
    }

    return RetValue;
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::NextSubKey(void)
{
    if (CurrentSubKeyIndex >= dwcSubKeys) 
    {
        return( ERROR_NO_MORE_ITEMS );
    }

    // Close the currently opened subkey
    CloseSubKey();

    if(++CurrentSubKeyIndex >= dwcSubKeys) 
    {
        // CurrentSubKeyIndex is 0 based, dwcSubKeys is one based
        return( ERROR_NO_MORE_ITEMS );
    }
    else 
    {
        return (ERROR_SUCCESS);           
    }
}

 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void CRegistry::PrepareToReOpen(void)
{ 
   Close();     
   SetDefaultValues(); 
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  SetCurrentKeyValueString(LPCSTR pValueName, CHString &DestValue)
 Description:   sets registry string using REG_SZ
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::SetCurrentKeyValue (

    LPCWSTR pValueName, 
    CHString &DestValue
)
{
    DWORD dwResult;
    
    if(DestValue.Find(_T('%')) != -1)
    {
        dwResult = SetCurrentKeyValueExpand (

            hKey, 
            pValueName, 
            DestValue
        );
    }
    else
    {
        dwResult = SetCurrentKeyValue (

            hKey, 
            pValueName, 
            DestValue
        );
    }
    
    return dwResult ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:  
 Description:
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::SetCurrentKeyValue (

    LPCWSTR pValueName, 
    DWORD &DestValue
)
{
    DWORD dwResult = SetCurrentKeyValue (

        hKey, 
        pValueName, 
        DestValue
    );

    return dwResult ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: SetCurrentKeyValue(LPCSTR pValueName, CHStringArray &DestValue)
 Description: sets registry string using REG_MULIT_SZ
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::SetCurrentKeyValue (

    LPCWSTR pValueName, 
    CHStringArray &DestValue
)
{
    DWORD dwResult = SetCurrentKeyValue (

        hKey, 
        pValueName, 
        DestValue
    );

    return dwResult ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: SetCurrentKeyValue(HKEY UseKey, LPCSTR pValueName, CHString &DestValue)
 Description: sets registry string using REG_MULIT_SZ
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::SetCurrentKeyValue (

    HKEY hUseKey, 
    LPCWSTR pValueName, 
    CHString &DestValue
)
{
    DWORD dwResult = myRegSetValueEx (

        hUseKey,    // key handle
        pValueName, // name of value
        0,  // reserved -- must be zero
        REG_SZ, // data type
        (const BYTE*)(LPCWSTR)DestValue,
        ( DestValue.GetLength() + 1 ) * sizeof ( WCHAR ) 
    );
        
    return dwResult ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: SetCurrentKeyValue(HKEY UseKey, LPCSTR pValueName, DWORD &DestValue)
 Description: sets registry string using REG_MULIT_SZ
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::SetCurrentKeyValue (

    HKEY hUseKey, 
    LPCWSTR pValueName, 
    DWORD &DestValue
)
{
    DWORD dwResult = myRegSetValueEx (

        hUseKey,    // key handle
        pValueName, // name of value
        0,  // reserved -- must be zero
        REG_DWORD,  // data type
        (const BYTE*)&DestValue,
        sizeof(DWORD)
    );
        
    return dwResult ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: SetCurrentKeyValue(HKEY UseKey, LPCSTR pValueName, CHStringArray &DestValue)
 Description: sets registry string using REG_MULIT_SZ
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::SetCurrentKeyValue (

    HKEY hUseKey, 
    LPCWSTR pValueName, 
    CHStringArray &DestValue
)
{
    DWORD dwResult = ERROR_SUCCESS;

    DWORD dwArrayChars = 0;
    for ( LONG Index = 0; Index < DestValue.GetSize(); Index++ )
    {
        CHString chsTemp = DestValue.GetAt(Index);
        
        dwArrayChars += (  chsTemp.GetLength() + 1 ) * sizeof(WCHAR);
    }

    // Add room for the trailing wide character null
    dwArrayChars += 2;
    
    WCHAR* pValue = new WCHAR[dwArrayChars];
    if( !pValue )
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }
 
    try 
    {
        memset( pValue, 0, dwArrayChars*sizeof(WCHAR) );
        
        DWORD dwCharCount = 0;
        for ( Index = 0; Index < DestValue.GetSize(); Index++ )
        {
            CHString chsTemp = DestValue.GetAt(Index);
                
            StringCchCopyW(&pValue[dwCharCount], dwArrayChars - dwCharCount, chsTemp.GetBuffer(0));

            dwCharCount += (  chsTemp.GetLength() + 1 ) ;
        }

        dwResult = myRegSetValueEx (

            hUseKey,    // key handle
            pValueName, // name of value
            0,  // reserved -- must be zero
            REG_MULTI_SZ,   // data type
            (const BYTE *)pValue,
            dwArrayChars
        );

        delete [] pValue;
		pValue = NULL;
    }
    catch ( ... )
    {
        delete [] pValue;
		pValue = NULL;
        throw ;
    }
    
        
    return dwResult ;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: SetCurrentKeyValueExpand(HKEY UseKey, LPCSTR pValueName, CHString &DestValue)
 Description: sets registry string using REG_EXPAND_SZ, required when the string contains variables (e.g., %SystemRoot%)
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::SetCurrentKeyValueExpand (

    HKEY hUseKey, 
    LPCWSTR pValueName, 
    CHString &DestValue
)
{
    DWORD dwResult = myRegSetValueEx (

        hUseKey,    // key handle
        pValueName, // name of value
        0,  // reserved -- must be zero
        REG_EXPAND_SZ,  // data type
        (const BYTE*)(LPCWSTR)DestValue,
        ( DestValue.GetLength() + 1 ) * sizeof ( WCHAR ) 
    );
        
    return dwResult ;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: SetCurrentKeyValue(HKEY UseKey, LPCSTR pValueName, CHStringArray &DestValue)
 Description: sets registry string using REG_MULIT_SZ
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::DeleteCurrentKeyValue (

    LPCWSTR pValueName
)
{
    return myRegDeleteValue (

        hKey, 
        pValueName
    );
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: SetCurrentKeyValue(HKEY UseKey, LPCSTR pValueName, CHStringArray &DestValue)
 Description: sets registry string using REG_MULIT_SZ
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
DWORD CRegistry::DeleteCurrentKeyValue (

    HKEY UseKey, 
    LPCWSTR pValueName
)
{
    return myRegDeleteValue (

        UseKey, 
        pValueName
    );
}   

//*****************************************************************
///////////////////////////////////////////////////////////////////
//
//  Class:  CRegistrySearch
//
//  This class searches through the registry for matching Values, 
//  Keys and Partial Keys 
//
///////////////////////////////////////////////////////////////////
//*****************************************************************
CRegistrySearch::CRegistrySearch()
{
}

///////////////////////////////////////////////////////////////////
CRegistrySearch::~CRegistrySearch()
{
}

///////////////////////////////////////////////////////////////////
//
//  void CRegistrySearch::CheckAndAddToList( CRegistry * pReg, 
//                                         CHString chsSubKey, 
//                                         CHString chsFullKey,
//                                         CHPtrArray & chpaList,
//                                         CHString chsSearchString,
//                                         int nSearchType)
//
//  Desc:       This function performs the requested search on the
//              current key and if it matches, then adds it to the
//              CHPtrArray
//
//  Parameters: 
//              pReg        - The current registry class
//              chsSubKey   - The current Key
//              chsFullKey  - The complete key
//              chpaList    - The target CHPtrArray
//              chsSearchString - The string to search for
//              nSearchType - The type of search, the following are
//                            supported:
//                            KEY_FULL_MATCH_SEARCH      
//                               Only keys that match the chsSearchString
//                            KEY_PARTIAL_MATCH_SEARCH   
//                               Keys that have chsSearchString anywhere in them
//                            VALUE_SEARCH               
//                               Values that match chsSearchString
//
//  History
//          Initial coding      jennymc     10/10/96
//  
///////////////////////////////////////////////////////////////////
void CRegistrySearch::CheckAndAddToList (

    CRegistry * pReg, 
    CHString chsSubKey, 
    CHString chsFullKey,
    CHPtrArray & chpaList,
    CHString chsSearchString,
    CHString chsValue,
    int nSearchType
)
{
    BOOL bFound = FALSE;

    //====================================================
    //  We need to check out the current key to see if it
    //  matches any of our criteria.
    //====================================================

    if( nSearchType == VALUE_SEARCH )
    {
        //====================================================
        //  If it is a Value search, then let us try to open
        //  the value.  
        //====================================================

        CHString chsTmp ;

        if( pReg->GetCurrentSubKeyValue(chsValue, chsTmp) == ERROR_SUCCESS)
        {
            if( chsSearchString.CompareNoCase(chsTmp) == 0 )
            {
                bFound = TRUE;
            }
        }
    }        
    else if( nSearchType == KEY_FULL_MATCH_SEARCH )
    {
        if( chsSearchString == chsSubKey )
        {
            bFound = TRUE;
        }
    }
    else
    {
        if( chsSubKey.Find(chsSearchString) )
        {
            bFound = TRUE;
        }
    }
    //====================================================
    //  If it was found, then record the key location
    //====================================================
    if( bFound )
    {
        CHString *pchsPtr = new CHString;
        if ( pchsPtr )
        {
            try 
            {
                *pchsPtr = chsFullKey;
                chpaList.Add( pchsPtr );
            }
            catch ( ... )
            {
                delete pchsPtr ;
				pchsPtr = NULL;
                throw ;
            }
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }
}

///////////////////////////////////////////////////////////////////
//  Public function:  Documented in cregcls.h
//
//  History
//          Initial coding      jennymc     10/10/96
//
///////////////////////////////////////////////////////////////////
BOOL CRegistrySearch::SearchAndBuildList (

    CHString chsRootKey, 
    CHPtrArray & cpaList,
    CHString chsSearchString,
    CHString chsValue,
    int nSearchType,
    HKEY hkDefault
)
{
    BOOL bRc;

    //=======================================================
    //  Allocate a registry class to open and enumerate the
    //  requested key.
    //=======================================================

    CRegistry *pReg = new CRegistry;
    if( !pReg )
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    try 
    {
        //=======================================================
        //  If the key cannot be opened, then cleanup and back
        //  out.
        //=======================================================
        if( pReg->OpenAndEnumerateSubKeys(hkDefault,chsRootKey, KEY_READ ) != ERROR_SUCCESS )
        {
            delete pReg ;
			pReg = NULL;
            return FALSE;
        }

        try 
        {
            CHString chsSubKey ;

            //=======================================================
            //  As long as there are subkeys under this key,
            //  let us open and enumerate each one, each time 
            //  checking if it has the value or part of the 
            //  string we want. 
            //
            //  The GetCurrentSubKeyName function only returns the
            //  current key, we have to add it to the end of the
            //  Parent key in order to get the full key name.
            //=======================================================
            while ( pReg->GetCurrentSubKeyName(chsSubKey) == ERROR_SUCCESS )
            {
                CHString chsFullKey ;
                CHString chsSlash = L"\\";

                chsFullKey = chsRootKey + chsSlash + chsSubKey;

                CheckAndAddToList (

                    pReg, 
                    chsSubKey, 
                    chsFullKey, 
                    cpaList, 
                    chsSearchString, 
                    chsValue, 
                    nSearchType 
                );

                pReg->NextSubKey();

                bRc = SearchAndBuildList (

                    chsFullKey, 
                    cpaList, 
                    chsSearchString, 
                    chsValue, 
                    nSearchType 
                );
            }

            //=======================================================
            //  Close the current key and delete the registry pointer
            //=======================================================
            pReg->Close();

        }
        catch ( ... )
        {
            pReg->Close();

            throw ;
        }

        delete pReg;
		pReg = NULL;
    }
    catch ( ... )
    {
        delete pReg ;
		pReg = NULL;
        throw ;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////
BOOL CRegistrySearch::FreeSearchList (

    int nType, 
    CHPtrArray & cpaList 
)
{
    BOOL bRc;
    int i;
    int nNum =  cpaList.GetSize();

    switch( nType )
    {
        case CSTRING_PTR:
        {
            CHString *pPtr;
            for ( i=0; i < nNum; i++ )
            {
                pPtr = ( CHString * ) cpaList.GetAt(i);
                delete pPtr;
				pPtr = NULL;
            }
            bRc = TRUE;
        }
        break;

        default:
        {
            bRc = FALSE;
        }
        break;
    }

    if( bRc )
    {
        cpaList.RemoveAll();
    }

    return bRc;
}

//////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION    :   MOPropertySet_DevMem::LocateNTOwnerDevice
//
//  DESCRIPTION :   Helper function for locating a key of the specified
//                  name, or a key containg the specified value name.
//
//  INPUTS      :   HKEY        hKeyParent - Parent Key
//                  LPCWSTR     pszKeyName - Name of Key to open
//                  LPCWSTR     pszSubKeyName - Name of SubKey to Find
//                  LPCWSTR*    ppszValueNames - Array of Value Names
//                  DWORD       dwNumValueNames - Number of names in array
//
//  OUTPUTS     :   CHString&   strFoundKeyName -   Storage for name of key if found.
//                  CHString&   strFoundKeyPath - Storage for pathed key name
//
//  RETURNS     :   nothing
//
//  COMMENTS    :   Recursively Enumerates the registry from a specified
//                  starting point until it locates a subkey matching either
//                  a supplied subkey name or a value name matching one of
//                  the supplied names.
//
//////////////////////////////////////////////////////////////////////////////

BOOL CRegistrySearch::LocateKeyByNameOrValueName(

    HKEY        hKeyParent,
    LPCWSTR     pszKeyName,
    LPCWSTR     pszSubKeyName,
    LPCWSTR*    ppszValueNames,
    DWORD       dwNumValueNames,
    CHString&   strFoundKeyName,
    CHString&   strFoundKeyPath
)
{
    CRegistry   reg;
    BOOL        fFound = FALSE;

    // Get out of here if we got garbage parameters
    if ( NULL == pszSubKeyName && NULL == ppszValueNames )
    {
        return FALSE;
    }

    // Open the key for enumeration and go through the sub keys.

    LONG t_Status = reg.OpenAndEnumerateSubKeys ( 

        hKeyParent,
        pszKeyName,
        KEY_READ 
    ) ;

    if ( ERROR_SUCCESS == t_Status )
    {
        try 
        {
            CHString    strSubKeyName;
            DWORD       dwValueBuffSize =   0;

            // As long as we can get sub keys, we can try to find values.

            while ( !fFound && ERROR_SUCCESS == reg.GetCurrentSubKeyName( strSubKeyName ) )
            {

                // First check if the specified sub key name matches the sub key name.
                // If not, then check for the value names.

                if ( NULL != pszSubKeyName && strSubKeyName == pszSubKeyName )
                {
                    fFound = TRUE;
                }
                else if ( NULL != ppszValueNames )
                {
                    // Enumerate the value names in the array until one is found.

                    for ( DWORD dwEnum = 0; !fFound && dwEnum < dwNumValueNames; dwEnum++ )
                    {
                        t_Status = reg.GetCurrentSubKeyValue(

                            ppszValueNames[dwEnum],
                            NULL,
                            &dwValueBuffSize 
                        ) ;

                        if ( ERROR_SUCCESS  ==  t_Status )
                        {
                            fFound = TRUE;
                        }

                    }   // FOR dwEnum

                }   // IF NULL != ppszValueNames

                // Check if one of the methods located the key.  If so, store all
                // the current values.

                if ( !fFound )
                {
                    //
                    // No success, so recurse (WOOHOO!)
                    //

                    fFound = LocateKeyByNameOrValueName (

                        reg.GethKey(),
                        strSubKeyName,
                        pszSubKeyName,
                        ppszValueNames,
                        dwNumValueNames,
                        strFoundKeyName,
                        strFoundKeyPath 
                    );
                }
                else
                {
                    // Store the actual key name in both the single
                    // name and path.  We will build the full path
                    // as we slide back up the recursive chain.

                    strFoundKeyName = strSubKeyName;
                    strFoundKeyPath = strSubKeyName;
                }

                // Lastly, since fFound may now have been set by recursion, we will
                // want to attach the current key path to the key name we've opened
                // so when we return out of here, we get the full path to the
                // located key name stored correctly.

                if ( fFound )
                {
                    CHString strSavePath( strFoundKeyPath );
                    strFoundKeyPath.Format(L"%s\\%s", (LPCWSTR) pszKeyName, (LPCWSTR) strSavePath );
                }
                else
                {
                    // Not found yet, so go to the next key.
                    reg.NextSubKey();
                }

            }   // While !Found

            reg.Close();
        }
        catch ( ... )
        {
            reg.Close () ;

            throw ;
        }

    }   // If OpenAndEnumerateSubKeys

    return fFound;

}

//========================================================================================
// These routines are for the multiplatform support
DWORD CRegistry::GetPlatformID(void)
{
    OSVERSIONINFOA OsVersionInfoA;

    OsVersionInfoA.dwOSVersionInfoSize = sizeof (OSVERSIONINFOA) ;
    GetVersionExA(&OsVersionInfoA);

    return OsVersionInfoA.dwPlatformId;
}

LONG CRegistry::myRegCreateKeyEx (

    HKEY hKey, 
    LPCWSTR lpwcsSubKey, 
    DWORD Reserved, 
    LPWSTR lpwcsClass, 
    DWORD dwOptions, 
    REGSAM samDesired, 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
    PHKEY phkResult, 
    LPDWORD lpdwDisposition
)
{
    if (CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT)
    {
        return RegCreateKeyExW (

            hKey, 
            lpwcsSubKey, 
            Reserved, 
            lpwcsClass, 
            dwOptions, 
            samDesired, 
            lpSecurityAttributes, 
            phkResult, 
            lpdwDisposition
        );
    }
    else
    {
        char *szSubKey = NULL ;
        bool t_ConversionFailure = false ;

        WCSTOANSISTRING ( lpwcsSubKey , szSubKey , t_ConversionFailure ) ;
        
	if (t_ConversionFailure)
	{
	  return ERROR_NO_UNICODE_TRANSLATION;
	}

        char *lpClass = NULL ;
        t_ConversionFailure = false ;

        WCSTOANSISTRING ( lpwcsClass , lpClass , t_ConversionFailure );
        
        if (t_ConversionFailure)
	{
	  return ERROR_NO_UNICODE_TRANSLATION;
	}
	
        return RegCreateKeyExA (

                    hKey, 
                    szSubKey, 
                    Reserved, 
                    lpClass, 
                    dwOptions, 
                    samDesired, 
                    lpSecurityAttributes, 
                    phkResult, 
                    lpdwDisposition
                );
    }
    return ERROR_NO_UNICODE_TRANSLATION;
}

LONG CRegistry::myRegSetValueEx (

    HKEY hKey, 
    LPCWSTR lpwcsSubKey, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE *lpData, 
    DWORD cbData
)
{
    LONG lRet;

    if ( CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT )
    {
        lRet = RegSetValueExW (

            hKey, 
            lpwcsSubKey, 
            Reserved, 
            dwType, 
            lpData, 
            cbData
        );
    }
    else
    {
// First convert the key name

        bool t_ConversionFailure = false ;
        char *pName = NULL ;

        if ( lpwcsSubKey != NULL )
        {
            WCSTOANSISTRING ( lpwcsSubKey , pName , t_ConversionFailure ) ;
            if ( ! t_ConversionFailure )
            {
                if ( ! pName )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
                return ERROR_NO_UNICODE_TRANSLATION ;
            }
        }

// Now, we may need to convert the data

        BYTE *pMyData = NULL ;

        try
        {
            DWORD dwMySize = 0 ;

            bool bDoit = false ;

            switch ( dwType )
            {
                case REG_EXPAND_SZ:
                case REG_SZ:
                {
// If it's a simple string, convert it

                    t_ConversionFailure = false ;

                    WCHAR *pStrUnicode = ( WCHAR * ) lpData ;
                    char *pStrAnsi = NULL ;

                    WCSTOANSISTRING ( pStrUnicode , pStrAnsi , t_ConversionFailure ) ;

                    if ( ! t_ConversionFailure )
                    {
                        if ( pStrAnsi != NULL )
                        {
                            pMyData = ( BYTE * ) pStrAnsi ;
                            dwMySize = strlen ( pStrAnsi ) ;

                            bDoit = true ;
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }
                    else
                    {
                        return ERROR_NO_UNICODE_TRANSLATION ;
                    }
                }
                break ;

                case REG_MULTI_SZ:
                {
// If it's a multi-sz, it take a little more

                    int nLen = ::WideCharToMultiByte (

                        CP_ACP , 
                        0 , 
                        ( const WCHAR *) lpData , 
                        cbData , 
                        NULL , 
                        0 , 
                        NULL , 
                        NULL
                    );

                    if ( nLen > 0 ) 
                    {
                        pMyData = new BYTE [ nLen ] ;
                        if ( pMyData != NULL )
                        {
                            dwMySize = WideCharToMultiByte (

                                CP_ACP , 
                                0, 
                                ( const WCHAR * ) lpData , 
                                cbData , 
                                ( char * )pMyData , 
                                nLen , 
                                NULL , 
                                NULL
                            ) ;

                            bDoit = true;
                        }
                        else
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                    }
                    else
                    {
                        lRet = ERROR_NO_UNICODE_TRANSLATION ;
                    }
                }
                break ;

                default:
                {
// All other types, just write it

                    pMyData = ( BYTE * ) lpData ;
                    dwMySize = cbData ;
                    bDoit = true;
                }
                break ;
            }

            if ( bDoit )
            {
                lRet = RegSetValueExA (

                    hKey, 
                    pName, 
                    Reserved, 
                    dwType, 
                    pMyData, 
                    dwMySize
                );
            }

            if ( ( dwType == REG_MULTI_SZ ) && ( pMyData != NULL ) )
            {
                delete [] pMyData ;
				pMyData = NULL;
            }
        }
        catch ( ... )
        {
            if ( ( dwType == REG_MULTI_SZ ) && ( pMyData != NULL ) )
            {
                delete [] pMyData ;
				pMyData = NULL;
            }

            throw ;
        }
    }

    return lRet;
}

LONG CRegistry::myRegQueryValueEx (

    HKEY hKey, 
    LPCWSTR lpwcsSubKey, 
    LPDWORD Reserved, 
    LPDWORD dwType, 
    LPBYTE lpData, 
    LPDWORD cbData
)
{
    LONG lRet;

    if ( CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT )
    {
        lRet = RegQueryValueExW (

            hKey, 
            lpwcsSubKey, 
            Reserved, 
            dwType, 
            lpData, 
            cbData
        );
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *pName = NULL ;

        if ( lpwcsSubKey != NULL )
        {
            WCSTOANSISTRING ( lpwcsSubKey , pName , t_ConversionFailure ) ;
            if ( ! t_ConversionFailure )
            {
                if ( ! pName )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
                return ERROR_NO_UNICODE_TRANSLATION ;
            }
        }

        BYTE *pMyData = NULL ;

        try
        {
            if ( lpData != NULL )
            {
                pMyData = new BYTE [ *cbData ] ;
                if ( ! pMyData )
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }

            if ( ( pMyData != NULL ) || (lpData == NULL))
            {
                DWORD dwMySize = *cbData;

                lRet = RegQueryValueExA (

                    hKey, 
                    pName, 
                    Reserved, 
                    dwType, 
                    pMyData, 
                    & dwMySize
                ) ;

// If it worked, we may need to convert the strings

                if ( lRet == ERROR_SUCCESS )
                {
                    switch ( *dwType )
                    {
                        case REG_EXPAND_SZ:
                        case REG_SZ:
                        {
// If lpData is null, there isn't any way to say for sure how long the target string needs
// to be.  However, it can't be more than twice as long (it can be less).

                            if (lpData == NULL)
                            {
                                *cbData = dwMySize * 2;
                            }
                            else
                            {
                                int nLen = ::MultiByteToWideChar (

                                    CP_ACP, 
                                    0, 
                                    (const char *)pMyData, 
                                    -1, 
                                    (WCHAR *)lpData, 
                                    *cbData
                                );  
// Convert to bytes
                                *cbData = nLen * 2;
                            }
                        }
                        break ;

                        case REG_MULTI_SZ:
                        {
// If lpData is null, there isn't any way to say for sure how long the target string needs
// to be.  However, it can't be more than twice as long (it can be less).

                            if (lpData == NULL)
                            {
                                *cbData = dwMySize * 2;
                            }
                            else
                            {
                                DWORD dwConverted = MultiByteToWideChar (

                                    CP_ACP, 
                                    0, 
                                    (const char *)pMyData, 
                                    dwMySize, 
                                    (WCHAR *)lpData, 
                                    *cbData
                                );
                            }
                        }
                        break ;

                        default:
                        {
// All other types are handled in RegQueryValue

                            *cbData = dwMySize ;

                            if( NULL != lpData )
                            {
                                memcpy ( lpData , pMyData , *cbData ) ;
                            }
                        }
                        break ;
                    }
                }

                delete [] pMyData;
				pMyData = NULL;
            }
        }
        catch ( ... )
        {
            delete [] pMyData ;
			pMyData = NULL;
            throw ;
        }
    }

    return lRet;
}

LONG CRegistry::myRegEnumKey (

    HKEY hKey, 
    DWORD dwIndex, 
    LPWSTR lpwcsName, 
    DWORD cbData       // number of characters in the lpwcsName buffer
)
{
    if (CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT)
    {
        return RegEnumKeyW (

            hKey, 
            dwIndex, 
            lpwcsName, 
            cbData
        );
    }
    else
    {
        char szName[MAX_SUBKEY_BUFFERSIZE];

        LONG lRet = RegEnumKeyA (

            hKey, 
            dwIndex, 
            szName, 
            sizeof(szName)/sizeof(szName[0])
        );

        if (lRet == ERROR_SUCCESS)
        {
            bool t_ConversionFailure = false ;
            WCHAR *pName = NULL ;
            // MAX_SUBKEY_BUFFERSIZE <= _MAX_PATH
            ANSISTRINGTOWCS ( szName , pName , t_ConversionFailure ) ;
            if ( ! t_ConversionFailure ) 
            {
                if ( pName )
                {
                    StringCchCopyW(lpwcsName, cbData, pName);
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
                return ERROR_NO_UNICODE_TRANSLATION ;
            }
            
        }

        return lRet;
    }
}

LONG CRegistry::myRegDeleteValue (

    HKEY hKey, 
    LPCWSTR lpwcsName
)
{
    if ( CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT )
    {
        return RegDeleteValueW (

            hKey, 
            lpwcsName
        );
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *pName = NULL ;
        WCSTOANSISTRING ( lpwcsName, pName , t_ConversionFailure ) ;

        if ( ! t_ConversionFailure ) 
        {
            if ( pName )
            {
                return RegDeleteValueA (

                    hKey, 
                    pName
                );
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            return ERROR_NO_UNICODE_TRANSLATION ;
        }
    }
    return ERROR_NO_UNICODE_TRANSLATION;
}

LONG CRegistry::myRegDeleteKey (

    HKEY hKey, 
    LPCWSTR lpwcsName
)
{
    if ( CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT )
    {
        return RegDeleteKeyW (

            hKey, 
            lpwcsName
        );
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *pName = NULL ;
        WCSTOANSISTRING ( lpwcsName, pName , t_ConversionFailure ) ;

        if ( ! t_ConversionFailure ) 
        {
            if ( pName )
            {
                return RegDeleteKeyA (

                    hKey, 
                    pName
                );
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            return ERROR_NO_UNICODE_TRANSLATION ;
        }
    }
    return ERROR_NO_UNICODE_TRANSLATION;
}

LONG CRegistry::myRegOpenKeyEx (

    HKEY hKey, 
    LPCWSTR lpwcsSubKey, 
    DWORD ulOptions, 
    REGSAM samDesired, 
    PHKEY phkResult
)
{
    if (CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT)
    {
        return RegOpenKeyExW (

            hKey, 
            lpwcsSubKey, 
            ulOptions, 
            samDesired, 
            phkResult
        );
    }

    char *pName = NULL ;
    bool t_ConversionFailure = false ;

    WCSTOANSISTRING ( lpwcsSubKey, pName , t_ConversionFailure );
    
    if ( ! t_ConversionFailure ) 
    {
        if ( pName )
        {
            return RegOpenKeyExA (

                hKey, 
                pName, 
                ulOptions, 
                samDesired, 
                phkResult
            );
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }

    return ERROR_NO_UNICODE_TRANSLATION;
}

LONG CRegistry::myRegQueryInfoKey (

    HKEY hKey, 
    LPWSTR lpwstrClass, 
    LPDWORD lpcbClass,
    LPDWORD lpReserved, 
    LPDWORD lpcSubKeys, 
    LPDWORD lpcbMaxSubKeyLen,  
    LPDWORD lpcbMaxClassLen,  
    LPDWORD lpcValues, 
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen, 
    LPDWORD lpcbSecurityDescriptor, 
    PFILETIME lpftLastWriteTime
)
{
    if ( CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT )
    {
        return RegQueryInfoKeyW (

            hKey, 
            lpwstrClass, 
            lpcbClass, 
            lpReserved, 
            lpcSubKeys, 
            lpcbMaxSubKeyLen, 
            lpcbMaxClassLen, 
            lpcValues, 
            lpcbMaxValueNameLen, 
            lpcbMaxValueLen, 
            lpcbSecurityDescriptor, 
            lpftLastWriteTime
        );
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *pName = NULL ;
        WCSTOANSISTRING ( lpwstrClass, pName, t_ConversionFailure );

        if ( ! t_ConversionFailure ) 
        {
            if ( pName )
            {

                return RegQueryInfoKeyA (

                    hKey, 
                    pName, 
                    lpcbClass, 
                    lpReserved, 
                    lpcSubKeys, 
                    lpcbMaxSubKeyLen, 
                    lpcbMaxClassLen, 
                    lpcValues, 
                    lpcbMaxValueNameLen, 
                    lpcbMaxValueLen, 
                    lpcbSecurityDescriptor, 
                    lpftLastWriteTime
                ) ;
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            return ERROR_NO_UNICODE_TRANSLATION;
        }
    }
    return ERROR_NO_UNICODE_TRANSLATION;
}

LONG CRegistry::myRegEnumValue (

    HKEY hKey, 
    DWORD dwIndex, 
    LPWSTR lpValueName,
    LPDWORD lpcbValueName, 
    LPDWORD lpReserved, 
    LPDWORD lpType,
    LPBYTE lpData, 
    LPDWORD lpcbData
)
{
    if (CRegistry::s_dwPlatform == VER_PLATFORM_WIN32_NT)
    {
        return RegEnumValueW (

            hKey, 
            dwIndex, 
            lpValueName, 
            lpcbValueName, 
            lpReserved, 
            lpType, 
            lpData, 
            lpcbData
        );
    }
    else
    {
        char szData[MAX_PATH * 2];

        LONG lRet = RegEnumValueA (

            hKey, 
            dwIndex, 
            szData, 
            lpcbValueName, 
            lpReserved, 
            lpType, 
            lpData, 
            lpcbData
        );

        if (lRet == ERROR_SUCCESS)
        {
            // Get the name.
            mbstowcs(lpValueName, szData, lstrlenA(szData) + 1);

            // Get the value if the data is a string.
            if (*lpType == REG_SZ || *lpType == REG_MULTI_SZ)
            {
                StringCchCopyA(szData, sizeof(szData)/sizeof(char), (LPSTR) lpData);
                mbstowcs((LPWSTR) lpData, szData, lstrlenA(szData) + 1);
                *lpcbData = (lstrlenW((LPWSTR) lpData) + 1) * sizeof(WCHAR);
            }
        }

        return lRet;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\include\analyser.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  analyser.h
//
//  Purpose: query analysis support.
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __WBEM_ANALYSER__H_
#define __WBEM_ANALYSER__H_

#include <stdio.h>

#pragma warning(4 : 4275 4800 4786 4251)

#include <wbemidl.h>
#include <GenLex.h>
#include <SQLLex.h>
#include <SQL_1.h>       // SQL level 1 tokens and expressions  
#include <chstring.h>
#include <chstrarr.h>
#include <comdef.h>
#include <vector>

#define DELETE_ME 
//-----------------------------


class CQueryAnalyser
{
public:

    static HRESULT WINAPI GetNecessaryQueryForProperty (

		IN SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
		IN LPCWSTR wszPropName,
		DELETE_ME SQL_LEVEL_1_RPN_EXPRESSION *&pNewExpr
	) ;

    static HRESULT WINAPI GetValuesForProp (

		SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
        LPCWSTR wszPropName, 
		CHStringArray& awsVals
	) ;

    // overloaded version in case client wants to use vector of _bstr_t's:

    static HRESULT WINAPI GetValuesForProp (

		SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
        LPCWSTR wszPropName, 
		std::vector<_bstr_t> &vectorVals
	) ;

    static HRESULT WINAPI GetValuesForProp (

	    SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
        LPCWSTR wszPropName, 
	    std::vector<int> &vectorVals
    );

    static HRESULT WINAPI GetValuesForProp (

		SQL_LEVEL_1_RPN_EXPRESSION *pExpr,
        LPCWSTR wszPropName, 
		std::vector<_variant_t> &vectorVals
	) ;

protected:

    static BOOL WINAPI IsTokenAboutProperty (

		IN SQL_LEVEL_1_TOKEN &Token,
		IN LPCWSTR wszPropName
	) ;

    static void WINAPI AppendQueryExpression (

		IN SQL_LEVEL_1_RPN_EXPRESSION *pDest,
		IN SQL_LEVEL_1_RPN_EXPRESSION *pSource
	) ;

    static HRESULT WINAPI AndQueryExpressions (

		IN SQL_LEVEL_1_RPN_EXPRESSION *pFirst,
		IN SQL_LEVEL_1_RPN_EXPRESSION *pSecond,
		OUT SQL_LEVEL_1_RPN_EXPRESSION *pNew
	) ;

    static HRESULT WINAPI OrQueryExpressions (

		IN SQL_LEVEL_1_RPN_EXPRESSION *pFirst,
		IN SQL_LEVEL_1_RPN_EXPRESSION *pSecond,
		OUT SQL_LEVEL_1_RPN_EXPRESSION *pNew
	);
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\utils.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  utils.cpp
//
//  Purpose: utility functions
//
//***************************************************************************

#include "precomp.h"
#include <utillib.h>
#include <utils.h>

// see comments in header
DWORD WINAPI NormalizePath(
                                    
    LPCWSTR lpwszInPath, 
    LPCWSTR lpwszComputerName, 
    LPCWSTR lpwszNamespace,
    DWORD dwFlags,
    CHString &sOutPath
)
{
    ParsedObjectPath    *pParsedPath = NULL;
    CObjectPathParser    objpathParser;

    GetValuesForPropResults eRet = e_OK;

    int nStatus = objpathParser.Parse( lpwszInPath,  &pParsedPath );

    if ( 0 == nStatus )
    {
        try
        {
            // Check the machine name and namespace
            if (pParsedPath->IsRelative( lpwszComputerName, lpwszNamespace ))
            {
                // If there is only one key, null out the property name (easier than trying
                // to find the key name if it is missing).
                if (pParsedPath->m_dwNumKeys == 1)
                {
                    if (pParsedPath->m_paKeys[0]->m_pName != NULL)
                    {
                        if (!(dwFlags & NORMALIZE_NULL))
                        {
                        }
                        else
                        {
                            delete pParsedPath->m_paKeys[0]->m_pName;
                            pParsedPath->m_paKeys[0]->m_pName = NULL;
                        }
                    }
                    else
                    {
                        if (!(dwFlags & NORMALIZE_NULL))
                        {
                            eRet = e_NullName;
                        }
                    }
                }

                if (eRet == e_OK)
                {
                    // Reform the object path, minus machine name and namespace name
                    LPWSTR pPath = NULL;
                    if (objpathParser.Unparse(pParsedPath, &pPath) == 0)
                    {
                        try
                        {
                            sOutPath = pPath;
                        }
                        catch ( ... )
                        {
                            delete pPath;
                            throw;
                        }
                        delete pPath;
                    }
                    else
                    {
                        sOutPath.Empty();
                        eRet = e_UnParseError;
                    }
                }
            }
            else
            {
                sOutPath.Empty();
                eRet = e_NonLocalPath;
            }
        }
        catch (...)
        {
            objpathParser.Free( pParsedPath );
            throw;
        }

        objpathParser.Free( pParsedPath );
    }
    else
    {
        sOutPath.Empty();
        eRet = e_UnparsablePath;
    }

    return eRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\wbemtime.cpp ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  wbemtime.cpp 
//
//  Purpose: Defines the WBEMTime and WBEMTimeSpan objects which are 
//  similar to the MFC CTime and CTimeSpan objects.  The WBEM versions
//  are capable of storing down to the nsec and also have functions for
//  Creating from and getting BSTRs.
//
//  Note; The current implementation of WBEMTime does not support dates 
//  before 1/1/1601;
//
//  WBEMTime::m_uTime is stored in GMT as 100 nsecs since 1/1/1601
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#pragma warning( disable : 4290 ) 

#ifdef UTILLIB
#include <assertbreak.h>
#else
#define ASSERT_BREAK(a)
#endif //UTILLIB

#include <WbemTime.h>
#include <comdef.h>


// These are here rather than wbemtime.h so we don't have to doc/support
#define DECPOS 14
#define SGNPOS 21
#define DMTFLEN 25

#define DEPRECATED 0
#define INVALID_TIME_FORMAT 0
#define INVALID_TIME_ARITHMETIC 0
#define BAD_TIMEZONE 0

// ****************************************************************
// Static functions and variables.  These can't be called/referenced
// outside of wbemtime.cpp

static WBEMTime g_Jan1970((time_t)0);

//***************************************************************************
//
//  StructtmToSystemTime
//
//  Description:  General utility for converting between the two common
//  data structures.
//
//  Return values: TRUE if OK;  
//
//***************************************************************************

static BOOL StructtmToSystemTime(const struct tm *ptm, SYSTEMTIME * pst)
{
    if (pst && ptm)
    {
        pst->wYear = ptm->tm_year + 1900; 
        pst->wMonth = ptm->tm_mon + 1; 
        pst->wDay = (WORD)ptm->tm_mday; 
        pst->wHour = (WORD)ptm->tm_hour; 
        pst->wMinute = (WORD)ptm->tm_min; 
        pst->wSecond = (WORD)ptm->tm_sec;
        pst->wDayOfWeek = (WORD)ptm->tm_wday;
        pst->wMilliseconds = 0;

        return TRUE;
    }

    return FALSE;
}

static BOOL SystemTimeToStructtm(const SYSTEMTIME *pst, struct tm *ptm)
{
    if (pst && ptm && pst->wYear >= 1900)
    {
        ptm->tm_year = pst->wYear - 1900; 
        ptm->tm_mon = pst->wMonth - 1; 
        ptm->tm_mday = pst->wDay; 
        ptm->tm_hour = pst->wHour; 
        ptm->tm_min = pst->wMinute; 
        ptm->tm_sec = pst->wSecond;
        ptm->tm_wday = pst->wDayOfWeek;
        ptm->tm_isdst = 0;  // Since we are working in gmt...

        return TRUE;
    }

    return FALSE;
}

//***************************************************************************
//
//  FileTimeToui64 
//  ui64ToFileTime
//
//  Description:  Conversion routines for going between FILETIME structures
//  and __int64.
//
//***************************************************************************

static void FileTimeToui64(const FILETIME *pft, ULONGLONG *p64)
{
    *p64 = pft->dwHighDateTime;
    *p64 = *p64 << 32;
    *p64 |=  pft->dwLowDateTime;
}

static void ui64ToFileTime(const ULONGLONG *p64,FILETIME *pft)
{
    unsigned __int64 uTemp = *p64;
    pft->dwLowDateTime = (DWORD)uTemp;
    uTemp = uTemp >> 32;
    pft->dwHighDateTime = (DWORD)uTemp; 
}

static int CompareSYSTEMTIME(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
{
    FILETIME ft1, ft2;

    SystemTimeToFileTime(pst1, &ft1);
    SystemTimeToFileTime(pst2, &ft2);

    return CompareFileTime(&ft1, &ft2);
}

// This function is used to convert the relative values that come
// back from GetTimeZoneInformation into an actual date for the year
// in question.  The system time structure that is passed in is updated
// to contain the absolute values.
static void DayInMonthToAbsolute(SYSTEMTIME *pst, const WORD wYear)
{
    const static int _lpdays[] = {
        -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
    };
    
    const static int _days[] = {
        -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
    };
    
    SHORT shYearDay;
    
    // If this is not 0, this is not a relative date
    if (pst->wYear == 0)
    {
        // Was that year a leap year?
        BOOL bLeap =  ( (( wYear % 400) == 0) || ((( wYear % 4) == 0) && (( wYear % 100) != 0)));
        
        // Figure out the day of the year for the first day of the month in question
        if (bLeap)
            shYearDay = 1 + _lpdays[pst->wMonth - 1];
        else
            shYearDay = 1 + _days[pst->wMonth - 1];
        
        // Now, figure out how many leap days there have been since 1/1/1601
        WORD yc = wYear - 1601;
        WORD y4 = (yc) / 4;
        WORD y100 = (yc) / 100;
        WORD y400 = (yc) / 400;
        
        // This will tell us the day of the week for the first day of the month in question.
        // The '1 +' reflects the fact that 1/1/1601 was a monday (figures).  You might ask,
        // 'why do we care what day of the week this is?'  Well, I'll tell you.  The way
        // daylight savings time is defined is with things like 'the last sunday of the month
        // of october.'  Kinda helps to know what day that is.
        SHORT monthdow = (1 + (yc * 365 + y4 + y400 - y100) + shYearDay) % 7;
        
        if ( monthdow < pst->wDayOfWeek )
            shYearDay += (pst->wDayOfWeek - monthdow) + (pst->wDay - 1) * 7;
        else
            shYearDay += (pst->wDayOfWeek - monthdow) + pst->wDay * 7;
        
            /*
            * May have to adjust the calculation above if week == 5 (meaning
            * the last instance of the day in the month). Check if yearday falls
            * beyond month and adjust accordingly.
        */
        if ( (pst->wDay == 5) &&
            (shYearDay > (bLeap ? _lpdays[pst->wMonth] :
        _days[pst->wMonth])) )
        {
            shYearDay -= 7;
        }

        // Now update the structure.
        pst->wYear = wYear;
        pst->wDay = shYearDay - (bLeap ? _lpdays[pst->wMonth - 1] :
        _days[pst->wMonth - 1]);
    }
    
}

// **************************************************************************
// These are static to WBEMTIME, which means they CAN be called from outside
// wbemtime

LONG WBEMTime::GetLocalOffsetForDate(const time_t &t)
{
    FILETIME ft;
    ULONGLONG ull = Int32x32To64(t, 10000000) + 116444736000000000;

    ui64ToFileTime(&ull, &ft);

    return GetLocalOffsetForDate(&ft);
}

LONG WBEMTime::GetLocalOffsetForDate(const struct tm *ptmin)
{
    SYSTEMTIME st;

    StructtmToSystemTime(ptmin, &st);
    
    return GetLocalOffsetForDate(&st);
}

LONG WBEMTime::GetLocalOffsetForDate(const FILETIME *pft)
{
    SYSTEMTIME st;

    FileTimeToSystemTime(pft, &st);
    
    return GetLocalOffsetForDate(&st);
}

LONG WBEMTime::GetLocalOffsetForDate(const SYSTEMTIME *pst)
{
    TIME_ZONE_INFORMATION tzTime;
    DWORD dwRes = GetTimeZoneInformation(&tzTime);
    LONG lRes = 0xffffffff;

    switch (dwRes)
    {
    case TIME_ZONE_ID_UNKNOWN:
        {
            // Read tz, but no dst defined in this zone
            lRes = tzTime.Bias * -1;
            break;
        }
    case TIME_ZONE_ID_STANDARD:
    case TIME_ZONE_ID_DAYLIGHT:
        {

            // Convert the relative dates to absolute dates
            DayInMonthToAbsolute(&tzTime.DaylightDate, pst->wYear);
            DayInMonthToAbsolute(&tzTime.StandardDate, pst->wYear);

            if ( CompareSYSTEMTIME(&tzTime.DaylightDate, &tzTime.StandardDate) < 0 ) 
            {
                /*
                 * Northern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.DaylightDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.StandardDate) > 0)
                {
                    lRes = tzTime.Bias * -1;
                }
                else
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
            }
            else 
            {
                /*
                 * Southern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.StandardDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.DaylightDate) > 0)
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
                else
                {
                    lRes = tzTime.Bias * -1;
                }
            }

            break;

        }
    case TIME_ZONE_ID_INVALID:
    default:
        {
            // Can't read the timezone info
            ASSERT_BREAK(BAD_TIMEZONE);
            break;
        }
    }

    return lRes;
}

///////////////////////////////////////////////////////////////////////////
// WBEMTime - This class holds time values. 

//***************************************************************************
//
//  WBEMTime::operator=(BSTR bstrWbemFormat) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  The string must have the format:
//  YYYYMMDDHHSS.123456789    So 3:04 am, 1/1/96 would be 199601010304.0
//
//  or the format yyyymmddhhmmss.mmmmmmsuuu.
//
//  Note that the fractional part can be between 1 and nine digits.   
//
//  Return: WBEMTime object.
//
//***************************************************************************

const WBEMTime & WBEMTime::operator=(const BSTR bstrWbemFormat)
{
    Clear();   // set when properly assigned

    if((NULL == bstrWbemFormat) || 
        wcslen(bstrWbemFormat) != DMTFLEN ||
		bstrWbemFormat[DECPOS] != L'.'
      )
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
        return *this;
    }

    if ( (wcslen(bstrWbemFormat) == DMTFLEN) &&
        (bstrWbemFormat[SGNPOS] == L'+' || bstrWbemFormat[SGNPOS] == L'-') )
    {
        SetDMTF(bstrWbemFormat);
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
    }
 
    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator=(const SYSTEMTIME) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard WIN32 SYSTEMTIME stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const WBEMTime & WBEMTime::operator=(const SYSTEMTIME & st)
{
    Clear();   // set when properly assigned
    FILETIME t_ft;

    if ( SystemTimeToFileTime(&st, &t_ft) )
    {
        // now assign using a FILETIME.
        *this = t_ft;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator=(const FILETIME) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard WIN32 FILETIME stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const WBEMTime & WBEMTime::operator=(const FILETIME & ft)
{
    FileTimeToui64(&ft, &m_uTime);
    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator=(struct tm tmin) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard c runtine struct tm stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const WBEMTime & WBEMTime::operator=(const struct tm &a_tmin)
{
    Clear();   // set when properly assigned

    SYSTEMTIME systemTime;
    if (StructtmToSystemTime(&a_tmin, &systemTime))
    {
        *this = systemTime;
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator=(struct time_t t) 
//
//  Description:  Assignment operator which is also used by the constructor.
//  This takes a standard c runtine time_t stucture.  
//
//  Return: WBEMTime object.
//
//***************************************************************************

const WBEMTime & WBEMTime::operator=(const time_t & t)
{
    if (t >= 0)
    {
        m_uTime = Int32x32To64(t, 10000000) + 116444736000000000;
    }
    else
    {
        Clear();
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTime::operator+(const WBEMTime &uAdd)
//
//  Description:  dummy function for adding two WBEMTime.  It doesnt really
//  make sense to add two date, but this is here for Tomas's template.
//
//  Return: WBEMTime object.
//
//***************************************************************************

WBEMTime WBEMTime::operator+(const WBEMTimeSpan &uAdd) const
{
    WBEMTime ret;

    if (IsOk() && uAdd.IsOk())
    {
        ret.m_uTime = m_uTime + uAdd.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

const WBEMTime &WBEMTime::operator+=( const WBEMTimeSpan &ts )
{ 
    if (IsOk() && ts.IsOk())
    {
        m_uTime += ts.m_Time ; 
    }
    else
    {
        Clear();
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return *this ; 
}

//***************************************************************************
//
//  WBEMTime::operator-(const WBEMTime & sub)
//
//  Description:  returns a WBEMTimeSpan object as the difference between 
//  two WBEMTime objects.
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

WBEMTimeSpan WBEMTime::operator-(const WBEMTime & sub)
{
    WBEMTimeSpan ret;

    if (IsOk() && sub.IsOk() && (m_uTime >= sub.m_uTime))
    {
        ret.m_Time = m_uTime-sub.m_uTime;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

WBEMTime WBEMTime::operator-(const WBEMTimeSpan & sub) const
{
    WBEMTime ret;

    if (IsOk() && sub.IsOk() && (m_uTime >= sub.m_Time))
    {
        ret.m_uTime = m_uTime - sub.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

const WBEMTime &WBEMTime::operator-=(const WBEMTimeSpan & sub)
{
    if (IsOk() && sub.IsOk() && (m_uTime >= sub.m_Time))
    {
        m_uTime -= sub.m_Time;
    }
    else
    {
        Clear();
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTime::GetBSTR(void)
//
//  This function used to CLAIM to do this:
//
//  WRONG Description:  Converts the time which is stored as the number of 
//  nano seconds since 1970 into a bstr with this format.
//  YYYYMMDDHHSS.123456789    So 3:04 am, 1/1/96 would be 199601010304.000000000
//
//  What it really did was return some bastardized form of a dmtf string.  Now
//  it returns a dmtf string in gmt form (which is what the docs claim).
//
//  Return: BSTR representation of time, or NULL if error.  Note that the
//  caller should free up this string!
//
//***************************************************************************

BSTR WBEMTime::GetBSTR(void) const
{
    return GetDMTF(false) ;
}

//***************************************************************************
//
//  WBEMTime::GetDMTFNonNtfs(void)
//
//***************************************************************************

BSTR WBEMTime::GetDMTFNonNtfs(void) const
{
    FILETIME t_ft1, t_ft2;
    BSTR t_Date = NULL;

    if (GetFILETIME(&t_ft1) && FileTimeToLocalFileTime(&t_ft1, &t_ft2))
    {
        t_Date = WBEMTime(t_ft2).GetDMTF();

        if (t_Date != NULL)
        {
            t_Date[21] = L'+';
            t_Date[22] = L'*';
            t_Date[23] = L'*';
            t_Date[24] = L'*';
        }
    }

    return t_Date;
}

//***************************************************************************
//
//  WBEMTime::time_t(time_t * ptm)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL WBEMTime::Gettime_t(time_t * ptm) const
{
    if( (!IsOk()) || (ptm == NULL) || (*this < g_Jan1970))
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    if (g_Jan1970 != *this)
    {
        LONGLONG t_tmp = ( (m_uTime - g_Jan1970.m_uTime) / 10000000);

        if (t_tmp <= (LONGLONG)0xffffffff)
        {
            *ptm = (time_t)t_tmp;
        }
        else
        {
            ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
            return FALSE;
        }
    }
    else
    {
        *ptm = 0;
    }

    return TRUE;
}

//***************************************************************************
//
//  WBEMTime::GetStructtm(struct tm * ptm)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL WBEMTime::GetStructtm(struct tm * ptm) const
{
    SYSTEMTIME systemTime;

    return (GetSYSTEMTIME(&systemTime) && SystemTimeToStructtm(&systemTime, ptm));
}

//***************************************************************************
//
//  WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL WBEMTime::GetSYSTEMTIME(SYSTEMTIME * pst) const
{
    if ((pst == NULL) || (!IsOk()))
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    FILETIME t_ft;

    if (GetFILETIME(&t_ft))
    {
        if (!FileTimeToSystemTime(&t_ft, pst))
        {
            ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//
//  WBEMTime::GetFILETIME(FILETIME * pst)
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL WBEMTime::GetFILETIME(FILETIME * pft) const
{
    if ((pft == NULL) || (!IsOk()))
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return FALSE;
    }

    ui64ToFileTime(&m_uTime, pft);

    return TRUE;
}

//***************************************************************************
//
//  CWbemTime::SetDMTF(BSTR wszText)
//
//  Description:  Sets the time value to the DMTF string datetime value
//  passed as the parameter
//
//  Return: TRUE if OK.
//
//***************************************************************************
BOOL WBEMTime::SetDMTF( const BSTR a_wszText )
{

    wchar_t t_DefaultBuffer[] = {L"16010101000000.000000+000"} ;
    wchar_t t_DateBuffer[ DMTFLEN + 1 ] ;
            t_DateBuffer[ DMTFLEN ] = NULL ;

    bstr_t  t_bstrDate( a_wszText ) ;

    // wildcard cleanup and validation
    // ===============================

    if( DMTFLEN != t_bstrDate.length() )
    {
        ASSERT_BREAK( INVALID_TIME_FORMAT ) ;
        return FALSE ;  
    }
    
    wchar_t *t_pwBuffer = (wchar_t*)t_bstrDate ;
    
    for( int t_i = 0; t_i < DMTFLEN; t_i++ )
    {
        switch( t_pwBuffer[ t_i ] )
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                // stepping on separator or sign
                if( DECPOS == t_i || SGNPOS == t_i )
                {
                    ASSERT_BREAK( INVALID_TIME_FORMAT ) ;
                    return FALSE ;  
                }
                t_DateBuffer[ t_i ] = t_pwBuffer[ t_i ] ;
                
                break ;
            }           
            case '*':
            {               
                // stepping on separator or sign
                if( DECPOS == t_i || SGNPOS == t_i )
                {
                    ASSERT_BREAK( INVALID_TIME_FORMAT ) ;
                    return FALSE ;  
                }
                else
                {
                    // replace with default stamp
                    t_DateBuffer[ t_i ] = t_DefaultBuffer[ t_i ] ; 
                }   
                break ;
            }           
            case '.':
            {
                if( DECPOS != t_i )
                {
                    ASSERT_BREAK( INVALID_TIME_FORMAT ) ;
                    return FALSE ;  
                }
                t_DateBuffer[ t_i ] = t_pwBuffer[ t_i ] ;

                break ;
            }           
            case '+':
            case '-':
            {
                if( SGNPOS != t_i )
                {
                    ASSERT_BREAK( INVALID_TIME_FORMAT ) ;
                    return FALSE ;  
                }
                t_DateBuffer[ t_i ] = t_pwBuffer[ t_i ] ;
                break ;
            }           
            default:
            {
                ASSERT_BREAK( INVALID_TIME_FORMAT ) ;
                return FALSE ;
            }           
        }
    }

    // Parse it
    // ========

    int nYear, nMonth, nDay, nHour, nMinute, nSecond, nMicro, nOffset;
    WCHAR wchSep;

    int nRes = swscanf (

        (LPCWSTR)&t_DateBuffer, 
        L"%4d%2d%2d%2d%2d%2d.%6d%c%3d", 
        &nYear, 
        &nMonth, 
        &nDay, 
        &nHour, 
        &nMinute, 
        &nSecond, 
        &nMicro, 
        &wchSep, 
        &nOffset
    );

    if ( ( 9 != nRes )  || ( 1601 > nYear) )    
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
        return FALSE;
    }

    // Convert it to SYSTEMTIME
    // ========================

    SYSTEMTIME st;
    st.wYear        = (WORD)nYear;
    st.wMonth       = (WORD)nMonth;
    st.wDay         = (WORD)nDay;
    st.wHour        = (WORD)nHour;
    st.wMinute      = (WORD)nMinute;
    st.wSecond      = (WORD)nSecond;
    st.wMilliseconds = 0;
    st.wDayOfWeek   = 0;

    *this = st;

	// we need to add microseconds and nanoseconds now!
	// it was basically cut when assigned to SYSTEMTIME
	// ================================================
	m_uTime += (LONGLONG)nMicro * 10;

    // NOW we adjust for the offset
    // ============================

    if ( IsOk() )
    {
        int nSign = (wchSep == L'+') ? 1 : -1 ;
        
        m_uTime -= (LONGLONG)nSign * (LONGLONG)nOffset * 60 * 10000000;
    }
    else
    {
        ASSERT_BREAK( INVALID_TIME_ARITHMETIC ) ;
        return FALSE ;
    }

    return TRUE;
}

//***************************************************************************
//
//  BSTR WBEMTime::GetDMTF(void)
//
//  Description:  Gets the time in DMTF string datetime format. User must call
//  SysFreeString with the result. If bLocal is true, then the time is given
//  in the local timezone, else the time is given in GMT.
//
//  Return: NULL if not OK.
//
//***************************************************************************


BSTR WBEMTime::GetDMTF(BOOL bLocal) const
{

    if (!IsOk())
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
        return NULL;
    }

    SYSTEMTIME t_Systime;
    wchar_t chsign = L'-';
    int offset = 0;

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
    ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
    t_ConversionZone = t_ConversionZone * 10000000L ;
    if ( !bLocal || ( m_uTime < t_ConversionZone ) )
    {
        if(!GetSYSTEMTIME(&t_Systime))
        {
            return NULL;
        }
    }
    else
    {
        if (GetSYSTEMTIME(&t_Systime))
        {
            offset = GetLocalOffsetForDate(&t_Systime);

            WBEMTime wt;
            if (offset >= 0)
            {
                chsign = '+';
                wt = *this + WBEMTimeSpan(0, 0, offset, 0);
            }
            else
            {
                offset *= -1;
                wt = *this - WBEMTimeSpan(0, 0, offset, 0);
            }
            wt.GetSYSTEMTIME(&t_Systime);
        }
        else
        {
            return NULL;
        }
    }

    LONGLONG tmpMicros = m_uTime%10000000;
    LONG micros = (LONG)(tmpMicros / 10);

    BSTR t_String = SysAllocStringLen(NULL, DMTFLEN + 1);
    if ( ! t_String ) 
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    swprintf(

        t_String,
        L"%04.4d%02.2d%02.2d%02.2d%02.2d%02.2d.%06.6d%c%03.3ld",
        t_Systime.wYear,
        t_Systime.wMonth, 
        t_Systime.wDay,
        t_Systime.wHour,
        t_Systime.wMinute,
        t_Systime.wSecond,
        micros, 
        chsign, 
        offset
    );

    return t_String ;

}

///////////////////////////////////////////////////////////////////////////
// WBEMTimeSpan - This class holds timespan values.  The data is stored
// in 100 nanosecond units (like FILETIME). 

//***************************************************************************
//
//  WBEMTimeSpan::WBEMTimeSpan(int iDays, int iHours, int iMinutes, int iSeconds, 
//                int iMSec, int iUSec, int iNSec)
//
//  Description:  Constructor.
//
//***************************************************************************

WBEMTimeSpan::WBEMTimeSpan(int iDays, int iHours, int iMinutes, int iSeconds, 
                int iMSec, int iUSec, int iNSec)
{
    m_Time = 0;        //todo, check values!!!
    m_Time += iSeconds;
    m_Time += iMinutes * 60;
    m_Time += iHours * 60 * 60;
    m_Time += iDays * 24 * 60 * 60;
    m_Time *= 10000000;
    m_Time += iNSec / 100;  // Nanoseconds
    m_Time += iUSec*10;   // Microseconds
    m_Time += iMSec*10000; // Milliseconds
}

WBEMTimeSpan::WBEMTimeSpan ( const FILETIME &ft )
{
    ASSERT_BREAK(DEPRECATED);
    *this = ft ; 
}

WBEMTimeSpan::WBEMTimeSpan ( const time_t & t )
{
    ASSERT_BREAK(DEPRECATED);
    *this = t ; 
} ;

//***************************************************************************
//
//  WBEMTimeSpan::operator=(const BSTR bstrWbemFormat) 
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

const WBEMTimeSpan & WBEMTimeSpan::operator=(const BSTR bstrWbemFormat)
{
    Clear();

    // all characters should be digits except for one which 
    // must be a period

    if ((bstrWbemFormat == NULL) || (bstrWbemFormat[DECPOS] != L'.') ||
        (wcslen(bstrWbemFormat) != DMTFLEN) || (bstrWbemFormat[SGNPOS] != L':') )
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
        return *this;
    }

    int nDays, nHours, nMinutes, nSeconds, nMicros, nOffset;
    WCHAR wchSep;

    int nRes = swscanf (

        bstrWbemFormat, 
        L"%8d%2d%2d%2d.%6d%c%3d", 
        &nDays, 
        &nHours, 
        &nMinutes, 
        &nSeconds, 
        &nMicros, 
        &wchSep, 
        &nOffset
    );

    if ( (nRes != 7) || ( nOffset != 0) )
    {
        ASSERT_BREAK(INVALID_TIME_FORMAT);
        return *this;
    }

    *this = WBEMTimeSpan(nDays, nHours, nMinutes, nSeconds, 0, nMicros, 0);

    return *this;
}

//***************************************************************************
//
//  WBEMTimeSpan::operator=(const FILETIME &) 
//  WBEMTimeSpan::operator=(const time_t &) 
//
//  Description:  Assignment operator which is also used by the constructor.
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

const WBEMTimeSpan &  WBEMTimeSpan::operator=(const FILETIME &ft)
{
    ASSERT_BREAK(DEPRECATED);

    ULONGLONG uTemp;
    FileTimeToui64(&ft, &uTemp);
    m_Time = uTemp;

    return *this;
}

const WBEMTimeSpan &  WBEMTimeSpan::operator=(const time_t & t)
{
    ASSERT_BREAK(DEPRECATED);

    ULONGLONG uTemp = 0;

    uTemp = t;
    if (t >= 0)
    {
        m_Time = uTemp * 10000000;
    }
    else
    {
        Clear();
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTimeSpan::operator +(const WBEMTimeSpan &uAdd)
//
//  Description:  function for adding two WBEMTimeSpan objects.
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

WBEMTimeSpan WBEMTimeSpan::operator+(const WBEMTimeSpan &uAdd) const
{
    WBEMTimeSpan ret;

    if (IsOk() && uAdd.IsOk())
    {
        ret.m_Time = m_Time + uAdd.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

const WBEMTimeSpan &WBEMTimeSpan::operator+= ( const WBEMTimeSpan &uAdd )
{ 
    if (IsOk() && uAdd.IsOk())
    {
        m_Time += uAdd.m_Time ; 
    }
    else
    {
        Clear();
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return *this ; 
}

//***************************************************************************
//
//  WBEMTimeSpan::operator -(const WBEMTimeSpan &uAdd)
//
//  Description:  function for adding two WBEMTimeSpan objects.
//
//  Return: WBEMTimeSpan object.
//
//***************************************************************************

WBEMTimeSpan WBEMTimeSpan::operator-(const WBEMTimeSpan &uSub) const
{
    WBEMTimeSpan ret;
    
    if (IsOk() && uSub.IsOk() && (m_Time >= uSub.m_Time))
    {
        ret.m_Time = m_Time - uSub.m_Time;
    }
    else
    {
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return ret;
}

const WBEMTimeSpan &WBEMTimeSpan::operator-= ( const WBEMTimeSpan &uSub ) 
{
    if (IsOk() && uSub.IsOk() && (m_Time >= uSub.m_Time))
    {
        m_Time -= uSub.m_Time;
    }
    else
    {
        Clear();
        ASSERT_BREAK(INVALID_TIME_ARITHMETIC);
    }

    return *this;
}

//***************************************************************************
//
//  WBEMTimeSpan::GetBSTR(void)
//
//  Description:  Converts the time which is stored as the number of 
//  100 nano second units into a dmtf formatted string
//  ddddddddhhmmss.mmmmmm:000
//
//  Return: BSTR representation of time, or NULL if error.  Note that the
//  caller should free up this string!
//
//***************************************************************************

BSTR WBEMTimeSpan::GetBSTR(void) const
{
    if(!IsOk())
    {
        return NULL;
    }

    ULONGLONG Time = m_Time;

    // The /10 is to convert from 100ns to microseconds
    long iMicro = (long)((Time % 10000000) / 10);
    Time /= 10000000;
    int iSec = (int)(Time % 60);
    Time /= 60;
    int iMin = (int)(Time % 60);
    Time /= 60;
    int iHour = (int)(Time % 24);
    Time /= 24;

    BSTR t_String = SysAllocStringLen(NULL, DMTFLEN + 1);
    if ( ! t_String ) 
    {
        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
    }

    swprintf(t_String, L"%08I64i%02d%02d%02d.%06ld:000",
                Time, iHour, iMin, iSec, iMicro);

    return t_String ;
}

//***************************************************************************
//
//  WBEMTimeSpan::Gettime_t(void)
//  WBEMTimeSpan::GetFILETIME(void)
//
//  Description:  Converts the time span which is stored as the number of 
//  nano seconds into common stuctures.
//
//  Return: TRUE if OK.
//
//***************************************************************************

BOOL WBEMTimeSpan::Gettime_t(time_t * ptime_t) const
{
    ASSERT_BREAK(DEPRECATED);

    if(!IsOk())
    {
        return FALSE;
    }

    *ptime_t = (DWORD)(m_Time / 10000000);

    return TRUE;
}

BOOL WBEMTimeSpan::GetFILETIME(FILETIME * pst) const
{
    ASSERT_BREAK(DEPRECATED);

    if(!IsOk())
    {
        return FALSE;
    }

    ULONGLONG uTemp;
    uTemp = m_Time;
    ui64ToFileTime(&uTemp,pst);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\include\assertbreak.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  AssertBreak.h
//
//  Purpose: AssertBreak macro definition
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _ASSERT_BREAK_HMH_
#define _ASSERT_BREAK_HMH_

#include <polarity.h>

// Needed to add L to the __FILE__
#define __FRT2(x)      L ## x
#define _FRT2(x)       __FRT2(x)

// We'll need both of these values in case we're running in NT.
// Since our project is not an NT-only project, these are #ifdefd
// out of windows.h

#ifndef _WIN32_WINNT
#define MB_SERVICE_NOTIFICATION          0x00200000L
#define MB_SERVICE_NOTIFICATION_NT3X     0x00040000L
#endif

void POLARITY WINAPI assert_break( LPCWSTR pszReason, LPCWSTR pszFilename, int nLine );

#if (defined DEBUG || defined _DEBUG)
#define ASSERT_BREAK(exp)    \
    if (!(exp)) { \
        assert_break( _FRT2(#exp), _FRT2(__FILE__), __LINE__ ); \
    }
#else
#define ASSERT_BREAK(exp)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\include\autoimprevert.h ===
//
// Copyright  Microsoft Corporation.  All rights reserved.
//
// CAutoImpRevert class header
// Created:  10/4/2000
// Author: khughes

#pragma once
#pragma warning( disable : 4290 ) 


class CAutoImpRevert;
class CAutoImpError;



class CAutoImpRevert
{
public:
    CAutoImpRevert(
        BOOL fOpenAsSelf = TRUE) throw(CAutoImpError);
    
    virtual ~CAutoImpRevert();

    DWORD LastError() const;

private:
    bool GetCurrentImpersonation(
        BOOL fOpenAsSelf);

    bool Revert();

    HANDLE m_hOriginalUser;
    DWORD m_dwLastError;

};




class CAutoImpError
{
public:
    
    CAutoImpError(
        LPCWSTR wstrDescription)
    {
        m_chstrDescription = wstrDescription;    
    }

    CAutoImpError(const CAutoImpError& err)
    {
        m_chstrDescription = err.m_chstrDescription;
    }   

    virtual ~CAutoImpError() {}
    
    CHString GetDescription() const
    {
        return m_chstrDescription;
    }


private:
    CHString m_chstrDescription;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\include\chptrarr.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  chptrarr.h
//
//  Purpose: Non-MFC CPtrArray class definition
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CHPTRARRAY__
#define __CHPTRARRAY__

#include <windows.h>
#include <limits.h>
#include <assert.h>
#include <tchar.h>
#include <polarity.h>
#include <ProvExce.h>

class POLARITY CHPtrArray
{
    public :

        // Construction/destruction
        //=========================

    CHPtrArray() ;

// Attributes
    int GetSize() const ;
    int GetUpperBound() const ;
    void SetSize(int nNewSize, int nGrowBy = -1) throw ( CHeap_Exception ) ;

// Operations
    // Clean up
    void FreeExtra() throw ( CHeap_Exception ) ;
    void RemoveAll() ;

    // Accessing elements
    void* GetAt(int nIndex) const ;
    void SetAt(int nIndex, void* newElement) ;
    void*& ElementAt(int nIndex) ;

    // Direct Access to the element data (may return NULL)
    const void** GetData() const ;
    void** GetData() ;

    // Potentially growing the array
    void SetAtGrow(int nIndex, void* newElement) throw ( CHeap_Exception ) ;
    int Add(void* newElement) throw ( CHeap_Exception ) ;
    int Append(const CHPtrArray& src) throw ( CHeap_Exception ) ;
    void Copy(const CHPtrArray& src) throw ( CHeap_Exception ) ;

    // overloaded operator helpers
    void* operator[](int nIndex) const ;
    void*& operator[](int nIndex) ;

    // Operations that move elements around
    void InsertAt(int nIndex, void* newElement, int nCount = 1) throw ( CHeap_Exception ) ;
    void RemoveAt(int nIndex, int nCount = 1) ;
    void InsertAt(int nStartIndex, CHPtrArray* pNewArray) throw ( CHeap_Exception ) ;

// Implementation
protected:
    void** m_pData ;   // the actual array of data
    int m_nSize ;     // # of elements (upperBound - 1)
    int m_nMaxSize ;  // max allocated
    int m_nGrowBy ;   // grow amount

public:
    ~CHPtrArray() ;
#ifdef _DEBUG
//    void Dump(CDumpContext&) const ;
    void AssertValid() const ;
#endif

protected:
    // local typedefs for class templates
    typedef void* BASE_TYPE ;
    typedef void* BASE_ARG_TYPE ;
} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\include\chstrarr.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  CHSTRARR.H
//
//  Purpose: Utility library version of MFC CHStringArray
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CHStringArray_
#define _CHStringArray_

#include <polarity.h>
#include <ProvExce.h>

class POLARITY CHStringArray 
{
    public:

        CHStringArray();
        ~CHStringArray();

        // Attributes
        int GetSize() const             { return m_nSize; }
        int GetUpperBound() const       { return m_nSize-1; }
        void SetSize(int nNewSize, int nGrowBy = -1) throw ( CHeap_Exception ) ;

        // Operations
        // Clean up
        void FreeExtra() throw ( CHeap_Exception ) ;
        void RemoveAll()                { SetSize(0); }

        // Accessing elements
#if (!defined DEBUG && !defined _DEBUG)
        CHString GetAt(int nIndex) const{ return m_pData[nIndex]; }
        void SetAt(int nIndex, LPCWSTR newElement){ m_pData[nIndex] = newElement; }
        CHString& ElementAt(int nIndex) { return m_pData[nIndex]; }
#else
        CHString GetAt(int nIndex) const;
        void SetAt(int nIndex, LPCWSTR newElement);
        CHString& ElementAt(int nIndex);
#endif

        // Direct Access to the element data (may return NULL)
        const CHString* GetData() const { return (const CHString*)m_pData; }
        CHString* GetData()             { return (CHString*)m_pData; }

        // Potentially growing the array
        void SetAtGrow(int nIndex, LPCWSTR newElement) throw ( CHeap_Exception ) ;
        int Add(LPCWSTR newElement) throw ( CHeap_Exception ) 
        { 
            int nIndex = m_nSize;
            SetAtGrow(nIndex, newElement);
            return nIndex; 
        }

        int Append(const CHStringArray& src) throw ( CHeap_Exception ) ;
        void Copy(const CHStringArray& src) throw ( CHeap_Exception ) ;

        // overloaded operator helpers
        CHString operator[](int nIndex) const { return GetAt(nIndex); }
        CHString& operator[](int nIndex)      { return ElementAt(nIndex); }

        // Operations that move elements around
        void InsertAt(int nIndex, LPCWSTR newElement, int nCount = 1) throw ( CHeap_Exception ) ;
        void RemoveAt(int nIndex, int nCount = 1);
        void InsertAt(int nStartIndex, CHStringArray* pNewArray) throw ( CHeap_Exception ) ;

        // Implementation

    protected:
        CHString* m_pData;      // the actual array of data
        int m_nSize;            // # of elements (upperBound - 1)
        int m_nMaxSize;         // max allocated
        int m_nGrowBy;          // grow amount
                                // local typedefs for class templates
        typedef CHString BASE_TYPE;
        typedef LPCWSTR BASE_ARG_TYPE;
};
////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\include\pragma.h ===
//
// Copyright  Microsoft Corporation.  All rights reserved.
//

#pragma comment(lib, "wbemuuid.lib")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\include\cnvmacros.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  cnvmacros.h
//
//  Purpose: Converts ansi to wcs or wcs to ansi using stack
//
//
//                          WARNING!
//
//  Do not attempt to use these functions on strings longer than _MAX_PATH
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CNVMACROS_H_
#define _CNVMACROS_H_

#include <assertbreak.h>

#define WCSTOANSISTRING(x, y, conversionFailure )                                                                                       \
        char t_##x[_MAX_PATH];                                                                                      \
        {                                                                                                           \
			conversionFailure = false ;																				\
        	int nLen = ::WideCharToMultiByte(CP_ACP, 0, x, -1, t_##x, _MAX_PATH, NULL, NULL);                       \
            if (nLen != 0)                                                                                          \
            {                                                                                                       \
                y = t_##x;                                                                                          \
	        }                                                                                                       \
            else                                                                                                    \
            {                                                                                                       \
                ASSERT_BREAK(0);                                                                                    \
				conversionFailure = true ;																			\
                y = NULL;                                                                                           \
            }                                                                                                       \
        }                                                                                                           \

#define ANSISTRINGTOWCS(in, out, conversionFailure )                                                                                    \
        WCHAR t_##x[_MAX_PATH];																							\
        {                                                                                                           \
			conversionFailure = false ;																				\
	        int nLen = MultiByteToWideChar(CP_ACP, 0, in, -1, t_##x, sizeof(t_##x)/sizeof(WCHAR));					\
            if (nLen != 0)                                                                                          \
            {                                                                                                       \
                out = t_##x;                                                                                        \
            }                                                                                                       \
            else                                                                                                    \
            {                                                                                                       \
                ASSERT_BREAK(0);                                                                                    \
				conversionFailure = true ;																			\
                out = NULL;                                                                                         \
            }                                                                                                       \
        }                                                                                                           \

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\include\copyright.h ===
//=================================================================
//
//	This file was automatically generated from the IDL files 
//	included with the WBEM SDK in the \include directory.  If you
//  experience problems compiling this file you can re-generate it
//  by running NMAKE (or another MAKE utility) from within the 
//	\include directory.
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//
//=================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\include\chstring.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  CHSTRING.h
//
//  Purpose: Utility library version of MFC CString
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CHSTRING_H
#define _CHSTRING_H

/////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <limits.h>
#include <tchar.h>
#include <polarity.h>
#pragma warning( disable : 4290 ) // Ignore 'C++ Exception Specification ignored'
#include <ProvExce.h>

/////////////////////////////////////////////////////////////////////////////

struct _DOUBLE  { BYTE doubleBits[sizeof(double)]; };

#ifdef FRAMEWORK_ALLOW_DEPRECATED
void POLARITY WINAPI SetCHStringResourceHandle(HINSTANCE handle);
#endif

/////////////////////////////////////////////////////////////////////////////
// CHString formatting
/////////////////////////////////////////////////////////////////////////////
#define TCHAR_ARG   WCHAR
#define WCHAR_ARG   WCHAR
#define CHAR_ARG    char

#if defined(_68K_) || defined(_X86_)
    #define DOUBLE_ARG  _DOUBLE
#else
    #define DOUBLE_ARG  double
#endif

struct CHStringData
{
    long nRefs;
    int nDataLength;
    int nAllocLength;

    WCHAR* data()
    {
        return (WCHAR*)(this+1); 
    }
};

/////////////////////////////////////////////////////////////////////////////
class POLARITY CHString
{
    protected:

        LPWSTR m_pchData;               // pointer to ref counted string data

    protected:

                                        // implementation helpers

        CHStringData* GetData() const;  // returns data pointer
        void Init();
        void AllocCopy(CHString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const throw ( CHeap_Exception ) ;
        void AllocBuffer(int nLen) throw ( CHeap_Exception ) ;
        void AssignCopy(int nSrcLen, LPCWSTR lpszSrcData) throw ( CHeap_Exception ) ;
        void ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data, int nSrc2Len, LPCWSTR lpszSrc2Data) throw ( CHeap_Exception ) ;
        void ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData);
        void CopyBeforeWrite() throw ( CHeap_Exception ) ;
        void AllocBeforeWrite(int nLen) throw ( CHeap_Exception ) ;
        void Release();
        static void WINAPI Release(CHStringData* pData);
        static inline int WINAPI SafeStrlen(LPCWSTR lpsz)   { return (lpsz == NULL) ? 0 : wcslen(lpsz); }

        // Helper function used to load resource into lpszBuf buffer.
#ifdef FRAMEWORK_ALLOW_DEPRECATED
        int LoadStringW(UINT nID, LPWSTR lpszBuf, UINT nMaxBuf) throw ( CHeap_Exception ) ;
#endif

    public:

// Constructors/Destruction

        CHString();
        CHString(const CHString& stringSrc);
        CHString(WCHAR ch, int nRepeat = 1) throw ( CHeap_Exception ) ;
        CHString(LPCSTR lpsz) throw ( CHeap_Exception ) ;
        CHString(LPCWSTR lpsz) throw ( CHeap_Exception ) ;
        CHString(LPCWSTR lpch, int nLength) throw ( CHeap_Exception ) ;
        inline CHString(const unsigned char* lpsz)  { Init(); *this = (LPCSTR)lpsz; }

        ~CHString();

// Functions

        void SetAt(int nIndex, WCHAR ch) throw ( CHeap_Exception ) ;
        void Empty();    

        // inlines

        inline int GetLength() const { return GetData()->nDataLength; }
        inline BOOL IsEmpty() const  { return GetData()->nDataLength == 0; }

#if (!defined DEBUG && !defined _DEBUG)
        inline WCHAR GetAt(int nIndex) const{ return m_pchData[nIndex]; }
        inline WCHAR operator[](int nIndex) const{  return m_pchData[nIndex]; }
#else
        WCHAR GetAt(int nIndex) const;
        WCHAR operator[](int nIndex) const;
#endif
        inline operator LPCWSTR() const     { return m_pchData; }
        inline int GetAllocLength() const       { return GetData()->nAllocLength; }

// overloaded assignment

        const CHString& operator=(const CHString& stringSrc) throw ( CHeap_Exception ) ;
        const CHString& operator=(WCHAR ch) throw ( CHeap_Exception ) ;
        const CHString& operator=(LPCSTR lpsz) throw ( CHeap_Exception ) ;
        const CHString& operator=(LPCWSTR lpsz) throw ( CHeap_Exception ) ;
        inline const CHString& operator=(const unsigned char* lpsz) throw ( CHeap_Exception ) { *this = (LPCSTR)lpsz; return *this; }
        inline const CHString& operator=(CHString *p) throw ( CHeap_Exception ) { *this = *p; return *this; }
        inline const CHString& operator=(char ch) throw ( CHeap_Exception ) { *this = (WCHAR)ch; return *this; }        
        
        inline const CHString& CHString::operator+=(char ch) throw ( CHeap_Exception ) { *this += (WCHAR)ch; return *this; }
        friend inline CHString  operator+(const CHString& string, char ch) throw ( CHeap_Exception ) { return string + (WCHAR)ch; }
        friend inline CHString  operator+(char ch, const CHString& string) throw ( CHeap_Exception ) { return (WCHAR)ch + string; }

        const CHString& operator+=(const CHString& string) throw ( CHeap_Exception ) ;
        const CHString& operator+=(WCHAR ch) throw ( CHeap_Exception ) ;
        const CHString& operator+=(LPCWSTR lpsz) throw ( CHeap_Exception ) ;

        friend CHString POLARITY WINAPI operator+(const CHString& string1,  const CHString& string2) throw ( CHeap_Exception ) ;
        friend CHString POLARITY WINAPI operator+(const CHString& string, WCHAR ch) throw ( CHeap_Exception ) ;
        friend CHString POLARITY WINAPI operator+(WCHAR ch, const CHString& string) throw ( CHeap_Exception ) ;
        friend CHString POLARITY WINAPI operator+(const CHString& string, LPCWSTR lpsz) throw ( CHeap_Exception ) ;
        friend CHString POLARITY WINAPI operator+(LPCWSTR lpsz, const CHString& string) throw ( CHeap_Exception ) ;

// string comparison

        int Compare(LPCWSTR lpsz) const;

        inline int CompareNoCase(LPCWSTR lpsz) const
        {
            // ignore case

            return _wcsicmp(m_pchData, lpsz); 

        }   // MBCS/Unicode aware

        inline int Collate(LPCWSTR lpsz) const
        {  
            // NLS aware
            // CHString::Collate is often slower than Compare but is MBSC/Unicode
            // aware as well as locale-sensitive with respect to sort order.

            return wcscoll(m_pchData, lpsz); 

        }   // locale sensitive

// Load string from resource file.

#ifdef FRAMEWORK_ALLOW_DEPRECATED
        BOOL LoadStringW(UINT nID) throw ( CHeap_Exception ) ;
#endif

// Access to string implementation buffer as "C" character array

        LPWSTR GetBuffer(int nMinBufLength) throw ( CHeap_Exception ) ;
        void ReleaseBuffer(int nNewLength = -1) throw ( CHeap_Exception ) ;
        LPWSTR GetBufferSetLength(int nNewLength) throw ( CHeap_Exception ) ;
        void FreeExtra() throw ( CHeap_Exception ) ;

// Use LockBuffer/UnlockBuffer to turn refcounting off

        LPWSTR LockBuffer() ;
        void UnlockBuffer();

// searching (return starting index, or -1 if not found)
// look for a single character match

        int Find(WCHAR ch) const;               // like "C" strchr
        int FindOneOf(LPCWSTR lpszCharSet) const;
        int ReverseFind(WCHAR ch) const;

// look for a specific sub-string

        int Find(LPCWSTR lpszSub) const;        // like "C" strstr

// upper/lower/reverse conversion

        void MakeUpper() throw ( CHeap_Exception ) ;
        void MakeLower() throw ( CHeap_Exception ) ;
        void MakeReverse() throw ( CHeap_Exception ) ;

// simple sub-string extraction

        CHString Mid(int nFirst, int nCount) const throw ( CHeap_Exception ) ;
        CHString Mid(int nFirst) const throw ( CHeap_Exception ) ;
        CHString Left(int nCount) const throw ( CHeap_Exception ) ;
        CHString Right(int nCount) const throw ( CHeap_Exception ) ;

        CHString SpanIncluding(LPCWSTR lpszCharSet) const throw ( CHeap_Exception ) ;
        CHString SpanExcluding(LPCWSTR lpszCharSet) const throw ( CHeap_Exception ) ;

// trimming whitespace (either side)

        void TrimRight() throw ( CHeap_Exception ) ;
        void TrimLeft() throw ( CHeap_Exception ) ;
    
// printf-like formatting using passed string
        void __cdecl Format(LPCWSTR lpszFormat, ...) throw ( CHeap_Exception ) ;
        void FormatV(LPCWSTR lpszFormat, va_list argList);

// printf-like formatting using referenced string resource
#ifdef FRAMEWORK_ALLOW_DEPRECATED
        void __cdecl Format(UINT nFormatID, ...) throw ( CHeap_Exception ) ;
#endif

// format using FormatMessage API on passed string
        // Warning: if you pass string inserts to this function, they must
        // be LPCSTRs on Win9x and LPCWSTRs on NT.
        void __cdecl FormatMessageW(LPCWSTR lpszFormat, ...) throw ( CHeap_Exception ) ;

// format using FormatMessage API on referenced string resource
        // Warning: if you pass string inserts to this function, they must
        // be LPCSTRs on Win9x and LPCWSTRs on NT.
#ifdef FRAMEWORK_ALLOW_DEPRECATED
        void __cdecl FormatMessageW(UINT nFormatID, ...) throw ( CHeap_Exception ) ;
#endif

#ifndef _NO_BSTR_SUPPORT

        // OLE BSTR support (use for OLE automation)

        BSTR AllocSysString() const throw ( CHeap_Exception ) ;
#endif

};

inline BOOL operator==(const CHString& s1, const CHString& s2)  { return s1.Compare(s2) == 0; }
inline BOOL operator==(const CHString& s1, LPCWSTR s2)          { return s1.Compare(s2) == 0; }

inline BOOL operator!=(const CHString& s1, const CHString& s2)  { return s1.Compare(s2) != 0; }
inline BOOL operator!=(const CHString& s1, LPCWSTR s2)          { return s1.Compare(s2) != 0; }

inline BOOL operator<(const CHString& s1, const CHString& s2)   { return s1.Compare(s2) < 0; }
inline BOOL operator<(const CHString& s1, LPCWSTR s2)           { return s1.Compare(s2) < 0; }

inline BOOL operator>(const CHString& s1, const CHString& s2)   { return s1.Compare(s2) > 0; }
inline BOOL operator>(const CHString& s1, LPCWSTR s2)           { return s1.Compare(s2) > 0; }

inline BOOL operator<=(const CHString& s1, const CHString& s2)  { return s1.Compare(s2) <= 0; }
inline BOOL operator<=(const CHString& s1, LPCWSTR s2)          { return s1.Compare(s2) <= 0; }

inline BOOL operator>=(const CHString& s1, const CHString& s2)  { return s1.Compare(s2) >= 0; }
inline BOOL operator>=(const CHString& s1, LPCWSTR s2)          { return s1.Compare(s2) >= 0; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\include\cregcls.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  cregcls.h
//
//  Purpose: registry wrapper class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CREGCLS_H_
#define _CREGCLS_H_

#include <Polarity.h>
#include <CHString.h>
#include <chstrarr.h>
#include <chptrarr.h>

#define MAX_VALUE_NAME (1024)
#define NULL_DWORD ((DWORD)0L)
#define MAX_SUBKEY_BUFFERSIZE (255+1)      // Per spec
#define QUOTE L"\""
#define CSTRING_PTR (1)

class POLARITY CRegistry 
{
public:

    CRegistry ();   // Constructor
    ~CRegistry ();  // Destructor

// Opens the key and subkey using the desired access mask

    LONG Open (

        HKEY hRootKey,          // handle of open key 
        LPCWSTR lpszSubKey, // address of name of subkey to open 
        REGSAM samDesired       // Access mask
    ); 
    
    // Version that properly opens the user key appropriate
    // to the current thread
    DWORD OpenCurrentUser(
        LPCWSTR lpszSubKey,     // address of name of subkey to open 
        REGSAM samDesired);     // Access mask


// Generalized RegCreateKeyEx form 

    LONG CreateOpen (

        HKEY hInRootKey, 
        LPCWSTR lpszSubKey,
        LPWSTR lpClass = NULL, 
        DWORD dwOptions = REG_OPTION_NON_VOLATILE, 
        REGSAM samDesired = KEY_ALL_ACCESS,
        LPSECURITY_ATTRIBUTES lpSecurityAttrib = NULL,
        LPDWORD pdwDisposition = NULL 
    );


// Deletes the specified subkey or the opened root

    LONG DeleteKey ( 

        CHString *pchsSubKeyPath = NULL 
    );

// Deletes the specified value within the createopened portion of the registry

    LONG DeleteValue (

        LPCWSTR pValueName 
    ); 

// Opens the key but forces the enumation of subkeys flag
//=======================================================

    LONG OpenAndEnumerateSubKeys (

        HKEY hInRootKey, 
        LPCWSTR lpszSubKey, 
        REGSAM samDesired
    );

    LONG EnumerateAndGetValues (

        DWORD &dwIndexOfValue,
        WCHAR *&pValueName,
        BYTE *&pValueData
    );

    void Close ( void ) ;



// Information Functions

// Having a key, but no class name is legal so just return a null string
// if there has been no class name set
//======================================================================

    HKEY GethKey ( void )                       { return hKey; }

    WCHAR *GetClassName ( void )                { return ( ClassName ) ; }
    DWORD GetCurrentSubKeyCount ( void )        { return ( dwcSubKeys ) ; }
    DWORD GetLongestSubKeySize ( void )         { return ( dwcMaxSubKey ) ; }
    DWORD GetLongestClassStringSize ( void )    { return ( dwcMaxClass ) ; }
    DWORD GetValueCount ( void )                { return ( dwcValues ) ; }
    DWORD GetLongestValueName ( void )          { return ( dwcMaxValueName ) ; }
    DWORD GetLongestValueData ( void )          { return ( dwcMaxValueData ) ; }

    DWORD GetCurrentKeyValue ( LPCWSTR pValueName , CHString &DestValue ) ;
    DWORD GetCurrentKeyValue ( LPCWSTR pValueName , DWORD &DestValue ) ;
    DWORD GetCurrentKeyValue ( LPCWSTR pValueName , CHStringArray &DestValue ) ;

    DWORD SetCurrentKeyValue ( LPCWSTR pValueName , CHString &DestValue ) ;
    DWORD SetCurrentKeyValue ( LPCWSTR pValueName , DWORD &DestValue ) ;
    DWORD SetCurrentKeyValue ( LPCWSTR pValueName , CHStringArray &DestValue ) ;

    DWORD GetCurrentBinaryKeyValue ( LPCWSTR pValueName , CHString &chsDest ) ;
    DWORD GetCurrentBinaryKeyValue ( LPCWSTR pValueName , LPBYTE pbDest , LPDWORD pSizeOfDestValue ) ;

    DWORD GetCurrentKeyValue ( HKEY UseKey , LPCWSTR pValueName , CHString &DestValue ) ;
    DWORD GetCurrentKeyValue ( HKEY UseKey , LPCWSTR pValueName , DWORD &DestValue ) ;
    DWORD GetCurrentKeyValue ( HKEY UseKey , LPCWSTR pValueName , CHStringArray &DestValue ) ;

    DWORD SetCurrentKeyValue ( HKEY UseKey , LPCWSTR pValueName , CHString &DestValue ) ;
    DWORD SetCurrentKeyValue ( HKEY UseKey , LPCWSTR pValueName , DWORD &DestValue ) ;
    DWORD SetCurrentKeyValue ( HKEY UseKey , LPCWSTR pValueName , CHStringArray &DestValue ) ;

    DWORD SetCurrentKeyValueExpand ( HKEY UseKey , LPCWSTR pValueName , CHString &DestValue ) ;

    DWORD GetCurrentBinaryKeyValue (  HKEY UseKey , LPCWSTR pValueName , LPBYTE pbDest , LPDWORD pSizeOfDestValue ) ;

    DWORD DeleteCurrentKeyValue ( LPCWSTR pValueName ) ;
    DWORD DeleteCurrentKeyValue ( HKEY UseKey , LPCWSTR pValueName ) ;

    // Subkey functions
    //=================

    void  RewindSubKeys ( void ) ;
    DWORD GetCurrentSubKeyName ( CHString &DestSubKeyName ) ;

    DWORD GetCurrentSubKeyValue ( LPCWSTR pValueName, void *pDestValue , LPDWORD pSizeOfDestValue ) ;
    DWORD GetCurrentSubKeyValue ( LPCWSTR pValueName, CHString &DestValue ) ;
    DWORD GetCurrentSubKeyValue ( LPCWSTR pValueName, DWORD &DestValue ) ;

    DWORD NextSubKey ( void ) ; 
    DWORD GetCurrentSubKeyPath ( CHString &DestSubKeyPath ) ; 

    LONG  OpenLocalMachineKeyAndReadValue (

        LPCWSTR lpszSubKey , 
        LPCWSTR pValueName, 
        CHString &DestValue
    );

private:

    // Private functions
    //==================

    // Set the member variables to their default state
    //================================================
    void SetDefaultValues ( void ) ;

    // Open and close the subkey
    // =========================
    DWORD OpenSubKey ( void ) ;
    void  CloseSubKey ( void ) ;

    // Given a good key gets the value
    // ===============================
    DWORD GetCurrentRawKeyValue (

        HKEY UseKey, 
        LPCWSTR pValueName, 
        void *pDestValue,
        LPDWORD pValueType, 
        LPDWORD pSizeOfDestValue
    ) ;

    DWORD GetCurrentRawSubKeyValue (

        LPCWSTR pValueName, 
        void *pDestValue,
        LPDWORD pValueType, 
        LPDWORD pSizeOfDestValue
    ) ;

    // Init static vars
    // ================
    static DWORD WINAPI GetPlatformID ( void ) ;

    // MultiPlatform support
    // =====================

    LONG myRegCreateKeyEx (

        HKEY hKey, 
        LPCWSTR lpwcsSubKey, 
        DWORD Reserved, 
        LPWSTR lpwcsClass, 
        DWORD dwOptions, 
        REGSAM samDesired, 
        LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
        PHKEY phkResult, 
        LPDWORD lpdwDisposition
    );

    LONG myRegSetValueEx (

        HKEY hKey, 
        LPCWSTR lpwcsSubKey, 
        DWORD Reserved, 
        DWORD dwType, 
        CONST BYTE *lpData, 
        DWORD cbData
    );

    LONG myRegQueryValueEx (

        HKEY hKey, 
        LPCWSTR lpwcsSubKey, 
        LPDWORD Reserved, 
        LPDWORD dwType, 
        LPBYTE lpData, 
        LPDWORD cbData
    );

    LONG myRegEnumKey (

        HKEY hKey, 
        DWORD dwIndex, 
        LPWSTR lpwcsName, 
        DWORD cbData
    );

    LONG myRegDeleteValue (

        HKEY hKey, 
        LPCWSTR lpwcsName
    ) ;

    LONG myRegDeleteKey (

        HKEY hKey, 
        LPCWSTR lpwcsName
    );

    LONG myRegOpenKeyEx (

        HKEY hKey, 
        LPCWSTR lpwcsSubKey, 
        DWORD ulOptions, 
        REGSAM samDesired, 
        PHKEY phkResult
    );

    LONG myRegQueryInfoKey (

        HKEY hKey, 
        LPWSTR lpwstrClass, 
        LPDWORD lpcbClass,
        LPDWORD lpReserved, 
        LPDWORD lpcSubKeys, 
        LPDWORD lpcbMaxSubKeyLen,  
        LPDWORD lpcbMaxClassLen, 
        LPDWORD lpcValues, 
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen, 
        LPDWORD lpcbSecurityDescriptor, 
        PFILETIME lpftLastWriteTime
    );

    LONG myRegEnumValue (

        HKEY hKey, 
        DWORD dwIndex, 
        LPWSTR lpValueName,
        LPDWORD lpcbValueName, 
        LPDWORD lpReserved, 
        LPDWORD lpType,
        LPBYTE lpData, 
        LPDWORD lpcbData
    );


    // In the event the caller is REUSING this instance,
    // close the existing key and reset values to the default
    // in preparation to REOPEN this instance
    //=======================================================
    void PrepareToReOpen ( void ) ;

    // Private data
    //=============

    HKEY hRootKey;             // Current root key for cla
    HKEY hKey;                 // Current active key
    HKEY hSubKey;             // Current active subkey
    static DWORD s_dwPlatform; // Currently running OS

    CHString RootKeyPath;      // Current path to root assigned by open

    DWORD CurrentSubKeyIndex; // Current subkey being indexed

    bool m_fFromCurrentUser;  // allows check on whether to free
                              // hRootKey member based on whether
                              // its value was populated via a call
                              // to ::RegOpenCurrentUser.

    // Information about this class
    //=============================

    WCHAR ClassName[MAX_PATH];      // Buffer for class name.
    DWORD dwcClassLen;              // Length of class string.
    DWORD dwcSubKeys;               // Number of sub keys.
    DWORD dwcMaxSubKey;             // Longest sub key size.
    DWORD dwcMaxClass;              // Longest class string.
    DWORD dwcValues;                // Number of values for this key.
    DWORD dwcMaxValueName;          // Longest Value name.
    DWORD dwcMaxValueData;          // Longest Value data.
    DWORD dwcSecDesc;               // Security descriptor.
    FILETIME ftLastWriteTime;       // Last write time.
}; 

//*********************************************************************
//
//   CLASS:         CRegistrySearch
//
//   Description:   This class uses the CRegistry Class to search
//                  through the registry to build a list of keys
//                  for the requested value, or requested full key
//                  name, or requested partial key name.  This class
//                  allocates CHString objects and puts them in the
//                  users CHPtrArray.  The user is responsible for
//                  deleting the memory allocated, the FreeSearchList
//                  function can accomplish this, or the user must
//                  remember to delete every object in the array
//                  before deallocating the array.
//
//
//=====================================================================
//
//  Note:  Private functions are documented in the .CPP file
//
//=====================================================================
//
//  Public functions
//
//=====================================================================
//
//  BOOL SearchAndBuildList( CHString chsRootKey, 
//                           CHPtrArray & cpaList,
//                           CHString chsSearchString,
//                           CHString chsValueString,
//                           int nSearchType );
//
//  Parameters:
//      chsRootKey          - The root key to start the search from.
//                            Note:  At this point in time, we just
//                            search thru HKEY_LOCAL_MACHINE, this
//                            can be changed when needed. 
//      cpaList             - The reference to the CHPtrArray to put
//                            the list of keys that matched the search
//                            criteria.
//      chsSearchString     - The string to search for
//      chsValueString      - The value to open and see if it matches what is 
//                            chsSearchString
//      nSearchType         - The type of search, the following are
//                            supported:
//                            KEY_FULL_MATCH_SEARCH      
//                               Only keys that match the chsSearchString
//                            KEY_PARTIAL_MATCH_SEARCH   
//                               Keys that have chsSearchString anywhere in them
//                            VALUE_SEARCH               
//                               Values that match chsSearchString
//*********************************************************************
#define KEY_FULL_MATCH_SEARCH      1
#define KEY_PARTIAL_MATCH_SEARCH   2
#define VALUE_SEARCH               3

class POLARITY CRegistrySearch
{
private:

    void CheckAndAddToList (

        CRegistry * pReg, 
        CHString chsSubKey, 
        CHString chsFullKey,
        CHPtrArray & chpaList,
        CHString chsSearchString,
        CHString chsValueString,
        int nSearchType
    );

    int m_nSearchType ;
    CHString m_chsSearchString ;
    CHPtrArray m_cpaList ;


public:

    CRegistrySearch () ;
    ~CRegistrySearch () ;

    BOOL SearchAndBuildList ( 

        CHString chsRootKey, 
        CHPtrArray & cpaList,
        CHString chsSearchString,
        CHString chsValueString,
        int nSearchType,
        HKEY hkDefault = HKEY_LOCAL_MACHINE 
    );

    BOOL FreeSearchList (

        int nType, 
        CHPtrArray & cpaList
    ) ;

    BOOL LocateKeyByNameOrValueName (

        HKEY hKeyParent,
        LPCWSTR pszKeyName,
        LPCWSTR pszSubKeyName,
        LPCWSTR *ppszValueNames,
        DWORD dwNumValueNames,
        CHString &strFoundKeyName,
        CHString &strFoundKeyPath
    ) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\include\utillib.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  utillib.h
//
//  Purpose: gather up utillib headers into one catch-all
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef UTILLIB_HEADERFILE_IS_INCLUDED
#define UTILLIB_HEADERFILE_IS_INCLUDED

#include <ProvExce.h>

#include <GenLex.h>
#include <ObjPath.h> 
#include <OPathLex.h> 

#include <CHString.h>
#include <CHStrArr.h>
#include <CHPtrArr.h>
#include <Polarity.h>
#include <WbemTime.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\include\provexce.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  ProvExce.h
//
//  Purpose: Exception handling classes
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _PROVIDER_EXCEPT_H
#define _PROVIDER_EXCEPT_H

/**************************************************************
 *
 **************************************************************/

#include <eh.h>

/**************************************************************
 *
 **************************************************************/

class CHeap_Exception
{
public:

	enum HEAP_ERROR
	{
		E_ALLOCATION_ERROR = 0 ,
		E_FREE_ERROR
	};

private:

	HEAP_ERROR m_Error;

public:

	CHeap_Exception ( HEAP_ERROR e ) : m_Error ( e ) {}
	~CHeap_Exception () {}

	HEAP_ERROR GetError() { return m_Error ; }
} ;

/**************************************************************
 *
 **************************************************************/

class CStructured_Exception
{
private:

    UINT m_nSE ;
	EXCEPTION_POINTERS *m_pExp ;

public:

    CStructured_Exception () {}
    CStructured_Exception ( UINT n , EXCEPTION_POINTERS *pExp ) : m_nSE ( n ) , m_pExp ( pExp ) {}
    ~CStructured_Exception () {}
    UINT GetSENumber () { return m_nSE ; }
	EXCEPTION_POINTERS *GetExtendedInfo() { return m_pExp ; }
} ;

/**************************************************************
 *
 **************************************************************/

class CSetStructuredExceptionHandler
{
private:

	_se_translator_function m_PrevFunc ;

public:

	static void _cdecl trans_func ( UINT u , EXCEPTION_POINTERS *pExp )
	{
		throw CStructured_Exception ( u , pExp ) ;
	}

	CSetStructuredExceptionHandler () : m_PrevFunc ( NULL )
	{
		m_PrevFunc = _set_se_translator ( trans_func ) ;
	}

	~CSetStructuredExceptionHandler ()
	{
		_set_se_translator ( m_PrevFunc ) ;
	}
} ;

/**************************************************************
 *
 **************************************************************/

#endif //_PROVIDER_EXCEPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\include\utils.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  utils.h
//
//  Purpose: utility functions
//
//***************************************************************************
#pragma once

#define NORMALIZE_NULL 1

typedef enum
{
    e_OK,
    e_UnparsablePath,
    e_NonLocalPath,
    e_UnParseError,
    e_NullName
} GetValuesForPropResults;

/*****************************************************************************
 *
 *  FUNCTION    : NormalizePath
 *
 *  DESCRIPTION : Converts object paths to a normalized form
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : Machine name is verified, then removed.  Namespace is verified
 *                then removed.  If there is only one key, then the key property
 *                name is removed.  If there is more than one key, then the order
 *                of the key names is alphabetized.
 *
 *                If dwFlags == 0, then DON'T null the key
 *                property name, if NORMALIZE_NULL, then DO null the key.
 *
 *****************************************************************************/

DWORD POLARITY WINAPI NormalizePath(
    
    LPCWSTR lpwszInPath, 
    LPCWSTR lpwszComputerName, 
    LPCWSTR lpwszNamespace,
    DWORD dwFlags,
    CHString &sOutPath
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\crc32.h ===
/*++

// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved 

Module Name:

    CRC32.H

Abstract:

    Standard CRC-32 implementation

History:

	raymcc      07-Jul-97       Createada

--*/

#ifndef _CRC_H_
#define _CRC_H_

#define STARTING_CRC32_VALUE    0xFFFFFFFF

DWORD UpdateCRC32(
    LPBYTE  pSrc,               // Points to buffer
    int     nBytes,             // Number of bytes to compute
    DWORD   dwOldCrc            // Must be STARTING_CRC_VALUE (0xFFFFFFFF) 
                                // if no previous CRC, otherwise this is the
                                // CRC of the previous cycle.
    );

#define FINALIZE_CRC32(x)    (x=~x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\bmof.h ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    BMOF.H

Abstract:

	Describes the format of binary MOF files.  In addition, it defines some
	structures which specify the details of the format and also defines some
	addtional structures and helper functions for navigating a BMOF file.

History:

	a-davj  14-April-97   Created.

--*/

#ifndef __BMOF__
#define __BMOF__


#ifdef __cplusplus
extern "C" {
#endif

//  Binary mof files contain a large blob of data which consists of stuctures
//  which contain other structures, etc.  The layout of that blob is detailed in
//  the following comments.  However, the binary files are compressed and always
//  starts off with the following DWORDS
//  [Signature] [Compression Type, Always 1] [Compressed size] [Expanded size] The blob follows!
//  An example of decompressing the file is in test.c
//
//   The following is a BNF description of the structures that make up
//   a BMOF file and also serve to illustrate the basic layout of WBEM
//   objects.
//  
//  --A MOF is zero or more objects
//  
//  WBEM_Binary_MOF ::= WBEM_Object*; 
//  
//  --An object is a qualifier list (applying to the entire object) and
//  --a property list
//  
//  WBEM_Object ::= WBEM_QualifierList WBEM_PropertyList;
//  
//  --A property list is zero or more properties
//     
//  WBEM_PropertyList ::= WBEM_Property*;   / zero or more properties
//  
//  --A property is a set of qualifiers applying to the property, and
//  --a type, a name, and a value
//  
//  WBEM_Property ::= WBEM_QualifierList* <type> <name> <value>;
//  
//  --A qualifier list is zero or more qualifiers
//  
//  WBEM_QualifierList ::= WBEM_Qualifier*;   -- zero or more qualifiers
//  
//  --A qualifier is a type, a name, and a value. However, the supported types
//  --are not as extensive as for properties.
//  
//  WBEM_Qualifier ::= <type> <name> <value>;
//  
//  
//  Note that a qualifier set (a list of qualifiers) can be applied
//  to the entire object or to individual properties. However, qualifiers
//  cannot be applied to other qualifiers:
//  
//      object = quals + props
//      prop = quals + name + value
//      qual = name + value
//  
//  Information such as the name of a class, the super class, etc., are coded
//  as property values.  Finding the value of the property __CLASS, for example,
//  gives the name of the class.  All properties beginning with a double
//  underscore are well-known system properties common to all WBEM objects.
//  All other properties are user-defined.
//  
//  The list of predefined properties is found in WBEM documentation.
//  
//  Offsets are relative to their owning structure, not absolute to the
//  entire encoding image.  This allows moving the subcomponents around
//  without rencoding everything.
//  
//  Note that an offset of 0xFFFFFFFF indicates that the field is not used.
//  
//  Both properties and qualifiers have value fields which contain data based
//  on Ole Automation types.  Qualifiers are simple types (no arrays or 
//  embedded objects) while property values might contain arrays and/or 
//  embedded objects.  
//
//  One difference from Ole is that BSTRs are actually stored as WCHAR 
//  strings even if the data type is marked as BSTR.  
//
//  In addition, some qualifiers or properties are actually aliases which 
//  must be resolved later.  Aliases are stored as BSTR values and the type
//  field is set to VT_BSTR | VT_BYREF.  An array of alias strings is a bit
//  more complicated since not all the elements need be aliases.  In the array
//  case, each actual alias string is prepended with a L'$' while each 
//  "regular" string is prepended by a L' '.
//
//  Currently, only scalars and single dimensional arrays are supported.
//  However, the BMOF file layout is designed so as to accommodate multi-
//  dimensional array in the future.  For array data, the data is layout out
//
//  ArrayData ::= ArrayHeaderData + RowOfData*; 
//
//  The ArrayHeaderData has the form;
//  dwtotalsize, dwNumDimenstions, dwMostSigDimension... dwLeastSigDimension
// 
//  Currently only 1 dimensional arrays are supported, a 5 element
//  array would start with;
//  dwSize, 1, 5
//
//  After the header, one or more rows would follow.  A row represents the
//  "most rapidly changing" data.  Currently, there is only one row.
//
//  The row format is;
//
//  dwSizeOfRow, MostSigDimension ... dwLeastSignificentDimension+1,data
//  For a one dimensional array, it would just be
//  dwSizeOfRow, Data
//

//  The extension  for supporting qualifier flavors is to add the following data after the current blob.
//  
//  typedef struct 
//  {
//      WCHAR wcSignature;          // the string BMOFQUALFLAVOR11
//      DWORD dwNumPair;
//      // BYTE FlavorInfo[];             // Blob containing array of WBEM_Object structs
//  }WBEM_Binary_FLAVOR;
//  
//  The FlavorInfo blob will be a series of DWORD pairs of the form
//  
//  Typedef struct
//  {
//  	DWORD dwOffsetInOriginalBlob;
//  	DWORD dwFlavor;
//  }

// Each Binary MOF file starts off with these signature bytes.

#define BMOF_SIG 0x424d4f46

// The following structures exactly describe the contents of a BMOF file.
// These can be used to navigate the file using the various offsets and
// lots of casting.  

typedef struct 
{
    DWORD dwSignature;          // four characters, BMOF
    DWORD dwLength;
    DWORD dwVersion;            // 0x1
    DWORD dwEncoding;           // 0x1 = little endian, DWORD-aligned, no compression

    DWORD dwNumberOfObjects;    // Total classes and instances in MOF

    // BYTE Info[];             // Blob containing array of WBEM_Object structs
                                // First object is at offset 0.
}WBEM_Binary_MOF;

typedef struct                  // Describes a class or instance
{
    DWORD dwLength;
    DWORD dwOffsetQualifierList;
    DWORD dwOffsetPropertyList;
    DWORD dwOffsetMethodList;
    DWORD dwType;               // 0 = class, 1 = instance
    
    //  BYTE Info[];            // Blob of qualifier set and properties
}WBEM_Object;

typedef struct 
{
    DWORD dwLength;
    DWORD dwNumberOfProperties;
    
    //  BYTE Info[];                // Blob with all properties placed end-to-end    
}WBEM_PropertyList;
                                                                   
typedef struct 
{
    DWORD dwLength;             // Length of this struct
    DWORD dwType;               // A VT_ type from WTYPES.H (VT_I4, VT_UI8, etc)
    DWORD dwOffsetName;         // Offset in <Info> of the null-terminated name.
    DWORD dwOffsetValue;        // Offset in <Info> of the value.
    DWORD dwOffsetQualifierSet; // 
        
    
    //  BYTE  Info[];           // Contains qualifier set, name, and value
}WBEM_Property;

// Rough encoding example for a string:
//
// dwLength = 10;
// dwType   = VT_LPWSTR;    
// dwOffsetName  = 0;
// dwOffsetValue = 8;
// dwOffsetQualifierSet = 0xFFFFFFFF;   // Indicates not used
//
// Info[] = "CounterValue\0<default value>\0";


typedef struct       
{
    DWORD dwLength;
    DWORD dwNumQualifiers;
    //  BYTE Info[];                // Array of WBEM_Qualifiers placed end-to-end
}WBEM_QualifierList;


typedef struct 
{
    DWORD dwLength;         // Length of this struct
    DWORD dwType;           // A VT_ type from WTYPES.H (VT_I4, VT_UI8, etc)
    DWORD dwOffsetName;     // Offset in <Info> of the null-terminated name.
    DWORD dwOffsetValue;    // Offset in <Info> of the value.
    //  BYTE  Info[];   
}WBEM_Qualifier;


// These structures and the helper functions that go with them can be used
// to easily navigate a BMOF file.  These structures "wrap" the above 
// structures so as to provide features such as searching and enumeration.

typedef struct 
{
    UNALIGNED WBEM_QualifierList * m_pql;
    UNALIGNED WBEM_Qualifier * m_pInfo;
    DWORD m_CurrQual;
    UNALIGNED WBEM_Qualifier * m_pCurr;

}CBMOFQualList;

typedef struct 
{
    UNALIGNED WBEM_Object * m_pob;
    BYTE * m_pInfo;
    UNALIGNED WBEM_PropertyList * m_ppl;
    DWORD m_CurrProp;
    UNALIGNED WBEM_Property * m_pCurrProp;

    UNALIGNED WBEM_PropertyList * m_pml;
    DWORD m_CurrMeth;
    UNALIGNED WBEM_Property * m_pCurrMeth;

}CBMOFObj;

typedef struct 
{
    WBEM_Binary_MOF * m_pol;
    DWORD m_CurrObj;
    UNALIGNED WBEM_Object * m_pInfo;
    UNALIGNED WBEM_Object * m_pCurrObj;   
}CBMOFObjList;


typedef struct 
{
    BYTE * m_pData;
    DWORD  m_dwType;
}CBMOFDataItem;

// Using any of the following help functions requires that these two 
// functions be provided in another module and allow independence from
// any particular allocation method.

void * BMOFAlloc(size_t Size);
void BMOFFree(void * pFree);


// These functions wrap the object list and provider for enumeration of
// the objects.

CBMOFObjList * CreateObjList(BYTE * pBuff);
void ResetObjList(CBMOFObjList * pol);
CBMOFObj * NextObj(CBMOFObjList *pol);
CBMOFObj * FindObj(CBMOFObjList *pol, WCHAR * pName);

// These functions allow access to the parts of a class or instance object

void ResetObj(CBMOFObj * pol);
CBMOFQualList * GetQualList(CBMOFObj * pol);
CBMOFQualList * GetPropQualList(CBMOFObj * pol, WCHAR * pName);
CBMOFQualList * GetMethQualList(CBMOFObj * pol, WCHAR * pName);
BOOL NextProp(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL NextMeth(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL FindProp(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem);
BOOL FindMeth(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem);
BOOL GetName(CBMOFObj * pob, WCHAR ** ppName);
DWORD GetType(CBMOFObj * pob);
UNALIGNED WBEM_Property * FindPropPtr(CBMOFObj * pob, WCHAR * pName);
UNALIGNED WBEM_Property * FindMethPtr(CBMOFObj * pob, WCHAR * pName);

//  These functions provide easy access to a qualifier list.

void ResetQualList(CBMOFQualList * pql);
BOOL NextQual(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL NextQualEx(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem, 
                                            DWORD * pdwFlavor, BYTE * pBuff, 
											BYTE * pToFar);
BOOL FindQual(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem);
BOOL FindQualEx(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem, 
                                            DWORD * pdwFlavor, BYTE * pBuff,
											BYTE * pToFar);

// These functions provide easy access to a data item.  Note that data items
// might be stored in arrays.

int GetNumDimensions(CBMOFDataItem *);
int GetNumElements(CBMOFDataItem *, long lDim);
int GetData(CBMOFDataItem *, BYTE * pRet, long * plDims);

// These functions are mainly useful to the above helper functions

int iTypeSize(DWORD vtTest);
BOOL SetValue(CBMOFDataItem * pItem, BYTE * pInfo, DWORD dwOffset, DWORD dwType);
BOOL SetName(WCHAR ** ppName, BYTE * pInfo, DWORD dwOffset);
CBMOFQualList * CreateQualList(UNALIGNED WBEM_QualifierList *pql);
CBMOFObj * CreateObj(UNALIGNED WBEM_Object * pob);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\crc32.cpp ===
/*++

// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved 

Module Name:

    CRC32.CPP

Abstract:

    Standard CRC-32 implementation

History:

    raymcc      07-Jul-97       Createada

--*/

#include "precomp.h"
#include <stdio.h>
#include <crc32.h>

static DWORD CrcTable[] =
{
0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};


DWORD UpdateCRC32(
    LPBYTE  pSrc,               // Points to buffer
    int     nBytes,             // Number of bytes to compute
    DWORD   dwOldCrc            // Must be 0xFFFFFFFF if no previous CRC
    )
{
    if(nBytes == 0)
        return dwOldCrc;

    DWORD dwNewCrc = 0;

    for (int n = 0; n < nBytes; n++)
    {
        dwNewCrc = CrcTable[ BYTE(dwOldCrc ^ DWORD(pSrc[n]))] 
            ^ ((dwOldCrc >> 8) & 0x00FFFFFF);
        dwOldCrc = dwNewCrc;            
    }
    
    return dwNewCrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\bmof.c ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    BMOF.C

Abstract:

    Structures and helper functions for naviagating a BMOF file.

History:

    a-davj  14-April-97   Created.

--*/

#include <windows.h>
#include <oleauto.h>
#include <string.h>
#include "bmof.h"
#include <wbemutil.h>


wchar_t ToLower(wchar_t c)
{
    wchar_t wideChar ;

    if (LCMapStringW(LOCALE_INVARIANT, LCMAP_LOWERCASE, &c, 1, &wideChar, 1) ==0)
    {
	return c;
    }
    return wideChar;
}

wchar_t wbem_towlower(wchar_t c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'A' && c <= 'Z')
            return c + ('a' - 'A');
        else
            return c;
    }
    else return ToLower(c);
}

int wbem_wcsicmp( const wchar_t* wsz1, const wchar_t* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}



int wmi_unaligned_wcslen( LPCWSTR wszString )
{
    BYTE*   pbData = (BYTE*) wszString;
	int i;

    // Walk the string looking for two 0 bytes next to each other.
    for( i =0; !(!*(pbData) && !*(pbData+1) ); pbData+=2, i++ );

    return i;
}

WCHAR* wmi_unaligned_wcscpy( WCHAR* wszDest, LPCWSTR wszSource )
{
    int nLen = wmi_unaligned_wcslen( wszSource );

    // Account for the NULL terminator when copying
    CopyMemory( (BYTE*) wszDest, (BYTE*) wszSource, (nLen+1) * 2 );

    return wszDest;
}

//***************************************************************************
//
//  BOOL LookupFlavor
//
//  DESCRIPTION:
//
//  Looks in the flavor table to see if a qualifier has a flavor.
//
//  PARAMETERS:
//
//  pQual      Pointer to the qualifier.
//  pdwFlavor  Pointer to where the return value is put
//  pBuff      Pointer to the main buffer.  I.e. "BMOF...."
//  pToFar	   Pointer to 1 past the last byte in the buffer
//
//
//  RETURN VALUE:
//
//  TRUE if there is a flavor.  Note that failure is normal
//
//***************************************************************************

BOOL LookupFlavor(BYTE * pQual, DWORD * pdwFlavor, BYTE * pBuff, BYTE * pToFar)
{
    UNALIGNED DWORD * pTemp;
    BYTE * pFlavorBlob;
    DWORD dwNumPairs;
    UNALIGNED DWORD * pOffset;
    UNALIGNED DWORD * pFlavor;
    DWORD dwMyOffset;
    DWORD dwCnt;

    *pdwFlavor = 0;

    // Calculate the pointer of the start of the flavor data

    pTemp = (DWORD * )pBuff;
    pTemp++;                            // point to the original blob size
    pFlavorBlob = pBuff + *pTemp;

	// Dont even try past the end of memory

	if(pToFar == NULL)
		return FALSE;

	if(pFlavorBlob + 16 >= pToFar)
		return FALSE;

    // Check if the flavor blob is valid, it should start off with the 
    // characters "BMOFQUALFLAVOR11"

    if(memcmp(pFlavorBlob, "BMOFQUALFLAVOR11", 16))
        return FALSE;                               // Not really a problem since it may be old file
    
    // The flavor part of the file has the format 
    // DWORD dwNumPair, followed by pairs of dwords;
    // offset, flavor

    // Determine the number of pairs

    pFlavorBlob+= 16;
    pTemp = (DWORD *)pFlavorBlob;
    dwNumPairs = *pTemp;              // Number of offset/value pairs
    if(dwNumPairs < 1)
        return FALSE;

    // point to the first offset/flavor pair

    pOffset = pTemp+1;
    pFlavor = pOffset+1;

    // Determine the offset we are looking for.  That is the pointer to the qualifier minus
    // the pointer to the start of the block;

    dwMyOffset = (DWORD)(pQual - pBuff);

    for(dwCnt = 0; dwCnt < dwNumPairs; dwCnt++)
    {
        if(dwMyOffset == *pOffset)
        {
            *pdwFlavor = *pFlavor;
        }
        if(dwMyOffset < *pOffset)
            return FALSE;
        pOffset += 2;
        pFlavor += 2;
    }
    return FALSE;
}

//***************************************************************************
//
//  int ITypeSize
//
//  DESCRIPTION:
//
//  Gets the number of bytes acutally used to store
//  a variant type.  0 if the type is unknown
//
//  PARAMETERS:
//
//  vtTest      Type in question.
//
//
//  RETURN VALUE:
//
//  see description
//
//***************************************************************************

int iTypeSize(
        IN DWORD vtTest)
{
    int iRet;
    vtTest &= ~ VT_ARRAY; // get rid of possible array bit
    vtTest &= ~ VT_BYREF; // get rid of possible byref bit

    switch (vtTest) {
        case VT_UI1:
        case VT_LPSTR:
            iRet = 1;
            break;
        case VT_LPWSTR:
        case VT_BSTR:
        case VT_I2:
            iRet = 2;
            break;
        case VT_I4:
        case VT_R4:
            iRet = 4;
            break;
        case VT_R8:
            iRet = 8;
            break;
        case VT_BOOL:
            iRet = sizeof(VARIANT_BOOL);
            break;
        case VT_ERROR:
            iRet = sizeof(SCODE);
            break;
        case VT_CY:
            iRet = sizeof(CY);
            break;
        case VT_DATE:
            iRet = sizeof(DATE);
            break;

        default:
            iRet = 0;
        }
    return iRet;
}


//***************************************************************************
//
//  CBMOFQualList * CreateQualList
//
//  DESCRIPTION:
//
//  Create a CBMOFQualList object which serves as a wrapper.
//
//  PARAMETERS:
//
//  pwql                 pointer to the WBEM_Qualifier structure in the binary
//                      MOF.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList structure that servers as a wrapper.  NULL
//  if error.  This must be freed via BMOFFree() when no longer needed.
//
//
//***************************************************************************

CBMOFQualList * CreateQualList(UNALIGNED WBEM_QualifierList *pwql)
{

    CBMOFQualList * pRet = NULL;
    if(pwql == NULL)
      return NULL;


    pRet = (CBMOFQualList *)BMOFAlloc(sizeof (CBMOFQualList));
    if(pRet != NULL)
    {
        pRet->m_pql = pwql;
        pRet->m_pInfo = (UNALIGNED WBEM_Qualifier *)
            ((BYTE *)pRet->m_pql + sizeof(WBEM_QualifierList));;
        ResetQualList(pRet);
    }
    return pRet;
}


//***************************************************************************
//
//  void ResetQualList
//
//  DESCRIPTION:
//
//  Resets CBMOFQualList stucture to point to the first entry.
//
//  PARAMETERS:
//
//  pql                 structure to be reset
//
//***************************************************************************

void ResetQualList(CBMOFQualList * pql)
{
   if(pql)
   {
      pql->m_CurrQual = 0;
      pql->m_pCurr = pql->m_pInfo;
   }
}

//***************************************************************************
//
//  BOOL NextQual
//
//  DESCRIPTION:
//
//  Gets the name and value of the next qualifier in the list.
//
//  PARAMETERS:
//
//  pql                 Input, points to CBMOFQualList object with data
//  ppName              Output, if functions succeeds, this points to a 
//                      WCHAR string that the caller must free.  May be
//                      NULL if caller doesnt want name.
//  pItem               Input/Output, if set, points to a data item structure
//                      which will be updated to point to the qualifier data.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//
//***************************************************************************

BOOL NextQual(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem)
{
    return NextQualEx(pql, ppName, pItem, NULL, NULL, NULL);
}


//***************************************************************************
//
//  BOOL NextQualEx
//
//  DESCRIPTION:
//
//  Gets the name and value of the next qualifier in the list.
//
//  PARAMETERS:
//
//  pql                 Input, points to CBMOFQualList object with data
//  ppName              Output, if functions succeeds, this points to a 
//                      WCHAR string that the caller must free.  May be
//                      NULL if caller doesnt want name.
//  pItem               Input/Output, if set, points to a data item structure
//                      which will be updated to point to the qualifier data.
//  pdwFlavor           optional, pointer to where the flavor value is to be copied
//                      if not null, then pBuff must be set!
//  pBuff               Pointer to the starting byte of the whole blob.  Same as 
//                      whats copied to CreateObjList.
//  pToFar              Pointer to one past the end of the memory buffer
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//
//***************************************************************************

BOOL NextQualEx(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem,
                                            DWORD * pdwFlavor, BYTE * pBuff, BYTE * pToFar)
{
    BYTE * pInfo;
    BOOL bRet = TRUE;

    if(pql == NULL || pql->m_CurrQual++ >= pql->m_pql->dwNumQualifiers)
        return FALSE;

    if(pdwFlavor && pBuff)
        LookupFlavor((BYTE *)pql->m_pCurr, pdwFlavor, pBuff, pToFar);
 
    pInfo = (BYTE *)pql->m_pCurr + sizeof(WBEM_Qualifier);
    
    if(ppName)
      SetName(ppName, pInfo, pql->m_pCurr->dwOffsetName);

    if(pInfo)
      bRet = SetValue(pItem, pInfo, pql->m_pCurr->dwOffsetValue, 
                        pql->m_pCurr->dwType);

    // advance to next
    pql->m_pCurr = (UNALIGNED WBEM_Qualifier *)((BYTE *)pql->m_pCurr + pql->m_pCurr->dwLength);
    return bRet;
}

//***************************************************************************
//
//  BOOL FindQual
//
//  DESCRIPTION:
//
//  Searches for a qualifier with a given name.  The search is case 
//  insensitive
//
//  PARAMETERS:
//
//  pql                 Input, pointer to qualifier list
//  pName               Input, Name to be searched for.
//  pItem               Input/Output, if successful set to point to the data.
//
//  RETURN VALUE:
//
//  True if OK.
//
//***************************************************************************

BOOL FindQual(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem)
{
    return FindQualEx(pql, pName, pItem, NULL, NULL, NULL);
}

//***************************************************************************
//
//  BOOL FindQualEx
//
//  DESCRIPTION:
//
//  Searches for a qualifier with a given name.  The search is case 
//  insensitive
//
//  PARAMETERS:
//
//  pql                 Input, pointer to qualifier list
//  pName               Input, Name to be searched for.
//  pItem               Input/Output, if successful set to point to the data.
//  pdwFlavor           optional, pointer to where the flavor value is to be copied
//                      if not null, then pBuff must be set!
//  pBuff               Pointer to the starting byte of the whole blob.  Same as 
//                      whats copied to CreateObjList.
//
//  RETURN VALUE:
//
//  True if OK.
//
//***************************************************************************

BOOL FindQualEx(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem, 
                                          DWORD * pdwFlavor, BYTE * pBuff, BYTE * pToFar)
{
    DWORD dwCnt;
    UNALIGNED WBEM_Qualifier * pQual = pql->m_pInfo;
    for(dwCnt = 0; dwCnt < pql->m_pql->dwNumQualifiers; dwCnt++)
    {
        WCHAR * pTest;
        BOOL bMatch;
        BYTE * pInfo = (BYTE *)pQual + sizeof(WBEM_Qualifier);
        if(!SetName(&pTest, pInfo, pQual->dwOffsetName))
            return FALSE;

        bMatch = !wbem_wcsicmp(pTest, pName);
        BMOFFree(pTest);
        if(bMatch)
        {
            if(pdwFlavor && pBuff)
                LookupFlavor((BYTE *)pQual, pdwFlavor, pBuff, pToFar);
            return SetValue(pItem, pInfo, pQual->dwOffsetValue, pQual->dwType);
        }
        pQual = (UNALIGNED WBEM_Qualifier *)((BYTE *)pQual + pQual->dwLength);
    }
    return FALSE;
}

//***************************************************************************
//
//  BOOL SetValue
//
//  DESCRIPTION:
//
//  Sets up a CBMOFDataItem structure to point to a value in the BMOF.
//
//  PARAMETERS:
//
//  pItem               Input/Output, item to be set
//  pInfo               Input, start of information block
//  dwOffset            Input, offset to actual data.
//  dwType              Input data type.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL SetValue(CBMOFDataItem * pItem, BYTE * pInfo, DWORD dwOffset, DWORD dwType)
{

    if(pItem == NULL || pInfo == NULL)
        return FALSE;

    pItem->m_dwType = dwType;

    // Check for NULL case.  This is how uninitialized data is stored.

    if(dwOffset == 0xffffffff)
        pItem->m_pData = NULL;
    else
        pItem->m_pData = pInfo + dwOffset;

    return TRUE;
}

//***************************************************************************
//
//  BOOL SetName
//
//  DESCRIPTION:
//
//  Gets a name out of an information block.
//
//  PARAMETERS:
//
//  ppName              Input/Output.  On successful return, will point to a
//                      WCHAR string containing the name.  This MUST be freed
//                      by the caller via BMOFFree()!
//  pInfo               Input, start of information block
//  dwOffset            Input, offset to actual data.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//***************************************************************************

BOOL SetName(WCHAR ** ppName, BYTE * pInfo, DWORD dwOffset)
{
    UNALIGNED WCHAR * pName;
    if(ppName == NULL || pInfo == NULL || dwOffset == 0xffffffff)
        return FALSE;

    pName = (UNALIGNED WCHAR *)(pInfo + dwOffset);   // point to string in info block
    *ppName = (WCHAR *)BMOFAlloc(2*(wmi_unaligned_wcslen((LPWSTR)pName) + 1));
    if(*ppName == NULL)
        return FALSE;
    wmi_unaligned_wcscpy(*ppName, (LPWSTR)pName);
    return TRUE;
}

//***************************************************************************
//
//  CBMOFObj * CreateObj
//
//  DESCRIPTION:
//
//  Create a CBMOFObj structure which wraps a WBEM_Object
//
//  PARAMETERS:
//
//  pwob                Input, structure to be wrapped
//
//  RETURN VALUE:
//
//  pointer to wrapper structure.  NULL if error.  This must be freed via
//  BMOFFree() when no longer needed.
//
//***************************************************************************

CBMOFObj * CreateObj(UNALIGNED WBEM_Object * pwob)
{
    CBMOFObj * pRet = (CBMOFObj *)BMOFAlloc(sizeof(CBMOFObj));
    if(pRet)
     {
        pRet->m_pob = pwob;
        pRet->m_pInfo = ((BYTE *)pwob) + sizeof(WBEM_Object);
        pRet->m_ppl = (WBEM_PropertyList*)(pRet->m_pInfo +
                                        pwob->dwOffsetPropertyList);
        pRet->m_pml = (WBEM_PropertyList*)(pRet->m_pInfo +
                                        pwob->dwOffsetMethodList);
        ResetObj(pRet);
     }
    return pRet;
}


//***************************************************************************
//
//  void ResetObj
//
//  DESCRIPTION:
//
//  Resets a CBMOFObj structure so that it points to its first property.
//
//  PARAMETERS:
//
//  pob                 Input/Output, stucture to be reset.
//
//***************************************************************************

void ResetObj(CBMOFObj * pob)
{
   if(pob)
   {
      pob->m_CurrProp = 0;
      pob->m_pCurrProp = (UNALIGNED WBEM_Property *) ((BYTE *)pob->m_ppl +
                                    sizeof(WBEM_PropertyList));
      pob->m_CurrMeth = 0;
      pob->m_pCurrMeth = (UNALIGNED WBEM_Property *) ((BYTE *)pob->m_pml +
                                    sizeof(WBEM_PropertyList));
   }
}

//***************************************************************************
//
//  CBMOFQualList * GetQualList
//
//  DESCRIPTION:
//
//  Returns a CBMOFQualList structure which wraps the objects qualifier list.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList stucture.  NULL if error.  Note that this must
//  be freed by the caller via BMOFFree()
//
//***************************************************************************

CBMOFQualList * GetQualList(CBMOFObj * pob)
{

    UNALIGNED WBEM_QualifierList *pql;
    if(pob->m_pob->dwOffsetQualifierList == 0xffffffff)
        return NULL;
    pql = (UNALIGNED WBEM_QualifierList *)((BYTE *)pob->m_pInfo+
                            pob->m_pob->dwOffsetQualifierList);
    return CreateQualList(pql);
}


//***************************************************************************
//
//  CBMOFQualList * GetPropQualList
//  CBMOFQualList * GetMethQualList
//
//  DESCRIPTION:
//
//  Returns a CBMOFQualList structure which wraps a property or
//  methods qualifier list.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input.  Property name.  Note that this is case
//                      insensitive.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList stucture.  NULL if error.  Note that this must
//  be freed by the caller via BMOFFree()
//
//***************************************************************************

CBMOFQualList * GetPropOrMethQualList(UNALIGNED WBEM_Property * pProp)
{
    if(pProp == NULL)
        return NULL;
    if(pProp->dwOffsetQualifierSet == 0xffffffff)
        return NULL;
    return CreateQualList((UNALIGNED WBEM_QualifierList *)(
                                    (BYTE *)pProp + sizeof(WBEM_Property)+
                                    pProp->dwOffsetQualifierSet));
}

CBMOFQualList * GetPropQualList(CBMOFObj * pob, WCHAR * pName)
{
    UNALIGNED WBEM_Property * pProp = FindPropPtr(pob, pName);
    return GetPropOrMethQualList(pProp);
}

CBMOFQualList * GetMethQualList(CBMOFObj * pob, WCHAR * pName)
{
    UNALIGNED WBEM_Property * pProp = FindMethPtr(pob, pName);
    return GetPropOrMethQualList(pProp);
}

//***************************************************************************
//
//  BOOL NextProp
//  BOOL NextMet
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  ppName              Output, if functions succeeds, this points to a
//                      WCHAR string that the caller must free.  May be
//                      NULL if caller doesnt want name.
//  pItem               Input/Output, if set, points to a data item structure
//                      which will be updated to point to the qualifier data.
///
//  RETURN VALUE:
//
//  TRUE if OK.
//***************************************************************************

BOOL Info(UNALIGNED WBEM_Property * pPropOrMeth, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BYTE * pInfo;
    BOOL bRet = TRUE;
    if(pPropOrMeth == NULL)
        return FALSE;

    pInfo = (BYTE *)pPropOrMeth + sizeof(WBEM_Property);
    if(ppName)
    {
       bRet = SetName(ppName, pInfo, pPropOrMeth->dwOffsetName);
       if(!bRet)
            return FALSE;
    }
    if(pItem)
       bRet = SetValue(pItem, pInfo,
                        pPropOrMeth->dwOffsetValue,
                        pPropOrMeth->dwType);
    return bRet;
}

BOOL NextProp(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BOOL bRet = TRUE;

    if(pob == FALSE || pob->m_CurrProp++ >= pob->m_ppl->dwNumberOfProperties)
        return FALSE;

    if(!Info(pob->m_pCurrProp, ppName, pItem))
        return FALSE;

    // advance pointer to next property.

    pob->m_pCurrProp = (UNALIGNED WBEM_Property *)
                        ((BYTE *)pob->m_pCurrProp + pob->m_pCurrProp->dwLength);
    return bRet;
}

BOOL NextMeth(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BOOL bRet = TRUE;

    if(pob == FALSE || pob->m_CurrMeth++ >= pob->m_pml->dwNumberOfProperties)
        return FALSE;

    if(!Info(pob->m_pCurrMeth, ppName, pItem))
        return FALSE;

    // advance pointer to next method.

    pob->m_pCurrMeth = (UNALIGNED WBEM_Property *)
                        ((BYTE *)pob->m_pCurrMeth + pob->m_pCurrMeth->dwLength);
    return bRet;
}

//***************************************************************************
//
//  BOOL FindProp
//  BOOL FindMeth
//
//  DESCRIPTION:
//
//  Sets a CBMOFDataItem structure to point to a properties data.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input. Name to be use for case insensitve search.
//  pItem               Input/Output.  Data item stucture to be updated.
//
//  RETURN VALUE:
//
//  True if found.
//
//***************************************************************************

BOOL FindProp(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem)
{
    UNALIGNED WBEM_Property * pProp = FindPropPtr(pob, pName);
    return Info(pProp, NULL, pItem);
}

BOOL FindMeth(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem)
{
    UNALIGNED WBEM_Property * pProp = FindMethPtr(pob, pName);
    return Info(pProp, NULL, pItem);
}

//***************************************************************************
//
//  BOOL GetName
//
//  DESCRIPTION:
//
//  Gets the name of an object.  This is works be returning the "__Class"
//  property.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  ppName              Input/Output.  Points to a WCHAR string which
//                      has the name.  The caller MUST free this via
//                      BMOFFree()
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL GetName(CBMOFObj * pob, WCHAR ** ppName)
{
    CBMOFDataItem Item;
    BOOL bRet = FALSE, bFound;
    if(pob == NULL || ppName == NULL)
        return FALSE;

    bFound = FindProp(pob, L"__Class", &Item);
    if(!bFound)
        return FALSE;
    if(Item.m_dwType == VT_BSTR  && ppName)
    {
        bRet = GetData(&Item, (BYTE *)ppName, NULL);
    }
    return bRet;
}


//***************************************************************************
//
//  DWORD GetType
//
//  DESCRIPTION:
//
//  Returns an objects type.  A 0 indicates a class while a 1 indicates an
//  instance.  A 0xffffffff if passed a null pointer.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//
//
//  RETURN VALUE:
//
//  See description.
//
//***************************************************************************

DWORD GetType(CBMOFObj * pob)
{
   if(pob)
      return pob->m_pob->dwType;
   else
      return 0xFFFFFFFF;
}

//***************************************************************************
//
//  WBEM_Property * FindPropPtr
//  WBEM_Property * FindMethPtr
//
//  DESCRIPTION:
//
//  Returns a WBEM_Property stucture pointer for a particular property or
//  method given its name.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input.  Name of property.  Comparison is case
//                      insensitive.
//
//  RETURN VALUE:
//
//  pointer to WBEM_Property, NULL if it cant be found.
//
//***************************************************************************

UNALIGNED WBEM_Property *  Search(BYTE * pList, DWORD dwListSize, WCHAR * pName)
{
    DWORD dwCnt;
    UNALIGNED WBEM_Property * pProp = NULL;

    // point to first property structure

    pProp = (UNALIGNED WBEM_Property *)(pList + sizeof(WBEM_PropertyList));

    for(dwCnt = 0; dwCnt < dwListSize; dwCnt++)
    {
        WCHAR * pTest;
        BOOL bMatch;

        // point to the property's name and retrieve it

        BYTE * pInfo = (BYTE *)pProp + sizeof(WBEM_Property);
        if(!SetName(&pTest, pInfo, pProp->dwOffsetName))
            return NULL;
        bMatch = !wbem_wcsicmp(pTest, pName);
        BMOFFree(pTest);

        // If we have a match, return

        if(bMatch)
            return pProp;

        pProp = (UNALIGNED WBEM_Property *)((BYTE *)pProp + pProp->dwLength);
    }
    return NULL;
}

UNALIGNED WBEM_Property * FindPropPtr(CBMOFObj * pob, WCHAR * pName)
{
    if(pob == NULL || pName == NULL)
      return NULL;

    // point to first property structure

    return Search((BYTE *)pob->m_ppl, pob->m_ppl->dwNumberOfProperties, pName);
}

UNALIGNED WBEM_Property * FindMethPtr(CBMOFObj * pob, WCHAR * pName)
{
    if(pob == NULL || pName == NULL)
      return NULL;

    // point to first property structure

    return Search((BYTE *)pob->m_pml, pob->m_pml->dwNumberOfProperties, pName);
}


//***************************************************************************
//
//  CBMOFObjList * CreateObjList
//
//  DESCRIPTION:
//
//  Create a CBMOFObjList structure which wraps a BMOF file.
//
//  PARAMETERS:
//
//  pBuff                Input, points to start of BMOF file.
//
//  RETURN VALUE:
//
//  pointer to wrapper structure.  NULL if error.  This must be freed via
//  BMOFFree() when no longer needed.
//
//***************************************************************************

CBMOFObjList * CreateObjList(BYTE * pBuff)
{
    CBMOFObjList * pRet = (CBMOFObjList * )BMOFAlloc(sizeof(CBMOFObjList));
    if(pRet)
    {
        pRet->m_pol = (WBEM_Binary_MOF *)pBuff;
        pRet->m_pInfo = (WBEM_Object *)
                   ((BYTE *)pBuff + sizeof(WBEM_Binary_MOF));
        ResetObjList(pRet);
    }
    return pRet;
}


//***************************************************************************
//
//  void ResetObjList
//
//  DESCRIPTION:
//
//  Resets a CBMOFObjList structure so that it points to its first object.
//
//  PARAMETERS:
//
//  pol                 Input/Output, stucture to be reset.
//
//***************************************************************************

void ResetObjList(CBMOFObjList * pol)
{
   if(pol)
   {
      pol->m_pCurrObj = pol->m_pInfo;
      pol->m_CurrObj = 0;
   }
}

//***************************************************************************
//
//  CBMOFObj * NextObj
//
//  DESCRIPTION:
//
//  Gets the next object in the list.
//
//  PARAMETERS:
//
//  pol                 Input. Pointer to CBMOFObjList object
//
//  RETURN VALUE:
//
//  Pointer to a CBMOFObj stucture which can be use to access the object
//  information.  NULL if error.  Note that the caller MUST Free this via
//  BMOFFree().
//
//***************************************************************************

CBMOFObj * NextObj(CBMOFObjList *pol)
{
    CBMOFObj * pRet;

    if(pol == NULL || pol->m_CurrObj++ >= pol->m_pol->dwNumberOfObjects)
        return NULL;

    pRet = CreateObj(pol->m_pCurrObj);
    pol->m_pCurrObj = (UNALIGNED WBEM_Object *)((BYTE *)pol->m_pCurrObj + pol->m_pCurrObj->dwLength);
    return pRet;
}


//***************************************************************************
//
//  CBMOFObj * FindObj
//
//  DESCRIPTION:
//
//  Searches the object list for the first object which has a "__className"
//  property.  The search is case insensitive.
//
//  PARAMETERS:
//
//  pol                 Input. Pointer to CBMOFObjList object
//  pName               Input. Name of object being searched for
//
//  RETURN VALUE:
//
//  Pointer to a CBMOFObj stucture which can be use to access the object
//  information.  NULL if error.  Note that the caller MUST Free this via
//  BMOFFree().
//
//***************************************************************************

CBMOFObj * FindObj(CBMOFObjList *pol, WCHAR * pName)
{
    DWORD dwCnt;
    UNALIGNED WBEM_Object * pob;

    if(pol->m_pol == NULL || pName == NULL)
        return NULL;

    pob = pol->m_pInfo;
    for(dwCnt = 0; dwCnt < pol->m_pol->dwNumberOfObjects; dwCnt)
    {
        WCHAR * pwcName = NULL;
        BOOL bMatch = FALSE;

        CBMOFObj * pRet = CreateObj(pob);
         if(pRet == NULL)
            return NULL;
        if(GetName(pRet,&pwcName))
            bMatch = TRUE;
        if(pwcName)
            BMOFFree(pwcName);

        // If we found it, return it, otherwise free object and advance

        if(bMatch)
            return pRet;
        BMOFFree(pRet);
        pob = (UNALIGNED WBEM_Object *)((BYTE *)pob + pob->dwLength);
    }
    return NULL;
}


//***************************************************************************
//
//  int GetNumDimensions
//
//  DESCRIPTION:
//
//  Returns the number of dimensions for a data item.
//
//  PARAMETERS:
//
//  pItem               Input.  Item in question.
//
//  RETURN VALUE:
//  -1 if bogus argument, or if the data item doesnt hold data which would
//     be the case for uninitialized properties.
//  0  if non array argument
//  n  Number of dimensions.  Currently only single dimension arrays are
//     supported.
//
//***************************************************************************

int GetNumDimensions(CBMOFDataItem * pItem)
{
   UNALIGNED unsigned long * pdwTemp;
   if(pItem == NULL)
      return -1;
   if(!(pItem->m_dwType & VT_ARRAY))
      return 0;
   if(pItem->m_pData == NULL)
      return -1;

   pdwTemp = (unsigned long *)pItem->m_pData;
   pdwTemp++;        // skip past total size
   return *pdwTemp;
}


//***************************************************************************
//
//  int GetNumElements
//
//  DESCRIPTION:
//
//  Gets the number of elements for an array dimension.  Note that 1 is the
//  first dimenstion.  Currently, only scalars and 1 dimensional arrays are
//  supported.
//
//  PARAMETERS:
//
//  pItem               Input.  Data item in question.
//  lDim                Input.  Dimension in question.  The most significent
//                      (and for now only) dimension is 0.
//
//  RETURN VALUE:
//
//  Number of array elements.  Note that scalars will return -1.
//
//***************************************************************************

int GetNumElements(CBMOFDataItem * pItem, long lDim)
{
   int iCnt; UNALIGNED DWORD * pdwTemp;
   int lNumDim = GetNumDimensions(pItem);
   if(lNumDim == -1 || lDim > lNumDim)
      return -1;
   pdwTemp = (UNALIGNED unsigned long *)pItem->m_pData;
   pdwTemp++;                          // skip total size
   pdwTemp++;                          // skip number of dimensions
   for(iCnt = 0; iCnt < lDim; iCnt++)
      pdwTemp++;
   return *pdwTemp;
}


//***************************************************************************
//
//  BYTE * GetDataElemPtr
//
//  DESCRIPTION:
//
//  Used to get the pointer to a particular data element.  Note that this is
//  usually used internally.
//
//  PARAMETERS:
//
//  pItem               Input.  Data item to use.
//  plDims              Input.  Pointer to array of dimension values.  Note
//                      that currenly only a single dimension is supported.
//  vtSimple            Input.  Variant type of the data with the VT_ARRAY
//                      and VT_BYREF bits cleared.
//
//  RETURN VALUE:
//

//  pointer to the data.
//***************************************************************************

BYTE * GetDataElemPtr(CBMOFDataItem * pItem, long * plDims, DWORD vtSimple)
{
   int iNumDim;
   DWORD dwTotalDataSize;
   BYTE * pEndOfData;
   UNALIGNED DWORD * pdwCurr;
   UNALIGNED DWORD * pdwCurrObj;
   BYTE * pRow;
   int iCnt;

   // first check the number of dimensions.

   iNumDim = GetNumDimensions(pItem);
   if(iNumDim == -1)
      return NULL;
   if(iNumDim == 0)           // simple case of scalar argument
      return pItem->m_pData;

   // for arrays, the data block starts off with this form,
   // dwtotalsize, dwNumDimenstions, dwMostSigDimension... dwLeastSigDimension
   // Since currently only 1 dimensional arrays are supported, a 5 element
   // array would start with
   // dwSize, 1, 5

   pdwCurr = (UNALIGNED DWORD *)pItem->m_pData;
   dwTotalDataSize = *pdwCurr;
   pEndOfData = pItem->m_pData + dwTotalDataSize;
   pdwCurr+= 2;      // skip to dimension list
   pdwCurr += iNumDim;  // skip of dimension sizes.

   while((BYTE *)pdwCurr < pEndOfData)
   {
      // Each row has the format
      // dwSizeOfRow, MostSigDimension ... dwLeastSignificentDimension+1,data
      // For a one dimensional array, it would just be
      // dwSizeOfRow, data


      DWORD dwRowSize = *pdwCurr;

      // test if this row is ok.  Each row of data will have
      // a set of Indicies for each higher dimension.

      for(iCnt = 0; iCnt < iNumDim-1; iCnt++)
      {
         UNALIGNED DWORD * pRowInd = pdwCurr +1 + iCnt;
         if((long)*pRowInd != plDims[iCnt])
            break;

      }
      if(iCnt >= iNumDim -1)
      {
         break;                  // found the row.
      }

      // go to the next row

      pdwCurr = (UNALIGNED DWORD *)((BYTE *)pdwCurr + dwRowSize);

   }

   if((BYTE *)pdwCurr >= pEndOfData)
      return NULL;

   pRow = (BYTE *)(pdwCurr + 1 + iNumDim -1);
   for(iCnt = 0; iCnt < plDims[iNumDim-1]; iCnt++)
   {
      if(vtSimple == VT_BSTR)
         pRow += 2*(wmi_unaligned_wcslen((WCHAR *)pRow)+1);
      else if(vtSimple == VT_EMBEDDED_OBJECT)
      {
         // Each embedded object starts off with its own size

         pdwCurrObj = (DWORD *)pRow;
         pRow += *pdwCurrObj;

      }
      else
         pRow += iTypeSize(vtSimple);
   }

   return pRow;

}


//***************************************************************************
//
//  int GetData
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//  pItem               Input.  Data item to use.
//  pRet                Input/Output.  Pointer to where the data is to be
//                      copied.  For simple data, such as ints, this can just
//                      be a pointer to an int.  For BSTRs, or embedded
//                      objects, this is treated as a pointer to a pointer
//                      and it is the responsibility of the caller to free
//                      the strings via BMOFFree().
//  plDims              Input.  Pointer to array of dimension values.  Note
//                      that currenly only a single dimension is supported.
//                      The first element in any dimension is 0.
//  RETURN VALUE:
//
//  Number of bytes of data.
//***************************************************************************

int GetData(CBMOFDataItem * pItem, BYTE * pRet, long * plDims)
{
   DWORD dwSimple;
   BYTE * pData;
   CBMOFObj * pObjRet = NULL;
   dwSimple = pItem->m_dwType &~ VT_ARRAY &~VT_BYREF;
   pData = GetDataElemPtr(pItem, plDims, dwSimple);
   if(pData == NULL)
      return 0;
   if(dwSimple == VT_BSTR)
   {

      // For strings, a new WCHAR buffer is returned.  Note that
      // SysAllocString isnt used so as to avoid any Ole dependencies.

      BYTE * pStr;
      DWORD dwSize = 2*(wmi_unaligned_wcslen((WCHAR *)pData)+1);

      pStr = BMOFAlloc(dwSize);
      if(pStr == NULL)
      		return 0;
      memcpy((void *)pRet, &pStr, sizeof(void *));
      wmi_unaligned_wcscpy((WCHAR *)pStr, (WCHAR *)pData);
      return dwSize;
   }
   else if(dwSimple == VT_EMBEDDED_OBJECT)
   {

      // This is the embedded object case.
      pObjRet = CreateObj((UNALIGNED WBEM_Object *)pData);
      memcpy((void *)pRet, &pObjRet, sizeof(void *));

      return sizeof(void *);
   }
   else
   {
      memcpy((void *)pRet, (void *)pData, iTypeSize(dwSimple));
      return iTypeSize(dwSimple);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\precomp.h ===
//
// Copyright (c) 1999-2002 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#include <strsafe.h>

#include <strutils.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\utillib\include\wbemtime.h ===
//***************************************************************************
//
//  Copyright  Microsoft Corporation.  All rights reserved.
//
//  wbemtime.h
//
//  Purpose: declares the WBEMTime and WBEMTimeSpan objects which are 
//  similar to the MFC CTime and CTimeSpan objects.  The WBEM versions
//  are capable of storing down to the nsec and also have functions for
//  Creating from and getting BSTRs.
//
//  Note; The current implementation of WBEMTime does not support dates 
//  before 1601;
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef WBEMTIME_HEADERFILE_IS_INCLUDED
#define WBEMTIME_HEADERFILE_IS_INCLUDED

#define INVALID_TIME 0xffffffffffffffff

#include <polarity.h>
#include <time.h>
#pragma warning( disable : 4290 ) // Ignore 'C++ Exception Specification ignored'
#include <ProvExce.h>

///////////////////////////////////////////////////////////////////////////
// WBEMTimeSpan - This class holds time span values. 

class POLARITY WBEMTimeSpan 
{
private:

    ULONGLONG m_Time;
    friend class WBEMTime;

public:

    WBEMTimeSpan ()                                             { m_Time = INVALID_TIME ; }
    WBEMTimeSpan ( const BSTR bstrDMTFFormat )                  { *this = bstrDMTFFormat ; }

    WBEMTimeSpan ( 

        int iDays , 
        int iHours , 
        int iMinutes ,  
        int iSeconds , 
        int iMSec=0 , 
        int iUSec=0, 
        int iNSec=0 
    ) ;

    WBEMTimeSpan operator+ (const WBEMTimeSpan &uAdd ) const ;
    const WBEMTimeSpan &operator+= ( const WBEMTimeSpan &uAdd ) ;

    WBEMTimeSpan operator- (const WBEMTimeSpan &uSub ) const ;
    const WBEMTimeSpan &operator-= ( const WBEMTimeSpan &uSub ) ;

    const WBEMTimeSpan &operator= ( const BSTR pDMTFFormat ) ; 

    BOOL operator== ( const WBEMTimeSpan &a ) const             { return m_Time == a.m_Time ; }
    BOOL operator!= ( const WBEMTimeSpan &a ) const             { return m_Time != a.m_Time ; }
    BOOL operator<  ( const WBEMTimeSpan &a ) const             { return m_Time < a.m_Time ; }
    BOOL operator<= ( const WBEMTimeSpan &a ) const             { return m_Time <= a.m_Time ; }
    BOOL operator>  ( const WBEMTimeSpan &a ) const             { return m_Time > a.m_Time ; }
    BOOL operator>= ( const WBEMTimeSpan &a ) const             { return m_Time >= a.m_Time ; }

    BSTR GetBSTR ( void ) const throw ( CHeap_Exception ) ;

    bool IsOk () const                                          { return m_Time != INVALID_TIME ? true : false; }
    ULONGLONG GetTime () const                                  { return m_Time ; }
    void Clear ( void )                                         { m_Time = INVALID_TIME ; }
    
    // These are all deprecated
    WBEMTimeSpan ( const FILETIME &ft ) ;
    WBEMTimeSpan ( const time_t & t ) ;
    const WBEMTimeSpan &operator= ( const FILETIME &ft ) ;
    const WBEMTimeSpan &operator= ( const time_t &t ) ;
    BOOL Gettime_t ( time_t *ptime_t ) const ;
    BOOL GetFILETIME ( FILETIME *pst ) const ;

};

///////////////////////////////////////////////////////////////////////////
// WBEMTime - This class holds time values. 

class POLARITY WBEMTime 
{
public:

    WBEMTime ()                                                 { m_uTime = INVALID_TIME ; }
    WBEMTime ( const BSTR bstrDMTFFormat )                      { *this = bstrDMTFFormat ; }
    WBEMTime ( const SYSTEMTIME &st )                           { *this = st ; }
    WBEMTime ( const FILETIME &ft )                             { *this = ft ; }
    WBEMTime ( const struct tm &tmin )                          { *this = tmin ; }
    WBEMTime ( const time_t &t )                                { *this = t ; }

    WBEMTime        operator+ ( const WBEMTimeSpan &uAdd ) const ;
    const WBEMTime &operator+=( const WBEMTimeSpan &ts ) ;

    WBEMTimeSpan    operator- ( const WBEMTime &sub ) ;

    WBEMTime        operator- ( const WBEMTimeSpan &sub ) const;
    const WBEMTime &operator-=( const WBEMTimeSpan &sub );

    const WBEMTime &operator= ( const BSTR bstrDMTFFormat ) ; 
    const WBEMTime &operator= ( const SYSTEMTIME &st ) ;
    const WBEMTime &operator= ( const FILETIME &ft ) ;
    const WBEMTime &operator= ( const struct tm &tmin ) ;
    const WBEMTime &operator= ( const time_t & t) ;

    BOOL operator== ( const WBEMTime &a ) const                 { return m_uTime == a.m_uTime ; }
    BOOL operator!= ( const WBEMTime &a ) const                 { return m_uTime != a.m_uTime ; }
    BOOL operator<  ( const WBEMTime &a ) const                 { return m_uTime < a.m_uTime ; }
    BOOL operator<= ( const WBEMTime &a ) const                 { return m_uTime <= a.m_uTime ; }
    BOOL operator>  ( const WBEMTime &a ) const                 { return m_uTime > a.m_uTime ; }
    BOOL operator>= ( const WBEMTime &a ) const                 { return m_uTime >= a.m_uTime ; }

    BSTR GetBSTR ( void ) const throw ( CHeap_Exception ) ;
    BOOL GetStructtm (struct tm *ptm ) const;
    BOOL Gettime_t ( time_t *ptime_t ) const;
    BOOL GetSYSTEMTIME ( SYSTEMTIME *pst ) const;
    BOOL GetFILETIME ( FILETIME *pst ) const;

    BOOL SetDMTF ( const BSTR wszText ) ;
    BSTR GetDMTF ( BOOL bLocal = FALSE ) const throw ( CHeap_Exception ) ;

    BSTR GetDMTFNonNtfs(void) const ;

    void Clear ( void )                                         { m_uTime = INVALID_TIME ; }

    bool IsOk () const                                          { return m_uTime != INVALID_TIME ? true : false; }
    ULONGLONG GetTime () const                                  { return m_uTime ; }

    static LONG WINAPI GetLocalOffsetForDate(const struct tm *tmin);
    static LONG WINAPI GetLocalOffsetForDate(const SYSTEMTIME *pst);
    static LONG WINAPI GetLocalOffsetForDate(const FILETIME *pft);
    static LONG WINAPI GetLocalOffsetForDate(const time_t &t);

private:
    ULONGLONG m_uTime;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\wdmshell.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#include "wmicom.h"
#include "wdmshell.h"
#include "wmimof.h"
#include "wmimap.h"
#include <stdlib.h>
#include <winerror.h>

//=============================================================================================================
//*************************************************************************************************************
//
//
//  CWMIStandardShell
//
//
//*************************************************************************************************************
//=============================================================================================================
CWMIStandardShell::CWMIStandardShell() 
{
	m_pClass = NULL;
	m_pWDM = NULL;
	m_fInit = FALSE;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWMIStandardShell::~CWMIStandardShell()
{
	SAFE_DELETE_PTR(m_pWDM);
	SAFE_DELETE_PTR(m_pClass);
	m_fInit = FALSE;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::Initialize(WCHAR * wcsClass, BOOL fInternalEvent, CHandleMap * pList,
									  BOOL fUpdate, ULONG uDesiredAccess, 
									  IWbemServices   __RPC_FAR * pServices, 
									  IWbemServices   __RPC_FAR * pRepository, 
                                      IWbemObjectSink __RPC_FAR * pHandler, 
									  IWbemContext __RPC_FAR *pCtx)
{
    HRESULT hr = WBEM_E_FAILED;

	if( !m_fInit )
	{
		m_pClass = new CWMIProcessClass(0);
		if( m_pClass )
		{
			hr = m_pClass->Initialize();
			if( S_OK == hr )
			{
				m_pClass->WMI()->SetWMIPointers(pList,pServices,pRepository,pHandler,pCtx);
				m_pClass->SetHiPerf(FALSE);
				if( !fInternalEvent )
				{
					if( wcsClass )
					{
						hr = m_pClass->SetClass(wcsClass);
						if( SUCCEEDED(hr))
						{
							if( !m_pClass->ValidClass())
							{
								hr = WBEM_E_INVALID_OBJECT;
							}
						}
					}
				}
				else
				{
					if( wcsClass )
					{
						hr = m_pClass->SetClassName(wcsClass);
					}
				}

				if( hr == S_OK )
				{
					m_pWDM = new CProcessStandardDataBlock();
					if( m_pWDM )
					{
						m_pWDM->SetDesiredAccess(uDesiredAccess);
						m_pWDM->SetClassProcessPtr(m_pClass);
						m_pWDM->UpdateNamespace(fUpdate);

						m_fInit = TRUE;
					}
				}
			}
		}
	}
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::SetGuidForEvent( WORD wType, WCHAR * wcsGuid, int cchSize )
{
   HRESULT hRes = WBEM_E_FAILED;
   if( m_fInit )
   {
   
		// ==============================================
		// Inform the WMI we want to register for the
		// event
		// ==============================================
		memset(wcsGuid,NULL,cchSize);

		switch( wType ){
			case MOF_ADDED:
				hRes = S_OK;
				m_pClass->SetHardCodedGuidType(wType);
				hRes = StringCchCopyW ( wcsGuid, cchSize, WMI_RESOURCE_MOF_ADDED_GUID );
				break;

			case MOF_DELETED:
				hRes = S_OK;
				m_pClass->SetHardCodedGuidType(wType);
				hRes = StringCchCopyW ( wcsGuid, cchSize, WMI_RESOURCE_MOF_REMOVED_GUID );
				break;

			case STANDARD_EVENT:
				hRes = m_pClass->GetQualifierString( NULL, L"guid", wcsGuid, cchSize );
				break;
		}
   }
    return hRes;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::ProcessSingleInstance( WCHAR * wcsInstanceName/*, PWNODE_SINGLE_INSTANCE pwSingle */)
{
   HRESULT hr = WBEM_E_FAILED;
   if( m_fInit )
   {

		//======================================================
		//  If we are not working with a specific guy, then
		//  query WMI to get it, if, of course it is valid
		//======================================================
		if( m_pClass->ValidClass() ){

	/*        if( pwSingle){
				hr = m_pWDM->SetSingleInstancePtr((PWNODE_SINGLE_INSTANCE)pwSingle);
			}
			else{*/
				hr = m_pWDM->OpenWMI();
				if( hr == S_OK ){
    				hr = m_pWDM->QuerySingleInstance(wcsInstanceName);
				}
	//        }
			//======================================================
			//  If we got the data and a valid class, the process it
			//======================================================
   			if( hr == S_OK )
			{
				hr = m_pWDM->ReadWMIDataBlockAndPutIntoWbemInstance();
				if( SUCCEEDED(hr))
				{
					hr = m_pClass->SendInstanceBack();
				}
			}
		}
   }
   return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::ProcessAllInstances( )
{
    HRESULT hr = WBEM_E_FAILED;
    if( m_fInit )
    {

		//======================================================
		//  If we are not working with a specific guy, then
		//  query WMI to get it
		//======================================================
	 //   if( pwAllNode ){
	  //      hr = m_pWDM->SetAllInstancePtr((PWNODE_ALL_DATA)pwAllNode);
	  //  }
	   // else{
			hr = m_pWDM->OpenWMI();
			if( hr == S_OK ){
    			hr = m_pWDM->QueryAllData();
			}
	   // }
		//======================================================
		//  If we got the data then process it
		//======================================================
		if( hr == S_OK ){
			while( TRUE ){
				hr = m_pWDM->ReadWMIDataBlockAndPutIntoWbemInstance();
				if( hr == S_OK ){
					hr = m_pClass->SendInstanceBack();
				}
				if( hr != S_OK ){
					break;
				}
				if( !m_pWDM->MoreToProcess() ){
					break;
				}
			}
		}
	}
    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::ExecuteMethod( WCHAR * wcsInstance,  WCHAR * MethodName,  IWbemClassObject * pParentClass, 
  							      IWbemClassObject * pInClassData, 
							      IWbemClassObject * pInClass, 
							      IWbemClassObject * pOutClass) 
{
	HRESULT hr = WBEM_E_FAILED;
    if( m_fInit )
    {
		CWMIProcessClass  MethodInput(0);
		CWMIProcessClass  MethodOutput(0);

		if( SUCCEEDED( MethodInput.Initialize() ) && SUCCEEDED( MethodOutput.Initialize() ) )
		{
			MethodInput.SetWMIPointers(m_pClass);
			MethodOutput.SetWMIPointers(m_pClass);


			//======================================================
			//  Initialize all of the necessary stuff and get the
			//  definition of the class we are working with
			//======================================================
			if( pInClass )
			{
				hr = MethodInput.SetClass(pInClass);
				if( hr != S_OK ){
					return hr;
				}
				MethodInput.SetClassPointerOnly(pInClassData);
			}

			if( pOutClass ){
  				hr = MethodOutput.SetClass(pOutClass, MethodInput.GetNumberOfProperties () );
				if( hr != S_OK ){
					return hr;
				}
			}

		   //======================================================
			//  Notify WMI which class we are going to be executing
			//  methods on
			//======================================================
			hr = m_pWDM->OpenWMI();
			if( hr == S_OK ){

				m_pWDM->SetMethodInput(&MethodInput);
				m_pWDM->SetMethodOutput(&MethodOutput);

				m_pClass->SetClassPointerOnly(pParentClass);

				// Create in Param Block
				// ========================
				BYTE * InputBuffer=NULL;
				ULONG uInputBufferSize=0L;

				hr = m_pWDM->CreateInParameterBlockForMethods(InputBuffer,uInputBufferSize);
				if( hr == S_OK ){
				
					// Allocate Out Param Block
					// ========================
    
					ULONG WMIMethodId = m_pClass->GetMethodId(MethodName);

					//======================================================
					//  If we got the data then process it
					//======================================================
    
					hr = m_pWDM->CreateOutParameterBlockForMethods();
					if( hr == S_OK ){
						hr = m_pWDM->ExecuteMethod( WMIMethodId,wcsInstance, uInputBufferSize,InputBuffer);
					}
				}

				SAFE_DELETE_ARRAY(InputBuffer);
			}
		}
	}
    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::ProcessEvent( WORD wBinaryMofType, PWNODE_HEADER WnodeHeader)
{

   HRESULT hr = S_OK;
   if( m_fInit )
   {

		//===================================================
		//  If the image path is empty, it is a binary guid
		//  which we need to process
		//===================================================
		if( wBinaryMofType ){
			hr = ProcessBinaryGuidsViaEvent( WnodeHeader, wBinaryMofType );
		}
		else{
			//=======================================================
			//  Process the data event
			//=======================================================
			if( WnodeHeader->Flags & WNODE_FLAG_ALL_DATA ){
				hr = m_pWDM->SetAllInstancePtr((PWNODE_ALL_DATA)WnodeHeader);
			}
			else if( WnodeHeader->Flags & WNODE_FLAG_SINGLE_INSTANCE ){
				hr = m_pWDM->SetSingleInstancePtr((PWNODE_SINGLE_INSTANCE)WnodeHeader);
			}
			if( hr == S_OK ){	
        
				//===================================================================
				//  Process all wnodes.
				//===================================================================
				while( TRUE ){

					if( S_OK == ( hr = m_pWDM->ReadWMIDataBlockAndPutIntoWbemInstance()) ){
						//===========================================================
						//  Now, send it to all consumers registered for this event
						//===========================================================
						hr = m_pClass->SendInstanceBack();
					}  
					//===============================================================
					//  If we errored out,we don't know that any of the pointers
					//  are ok, so get out of there.
					//===============================================================
					else{
						break;
					}

					//===============================================================
					//  Process all of the instances for this event
					//===============================================================
					if( !m_pWDM->MoreToProcess() ){
	    				break;
					}
				}
			}
		}
		//============================================================================
		// Since we never allocated anything, just used the incoming stuff,
		// for cleanliness sake, init ptrs to null
		//============================================================================
		m_pWDM->InitDataBufferToNull();
   }
   return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::FillInAndSubmitWMIDataBlob( IWbemClassObject * pIClass, int nTypeOfPut, CVARIANT & vList)
{
   HRESULT hr = WBEM_E_FAILED;
   if( m_fInit )
   {

		hr = m_pWDM->OpenWMI();
		if( hr == S_OK ){
			//  Now, work with the class we want to write
			if( SUCCEEDED(m_pClass->SetClassPointerOnly(pIClass))){
    
				if( nTypeOfPut == PUT_WHOLE_INSTANCE ){
					hr = m_pWDM->ConstructDataBlock(TRUE) ;
	 				if( S_OK == hr ){
						hr = m_pWDM->SetSingleInstance();
					}
				}
				else{
					if(m_pWDM->GetListOfPropertiesToPut(nTypeOfPut,vList)){
						hr = m_pWDM->PutSingleProperties();
					}
					else{
						hr =  WBEM_E_INVALID_CONTEXT;
					}
				}
			}
		}
   }
   return(hr);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::QueryAndProcessAllBinaryGuidInstances(CNamespaceManagement & Namespace, BOOL & fMofHasChanged,
																 KeyList * pArrDriversInRegistry)
{
	HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
		CAutoWChar wcsTmpKey(MAX_PATH*3);
		if( wcsTmpKey.Valid() )
		{
			m_pClass->SetHardCodedGuidType(MOF_ADDED);
			m_pClass->GetGuid();
			hr = m_pWDM->OpenWMI();
			if( hr == S_OK )
			{
    			hr = m_pWDM->QueryAllData();
				//======================================================
				//  If we got the data then process it
				//======================================================
				if( hr == S_OK )
				{
					while( SUCCEEDED ( hr ) )
					{
						hr = m_pWDM->ProcessNameBlock(FALSE);
						if( hr == S_OK )
						{
 							hr = m_pWDM->ProcessBinaryMofDataBlock(CVARIANT(m_pClass->GetClassName()),wcsTmpKey, MAX_PATH*3);
							if( hr == S_OK )
							{
	       						hr = Namespace.UpdateQuery(L" and Name != ",wcsTmpKey);

								if( pArrDriversInRegistry )
								{
									pArrDriversInRegistry->Remove(wcsTmpKey);
								}
							}

							if( !m_pWDM->MoreToProcess() )
							{
								break;
							}
						}
					}
				}
			}
		}
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIStandardShell::ProcessBinaryGuidsViaEvent( PWNODE_HEADER WnodeHeader, WORD wType )
{
   HRESULT hr = WBEM_E_FAILED;
   if( m_fInit )
   {
		//======================================================
		//  Initialize all of the necessary stuff and get the
		//  definition of the class we are working with
		//======================================================
		m_pClass->SetHardCodedGuidType(wType);
		//==================================================================
		//  We are working with a specific guy, so we need to find out
		//  if it is a Binary Mof Guid to do a query all data on, or
		//  if it is a Resource Name and File to open up and extract
		//==================================================================
		if( WnodeHeader->Flags & WNODE_FLAG_ALL_DATA )
		{
			hr = m_pWDM->SetAllInstancePtr((PWNODE_ALL_DATA)WnodeHeader);
			if(hr == S_OK)
			{
				hr = m_pWDM->ReadWMIDataBlockAndPutIntoWbemInstance();
			}
		}
		else if( WnodeHeader->Flags & WNODE_FLAG_SINGLE_INSTANCE )
		{
			hr = m_pWDM->SetSingleInstancePtr((PWNODE_SINGLE_INSTANCE)WnodeHeader);
			if( hr == S_OK )
			{
				hr = m_pWDM->ProcessDataBlock();
			}
		}
		else
		{
			hr = WBEM_E_INVALID_PARAMETER;
		}
   }
   return hr;
}

//************************************************************************************************************
//============================================================================================================
//
//   CWMIHiPerfShell
//
//============================================================================================================
//************************************************************************************************************

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWMIHiPerfShell::CWMIHiPerfShell(BOOL fAutoCleanup)
{
    m_fAutoCleanup = fAutoCleanup;
	m_pWDM = NULL;
    m_pClass = NULL;
	m_fInit = FALSE;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::Initialize	(
										BOOL fUpdate,
										ULONG uDesiredAccess,
										CHandleMap * pList,WCHAR * wcs,
										IWbemServices   __RPC_FAR * pServices, 
										IWbemServices   __RPC_FAR * pRepository, 
										IWbemObjectSink __RPC_FAR * pHandler,
										IWbemContext __RPC_FAR *pCtx
									) 
{
    HRESULT hr = WBEM_E_FAILED;

    m_pClass = new CWMIProcessClass(0);
    if( m_pClass )
    {
		hr = m_pClass->Initialize();
		if( S_OK == hr )
		{
			m_pClass->WMI()->SetWMIPointers(pList,pServices,pRepository,pHandler,pCtx);
			m_pClass->SetHiPerf(TRUE);
			m_pClass->SetClass(wcs);

			m_pWDM = new CProcessHiPerfDataBlock;
			if( m_pWDM )
			{
				m_pWDM->SetDesiredAccess(uDesiredAccess);
				m_pWDM->UpdateNamespace(fUpdate);
				m_pWDM->SetClassProcessPtr(m_pClass);
				m_fInit = TRUE;
			}
			hr = S_OK;
		}
    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWMIHiPerfShell::~CWMIHiPerfShell() 
{
    if( m_fAutoCleanup )
    {
        SAFE_DELETE_PTR(m_pClass);
    }
	SAFE_DELETE_PTR(m_pWDM);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::QueryAllHiPerfData()
{
	HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		//===============================================================
		//  There is only one handle for this class, so see if we can
		//  get it
		//===============================================================
		CAutoBlock(m_pHiPerfMap->GetCriticalSection());

		HANDLE WMIHandle = 0;

		hr = m_pWDM->GetWMIHandle(WMIHandle);
		if( SUCCEEDED(hr))
		{
			// =====================================================
			//  Query for all of the objects for this class
			//  Add all the objects at once into the enumerator
			//  Handles are guaranteed to be open at this time
			//======================================================
			hr = QueryAllInstances(WMIHandle,NULL);
		}
	}
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::RefreshCompleteList()
{
    //=======================================================================
    // Go through all the enumerators and instances to refresh everything
    //=======================================================================
    HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		CAutoBlock(m_pHiPerfMap->GetCriticalSection());
		HANDLE WMIHandle = 0;
		IWbemHiPerfEnum * pEnum = NULL;
		CWMIProcessClass * pSavedClass = m_pClass;

		//==============================================================
		// 
		//==============================================================
		hr = m_pHiPerfMap->GetFirstHandle( WMIHandle, m_pClass, pEnum);
		while( hr == S_OK )
		{
			if( WMIHandle )
			{
				m_pWDM->SetClassProcessPtr(m_pClass);
				if( pEnum )
				{
					hr = QueryAllInstances(WMIHandle,pEnum);
				}
				else
				{
					hr = QuerySingleInstance(WMIHandle);
				}

				if(SUCCEEDED(hr))
				{
					hr = m_pHiPerfMap->GetNextHandle(WMIHandle,m_pClass,pEnum);
				}
			}
			if( hr == WBEM_S_NO_MORE_DATA )
			{
				hr = S_OK;
				break;
			}
		}

		//================================================================
		m_pClass = pSavedClass;
	}
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::HiPerfQuerySingleInstance(WCHAR * wcsInstance)
{
    HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		//======================================================
		//  Go through the list of handles and get the handles
		//  to send and how many there are, also, get the 
		//  instance names
		//======================================================
		CAutoBlock(m_pHiPerfMap->GetCriticalSection());

		IWbemObjectAccess * pAccess  = NULL;
		CWMIProcessClass * pClass = NULL;

		HANDLE WMIHandle = 0;
		ULONG_PTR lTmp = (ULONG_PTR)pAccess;

		hr = m_pHiPerfMap->FindHandleAndGetClassPtr(WMIHandle,lTmp, pClass);
		if( SUCCEEDED(hr))
		{
			hr = QuerySingleInstance(WMIHandle);
		}
	}
    return hr;
}	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::AddAccessObjectToRefresher(IWbemObjectAccess *pAccess,
                                                    IWbemObjectAccess ** ppRefreshable,
                                                    ULONG_PTR *plId)
{
    HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		//======================================================
		//  Get the definition of the class we are working with
		//======================================================
		hr = m_pClass->SetAccess(pAccess);
		if( SUCCEEDED(hr))
		{
			CAutoBlock(m_pHiPerfMap->GetCriticalSection());

			HANDLE WMIHandle = 0;
			CLSID Guid;

			hr = m_pWDM->GetWMIHandle(WMIHandle);
			if( SUCCEEDED(hr))
			{
				// =======================================================
				// We have the WMI Handle, now add it to the hi perf map
				// for this refresher
   				// =======================================================
				if( m_pClass->GetANewAccessInstance() )
				{
					//====================================================
					//  Set the flag so we don't get a new instance for
					//  this anymore
					//====================================================
					m_pClass->GetNewInstance(FALSE);
					hr = m_pClass->SetKeyFromAccessPointer();
					if( SUCCEEDED(hr))
					{
						*ppRefreshable = m_pClass->GetAccessInstancePtr();
						*plId = (ULONG_PTR)(*ppRefreshable);

						hr = m_pHiPerfMap->Add(WMIHandle, *plId, m_pClass, NULL );
					}
				}
			}
		}
	}
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::AddEnumeratorObjectToRefresher(IWbemHiPerfEnum* pHiPerfEnum, ULONG_PTR *plId)
{
	HRESULT hr = WBEM_E_FAILED;

	if( m_fInit )
	{
		//===============================================================
		//  There is only one handle for this class, so see if we can
		//  get it
		//===============================================================
		HANDLE WMIHandle = 0;
		CLSID Guid;
		CAutoBlock(m_pHiPerfMap->GetCriticalSection());

		hr = m_pWDM->GetWMIHandle(WMIHandle);
		if( SUCCEEDED(hr))
		{
			*plId = (ULONG_PTR)pHiPerfEnum;
			hr = m_pHiPerfMap->Add(WMIHandle, *plId, m_pClass,pHiPerfEnum);
		}
	}
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::RemoveObjectFromHandleMap(ULONG_PTR lHiPerfId)
{
	HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		HANDLE hHandle = 0;
		CHandleMap *pHandleMap = m_pClass->WMI()->HandleMap();
		CAutoBlock(m_pHiPerfMap->GetCriticalSection());

		//==============================================================
		// First, delete the object from the map
		//==============================================================
		hr = m_pHiPerfMap->Delete( hHandle, lHiPerfId );
		if( SUCCEEDED(hr))
		{
			//==========================================================
			//  If we got a handle back, then we know it is an access
			//  instance and we need to release the WMI Handle
			//==========================================================
			if( hHandle ){
				hr = pHandleMap->ReleaseHandle(hHandle);        
			}
		}
	}
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  PRIVATE
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::QueryAllInstances(HANDLE WMIHandle,IWbemHiPerfEnum* pHiPerfEnum)
{
	HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		long	lCount = 0;
		HandleList ids;
		//==================================================
		//  Collect all of the WDM Handles to query all at
		//  once.
		//==================================================
		// 170635
		if(SUCCEEDED(hr = ids.Add(WMIHandle)))
		{
			// =====================================================
			//  Query for all of the objects for this class
			//  Add all the objects at once into the enumerator
			//  Handles are guaranteed to be open at this time
			//======================================================
			HANDLE * pHandles = (HANDLE*)*(ids.List());
			hr = m_pWDM->HiPerfQueryAllData(pHandles,ids.Size());
			//======================================================
			//  If we got the data then process it
			//======================================================
			if( SUCCEEDED(hr))
			{
			
				//======================================================
				//  Get the list of ptrs
				//======================================================
				AccessList AccessList;
				while( TRUE )
				{
					hr = m_pWDM->ReadWMIDataBlockAndPutIntoWbemInstance();
					if( hr == S_OK )
					{
						IWbemObjectAccess * p = m_pClass->GetAccessInstancePtr();
						if(SUCCEEDED(hr = AccessList.Add(p)))
						{
							lCount++;
						}
					}
					if( hr != S_OK )
					{
						break;
					}
					if( !m_pWDM->MoreToProcess() )
					{
						break;
					}
					if( !pHiPerfEnum )
					{
						m_pClass->SendInstanceBack();
					}
				}

				//======================================================
				//  Now, once we have collected them, send them off
				//  if asked to
				//======================================================
				if( pHiPerfEnum )
				{
					if( lCount > 0 )
					{
						long * pLong = new long[lCount];
						if(pLong)
						{
							for(long l = 0; l < lCount; l++)
							{
								pLong[l] = l;
							}

							IWbemObjectAccess ** pAccess = (IWbemObjectAccess**)AccessList.List();
							// Remove all the objects in the enumerator before adding the object
							pHiPerfEnum->RemoveAll(0);
							hr = pHiPerfEnum->AddObjects( 0L, AccessList.Size(), pLong, pAccess);
							SAFE_DELETE_ARRAY(pLong);
						}
						else
						{
							hr = E_OUTOFMEMORY;
						}
					}
				}
			}						
		}
	}
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIHiPerfShell::QuerySingleInstance(HANDLE WMIHandle)
{
    HRESULT hr = WBEM_E_FAILED;
	if( m_fInit )
	{
		CVARIANT varName;

		hr = m_pClass->GetKeyFromAccessPointer((CVARIANT *)&varName);
		if(SUCCEEDED(hr))
		{
			WCHAR * p = varName.GetStr();
			if(p)
			{
				hr = m_pWDM->HiPerfQuerySingleInstance(&WMIHandle, &p, 1,1);
				//======================================================
				//  If we got the data, process it
				//======================================================
				if( SUCCEEDED(hr))
				{
					hr = m_pWDM->ReadWMIDataBlockAndPutIntoWbemInstance();
//					if( hr == S_OK )
//					{
//					   m_pClass->SendInstanceBack();
//					}
				}                
			}
			else
			{
				hr = WBEM_E_FAILED;
			}
		}
	}
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\wdmshell.h ===
//***************************************************************************
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#ifndef _WDMSHELL_HEADER
#define _WDMSHELL_HEADER
#include "wmicom.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CWMIStandardShell 
{

    private:

        CWMIProcessClass          * m_pClass;
        CProcessStandardDataBlock * m_pWDM;
		BOOL					  m_fInit;

 
    public:
        CWMIStandardShell();
        ~CWMIStandardShell();      


		HRESULT Initialize	(
								WCHAR * wcsClass,
								BOOL fInternalEvent,
								CHandleMap * pList,
								BOOL fUpdateNamespace,
								ULONG uDesiredAccess,
								IWbemServices   __RPC_FAR * pServices, 
								IWbemServices   __RPC_FAR * pRepository, 
								IWbemObjectSink __RPC_FAR * pHandler,
								IWbemContext __RPC_FAR *pCtx
							);

		inline BOOL HasMofChanged()	{ return m_pWDM->HasMofChanged(); }

        //=============================================
        //  Process All and Single WMI Instances
        //=============================================
        HRESULT ProcessAllInstances();

        HRESULT ProcessSingleInstance( WCHAR * wcsInstanceName);
        //==========================================================
        //  The put instance group
        //==========================================================
        HRESULT FillInAndSubmitWMIDataBlob( IWbemClassObject * pIClass, int nTypeOfPut, CVARIANT & vList);
        	
        //=============================================
        // Event functions
        //=============================================
        HRESULT ProcessEvent(WORD wBinaryMofType, PWNODE_HEADER WnodeHeader);
        inline HRESULT  RegisterWMIEvent( WCHAR * wcsGuid, ULONG_PTR uContext, CLSID & Guid, BOOL fRegistered)
                                         { return m_pWDM->RegisterWMIEvent(wcsGuid,uContext,Guid,fRegistered);}
                                                                 

	
        //=============================================
        // method functions
        //=============================================
        HRESULT ExecuteMethod( WCHAR * wcsInstance,
                               WCHAR * MethodInstanceName,
                               IWbemClassObject * pParentClass, 
    					       IWbemClassObject * pInClassData, 
							   IWbemClassObject * pInClass, 
							   IWbemClassObject * pOutClass ) ;
        //=============================================
        // data processing functions
        //=============================================
        HRESULT GetGuid(WCHAR * pwcsGuid);

        HRESULT SetGuidForEvent( WORD wType,WCHAR * wcsGuid, int cchSize );
        HRESULT RegisterForWMIEvents( ULONG uContext, WCHAR * wcsGuid, BOOL fRegistered,CLSID & Guid );
        inline BOOL CancelWMIEventRegistration( GUID gGuid , ULONG_PTR uContext ) { return m_pClass->WMI()->CancelWMIEventRegistration(gGuid,uContext);}

        //=============================================
        //  The binary mof groupg
        //=============================================
        HRESULT ProcessBinaryGuidsViaEvent( PWNODE_HEADER WnodeHeader,WORD wType );
        HRESULT QueryAndProcessAllBinaryGuidInstances(CNamespaceManagement & Namespace, BOOL & fMofHasChanged, KeyList * pArrDriversInRegistry);
		//=============================================
        //  Misc
        //=============================================
        inline CLSID * GuidPtr()                  { return m_pClass->GuidPtr();}
        inline HRESULT SetErrorMessage(HRESULT hr){ return m_pClass->WMI()->SetErrorMessage(hr,m_pClass->GetClassName(),m_pWDM->GetMessage());}

};

//************************************************************************************************************
//============================================================================================================
//
//   The Hi Performance Shell
//
//============================================================================================================
//************************************************************************************************************

class CWMIHiPerfShell 
{
    private:

        CHiPerfHandleMap        * m_pHiPerfMap;
        CProcessHiPerfDataBlock * m_pWDM;
        CWMIProcessClass        * m_pClass;
        BOOL                      m_fAutoCleanup;
		BOOL					  m_fInit;

        HRESULT QueryAllInstances(HANDLE WMIHandle,IWbemHiPerfEnum* pHiPerfEnum);
        HRESULT QuerySingleInstance(HANDLE WMIHandle);

        

    public:

        CWMIHiPerfShell(BOOL fAuto);
        ~CWMIHiPerfShell();

		HRESULT Initialize	(
								BOOL fUpdate,
								ULONG uDesiredAccess,
								CHandleMap * pList,
								WCHAR * wcs,
								IWbemServices   __RPC_FAR * pServices, 
								IWbemServices   __RPC_FAR * pRepository, 
								IWbemObjectSink __RPC_FAR * pHandler,
								IWbemContext __RPC_FAR *pCtx
							) ;
		

        inline void SetHiPerfHandleMap(CHiPerfHandleMap * p)    { m_pHiPerfMap = p; }
        inline CCriticalSection * GetCriticalSection()          { return m_pHiPerfMap->GetCriticalSection();}
        inline CHiPerfHandleMap * HiPerfHandleMap()             { return m_pHiPerfMap;}

        HRESULT QueryAllHiPerfData();
        HRESULT HiPerfQuerySingleInstance(WCHAR * wcsInstance);
        HRESULT AddAccessObjectToRefresher(IWbemObjectAccess *pAccess, IWbemObjectAccess ** ppRefreshable, ULONG_PTR * plId);
        HRESULT AddEnumeratorObjectToRefresher(IWbemHiPerfEnum* pHiPerfEnum, ULONG_PTR * plId);
        HRESULT RemoveObjectFromHandleMap(ULONG_PTR lHiPerfId);
        HRESULT RefreshCompleteList();

        inline HRESULT SetErrorMessage(HRESULT hr){ return m_pClass->WMI()->SetErrorMessage(hr,m_pClass->GetClassName(),m_pWDM->GetMessage());}


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\wmimap.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#include "precomp.h"
#include "wmicom.h"
#include "wmimap.h"
#include <stdlib.h>
#include <CWbemTime.h>

/*
These are the types we support
	CIM_SINT8	= 16,
	CIM_UINT8	= 17,
	CIM_SINT16	= 2,
	CIM_UINT16	= 18,
	CIM_SINT32	= 3,
	CIM_UINT32	= 19,
	CIM_SINT64	= 20,
	CIM_UINT64	= 21,
	CIM_REAL32	= 4,
	CIM_REAL64	= 5,
	CIM_BOOLEAN	= 11,
	CIM_STRING	= 8,
	CIM_DATETIME	= 101,
	CIM_REFERENCE	= 102,
	CIM_CHAR16	= 103,
	CIM_OBJECT	= 13,
	CIM_FLAG_ARRAY	= 0x2000
*/
BOOL ValidateDateTime(WCHAR * wcsValue)
{
	BOOL fRc = FALSE;
    // Pre-test
    // ========
    	
    WCHAR * psz = wcsValue;
    if( psz )
    {
        if(wcslen(psz) == 25){

	        if(psz[14] != L'.' && psz[14] != L'*'){
			    goto ExitValidateTime;
		    }

		    if(psz[21] != L':' && psz[21] != L'-' && psz[21] != L'+' && psz[21] != L'*'){
			    goto ExitValidateTime;
		    }

	        for(int i = 0; i < 25; i++){
			    if(i == 21 || i == 14)
				    continue;
			    if(psz[i] != L'*' && !wbem_iswdigit(psz[i])){
				    goto ExitValidateTime;
                }

	        }

		    // Passed pre-test. Check if any stars were specified
		    // ==================================================

			if(wcschr(psz, L'*')) {
			    // No further checking
			    fRc = TRUE;
			    goto ExitValidateTime;
		    }

		    if(psz[21] == L':'){
            // Interval -- no checking
			    fRc = TRUE;
			    goto ExitValidateTime;
	        }

		    WCHAR wcsTmp[SIZEOFWBEMDATETIME+2];
		    StringCchCopyW(wcsTmp,SIZEOFWBEMDATETIME+2,wcsValue);

		    CWbemTime Time;
		    fRc = Time.SetDMTF(wcsTmp);

	    }
    }

ExitValidateTime:
    return fRc;
}

//=============================================================
BOOL CWMIDataTypeMap::ConvertDWORDToWMIDataTypeAndWriteItToBlock(DWORD dwLong, int nSize )
{
    BOOL fRc = FALSE;
    if( NaturallyAlignData( nSize, WRITE_IT)){
        if( nSize == sizeof(BYTE) ){
            m_pWMIBlockInfo->SetByte((BYTE)dwLong);
        }
        else if( nSize == sizeof(short)){
            m_pWMIBlockInfo->SetWord((WORD)dwLong);
        }
        else{
            m_pWMIBlockInfo->SetDWORD(dwLong);
        }
        fRc = TRUE;
    }
    return fRc;
}

//=============================================================
DWORD CWMIDataTypeMap::ConvertWMIDataTypeToDWORD(int nSize)
{
    DWORD dwLong = 0L;

    if( nSize == sizeof(BYTE) ){
        BYTE bByte;
        m_pWMIBlockInfo->GetByte(bByte);
        dwLong = (DWORD) bByte;
    }
    else if( nSize == sizeof(short)){
        WORD nInt;
        m_pWMIBlockInfo->GetWord(nInt);
        dwLong = (DWORD) nInt;
    }
    else{
        m_pWMIBlockInfo->GetDWORD(dwLong);
    }
    return dwLong;
}
//=============================================================
BOOL CWMIDataTypeMap::SetDefaultMissingQualifierValue( CVARIANT & v, long lType, CVARIANT & vToSet )
{ 
    BOOL fRc = TRUE;
	switch (lType){

	//	CIM_SINT16	= 2,
	//  CIM_CHAR16
		case CIM_CHAR16:
			break;

		//	CIM_SINT8	= 16,
		case VT_I1:
		case VT_I2:		
            vToSet.Clear();
            vToSet.SetShort(v.GetShort());
            break;
			
		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		//	CIM_UINT16	= 18,
		case VT_UI2:
		case VT_I4:	
		case VT_UI4:	
            vToSet.Clear();
            vToSet.SetLONG(v.GetLONG());
            break;

		//	CIM_REAL32	= 4,
		case VT_R4:		
		case VT_R8:		
            vToSet.Clear();
            vToSet.SetDouble(v.GetDouble());
			break;

		//	CIM_SINT64	= 20,
		//	CIM_UINT64	= 21,
		case VT_I8:	
		case VT_UI8:
            vToSet.Clear();
            vToSet.SetStr(v.GetStr());
			break;

		//	CIM_DATETIME	= 101,
		case CIM_DATETIME:
			break;

		//	CIM_STRING	= 8,
		//	CIM_REFERENCE	= 102,
		//	CIM_OBJECT	= 13,
		//	CIM_FLAG_ARRAY	= 0x2000
		case VT_BSTR:
			break;
			
		//	CIM_BOOLEAN	= 11,
		case VT_BOOL:
            vToSet.Clear();
            vToSet.SetBool(v.GetBool());
			break;

		//	CIM_UINT8	= 17,
		case VT_UI1:	
            vToSet.Clear();
            vToSet.SetByte(v.GetByte());
			break;

        default:
			fRc = FALSE;

	}

	return fRc;
}

//=============================================================
BOOL CWMIDataTypeMap::MissingQualifierValueMatches( CSAFEARRAY * pSafe, long i, CVARIANT & v, long lType, CVARIANT & vToCompare )
{ 
    BOOL fRc = FALSE;
	switch (lType){

	//	CIM_SINT16	= 2,
	//  CIM_CHAR16
		case CIM_CHAR16:
			break;

		//	CIM_SINT8	= 16,
		case VT_I1:
		case VT_I2:		
			{
				short v1 = 0;
                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &v1))
					{
                        return FALSE;
                    }
                }
				else
				{
					v1 = (short) v.GetShort();
				}

				short v2 = (short)vToCompare.GetShort();
				if( v1 == v2){
					fRc = TRUE;
				}
				break;
			}
			
		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		//	CIM_UINT16	= 18,
		case VT_UI2:
		case VT_I4:	
		case VT_UI4:	
			{
				long v1 = 0;
                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &v1))
					{
                        return FALSE;
                    }
                }
				else
				{
					v1 = (long)v.GetLONG();
				}
				long v2 = (long)vToCompare.GetLONG();
				if( v1 == v2){
					fRc = TRUE;
				}
				break;
			}
		//	CIM_REAL32	= 4,
		case VT_R4:		
		case VT_R8:		
			{
				double v1 = 0;
                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &v1))
					{
                        return FALSE;
                    }
                }
				else
				{
					v1 = (double)v.GetDouble();
				}
				double v2 = (double)vToCompare.GetDouble();
				if( v1 == v2 ){
					fRc = TRUE;
				}
				break;
			}

		//	CIM_SINT64	= 20,
		//	CIM_UINT64	= 21,
 
		case VT_UI8:
			{
			    unsigned __int64 I1 = 0L, I2 = 0L;
			
                CBSTR bstr2;
                CBSTR bstr1;

                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &bstr1))
					{
                        return FALSE;
                    }
                }
                else
				{	
                    bstr1.SetStr(v.GetStr());
                }
				bstr2.SetStr(vToCompare.GetStr());

            	if( bstr1 && bstr2)
				{
					I1 =(unsigned __int64) _wtoi64(bstr1);
					I2 =(unsigned __int64)_wtoi64(bstr2);
					if( I1 == I2 ){
						fRc = TRUE;
					}
				}

				break;
			}


		case VT_I8:	
			{
			    __int64 I1 = 0L, I2 = 0L;
			
                CBSTR bstr2;
                CBSTR bstr1;

                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &bstr1))
					{
                        return FALSE;
                    }
                }
                else
				{
                    bstr1.SetStr(v.GetStr());
                }
				bstr2.SetStr(vToCompare.GetStr());

            	if( bstr1 && bstr2)
				{
					I1 = _wtoi64(bstr1);
					I2 = _wtoi64(bstr2);
					if( I1 == I2 ){
						fRc = TRUE;
					}
				}

				break;
			}
		
		//	CIM_DATETIME	= 101,
		case CIM_DATETIME:
			break;

		//	CIM_STRING	= 8,
		//	CIM_REFERENCE	= 102,
		//	CIM_OBJECT	= 13,
		//	CIM_FLAG_ARRAY	= 0x2000
		case VT_BSTR:
			break;
			
		//	CIM_BOOLEAN	= 11,
		case VT_BOOL:
			{
				BOOL v1 = 0;
                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &v1))
					{
                        return FALSE;
                    }
                }
				else
				{
					v1 = (BOOL)v.GetBool();
				}

				BOOL v2 = (BOOL)vToCompare.GetBool();
				if( v1 == v2 )
				{
					fRc = TRUE;
				}
				break;
			}

		//	CIM_UINT8	= 17,
		case VT_UI1:	
			{
				BYTE v1 = 0;
                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &v1))
					{
                        return FALSE;
                    }
                }
				else
				{
					v1 = (BYTE) v.GetByte();
				}
				BYTE v2 = (BYTE)vToCompare.GetByte();
				if( v1 == v2){
					fRc = TRUE;
				}
				break;
			}

        default:
			fRc = FALSE;

	}

	return fRc;
}

//=============================================================
DWORD CWMIDataTypeMap::ArraySize(long lType,CVARIANT & var)
{
	DWORD dwCount = 0;
	switch( lType ){
		case VT_I2:	
		case VT_UI2:			
    		dwCount = (DWORD) var.GetShort();
            break;

        case VT_I4:																
        case VT_UI4:																
		case VT_R4:		
			dwCount = (DWORD) var.GetLONG();
			break;

        case VT_UI1:	
        case VT_I1:	
		    dwCount = (DWORD) var.GetByte();
            break;
	}
	return dwCount;
}
//=============================================================
BOOL CWMIDataTypeMap::SetDataInDataBlock(CSAFEARRAY * pSafe, int i, CVARIANT & v, long lType, int nSize)
{ 
    BOOL fRc = TRUE;
	switch (lType){

	//	CIM_SINT16	= 2,
	//  CIM_CHAR16
		case CIM_CHAR16:
		case VT_I2:		
			{
				SHORT iShort;
                if( pSafe ){
                    if( S_OK != pSafe->Get(i, &iShort)){
                        return FALSE;
                    }
                }
                else{
				    iShort = v.GetShort();
                }
                if( NaturallyAlignData( sizeof(WORD), WRITE_IT)){
                    m_pWMIBlockInfo->SetWord(iShort);
                }
				break;
			}

		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		//	CIM_UINT16	= 18,
		case VT_UI2:
		case VT_I4:	
		case VT_UI4:	
            {
                DWORD dwLong = 0L;
                if( pSafe ){
                    if( S_OK != pSafe->Get(i, &dwLong)){
                        return FALSE;
                    }
                }
                else{
			        dwLong = v.GetLONG();
                }
                ConvertDWORDToWMIDataTypeAndWriteItToBlock(dwLong,nSize);
		    	break;
            }

		//	CIM_REAL32	= 4,
		case VT_R4:		
			{
				float fFloat;
                if( pSafe ){
                    if( S_OK != pSafe->Get(i, &fFloat)){
                        return FALSE;
                    }
                }
                else{
				    fFloat =(float) v.GetDouble();
                }
                if( NaturallyAlignData( sizeof(WORD), WRITE_IT )){
                    m_pWMIBlockInfo->SetFloat(fFloat);
                }
				break;
			}

	//	CIM_REAL64	= 5,
		case VT_R8:		
			{
				DOUBLE dDouble;
                if( pSafe ){
                    if( S_OK != pSafe->Get(i, &dDouble)){
                        return FALSE;
                    }
                }
                else{
    				dDouble = v.GetDouble();
                }
                if( NaturallyAlignData( sizeof(DOUBLE),WRITE_IT)){
                    m_pWMIBlockInfo->SetDouble(dDouble);
                }
				break;
			}

		//	CIM_SINT64	= 20,
		case VT_I8:	
			{
				
				__int64 Int64 = 0L;
			
                CBSTR bstr;

                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &bstr))
					{
                        return FALSE;
                    }
                }
                else
				{
                    bstr.SetStr(v.GetStr());
                }
				if( bstr )
				{
					Int64 = _wtoi64(bstr);
				}						  

                if( NaturallyAlignData( sizeof(__int64), WRITE_IT ))
				{
                    m_pWMIBlockInfo->SetSInt64(Int64);

                }
				break;
			}
		//	CIM_UINT64	= 21,
		case VT_UI8:
			{
				unsigned __int64 Int64 = 0L;

                CBSTR bstr;

                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &bstr))
					{
                        return FALSE;
                    }
                }
                else
				{
                    bstr.SetStr(v.GetStr());
                }
				if( bstr )
				{
					Int64 = (unsigned __int64) _wtoi64(bstr);
				}
                if( NaturallyAlignData( sizeof(unsigned __int64),WRITE_IT))
				{
                    m_pWMIBlockInfo->SetUInt64(Int64);
                }
				break;
			}
	
		//	CIM_DATETIME	= 101,
		case CIM_DATETIME:
            {
			    WORD wCount=0;
                CBSTR bstr;
				WCHAR wDateTime[SIZEOFWBEMDATETIME+2];
				memset( wDateTime,NULL,SIZEOFWBEMDATETIME+2 );
                BOOL fContinue = TRUE;

                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &bstr))
					{
                        return FALSE;
                    }
                }
                else
				{
                    bstr.SetStr(v.GetStr());
                }

                //=========================================================
                //  Initialize buffer
                //=========================================================

				if( bstr != NULL )
				{
					if( ValidateDateTime(bstr))
					{
						StringCchCopyW(wDateTime, SIZEOFWBEMDATETIME+2, bstr);
			        }
                    else
					{
                        fContinue = FALSE;
                    }
				}
                else
				{
    				StringCchCopyW(wDateTime, SIZEOFWBEMDATETIME+2, L"00000000000000.000000:000");
                }

                if( fContinue )
				{
				    if( NaturallyAlignData( SIZEOFWBEMDATETIME, WRITE_IT))
					{
		                m_pWMIBlockInfo->SetString(wDateTime,SIZEOFWBEMDATETIME);
                    }
                }
				else
				{
					return FALSE ;
				}

			    break;
            }
		//	CIM_STRING	= 8,
		//	CIM_REFERENCE	= 102,
		//	CIM_OBJECT	= 13,
		//	CIM_FLAG_ARRAY	= 0x2000
		case VT_BSTR:
            {
			    WORD wCount=0;
                CBSTR bstr;
                if( pSafe )
				{
                    if( S_OK != pSafe->Get(i, &bstr))
					{
                        return FALSE;
                    }
                }
                else
				{
                    bstr.SetStr(v.GetStr());
                }

				if( bstr != NULL )
				{
					wCount = (wcslen(bstr))* sizeof(WCHAR);
				}

                if( NaturallyAlignData( sizeof ( WORD ), WRITE_IT ) )
				{
                    m_pWMIBlockInfo->SetWord(wCount);
                }

				if( bstr )
				{
	                if( S_OK != m_pWMIBlockInfo->GetBufferReady ( wCount ) )
					{
						return FALSE;
					}

				    m_pWMIBlockInfo->SetString(bstr,wCount);
					*m_pdwAccumulativeSizeOfBlock += wCount;
				}
			    break;
            }
		//	CIM_BOOLEAN	= 11,
		case VT_BOOL:	
			{
				BYTE bByte;

                if( pSafe ){
                    BOOL bTmp;
                    if( S_OK != pSafe->Get(i, &bTmp)){
                        return FALSE;
                    }
                    bByte = (BYTE) bTmp;
                }
                else{
    				bByte =(BYTE) v.GetBool();
                }

                if( NaturallyAlignData( sizeof(BYTE), WRITE_IT )){
                    m_pWMIBlockInfo->SetByte(bByte);
                }
				break;
			}

		//	CIM_UINT8	= 17,
		case VT_UI1:	
			{
			    BYTE bByte;
                if( pSafe ){
                    if( S_OK != pSafe->Get(i, &bByte)){
                        return FALSE;
                    }
                }
                else{
    				bByte = v.GetByte();
                }

                if( NaturallyAlignData( 1, WRITE_IT )){
                    m_pWMIBlockInfo->SetByte(bByte);
                }
				break;
			}

		//	CIM_SINT8	= 16,
		case VT_I1:
			{
				short tmpShort;

                if( pSafe ){
                    if( S_OK != pSafe->Get(i, &tmpShort)){
                        return FALSE;
                    }
                }
                else{
    				tmpShort = v.GetShort();
                }

                if( NaturallyAlignData( 1, WRITE_IT )){
					BYTE bByte = (signed char)tmpShort;
                    m_pWMIBlockInfo->SetByte(bByte);
                }
				break;
			}

        default:
			fRc = FALSE;

	}

	return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataTypeMap::GetDataFromDataBlock(IWbemObjectAccess * p, long lHandle, long lType, int nSize)
{
    HRESULT hr = S_OK;

	switch (lType){


		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		case VT_I4:	
		case VT_UI4:			
            if( NaturallyAlignData( nSize, READ_IT )){
                hr = p->WriteDWORD(lHandle,ConvertWMIDataTypeToDWORD(nSize));
            }
		    break;
            
   		case VT_I8:	
        case VT_UI8:	
            if( NaturallyAlignData( nSize, READ_IT ))
			{
                unsigned __int64 uInt64;
                m_pWMIBlockInfo->GetQWORD(uInt64);
        		hr = p->WriteQWORD(lHandle,uInt64);
            }
			break;


		//	CIM_UINT16	= 18,
		//	CIM_SINT16	= 2,
		//	CIM_CHAR16	= 103,
		case VT_I2:		
		case VT_UI2:
		case CIM_CHAR16:
            if( NaturallyAlignData( nSize,  READ_IT )){
                WORD wWord;
                m_pWMIBlockInfo->GetWord(wWord);
                // Read but don't assign to anything
            }
			break;

            
		//	CIM_REAL32	= 4,
		case VT_R4:		
            if( NaturallyAlignData( nSize, READ_IT)){
                float fFloat;
                m_pWMIBlockInfo->GetFloat(fFloat);
                // Read but don't assign to anything
            }
			break;

		//	CIM_REAL64	= 5,
		case VT_R8:		
            if( NaturallyAlignData( nSize,  READ_IT )){
                DOUBLE dDouble;
                m_pWMIBlockInfo->GetDouble(dDouble);
                // Read but don't assign to anything
            }
			break;

		//	CIM_DATETIME	= 101, which is 25 WCHARS
		case CIM_DATETIME:
            if( NaturallyAlignData( SIZEOFWBEMDATETIME,  READ_IT ))
			{
                WORD wSize = SIZEOFWBEMDATETIME + 2 ;
				WCHAR Buffer[SIZEOFWBEMDATETIME + 2] ;
				m_pWMIBlockInfo->GetString(Buffer,SIZEOFWBEMDATETIME,wSize);
                // Read but don't assign to anything
            }
    		break;
			
		//	CIM_REFERENCE	= 102,
		//	CIM_STRING	= 8,
        case VT_BSTR:	
            if( NaturallyAlignData( 2,  READ_IT )){
				WORD wCount=0;
				WCHAR * pBuffer=NULL;

				//  Get the size of the string
                m_pWMIBlockInfo->GetWord(wCount);
				if( wCount > 0 )
                {
			   	    if( m_pWMIBlockInfo->CurrentPtrOk((ULONG)(wCount)) )
                    {
                        WORD wSize = wCount + 2;
						pBuffer = new WCHAR[wSize];
                        if( pBuffer )
                        {
						    try
                            {
							    m_pWMIBlockInfo->GetString(pBuffer,wCount,wSize);
                                // Read but don't assign to anything
                                SAFE_DELETE_ARRAY(pBuffer);
							    *m_pdwAccumulativeSizeOfBlock += wCount;
                            }
                            catch(...)
                            {
                                hr = WBEM_E_UNEXPECTED;
                                SAFE_DELETE_ARRAY(pBuffer);
                                throw;
                            }
						}
                    
					}
                    else
                    {
                        hr = WBEM_E_INVALID_OBJECT;
                    }
				}
            }
			break;
			
		//	CIM_BOOLEAN	= 11,
		case VT_BOOL:	
            if( NaturallyAlignData( nSize,  READ_IT )){
				BYTE bByte=0;
                m_pWMIBlockInfo->GetByte(bByte);
                // Read but don't assign to anything
			}
			break;

		//	CIM_SINT8	= 16,
		//	CIM_UINT8	= 17,
		case VT_UI1:	
		case VT_I1:
            if( NaturallyAlignData( nSize,  READ_IT )){
				BYTE bByte=0;
	            m_pWMIBlockInfo->GetByte(bByte);
                // Read but don't assign to anything
            }
			break;

		default:
			return WBEM_E_INVALID_OBJECT;									

	}

	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataTypeMap::GetDataFromDataBlock(CVARIANT & v, long lType,  int nSize )
{ 
    HRESULT hr = WBEM_E_INVALID_OBJECT;

	switch (lType){

		//	CIM_SINT16	= 2,
		//	CIM_CHAR16	= 103,
		case VT_I2:		
		case CIM_CHAR16:
            if( NaturallyAlignData( nSize,  READ_IT )){
                hr = WBEM_S_NO_ERROR;
                WORD wWord;
                m_pWMIBlockInfo->GetWord(wWord);
			    v.SetShort(wWord);
            }
			break;

		//	CIM_SINT32	= 3,
		//	CIM_UINT16	= 18,
		//	CIM_UINT32	= 19,
		case VT_I4:	
		case VT_UI2:
		case VT_UI4:			
            if( NaturallyAlignData( nSize,  READ_IT )){
                hr = WBEM_S_NO_ERROR;
        		v.SetLONG(ConvertWMIDataTypeToDWORD(nSize));
            }
		    break;
            
		//	CIM_REAL32	= 4,
		case VT_R4:		
            if( NaturallyAlignData( nSize, READ_IT)){
                hr = WBEM_S_NO_ERROR;
                float fFloat;
                m_pWMIBlockInfo->GetFloat(fFloat);
		    	v.SetDouble(fFloat);
            }
			break;

		//	CIM_REAL64	= 5,
		case VT_R8:		
            if( NaturallyAlignData( nSize,  READ_IT )){
                hr = WBEM_S_NO_ERROR;
                DOUBLE dDouble;
                m_pWMIBlockInfo->GetDouble(dDouble);
		    	v.SetDouble(dDouble);
            }
			break;

		//	CIM_SINT64	= 20,
		case VT_I8:	
            if( NaturallyAlignData( nSize,  READ_IT )){
                hr = WBEM_S_NO_ERROR;
				WCHAR pwcsBuffer[256];
                memset(pwcsBuffer,NULL,256);
                if ( SUCCEEDED ( hr = m_pWMIBlockInfo->GetSInt64 ( pwcsBuffer, 256 ) ) )
				{
					v.SetStr(pwcsBuffer);
				}
            }
			break;

		//	CIM_UINT64	= 21,
		case VT_UI8:	
            if( NaturallyAlignData( nSize,  READ_IT )){
                hr = WBEM_S_NO_ERROR;
				WCHAR pwcsBuffer[256];
                memset(pwcsBuffer,NULL,256);
                if ( SUCCEEDED ( hr = m_pWMIBlockInfo->GetUInt64 ( pwcsBuffer, 256 ) ) )
				{
					v.SetStr(pwcsBuffer);
				}
            }
			break;
	
		//	CIM_DATETIME	= 101, which is 25 WCHARS
		case CIM_DATETIME:
    		v.SetStr(NULL);
            if( NaturallyAlignData( SIZEOFWBEMDATETIME,  READ_IT ))
			{
                hr = WBEM_S_NO_ERROR;

                WORD wSize = SIZEOFWBEMDATETIME + 2 ;
				WCHAR Buffer[SIZEOFWBEMDATETIME + 2] ;
				m_pWMIBlockInfo->GetString(Buffer,SIZEOFWBEMDATETIME,wSize);

                if( wbem_wcsicmp(Buffer,L"00000000000000.000000:000") != 0 ){
        		   	v.SetStr(Buffer);
                }
            }
    		break;
			
		//	CIM_REFERENCE	= 102,
		//	CIM_STRING	= 8,
        case VT_BSTR:	
    		v.SetStr(NULL);

            if( NaturallyAlignData( 2,  READ_IT )){
				WORD wCount=0;
				WCHAR * pBuffer=NULL;

				//  Get the size of the string
                m_pWMIBlockInfo->GetWord(wCount);

                hr = WBEM_S_NO_ERROR;
				if( wCount > 0 ){
			   	    if( m_pWMIBlockInfo->CurrentPtrOk((ULONG)(wCount)) ){
                        WORD wSize = wCount + 2;
						pBuffer = new WCHAR[wSize];
                        if( pBuffer )
                        {
						    try
                            {
							    m_pWMIBlockInfo->GetString(pBuffer,wCount,wSize);
    						    v.SetStr(pBuffer);
                                SAFE_DELETE_ARRAY(pBuffer);
							    *m_pdwAccumulativeSizeOfBlock += wCount;
						    }
                            catch(...)
                            {
                                hr = WBEM_E_UNEXPECTED;
                                SAFE_DELETE_ARRAY(pBuffer);
                                throw;
                            }
                        }
					}
                    else{
                        hr = WBEM_E_INVALID_OBJECT;
                    }
				}
				else{
					v.SetStr(NULL);
				}
            }
			break;
			
		//	CIM_BOOLEAN	= 11,
		case VT_BOOL:	
            if( NaturallyAlignData( nSize,  READ_IT )){
                hr = WBEM_S_NO_ERROR;
				BYTE bByte=0;
                m_pWMIBlockInfo->GetByte(bByte);
				v.SetBool((BOOL)bByte);
			}
			break;

		//	CIM_SINT8	= 16,
		//	CIM_UINT8	= 17,
		case VT_UI1:	
		case VT_I1:
            if( NaturallyAlignData( nSize,  READ_IT )){
                hr = WBEM_S_NO_ERROR;
				BYTE bByte=0;
	            m_pWMIBlockInfo->GetByte(bByte);

				if( lType == VT_I1 ){
					v.SetShort((signed char)bByte);
				}
				else{
					v.SetByte(bByte);
				}
            }
			break;

		default:
			return WBEM_E_INVALID_OBJECT;									

	}

	return hr;
}
//////////////////////////////////////////////////////////////////////
int CWMIDataTypeMap::GetWMISize(long lType)
{
	int nWMISize = 0;

    switch(lType){
		//	CIM_SINT8	= 16,
		//	CIM_UINT8	= 17,
		case VT_I1:
		case VT_UI1:
			nWMISize = sizeof(BYTE);
			break;
    
		//	CIM_SINT16	= 2,
		//	CIM_UINT16	= 18,
		case VT_I2:
		case CIM_CHAR16:
		case VT_UI2:
			nWMISize = sizeof(short);
			break;

		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		case VT_I4:
		case VT_UI4:
			nWMISize = sizeof(DWORD);
			break;
    
		//	CIM_SINT64	= 20,
		//	CIM_UINT64	= 21,
		case VT_I8:
		case VT_UI8:
	        nWMISize = sizeof(__int64);
			break;

		//	CIM_REAL32	= 4,
		case VT_R4:
			nWMISize = sizeof(float);
			break;

	//	CIM_REAL64	= 5,
		case VT_R8:
			nWMISize = sizeof(double);
			break;

	//	CIM_BOOLEAN	= 11,
		case VT_BOOL:
	        nWMISize = sizeof(BYTE);
			break;

		case CIM_DATETIME:
			nWMISize = SIZEOFWBEMDATETIME;
			break;

		case CIM_STRING:
			nWMISize = 2;
			break;

		default:
			//	CIM_STRING	= 8,
			//	CIM_REFERENCE	= 102,
			//	CIM_OBJECT	= 13,
			//	CIM_FLAG_ARRAY	= 0x2000
 			nWMISize = 0;
	}

	return nWMISize;
}
///////////////////////////////////////////////////////////////
long CWMIDataTypeMap::GetVariantType(WCHAR * wcsType)
{
	long lType;

	//	CIM_SINT8	= 16,
	if( 0 == wbem_wcsicmp( L"sint8",wcsType) ){
		lType = VT_I1;
    }
	//	CIM_UINT8	= 17,
	else if( 0 == wbem_wcsicmp( L"uint8",wcsType) ){
		lType = VT_UI1;
    }
	//	CIM_CHAR16	= 103,
	else if( 0 == wbem_wcsicmp( L"char16",wcsType) ){
		lType = VT_I2;
	}
	//	CIM_SINT16	= 2,
	else if( 0 == wbem_wcsicmp( L"sint16",wcsType) ){
		lType = VT_I2;
    }
	//	CIM_UINT16	= 18,
	else if( 0 == wbem_wcsicmp( L"uint16",wcsType) ){
		lType = VT_UI2;
    }
	//	CIM_SINT32	= 3,
	else if( 0 == wbem_wcsicmp( L"sint32",wcsType) ){
		lType = VT_I4;
    }
	//	CIM_UINT32	= 19,
	else if( 0 == wbem_wcsicmp( L"uint32",wcsType) ){
		lType = VT_UI4;
    }
	//	CIM_SINT64	= 20,
	else if( 0 == wbem_wcsicmp( L"sint64",wcsType) ){
		lType = VT_I8;
	}
	//	CIM_UINT64	= 21,
	else if( 0 == wbem_wcsicmp( L"uint64",wcsType) ){
		lType = VT_UI8;
	}
	//	CIM_REAL32	= 4,
	else if( 0 == wbem_wcsicmp( L"real32",wcsType) ){
		lType = VT_R4;
	}
	//	CIM_REAL64	= 5,
	else if( 0 == wbem_wcsicmp( L"real64",wcsType) ){
		lType = VT_R8;
	}
	//	CIM_BOOLEAN	= 11,
	else if( 0 == wbem_wcsicmp( L"boolean",wcsType) ){
		lType = VT_BOOL;
	}
	//	CIM_DATETIME	= 101,
	else if( 0 == wbem_wcsicmp( L"datetime",wcsType) ){
		lType = CIM_DATETIME;
	}
	//	CIM_STRING	= 8,
	//	CIM_REFERENCE	= 102,
	//	CIM_OBJECT	= 13,
	//	CIM_FLAG_ARRAY	= 0x2000
    else{
		lType = VT_BSTR;
	}
	return lType;
}
///////////////////////////////////////////////////////////////
WCHAR * CWMIDataTypeMap::SetVariantType(long lType)
{
   	if( lType & CIM_FLAG_ARRAY ){
      lType = lType &~  CIM_FLAG_ARRAY;
    }
	switch(lType){

    	//	CIM_SINT8	= 16,
        case VT_I1:
            return L"sint8";

    	//	CIM_UINT8	= 17,
        case VT_UI1:
            return L"uint8";

        //	CIM_SINT16	= 2,
        case VT_I2:
            return L"sint16";    

	    //	CIM_UINT16	= 18,
        case VT_UI2:
            return  L"uint16";

	    //	CIM_SINT32	= 3,
        case VT_I4:
            return L"sint32";

    	//	CIM_UINT32	= 19,
        case VT_UI4:
            return L"uint32";
    
    	//	CIM_SINT64	= 20,
        case VT_I8:
            return L"sint64";

	    //	CIM_UINT64	= 21,
        case VT_UI8:
            return L"uint64";

    	//	CIM_REAL32	= 4,
        case VT_R4:
            return L"real32";

	    //	CIM_REAL64	= 5,
        case VT_R8:
            return L"real64";

	    //	CIM_BOOLEAN	= 11,
        case VT_BOOL:
            return L"boolean";
	
	    //	CIM_STRING	= 8,
        case VT_BSTR:
            return L"string";

	    //	CIM_CHAR16	= 103,
        case CIM_CHAR16: 
            return L"char16";

	    //	CIM_OBJECT	= 13,
        case CIM_OBJECT: 
            return L"object";

	    //	CIM_REFERENCE	= 102,
        case CIM_REFERENCE: 
            return L"ref";

	    //	CIM_DATETIME	= 101,
        case CIM_DATETIME: 
            return L"datetime";

        default: return NULL;
    }
}

////////////////////////////////////////////////////////////////
void CWMIDataTypeMap::GetSizeAndType( WCHAR * wcsType, IDOrder * p, long & lType, int & nWMISize )
{
	BOOL fArray = FALSE;
	if( lType & CIM_FLAG_ARRAY ){
		fArray = TRUE;
	}

	DWORD dwSizeObject = wcslen(L"object:");
	if( 0 == wbem_wcsnicmp( L"object:",wcsType,dwSizeObject ) )
	{
	        //============================================
        	//  Extract out the object name
	        //============================================
		WCHAR * pName = & wcsType [ dwSizeObject ];
		p->SetEmbeddedName(pName);
		lType = VT_UNKNOWN;
		nWMISize =  0;
	}
	else{
		lType = GetVariantType(wcsType);
		nWMISize = GetWMISize(lType);
	}
	if( fArray ){
		lType |= CIM_FLAG_ARRAY;
	}
}
/////////////////////////////////////////////////////////////////////
long CWMIDataTypeMap::ConvertType(long lType )
{
	long lConvert = lType;
	switch (lType){

	//	CIM_SINT16	= 2,
	//	CIM_UINT16	= 18,
	// CIM_SINT8
		case VT_I1:
		case VT_I2:		
			lConvert = VT_I2;
			break;

		case VT_UI2:
			lConvert = VT_I4;
			break;

		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		case VT_I4:	
		case VT_UI4:			
			lConvert = VT_I4;
			break;

		//	CIM_REAL32	= 4,
		//	CIM_REAL64	= 5,
		case VT_R4:		
		case VT_R8:		
			lConvert = VT_R8;
			break;

		//	CIM_SINT64	= 20,
		//	CIM_UINT64	= 21,
		//	CIM_STRING	= 8,
		//	CIM_DATETIME	= 101,
		//	CIM_REFERENCE	= 102,
		//	CIM_CHAR16	= 103,
		//	CIM_OBJECT	= 13,
		//	CIM_FLAG_ARRAY	= 0x2000
		case VT_I8:	
		case VT_UI8:
		case VT_BSTR:	
        case CIM_DATETIME:
			lConvert = VT_BSTR;
			break;
			
		//	CIM_BOOLEAN	= 11,
		case VT_BOOL:	
			lConvert = VT_BOOL;
			break;

		//	CIM_UINT8	= 17,
		case VT_UI1:	
			lConvert = VT_UI1;
			break;

		case VT_UNKNOWN:
			lConvert = VT_UNKNOWN;
			break;

        default:
			break;
	}
	return lConvert;

}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIDataTypeMap::PutInArray(SAFEARRAY * & psa,long * pi, long & lType, VARIANT * pVar)
{
    HRESULT hr = WBEM_E_INVALID_OBJECT;
	VARIANT v = *pVar;
	switch (lType){

	//	CIM_SINT16	= 2,
	//	CIM_UINT16	= 18,
	// CIM_SINT8
		case VT_I1:
		case VT_I2:		
			lType = V_VT(&v) = VT_I2;
			hr = SafeArrayPutElement(psa,pi,&V_I2(&v));
			break;

		case VT_UI2:
			lType = V_VT(&v) = VT_I4;
			hr = SafeArrayPutElement(psa,pi,&V_I4(&v));
			break;

		//	CIM_SINT32	= 3,
		//	CIM_UINT32	= 19,
		case VT_I4:	
		case VT_UI4:			
			lType = V_VT(&v) = VT_I4;
			hr = SafeArrayPutElement(psa,pi,&V_I4(&v));
			break;

		//	CIM_REAL32	= 4,
		//	CIM_REAL64	= 5,
		case VT_R4:		
		case VT_R8:		
			lType = V_VT(&v) = VT_R8;
			hr = SafeArrayPutElement(psa,pi,&V_R8(&v));
			break;

		//	CIM_SINT64	= 20,
		//	CIM_UINT64	= 21,
		//	CIM_STRING	= 8,
		//	CIM_DATETIME	= 101,
		//	CIM_REFERENCE	= 102,
		//	CIM_CHAR16	= 103,
		//	CIM_OBJECT	= 13,
		//	CIM_FLAG_ARRAY	= 0x2000
		case VT_I8:	
		case VT_UI8:
		case VT_BSTR:	
        case CIM_DATETIME:
			lType = V_VT(&v) = VT_BSTR; 
			hr = SafeArrayPutElement(psa,pi,V_BSTR(&v));
			break;
			
		//	CIM_BOOLEAN	= 11,
		case VT_BOOL:	
			lType = V_VT(&v) = VT_BOOL;
			hr = SafeArrayPutElement(psa,pi,&V_BOOL(&v));
			break;

		//	CIM_UINT8	= 17,
		case VT_UI1:	
			lType = V_VT(&v) = VT_UI1;
			hr = SafeArrayPutElement(psa,pi,&V_UI1(&v));
			break;

		case VT_UNKNOWN:
			lType = V_VT(&v) = VT_UNKNOWN;
			hr = SafeArrayPutElement(psa,pi,V_UNKNOWN(&v));
			break;

        default:
			break;

	}
	return hr;
}
//////////////////////////////////////////////////////////////////////
BOOL CWMIDataTypeMap::NaturallyAlignData( int nSize, BOOL fRead )
{
    BOOL fRc = FALSE;
	DWORD dwBytesToPad = 0;
	if( *m_pdwAccumulativeSizeOfBlock != 0 ){

		DWORD dwMod;
		int nNewSize = nSize;

        if( nSize == SIZEOFWBEMDATETIME ){
			nNewSize = 2;
		}

	    dwMod = *m_pdwAccumulativeSizeOfBlock % nNewSize;

		if( dwMod > 0 ){
			dwBytesToPad = (DWORD)nNewSize - dwMod;
        }
	}
    if( fRead ){
   	    if( m_pWMIBlockInfo->CurrentPtrOk((ULONG)(dwBytesToPad+nSize)) ){
            fRc = TRUE;
        }
        else{
            dwBytesToPad = 0;
        }
    }
	else{
		fRc = TRUE;
	}
    m_pWMIBlockInfo->AddPadding(dwBytesToPad);
    *m_pdwAccumulativeSizeOfBlock += nSize + dwBytesToPad;

    return fRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\wmicom.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#include "wmicom.h"
#include "wmimof.h"
#include "wmimap.h"
#include <stdlib.h>
#include <winerror.h>
#include <TCHAR.h>

//
// GlobalInterfaceTable
//

IGlobalInterfaceTable * g_pGIT = NULL;

////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************
//  Global Utility Functions
//**********************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////
BOOL IsBinaryMofResourceEvent(LPOLESTR pGuid, GUID gGuid)
{
	HRESULT hr;
	GUID Guid;

	hr = CLSIDFromString(pGuid,&Guid);
	if( SUCCEEDED(hr) )
    {
		if( gGuid == Guid)
        {
			return TRUE;
		}
	}

    return FALSE;
}
/////////////////////////////////////////////////////////////////////
BOOL GetParsedPropertiesAndClass( BSTR Query,WCHAR * wcsClass, int cchSize )
{
	ParsedObjectPath   * pParsedPath = NULL;										// stdlibrary API
	CObjectPathParser   Parser;	
    BOOL fRc = FALSE;

    if( CObjectPathParser::NoError == Parser.Parse(Query, &pParsedPath))
    {
        try
        {
			// NTRaid:136400
			// 07/12/00
            if(pParsedPath && !IsBadReadPtr( pParsedPath, sizeof(ParsedObjectPath)))
            {
            	KeyRef * pKeyRef = NULL;
        	    pKeyRef = *(pParsedPath->m_paKeys);
                if(!IsBadReadPtr( pKeyRef, sizeof(KeyRef)))
                {
                    if ( SUCCEEDED ( StringCchCopyW (wcsClass,cchSize,pParsedPath->m_pClass) ) )
					{
						fRc = TRUE;
					}
                }
            }

  	        Parser.Free(pParsedPath);
        }
        catch(...)
        {
            Parser.Free(pParsedPath);
            throw;
        }
    }

    return fRc;
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CheckIfThisIsAValidKeyProperty(WCHAR * wcsClass, WCHAR * wcsProperty, IWbemServices * p)
{
	HRESULT hr = WBEM_E_FAILED;
	IWbemClassObject * pIHCO = NULL;
    IWbemQualifierSet * pIWbemQualifierSet = NULL;
    long lType = 0L;
	BSTR strPath = NULL;


	strPath = SysAllocString(wcsClass);
	if(strPath == NULL)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		hr = p->GetObject(strPath, 0,NULL, &pIHCO, NULL);
		SysFreeString(strPath);
		if (WBEM_S_NO_ERROR != hr)
			return WBEM_E_INVALID_CLASS;

		if(wcsProperty){
			hr = pIHCO->GetPropertyQualifierSet(wcsProperty,&pIWbemQualifierSet);
			if( SUCCEEDED(hr) ){

           		CVARIANT v;
	    		hr = pIWbemQualifierSet->Get(L"key", 0, &v, 0);
				SAFE_RELEASE_PTR(pIWbemQualifierSet);
			}
			else{
				hr = WBEM_E_INVALID_OBJECT_PATH;
			}
		}

		//============================================================
		//  Cleanup
		//============================================================
		SAFE_RELEASE_PTR(pIHCO);
	}
	return hr;

}
//====================================================================
HRESULT GetParsedPath( BSTR ObjectPath, WCHAR * wcsClass, int cchSizeClass, WCHAR * wcsInstance, int cchSizeInstance, IWbemServices * p )
{
    //============================================================
	//  Get the path and instance name and check to make sure it
    //  is valid
	//============================================================
	ParsedObjectPath   * pParsedPath = NULL;										// stdlibrary API
	CObjectPathParser   Parser;	
    HRESULT hr = WBEM_E_FAILED;

    if( 0 == Parser.Parse(ObjectPath, &pParsedPath))
    {
        try
        {
			// NTRaid:136395
			// 07/12/00
            if(pParsedPath && !IsBadReadPtr( pParsedPath, sizeof(ParsedObjectPath)))
            {
            	KeyRef * pKeyRef = NULL;
                pKeyRef = *(pParsedPath->m_paKeys);
                if( !IsBadReadPtr( pKeyRef, sizeof(KeyRef)))
                {
                    hr = CheckIfThisIsAValidKeyProperty(pParsedPath->m_pClass, pKeyRef->m_pName,p );
			        if( SUCCEEDED(hr) )
                    {
				        if ( SUCCEEDED ( hr = StringCchCopyW (wcsClass,cchSizeClass,pParsedPath->m_pClass) ) )
						{
							hr = StringCchCopyW ( wcsInstance, cchSizeInstance, pKeyRef->m_vValue.bstrVal );
						}
			        }
                }
            }
  	        Parser.Free(pParsedPath);
        }
        catch(...)
        {
            hr = WBEM_E_UNEXPECTED;
            Parser.Free(pParsedPath);
            throw;
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL GetUserThreadToken(HANDLE * phThreadTok)
{
    BOOL fRc = FALSE;

	HRESULT hRes = WbemCoImpersonateClient();
    if (SUCCEEDED(hRes))
    {
		// Now, let's check the impersonation level.  First, get the thread token
        if (!OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, phThreadTok))
        {
            // If the CoImpersonate works, but the OpenThreadToken fails, we are running under the
            // process token (either local system, or if we are running with /exe, the rights of
            // the logged in user).  In either case, impersonation rights don't apply.  We have the
            // full rights of that user.

             if(GetLastError() == ERROR_NO_TOKEN)
             {
                // Try getting the thread token.  If it fails it's because we're a system thread and
                // we don't yet have a thread token, so just impersonate self and try again.
                if( ImpersonateSelf(SecurityImpersonation) )
                {
                    if (!OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, phThreadTok))
                    {
                        fRc = FALSE;
                    }
                    else
                    {
                        fRc = TRUE;
                    }
                }
                else
                {
                    ERRORTRACE((THISPROVIDER,"ImpersonateSelf(SecurityImpersonation)failed\n"));
                }
            }
         }
         else
         {
             fRc = TRUE;
         }
	}
    if( !fRc )
    {
	    ERRORTRACE((THISPROVIDER,IDS_ImpersonationFailed));
    }
    return fRc;
}
////////////////////////////////////////////////////////////////////////////////////////////////

SAFEARRAY * OMSSafeArrayCreate( IN VARTYPE vt, IN int iNumElements)
{
    if(iNumElements < 1)
    {
        return NULL;
    }
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iNumElements;
    return SafeArrayCreate(vt,1,rgsabound);
}
////////////////////////////////////////////////////////////////////////////////////////////////
void TranslateAndLog( WCHAR * wcsMsg, BOOL bVerbose )
{
	BOOL bContinue = FALSE ;

	if ( bVerbose )
	{
		if ( LoggingLevelEnabled ( 2 ) )
		{
			bContinue = TRUE ;
		}
	}
	else
	{
		bContinue = TRUE ;
	}

	if ( bContinue )
	{
		char * pStr = NULL;

		DWORD cCharacters = wcslen(wcsMsg)+1;
		pStr = new char[cCharacters*2];
		if (NULL != pStr)
		{
			try
			{
				// Convert to ANSI.
				if (0 != WideCharToMultiByte(CP_ACP, 0, wcsMsg, cCharacters, pStr, cCharacters*2, NULL, NULL))
				{
					if ( bVerbose )
					{
						DEBUGTRACE((THISPROVIDER,pStr));
					}
					else
					{
						ERRORTRACE((THISPROVIDER,pStr));
					}
					SAFE_DELETE_ARRAY(pStr);
				}
			}
			catch(...)
			{
				SAFE_DELETE_ARRAY(pStr);
				throw;
			}
		}

		if ( bVerbose )
		{
			DEBUGTRACE((THISPROVIDER,"\n"));
		}
		else
		{
			ERRORTRACE((THISPROVIDER,"\n"));
		}
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////
bool IsNT(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwPlatformId == VER_PLATFORM_WIN32_NT;
}
////////////////////////////////////////////////////////////////////
BOOL SetGuid(WCHAR * pwcsGuidString, CLSID & Guid)
{
	BOOL fRc = FALSE;
	CAutoWChar wcsGuid(MAX_PATH+2);

	if( wcsGuid.Valid() )
	{
		if ( FAILED ( CLSIDFromString ( pwcsGuidString, &Guid ) ) )
		{
			if ( SUCCEEDED ( StringCchPrintfW ( wcsGuid, MAX_PATH+2, L"{%s}", pwcsGuidString ) ) )		
			{
				if ( SUCCEEDED ( CLSIDFromString ( wcsGuid, &Guid ) ) )
				{
					fRc = TRUE;
				}
			}
		}
		else
		{
			fRc = TRUE;
		}
	}
	return fRc;
}
////////////////////////////////////////////////////////////////////
HRESULT AllocAndCopy(WCHAR * wcsSource, WCHAR ** pwcsDest )
{
    HRESULT hr = WBEM_E_FAILED;

    int nLen = wcslen(wcsSource);
    if( nLen > 0 )
    {
       *pwcsDest = new WCHAR[nLen + 2 ];
       if( *pwcsDest )
       {
          hr = StringCchCopyW(*pwcsDest, nLen+2, wcsSource);
       }
    }

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************
//  Utility Classes
//**********************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////
void _WMIHandleMap::AddRef()
{
  InterlockedIncrement((long*)&RefCount);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
long _WMIHandleMap::Release()
{
  	ULONG cRef = InterlockedDecrement( (long*) &RefCount);
	if ( !cRef ){
        WmiCloseBlock(WMIHandle);
		return 0;
	}
	return cRef;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
_WMIEventRequest::_WMIEventRequest()
{
    pwcsClass = NULL ;
    pHandler = NULL;
    pCtx = NULL;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
_WMIEventRequest::~_WMIEventRequest()
{
    SAFE_RELEASE_PTR(pCtx);
    SAFE_DELETE_ARRAY(pwcsClass);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT _WMIEventRequest::AddPtrs	(
										IWbemObjectSink __RPC_FAR * Handler,
										IWbemServices __RPC_FAR * Services,
										IWbemServices __RPC_FAR * Repository,
										IWbemContext __RPC_FAR * Ctx
									)
{
	HRESULT hr = E_FAIL;
	if ( SUCCEEDED ( hr = gipServices.Globalize(Services) ) )
	{
		if ( SUCCEEDED ( hr = gipRepository.Globalize(Repository) ) )
		{
			pHandler = Handler;
			pCtx = Ctx;
			if( pCtx ){
				pCtx->AddRef();
			}
		}
	}

    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
_AccessList::~_AccessList()
{
    for( int i = 0; i < m_List.Size(); i++ )
    {
        IWbemObjectAccess * pPtr = (IWbemObjectAccess *)m_List[i];
        SAFE_RELEASE_PTR(pPtr);
    }
    m_List.Empty();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
_IdList::~_IdList()
{
    for( int i = 0; i < m_List.Size(); i++ )
    {
        ULONG_PTR* pPtr = (ULONG_PTR*)m_List[i];
        SAFE_DELETE_PTR(pPtr);
    }
    m_List.Empty();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
_HandleList::~_HandleList()
{
    for( int i = 0; i < m_List.Size(); i++ )
    {
        HANDLE * pPtr = (HANDLE*)m_List[i];
        SAFE_DELETE_PTR(pPtr);
    }
    m_List.Empty();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
_InstanceList::~_InstanceList()
{
    for( int i = 0; i < m_List.Size(); i++ )
    {
        WCHAR * p = (WCHAR*)m_List[i];
        SAFE_DELETE_ARRAY(p);
    }
    m_List.Empty();
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
_OldClassInfo::~_OldClassInfo()
{
     SAFE_DELETE_ARRAY(m_pClass);
     SAFE_DELETE_ARRAY(m_pPath);
     m_pClass = m_pPath = NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
_OldClassList::~_OldClassList()
{
    for( int i = 0; i < m_List.Size(); i++ )
    {
        OldClassInfo * p = (OldClassInfo*)m_List[i];
        SAFE_DELETE_PTR(p);
    }
    m_List.Empty();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
_WMIHiPerfHandleMap::_WMIHiPerfHandleMap(CWMIProcessClass * p, IWbemHiPerfEnum * pEnum)
{
    m_pEnum = pEnum;
    if( pEnum )
    {
        pEnum->AddRef();
    }
    m_pClass = p;
    m_fEnumerator = FALSE;
    lHiPerfId = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
_WMIHiPerfHandleMap::~_WMIHiPerfHandleMap()
{
    SAFE_RELEASE_PTR(m_pEnum);
    lHiPerfId = 0;
    SAFE_DELETE_PTR(m_pClass);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Hi Perf Handle Map = Handles are addref'd and when released, then the block is closed
//  Critical Sections are handled elsewhere
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CHiPerfHandleMap::Add( HANDLE hCurrent, ULONG_PTR lHiPerfId, CWMIProcessClass * p, IWbemHiPerfEnum * pEnum)
{
    HRESULT hr = S_OK;

	WMIHiPerfHandleMap * pWMIMap = new WMIHiPerfHandleMap(p,pEnum);
    if( pWMIMap )
    {
        try
        {
    	    pWMIMap->WMIHandle = hCurrent;
            pWMIMap->lHiPerfId = lHiPerfId;
			// 170635
 	        if(CFlexArray::out_of_memory == m_List.Add(pWMIMap))
			{
				SAFE_DELETE_PTR(pWMIMap);
				hr = E_OUTOFMEMORY;
			}
        }
        catch(...)
        {
            hr = WBEM_E_UNEXPECTED;
            SAFE_DELETE_PTR(pWMIMap);
            throw;
        }
	}

    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CHiPerfHandleMap::FindHandleAndGetClassPtr( HANDLE & hCurrent, ULONG_PTR lHiPerfId,CWMIProcessClass *& p)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    for( int i=0; i<m_List.Size(); i++)
    {
        //===================================================
        //
        //===================================================
        WMIHiPerfHandleMap * pMap = (WMIHiPerfHandleMap *) m_List[i];
        if( pMap->lHiPerfId == lHiPerfId )
        {
            hCurrent = pMap->WMIHandle;
            p = pMap->m_pClass;
            hr = S_OK;
        }
    }

    return hr;

}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CHiPerfHandleMap::GetFirstHandle(HANDLE & hCurrent,CWMIProcessClass *& p, IWbemHiPerfEnum *& pEnum)
{
    m_nIndex=0;
    return GetNextHandle(hCurrent,p,pEnum);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CHiPerfHandleMap::GetNextHandle(HANDLE & hCurrent,CWMIProcessClass *& p, IWbemHiPerfEnum *& pEnum)
{
    HRESULT hr = WBEM_S_NO_MORE_DATA;

    if( m_nIndex < m_List.Size() )
    {
        WMIHiPerfHandleMap * pMap = (WMIHiPerfHandleMap *) m_List[m_nIndex];
        hCurrent = pMap->WMIHandle;
        p = pMap->m_pClass;
        pEnum = pMap->m_pEnum;
        m_nIndex++;
        hr = S_OK;
    }
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CHiPerfHandleMap::Delete( HANDLE & hCurrent, ULONG_PTR lHiPerfId )
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    for( int i=0; i<m_List.Size(); i++)
    {
        //===================================================
        //
        //===================================================
        WMIHiPerfHandleMap * pMap = (WMIHiPerfHandleMap *) m_List[i];
        if( pMap->lHiPerfId == lHiPerfId )
        {
            hCurrent = pMap->WMIHandle;
            SAFE_DELETE_PTR(pMap);
            m_List.RemoveAt(i);
            hr = S_OK;
            break;
        }
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//  When this function is called, release all the handles kept
// THis function is called in the destructor of the class to release all teh WMIHiPerfHandleMap
// classes allocated
////////////////////////////////////////////////////////////////////////////////////////////////
void CHiPerfHandleMap::CloseAndReleaseHandles()
{
	//===================================
	//  Go through the handles one at
	//  a time and close them, then
	//  delete the records from the
	//  array
	//===================================

    CAutoBlock((CCriticalSection *)&m_HandleCs);

    if( m_List.Size() > 0 ){

        for(int i = 0; i < m_List.Size(); i++){
    		
		    WMIHiPerfHandleMap * pWMIMap = (WMIHiPerfHandleMap *) m_List[i];
            SAFE_DELETE_PTR(pWMIMap);
	    }

	    //==================================================
	    //  Remove it and deallocate memory
	    //==================================================
        m_List.Empty();
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Regular Handle Map = Expensize handles are always kept open - by default we, dont' know the lifetime
//  of these handles
///////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CHandleMap::Add(CLSID Guid, HANDLE hCurrent, ULONG uDesiredAccess)
{
    // Critical section is called elsewhere

    HRESULT hr = S_OK;

	WMIHandleMap * pWMIMap = new WMIHandleMap();
    if( pWMIMap )
    {
	    try
        {
            pWMIMap->AddRef();                          // Used for HiPerf counts, otherwise not referenced
    		pWMIMap->WMIHandle = hCurrent;
		    pWMIMap->Guid = Guid;
		    pWMIMap->uDesiredAccess = uDesiredAccess;

			// 170635
		    if(CFlexArray::out_of_memory == m_List.Add(pWMIMap))
			{
				hr = E_OUTOFMEMORY;
				SAFE_DELETE_PTR(pWMIMap);
			}
	    }
        catch(...)
        {
            hr = WBEM_E_UNEXPECTED;
            SAFE_DELETE_PTR(pWMIMap);
            throw;
        }
    }
    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////
int CHandleMap::ExistingHandleAlreadyExistsForThisGuidUseIt(CLSID Guid,
                                                            HANDLE & hCurrentWMIHandle,
                                                            BOOL & fCloseHandle,
                                                            ULONG uDesiredAccess)
{
	int nRc = ERROR_NOT_SUPPORTED;

    // Critical section is called elsewhere

	//=====================================================
	//  Initialize stuff
	//=====================================================
	hCurrentWMIHandle = 0;
	fCloseHandle = TRUE;

    for(int i = 0; i < m_List.Size(); i++){
    		
		WMIHandleMap * pWMIMap = (WMIHandleMap*) m_List[i];
		//==================================================
		//  Compare and see if this guid already has a
		//  handle assigned for it with the access permissions
		//  that we want to use
		//==================================================
		if( pWMIMap->Guid == Guid ){
			if( pWMIMap->uDesiredAccess == uDesiredAccess ){

				hCurrentWMIHandle = pWMIMap->WMIHandle;
                pWMIMap->AddRef();                      // Used for HiPerf Handles, otherwise not needed
				nRc = ERROR_SUCCESS;
				fCloseHandle = FALSE;
				break;
			}
		}
    }

	return nRc;
}
////////////////////////////////////////////////////////////////////////////////////////////////
//  When this function is called, we need to close all of the handles that may have been kept
//  open for accumulation purposes
////////////////////////////////////////////////////////////////////////////////////////////////
void CHandleMap::CloseAllOutstandingWMIHandles()
{
	//===================================
	//  Go through the handles one at
	//  a time and close them, then
	//  delete the records from the
	//  array
	//===================================

    CAutoBlock((CCriticalSection *)&m_HandleCs);

    if( m_List.Size() > 0 ){

        for(int i = 0; i < m_List.Size(); i++){
    		
		    WMIHandleMap * pWMIMap = (WMIHandleMap*) m_List[i];
		    //==================================================
		    //  Inform WMI we are done with this guy
		    //==================================================
            try
            {
		        WmiCloseBlock(pWMIMap->WMIHandle);
            }
            catch(...)
            {
                // don't throw
            }
            SAFE_DELETE_PTR(pWMIMap);
	    }

	    //==================================================
	    //  Remove it and deallocate memory
	    //==================================================
        m_List.Empty();
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////
//  Used when we know the handles lifetimes
////////////////////////////////////////////////////////////////////////////////////////////////
int CHandleMap::ReleaseHandle( HANDLE hCurrentWMIHandle )
{
	int nRc = ERROR_NOT_SUPPORTED;

    CAutoBlock((CCriticalSection *)&m_HandleCs);

    for(int i = 0; i < m_List.Size(); i++){
    		
		WMIHandleMap * pWMIMap = (WMIHandleMap*) m_List[i];

        if( pWMIMap->WMIHandle == hCurrentWMIHandle )
        {
            long RefCount = pWMIMap->Release();                      // Used for HiPerf Handles, otherwise not needed
            if( !RefCount )
            {
//                WmiCloseBlock(hCurrentWMIHandle);
                SAFE_DELETE_PTR( pWMIMap);
                m_List.RemoveAt(i);
            }
			nRc = ERROR_SUCCESS;
			break;
		}
    }

	return nRc;
}
////////////////////////////////////////////////////////////////////////////////////////////////
int CHandleMap::GetHandle(CLSID Guid, HANDLE & hCurrentWMIHandle )
{
	int nRc = ERROR_NOT_SUPPORTED;

    CAutoBlock((CCriticalSection *)&m_HandleCs);

	//=====================================================
	//  Initialize stuff
	//=====================================================
	hCurrentWMIHandle = 0;

    for(int i = 0; i < m_List.Size(); i++){
    		
		WMIHandleMap * pWMIMap = (WMIHandleMap*) m_List[i];
		if( pWMIMap->Guid == Guid ){

			hCurrentWMIHandle = pWMIMap->WMIHandle;
            pWMIMap->AddRef();                      // Used for HiPerf Handles, otherwise not needed
			nRc = ERROR_SUCCESS;
			break;
		}
    }

	return nRc;
}

//************************************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//   CWMIManagement
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//************************************************************************************************************
CWMIManagement::CWMIManagement( ) :
    m_pHandler ( NULL ) ,
    m_pServices ( NULL ) ,
    m_pRepository ( NULL ) ,
    m_pCtx ( NULL ) ,
    m_pHandleMap ( NULL )

{
}
//////////////////////////////////////////////////////////////////////////////////////
CWMIManagement::~CWMIManagement()
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWMIManagement::SendPrivilegeExtendedErrorObject( HRESULT hrToReturn,WCHAR * wcsClass)
{
	HRESULT hr,hRes;
	IWbemClassObject * pClass = NULL, *pInst=NULL;
    BOOL fSetStatus = FALSE;


	if( hrToReturn == WBEM_E_ACCESS_DENIED ){

		TOKEN_PRIVILEGES * ptPriv = NULL;

		hr = GetListOfUserPrivileges(ptPriv);
		if( SUCCEEDED(hr ) ){
			
			BSTR strPrivelegeStat = NULL;
			strPrivelegeStat = SysAllocString(L"Win32_PrivilegesStatus");
			if(strPrivelegeStat != NULL)
			{
				hr = m_pRepository->GetObject(strPrivelegeStat, 0,m_pCtx, &pClass, NULL);
				if( hr == S_OK){	

					//=============================================================
					// Get an instance of the extended class
					//=============================================================
					hr = pClass->SpawnInstance(0,&pInst);
					SAFE_RELEASE_PTR(pClass);
			
					if( pInst ){

						CVARIANT varTmp;
						//=========================================================
						//  Fill in description
						//=========================================================
						varTmp.SetStr(IDS_ImpersonationFailedWide);
						hr = pInst->Put(L"Description", 0, &varTmp, NULL);

						//======================================================
						//  Initialize all of the necessary stuff and get the
						//  definition of the class we are working with
						//======================================================
						CWMIProcessClass ClassInfo(0);
						if( SUCCEEDED(ClassInfo.Initialize()) )
						{
							ClassInfo.WMI()->SetWMIPointers(m_pHandleMap,m_pServices,m_pRepository,m_pHandler,m_pCtx);
							ClassInfo.SetClass(wcsClass);
							SAFEARRAY *psaPrivNotHeld=NULL;
							SAFEARRAY *psaPrivReq=NULL;

							//=========================================================
							// Get PrivilegesRequired
							// The only place to get this, if possible, is from the
							// class
							//=========================================================
					
							hRes = ClassInfo.GetPrivilegesQualifer(&psaPrivReq);
							if( hRes == WBEM_S_NO_ERROR){

								//=========================================================
								// Get PrivilegesNotHeld
								//=========================================================
								ProcessPrivileges(ptPriv,psaPrivNotHeld,psaPrivReq);
								//=========================================================
								//  Send it off
								//=========================================================
								VARIANT v;

								if( psaPrivReq ){
									VariantInit(&v);
									SAFEARRAY *pSafeArray = NULL;

									if ( SUCCEEDED ( SafeArrayCopy ((SAFEARRAY*)psaPrivReq , &pSafeArray ) ) ){
        								v.vt = VT_BSTR | VT_ARRAY;
	        							v.parray = pSafeArray;
										pInst->Put(L"PrivilegesRequired", 0, &v, NULL);
										VariantClear(&v);
									}
								}

								if( psaPrivNotHeld ){
									VariantInit(&v);
									SAFEARRAY *pSafeArray = NULL;

									if ( SUCCEEDED ( SafeArrayCopy ((SAFEARRAY*)psaPrivNotHeld , &pSafeArray ) ) ){
        								v.vt = VT_BSTR | VT_ARRAY;
	        							v.parray = pSafeArray;
										pInst->Put(L"PrivilegesNotHeld", 0, &v, NULL);
										VariantClear(&v);
									}
								}
							}
							//=========================================================
							// Now, send this guy off...
							//=========================================================
							fSetStatus = TRUE;
							hr = m_pHandler->SetStatus(0,hrToReturn,NULL,pInst);


							if (psaPrivNotHeld)
								SafeArrayDestroy(psaPrivNotHeld);
							if (psaPrivReq)
								SafeArrayDestroy(psaPrivReq);
						}

					}
					SAFE_RELEASE_PTR(pInst);
				}	
				SysFreeString(strPrivelegeStat);
			}						
		}

        SAFE_DELETE_ARRAY(ptPriv);
	}

    if( !fSetStatus ){
        hr = m_pHandler->SetStatus(0,hrToReturn,NULL,NULL);
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIManagement::SetErrorMessage(HRESULT hrToReturn,WCHAR * wcsClass,WCHAR * wcsMsg)
{
	HRESULT hr;
	IWbemClassObject * pClass = NULL, *pInst=NULL;
    BOOL fSetStatus = FALSE;

    if( m_pHandler )
    {
		BSTR strExtendedStat = NULL;

	    switch( hrToReturn ){

		    case WBEM_E_ACCESS_DENIED:
			    SendPrivilegeExtendedErrorObject(hrToReturn,wcsClass);
			    break;

		    case S_OK :
		        hr = m_pHandler->SetStatus(0,hrToReturn,NULL,NULL);
			    break;

		    default:
				strExtendedStat = SysAllocString(L"__ExtendedStatus");
				if(strExtendedStat != NULL)
				{
					hr = m_pRepository->GetObject(strExtendedStat, 0,m_pCtx, &pClass, NULL);
					if( hr == S_OK){	
						hr = pClass->SpawnInstance(0,&pInst);
						if( pInst ){

							CVARIANT varTmp;
							varTmp.SetStr(wcsMsg);
				
							hr = pInst->Put(L"Description", 0, &varTmp, NULL);
							hr = m_pHandler->SetStatus(0,hrToReturn,NULL,pInst);
							fSetStatus = TRUE;

							// Now log the error in the error log
							if( hrToReturn != S_OK ){
								TranslateAndLog(varTmp.GetStr());
							}
						}		
					}
					if( !fSetStatus ){
    					hr = m_pHandler->SetStatus(0,hrToReturn,NULL,NULL);
					}
					SAFE_RELEASE_PTR(pClass);
					SAFE_RELEASE_PTR(pInst);
					SysFreeString(strExtendedStat);
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
			    break;
	    }
    }
    return hrToReturn;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIManagement::GetListOfUserPrivileges(TOKEN_PRIVILEGES *& ptPriv)
{
	HRESULT hr = WBEM_E_FAILED;

	//  Get the privileges this user has
	DWORD dwTokenInfoLength = 0;
	DWORD dwSize = 0;
	HANDLE hThreadTok;
	
    if (IsNT()){

		if( GetUserThreadToken(&hThreadTok) ){

		 // get information
			if (!GetTokenInformation(hThreadTok, TokenPrivileges, NULL, dwTokenInfoLength, &dwSize)){
				if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
				{
    				ptPriv = ( TOKEN_PRIVILEGES* ) new BYTE[dwSize];
                    if( ptPriv )
                    {
					    try
                        {
						    dwTokenInfoLength = dwSize;
							if(GetTokenInformation(hThreadTok, TokenPrivileges, (LPVOID)ptPriv, dwTokenInfoLength, &dwSize))
                            {
								hr = WBEM_NO_ERROR;
							}
						}
                        catch(...)
                        {
                            SAFE_DELETE_ARRAY(ptPriv);
                            hr = WBEM_E_UNEXPECTED;
                            throw;
                        }
                    }
				}
			}

            // Done with this handle
            CloseHandle(hThreadTok);
 		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWMIManagement::ProcessPrivileges(TOKEN_PRIVILEGES *ptPriv, SAFEARRAY *& psaPrivNotHeld, SAFEARRAY * psaPrivReq )
{
	BOOL fFound = FALSE;

	//==============================================================
	//  Create a temporary working array, we know the MAX can be
	//  the number of priv held + the number of priv req, so
	//  allocate it for that
	//==============================================================
	CSAFEARRAY PrivReq( psaPrivReq );
			

	long lMax = PrivReq.GetNumElements()+ptPriv->PrivilegeCount;
    psaPrivNotHeld = OMSSafeArrayCreate(VT_BSTR,lMax);	
	long nCurrentIndex = 0;

	//==============================================================
	// Get how many privs are not held
	//==============================================================
	for( long n = 0; n < PrivReq.GetNumElements(); n++ ){
		//==============================================================
		//  Now, get the privileges held array ready to put stuff in
		//==============================================================
		TCHAR * pPrivReq = NULL;
		CBSTR bstr;

        if( S_OK != PrivReq.Get(n, &bstr)){
			return;
		}
		fFound = FALSE;
		pPrivReq = (TCHAR *)bstr;

		// NTRaid:136384
		// 07/12/00
		if(pPrivReq)
		{

			for(int i=0;i < (int)ptPriv->PrivilegeCount;i++)
			{
				DWORD dwPriv=NAME_SIZE*2;
				TCHAR szPriv[NAME_SIZE*2];

				if( LookupPrivilegeName( NULL, &ptPriv->Privileges[i].Luid, szPriv, &dwPriv)){
						
					//==============================================
					//  If we found the privilege, then the user has
					//  it.  break out
					//==============================================
					if( _tcscmp( pPrivReq,szPriv ) == 0 ){
						fFound = TRUE;
						break;
					}

				}
				//==================================================
				//  If we didn't find it, then we need to add it to
				//  the list so we can notify the user
				//==================================================
				if( !fFound ){
					if( S_OK == SafeArrayPutElement(psaPrivNotHeld, &nCurrentIndex, bstr))
					{
    					nCurrentIndex++;
					}
				}
			}
		}
		pPrivReq = NULL;
	}
	
	SAFEARRAYBOUND rgsabound[1];
   	rgsabound[0].lLbound = 0;
   	rgsabound[0].cElements = nCurrentIndex;
    HRESULT hr = SafeArrayRedim(psaPrivNotHeld, rgsabound);

	PrivReq.Unbind();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\wmiclass.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#include "precomp.h"
#include "wmicom.h"
#include "wmimap.h"
#include <stdlib.h>
#include <winerror.h>
#include <crc32.h>


////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************
//  THE CWbemInfoClass
//**********************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************
//
// NAME			GetPropertiesInID_Order
// PURPOSE		Return a WCHAR string containing the class's 
//              property names, orderd by an ID number
//				contained within the named property qualifier.
//			
// WRAPPER		Not a wrapper.  This is a standalone filter/sort 
//              utility function.
//
//**********************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////
CWMI_IDOrder::CWMI_IDOrder(IWbemClassObject * pC, IWbemObjectAccess * pA) 
{ 
    m_pWMIDataIdList = NULL;
    InitMemberVars();
    m_pClass = pC;
    m_pAccess = pA;
}

///////////////////////////////////////////////////////////////////////
CWMI_IDOrder::~CWMI_IDOrder()
{
    // m_pClass & m_pAccess released elsewhere
    InitMemberVars();
}
///////////////////////////////////////////////////////////////////////
void CWMI_IDOrder::InitMemberVars()
{
    m_nTotal = 0;
    m_nCurrent = 0;

    if( m_pWMIDataIdList )
    {
        SAFE_DELETE_ARRAY(m_pWMIDataIdList);
        m_pWMIDataIdList = NULL;
    }
}
///////////////////////////////////////////////////////////////////////
WCHAR * CWMI_IDOrder::GetFirstID()
{
		m_nCurrent = -1 ;
		return GetNextID();
}
///////////////////////////////////////////////////////////////////////
WCHAR * CWMI_IDOrder::GetNextID()
{
    WCHAR * pChar = NULL;

    //===================================================================
	//  Go in a loop to find the next ID
	//  Increment current first, remember, current has to stay valid at
	//  all times
    //===================================================================
	m_nCurrent++;

    //===================================================================
	// If there is no property name, then we know we are done
	// with the properties
    //===================================================================
    while( m_pWMIDataIdList[m_nCurrent].pwcsPropertyName ){

        if( m_pWMIDataIdList[m_nCurrent].fPutProperty == FALSE )
        {
			m_nCurrent++;
        }
        else
        { 
            pChar = m_pWMIDataIdList[m_nCurrent].pwcsPropertyName;
	        break;
        }
    }//End while loop

    return pChar;
}

///////////////////////////////////////////////////////////////////////
HRESULT CWMI_IDOrder::ProcessPropertyQualifiers ( LPCWSTR strPropName, BOOL fHiPerf, UINT uSizeArray, UINT uStartIndex )
{
	IWbemQualifierSet * pIWbemQualifierSet = NULL;
    CIMTYPE lType = 0; 
        
    HRESULT hr = m_pClass->GetPropertyQualifierSet(strPropName,&pIWbemQualifierSet);
	if( SUCCEEDED(hr) )
    {
		UINT nPosition = 0;
       	CVARIANT v;

		hr = pIWbemQualifierSet->Get(L"WmiDataId", 0, &v, 0);
		if( hr == S_OK )
        {
			nPosition = v.GetLONG();

			//
			// it is required that WmiDataId is 1-based. provider
			// stores internally to 0-based array so decrement
			//
			nPosition-- ;
		}
		else
        {
			//
			// let's try mofcomp generated ID (methods only) as
			// class designers often don't use WmiDataId for
			// properties of __PARAMETERS
			//
			if ( WBEM_E_NOT_FOUND == hr )
			{
				hr = pIWbemQualifierSet->Get(L"ID", 0, &v, 0);
				if( hr == S_OK )
				{
					nPosition = v.GetLONG();
				}
			}
		}

		if( SUCCEEDED(hr))
        {
			//
			// now we need to find real index based on 
			// ( ( ( id/size ) * size ) + ( id%size ) ) - startindex
			//

			UINT div = ( nPosition/uSizeArray ) ;
			UINT mod = ( nPosition%uSizeArray ) ;

			nPosition = ( ( div * uSizeArray ) + mod ) - uStartIndex ;

			if ( nPosition < uSizeArray )
			{
				if ( FALSE == m_pWMIDataIdList[nPosition].bIsDirty )
				{
					//===================================================
					// Get the exact number and 
					// copy property name into the correct array location
					// and get all of the attributes of the property
					// we will need in the future to process it.
					//===================================================
					hr =m_pClass->Get(strPropName, 0, &v, &lType, NULL);
					if( SUCCEEDED(hr) )
					{
           				CVARIANT vQual;  

						hr = pIWbemQualifierSet->Get(L"CIMType", 0, &vQual,0);
						if ( SUCCEEDED(hr) )
						{
							//=================================================================
							//  If we are accumulating hi perf info, then get the handle to 
							//  access the property instead of via property name
							//=================================================================
							if( fHiPerf )
							{
								long lHandle = 0;
								if( S_OK == m_pAccess->GetPropertyHandle(strPropName, 0, &lHandle))
								{
    								m_pWMIDataIdList[nPosition].lHandle = (long)lHandle;
								}
							}
												
							//=================================================================
							//  Now, set the rest of the property information
							//=================================================================
							m_pWMIDataIdList[nPosition].lType = (long)lType;
							m_pWMIDataIdList[nPosition].SetPropertyName((WCHAR*)strPropName);
							m_pWMIDataIdList[nPosition].fPutProperty = TRUE;

        					CWMIDataTypeMap MapWMIData;
							CBSTR cbstrTmp(vQual.GetStr());

							MapWMIData.GetSizeAndType	(
															cbstrTmp,
															&m_pWMIDataIdList[nPosition],
															m_pWMIDataIdList[nPosition].lType, 
															m_pWMIDataIdList[nPosition].nWMISize
														);

							//
							// check MAX or WmiSizeIs qualifiers
							//
							m_pWMIDataIdList[nPosition].dwArraySize = GetSizeOfArray ( strPropName );

							//
							// set the dirty flag
							//
							m_pWMIDataIdList[nPosition].bIsDirty = TRUE ;

							m_nTotal++;
						}
					}
				}
				else
				{
					//
					// already set that position. this
					// means that there must be same WmiDataId used
					//

					hr = WBEM_E_INVALID_CLASS ;
				}
			}
			else
			{
				//
				// qualifier value is not contiguous 
				//

				hr = WBEM_E_INVALID_CLASS ;
			}
		}
		else
        {
			//
			// only when qualifier was not found
			//
			if ( WBEM_E_NOT_FOUND == hr )
			{
				// As some properties are ok not to have WMIDataIds, we have
				// to set this to OK, need to log this in the future
				hr = S_OK;
			}
		}
    }
	else
    {
		switch ( hr )
		{
			case WBEM_E_SYSTEM_PROPERTY:
			{
				//
				// this is not really expected as GetNames called
				// inside of caller was supposed to ask for
				// non-system properties only, but keeping backward
				// behavior ...
				//

				hr = WBEM_S_NO_ERROR ;
				break ;
			}

			default :
			{
				//
				// populate this error back
				//
				break ;
			}
		}
	}

    SAFE_RELEASE_PTR(pIWbemQualifierSet);
    return hr;
}
///////////////////////////////////////////////////////////////////////
HRESULT CWMI_IDOrder::GetPropertiesInIDOrder ( BOOL fHiPerf, UINT uStartIndex )
{
	HRESULT  hr = WBEM_E_FAILED;
	SAFEARRAY * psaNames = NULL;
    
    //======================================================
    // Get Array boundaries
    //======================================================
	hr = m_pClass->GetNames ( NULL, WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames ) ;
    if (SUCCEEDED(hr)){
    	long lLower = 0, lUpper = 0; 

    	hr = SafeArrayGetLBound(psaNames,1,&lLower);
        if (SUCCEEDED(hr)){

            hr = SafeArrayGetUBound(psaNames,1,&lUpper);
            if (SUCCEEDED(hr)){

                //===========================================
                // Get the total number of elements, so we
                // create the right sized array of ID structs
                //===========================================
  
				UINT nSize = ( lUpper-lLower ) + 1;
			    m_pWMIDataIdList = new IDOrder [ nSize + 1 ];

                if( m_pWMIDataIdList )
                {
                    try
                    {
						//
						// last item in array serves as stopper
						//
				        memset ( m_pWMIDataIdList, NULL, ( sizeof ( IDOrder )* ( nSize + 1 ) ) );

				        for(long ndx = lLower; ndx <= lUpper; ndx++)
                        {
                            CBSTR cbstrPropName;
					        hr = SafeArrayGetElement(psaNames, &ndx, &cbstrPropName);
					        if (WBEM_S_NO_ERROR == hr)
                            {
	    				        hr = ProcessPropertyQualifiers ( cbstrPropName, fHiPerf, nSize, uStartIndex ) ;
						        if( hr != WBEM_S_NO_ERROR )
                                {
							        break;
						        }
					        }
				        }
                    }
                    catch(...)
                    { 
                        SAFE_DELETE_ARRAY(m_pWMIDataIdList);
                        hr = WBEM_E_UNEXPECTED; 
                        throw;
                    }
                }
            }
        }
	}
	if( psaNames )
    {
		SafeArrayDestroy(psaNames);
	}
	return hr;
}
////////////////////////////////////////////////////////////////////////
DWORD CWMI_IDOrder::GetSizeOfArray(LPCWSTR strProp)
{
	HRESULT hr = WBEM_E_OUT_OF_MEMORY;
	CAutoWChar pwcsArraySize(_MAX_PATH+2);
	DWORD dwCount = 0L;
	if( pwcsArraySize.Valid() )
	{
		IWbemQualifierSet * pIWbemQualifierSet = NULL;
		hr = m_pClass->GetPropertyQualifierSet(strProp,&pIWbemQualifierSet);
		if( SUCCEEDED(hr) )
		{
			CVARIANT v;

			BOOL bInClassObject = FALSE ;

			hr = pIWbemQualifierSet->Get(L"out", 0, &v, 0);
			if ( SUCCEEDED ( hr ) )
			{
				if ( VT_BOOL != V_VT ( &v ) || ( VARIANT_TRUE != V_BOOL ( &v ) ) )
				{
					bInClassObject = TRUE ;
				}
			}
			else
			{
				if ( WBEM_E_NOT_FOUND == hr ) 
				{
					bInClassObject = TRUE ;
				}
			}

			if ( TRUE == bInClassObject )
			{
				hr = pIWbemQualifierSet->Get(L"MAX", 0, &v, 0);
				if( SUCCEEDED(hr))
				{
					dwCount = v.GetLONG();
				}
				else
				{
					hr = pIWbemQualifierSet->Get(L"WMISizeIs", 0, &v, 0);
					if( hr == S_OK )
					{
						CVARIANT var;
						CIMTYPE lTmpType=0;
						CWMIDataTypeMap MapWMIData;
						hr = m_pClass->Get(v, 0, &var, &lTmpType,NULL);		
						if( hr == S_OK )
						{
							dwCount = MapWMIData.ArraySize(lTmpType,var);
						}
					}
				}
			}
		}

		SAFE_RELEASE_PTR(pIWbemQualifierSet);
	}
    return dwCount;
}        
//******************************************************************
////////////////////////////////////////////////////////////////////
//  CWMIProcessClass
////////////////////////////////////////////////////////////////////
//******************************************************************
//  WbemClassInfo deals with all the pointers and info with one
//  particular wbem class
//
//******************************************************************
////////////////////////////////////////////////////////////////////
CWMIProcessClass::~CWMIProcessClass()
{
    ReleaseInstancePointers();
    SAFE_RELEASE_PTR(m_pAccess);
    SAFE_RELEASE_PTR(m_pClass );
    SAFE_DELETE_ARRAY(m_pwcsClassName);
    SAFE_DELETE_PTR(m_pCurrentProperty);
	SAFE_DELETE_PTR(m_pWMI);
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::Initialize()
{
	HRESULT hr = WBEM_E_FAILED;

	SAFE_DELETE_PTR(m_pWMI);

	m_pWMI = new CWMIManagement;
	if( m_pWMI )
	{
		hr = S_OK;
		m_fInit = TRUE;
	}
	return hr;
}
/////////////////////////////////////////////////////////////////////
CWMIProcessClass::CWMIProcessClass(BOOL b)
{
	m_pWMI = NULL;
	m_fInit = FALSE;
    m_fGetNewInstance = TRUE;
   	m_pAccessInstance = NULL;
    m_pClassInstance = NULL;
    m_pClass = NULL;
	m_pAccess = NULL;
    m_pCurrentProperty = NULL;
    m_pwcsClassName = NULL;
    m_wHardCodedGuid = 0;
}
/////////////////////////////////////////////////////////////////////
BOOL CWMIProcessClass::GetANewAccessInstance()
{ 
    HRESULT hr = S_OK;

    hr = m_pAccess->SpawnInstance(0, &m_pClassInstance);
    m_pClassInstance->AddRef();
    if( SUCCEEDED(hr) )
    {
        hr = m_pClassInstance->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&m_pAccessInstance);

    }
    return ( hr == 0 ) ? TRUE : FALSE; 
}
/////////////////////////////////////////////////////////////////////
BOOL CWMIProcessClass::GetANewInstance()
{ 
    HRESULT hr = S_OK;

    if( m_fGetNewInstance )
    {
        SAFE_RELEASE_PTR(m_pClassInstance);
        hr = m_pClass->SpawnInstance(0, &m_pClassInstance);
        if( SUCCEEDED(hr) )
        {
            if( m_fHiPerf )
            {
                SAFE_RELEASE_PTR(m_pAccessInstance);
                hr = m_pClassInstance->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&m_pAccessInstance);
            }
        }
    }
    return ( hr == 0 ) ? TRUE : FALSE; 
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::SetKeyFromAccessPointer()
{
    CVARIANT varName;
	
    HRESULT hr  = m_pAccess->Get(L"InstanceName", 0, &varName, NULL, NULL);		
    if( SUCCEEDED(hr))
    {
        hr = m_pClassInstance->Put(L"InstanceName", 0, &varName, NULL);
    }
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT  CWMIProcessClass::GetKeyFromAccessPointer(CVARIANT * v)
{
	return m_pAccessInstance->Get(L"InstanceName", 0, (VARIANT *)v, NULL, NULL);		
}

/////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::SetHiPerfProperties(LARGE_INTEGER TimeStamp)  
{ 
    LONG lHandle = 0;

    //=========================================================================================================
    // Timestamp_PerfTime = timestamp in PerfFreq units returned by (QueryPerformanceCounter)
    //=========================================================================================================
    HRESULT hr = m_pAccess->GetPropertyHandle(L"Frequency_PerfTime", 0, &lHandle);
    if(SUCCEEDED(hr))
    {
        LARGE_INTEGER Counter;
        if( QueryPerformanceCounter(&Counter))
        {
            hr = m_pAccessInstance->WriteQWORD(lHandle, Counter.QuadPart);
        }

        //=====================================================================================================
        // Timestamp_Sys100NS = timestamp in 100 NS units/QueryPerformanceCounter()dumbed down to 100NS
        //=====================================================================================================
        if ( SUCCEEDED( hr ) )
        {
            hr = m_pAccess->GetPropertyHandle(L"Timestamp_Sys100NS", 0, &lHandle);
            if( SUCCEEDED(hr))
            {
	            LARGE_INTEGER Sys;
                Sys.QuadPart = Counter.QuadPart / 100;
                hr = m_pAccessInstance->WriteQWORD(lHandle, Sys.QuadPart);
            }
        }
    }

    //=========================================================================================================
    // Frequency_PerfTime = the value returned by QueryPerformanceFrequency
    //=========================================================================================================
    if ( SUCCEEDED( hr ) )
    {
        hr = m_pAccess->GetPropertyHandle(L"Timestamp_PerfTime", 0, &lHandle);
        if( SUCCEEDED(hr))
        {
            LARGE_INTEGER freq;
            if( QueryPerformanceFrequency (&freq))
            {
                hr = m_pAccessInstance->WriteQWORD(lHandle, freq.QuadPart);
            }
        }
    }
     

    //=========================================================================================================
    // Timestamp_Object = (WnodeHeader)->TimeStamp
    //=========================================================================================================
    if ( SUCCEEDED( hr ) )
    {
        hr = m_pAccess->GetPropertyHandle(L"Timestamp_Object", 0, &lHandle);
        if( SUCCEEDED(hr))
        {
            hr = m_pAccessInstance->WriteQWORD(lHandle, TimeStamp.QuadPart);
        }
    }

    //=========================================================================================================
    // Frequency_Sys100NS = 10000000
    // Frequency_Object = 10000000
    //=========================================================================================================
    if ( SUCCEEDED( hr ) )
    {
        LARGE_INTEGER Tmp;
        Tmp.QuadPart = 10000000;
        hr = m_pAccess->GetPropertyHandle(L"Frequency_Object", 0, &lHandle);
        if( SUCCEEDED(hr))
        {
            hr = m_pAccessInstance->WriteQWORD(lHandle, Tmp.QuadPart);
        }
        hr = m_pAccess->GetPropertyHandle(L"Frequency_Sys100NS", 0, &lHandle);
        if( SUCCEEDED(hr))
        {
            hr = m_pAccessInstance->WriteQWORD(lHandle, Tmp.QuadPart);
        }
    }

    
    return hr;
}
/////////////////////////////////////////////////////////////////////
void CWMIProcessClass::SetActiveProperty()  
{ 
    CVARIANT vActive; 
    vActive.SetBool(TRUE);  

    if( !m_fHiPerf )
    {
        m_pClassInstance->Put(L"Active", 0, &vActive, NULL);
    }
}

/////////////////////////////////////////////////////////////////////
void CWMIProcessClass::ReleaseInstancePointers()
{
    SAFE_RELEASE_PTR( m_pClassInstance );
    SAFE_RELEASE_PTR( m_pAccessInstance);
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::SendInstanceBack()
{
    HRESULT hr = WBEM_E_FAILED;
	//===============================================
	// Send the object to the caller
	//===============================================
	if( HANDLER )
    {
        hr = HANDLER->Indicate(1,&m_pClassInstance);
        if( m_fGetNewInstance )
        {
            ReleaseInstancePointers();
	    }
    }
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::SetInstanceName(WCHAR * wName, BOOL fSetName)
{
    CVARIANT varName(wName);
    HRESULT  hr = WBEM_E_INVALID_OBJECT;

    if( fSetName )
    {
        if( m_pClassInstance )
        {
            if( !m_fHiPerf )
            {
                hr = m_pClassInstance->Put(L"InstanceName", 0, &varName, NULL);
            }
            else
            {
                hr = m_pClassInstance->Put(L"InstanceName", 0, &varName, NULL);
            }
        }
    }
    else
    {
        hr = SetClassName(wName);
    }
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::GetInstanceName(WCHAR *& p)
{
    CVARIANT vValue;

    HRESULT hr = m_pClass->Get(L"InstanceName", 0, &vValue, NULL, NULL);		
	if( SUCCEEDED(hr) )
    {
		if( vValue.GetStr() )
        {	        	
			int nlen = wcslen(vValue.GetStr());
            p = new WCHAR [nlen + 4];
            if( p )
            {
                hr = StringCchCopyW(p,nlen+4,vValue.GetStr());
            }
            else
            {
                hr = WBEM_E_UNEXPECTED;
            } 
        }
    }
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::GetPropertiesInIDOrder ( BOOL fHiPerf, UINT uStartIndex )
{
    HRESULT hr = S_OK;
    //============================================
    //  If the pointer is NOT = to NULL, then this
    //  means we haven't released the previous one
    //  return FALSE, to prevent memory leaks
    //============================================
    if( !m_pCurrentProperty )
    {
	    m_pCurrentProperty = new CWMI_IDOrder(m_pClass,m_pAccess);
	    if( m_pCurrentProperty )
        {
            try
            {
			    hr = m_pCurrentProperty->GetPropertiesInIDOrder ( fHiPerf, uStartIndex ) ;
			    if( hr != S_OK )
                {
                    SAFE_DELETE_PTR(m_pCurrentProperty);
			    }
		    }
            catch(...)
            {
                hr = WBEM_E_UNEXPECTED;
                SAFE_DELETE_PTR(m_pCurrentProperty);
                throw;
            }
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// NAME			GetQualifierString (takes a class name)
// PURPOSE		Gets a qualifier value and returns it as a wide char string
// WRAPPER		High level
//
// PARAMETERS	(1) [in] Pointer to an existing IWbemClassObject
//				(2) [in] Pointer to a Property Name string 
//				(3) [in] Pointer to a Qualifier Name 
//				(4) [in\out] Pointer to an external character buffer
//
// RETURNS		Success:  S_OK
//				Failure:  non zero value
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::GetQualifierString( WCHAR * ppwcsPropertyName, 
     						                WCHAR * pwcsQualifierName, 
                                            WCHAR * pwcsExternalOutputBuffer,
											int nSize )
{
	CVARIANT vQual;
	HRESULT hr = GetQualifierValue( ppwcsPropertyName, pwcsQualifierName, (CVARIANT*)&vQual);
    if (WBEM_S_NO_ERROR == hr)
    {
		if(vQual.GetType() != VT_BSTR)
        {		
    		VariantChangeType(&vQual, &vQual, 0, VT_BSTR);
		}
		int nTmp=wcslen(V_BSTR(&vQual));
		if( nTmp > nSize )
        {
			hr = WBEM_E_BUFFER_TOO_SMALL;
		}
		else
        {
	    	hr = StringCchCatW(pwcsExternalOutputBuffer, nSize, V_BSTR(&vQual));
		}
	}
	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::GetQualifierValue( WCHAR * ppwcsPropertyName, WCHAR * pwcsQualifierName, CVARIANT * vQual )
{
	IWbemClassObject * pClass = NULL;
    IWbemQualifierSet * pIWbemQualifierSet = NULL;

	HRESULT hr = WBEM_E_INVALID_PARAMETER;
	BOOL bDone = FALSE;


	if ( m_pClass )
	{
		CBSTR cb(L"__GENUS");
		CVARIANT v1;

		if ( SUCCEEDED ( m_pClass->Get(cb, 0, &v1, 0, 0 ) ) )
		{
			if ( V_I4 (&v1) == 1 )
			{
				( pClass = m_pClass ) -> AddRef ();
				bDone = TRUE;
			}
		}
	}

	if ( !bDone )
	{
		CBSTR cbstr(m_pwcsClassName);

		if ( WBEM_S_NO_ERROR == REPOSITORY->GetObject(cbstr, 0, CONTEXT, &pClass, NULL) )
		{
			bDone = TRUE;
		}
	}

	if ( bDone )
	{
		if(ppwcsPropertyName)
		{
			hr = pClass->GetPropertyQualifierSet(ppwcsPropertyName, &pIWbemQualifierSet);
		}
		else
		{
			hr = pClass->GetQualifierSet(&pIWbemQualifierSet);
		}
	}

	if ( SUCCEEDED ( hr ) && pIWbemQualifierSet ) 
    {
        long lType = 0L;
		hr = pIWbemQualifierSet->Get(pwcsQualifierName, 0,(VARIANT *) vQual,&lType);
	}

    SAFE_RELEASE_PTR(pIWbemQualifierSet);
    SAFE_RELEASE_PTR(pClass);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::GetPrivilegesQualifer(SAFEARRAY ** psaPrivReq)
{
	IWbemClassObject * pClass = NULL;
    IWbemQualifierSet * pIWbemQualifierSet = NULL;
	CBSTR cbstr(m_pwcsClassName);


	HRESULT hr = REPOSITORY->GetObject(cbstr, 0,CONTEXT, &pClass, NULL);
    if(SUCCEEDED(hr))
    {
        pClass->GetQualifierSet(&pIWbemQualifierSet);
	    if( pIWbemQualifierSet ) {

		    CVARIANT vQual;
            long lType = 0L;

		    hr = pIWbemQualifierSet->Get(L"Privileges", 0, &vQual,&lType);
		    if (SUCCEEDED(hr)){

			    VARIANT *p = (VARIANT *)vQual;
			    SAFEARRAY * psa = V_ARRAY(p);

			    if( !IsBadReadPtr( psaPrivReq, sizeof(SAFEARRAY)))
                {
			        CSAFEARRAY Safe(psa);
			        *psaPrivReq = OMSSafeArrayCreate(VT_BSTR,Safe.GetNumElements());
			        hr = SafeArrayCopy(psa,psaPrivReq );
			        Safe.Unbind();
        		    // Don't need to destroy, it will be destroyed
                }
		    }
            SAFE_RELEASE_PTR(pIWbemQualifierSet);
        }
	}

    SAFE_RELEASE_PTR(pClass);
	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::GetGuid(void)
{
	WCHAR pwcsGuidString[128];
    HRESULT hr = S_OK;

	//=======================================
	//  Initialize ptrs we will need
	//=======================================
    if( m_wHardCodedGuid ){
        hr = StringCchCopyW( pwcsGuidString, 128, WMI_BINARY_MOF_GUID );
    }
    else{
        memset(pwcsGuidString,NULL,128);
	    hr = GetQualifierString( NULL, L"guid", pwcsGuidString,128);
    }
	if(SUCCEEDED(hr))
    {  
        //===========================================================
        //  Set the GUID first, before we try to open the WMI
        //  data block, if succeeds, then open WMI
	    //===========================================================
        if( !SetGuid(pwcsGuidString,m_Guid) )
        {
            hr = WBEM_E_FAILED;
        }
    }
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::SetClass(WCHAR * wcsClass)
{
    HRESULT hr = WBEM_E_FAILED;
    if( wcsClass )
    {
        hr = SetClassName(wcsClass);
        if( SUCCEEDED(hr))
        {
			CBSTR cbstr(m_pwcsClassName);

            hr = m_pWMI->Repository()->GetObject(cbstr,0,CONTEXT,&m_pClass, NULL);
            if( hr == S_OK )
            {
                hr = GetGuid();
				// If there is no GUID for the class then set proper error message
				if(hr == WBEM_E_NOT_FOUND)
				{
					hr = WBEM_E_NOT_SUPPORTED;
				}
                if( SUCCEEDED(hr))
                {
                    //===========================================================
                	// Get the IWbemObjectAccess interface for the object
	                // ==========================================================
                    if( m_fHiPerf )
                    {
            	        hr = m_pClass->QueryInterface(IID_IWbemObjectAccess, (PVOID*)&m_pAccess);
                    }
                    if( SUCCEEDED(hr))
                    {
                        hr = GetPropertiesInIDOrder(m_fHiPerf);
                    }
                }
            }
        }
    }
	return hr;
}
//=============================================================
//=============================================================
HRESULT CWMIProcessClass::SetClassName(WCHAR * pIn )
{
    SAFE_DELETE_ARRAY(m_pwcsClassName); 
    return AllocAndCopy(pIn,&m_pwcsClassName);
}
//=============================================================
HRESULT CWMIProcessClass::SetClass ( IWbemClassObject * pPtr, UINT uStartIndex )
{
    HRESULT hr = WBEM_E_FAILED;

    if( pPtr )
    {
		//
		// as this is input we must addref due to releasing in
		// class destructor as well as in the caller
		//
        ( m_pClass = pPtr ) -> AddRef () ;

		CVARIANT vName;
        hr = m_pClass->Get(L"__CLASS", 0, &vName, NULL, NULL);		
        if( hr == S_OK )
        {
            hr = SetClassName(vName.GetStr());
            if( SUCCEEDED(hr))
            {
       		    hr = GetPropertiesInIDOrder ( FALSE, uStartIndex );
            }
        }
    }
	return hr;
}
//=============================================================
HRESULT CWMIProcessClass::SetAccess(IWbemObjectAccess * pPtr)
{
    HRESULT hr = WBEM_E_FAILED;

    if( pPtr )
    {
        SAFE_RELEASE_PTR(m_pAccess);
        SAFE_RELEASE_PTR(m_pClass);

        m_pAccess = pPtr;
        m_pAccess->AddRef();

        CVARIANT vName;
        hr = m_pAccess->Get(L"__CLASS", 0, &vName, NULL, NULL);		
        if( SUCCEEDED(hr))
        {
            hr = SetClassName(vName.GetStr());
            if( hr == S_OK )
            {
				CBSTR cbstr(m_pwcsClassName);

            	hr = REPOSITORY->GetObject(cbstr, 0,CONTEXT, &m_pClass, NULL);
                if( SUCCEEDED(hr))
                {
                    hr = GetGuid();
                    if( SUCCEEDED(hr))
                    {
       		            hr = GetPropertiesInIDOrder(TRUE);
                    }
                }
            }
        }
    }
	return hr;
}
//=============================================================
HRESULT CWMIProcessClass::SetClassPointerOnly(IWbemClassObject * pPtr)
{
    HRESULT hr = WBEM_E_FAILED;

    if( pPtr )
    {
        SAFE_RELEASE_PTR(m_pClass);
        m_pClass = pPtr;
		m_pClass->AddRef();
		hr = S_OK;
	}
    return hr;
}
//=============================================================
void CWMIProcessClass::SaveEmbeddedClass(CVARIANT & v)
{
	IDispatch * pAlterEgo = NULL;
	m_pClassInstance->QueryInterface(IID_IUnknown, (void**)&pAlterEgo);
	// VariantClear will call release()
	v.SetUnknown(pAlterEgo);
}
//=============================================================
HRESULT CWMIProcessClass::ReadEmbeddedClassInstance( IUnknown * pUnknown, CVARIANT & v )
{
    HRESULT hr = WBEM_E_FAILED;
    //=============================================
    //  Get the class
    //=============================================
	IUnknown * pUnk = NULL;
	if( pUnknown )
    {
		pUnk = pUnknown;
	}
	else
    {
		pUnk = v.GetUnknown();
	}

	IWbemClassObject * pClass = NULL;
	if( pUnk )
    {
		pUnk->QueryInterface(IID_IWbemClassObject,(void**) &pClass );
		if( pClass )
        {
            //===============================================
            // Get class definition, so we need to get the
            // class name
            CVARIANT vName;
            CAutoWChar wcsClassName(_MAX_PATH+2);
			if( wcsClassName.Valid() )
			{
				hr = pClass->Get(L"__CLASS", 0, &vName, NULL, NULL);		
				if( hr == S_OK )
				{
					if ( SUCCEEDED ( hr = StringCchCopyW( wcsClassName, _MAX_PATH+2, vName.GetStr() ) ) )
					{
            			hr = SetClass(wcsClassName);
						if( S_OK == hr )
						{
							hr = SetClassPointerOnly(pClass);
						}
					}
				}
			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
        }
    }
    SAFE_RELEASE_PTR( pClass );

    return hr;
}
//=======================================================================
int CWMIProcessClass::PropertyCategory()
{
  	if (!(m_pCurrentProperty->PropertyType() & CIM_FLAG_ARRAY) )
    {
		if( m_pCurrentProperty->PropertyType() == VT_UNKNOWN )
        {
            return CWMIProcessClass::EmbeddedClass;
		}
		else
        {
            return CWMIProcessClass::Data;
		}
	}
	else
    {
        return CWMIProcessClass::Array;
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::InitializeEmbeddedClass(CWMIProcessClass * p)
{
   SetWMIPointers(p);
   return SetClass(p->EmbeddedClassName());
}

//=======================================================================
HRESULT CWMIProcessClass::GetLargestDataTypeInClass(int & nSize)
{
    HRESULT hr = WBEM_E_FAILED;
    WCHAR * pwcsProperty;
    BOOL fClassContainsAnotherDataTypeBesidesAnEmbeddedClass = FALSE;
    int nNewSize = 0L;

    nSize = 0L;
    //=========================================================
    //  Get size of largest data type within the class and 
    //  align it on that, however, if the class contains an 
    //  embedded class ONLY, then get the size of the largest 
    //  datatype within that embedded class.
    //=========================================================
    pwcsProperty = FirstProperty();

    while (NULL != pwcsProperty)
    {
        switch( PropertyCategory())
        {
            case CWMIProcessClass::EmbeddedClass:
                {
                    if( !fClassContainsAnotherDataTypeBesidesAnEmbeddedClass ){
                        CWMIProcessClass EmbeddedClass(0);
						
						hr = EmbeddedClass.Initialize();
						if( S_OK == hr )
						{
							hr = EmbeddedClass.InitializeEmbeddedClass(this);
     						if( hr != S_OK ){
								break;
							}

							// embedded object
							hr = EmbeddedClass.GetLargestDataTypeInClass(nNewSize);
							if( hr != S_OK ){
								break;
							}
						}
                    }
                }
   		        break;

            case CWMIProcessClass::Array:
            case CWMIProcessClass::Data:
                fClassContainsAnotherDataTypeBesidesAnEmbeddedClass = TRUE;
           	    nNewSize = PropertySize();
	            break;
        }

		if( nNewSize == SIZEOFWBEMDATETIME ){
			nNewSize = 1;
		}

        if( nNewSize > nSize ){
            nSize = nNewSize;
        }

        pwcsProperty = NextProperty();
		hr = WBEM_S_NO_ERROR;
    }

    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIProcessClass::GetSizeOfArray(long & lType, DWORD & dwCount, BOOL & fDynamic)
{
	HRESULT  hr = WBEM_E_OUT_OF_MEMORY;
    CAutoWChar pwcsArraySize(_MAX_PATH+2);

	if( pwcsArraySize.Valid() )
	{
		dwCount = 0;
		lType = m_pCurrentProperty->PropertyType() &~  CIM_FLAG_ARRAY;
		
		pwcsArraySize[0]=NULL;
		//======================================================
		// Get the number of elements in the array from the 			
		// "ArraySize" property qualifier
		//======================================================
		hr = GetQualifierString(m_pCurrentProperty->PropertyName(), L"MAX",pwcsArraySize, MAX_PATH);
		if( hr == S_OK )
		{
			dwCount = _wtol(pwcsArraySize);
		}
		else
		{
			hr = GetQualifierString(m_pCurrentProperty->PropertyName(),L"WMISizeIs",pwcsArraySize,MAX_PATH);
			if( hr == S_OK )
			{
				CVARIANT var;
				CIMTYPE lTmpType;
				hr = WBEM_E_FAILED;

				fDynamic = TRUE;

				if( m_pClassInstance )
				{
					hr = m_pClassInstance->Get(pwcsArraySize, 0, &var, &lTmpType,NULL);		
				}
				else
				{
					if( m_pClass )
					{
						hr = m_pClass->Get(pwcsArraySize, 0, &var, &lTmpType,NULL);
					}
				}
				if( hr == S_OK )
				{
           			CWMIDataTypeMap MapIt;
					dwCount = MapIt.ArraySize(lTmpType,var);
				}
			}
		}

		//==============================================================================
		//  If all else fails, get the size of the array from the class definition.
		//==============================================================================
		if( hr != S_OK )
		{
    		dwCount = m_pCurrentProperty->ArraySize();
			hr = S_OK;
		}
	}
    return hr;
}        
//======================================================================
HRESULT CWMIProcessClass::GetSizeOfClass(DWORD & dwSize)
{
    HRESULT hr = WBEM_E_FAILED;
    WCHAR * pwcsProperty;

    dwSize = 0;

    pwcsProperty = FirstProperty();

    while (NULL != pwcsProperty)
    {
        switch( PropertyCategory())
        {
            case CWMIProcessClass::EmbeddedClass:
                {
                    DWORD dwEmbeddedSize;
                    CWMIProcessClass EmbeddedClass(0);

					hr = EmbeddedClass.Initialize();
					if( S_OK == hr )
					{
						hr = EmbeddedClass.InitializeEmbeddedClass(this);
						if( hr != S_OK ){
							break;
						}
						// embedded object
						hr = EmbeddedClass.GetSizeOfClass(dwEmbeddedSize);
						if( hr != S_OK ){
							break;
						}
						dwSize += dwEmbeddedSize;
					}
                }
   		        break;

            case CWMIProcessClass::Array:
                {
            	    int nSize = PropertySize();
                    dwSize += (nSize *  ArraySize());
                }
	            break;

            case CWMIProcessClass::Data:
                dwSize += PropertySize();
	            break;
        }
        pwcsProperty = NextProperty();
		hr = WBEM_S_NO_ERROR;
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////

ULONG CWMIProcessClass::GetMethodId(LPCWSTR strProp)
{
	ULONG uMethodId = 0;
	IWbemQualifierSet * pIWbemQualifierSet = NULL;
	
	//======================================================
	// Get the number of elements in the array from the 			
	// "ArraySize" property qualifier
	//======================================================
    HRESULT hr = m_pClass->GetMethodQualifierSet(strProp,&pIWbemQualifierSet);
	if( SUCCEEDED(hr) )
    {
        CVARIANT v;
		hr = pIWbemQualifierSet->Get(L"WMIMethodId", 0, &v, 0);
		if( SUCCEEDED(hr))
        {
            uMethodId = v.GetLONG();
		}
        SAFE_RELEASE_PTR(pIWbemQualifierSet);
    }
    return uMethodId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\wmicom.h ===
//***************************************************************************
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#ifndef _WMICOM_HEADER
#define _WMICOM_HEADER

#define THISPROVIDER LOG_WIMPROV

///////////////////////////////////////////////////////////////////////
// Forward declarations
///////////////////////////////////////////////////////////////////////

class CWMIManagement;
class CWMIDataBlock;
class CWMIProcessClass;
class CNamespaceManagement;

#define FROM_DATA_BLOCK 1
#define FROM_INITIALIZATION 2
#define RUNTIME_BINARY_MOFS_ADDED L"RuntimeBinaryMofsAdded"
#define RUNTIME_BINARY_MOFS_DELETED L"RuntimeBinaryMofsDeleted"

///////////////////////////////////////////////////////////////////////

//#pragma warning( disable : 4005 )				
#include <objbase.h>
//#pragma warning( default : 4005 )				
// kill warning:  "nonstandard extension ...
//#pragma warning( disable : 4200 )				
#include "wmi\wmium.h"
//#pragma warning( default : 4200 )				

#include <wbemint.h>
#include <wchar.h>
#include <wbemidl.h>
#include <GENLEX.H>
#include <OPATHLEX.H>
#include <OBJPATH.H>
#include <flexarry.h>
#include <oahelp.inl>
#include <mofcomp.h>
#include <wbemutil.h>
#include <cominit.h>

#define SERVICES	m_pWMI->Services()
#define REPOSITORY	m_pWMI->Repository()
#define CONTEXT		m_pWMI->Context()
#define HANDLER		m_pWMI->Handler()

SAFEARRAY * OMSSafeArrayCreate( IN VARTYPE vt, IN int iNumElements);
#define WMI_BINARY_MOF_GUID L"{05901221-D566-11d1-B2F0-00A0C9062910}"




///////////////////////////////////////////////////////////////////////
//  Defines
/////////////////////////////////////////////////////////////////////
#define SAFE_DELETE_PTR(pv)  \
	{ if(pv) delete pv;  \
      pv = NULL; }

#define SAFE_RELEASE_PTR(pv)  \
{   if(pv){  pv->Release(); }  \
      pv = NULL; }

#define SAFE_DELETE_ARRAY(pv)  \
	{ if(pv) delete []pv;  \
      pv = NULL; }
#define GUID_SIZE 128
#define NAME_SIZE 256*2
#define ProcessOneFixedInstance 1
#define ProcessUnfixedInstance  2
#define NoMore                  3
#define MEMSIZETOALLOCATE       512
#define MSG_SIZE				512
#define INTERNAL_EVENT 5
#define PERMANENT_EVENT 6
#define SIZEOFWBEMDATETIME sizeof(WCHAR)*25
#define WMI_NO_MORE 0x80044001
#define PUT_WHOLE_INSTANCE           0
#define PUT_PROPERTIES_ONLY          1
#define PUT_PROPERTIES_IN_LIST_ONLY  2
#define WMI_RESOURCE_MOF_ADDED_GUID L"{B48D49A2-E777-11D0-A50C-00A0C9062910}"
#define WMI_RESOURCE_MOF_REMOVED_GUID L"{B48D49A3-E777-11d0-A50C-00A0C9062910}"

#define MSG_DATA_INSTANCE_NOT_FOUND L"The instance name passed was not recognized as valid"
#define MSG_DATA_NOT_AVAILABLE L"The WDM data block is no longer available."
#define MSG_SUCCESS L"Operation completed successfully"
#define MSG_INVALID_BLOCK_POINTER L"WDM Buffer size and actual size of data do not match"
#define MSG_DRIVER_ERROR L"WDM specific error code: 4209 (Driver specific error, driver could not complete request)"
#define MSG_READONLY_ERROR L"WDM specific error code: 4213 (The WDM data item or data block is read-only)"
#define MSG_ARRAY_ERROR L"Array is the wrong size"
#define IDS_ImpersonationFailedWide L"Impersonation failed - Access denied\n"
#define IDS_ImpersonationFailed "Impersonation failed - Access denied\n"

#define ANSI_MSG_DATA_INSTANCE_NOT_FOUND "The instance name passed was not recognized as valid"
#define ANSI_MSG_DRIVER_ERROR "WDM specific error code: 4209 (Driver specific error, driver could not complete request)"
#define ANSI_MSG_INVALID_PARAMETER "Invalid Parameter"
#define ANSI_MSG_INVALID_DATA "Invalid Data"
#define ANSI_MSG_INVALID_NAME_BLOCK "Invalid Name Block"
#define ANSI_MSG_INVALID_DATA_BLOCK "Invalid Data Block"
#define ANSI_MSG_ACCESS_DENIED "Access Denied"

#define MOF_ADDED   1
#define MOF_DELETED 2
#define STANDARD_EVENT 0

//************************************************************************************************************
//============================================================================================================
//
//   The Utility Functions
//
//============================================================================================================
//************************************************************************************************************
BOOL IsBinaryMofResourceEvent(LPOLESTR pGuid, GUID gGuid);
bool IsNT(void);
BOOL GetUserThreadToken(HANDLE * phThreadTok);
void TranslateAndLog( WCHAR * wcsMsg, BOOL bVerbose = FALSE );
BOOL SetGuid(WCHAR * wcsGuid, CLSID & Guid);
HRESULT AllocAndCopy(WCHAR * wcsSource, WCHAR ** pwcsDest );

HRESULT CheckIfThisIsAValidKeyProperty(WCHAR * wcsClass, WCHAR * wcsProperty, IWbemServices * p);
HRESULT GetParsedPath( BSTR ObjectPath,WCHAR * wcsClass, int cchSizeClass, WCHAR * wcsInstance, int cchSizeInstance, IWbemServices * p );
BOOL GetParsedPropertiesAndClass( BSTR Query,WCHAR * wcsClass, int cchSize );


//************************************************************************************************************
//============================================================================================================
//
//   The Utility Classes / struct definitions
//
//============================================================================================================
//************************************************************************************************************
class CAutoWChar
{
    WCHAR * m_pStr;
public:
    CAutoWChar(int nSize)    { m_pStr = new WCHAR[nSize+1]; if( m_pStr ) memset( m_pStr,NULL,nSize+1); }
   ~CAutoWChar()             { SAFE_DELETE_ARRAY(m_pStr);}
    BOOL Valid()			 { if( !m_pStr ) return FALSE;  return TRUE; }
    operator PWCHAR()		 { return m_pStr; }
};
///////////////////////////////////////////////////////////////////////

class CCriticalSection
{
    public:		
        CCriticalSection() : m_bInitialized ( FALSE )
		{
		}
        ~CCriticalSection() 	    {  }
        inline BOOL Init()          {
										m_bInitialized = InitializeCriticalSectionAndSpinCount(&m_criticalsection, 0);
										return m_bInitialized ;
									}
        inline void Delete()        {
										if ( m_bInitialized )
										{
											DeleteCriticalSection(&m_criticalsection);
											m_bInitialized = FALSE;
										}
									}
        inline BOOL TryEnter()         { return TryEnterCriticalSection(&m_criticalsection); }

        inline void Enter()         { EnterCriticalSection(&m_criticalsection); }
        inline void Leave()         { LeaveCriticalSection(&m_criticalsection); }

		BOOL IsValid () { return m_bInitialized; }
    private:
	    CRITICAL_SECTION	m_criticalsection;			// standby critical section
		BOOL				m_bInitialized;				// validity flag
};

///////////////////////////////////////////////////////////////////////
class CAutoBlock
{
    private:

	    CCriticalSection *m_pCriticalSection;

    public:

        CAutoBlock(CCriticalSection *pCriticalSection)
        {
	        m_pCriticalSection = NULL;
	        if(pCriticalSection)
            {
		        pCriticalSection->Enter();
            }
	        m_pCriticalSection = pCriticalSection;
        }

        ~CAutoBlock()
        {
	        if(m_pCriticalSection)
		        m_pCriticalSection->Leave();

        }
};
typedef struct _AccessList
{
    CFlexArray m_List;
    HRESULT Add(IWbemObjectAccess * pPtr)
	{
		HRESULT hr = S_OK;
		pPtr->AddRef();
		if(CFlexArray::out_of_memory == m_List.Add(pPtr))
		{
			pPtr->Release();
			hr = E_OUTOFMEMORY;
		}

		return hr;
	}
    inline long Size()                 { return m_List.Size(); }
    inline void ** List()              { return m_List.GetArrayPtr(); }

    _AccessList()   {}
    ~_AccessList(); // code elsewhere

}AccessList;

typedef struct _IdList
{
    CFlexArray m_List;
	// 170635
    HRESULT Add( ULONG_PTR l)
	{
		HRESULT hr = S_OK;
		ULONG_PTR * lp = new ULONG_PTR;
		if(lp)
		{
			*lp = l;
			if(CFlexArray::out_of_memory == m_List.Add(lp))
			{
				SAFE_DELETE_PTR(lp);
				hr = E_OUTOFMEMORY;
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
		return hr;
	}

    inline long Size()               { return m_List.Size(); }
    inline void ** List()            { return m_List.GetArrayPtr(); }

    _IdList() {}
    ~_IdList();   // code elsewhere

} IdList;

typedef struct _HandleList
{
    CFlexArray m_List;
	// 170635
    HRESULT Add( HANDLE l )
	{
		HRESULT hr = S_OK;
		HANDLE * lp = new HANDLE;
		if(lp)
		{
			*lp = l;
			if(CFlexArray::out_of_memory == m_List.Add(lp))
			{
				SAFE_DELETE_PTR(lp);
				hr = E_OUTOFMEMORY;
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
		return hr;
	}

    inline long Size()               { return m_List.Size(); }
    inline void ** List()            { return m_List.GetArrayPtr(); }

    _HandleList() {}
    ~_HandleList();   // code elsewhere

} HandleList;

typedef struct _KeyList
{
    CWStringArray m_List;

    // ================================================================
    // Appends a new element to the end of the array. Copies the param.
    // ================================================================
    int Add(WCHAR * pStr)
	{
		return m_List.Add( pStr );
	}

    // ================================================================
    // Locates a string or returns -1 if not found.
    // ================================================================
	int Find(WCHAR * pStr)
	{
		int nFlags = 0;
		return m_List.FindStr( pStr, nFlags );
	}

    // ================================================================
    // Removes a string
    // ================================================================
	HRESULT Remove(WCHAR * pStr)
	{
		int nIndex = Find(pStr);
		if( nIndex > -1 )
		{
			m_List.RemoveAt( nIndex );
		}
		return S_OK;
	}
    // ================================================================
    // Removes a string
    // ================================================================
	BOOL OldDriversLeftOver()
	{
		if( m_List.Size() > 0 )
		{
			return TRUE;
		}
		return FALSE;
	}

    // ================================================================
	// Get how many are in there
    // ================================================================
	int GetSize()
	{
		return m_List.Size();
	}

    // ================================================================
	// Get at a specific position
    // ================================================================
	WCHAR * GetAt(int n)
	{
		return m_List.GetAt(n);
	}
    _KeyList() {}
    ~_KeyList(){}
	
} KeyList;

typedef struct _InstanceList
{
    CFlexArray m_List;
	// 170635
    HRESULT Add( WCHAR * p )
	{
		HRESULT hr = S_OK;
		WCHAR * pNew = NULL;
		if(SUCCEEDED(hr = AllocAndCopy(p, &pNew)))
		{
			if(CFlexArray::out_of_memory == m_List.Add(pNew))
			{
				hr = E_OUTOFMEMORY;
				SAFE_DELETE_ARRAY(pNew);
			}
		}
		return hr;
	}

    inline long Size()           { return m_List.Size(); }
    inline void ** List()        { return m_List.GetArrayPtr(); }

    _InstanceList() {}
    ~_InstanceList();   // code elsewhere

} InstanceList;

typedef struct _OldClassInfo
{
    WCHAR * m_pClass;
    WCHAR * m_pPath;

    _OldClassInfo() { m_pClass = m_pPath = NULL; }
    ~_OldClassInfo();   // code elsewhere
} OldClassInfo;

typedef struct _OldClassList
{
    CFlexArray m_List;

    HRESULT Add( WCHAR * pClass, WCHAR * pPath )       
	{  
		HRESULT hr = S_OK;

		if ( !pClass )
		{
			return WBEM_E_INVALID_PARAMETER;
		}
		if ( !pPath)
		{
			return WBEM_E_INVALID_PARAMETER;
		}

        OldClassInfo * pInfo = new OldClassInfo;
        if( pInfo )
        {
	        if(SUCCEEDED(hr = AllocAndCopy(pClass, &(pInfo)->m_pClass)))
	        {
    	        if(SUCCEEDED(hr = AllocAndCopy(pPath, &(pInfo)->m_pPath)))
	            {
    		        if(CFlexArray::out_of_memory == m_List.Add(pInfo)) 
	    	        {
		    	        hr = E_OUTOFMEMORY;
			            SAFE_DELETE_PTR(pInfo);
			        }
                }
	        }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
		return hr;
	}

    WCHAR * GetClass( int nIndex )       
	{  
		HRESULT hr = S_OK;
        OldClassInfo * pInfo = NULL;

        pInfo = (OldClassInfo *) m_List[nIndex];
        return pInfo->m_pClass;
	}

    WCHAR * GetPath( int nIndex )       
	{  
		HRESULT hr = S_OK;
        OldClassInfo * pInfo = NULL;

        pInfo = (OldClassInfo *)m_List[nIndex];
        return pInfo->m_pPath;
	}

    inline long Size()           { return m_List.Size(); }
    inline void ** List()        { return m_List.GetArrayPtr(); }

    _OldClassList() {}
    ~_OldClassList();   // code elsewhere

} OldClassList;

//
// IGlobalInterfaceTable
//

extern IGlobalInterfaceTable * g_pGIT;

//
// GlobalInterfaceTable
//

template <class Itf, const IID* piid>
class GlobalInterfaceTable
{
	DWORD m_dwCookie; // the GIT cookie

	GlobalInterfaceTable(const GlobalInterfaceTable&);
	void operator =(const GlobalInterfaceTable&);

	// revoke an interface pointer in GIT
	HRESULT Unglobalize(void)
	{
		HRESULT hr = g_pGIT->RevokeInterfaceFromGlobal(m_dwCookie);
		m_dwCookie = 0;

		return hr;
	}

	public:

	// start with invalid cookie
	GlobalInterfaceTable() 
	  : m_dwCookie(0)
	{
	}

	// auto-unglobalize
	~GlobalInterfaceTable(void) 
	{
		if (m_dwCookie)
		{
			Unglobalize();
		}
	}

	// register an interface pointer in GIT
	HRESULT Globalize(Itf *pItf)
	{
		HRESULT hr = E_UNEXPECTED;
		if ( m_dwCookie )
		{
#ifdef	DBG
			DebugBreak();
#endif	DBG
		}
		else
		{
			if ( pItf )
			{
				hr = g_pGIT->RegisterInterfaceInGlobal(pItf, *piid, &m_dwCookie);
			}
			else
			{
				hr = S_FALSE;
			}
		}

		return hr;
	}

	// get a local interface pointer from GIT
	HRESULT Localize(Itf **ppItf) const
	{
	  return g_pGIT->GetInterfaceFromGlobal(m_dwCookie, *piid,(void**)ppItf);
	}
};
#define GIP(Itf) GlobalInterfaceTable<Itf, &IID_##Itf>

typedef struct _WMIEventRequest
{
    DWORD dwId;
    WCHAR wcsGuid[GUID_SIZE];
    WCHAR * pwcsClass;
	BOOL fHardCoded;
    CLSID gGuid;
    IWbemObjectSink __RPC_FAR * pHandler;
	GIP(IWbemServices)   gipServices;
	GIP(IWbemServices)   gipRepository;
	IWbemContext __RPC_FAR *    pCtx;

    _WMIEventRequest();
    ~_WMIEventRequest();
    HRESULT AddPtrs	(
						IWbemObjectSink __RPC_FAR * pHandler,
						IWbemServices __RPC_FAR * Services,
						IWbemServices __RPC_FAR * Repository,
						IWbemContext __RPC_FAR *    pCtx
					);
    BOOL SetClassName( WCHAR * p )   { SAFE_DELETE_ARRAY(pwcsClass); return SUCCEEDED(AllocAndCopy( p, &pwcsClass)) ? TRUE : FALSE; }

} WMIEventRequest;

typedef struct _WMIHandleMap
{
	HANDLE              WMIHandle;
    GUID                Guid;
	ULONG	            uDesiredAccess;
    LONG                RefCount;

    void AddRef();
    LONG Release();
    _WMIHandleMap()              { WMIHandle = 0; uDesiredAccess = 0; RefCount = 0; }
    ~_WMIHandleMap()        {  }

}WMIHandleMap;

typedef struct _WMIHiPerfHandleMap
{
    WMIHANDLE           WMIHandle;
    ULONG_PTR           lHiPerfId;
    BOOL                m_fEnumerator;
    CWMIProcessClass    * m_pClass;
    IWbemHiPerfEnum     * m_pEnum;

    _WMIHiPerfHandleMap(CWMIProcessClass * p, IWbemHiPerfEnum * pEnum);
    ~_WMIHiPerfHandleMap();

}WMIHiPerfHandleMap;


typedef struct _IDOrder
{
    WCHAR * pwcsPropertyName;
    WCHAR * pwcsEmbeddedObject;
    long    lType;
    int     nWMISize;
    long    lHandle;
    DWORD   dwArraySize;
    BOOL    fPutProperty;

	//
	// recognize that item was set
	//
	BOOL bIsDirty ;

    _IDOrder()                          { pwcsPropertyName = NULL; pwcsEmbeddedObject = NULL; lType = 0L; nWMISize = 0; lHandle = 0L; dwArraySize = 0; fPutProperty = FALSE; bIsDirty = FALSE; }
    ~_IDOrder()                         { SAFE_DELETE_PTR(pwcsPropertyName); SAFE_DELETE_PTR(pwcsEmbeddedObject); bIsDirty = FALSE; }
    BOOL SetPropertyName( WCHAR * p )   { SAFE_DELETE_PTR(pwcsPropertyName);  return SUCCEEDED(AllocAndCopy( p, &pwcsPropertyName)) ? TRUE : FALSE; }
    BOOL SetEmbeddedName( WCHAR * p )   { SAFE_DELETE_PTR(pwcsEmbeddedObject);return SUCCEEDED(AllocAndCopy( p, &pwcsEmbeddedObject)) ? TRUE : FALSE; }

} IDOrder;

///////////////////////////////////////////////////////////////////////
class CAutoChangePointer
{
    private:
        CWMIProcessClass * m_pTmp;
        CWMIProcessClass ** m_pOriginal;
    public:
        CAutoChangePointer(CWMIProcessClass ** ppOriginal, CWMIProcessClass * pNew)
        { m_pTmp = *ppOriginal; m_pOriginal = ppOriginal; *ppOriginal = pNew; }

        ~CAutoChangePointer()
        { *m_pOriginal = m_pTmp; }
};

//************************************************************************************************************
//============================================================================================================
//
//   The Common Base Classes
//
//============================================================================================================
//************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Common functions regarding binary mof processing & security
//
///////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
class CHandleMap
{
    protected:

        CFlexArray           m_List;
        CCriticalSection     m_HandleCs;

	private:

		BOOL				m_Initialized ;

    public:

		BOOL				IsValid ()
		{
			return m_Initialized ;
		}

        CHandleMap()    {  m_Initialized = m_HandleCs.Init(); }
        ~CHandleMap()   
		{
			CloseAllOutstandingWMIHandles() ;

			if ( m_HandleCs.IsValid () ) 
			{
				m_HandleCs.Delete() ;
			}
		}

        inline CCriticalSection * GetCriticalSection()      { return (CCriticalSection*)&m_HandleCs;}
        HRESULT Add(CLSID Guid, HANDLE hCurrent, ULONG uDesiredAccess);

        int ExistingHandleAlreadyExistsForThisGuidUseIt(CLSID Guid, HANDLE & hCurrentWMIHandle, BOOL & fCloseHandle, ULONG uDesiredAccess);
        void CloseAllOutstandingWMIHandles();
        int ReleaseHandle( HANDLE hCurrentWMIHandle );
        int GetHandle(CLSID Guid, HANDLE & hCurrentWMIHandle );
 };
///////////////////////////////////////////////////////////////////////
class CHiPerfHandleMap : public CHandleMap
{
    private:
        int m_nIndex;

    public:

        CHiPerfHandleMap() {    m_nIndex = 0; }
        ~CHiPerfHandleMap(){CloseAndReleaseHandles();}

        HRESULT Delete( HANDLE & hCurrent, ULONG_PTR lHiPerfId );
        HRESULT Add( HANDLE hCurrent, ULONG_PTR lHiPerfId, CWMIProcessClass * p, IWbemHiPerfEnum * pEnum );

        HRESULT FindHandleAndGetClassPtr( HANDLE & lWMIHandle, ULONG_PTR lHiPerfId,CWMIProcessClass *& p);
        HRESULT GetFirstHandle(HANDLE & hCurrent,CWMIProcessClass *& p, IWbemHiPerfEnum *& pEnum);
        HRESULT GetNextHandle(HANDLE & hCurrent,CWMIProcessClass *& p, IWbemHiPerfEnum *& pEnum);
		void CloseAndReleaseHandles();

};
///////////////////////////////////////////////////////////////////////
class CWMI_IDOrder
{
    private:

        DWORD				m_nTotal;
        DWORD				m_nCurrent;

		IWbemObjectAccess * m_pAccess;
        IWbemClassObject *  m_pClass;

        IDOrder         * m_pWMIDataIdList;

		DWORD   GetSizeOfArray ( LPCWSTR bProp ) ;
        HRESULT ProcessPropertyQualifiers ( LPCWSTR bstrPropName, BOOL fHiPerf, UINT uSizeArray, UINT uStartIndex ) ;

    public:

		CWMI_IDOrder(IWbemClassObject * p, IWbemObjectAccess * p2);
        ~CWMI_IDOrder();

        WCHAR * GetFirstID();
        WCHAR * GetNextID();
        void InitMemberVars();

        HRESULT GetPropertiesInIDOrder ( BOOL HiPerf, UINT uStartIndex );
        inline long PropertyType()          { return m_pWMIDataIdList[m_nCurrent].lType;}
        inline int  PropertySize()          { return m_pWMIDataIdList[m_nCurrent].nWMISize;}
        inline int  ArraySize()             { return m_pWMIDataIdList[m_nCurrent].dwArraySize; }
        inline WCHAR * PropertyName()       { return m_pWMIDataIdList[m_nCurrent].pwcsPropertyName;}
        inline WCHAR * EmbeddedClassName()  { return m_pWMIDataIdList[m_nCurrent].pwcsEmbeddedObject;}
        inline ULONG WMIDataId()            { return m_nCurrent; }
        inline void SetPutProperty(BOOL fV) { m_pWMIDataIdList[m_nCurrent].fPutProperty = fV;}
        inline BOOL GetPutProperty(void)    { return m_pWMIDataIdList[m_nCurrent].fPutProperty;}
        inline LONG GetPropertyHandle()     { return m_pWMIDataIdList[m_nCurrent].lHandle;}

		DWORD GetNumberOfProperties () { return m_nTotal ; }
};
////////////////////////////////////////////////////////////////////

class CWMIManagement
{
    protected:

        IWbemObjectSink __RPC_FAR   * m_pHandler;
        IWbemServices __RPC_FAR     * m_pServices;
        IWbemServices __RPC_FAR     * m_pRepository;
        IWbemContext __RPC_FAR      * m_pCtx;

 		CHandleMap *  m_pHandleMap;
		//======================================================
        //   ************** PUBLIC ********************
		//======================================================
    public:

        CWMIManagement();
        ~CWMIManagement();

        inline IWbemObjectSink __RPC_FAR    * Handler()       { return m_pHandler;}
        inline IWbemServices __RPC_FAR      * Services()      { return m_pServices;}
        inline IWbemServices __RPC_FAR      * Repository()    { return m_pRepository;}
        inline IWbemContext __RPC_FAR       * Context()       { return m_pCtx;}
        inline CHandleMap                   * HandleMap()     { return m_pHandleMap;}

        inline void SetWMIPointers	(
										CHandleMap * pList,
										IWbemServices   __RPC_FAR * pServices,
										IWbemServices   __RPC_FAR * pRepository,
										IWbemObjectSink __RPC_FAR * pHandler,
										IWbemContext __RPC_FAR *pCtx
									)
		{
			m_pHandleMap = pList;
			m_pServices = pServices;
			m_pRepository = pRepository;
			m_pHandler = pHandler;
			m_pCtx = pCtx;
		}

		//==========================================================
        //  THE Event Group
        //==========================================================
         BOOL CancelWMIEventRegistration( GUID gGuid , ULONG_PTR uContext );

		//======================================================
        //  Cleanup Group
		//======================================================
        void CloseAllOutstandingWMIHandles();

		//======================================================
        //  Error message processing/checking access
    	//======================================================

        void SendPrivilegeExtendedErrorObject(HRESULT hrToReturn,WCHAR * wcsClass);
        HRESULT SetErrorMessage(HRESULT hrToReturn, WCHAR * wcsClass, WCHAR * wcsMsg);

    	HRESULT GetListOfUserPrivileges(TOKEN_PRIVILEGES *& ptPriv);
		void ProcessPrivileges(TOKEN_PRIVILEGES *ptPriv, SAFEARRAY *& psaPrivNotHeld, SAFEARRAY * psaPrivReq );

};
////////////////////////////////////////////////////////////////////
class CWMIProcessClass
{
    protected:

        CWMIManagement      * m_pWMI;
        CWMI_IDOrder        * m_pCurrentProperty;
        WCHAR               * m_pwcsClassName;
        IWbemClassObject    * m_pClass;
	    IWbemClassObject    * m_pClassInstance;
        IWbemObjectAccess   * m_pAccess;
        IWbemObjectAccess   * m_pAccessInstance;
        CLSID                 m_Guid;
        WORD                  m_wHardCodedGuid;
        BOOL                  m_fHiPerf;
        BOOL                  m_fGetNewInstance;
		BOOL				  m_fInit;
	
         //=============================================
        //  Private functions
        //=============================================
        void InitMemberVars();
        void ReleaseInstancePointers();
        HRESULT GetPropertiesInIDOrder ( BOOL fHiPerf, UINT uStartIndex = 0 );

    public:

        CWMIProcessClass(BOOL b);
        ~CWMIProcessClass();

        enum __PropertyCategory{  EmbeddedClass = 0,        // For the property categories
                Array = 1,
                Data = 2
        } _PropertyCategory;

		HRESULT Initialize();

         //=============================================
        // inline functions
        //=============================================
        inline BOOL SetHiPerf(BOOL f)                           { return m_fHiPerf = f;}
        inline BOOL GetNewInstance(BOOL f)                      { return m_fGetNewInstance = f;}
        inline CWMIManagement * WMI()                           { return m_pWMI;}
        inline void SetWMIPointers(CWMIProcessClass * p)
		{
			if( m_pWMI )
			{
				m_pWMI->SetWMIPointers	(
											p->WMI()->HandleMap(),
											p->WMI()->Services(),
											p->WMI()->Repository(),
											p->WMI()->Handler(),
											p->WMI()->Context()
										);
			}
		}

        inline CWMIManagement * GetWMIManagementPtr()           { return m_pWMI; }
        inline void SetHardCodedGuidType( WORD wValue )         { m_wHardCodedGuid= wValue; }
        inline WORD GetHardCodedGuidType()                      { return m_wHardCodedGuid;}

        inline CLSID * GuidPtr()                            { return &m_Guid;}
        inline IWbemObjectAccess * GetAccessInstancePtr()   { return m_pAccessInstance; }
        inline WCHAR * EmbeddedClassName()                  { return m_pCurrentProperty->EmbeddedClassName();}
        inline WCHAR * FirstProperty()                      { return m_pCurrentProperty->GetFirstID(); }
        inline WCHAR * NextProperty()                       { return m_pCurrentProperty->GetNextID(); }
        inline int ArraySize()                              { return m_pCurrentProperty->ArraySize(); }
        inline int PropertySize()                           { return m_pCurrentProperty->PropertySize(); }
        inline long PropertyType()                          { return m_pCurrentProperty->PropertyType(); }
        inline WCHAR * GetClassName()                       { return m_pwcsClassName;}
        inline IWbemClassObject * ClassPtr()                { return m_pClass; }
        inline long GetPropertyHandle()                     { return m_pCurrentProperty->GetPropertyHandle(); }

		DWORD GetNumberOfProperties	()						{ return ( m_pCurrentProperty ) ? m_pCurrentProperty->GetNumberOfProperties () : 0 ; }

        //=============================================
        //  Basic class manipulation
        //=============================================
        BOOL GetANewAccessInstance();
        BOOL  GetANewInstance() ;
        inline BOOL  ValidClass()                   { if( m_pClass && m_pCurrentProperty){return TRUE;} return FALSE;}
        int   PropertyCategory();

        HRESULT SetClassName(WCHAR * wcsName);
        HRESULT SetClass(WCHAR * wcsClass);
        HRESULT SetClass ( IWbemClassObject * pPtr, UINT uStartIndex = 0 ) ;
        HRESULT SetAccess(IWbemObjectAccess * pPtr);
        HRESULT SetClassPointerOnly(IWbemClassObject * pPtr);
        HRESULT SetClassPointerOnly(IWbemObjectAccess * pPtr);
        HRESULT GetGuid(void);
        HRESULT SetKeyFromAccessPointer();
        HRESULT GetKeyFromAccessPointer(CVARIANT * v);
        HRESULT InitializeEmbeddedClass(CWMIProcessClass * Em );
         //=============================================
        //  Property manipulation
        //=============================================
        void SetActiveProperty();
        HRESULT SetHiPerfProperties(LARGE_INTEGER TimeStamp) ;


        inline HRESULT PutPropertyInInstance(VARIANT * vToken)
                    { return ( m_pClassInstance->Put(m_pCurrentProperty->PropertyName(), 0, vToken, NULL));}

        inline HRESULT GetPropertyInInstance(WCHAR * pwcsProperty,CVARIANT & vValue, LONG & lType)
                    {  return m_pClass->Get(pwcsProperty, 0, &vValue, &lType, NULL);}
        HRESULT GetSizeOfArray(long & lType, DWORD & dwCount, BOOL & fDynamic);


        //=============================================
        // Embedded classes
        //=============================================
        HRESULT ReadEmbeddedClassInstance( IUnknown * pUnknown, CVARIANT & v );
        HRESULT GetLargestDataTypeInClass(int & nSize);
        void SaveEmbeddedClass(CVARIANT & v);
        HRESULT GetSizeOfClass(DWORD & dwSize);


        //=============================================
        //  Send the instance back to WBEM
        //=============================================
        inline ULONG WMIDataId()            { return m_pCurrentProperty->WMIDataId();}
        inline void SetPutProperty(BOOL fV) { m_pCurrentProperty->SetPutProperty(fV);}
        inline BOOL GetPutProperty()        { return m_pCurrentProperty->GetPutProperty();}

        HRESULT SendInstanceBack();
        HRESULT SetInstanceName(WCHAR * wName,BOOL);
        HRESULT GetInstanceName(WCHAR *& p);

        //=============================================
        //  Class functions, providing access to the
        //  properties, qualifiers in a class.
        //  NOTE:  Properties are in WMI order
        //=============================================

        HRESULT GetQualifierString( WCHAR * pwcsPropertyName, WCHAR * pwcsQualifierName,
                                    WCHAR * pwcsExternalOutputBuffer,int nSize);
		HRESULT GetQualifierValue( WCHAR * pwcsPropertyName, WCHAR * pwcsQualifierName, CVARIANT * vQual);
		HRESULT GetPrivilegesQualifer(SAFEARRAY ** psaPrivReq);

        //=============================================
        //  Methods
        //=============================================
        ULONG GetMethodId(LPCWSTR bProp);
};

//=============================================================
class CWMIDataBlock
{
    protected:
		BOOL					m_fUpdateNamespace;
		BOOL					m_fMofHasChanged;

        CWMIProcessClass        * m_Class;

 		HANDLE					  m_hCurrentWMIHandle;
		BOOL					  m_fCloseHandle;

  		BYTE * m_pbDataBuffer,* m_pbCurrentDataPtr,* m_pbWorkingDataPtr;
        DWORD                   m_dwDataBufferSize;
        ULONG *                 m_upNameOffsets;
		ULONG *					m_pMaxPtr;
		ULONG 					m_ulVersion,m_uInstanceSize;
	    int                     m_nCurrentInstance;
	    int                     m_nTotalInstances;
        BOOL                    m_fFixedInstance;
        PWNODE_SINGLE_INSTANCE  m_pSingleWnode;
        PWNODE_ALL_DATA         m_pAllWnode;
        WNODE_HEADER*           m_pHeaderWnode;
		DWORD                   m_dwCurrentAllocSize;
        DWORD                   m_dwAccumulativeSizeOfBlock;
		BOOL					m_fMore;
		WCHAR                   m_wcsMsg[MSG_SIZE];
        ULONG                   m_uDesiredAccess;


		//======================================================
		//  Initializing member variables
		//======================================================
        void InitMemberVars();
        HRESULT SetAllInstanceInfo();
        HRESULT SetSingleInstanceInfo();


        //=============================================
        //  Get the data from WMI
        //=============================================
        BOOL InitializeDataPtr();
        void GetNextNode();
        BOOL ParseHeader();
        HRESULT ProcessArrayTypes(VARIANT & vToken,WCHAR * pwcsProperty);
		HRESULT WriteArrayTypes(WCHAR * pwcsProperty,CVARIANT & v);
        HRESULT FillInProperty();

        BOOL GetDataBlockReady(DWORD dwSize,BOOL );
        HRESULT ReAllocateBuffer(DWORD wCount);
        HRESULT AllocateBuffer(DWORD dwSize);
        inline BOOL PtrOk(ULONG * pPtr,ULONG uHowMany);
		int AssignNewHandleAndKeepItIfWMITellsUsTo();

		//===============================================
		//  Mapping return code and dumping out
		//  WNODE info
		//===============================================
		HRESULT MapReturnCode(ULONG uRc);
		HRESULT DumpWnodeInfo(char * pwcsMsg);
		void DumpAllWnode();
		void DumpSingleWnode();
        void DumpWnodeMsg(char * wcsMsg) ;

    public:
        CWMIDataBlock();
        ~CWMIDataBlock();

		void UpdateNamespace(BOOL fUpdate)   { m_fUpdateNamespace = fUpdate;}
		BOOL UpdateNamespace()				 { return m_fUpdateNamespace; }
		BOOL HasMofChanged()				 { return m_fMofHasChanged; }

		inline void SetClassProcessPtr(CWMIProcessClass * Class)     { m_Class = Class;}

        //=============================================
		//  Open and Close WMI ... :)
        //=============================================
		void CloseAllOutstandingWMIHandles(void);
        HRESULT OpenWMI();
		HRESULT OpenWMIForBinaryMofGuid();

        //=============================================
        //  Setting up and cancelling Events
        //  Setting ptrs to the data sent by the event
        //=============================================
        HRESULT RegisterWMIEvent( WCHAR * wcsGuid, ULONG_PTR uContext, CLSID & Guid, BOOL fRegistered);
        HRESULT SetAllInstancePtr( PWNODE_ALL_DATA pwAllNode );

        //=============================================
        // Processing the data we got back and putting
        // it into WBEM
        //=============================================
        virtual HRESULT FillOutProperties()=0;

        HRESULT ProcessBinaryMof();
        HRESULT ReadWMIDataBlockAndPutIntoWbemInstance();
		inline BOOL MoreToProcess()	        				  { return m_fMore;}

        //=============================================
        // Embedded Class
        //=============================================
        HRESULT ProcessEmbeddedClass(CVARIANT & v);

        //=====================================================
        //  The Put Instance Group
        //=====================================================
		HRESULT WriteEmbeddedClass(IUnknown * pUnknown,CVARIANT & v);

        HRESULT ConstructDataBlock(BOOL fInit);
        HRESULT WriteDataToBufferAndIfSinglePropertySubmitToWMI(BOOL fInit,BOOL fPutProperty);
        HRESULT SetSingleInstancePtr( PWNODE_SINGLE_INSTANCE pwSingleNode);
        HRESULT SetSingleItem();
        HRESULT PutSingleProperties();
        BOOL    GetListOfPropertiesToPut(int nWhich, CVARIANT & vList);
        //=====================================================
        //  Manipulate data in the data block
        //=====================================================
        void GetWord(WORD & wWord) ;
        void GetDWORD(DWORD & dwWord) ;
        void GetFloat(float & fFloat) ;
        void GetDouble(DOUBLE & dDouble) ;
        HRESULT GetSInt64 ( WCHAR * pwcsBuffer, DWORD cchSize ) ;
        HRESULT GetUInt64 ( WCHAR * pwcsBuffer, DWORD cchSize ) ;
        void GetQWORD(unsigned __int64 & uInt64);
        void GetString(WCHAR * pwcsBuffer,WORD wCount, WORD wBufferSize) ;
        void GetByte(BYTE & bByte) ;
        void SetWord(WORD wWord) ;
        void SetDWORD(DWORD dwWord) ;
        void SetFloat(float fFloat) ;
        void SetDouble(DOUBLE dDouble) ;
        void SetSInt64(__int64 Int64) ;
        void SetUInt64(unsigned __int64 UInt64) ;
        void SetString(WCHAR * pwcsBuffer,WORD wCount) ;
        void SetByte(byte bByte) ;

        void AddPadding(DWORD dwBytesToPad);
		BOOL CurrentPtrOk(ULONG uHowMany);
        HRESULT GetBufferReady(DWORD wCount);
        //=======================================================
        //  Utility functions
        //=======================================================
		inline void InitDataBufferToNull() { m_dwDataBufferSize = 0; m_pbDataBuffer = NULL;}
        BOOL ResetMissingQualifierValue(WCHAR * pwcsProperty, SAFEARRAY *& pSafe);
        BOOL ResetMissingQualifierValue(WCHAR * pwcsProperty, CVARIANT & vToken);

        HRESULT ProcessDataBlock();
        int AdjustDataBlockPtr(HRESULT & hr);
        HRESULT ProcessNameBlock(BOOL f);

        //=========================================================
        // Binary mof processing
        //=========================================================
        HRESULT ExtractImageAndResourceName(CVARIANT & vImagePath,CVARIANT & vResourceName);
        HRESULT AddBinaryMof(CVARIANT & vImagePath,CVARIANT & vResourceName);
        HRESULT DeleteBinaryMof(CVARIANT & vImagePath,CVARIANT & vResourceName);
        HRESULT ProcessBinaryMofDataBlock(CVARIANT & vResourceName, WCHAR * w, int cchSize);

        //=========================================================
        // Cleanup
        //=========================================================
        void ResetDataBuffer();

        //======================================================
        //  Error Message
		//======================================================

        inline WCHAR * GetMessage()                     { return m_wcsMsg; }

        inline void SetDesiredAccess(ULONG u)           { m_uDesiredAccess = u; }

};



//************************************************************************************************************
//============================================================================================================
//
//   The Standard Provider Classes
//
//============================================================================================================
//************************************************************************************************************

class CProcessStandardDataBlock : public CWMIDataBlock
{
    private:

        HRESULT FillOutProperties();
        CWMIProcessClass        * m_pMethodInput;
        CWMIProcessClass        * m_pMethodOutput;


    public:

        CProcessStandardDataBlock();
        ~CProcessStandardDataBlock() ;

        inline void SetMethodInput( CWMIProcessClass * p )  { m_pMethodInput = p;}
        inline void SetMethodOutput( CWMIProcessClass * p )  { m_pMethodOutput = p;}

        //=============================================
        // Getting the data to process in response to
        // a request for enumeration.  We either get
        // a single guy, or a bunch of guys
        //=============================================
        ULONG GetDataBufferAndQueryAllData(DWORD dwSize);
        ULONG GetDataBufferAndQuerySingleInstance(DWORD dwSize,WCHAR * wcsInstanceName);

        HRESULT QueryAllData();
        HRESULT QuerySingleInstance(WCHAR * wcsInstanceName);
        HRESULT SetSingleInstance();

        //=============================================
        //  Methods
        //=============================================
	    HRESULT ProcessMethodInstanceParameters();
        HRESULT ExecuteMethod(ULONG MethodId, WCHAR * MethodInstanceName, ULONG InputValueBufferSize,BYTE * InputValueBuffer);

        //=============================================
        //  Methods
        //=============================================
	    ULONG GetMethodId(LPCWSTR bProp);
        HRESULT CreateOutParameterBlockForMethods();
        HRESULT CreateInParameterBlockForMethods( BYTE *& Buffer, ULONG & uBufferSize);
        HRESULT AllocateBlockForMethodOutput(DWORD & dwSize,CWMIProcessClass & Class);
        HRESULT GetEmbeddedClassSize(WCHAR * wcsEmbedded, DWORD &  dwSize);

};

//************************************************************************************************************
//============================================================================================================
//
//   The Hi Performance Classes
//
//============================================================================================================
//************************************************************************************************************


class CProcessHiPerfDataBlock : public CWMIDataBlock
{
    private:

        ULONG GetDataBufferAndHiPerfQueryAllData(DWORD dwSize, WMIHANDLE * List, long lHandleCount);
        ULONG GetDataBufferAndHiPerfQuerySingleInstance( DWORD dwSize,WMIHANDLE *List, PWCHAR * pInstances, long lHandleCount);


    public:

        CProcessHiPerfDataBlock() { m_fCloseHandle = FALSE;}
        ~CProcessHiPerfDataBlock() {}

        HRESULT HiPerfQuerySingleInstance(WMIHANDLE *List, PWCHAR * pInstances, DWORD dwInstanceNameSize, long lHandleCount);
        HRESULT HiPerfQueryAllData(WMIHANDLE * List,long lHandleCount);
        HRESULT OpenHiPerfHandle();
        HRESULT GetWMIHandle(HANDLE & lWMIHandle);

        HRESULT FillOutProperties();

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\wmidata.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#include "precomp.h"
#include "wmicom.h"
#include "wmimof.h"
#include "wmimap.h"
#include <stdlib.h>
#include <winerror.h>
#include <crc32.h>
#include <align.h>

#define NO_DATA_AVAILABLE 2
#define WMI_INVALID_HIPERFPROP	3
#define OffsetToPtr(Base, Offset) ((PBYTE)((PBYTE)Base + Offset))
////////////////////////////////////////////////////////////////////////////////////////////////
void WINAPI EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG_PTR Context);

#define WMIINTERFACE m_Class->GetWMIManagementPtr()
////////////////////////////////////////////////////////////////////////////////////////////////
//=============================================================
BOOL CWMIManagement::CancelWMIEventRegistration( GUID gGuid , ULONG_PTR uContext )
{ 
    BOOL fRc = FALSE;

    try
    {
        if( ERROR_SUCCESS == WmiNotificationRegistration(&gGuid, FALSE,EventCallbackRoutine,uContext, NOTIFICATION_CALLBACK_DIRECT))
        {
            fRc = TRUE;
        }
    }
    catch(...)
    {
        // don't throw
    }

    return fRc;    
}

//**********************************************************************************************
//  WMI Data block
//**********************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////
void CWMIDataBlock::DumpAllWnode() 
{
	//=========================================
	//   Dump Wnode All Node info 
	//=========================================
	DEBUGTRACE((THISPROVIDER,"***************************************\n"));
	DEBUGTRACE((THISPROVIDER,"WNODE_ALL_DATA 0x%x\n",m_pAllWnode));

	DEBUGTRACE((THISPROVIDER,"  DataBlockOffset..............%x\n",m_pAllWnode->DataBlockOffset));
	DEBUGTRACE((THISPROVIDER,"  InstanceCount................%x\n",m_pAllWnode->InstanceCount));
	DEBUGTRACE((THISPROVIDER,"  OffsetInstanceNameOffsets....%x\n",m_pAllWnode->OffsetInstanceNameOffsets));
                      
	if( m_fFixedInstance ){
		DEBUGTRACE((THISPROVIDER,"  FixedInstanceSize....%x\n",m_pAllWnode->FixedInstanceSize));
	}
	else{
		DEBUGTRACE((THISPROVIDER,"  OffsetInstanceData....%x\n",m_pAllWnode->OffsetInstanceDataAndLength[0].OffsetInstanceData));
		DEBUGTRACE((THISPROVIDER,"  LengthInstanceData....%x\n",m_pAllWnode->OffsetInstanceDataAndLength[0].LengthInstanceData));
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////
void CWMIDataBlock::DumpSingleWnode() 
{
	//=========================================
	//   Dump Wnode Single Node info 
	//=========================================
	DEBUGTRACE((THISPROVIDER,"***************************************\n"));
	DEBUGTRACE((THISPROVIDER,"WNODE_SINGLE_INSTANCE 0x%x\n",m_pSingleWnode));

	DEBUGTRACE((THISPROVIDER,"  OffsetInstanceName....0x%x\n",m_pSingleWnode->OffsetInstanceName));
	DEBUGTRACE((THISPROVIDER,"  InstanceIndex.........0x%x\n",m_pSingleWnode->InstanceIndex));
	DEBUGTRACE((THISPROVIDER,"  DataBlockOffset.......0x%x\n",m_pSingleWnode->DataBlockOffset));
	DEBUGTRACE((THISPROVIDER,"  SizeDataBlock.........0x%x\n",m_pSingleWnode->SizeDataBlock));

	DEBUGTRACE((THISPROVIDER,"***************************************\n"));

}
////////////////////////////////////////////////////////////////////////////////////////////////
void CWMIDataBlock::DumpWnodeMsg(char * wcsMsg) 
{
	ERRORTRACE((THISPROVIDER,"***************************************\n"));
	ERRORTRACE((THISPROVIDER,"%s\n",wcsMsg));
	ERRORTRACE((THISPROVIDER,"***************************************\n"));

}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::DumpWnodeInfo(char * wcsMsg) 
{
    HRESULT hr = WBEM_E_UNEXPECTED;
	//=========================================
	//   Dump Wnode header info first
	//=========================================
	// WNODE definition
	if( m_pHeaderWnode )
    {
    	if( !IsBadReadPtr( m_pHeaderWnode, m_pHeaderWnode->BufferSize))
        {

            DumpWnodeMsg(wcsMsg);

			if ( LoggingLevelEnabled ( 1 ) )
			{
				ERRORTRACE((THISPROVIDER,"*******************************************\n"));
				ERRORTRACE((THISPROVIDER,"Enable verbose logging for more information\n"));
				ERRORTRACE((THISPROVIDER,"*******************************************\n"));
			}

	        DEBUGTRACE((THISPROVIDER,"WNODE_HEADER 0x%x\n",m_pHeaderWnode));
	        DEBUGTRACE((THISPROVIDER,"  BufferSize........0x%x\n",m_pHeaderWnode->BufferSize));
	        DEBUGTRACE((THISPROVIDER,"  ProviderId........0x%x\n",m_pHeaderWnode->ProviderId));
	        DEBUGTRACE((THISPROVIDER,"  Version...........0x%x\n",m_pHeaderWnode->Version));
	        
	        if( m_pHeaderWnode->Linkage != 0 ){
		        DEBUGTRACE((THISPROVIDER,"  Linkage...........%x\n",m_pHeaderWnode->Linkage));
	        }

	        DEBUGTRACE((THISPROVIDER,"  TimeStamp:LowPart.0x%x\n",m_pHeaderWnode->TimeStamp.LowPart));
	        DEBUGTRACE((THISPROVIDER,"  TimeStamp:HiPart..0x%x\n",m_pHeaderWnode->TimeStamp.HighPart));

	        WCHAR * pwcsGuid=NULL;

	        if( S_OK == StringFromCLSID(m_pHeaderWnode->Guid,&pwcsGuid )){
		        DEBUGTRACE((THISPROVIDER,"  Guid.............."));
                TranslateAndLog(pwcsGuid, TRUE);
		        DEBUGTRACE((THISPROVIDER,"\n"));
                CoTaskMemFree(pwcsGuid);
            }

	        DEBUGTRACE((THISPROVIDER,"  Flags.............0x%x\n",m_pHeaderWnode->Flags));

	        //==================================================================
	        // Now that we printed the header, we should print out the node 
	        // either single or all
	        //==================================================================
	        if( m_pSingleWnode ){
		        DumpSingleWnode();
	        }
	        if( m_pAllWnode ){
		        DumpAllWnode();
	        }
	        //==================================================================
	        //  Now, dump the memory
	        //==================================================================
	        DWORD dwCount;

	        if( IsBadReadPtr( m_pHeaderWnode, m_pHeaderWnode->BufferSize) == 0 )
			{
		        BYTE * pbBuffer = NULL;
		        BYTE b1,b2,b3,b4,b5,b6,b7,b8,b9,b10;
		        dwCount = m_pHeaderWnode->BufferSize;
				pbBuffer = new BYTE[dwCount+256];
				if( pbBuffer )
				{
					BYTE bDump[12];
					DEBUGTRACE((THISPROVIDER,"Writing out buffer, total size to write: %ld\n", dwCount ));
					memset(pbBuffer,NULL,dwCount+256);
					memcpy(pbBuffer,(BYTE*)m_pHeaderWnode,dwCount);
					BYTE * pTmp = pbBuffer;
					for( DWORD i = 0; i < dwCount; i +=10)
					{
						memset(bDump, NULL, 12 );
						memcpy(bDump, pTmp, 10);
						DEBUGTRACE((THISPROVIDER,"  %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x  \n",bDump[0],bDump[1],bDump[2],bDump[3],bDump[4],bDump[5],bDump[6],bDump[7],bDump[8],bDump[9])); 
						pTmp+=10;
					}
					SAFE_DELETE_ARRAY(pbBuffer);
				}
            }
        }
    }
    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::MapReturnCode(ULONG uRc) 
{

	if( uRc != 0 )
	{
		ERRORTRACE((THISPROVIDER,"WDM call returned error: %lu\n", uRc));
	}
	StringCchPrintfW ( m_wcsMsg, MSG_SIZE, L"WDM specific return code: %lu\n",uRc );

	switch(uRc){

		case ERROR_WMI_GUID_NOT_FOUND:
			return WBEM_E_NOT_SUPPORTED;
			break;

		case S_OK:
			return S_OK;

		case ERROR_NOT_SUPPORTED:
		case ERROR_INVALID_FUNCTION:
			return WBEM_E_NOT_SUPPORTED;

		case ERROR_WMI_SERVER_UNAVAILABLE:
			return WBEM_E_NOT_SUPPORTED;

		case NO_DATA_AVAILABLE:
			return S_OK;

		case ERROR_INVALID_HANDLE:
			return WBEM_E_NOT_AVAILABLE;

		case ERROR_WMI_DP_FAILED:
			StringCchCopyW ( m_wcsMsg, MSG_SIZE, MSG_DRIVER_ERROR );
			DumpWnodeInfo(ANSI_MSG_DRIVER_ERROR);
			return WBEM_E_INVALID_OPERATION;

		case ERROR_WMI_READ_ONLY:
			StringCchCopyW ( m_wcsMsg, MSG_SIZE, MSG_READONLY_ERROR );
			return WBEM_E_READ_ONLY;

        case ERROR_INVALID_PARAMETER:
			DumpWnodeInfo(ANSI_MSG_INVALID_PARAMETER);
            return WBEM_E_INVALID_PARAMETER;

		case ERROR_INVALID_DATA:
			StringCchCopyW ( m_wcsMsg, MSG_SIZE, MSG_ARRAY_ERROR );
			DumpWnodeInfo(ANSI_MSG_INVALID_DATA);
			return WBEM_E_INVALID_PARAMETER;

        case ERROR_WMI_GUID_DISCONNECTED:
			StringCchCopyW ( m_wcsMsg, MSG_SIZE, MSG_DATA_NOT_AVAILABLE );
			return WBEM_E_NOT_SUPPORTED;

        case ERROR_ACCESS_DENIED:
        case ERROR_INVALID_PRIMARY_GROUP:
        case ERROR_INVALID_OWNER:
			DumpWnodeInfo(ANSI_MSG_ACCESS_DENIED);
            return WBEM_E_ACCESS_DENIED;

        case ERROR_WMI_INSTANCE_NOT_FOUND:
			StringCchCopyW ( m_wcsMsg, MSG_SIZE, MSG_DATA_INSTANCE_NOT_FOUND );
            DumpWnodeMsg(ANSI_MSG_DATA_INSTANCE_NOT_FOUND);
			return WBEM_E_NOT_SUPPORTED;

	}
	return WBEM_E_FAILED;
}


//******************************************************************
////////////////////////////////////////////////////////////////////
//   CWMIDataBlock
////////////////////////////////////////////////////////////////////
//******************************************************************
////////////////////////////////////////////////////////////////////
//******************************************************************
//
//  WMIDataBlock handles the reading and writing of a WMI Data
//  block.
//
//******************************************************************
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
CWMIDataBlock::CWMIDataBlock()
{
    m_hCurrentWMIHandle = NULL;
    InitMemberVars();
	memset(m_wcsMsg,NULL,MSG_SIZE);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
CWMIDataBlock::~CWMIDataBlock()
{

	if( m_fCloseHandle )
    {
        if( m_hCurrentWMIHandle )
        {
            try
            {
		        WmiCloseBlock(m_hCurrentWMIHandle);
            }
            catch(...){
               // don't throw
            }
        }
	}

    ResetDataBuffer();
	InitMemberVars();
}
////////////////////////////////////////////////////////////////////
void CWMIDataBlock::InitMemberVars()
{
	m_fUpdateNamespace = TRUE;
	m_fMofHasChanged   = FALSE;
    m_uDesiredAccess = 0;
    m_dwDataBufferSize = 0;
	m_pbDataBuffer= NULL;
	m_fMore = 0L;
	//=======================================
	//  ptrs
	//=======================================
	m_pHeaderWnode = NULL;
	m_pSingleWnode = NULL;
	m_pAllWnode = NULL;
	m_dwAccumulativeSizeOfBlock = 0L;
	m_dwCurrentAllocSize		= 0L;

	m_uInstanceSize = 0L;
}
//====================================================================
HRESULT CWMIDataBlock::OpenWMIForBinaryMofGuid()
{
	int nRc = 0;
	HRESULT hr = WBEM_E_FAILED;
	m_fCloseHandle = TRUE;
    try
    {
        hr = m_Class->GetGuid();
        if( S_OK == hr )
        {
		    nRc = WmiOpenBlock(m_Class->GuidPtr(),m_uDesiredAccess, &m_hCurrentWMIHandle);
		    if( nRc == ERROR_SUCCESS )
            {
			    hr = S_OK;
		    }
        }
    }
    catch(...)
    {
        hr = WBEM_E_UNEXPECTED;
        // don't throw
    }
	return hr;
}
//====================================================================
int CWMIDataBlock::AssignNewHandleAndKeepItIfWMITellsUsTo()
{
	int nRc = 0;

    try
    {
	    nRc = WmiOpenBlock(m_Class->GuidPtr(),m_uDesiredAccess, &m_hCurrentWMIHandle);

	    //===========================================================
	    //  Now that we opened the block successfully, check to see
	    //  if we need to keep this guy open or not, if we do
	    //  then add it to our list, otherwise don't
	    //===========================================================
	    if( nRc == ERROR_SUCCESS )
        {
		    //=======================================================
		    //  Call WMI function here to see if we should save or
		    //  not
		    //=======================================================
		    WMIGUIDINFORMATION GuidInfo;
		    GuidInfo.Size = sizeof(WMIGUIDINFORMATION);

		    
            if( ERROR_SUCCESS == WmiQueryGuidInformation(m_hCurrentWMIHandle,&GuidInfo))
            {
			    if(GuidInfo.IsExpensive)
                {

					if( m_fUpdateNamespace )
					{
						//================================================
						//  Add it to our list of handles to keep 
						//================================================
						m_fCloseHandle = FALSE;
						WMIINTERFACE->HandleMap()->Add(*(m_Class->GuidPtr()),m_hCurrentWMIHandle,m_uDesiredAccess);
					}
			    }
		    }
	    }
    }
    catch(...)
    {
        nRc = E_UNEXPECTED;
        // don't throw
    }

	return nRc;
}
//====================================================================
HRESULT CWMIDataBlock::OpenWMI()
{
	int nRc;
	HRESULT hr = WBEM_E_FAILED;

    //=======================================================
    //  Ok, we only want to keep the handles that are flagged
	//  by WMI to be kept, otherwise, we just open the handle
	//  and then close it.  Because of this, we need to 
	//  check first and see if the Guid we are going after
	//  already has a handle open, if it does, use it
    //=======================================================
	if( m_fUpdateNamespace )
	{
		CAutoBlock(WMIINTERFACE->HandleMap()->GetCriticalSection());

			nRc = WMIINTERFACE->HandleMap()->ExistingHandleAlreadyExistsForThisGuidUseIt( *(m_Class->GuidPtr()), m_hCurrentWMIHandle, m_fCloseHandle ,m_uDesiredAccess);
			if( nRc != ERROR_SUCCESS)
			{
				nRc = AssignNewHandleAndKeepItIfWMITellsUsTo();
			}
	}
	else
	{
		nRc = AssignNewHandleAndKeepItIfWMITellsUsTo();
	}
	hr = MapReturnCode(nRc);
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ProcessDataBlock()
{
    HRESULT hr = S_OK;
	//================================================================
    //  Data blocks can either be of fixed instance size or dynamic
    //  instance size, call this function so we can determine what
    //  type of data ptr we are working with
    //  If there are no more, then break.  Otherwise, we know
    //  we are processing at least one instance
    //============================================================
	ULONG *pMaxPtrTmp = m_pMaxPtr;
    if( NoMore != AdjustDataBlockPtr(hr)){
		
        hr = FillOutProperties();
    }
	m_pMaxPtr = pMaxPtrTmp;

	//====================================================================
	//  If we didn't succeed in processing these blocks, write it out
	//	If invalid datablock is from Hi-Perf provider, don't log the data
	//	to the file as this could be because of Embededclass or array
	//	properties in the class
	//====================================================================
	if(hr == WMI_INVALID_HIPERFPROP)
	{
		hr = WBEM_E_FAILED;
	}
	else
	if( hr != S_OK )
	{
		DumpWnodeInfo(ANSI_MSG_INVALID_DATA_BLOCK);
	}

    return hr;

}
////////////////////////////////////////////////////////////////////
int CWMIDataBlock::AdjustDataBlockPtr(HRESULT & hr)
{
    int nType = NoMore;
	//================================================================
	//   Get pointer to the data offsets
	//================================================================
	
	// INSTANCES ARE ALWAYS ALIGNED ON 8 bytes

	if( m_fFixedInstance )
	{
		//========================================================
	    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is set in Flags then 
		// FixedInstanceSize specifies the size of each data block. 
		//========================================================
		// traverse all instances of requested class
		//========================================================
        if( m_nCurrentInstance == 1 )
		{
            m_pbWorkingDataPtr = m_pbCurrentDataPtr;
        }
		else
		{
			if( m_dwAccumulativeSizeOfBlock < m_pAllWnode->FixedInstanceSize )
			{
				m_pbWorkingDataPtr += m_pAllWnode->FixedInstanceSize - m_dwAccumulativeSizeOfBlock ;
				m_dwAccumulativeSizeOfBlock += m_pAllWnode->FixedInstanceSize - m_dwAccumulativeSizeOfBlock;
			}

			//=============================================================================
			// make sure we adjust for the fixed instance size, then make sure that it is 
			// on an 8 byte boundary.
			// otherwise, we are going to calculate where it should go next
			//=============================================================================
			DWORD dwBytesToPad = 0 ;
			DWORD dwReminder = m_dwAccumulativeSizeOfBlock % 8 ;

			if ( 0 < dwReminder )
			{
				dwBytesToPad = 8 - dwReminder ;
			}

			if ( 0 < dwBytesToPad )
			{
				AddPadding ( dwBytesToPad ) ;
				m_dwAccumulativeSizeOfBlock += dwBytesToPad ;
			}

			//
			// just get maximum ptr where returned data are
			//
			m_pMaxPtr = (ULONG *)OffsetToPtr(m_pbWorkingDataPtr, m_pAllWnode->FixedInstanceSize);
		}

        nType = ProcessOneFixedInstance;
    } 
	else
	{
		m_dwAccumulativeSizeOfBlock = 0L;				

		//====================================================
		//
	    // If WMI_FLAG_FIXED_DATA_SIZE is not set then 
		// OffsetInstanceData data is an array of ULONGS that 
		// specifies the offsets to the data blocks for each 
		// instance. In this case there is an array of 
		// InstanceCount ULONGs followed by the data blocks.
		//
        // struct {
        //     ULONG OffsetInstanceData;
        //     ULONG LengthInstanceData;
        // } OffsetInstanceDataAndLength[]; /* [InstanceCount] */
		//====================================================
        ULONG uOffset;
		memcpy( &uOffset, m_pbCurrentDataPtr, sizeof(ULONG) );
		if( uOffset == 0 )
		{
			nType = NoMore;
            hr = S_OK;
		}
        else
		{
		    m_pbCurrentDataPtr += sizeof( ULONG );

    		memcpy( &m_uInstanceSize, m_pbCurrentDataPtr, sizeof(ULONG) );
	    	m_pbCurrentDataPtr += sizeof( ULONG );
            m_pbWorkingDataPtr =(BYTE*) (ULONG *)OffsetToPtr(m_pAllWnode, uOffset);
            nType = ProcessUnfixedInstance;
			m_pMaxPtr = (ULONG *)OffsetToPtr(m_pbWorkingDataPtr, m_uInstanceSize);

        }
	}

	return nType;
}
/////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ProcessNameBlock(BOOL fSetName)
{

    HRESULT hr = WBEM_E_FAILED;
	WCHAR wName[NAME_SIZE+2];
	SHORT NameLen = 0;
	BYTE *pbData;
    ULONG * upNameOffset = NULL;

	memset(wName,NULL,NAME_SIZE+2);
	//=====================================================
	//  Either the m_pAllWnode or m_pSingleNode is Null,
	//  which ever isn't, is the type we are working with
	//=====================================================
	if( m_pAllWnode ){
		if( IsBadReadPtr( m_upNameOffsets, sizeof( ULONG *)) == 0 ){
			upNameOffset = ((ULONG *)OffsetToPtr(m_pAllWnode, *m_upNameOffsets));
		}
	}
	else{
		upNameOffset = m_upNameOffsets;
	}

	hr = WBEM_E_INVALID_OBJECT;
	if( IsBadReadPtr( upNameOffset, sizeof( ULONG *)) == 0 ){
		if((ULONG *) (upNameOffset) < m_pMaxPtr ){
    		//================================================================
			//   Get pointer to the name offsets & point to next one
			//================================================================
		
			pbData = (LPBYTE)upNameOffset;        
			if( PtrOk((ULONG*)pbData,(ULONG)0) ){
				if( pbData ){
				
    				memcpy( &NameLen, pbData, sizeof(USHORT) );
					pbData += sizeof(USHORT);

					if( NameLen > 0 ){
						if( PtrOk((ULONG*)pbData,(ULONG)NameLen) ){

    						memcpy(wName,pbData,NameLen);
							pbData+=NameLen;
						    hr = m_Class->SetInstanceName(wName,fSetName);
						}
					}
				}
			}
		}
	}
	//====================================================================
	//  If we didn't succeed in processing these blocks, write it out
	//====================================================================
	if( hr != S_OK ){
		DumpWnodeInfo(ANSI_MSG_INVALID_NAME_BLOCK);
	}

    return hr;
}

////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ProcessBinaryMofDataBlock( CVARIANT & vResourceName,WCHAR * wcsTmp, int cchSize )
{
    HRESULT hr = WBEM_E_FAILED;

	ULONG *pMaxPtrTmp = m_pMaxPtr;
    AdjustDataBlockPtr(hr);
	m_pMaxPtr = pMaxPtrTmp;

    CWMIBinMof bMof;
	hr = bMof.Initialize(WMIINTERFACE,m_fUpdateNamespace);
	if( S_OK == hr )
	{

		if ( SUCCEEDED ( hr = bMof.SetBinaryMofClassName(vResourceName.GetStr(),wcsTmp, cchSize) ) )
		{
			hr = bMof.ExtractBinaryMofFromDataBlock(m_pbWorkingDataPtr,m_uInstanceSize,wcsTmp, m_fMofHasChanged);
			if( hr != S_OK )
			{
				DumpWnodeInfo(ANSI_MSG_INVALID_DATA_BLOCK);
			}
			//===============================================
			//  Get the next node name and data ptrs ready
			//===============================================
			if( m_pAllWnode )
			{
				GetNextNode();
			}
			m_nCurrentInstance++;
		}
	}
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::AddBinaryMof(CVARIANT & vImagePath,CVARIANT & vResourceName)
{
    HRESULT hr = WBEM_E_OUT_OF_MEMORY;
    CAutoWChar wcsTmp(MAX_PATH*2);
	if( wcsTmp.Valid() )
	{
		 hr = WBEM_E_INVALID_OBJECT;
		//=================================================================
		// if we have an image path and resource path, then do the normal 
		// thing
		//=================================================================
		if((vResourceName.GetType() != VT_NULL ) && ( vImagePath.GetType() != VT_NULL  ))
		{
			//=============================================================
			//  If this was a mof that was being added, then add it
			//=============================================================
			CWMIBinMof bMof;
			hr = bMof.Initialize(WMIINTERFACE,m_fUpdateNamespace);
			if( S_OK == hr )
			{
 				bMof.ExtractBinaryMofFromFile(vImagePath.GetStr(),vResourceName.GetStr(),wcsTmp, MAX_PATH*2, m_fMofHasChanged);
			}
		}        
		else if( vResourceName.GetType() != VT_NULL ){
			//=================================================================
			// if we have a resource to query for
			//=================================================================
			CProcessStandardDataBlock * pTmp = new CProcessStandardDataBlock();
			if( pTmp )
			{
				try
				{
					pTmp->UpdateNamespace(m_fUpdateNamespace);
					pTmp->SetClassProcessPtr(m_Class);

					hr = pTmp->OpenWMIForBinaryMofGuid();
					if( hr == S_OK )
					{
						hr = pTmp->QuerySingleInstance(vResourceName.GetStr());
						if( hr == S_OK )
						{
							hr = pTmp->ProcessBinaryMofDataBlock(vResourceName,wcsTmp, MAX_PATH*2);
							m_fMofHasChanged = pTmp->HasMofChanged();
						}
						else
						{
                			ERRORTRACE((THISPROVIDER,"***************************************\n"));
                			ERRORTRACE((THISPROVIDER,"Instance failed for: "));
							TranslateAndLog(vResourceName.GetStr());
                			ERRORTRACE((THISPROVIDER,"***************************************\n"));
						}
					}
					SAFE_DELETE_PTR(pTmp);
				}
				catch(...)
				{
					SAFE_DELETE_PTR(pTmp);
					hr = WBEM_E_UNEXPECTED;
					throw;
				}
			}
		}
	}
    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ProcessBinaryMof()
{
	//================================================================
	//  The binary mof blocks are always going to be two strings,
	//  1).  Image Path
	//  2).  Mof resource name
	//
	//  If the image path and resource name are both filled in, then
	//  we need to go open the file and extract the binary mof as 
	//  usual.
	//  If the Imagepath is empty, then the mof resource name is going
	//  to contain the static instance name to query for, we then
	//  process that.
	//================================================================
    CVARIANT vImagePath, vResourceName;
	CWMIDataTypeMap MapWMIData(this,&m_dwAccumulativeSizeOfBlock);
	m_dwAccumulativeSizeOfBlock = 0;

    HRESULT hr = MapWMIData.GetDataFromDataBlock(vImagePath,VT_BSTR,0);
    if( SUCCEEDED(hr) )
	{
	    hr = MapWMIData.GetDataFromDataBlock(vResourceName,VT_BSTR,0);
        if( hr == S_OK )
		{
            if( m_Class->GetHardCodedGuidType() == MOF_ADDED )
			{
                hr = AddBinaryMof( vImagePath, vResourceName);
            }
            else
			{
                CWMIBinMof bMof;
				hr = bMof.Initialize(WMIINTERFACE,m_fUpdateNamespace);
				if( S_OK == hr )
				{
					hr = bMof.DeleteMofsFromEvent(vImagePath, vResourceName, m_fMofHasChanged);
				}
            }
        }
	}
    return hr;
}
////////////////////////////////////////////////////////////////////
BOOL CWMIDataBlock::ResetMissingQualifierValue(WCHAR * pwcsProperty, CVARIANT & vToken )
{
	BOOL fRc = FALSE;
	CVARIANT vQual;

	CWMIDataTypeMap Map(this,&m_dwAccumulativeSizeOfBlock);
	//============================================================
	// We are only going to support this for numerical types
	//============================================================

	HRESULT hr = m_Class->GetQualifierValue(pwcsProperty, L"MissingValue", (CVARIANT*)&vQual);
	if( hr == S_OK ){
		if( vQual.GetType() != VT_EMPTY ){
			if( Map.SetDefaultMissingQualifierValue( vQual, m_Class->PropertyType(), vToken ) ){
				fRc = TRUE;
			}
		}
    }
	return fRc;
	
}
////////////////////////////////////////////////////////////////////
BOOL CWMIDataBlock::ResetMissingQualifierValue(WCHAR * pwcsProperty, SAFEARRAY *& pSafe)
{
	BOOL fRc = FALSE;
	CVARIANT vQual;
	
	CWMIDataTypeMap Map(this,&m_dwAccumulativeSizeOfBlock);
	//============================================================
	// We are only going to support this for numerical types
	//============================================================

	HRESULT hr = m_Class->GetQualifierValue(pwcsProperty, L"MissingValue", (CVARIANT*)&vQual);
	if( hr == S_OK ){
		if( vQual.GetType() != VT_EMPTY )
		{
			SAFEARRAY * psa = V_ARRAY((VARIANT*)vQual);
			CSAFEARRAY Safe(psa);
			CVARIANT vElement;
            DWORD dwCount = Safe.GetNumElements();
            //============================================================
            //  Now, process it
            //============================================================

            if( dwCount > 0 ){
            	// Set each element of the array
		        for (DWORD i = 0; i < dwCount; i++){

        			if( S_OK == Safe.Get(i,&vElement) ){
                        long lType = m_Class->PropertyType();

		        		if( Map.SetDefaultMissingQualifierValue( vQual, lType, vElement ) ){
       			        	Map.PutInArray(pSafe,(long *)&i,lType,(VARIANT * )vElement);
						    fRc = TRUE;

	        			}
			        }
                }
            }
			Safe.Unbind();
		}
    }
	return fRc;
	
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::RegisterWMIEvent( WCHAR * wcsGuid, ULONG_PTR uContext, CLSID & Guid, BOOL fRegistered)
{
    ULONG Status;
    HRESULT hr = WBEM_E_UNEXPECTED;

    if( SetGuid(wcsGuid, Guid) ){

        try
        {
            if( !fRegistered )
            {
                Status = WmiNotificationRegistration(&Guid, TRUE, EventCallbackRoutine, uContext, NOTIFICATION_CALLBACK_DIRECT);
            }
            else
            {
                Status = WmiNotificationRegistration(&Guid, TRUE, EventCallbackRoutine, uContext, NOTIFICATION_CHECK_ACCESS );
            }
       		hr = MapReturnCode(Status);
        }
        catch(...)
        {
            // don't throw
        }
    } 
    else 
    {
        Status = GetLastError();
    }

    if( hr != S_OK )
    {
        ERRORTRACE((THISPROVIDER,"WmiNotificationRegistration failed ...%ld\n",Status));
    }

   	return hr;
}
//=============================================================
void CWMIDataBlock::GetNextNode()
{
    BOOL fRc = FALSE;

    //============================================================================================
    //   If we still have more instances to get, then get them
    //============================================================================================
    if( m_nCurrentInstance < m_nTotalInstances ){
		m_upNameOffsets++;
        fRc = TRUE;
    }
    else{

        //========================================================================================
        //  Otherwise, lets see if we have another NODE to get, if not, then we are done.
        //========================================================================================
        if (m_pAllWnode->WnodeHeader.Linkage != 0){

            m_pAllWnode = (PWNODE_ALL_DATA)OffsetToPtr(m_pAllWnode, m_pAllWnode->WnodeHeader.Linkage);
	        m_pHeaderWnode = &(m_pAllWnode->WnodeHeader);
       	    m_nTotalInstances = m_pAllWnode->InstanceCount;
            m_nCurrentInstance = 0;
            m_upNameOffsets = (ULONG *)OffsetToPtr(m_pAllWnode, m_pAllWnode->OffsetInstanceNameOffsets); 
            if( ParseHeader() ){
	    		fRc = InitializeDataPtr();
		    }
		    fRc = TRUE;
        }
	}

	m_fMore = fRc;
}

////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ReadWMIDataBlockAndPutIntoWbemInstance()
{
	//===============================================
    //  Read the data and name blocks
    //===============================================
    HRESULT hr = ProcessDataBlock();
    if( hr == S_OK ){

		//=======================================================
		//  if this isn't a binary mof to process, then we will
		//  process the name block, otherwise we will return
		//  as binary mofs do not have any more useful info in
		//  them in the name block - we already have what we need
		//  from the data block ( at this present time anyway...)
		//=======================================================
		if( !m_Class->GetHardCodedGuidType() ){

			hr = ProcessNameBlock(TRUE);
			if( hr == S_OK ){
        		//===============================================
				//  Get the next node name and data ptrs ready
    			//===============================================
				if( m_pAllWnode ){
					GetNextNode();
				}
   				m_nCurrentInstance++;
			}
		}
    }

    return hr;
}
//=============================================================
HRESULT CWMIDataBlock::ReAllocateBuffer(DWORD dwAddOn)
{
    HRESULT hr = WBEM_E_FAILED;

    m_dwCurrentAllocSize += MEMSIZETOALLOCATE * ((dwAddOn / MEMSIZETOALLOCATE) +1);

	// save the old buffer ptr
    BYTE * pOld = m_pbDataBuffer;

	if( pOld ){
		// save the location of where we are
        ULONG_PTR dwHowmany;
        dwHowmany = (ULONG_PTR)m_pbWorkingDataPtr - (ULONG_PTR)m_pbDataBuffer;

		// get the new buffer
		m_pbDataBuffer = new BYTE[m_dwCurrentAllocSize+1];
		if( m_pbDataBuffer )
        {
		    // copy what we have so far
		    memcpy(m_pbDataBuffer,pOld,dwHowmany);

		    // Set the working ptr to the current place
		    m_pbWorkingDataPtr = m_pbDataBuffer;
		    m_pbWorkingDataPtr += dwHowmany;

		    // delete the old buffer
	        SAFE_DELETE_ARRAY(pOld);
            hr = S_OK;
        }
		else
		{
		    m_dwCurrentAllocSize -= MEMSIZETOALLOCATE * ((dwAddOn / MEMSIZETOALLOCATE) +1);
			m_pbDataBuffer = pOld;
		}
	}

	return hr;
}
//=============================================================
HRESULT CWMIDataBlock::AllocateBuffer(DWORD dwSize)
{
    HRESULT hr = WBEM_E_FAILED;
	m_pbDataBuffer = new byte[dwSize+2];
	if( m_pbDataBuffer )
    {
		hr = S_OK;
	}
    return hr;
}
//=============================================================
void CWMIDataBlock::ResetDataBuffer()
{
	if(m_dwCurrentAllocSize)
	{
		m_dwDataBufferSize = 0;
		m_dwCurrentAllocSize = 0;
		SAFE_DELETE_ARRAY(m_pbDataBuffer);
	}
}
//=============================================================
HRESULT CWMIDataBlock::SetAllInstancePtr( PWNODE_ALL_DATA pwAllNode )
{
	m_pbDataBuffer = (BYTE*)pwAllNode;
    return(SetAllInstanceInfo());
}
//=============================================================
HRESULT CWMIDataBlock::SetSingleInstancePtr( PWNODE_SINGLE_INSTANCE pwSingleNode )
{
	m_pbDataBuffer = (BYTE*)pwSingleNode;
    return(SetSingleInstanceInfo());
}
//=============================================================
HRESULT CWMIDataBlock::SetAllInstanceInfo()
{
    HRESULT hr = WBEM_E_INVALID_OBJECT;
    if( m_pbDataBuffer ){
      	m_pAllWnode = (PWNODE_ALL_DATA)m_pbDataBuffer;
	    m_upNameOffsets = (ULONG *)OffsetToPtr(m_pAllWnode, m_pAllWnode->OffsetInstanceNameOffsets); 
    	m_nCurrentInstance = 1;
	    m_nTotalInstances = m_pAllWnode->InstanceCount;
        m_pHeaderWnode = &(m_pAllWnode->WnodeHeader);
        m_pSingleWnode = NULL;
		if( m_nTotalInstances > 0 ){
			if( ParseHeader() ){
				if( InitializeDataPtr()){
	                hr = S_OK;
		        }
			}
		}
		else{
			hr = WBEM_S_NO_MORE_DATA;
		}
	}
    return hr;
}
//=============================================================
HRESULT CWMIDataBlock::SetSingleInstanceInfo()
{
    HRESULT hr = WBEM_E_INVALID_OBJECT;
    if( m_pbDataBuffer ){
    	m_pSingleWnode = (PWNODE_SINGLE_INSTANCE)m_pbDataBuffer;
	    m_upNameOffsets = (ULONG *)OffsetToPtr(m_pSingleWnode, m_pSingleWnode->OffsetInstanceName); 
	    m_nCurrentInstance = 1;
	    m_nTotalInstances = 1;
        m_pAllWnode = NULL;
        m_pHeaderWnode = &(m_pSingleWnode->WnodeHeader);
        if( ParseHeader() ){
            if( InitializeDataPtr()){
                hr = S_OK;
            }
        }
    }
    return hr;
}
//=============================================================
BOOL CWMIDataBlock::InitializeDataPtr()
{
    //=====================================================
    //  Either the m_pAllWnode or m_pSingleNode is Null,
    //  which ever isn't, is the type we are working with
    //=====================================================
    if(m_pAllWnode){
		if( m_fFixedInstance ){
			m_pbCurrentDataPtr =(BYTE*) (ULONG *)OffsetToPtr(m_pAllWnode, m_pAllWnode->DataBlockOffset);
			//==========================================================================================
			// for the case of binary mofs, we need to know the size of the instance to calculate the
			// crc, so we need to put the whole size of the fixed instance buffer.
			//==========================================================================================
			m_uInstanceSize = m_pAllWnode->FixedInstanceSize;
		}
		else{
            m_pbCurrentDataPtr =(BYTE*)(ULONG*) m_pAllWnode->OffsetInstanceDataAndLength;
		}
		m_pMaxPtr = (ULONG *)OffsetToPtr(m_pAllWnode, m_pHeaderWnode->BufferSize);
    }
    else{
        if( m_pSingleWnode ){
		    m_fFixedInstance = TRUE;
            m_pbCurrentDataPtr = (BYTE*)(ULONG *)OffsetToPtr(m_pSingleWnode, m_pSingleWnode->DataBlockOffset);
		    m_pMaxPtr = (ULONG *)OffsetToPtr(m_pSingleWnode, m_pHeaderWnode->BufferSize);
			//==========================================================================================
			// for the case of binary mofs, we need to know the size of the instance to calculate the
			// crc, so we need to put the whole size of the fixed instance buffer.
			//==========================================================================================
			m_uInstanceSize = m_pSingleWnode->SizeDataBlock;

        }
    }
	if( (ULONG*)m_pbCurrentDataPtr > (ULONG*) m_pMaxPtr ){
		return FALSE;
	}
	if( (ULONG*) m_pbCurrentDataPtr < (ULONG*) m_pAllWnode ){
		return FALSE;
	}

	return TRUE;
}

//=============================================================
BOOL CWMIDataBlock::ParseHeader() 
{
    BOOL fRc;
	//====================================================
    // Check out class to see if it is valid first
	//====================================================
	if( !m_pHeaderWnode ){
		return FALSE;
	}
    m_ulVersion = m_pHeaderWnode->Version;

	if ((m_pHeaderWnode->BufferSize == 0)){
		fRc = FALSE;
	}
    else{
        if (m_pHeaderWnode->Flags &  WNODE_FLAG_FIXED_INSTANCE_SIZE){
		    m_fFixedInstance = TRUE;
        }
	    else{
		    m_fFixedInstance = FALSE;
	    }
    
        fRc = TRUE;
    }
    return fRc;
}
////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::WriteArrayTypes(WCHAR * pwcsProperty, CVARIANT & v)
{
    LONG lType = 0;
    DWORD dwCount = 0;
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    CVARIANT vValue;
    BOOL fDynamic = FALSE;

    m_Class->GetSizeOfArray( lType,dwCount, fDynamic);
	if( fDynamic && dwCount == 0 )
	{
		return WBEM_S_NO_ERROR;
	}


	//============================================================
	//  Make sure we get a valid ptr
	//============================================================
	VARIANT *p = (VARIANT *)v;
	SAFEARRAY * psa = V_ARRAY(p);
    if( IsBadReadPtr( psa, sizeof(SAFEARRAY) != 0)){

		ERRORTRACE((THISPROVIDER,"*****************************************\n"));
		ERRORTRACE((THISPROVIDER,"Class ... %S\n", m_Class->GetClassName()));
		ERRORTRACE((THISPROVIDER,"Current property ... %S\n", pwcsProperty));
		ERRORTRACE((THISPROVIDER,"\n"));
		ERRORTRACE((THISPROVIDER,"array ptr ... %x\n", psa));
		ERRORTRACE((THISPROVIDER,"*****************************************\n"));

        return hr;
    }

	CSAFEARRAY Safe(psa);
	//============================================================
	//  Make sure there is really what we expect in the array
    //  NOTE:  The MAX represents the fixed size of the array,
    //         while if it is a dynamic array, the size is determined
    //         by the property listed in the WMIDATASIZE is property.
    //         either way, the size returned above is the size the
    //         array is supposed to be, if it isn't error out.
	//============================================================
	DWORD dwNumElements = Safe.GetNumElements();
	if( dwNumElements != dwCount )
	{
		Safe.Unbind();

		ERRORTRACE((THISPROVIDER,"*****************************************\n"));
		ERRORTRACE((THISPROVIDER,"Class ... %S\n", m_Class->GetClassName()));
		ERRORTRACE((THISPROVIDER,"Current property ... %S\n", pwcsProperty));
		ERRORTRACE((THISPROVIDER,"\n"));
		ERRORTRACE((THISPROVIDER,"Expected size ... %d\n", dwCount));
		ERRORTRACE((THISPROVIDER,"Current size  ... %d\n", dwNumElements));
		ERRORTRACE((THISPROVIDER,"*****************************************"));

		// Don't need to destroy, it will be destroyed
		return WBEM_E_INVALID_PARAMETER;
	}

    //============================================================
    //  Set missing qualifier value to the value from the NULL
    //============================================================
    if( vValue.GetType() == VT_NULL ){
        ResetMissingQualifierValue(pwcsProperty,psa);
    }

	// if the array is not array of embedded instances
	// then check if the buffer allocated is enough
	if(lType != VT_UNKNOWN)
	{
		// This function check if enought memory is allocated and if not
		// allocates memory
		if(S_OK != GetBufferReady ( m_Class->PropertySize() * ( dwCount + 1 ) ) )
		{
			return WBEM_E_FAILED;
		}
	}
    //============================================================
    //  Now, process it
    //============================================================

    if( dwCount > 0 ){
		// Set each element of the array
		for (DWORD i = 0; i < dwCount; i++){
			if( lType == VT_UNKNOWN ){
				// embedded object
				IUnknown * pUnk = NULL;
				hr = Safe.Get(i, &pUnk); 
				if( pUnk ){
					hr = WriteEmbeddedClass(pUnk,vValue);
				}
				else{
					hr = WBEM_E_FAILED;
				}
			}
			else{

        		CWMIDataTypeMap MapWMIData(this,&m_dwAccumulativeSizeOfBlock);
                
				if(!MapWMIData.SetDataInDataBlock(&Safe,i,vValue,lType,m_Class->PropertySize()) ){
					hr = WBEM_E_FAILED;
					break;
				}
				else{
					hr = S_OK;
				}
			}
            if (WBEM_S_NO_ERROR != hr){
    		    break;
            }
 	    }
    }        
	Safe.Unbind();
	// Don't need to destroy, it will be destroyed
    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ProcessArrayTypes(VARIANT & vToken,WCHAR * pwcsProperty)
{
    LONG lConvertedType = 0, lType = 0;
    DWORD dwCount = 0;
    BOOL fDynamic = TRUE; 

    HRESULT hr = m_Class->GetSizeOfArray( lType,dwCount, fDynamic);
	if( hr != S_OK ){
		return hr;
	}


    if( dwCount > 0 )
	{
		CWMIDataTypeMap MapWMIData(this,&m_dwAccumulativeSizeOfBlock);
	    //======================================================
        // Allocate array with the converted data type.
		// WMI and CIM data types do not match, so use the
		// mapping class to get the correct size of the target
		// property for CIM
	    //======================================================
		lConvertedType = MapWMIData.ConvertType(lType);
        SAFEARRAY * psa = OMSSafeArrayCreate((unsigned short)lConvertedType,dwCount);
        if(psa == NULL)
		{
            return WBEM_E_FAILED;
        }

        //=======================================================   
        //  Now, get the MissingValue for each element of the 
        //  array
        //=======================================================   
		lConvertedType = lType;
		BOOL fMissingValue = FALSE;
	    CVARIANT vQual; 
		SAFEARRAY * psaMissingValue = NULL;
		long lMax = 0;

		CWMIDataTypeMap Map(this,&m_dwAccumulativeSizeOfBlock);
		hr = m_Class->GetQualifierValue( pwcsProperty, L"MissingValue", (CVARIANT *)&vQual );
		if( hr == S_OK )
		{
			if( vQual.GetType() != VT_EMPTY )
			{
				if( vQual.GetType() & VT_ARRAY )
				{
					//============================================================
					//  Make sure we get a valid ptr
					//============================================================
					psaMissingValue = V_ARRAY((VARIANT*)&vQual);
					fMissingValue = TRUE;
					// Don't need to destroy, it will be destroyed in the deconstructor
				}
			}
		}

		CSAFEARRAY SafeMissingValue(psaMissingValue);
		if( fMissingValue )
		{
			lMax = SafeMissingValue.GetNumElements();
		}

	    for (long i = 0; i < (long)dwCount; i++)
		{
            CVARIANT v;

		    if( lType == VT_UNKNOWN )
			{
                // embedded object
                hr = ProcessEmbeddedClass(v);
				if( S_OK == hr )
				{
					MapWMIData.PutInArray(psa,(long *)&i,lConvertedType,(VARIANT * )v);
				}
		    }
		    else
			{
			    hr = MapWMIData.GetDataFromDataBlock(v,lType,m_Class->PropertySize());
				if( hr != S_OK )
				{
					StringCchCopyW ( m_wcsMsg, MSG_SIZE, MSG_INVALID_BLOCK_POINTER );
				}
				else
				{
					BOOL fPutProperty = TRUE;
					if( fMissingValue )
					{
						if( i < lMax )
						{
							CVARIANT vElement;
							if( Map.MissingQualifierValueMatches( &SafeMissingValue, i, vElement, v.GetType(), v ) )
							{
								fPutProperty = FALSE;
							}
						}
					}
					if( fPutProperty )
					{
						MapWMIData.PutInArray(psa,(long *)&i,lConvertedType,(VARIANT * )v);
					}
				}
		    }
            if (WBEM_S_NO_ERROR != hr)
			{
			    break;
            }

	    }
		SafeMissingValue.Unbind();
        vToken.vt = (VARTYPE)(lConvertedType | CIM_FLAG_ARRAY);
        vToken.parray = psa;
    }        
	else{
		hr = WBEM_S_NO_MORE_DATA;
	}
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ProcessEmbeddedClass(CVARIANT & v)
{
	HRESULT hr = WBEM_E_FAILED;

    CWMIProcessClass EmbeddedClass(0);
	hr = EmbeddedClass.Initialize();
	if( S_OK == hr )
	{
		 hr = EmbeddedClass.InitializeEmbeddedClass(m_Class);
		DWORD dwAccumulativeSize = 0;

		CAutoChangePointer p(&m_Class,&EmbeddedClass);
		if( hr == S_OK ){

			//=============================================
			//  Align the embedded class properly
			//=============================================
			int nSize = 0L;
			hr = EmbeddedClass.GetLargestDataTypeInClass(nSize);
			// NTRaid:136388
			// 07/12/00
			if( hr == S_OK && nSize > 0){

				CWMIDataTypeMap Map(this,&m_dwAccumulativeSizeOfBlock);
				if( Map.NaturallyAlignData(nSize, READ_IT)){
					dwAccumulativeSize = m_dwAccumulativeSizeOfBlock - nSize;
					hr = S_OK;
				}
				else{
					hr = WBEM_E_FAILED;
				}
			}
			else
			if(nSize <= 0 && hr == S_OK)
			{
				hr = WBEM_E_FAILED;
			}
		}

		//=============================================
		//  Get the class
		//=============================================
		if( hr == S_OK ){
		
			hr = FillOutProperties();
			if( hr == S_OK ){
				m_dwAccumulativeSizeOfBlock += dwAccumulativeSize;
				//=============================================
				//  Save the object
				//=============================================
				EmbeddedClass.SaveEmbeddedClass(v);
			}
		}
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::WriteEmbeddedClass( IUnknown * pUnknown,CVARIANT & v)
{
	HRESULT hr = WBEM_E_FAILED;
    CWMIProcessClass EmbeddedClass(0);

	hr = EmbeddedClass.Initialize();
	if( S_OK == hr )
	{
		hr = EmbeddedClass.InitializeEmbeddedClass(m_Class);

		CAutoChangePointer p(&m_Class,&EmbeddedClass);

		//=============================================
		hr = EmbeddedClass.ReadEmbeddedClassInstance(pUnknown,v);
		if( hr == S_OK ){
			//=============================================
			//  Align the embedded class properly
			//=============================================
			int nSize = 0L;
			hr = EmbeddedClass.GetLargestDataTypeInClass(nSize);
			if( hr == S_OK && nSize > 0){
				CWMIDataTypeMap Map(this,&m_dwAccumulativeSizeOfBlock);
				if( Map.NaturallyAlignData(nSize,WRITE_IT)){
					m_dwAccumulativeSizeOfBlock -= nSize;
					hr = ConstructDataBlock(FALSE);
				}
				else{
					hr = WBEM_E_FAILED;
				}
			}
			else{
				hr = WBEM_E_FAILED;
			}
		}
	}
    return hr;
}
///////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::SetSingleItem()
{
    WCHAR * pwcsInst = NULL;
    ULONG uRc = E_UNEXPECTED;
    
    if( SUCCEEDED(m_Class->GetInstanceName(pwcsInst)))
    {

        try
        {
           uRc = WmiSetSingleItem( m_hCurrentWMIHandle, pwcsInst, m_Class->WMIDataId(), m_ulVersion, m_dwDataBufferSize, m_pbDataBuffer);
        }
        catch(...)
        {
            // don't throw
        }

        SAFE_DELETE_ARRAY(pwcsInst);
    }

	return(MapReturnCode(uRc));
}

////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::GetBufferReady(DWORD dwCount)
{
	//
	// is accumulation passing allocation already?
	//
    if( ( m_dwAccumulativeSizeOfBlock + dwCount ) >= m_dwCurrentAllocSize )
	{
		if( FAILED(ReAllocateBuffer(dwCount)))
		{
			return WBEM_E_FAILED;
   		}
    }
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::WriteDataToBufferAndIfSinglePropertySubmitToWMI( BOOL fInit, BOOL fPutProperty)
{
    HRESULT hr = WBEM_E_FAILED;
	CIMTYPE lType;
    WCHAR * pwcsProperty;
	CWMIDataTypeMap MapWMIData(this,&m_dwAccumulativeSizeOfBlock);

    if( fInit ){
    	if( !GetDataBlockReady(MEMSIZETOALLOCATE,FALSE) ){
		    return WBEM_E_FAILED;
        }
	}

	//=============================================================
	// get first delimiter in the ordered string	
	//=============================================================
    pwcsProperty = m_Class->FirstProperty();
    
	while (NULL != pwcsProperty){

    	CVARIANT vValue;
	    vValue.Clear();
        memset(&vValue,0,sizeof(CVARIANT));
        //======================================================
	    // Get a property type and value		
	    //======================================================
        hr = m_Class->GetPropertyInInstance(pwcsProperty, vValue, lType);		

	    //======================================================
		//  We need to put in defaults if there are some 
        //  available
	    //======================================================
		if( hr == S_OK ){

           if( ( vValue.GetType() == VT_NULL )&&
                 ( m_Class->PropertyType() != CIM_STRING &&
                 m_Class->PropertyType() != CIM_DATETIME &&
                 m_Class->PropertyCategory() != CWMIProcessClass::Array))
           {

				ERRORTRACE((THISPROVIDER,"*****************************************\n"));
				ERRORTRACE((THISPROVIDER,"Class ... %S\n", m_Class->GetClassName()));
				ERRORTRACE((THISPROVIDER,"Current property ... %S\n", pwcsProperty));
				ERRORTRACE((THISPROVIDER,"\n"));
				ERRORTRACE((THISPROVIDER,"value type ... VT_NULL\n"));
				ERRORTRACE((THISPROVIDER,"cim type ... %d\n", lType));
				ERRORTRACE((THISPROVIDER,"property type ... %d\n", m_Class->PropertyType()));
				ERRORTRACE((THISPROVIDER,"*****************************************\n"));

                hr = WBEM_E_INVALID_PARAMETER;
				break;
    		}
		}

		if( SUCCEEDED(hr) )	{

		    //==================================================
			//  Check to see if the buffer is big enough
			//==================================================
            if( S_OK != GetBufferReady(m_Class->PropertySize())) {
   				return WBEM_E_FAILED;
		    }

            //==================================================
			//  Add the current buffer size
		    //==================================================
            switch( m_Class->PropertyCategory()) {

                case CWMIProcessClass::EmbeddedClass:
				    hr = WriteEmbeddedClass((IUnknown *)NULL,vValue);
   		            break;

                case CWMIProcessClass::Array:
    		        hr = WriteArrayTypes(pwcsProperty,vValue);
	                break;

                case CWMIProcessClass::Data:
                    //============================================================
                    //  Set missing qualifier value to the value from the NULL
                    //============================================================
                    if( vValue.GetType() == VT_NULL ) {

                        ResetMissingQualifierValue(pwcsProperty,vValue);
                    }

					if( !MapWMIData.SetDataInDataBlock( NULL,0,vValue,m_Class->PropertyType(),m_Class->PropertySize())) {

						hr = WBEM_E_FAILED;
					}
	                break;
            }
            //=================================================
            //  If we could not set it, then get out
            //=================================================
            if( hr != S_OK ){
                break;
            }
            //=================================================
            //  If we are supposed to put the single property
            //  at this point, then write it, otherwise, keep
            //  accumulating it.  If it is == NULL, we don't
            //  want it.
            //=================================================
            if( fPutProperty ){

				//=================================================================================
				//  If we are supposed to set just this property, then do so, otherwise don't
				//=================================================================================
                m_dwDataBufferSize = m_dwAccumulativeSizeOfBlock;
				if( m_Class->GetPutProperty() ){

                    if( ( vValue.GetType() == VT_NULL )&& ( m_Class->PropertyType() != CIM_STRING && m_Class->PropertyType() != CIM_DATETIME )){
                        ERRORTRACE((THISPROVIDER,"Datatype does not support NULL values\n"));
                        hr = WBEM_E_INVALID_PARAMETER;
                   }
                    else{
						hr = SetSingleItem();
						if( hr != S_OK ){
							break;
						}
            			if( !GetDataBlockReady(MEMSIZETOALLOCATE,FALSE) ){
    						return hr;
						}
					}
				}
                m_dwAccumulativeSizeOfBlock = 0;
            }
            //=================================================
	    }
		m_dwDataBufferSize = m_dwAccumulativeSizeOfBlock;	
	    pwcsProperty = m_Class->NextProperty();
    }
    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::ConstructDataBlock(BOOL fInit)
{
    return( WriteDataToBufferAndIfSinglePropertySubmitToWMI(fInit,FALSE) );
}    
////////////////////////////////////////////////////////////////////////
HRESULT CWMIDataBlock::PutSingleProperties()
{

    return( WriteDataToBufferAndIfSinglePropertySubmitToWMI(TRUE,TRUE) );
}
////////////////////////////////////////////////////////////////////////
BOOL CWMIDataBlock::GetListOfPropertiesToPut(int nWhich, CVARIANT & vList)
{
    BOOL fRc = FALSE;
    //=========================================================
    //  if nWhich == PUT_PROPERTIES_ONLY, we aren't going to
    //  do anything special, as, by default, the fPutProperty 
    //  flag on the property is set to TRUE, so, in the 
    //  processing above, we will put the properties that are
    //  not NULL.  The only problem we have now, is if 
    //  __PUT_EXT_PROPERTIES is set to TRUE, then we have to
    //  loop through all of the properties to see it they
    //  are in our __PUT_EXT_PROPERTIES list, if they are NOT
    //  then we are going to set the fPutProperty flag on that
    //  property to FALSE, so we won't process it above.
    //=========================================================
    if( nWhich == PUT_PROPERTIES_ONLY ){
        fRc = TRUE;
    }
    else{

    	//=====================================================
    	//  Make sure we get a valid ptr
    	//=====================================================
		SAFEARRAY * psa = V_ARRAY((VARIANT*)vList);
		if( IsBadReadPtr( psa, sizeof(SAFEARRAY) != 0))
		{
			return FALSE;
	    }

		CSAFEARRAY Safe(psa);
		DWORD dwCount = Safe.GetNumElements();

		// Set each element of the array
		for (DWORD i = 0; i < dwCount; i++){
            CBSTR bstrProperty;
            WCHAR * pwcsProperty = NULL;
            //=================================================
            //  Loop thru all the properties in the class and
            //  see which ones are in the list to be PUT
            //=================================================
            pwcsProperty = m_Class->FirstProperty();
            while( pwcsProperty != NULL ){

                BOOL fFound = FALSE;

    		    for (DWORD j = 0; j < dwCount; j++)
                {
                    if( S_OK != Safe.Get(j, &bstrProperty))
                    {
                        return FALSE;
                    }
                    if( wbem_wcsicmp( bstrProperty, pwcsProperty ) == 0 )
                    {
                        fFound = TRUE;
                        break;
                    }
                }
                if( !fFound ){
                    m_Class->SetPutProperty(FALSE);
                }
				pwcsProperty = m_Class->NextProperty();
     	    }
 	    }
		Safe.Unbind();
		// Don't need to destroy, it will be destroyed
		fRc = TRUE;
    }        

    return fRc;
}
//=============================================================
BOOL CWMIDataBlock::GetDataBlockReady(DWORD dwSize,BOOL fReadingData)
{
    BOOL fRc = FALSE;

    ResetDataBuffer();
    m_dwCurrentAllocSize = dwSize;
    if( SUCCEEDED(AllocateBuffer(m_dwCurrentAllocSize)))
    {
        m_pbCurrentDataPtr = m_pbWorkingDataPtr = m_pbDataBuffer;
        //===================================================
        //  If we are writing data, we will let the size
        //  remain at 0, otherwise set it to what the max
        //  is we can read.
        //===================================================
        if(fReadingData){
            m_dwDataBufferSize = dwSize;
        }
        fRc = TRUE;
    }
	else
	{
		m_dwCurrentAllocSize = 0;
	}

	return fRc;
}
//=============================================================
void CWMIDataBlock::AddPadding(DWORD dwBytesToPad)
{
	m_pbWorkingDataPtr += dwBytesToPad ;
}
//=============================================================
inline BOOL CWMIDataBlock::PtrOk(ULONG * pPtr,ULONG uHowMany)
{ 
    ULONG * pNewPtr;
	pNewPtr = (ULONG *)OffsetToPtr(pPtr,uHowMany);
	if(pNewPtr <= m_pMaxPtr){	
		return TRUE;
	}
	return FALSE;
}
//=============================================================
BOOL CWMIDataBlock::CurrentPtrOk(ULONG uHowMany)
{ 
    return(PtrOk((ULONG *)m_pbWorkingDataPtr,uHowMany));
}
//=============================================================
void CWMIDataBlock::GetWord(WORD & wWord)
{
    memcpy( &wWord,m_pbWorkingDataPtr,sizeof(WORD));
	m_pbWorkingDataPtr += sizeof(WORD);
}
//=============================================================
void CWMIDataBlock::GetDWORD(DWORD & dwWord)
{
    memcpy( &dwWord,m_pbWorkingDataPtr,sizeof(DWORD));
	m_pbWorkingDataPtr += sizeof(DWORD);
}
//=============================================================
void CWMIDataBlock::GetFloat(float & fFloat)
{
    memcpy( &fFloat,m_pbWorkingDataPtr,sizeof(float));
	m_pbWorkingDataPtr += sizeof(float);
}
//=============================================================
void CWMIDataBlock::GetDouble(DOUBLE & dDouble)
{
    memcpy( &dDouble,m_pbWorkingDataPtr,sizeof(DOUBLE));
    m_pbWorkingDataPtr += sizeof(DOUBLE);
}
	
//=============================================================
HRESULT CWMIDataBlock::GetSInt64( WCHAR * pwcsBuffer, DWORD cchSize )
{
	HRESULT hr = WBEM_E_FAILED;

	signed __int64 * pInt64;
	pInt64 = (__int64 *)m_pbWorkingDataPtr;
	if ( SUCCEEDED ( hr = StringCchPrintfW ( pwcsBuffer, cchSize, L"%I64d", *pInt64 ) ) )
	{
		m_pbWorkingDataPtr += sizeof( signed __int64);
	}

	return hr;
}
//=============================================================
void CWMIDataBlock::GetQWORD(unsigned __int64 & uInt64)
{
    memcpy( &uInt64,m_pbWorkingDataPtr,sizeof(unsigned __int64));
	m_pbWorkingDataPtr += sizeof(unsigned __int64);
}

//=============================================================
HRESULT CWMIDataBlock::GetUInt64( WCHAR * pwcsBuffer, DWORD cchSize )
{
	HRESULT hr = WBEM_E_FAILED;

	unsigned __int64 * puInt64;
	puInt64 = (unsigned __int64 *)m_pbWorkingDataPtr;
	if ( SUCCEEDED ( hr = StringCchPrintfW ( pwcsBuffer,cchSize, L"%I64u", *puInt64 ) ) )
	{
		m_pbWorkingDataPtr += sizeof(unsigned __int64);
	}

	return hr;
}
//=============================================================
void CWMIDataBlock::GetString(WCHAR * pwcsBuffer,WORD wCount,WORD wBufferSize)
{
	memset(pwcsBuffer,NULL,wBufferSize);
	memcpy(pwcsBuffer,m_pbWorkingDataPtr, wCount);		
	m_pbWorkingDataPtr += wCount;
}
//=============================================================
void CWMIDataBlock::GetByte(BYTE & bByte)
{
    memcpy( &bByte,m_pbWorkingDataPtr,sizeof(BYTE));
	m_pbWorkingDataPtr += sizeof(BYTE);
}
//=============================================================
void CWMIDataBlock::SetWord(WORD wWord)
{
    memcpy(m_pbWorkingDataPtr,&wWord,sizeof(WORD));
	m_pbWorkingDataPtr += sizeof(WORD);
}
//=============================================================
void CWMIDataBlock::SetDWORD(DWORD dwWord)
{
    memcpy(m_pbWorkingDataPtr,&dwWord,sizeof(DWORD));
	m_pbWorkingDataPtr += sizeof(DWORD);
}
//=============================================================
void CWMIDataBlock::SetFloat(float fFloat)
{
    memcpy(m_pbWorkingDataPtr,&fFloat,sizeof(float));
	m_pbWorkingDataPtr += sizeof(float);
}
//=============================================================
void CWMIDataBlock::SetDouble(DOUBLE dDouble)
{
    memcpy( m_pbWorkingDataPtr,&dDouble,sizeof(DOUBLE));
	m_pbWorkingDataPtr += sizeof(DOUBLE);
}
	
//=============================================================
void CWMIDataBlock::SetSInt64(__int64 Int64)
{
    memcpy(m_pbWorkingDataPtr,&Int64,sizeof(__int64));
	m_pbWorkingDataPtr += sizeof(__int64);									
}
//=============================================================
void CWMIDataBlock::SetUInt64(unsigned __int64 UInt64)
{
    memcpy(m_pbWorkingDataPtr,&UInt64,sizeof(unsigned __int64));
	m_pbWorkingDataPtr += sizeof(unsigned __int64);									
}
//=============================================================
void CWMIDataBlock::SetString(WCHAR * pwcsBuffer,WORD wCount)
{
	memcpy(m_pbWorkingDataPtr,pwcsBuffer, wCount);		
	m_pbWorkingDataPtr += wCount;
}
//=============================================================
void CWMIDataBlock::SetByte(byte bByte)
{
    memcpy(m_pbWorkingDataPtr,&bByte,sizeof(byte));
	m_pbWorkingDataPtr += sizeof(byte);

}
///////////////////////////////////////////////////////////////////////////////////////////////////
//*************************************************************************************************
//
//  CProcessStandardDataBlock
//
//*************************************************************************************************

/////////////////////////////////////////////////////////////////////////////////////////////////////////
CProcessStandardDataBlock::CProcessStandardDataBlock() 
{
    m_Class = NULL;
    m_pMethodInput = NULL;
    m_pMethodOutput = NULL;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
CProcessStandardDataBlock::~CProcessStandardDataBlock()
{

}
////////////////////////////////////////////////////////////////////
// WMIRaid:2445
HRESULT CProcessStandardDataBlock::FillOutProperties()	
{
	HRESULT hr = WBEM_E_INVALID_OBJECT;
 
    if( m_Class->GetHardCodedGuidType() )
    {
        hr = ProcessBinaryMof();
	}

    else if(m_Class->GetANewInstance()){
 
       	//=========================================================
	    // get the properties from the class and read the WMI Data
	    //=========================================================
        hr = WBEM_S_NO_ERROR;
        WCHAR * pwcsProperty=NULL;
    	CWMIDataTypeMap MapWMIData(this,&m_dwAccumulativeSizeOfBlock);
		m_dwAccumulativeSizeOfBlock = 0L;						

        pwcsProperty = m_Class->FirstProperty();
        while (NULL != pwcsProperty)
        {
            CVARIANT vToken;
            //=========================================================
            // See if it is an array or not
            //=========================================================
            switch( m_Class->PropertyCategory()){

                case CWMIProcessClass::EmbeddedClass:
                    hr = ProcessEmbeddedClass(vToken);
					if( hr == S_OK )
                    {
						m_Class->PutPropertyInInstance(&vToken);
					}
                    break;

                case CWMIProcessClass::Array:
                    VARIANT v;
                    VariantInit(&v);
                    hr = ProcessArrayTypes(v,pwcsProperty);
                    if( hr == WBEM_S_NO_MORE_DATA )
                    {
                        hr = S_OK;
                    }
                    else if( SUCCEEDED(hr) )
                    {
                        hr = m_Class->PutPropertyInInstance(&v);
	                }
                    VariantClear(&v);
                    break;

                case CWMIProcessClass::Data:

			        hr = MapWMIData.GetDataFromDataBlock(vToken, m_Class->PropertyType(), m_Class->PropertySize());
    	            if( SUCCEEDED(hr) )
                    {
						CWMIDataTypeMap Map(this,&m_dwAccumulativeSizeOfBlock);
						//============================================================
						// We are only going to support this for numerical types
						//============================================================
						CVARIANT vQual;
						hr = m_Class->GetQualifierValue( pwcsProperty, L"MissingValue", (CVARIANT *)&vQual);
						if( hr == S_OK )
						{
							if( vQual.GetType() != VT_EMPTY )
							{
								if( !(Map.MissingQualifierValueMatches( NULL, 0,vQual, vToken.GetType(), vToken ) ))
								{
			                        hr = m_Class->PutPropertyInInstance(&vToken);
								}
							}
							else
							{
								hr = m_Class->PutPropertyInInstance(&vToken);
							}
						}
						else
						{
	                        hr = m_Class->PutPropertyInInstance(&vToken);
						}
	                }
					else
                    {
						StringCchCopyW ( m_wcsMsg, MSG_SIZE, MSG_INVALID_BLOCK_POINTER );
					}
                    break;
	        }
        	pwcsProperty = m_Class->NextProperty();
	    }
        //===============================================
	    // Set the active value
	    //===============================================
        m_Class->SetActiveProperty();
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CProcessStandardDataBlock::CreateOutParameterBlockForMethods()
{
    HRESULT hr = WBEM_E_FAILED;
    BOOL fRc = FALSE;

	//========================================================
	//  If we don't have a class, then we don't have to
	//  worry about creating a block
	//========================================================
	if( !m_pMethodOutput->ValidClass() ){
		ResetDataBuffer();
		return S_OK;
	}
    
    DWORD dwSize = 0L;
    hr = m_pMethodOutput->GetSizeOfClass(dwSize);
    if( hr == S_OK ){
        // Allocate space for property
	    m_dwDataBufferSize = dwSize;
        if( dwSize > 0 ){
            GetDataBlockReady(dwSize,TRUE);
        }
    }
    return hr;
}

//=============================================================
HRESULT CProcessStandardDataBlock::CreateInParameterBlockForMethods( BYTE *& Buffer, ULONG & uBufferSize)
{
    HRESULT hr = WBEM_E_FAILED;
    BOOL fRc = FALSE;

	//========================================================
	//  If we don't have a class, then we don't have to
	//  worry about creating a block
	//========================================================
	if( !m_pMethodInput->ValidClass() ){
		Buffer = NULL;
		uBufferSize = 0;
		return S_OK;
	}

    //========================================================
    // When it goes out of scope, it will reset m_Class back 
    // to what it was
    //========================================================
    CAutoChangePointer p(&m_Class,m_pMethodInput);
	DEBUGTRACE((THISPROVIDER,"Constructing the data block\n"));

	hr = ConstructDataBlock(TRUE);
	if( S_OK == hr ){

		uBufferSize = (ULONG)m_dwDataBufferSize;
		Buffer = new byte[ uBufferSize +1];
        if( Buffer )
        {
	        try
            {
			    memcpy( Buffer, m_pbDataBuffer, uBufferSize );
			    ResetDataBuffer();
			    hr = S_OK;
            }
            catch(...)
            {
                SAFE_DELETE_ARRAY(Buffer);
                hr = WBEM_E_UNEXPECTED;
                throw;
            }
		}
    
	}

    return hr;
}
//=============================================================
HRESULT CProcessStandardDataBlock::ProcessMethodInstanceParameters()
{
	HRESULT hr = WBEM_E_FAILED;

	// Create out-param
	// ================
	m_pMaxPtr = (ULONG *)OffsetToPtr(m_pbDataBuffer, m_dwDataBufferSize);
	m_nCurrentInstance = 1;
	m_nTotalInstances = 1;
	m_pAllWnode = NULL;
	m_pHeaderWnode = NULL;
	m_pbCurrentDataPtr = m_pbWorkingDataPtr = m_pbDataBuffer;
	
    CAutoChangePointer p(&m_Class,m_pMethodOutput);

	hr = FillOutProperties();
	if( hr == S_OK )
	{
        hr = m_pMethodOutput->SendInstanceBack();
	}
    return hr;
}


//=============================================================
// NTRaid:127832
// 07/12/00
//=============================================================
HRESULT CProcessStandardDataBlock::ExecuteMethod(ULONG MethodId, WCHAR * MethodInstanceName, ULONG InputValueBufferSize, 
                                             BYTE * InputValueBuffer )
{
    ULONG uRc = E_UNEXPECTED;

    try
    {
        uRc = WmiExecuteMethod(m_hCurrentWMIHandle, MethodInstanceName, MethodId, InputValueBufferSize,
                               InputValueBuffer,&m_dwDataBufferSize,m_pbDataBuffer);
        if( uRc == ERROR_INSUFFICIENT_BUFFER )
        {
            if( GetDataBlockReady(m_dwDataBufferSize,TRUE))
            {
    	        uRc = WmiExecuteMethod(m_hCurrentWMIHandle, MethodInstanceName, MethodId, InputValueBufferSize,
                                       InputValueBuffer,&m_dwDataBufferSize,m_pbDataBuffer);
            }
        }
    }
    catch(...)
    {
        uRc = E_UNEXPECTED;
        // don't throw
    }

	if( uRc == ERROR_SUCCESS ){
        //===========================================================
        // If we have an out class, process it, otherwise, we are
        // done so set hr to success.
        //===========================================================g
        if( m_pMethodOutput->ValidClass() )
        {
            if(SUCCEEDED(ProcessMethodInstanceParameters())){
                uRc = ERROR_SUCCESS;
            }
        }
	}

    return MapReturnCode(uRc);

}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG CProcessStandardDataBlock::GetDataBufferAndQueryAllData(DWORD dwSize)
{
    ULONG uRc = E_UNEXPECTED;
    if(GetDataBlockReady(dwSize,TRUE))
    {
        try
        {
            uRc = WmiQueryAllData(m_hCurrentWMIHandle, &m_dwDataBufferSize,m_pbDataBuffer);
        }
        catch(...)
        {
            uRc = E_UNEXPECTED;
            // don't throw
        }
    }
    return uRc;
}
/////////////////////////////////////////////////////////////////////
HRESULT CProcessStandardDataBlock::QueryAllData()
{
    HRESULT hr = WBEM_E_FAILED;
	//============================================================
	//  Get the instances
	//============================================================
    ULONG uRc = GetDataBufferAndQueryAllData(sizeof(WNODE_ALL_DATA));
    if( uRc == ERROR_INSUFFICIENT_BUFFER )
    {
        //=================================================
        //  We just want to try one more time to get it,
        //  if it fails, then bail out. m_dwDataBufferSize
        //  should now have the correct size needed in it
        //=================================================
        uRc = GetDataBufferAndQueryAllData(m_dwDataBufferSize);
    }
    //=====================================================
    //  Ok, since we are querying for all instances, make
    //  sure the header node says that all of the instances
    //  are fine, if not reallocate
    //=====================================================
	if( uRc == ERROR_SUCCESS )
    {
        if( S_OK ==(hr = SetAllInstanceInfo()))
        {
	        if (m_pHeaderWnode->Flags &  WNODE_FLAG_TOO_SMALL)
            {
                while( TRUE )
                {
                    //==========================================================
                    //  keep on querying until we get the correct size
                    //  This error may come from the driver
                    //==========================================================
                    uRc = GetDataBufferAndQueryAllData(m_dwDataBufferSize);
                    if( uRc == ERROR_SUCCESS )
                    {
                        if( S_OK ==(hr = SetAllInstanceInfo()))
                        {
                            if (!(m_pHeaderWnode->Flags &  WNODE_FLAG_TOO_SMALL))
                            {
                                break;
        		            }
			            }
                    } // end GetDataBufferAndQueryAllData
                } // end of while
            } // end of WNODE_FLAG_TOO_SMALL test
        } // end of SetAllInstanceInfo
    }

    //==========================================================================
    //  if uRc succeeded, then the return code is already set by SetAllInstance
    //  otherwise need to map it out
    //==========================================================================
    if( uRc != ERROR_SUCCESS )
    {
        hr  = MapReturnCode(uRc);
    }
 	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG CProcessStandardDataBlock::GetDataBufferAndQuerySingleInstance(DWORD dwSize,WCHAR * wcsInstanceName)
{
    ULONG uRc = E_UNEXPECTED;
    if(GetDataBlockReady(dwSize,TRUE))
    {
        try
        {
	        uRc = WmiQuerySingleInstance(m_hCurrentWMIHandle, wcsInstanceName, &m_dwDataBufferSize, m_pbDataBuffer);
        }
        catch(...)
        {
            uRc = E_UNEXPECTED;
            // don't throw
        }
    }
    return uRc;
}
///////////////////////////////////////////////////////////////////////
HRESULT CProcessStandardDataBlock::QuerySingleInstance(WCHAR * wcsInstanceName)
{
    
	//============================================================
	//  Get the instances
	//============================================================
	DWORD dwChar = wcslen(wcsInstanceName);
	DWORD dwSize =  ROUND_UP_COUNT(sizeof(WNODE_SINGLE_INSTANCE) + dwChar ,8);
    ULONG uRc = GetDataBufferAndQuerySingleInstance(dwSize,wcsInstanceName);
    if( uRc == ERROR_INSUFFICIENT_BUFFER )
    {
        uRc = GetDataBufferAndQuerySingleInstance(m_dwDataBufferSize,wcsInstanceName);
    }

	if( uRc == ERROR_SUCCESS )
    {
		return(SetSingleInstanceInfo());
    }

	return(MapReturnCode(uRc));
}
///////////////////////////////////////////////////////////////////////
// NTRaid : 136392
//	07/12/00
HRESULT CProcessStandardDataBlock::SetSingleInstance()
{
    ULONG uRc = S_OK;

    WCHAR * pwcsInst = NULL;
    
    if( SUCCEEDED(m_Class->GetInstanceName(pwcsInst)))
    {

        try
        {
            uRc = WmiSetSingleInstance( m_hCurrentWMIHandle, pwcsInst,1,m_dwDataBufferSize,m_pbDataBuffer);
        }
        catch(...)
        {
            uRc = E_UNEXPECTED;
            // don't throw
        }
        SAFE_DELETE_ARRAY(pwcsInst);
    }
    
	return(MapReturnCode(uRc));
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************************
//
// CProcessHiPerfDataBlock
//
//*******************************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CProcessHiPerfDataBlock::OpenHiPerfHandle()
{
    HRESULT hr = WBEM_E_FAILED;
    ULONG uRc = ERROR_SUCCESS;
    //========================================================
    //  Open the handle
    //========================================================
    try
    {
        uRc = WmiOpenBlock(m_Class->GuidPtr(),m_uDesiredAccess, &m_hCurrentWMIHandle);
        if( uRc == ERROR_SUCCESS )
        {
           // WMIINTERFACE->HandleMap()->Add(*(m_Class->GuidPtr()),m_hCurrentWMIHandle);
	    }
    }
    catch(...)
    {
        hr = E_UNEXPECTED;
        // don't throw
    }

	return MapReturnCode(uRc);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////

ULONG CProcessHiPerfDataBlock::GetDataBufferAndHiPerfQueryAllData(DWORD dwSize,WMIHANDLE * List, long lHandleCount)
{
    ULONG uRc = E_UNEXPECTED;
    if(GetDataBlockReady(dwSize,TRUE))
    {
        try
        {
            uRc = WmiQueryAllDataMultiple(List, lHandleCount, &m_dwDataBufferSize,m_pbDataBuffer);
        }
        catch(...)
        {
            uRc = E_UNEXPECTED;
            // don't throw
        }
    }
    return uRc;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CProcessHiPerfDataBlock::HiPerfQueryAllData(WMIHANDLE * List,long lHandleCount)
{
    HRESULT hr = WBEM_E_FAILED;
	//============================================================
	//  Get the instances
	//============================================================
    ULONG uRc = GetDataBufferAndHiPerfQueryAllData(sizeof(WNODE_ALL_DATA)*lHandleCount,List,lHandleCount);
    if( uRc == ERROR_INSUFFICIENT_BUFFER )
    {
        //=================================================
        //  We just want to try one more time to get it,
        //  if it fails, then bail out. m_dwDataBufferSize
        //  should now have the correct size needed in it
        //=================================================
        uRc = GetDataBufferAndHiPerfQueryAllData(m_dwDataBufferSize,List,lHandleCount);
    }
    //=====================================================
    //  Ok, since we are querying for all instances, make
    //  sure the header node says that all of the instances
    //  are fine, if not reallocate
    //=====================================================
	if( uRc == ERROR_SUCCESS )
    {
        if( S_OK ==(hr = SetAllInstanceInfo()))
        {
	        if (m_pHeaderWnode->Flags &  WNODE_FLAG_TOO_SMALL)
            {
                while( TRUE )
                {
                    //==========================================================
                    //  keep on querying until we get the correct size
                    //  This error may come from the driver
                    //==========================================================
                    uRc = GetDataBufferAndHiPerfQueryAllData(m_dwDataBufferSize,List,lHandleCount);
                    if( uRc == ERROR_SUCCESS )
                    {
                        if( S_OK ==(hr = SetAllInstanceInfo()))
                        {
                            if (!(m_pHeaderWnode->Flags &  WNODE_FLAG_TOO_SMALL))
                            {
                                break;
        		            }
			            }
                    } // end GetDataBufferAndQueryAllData
                } // end of while
            } // end of WNODE_FLAG_TOO_SMALL test
        } // end of SetAllInstanceInfo
	}
    //==========================================================================
    //  if uRc succeeded, then the return code is already set by SetAllInstance
    //  otherwise need to map it out
    //==========================================================================
    if( uRc != ERROR_SUCCESS )
    {
        hr  = MapReturnCode(uRc);
    }

 	return(hr);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG CProcessHiPerfDataBlock::GetDataBufferAndHiPerfQuerySingleInstance( DWORD dwSize,WMIHANDLE *List, PWCHAR * pInstances,long lHandleCount)
{
    ULONG uRc = E_UNEXPECTED;
    if(GetDataBlockReady(dwSize,TRUE))
    {
        try
        {
	        uRc = WmiQuerySingleInstanceMultiple( List, pInstances, lHandleCount, &m_dwDataBufferSize, m_pbDataBuffer);
        }
        catch(...)
        {
            uRc = E_UNEXPECTED;
            // don't throw
        }
    }
    return uRc;
}

///////////////////////////////////////////////////////////////////////
HRESULT CProcessHiPerfDataBlock::HiPerfQuerySingleInstance(WMIHANDLE *List, PWCHAR * pInstances, DWORD dwInstanceNameSize, long lHandleCount)
{
 	//============================================================
	//  Get the instances
	//============================================================
    ULONG uRc = GetDataBufferAndHiPerfQuerySingleInstance((sizeof(WNODE_SINGLE_INSTANCE)*lHandleCount) + dwInstanceNameSize ,List,pInstances,lHandleCount);
    if( uRc == ERROR_INSUFFICIENT_BUFFER )
    {
        uRc = GetDataBufferAndHiPerfQuerySingleInstance(m_dwDataBufferSize,List,pInstances,lHandleCount);
    }

	if( uRc == ERROR_SUCCESS )
    {
		return(SetSingleInstanceInfo());
    }

	return(MapReturnCode(uRc));
}
////////////////////////////////////////////////////////////////////
HRESULT CProcessHiPerfDataBlock::FillOutProperties()	
{
	HRESULT hr = WBEM_E_INVALID_OBJECT;
    //=========================================================
	// get the properties from the class and read the WMI Data
	//=========================================================
    if(m_Class->GetANewInstance()){


        WCHAR * pwcsProperty=NULL;
        CWMIDataTypeMap MapWMIData(this,&m_dwAccumulativeSizeOfBlock);
	    m_dwAccumulativeSizeOfBlock = 0L;						

        pwcsProperty = m_Class->FirstProperty();
        while (NULL != pwcsProperty){

            //=========================================================
            // We do not support arrays or embedded classes
            //=========================================================
            if( ( CWMIProcessClass::EmbeddedClass == m_Class->PropertyCategory()) ||
                ( CWMIProcessClass::Array == m_Class->PropertyCategory() ) ){
					hr = WMI_INVALID_HIPERFPROP;
					ERRORTRACE((THISPROVIDER,"Class %S has embedded class or array property\n",m_Class->GetClassName()));
                    break;
            }

	        hr = MapWMIData.GetDataFromDataBlock(m_Class->GetAccessInstancePtr(), m_Class->GetPropertyHandle(), m_Class->PropertyType(), m_Class->PropertySize());
            if( FAILED(hr) ){
                break;
	        }

            pwcsProperty = m_Class->NextProperty();
	    }
    }

    //====================================================================
    //  Now, fill in the specific HI PERF properties
    //====================================================================
    if( hr == S_OK )
    {
         hr = m_Class->SetHiPerfProperties(m_pHeaderWnode->TimeStamp);
    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  This function searches the standard HandleMap for the handle and if it isn't there, it is added.
//  The hiperf handles are added/mapped elsewhere.
///////////////////////////////////////////////////////////
HRESULT CProcessHiPerfDataBlock::GetWMIHandle(HANDLE & lWMIHandle)
{
    HRESULT hr = WBEM_E_FAILED;

    lWMIHandle = 0;
    hr = WMIINTERFACE->HandleMap()->GetHandle(*(m_Class->GuidPtr()),lWMIHandle);
    if( hr != ERROR_SUCCESS )
    {
         hr = OpenHiPerfHandle();
         if( SUCCEEDED(hr))
         {
             lWMIHandle = m_hCurrentWMIHandle;
             hr = WMIINTERFACE->HandleMap()->Add( *(m_Class->GuidPtr()), lWMIHandle,WMIGUID_QUERY );
         }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\wmimap.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#ifndef _WMIMAP_HEADER
#define _WMIMAP_HEADER

#define WRITE_IT 0
#define READ_IT  1

///////////////////////////////////////////////////////////////////////
class CWMIDataTypeMap
{

	public:
        CWMIDataTypeMap()
            { m_pWMIBlockInfo = NULL; m_pdwAccumulativeSizeOfBlock = NULL; }

        CWMIDataTypeMap(CWMIDataBlock * pBlock, DWORD * pdw)
            { m_pWMIBlockInfo = pBlock; m_pdwAccumulativeSizeOfBlock = pdw; }
		~CWMIDataTypeMap(){}

 		int  GetWMISize(long lType);

		long GetVariantType(WCHAR * wcsType);
		long ConvertType(long lType );

		void GetSizeAndType( WCHAR * wcsType, IDOrder * p,  long & lType,  int & nWMISize );
        
        DWORD ArraySize(long lType,CVARIANT & var);

		HRESULT GetDataFromDataBlock(CVARIANT & v,long lType, int nSize );
		HRESULT GetDataFromDataBlock(IWbemObjectAccess * p, long lHandle, long lType, int nSize);
		HRESULT PutInArray(SAFEARRAY * & psa,long * pi, long & lType, VARIANT * var);
        
        WCHAR * SetVariantType(long lType);

        BOOL SetDataInDataBlock(CSAFEARRAY * pSafe,int i,CVARIANT & v, long lType, int nSize);
        BOOL NaturallyAlignData( int nSize, BOOL fRead);
		BOOL MissingQualifierValueMatches( CSAFEARRAY * pSafe, long index, CVARIANT & v, long lType, CVARIANT & vToCompare );
        BOOL SetDefaultMissingQualifierValue( CVARIANT & v, long lType, CVARIANT & vToSet );

	private:
		BOOL ConvertDWORDToWMIDataTypeAndWriteItToBlock(DWORD dwLong,int nSize);
		DWORD ConvertWMIDataTypeToDWORD(int nSize);

        CWMIDataBlock   * m_pWMIBlockInfo;
        DWORD           * m_pdwAccumulativeSizeOfBlock;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\wmimof.cpp ===
/////////////////////////////////////////////////////////////////////
//
//  BINMOF.CPP
//
//  Module:
//  Purpose:
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////
#include "wmicom.h"
#include "wmimof.h"
#include <wchar.h>
#include <stdio.h>
#include "wdmshell.h"
#include <cregcls.h>
#include <bmof.h>
#include <mrcicode.h>
#include <mofcomp.h>
#include <crc32.h>
#include <TCHAR.h>
#include <autoptr.h>

#include <comdef.h>

#include <strutils.h>

//
// auto variables
//
#include <ScopeGuard.h>

#if defined(_M_IA64)
//
// NTBUG#744176
//

template void deleteArray<unsigned char>(unsigned char*);
template void deleteArray<unsigned short>(unsigned short*);
template void deletePtr<CWMIStandardShell>(const CWMIStandardShell*);
template void deletePtr<CNamespaceManagement>(const CNamespaceManagement*);

#endif

#define WDM_REG_KEY			L"Software\\Microsoft\\WBEM\\WDM"
#define WDM_DREDGE_KEY		L"Software\\Microsoft\\WBEM\\WDM\\DREDGE"
#define DREDGE_KEY			L"DREDGE"

///////////////////////////////////////////////////////////////////////////////////////////
//***************************************************************************
//
//  void * BMOFAlloc
//
//  DESCRIPTION:
//
//  Provides allocation service for BMOF.C.  This allows users to choose
//  the allocation method that is used.
//
//  PARAMETERS:
//
//  Size                Input.  Size of allocation in bytes.
//
//  RETURN VALUE:
//
//  pointer to new data.  NULL if allocation failed.
//
//***************************************************************************

void * BMOFAlloc(size_t Size)
{
    return malloc(Size);
}
//***************************************************************************
//
//  void BMOFFree
//
//  DESCRIPTION:
//
//  Provides allocation service for BMOF.C.  This frees what ever was
//  allocated via BMOFAlloc.
//
//  PARAMETERS:
//
//  pointer to memory to be freed.
//
//***************************************************************************

void BMOFFree(void * pFree)
{
   free(pFree);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT ConvertStringToCTypeString( WCHAR * Out, int cchSizeOut, WCHAR * In )
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    WCHAR * token = NULL;

    if(In)
    {
        CAutoWChar tmpBuf(_MAX_PATH*2);
        if( tmpBuf.Valid() )
        {
            if ( hr = SUCCEEDED ( StringCchCopyW ((WCHAR*)tmpBuf,_MAX_PATH*2,In) ) ) 
            {
                token = wcstok( (WCHAR*)tmpBuf, L"\\" );
                if( !token )
                {
                    hr = StringCchCopyW (Out,cchSizeOut,In);
                }
                else
                {
                    hr = WBEM_S_FALSE;
                    BOOL fFirst = TRUE;
                    while( SUCCEEDED ( hr ) && token != NULL )
                    {
                        if( fFirst )
                        {
                            hr = StringCchCopyW(Out,cchSizeOut,token);
                            fFirst = FALSE;
                        }
                        else
                        {
                            if ( SUCCEEDED ( hr = StringCchCatW(Out,cchSizeOut,L"\\\\") ) )
                            {
                                hr = StringCchCatW(Out,cchSizeOut,token);
                            }
                        }
                        token = wcstok( NULL, L"\\" );
                    }
                }
            }
        }
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************
//  The binary mof class
//*****************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////
CWMIBinMof::CWMIBinMof()
{
    m_pCompiler    = NULL;
    m_pWMI = NULL;
    m_nInit = NOT_INITIALIZED;
    m_pMofResourceInfo = NULL;
}

/////////////////////////////////////////////////////////////////////


HRESULT CWMIBinMof::InitializePtrs	(
										CHandleMap * pList,
										IWbemServices __RPC_FAR * pServices,	
										IWbemServices __RPC_FAR * pRepository,	
										IWbemObjectSink __RPC_FAR * pHandler,
										IWbemContext __RPC_FAR *pCtx
									)
{
    HRESULT hr = WBEM_E_FAILED;


	SAFE_DELETE_PTR(m_pWMI);
	m_pWMI = new CWMIManagement;
	if( m_pWMI )
	{
		m_pWMI->SetWMIPointers(pList, pServices, pRepository, pHandler, pCtx);
		m_nInit = FULLY_INITIALIZED;
		hr = S_OK;
	}
	return hr;

}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::Initialize(CWMIManagement * p,BOOL fUpdateNamespace)
{

	HRESULT hr = WBEM_E_FAILED;
	if( p )
	{
		hr = InitializePtrs(p->HandleMap(),p->Services(),p->Repository(),p->Handler(),p->Context());
	}
	else
	{
		m_nInit = PARTIALLY_INITIALIZED;
		hr = S_OK;
	}
	m_fUpdateNamespace = fUpdateNamespace;
	return hr;

}
/////////////////////////////////////////////////////////////////////

HRESULT CWMIBinMof::Initialize	(
									CHandleMap * pList,
									BOOL fUpdateNamespace,
									ULONG uDesiredAccess,
									IWbemServices __RPC_FAR * pServices,
									IWbemServices __RPC_FAR * pRepository,
									IWbemObjectSink __RPC_FAR * pHandler, 
									IWbemContext __RPC_FAR *pCtx
								)
{

	HRESULT hr = WBEM_E_FAILED;
	hr = InitializePtrs(pList,pServices,pRepository,pHandler,pCtx);
	m_fUpdateNamespace = fUpdateNamespace;

    return hr;
}
/////////////////////////////////////////////////////////////////////
CWMIBinMof::~CWMIBinMof()
{
    SAFE_RELEASE_PTR(m_pCompiler);
    SAFE_DELETE_PTR(m_pWMI);
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::OpenFileAndLookForItIfItDoesNotExist(wmilib::auto_buffer<TCHAR> & pFile, HANDLE & hFile )
{
    HRESULT hr = S_OK;

    //=========================================================================
    //  Ok, hopefully CreateFile will find it 
    //=========================================================================
    hFile = CreateFile(pFile.get(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if( hFile != INVALID_HANDLE_VALUE )
    {
        return S_OK;
    }

    // cache last error value
    DWORD dwLastError = ::GetLastError ();

    hr = WBEM_E_FAILED;
    //=====================================================================
    //  CreateFile DIDN'T find it, so look in the Windows dir
    //=====================================================================
    wmilib::auto_ptr<TCHAR> pszSysDir( new TCHAR[MAX_PATH+1]);
    if ( NULL == pszSysDir.get() ) return WBEM_E_OUT_OF_MEMORY;;

    UINT uSize = GetSystemDirectory(pszSysDir.get(), MAX_PATH+1);
    if( 0 == uSize )
    {
        ::SetLastError ( dwLastError );
        return WBEM_E_FAILED;
     }            

    if ( uSize > MAX_PATH )
    {
        pszSysDir.reset( new TCHAR [ uSize + 1 ]);
        if ( NULL == pszSysDir.get()) return WBEM_E_OUT_OF_MEMORY;
        if (!GetSystemDirectory( pszSysDir.get(), uSize + 1 ) )
        {
            return WBEM_E_FAILED;
        }
    }
    
    wmilib::auto_buffer<TCHAR> pFileNew( new TCHAR[MAX_PATH*2 + 1]);
    if( NULL == pFileNew.get() ) return WBEM_E_OUT_OF_MEMORY;

    if (FAILED( hr = StringCchPrintfW ( pFileNew.get(), MAX_PATH*2 + 1, L"%s\\%s", pszSysDir.get(), pFile.get())))
    {
        ::SetLastError ( dwLastError );
        return WBEM_E_FAILED;
    }

    //=============================================================
    //  Ok, now try to open again
    //=============================================================
    hFile = CreateFile(pFileNew.get(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if( hFile == INVALID_HANDLE_VALUE )
    {
        ::SetLastError ( dwLastError );
        return WBEM_E_FAILED;                  
    }

    pFile.reset(pFileNew.release());
    
    return S_OK;
}
/////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::GetFileDateAndTime(ULONG & lLowDateTime,ULONG & lHighDateTime,WCHAR  * wcsFileName, int cchSize)
{
    HANDLE hFile = NULL;
    FILETIME ftCreationTime, ftLastAccessTime, ftLastWriteTime,ftLocal;
    BOOL fRc = FALSE;
    wmilib::auto_buffer<TCHAR> pFile;

    if( ExtractFileNameFromKey(pFile,wcsFileName,cchSize) )
    {
        if( SUCCEEDED(OpenFileAndLookForItIfItDoesNotExist( pFile, hFile )))
        {
            if( GetFileTime( hFile, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime ))
            {
                //==========================================================
                // Pick up the path of the file while we are here....
                //==========================================================
                TCHAR sFullPath[MAX_PATH * 4];
                TCHAR *sFilename = NULL;

                if (GetFullPathName(pFile.get(), MAX_PATH * 4, sFullPath, &sFilename) != 0)
                {
                    StringCchCopyW ( wcsFileName, MAX_PATH*4, sFullPath );
                }
                else
                {
                    DWORD dwTest = GetLastError();
                    ERRORTRACE((THISPROVIDER,"GetFullPathName FAILED for filename: \n"));
                    TranslateAndLog(wcsFileName);
                    ERRORTRACE((THISPROVIDER,": GetlastError returned %ld\n",dwTest));
                }

                FileTimeToLocalFileTime( &ftLastWriteTime, &ftLocal);

                lLowDateTime  = (ULONG)ftLocal.dwLowDateTime;
                lHighDateTime = (ULONG)ftLocal.dwHighDateTime;

                fRc = TRUE;
            }
            else
            {
                    DWORD dwTest = GetLastError();
                    ERRORTRACE((THISPROVIDER,"GetFileTime FAILED for filename:\n"));
                    TranslateAndLog(wcsFileName);
                    ERRORTRACE((THISPROVIDER,": GetlastError returned %ld\n",dwTest));
               }

            CloseHandle(hFile);
        }
        else
        {
            DWORD dwTest = GetLastError();
            ERRORTRACE((THISPROVIDER,"CreateFile FAILED for filename:\n"));
            TranslateAndLog(wcsFileName);
            ERRORTRACE((THISPROVIDER,": GetlastError returned %ld\n",dwTest));
        }

    }
    else
    {
        DWORD dwTest = GetLastError();
        ERRORTRACE((THISPROVIDER,"Can't extract filename: \n"));
        TranslateAndLog(wcsFileName);
        ERRORTRACE((THISPROVIDER,": GetlastError returned %ld\n",dwTest));
    }
    
    return fRc;
}
/////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::NeedToProcessThisMof( WCHAR * wcsFileName,ULONG & lLowDateTime, ULONG & lHighDateTime )
{
    BOOL fNeedToProcessThisMof = TRUE;
    HRESULT hr = WBEM_E_OUT_OF_MEMORY;
    IWbemClassObject * pClass=NULL;
    CAutoWChar wcsBuf(_MAX_PATH*4);
    CAutoWChar wcsTmp(_MAX_PATH*4);
    if( wcsTmp.Valid() && wcsBuf.Valid() )
    {

        //==================================================
        // Change all \ to \\
        //==================================================
        if ( SUCCEEDED ( hr = ConvertStringToCTypeString( wcsTmp,_MAX_PATH*4,wcsFileName ) ) )
        {
            if ( SUCCEEDED ( hr = StringCchPrintfW(wcsBuf,_MAX_PATH*4,L"WmiBinaryMofResource.HighDateTime=%lu,LowDateTime=%lu,Name=\"%s\"",lHighDateTime,lLowDateTime,wcsTmp) ) )
            {
                //==================================================
                //  Get a pointer to a IWbemClassObject object
                //  Have we ever processed this mof before?
                //  if not, then return TRUE
                //==================================================

                if( m_fUpdateNamespace )
                {
                    CBSTR cbstr(wcsBuf);
                    hr = REPOSITORY->GetObject(cbstr, 0,CONTEXT, &pClass, NULL);
                    if(WBEM_NO_ERROR == hr)
                    {  
                        fNeedToProcessThisMof = FALSE;
                        CVARIANT vSuccess;
                
                        hr = pClass->Get(L"MofProcessed", 0, &vSuccess, 0, 0);
                        if( hr == WBEM_NO_ERROR )
                        {
                            //=========================================================================
                            // make sure it is added to the registry
                            //=========================================================================
                            AddThisMofToRegistryIfNeeded(WDM_REG_KEY,wcsFileName,lLowDateTime,lHighDateTime,vSuccess.GetBool());
                        }
                        SAFE_RELEASE_PTR( pClass);
                    }
                    //==============================================================================
                    //  Delete any old instances that might be hanging around for this driver
                    //==============================================================================
                    IEnumWbemClassObject* pEnum = NULL;
                    CAutoWChar wcsQuery(MEMSIZETOALLOCATE);
                    if( wcsQuery.Valid() )
                    {
                        ULONG uReturned = 0;
                        if ( SUCCEEDED ( hr = StringCchPrintfW(wcsQuery,MEMSIZETOALLOCATE,L"select * from WMIBinaryMofResource where Name = \"%s\"",wcsTmp) ) )
                        {
                            CBSTR bstrTemp = wcsQuery;
                            CBSTR strQryLang(L"WQL");

							hr = REPOSITORY->ExecQuery(strQryLang, bstrTemp, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,CONTEXT,&pEnum);
							if( hr == WBEM_NO_ERROR )
							{
    							IWbemClassObject * pClass = NULL;
								while( TRUE )
								{
									if( WBEM_NO_ERROR == (hr = pEnum->Next(2000, 1, &pClass, &uReturned)))
									{
										CVARIANT vPath, vDriver;
										hr = pClass->Get(L"__RELPATH", 0, &vPath, 0, 0);
										if( hr == WBEM_NO_ERROR )
										{
											if( vPath.GetStr() )
											{
												if( wbem_wcsicmp(vPath.GetStr(),wcsBuf) != 0 )
												{
													hr = REPOSITORY->DeleteInstance(vPath.GetStr(),0,CONTEXT,NULL);
                                                    if ( FAILED ( hr ) )
                                                    {
                                                        ERRORTRACE((THISPROVIDER,"We have been requested to delete this mof:\n"));
                                                        TranslateAndLog(vPath.GetStr());
                                                        ERRORTRACE((THISPROVIDER,"It failed with 0x%08lx\n", hr));
                                                    }
                                                    else
                                                    {
                                                        DEBUGTRACE((THISPROVIDER,"We have been requested to delete this mof:\n"));
                                                        TranslateAndLog(vPath.GetStr(), TRUE);
                                                    }

                                                    if( hr == WBEM_NO_ERROR )
                                                    {
                                                        //=====================================================
                                                        //  Duplicate change in registry
                                                        //=====================================================
                                                        DeleteMofFromRegistry( vPath.GetStr() );
                                                        //==========================================================================
                                                        //  Gets rid of the old classes for the old versions of this driver
                                                        //==========================================================================
                                                        hr = pClass->Get(L"Driver", 0, &vDriver, 0, 0);
                                                        if( hr == WBEM_NO_ERROR )
                                                        {
                                                            CNamespaceManagement Namespace(this);
                                                            Namespace.DeleteOldClasses(vDriver.GetStr(),CVARIANT((long)lLowDateTime),CVARIANT((long)lHighDateTime), TRUE);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    SAFE_RELEASE_PTR( pClass );
                                    if( hr != WBEM_NO_ERROR )
                                    {
                                        break;
                                    }
                                }

                                SAFE_RELEASE_PTR(pEnum);
                            }
                        }
                    }
                }
                else
                {
                    if( ThisMofExistsInRegistry(WDM_DREDGE_KEY,wcsFileName, lLowDateTime, lHighDateTime, TRUE) )
                    { 
                        fNeedToProcessThisMof = FALSE;
                    }
                }
            }
        }
    }
    return fNeedToProcessThisMof;
}
/////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::UpdateMofTimestampInHMOM(WCHAR * wcsKey,ULONG & lLowDateTime, ULONG & lHighDateTime, BOOL fSuccess )
{
    BOOL fRc = FALSE;
    IWbemClassObject * pNewInst = NULL;
    IWbemClassObject * pIWbemClassObject = NULL;
    //==================================================
    //  Get a pointer to a IWbemClassObject object
    //==================================================
    HRESULT hr = WBEM_NO_ERROR;
    if( m_fUpdateNamespace )
    {
        CVARIANT cvarName;
        cvarName.SetStr(L"WMIBinaryMofResource");
        hr = REPOSITORY->GetObject(cvarName, 0,CONTEXT, &pIWbemClassObject, NULL);        
        if(WBEM_NO_ERROR ==  hr)
        {
               //=============================================================
            //  Spawn a new instance
            //=============================================================
            hr = pIWbemClassObject->SpawnInstance(0, &pNewInst);
            SAFE_RELEASE_PTR(pIWbemClassObject);
            if( WBEM_NO_ERROR == hr )
            {
                CVARIANT vLow, vHigh, vName, vSuccess;

                vSuccess.SetBool(fSuccess);
                vName.SetStr(wcsKey);
                vLow.SetLONG(lLowDateTime);
                vHigh.SetLONG(lHighDateTime);
            
                hr = pNewInst->Put(L"Name", 0, &vName, NULL);
                if( S_OK == hr )
                {
                    hr = pNewInst->Put(L"LowDateTime", 0, &vLow, NULL);
                    if( S_OK == hr )
                    {
                        hr = pNewInst->Put(L"HighDateTime", 0, &vHigh, NULL);
                        if( S_OK == hr )
                        {
                            hr = pNewInst->Put(L"MofProcessed", 0, &vSuccess, NULL);
                            if( S_OK == hr )
                            {
                                CVARIANT vActive;
                                vActive.SetBool(TRUE);
                                pNewInst->Put(L"Active", 0, &vActive, NULL);
                            }
        
                            hr = REPOSITORY->PutInstance(pNewInst,WBEM_FLAG_CREATE_OR_UPDATE,CONTEXT,NULL);
                            SAFE_RELEASE_PTR(pNewInst);
                        }
                    }
                }
            }
        }
    }

    if( hr == WBEM_NO_ERROR )
    {
        //==========================================
        //  Make sure this really is in the registry
        //  too
        //==========================================
        if( WBEM_NO_ERROR == AddThisMofToRegistryIfNeeded(WDM_REG_KEY,wcsKey,lLowDateTime,lHighDateTime,fSuccess))
        {
            fRc = TRUE;
        }
    }
    return fRc;
}
///////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::GetNextSectionFromTheEnd(WCHAR * pwcsTempPath, WCHAR * pwcsEnd, int cchSize )
{
    BOOL fReturn = FALSE;
    WCHAR * pc = wcsrchr(pwcsTempPath,'\\');
    if(pc)
    {
        //==================================================
        // Copy what was there and set the end to NULL
        //==================================================
        pc++;

        if ( *pc )
        {
            if ( SUCCEEDED ( StringCchCopyW ( pwcsEnd, cchSize, pc ) ) )
            {
                fReturn = TRUE;
            }
        }
        pc--;
        *(pc) = NULL;  
    }
    return fReturn;
}
///////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::UseDefaultLocaleId(WCHAR * wcsFile, WORD & wLocalId)
{
    BOOL fLoadDefaultLocale = TRUE;

    //=============================================================
    //  Parse paths - get the locale id from paths of this format:
    //
    //  check for path beginning with %windir% and with MUI in second to last position
    //  if not found, check for fixed directory: %windir%\MUI\Fallback
    //  if not found - assume it is not MUI related and try it with FindResource
    //
     //=============================================================
    TCHAR* szWindowsDir = new TCHAR[_MAX_PATH + 1];
    if ( szWindowsDir )
    {
        UINT uSize = GetWindowsDirectory ( szWindowsDir , _MAX_PATH + 1);
        if ( uSize )
        {
            if ( uSize > MAX_PATH )
            {
                SAFE_DELETE_ARRAY ( szWindowsDir );
                szWindowsDir = new TCHAR [ uSize + 1 ];
                if ( szWindowsDir )
                {
                    if ( ! GetWindowsDirectory( szWindowsDir, uSize + 1 ) )
                    {
                        SAFE_DELETE_ARRAY ( szWindowsDir );
                        return fLoadDefaultLocale;
                    }
                }
                else
                {
                    return fLoadDefaultLocale;
                }
            }

            //==========================================================
            //  if these are windows directories
            //==========================================================
            if( 0 == wbem_wcsnicmp( szWindowsDir, wcsFile, wcslen(szWindowsDir)))
            {
                CAutoWChar wcsTempPath(_MAX_PATH);
                CAutoWChar wcsBuffer(_MAX_PATH);

                if( wcsTempPath.Valid() && wcsBuffer.Valid() )
                {
                    //======================================================
                    //  Find last \ in the string, and trim off filename
                    //======================================================
                    if ( SUCCEEDED ( StringCchCopyW (wcsTempPath,_MAX_PATH,wcsFile) ) )
                    {
                        if( GetNextSectionFromTheEnd( wcsTempPath, wcsBuffer, _MAX_PATH ))
                        {
                            //==================================================
                            //  Now, get the potential locale id
                            //==================================================
                            if( GetNextSectionFromTheEnd( wcsTempPath, wcsBuffer, _MAX_PATH ))
                            {
                                wLocalId = (WORD) _wtoi(wcsBuffer);
                                //==============================================
                                //  Now, get the next bit to see if it says MUI 
                                //  or Fallback
                                //==============================================
                                if( GetNextSectionFromTheEnd( wcsTempPath, wcsBuffer, _MAX_PATH ))
                                {
                                    if( 0 == wbem_wcsicmp( L"MUI", wcsBuffer ))
                                    {
                                        fLoadDefaultLocale = FALSE;
                                    }
                                    else if( 0 == wbem_wcsicmp( L"Fallback", wcsBuffer ) )
                                    {
                                        //==============================================
                                        //  If it says Fallback, then check to make 
                                        //  sure the next bit says MUI
                                        //==============================================
                                        if( GetNextSectionFromTheEnd( wcsTempPath, wcsBuffer, _MAX_PATH ))
                                        {
                                            if( 0 == wbem_wcsicmp( L"MUI", wcsBuffer ) )
                                            {
                                                fLoadDefaultLocale = FALSE;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        SAFE_DELETE_ARRAY ( szWindowsDir );
    }
    return fLoadDefaultLocale;
}
///////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::GetPointerToBinaryResource(BYTE *& pRes,
                                            DWORD & dwSize,
                                            HGLOBAL & hResource,
                                            HINSTANCE & hInst,
                                            WCHAR * wcsResource,
                                            WCHAR * wcsFile,
                                            int cchSizeFile)

{
    TCHAR * pResource = NULL;
    BOOL fRc = FALSE;
    DWORD dwError = 0;

     wmilib::auto_buffer<TCHAR> pFile;

    if( ExtractFileNameFromKey(pFile,wcsFile,cchSizeFile) ){

        pResource = wcsResource;
        if( pResource )
        {
            hInst = LoadLibraryEx(pFile.get(),NULL,LOAD_LIBRARY_AS_DATAFILE);
            if( hInst != NULL )
            {
                HRSRC hSrc = NULL;
                WORD wLocaleId = 0;
                if( UseDefaultLocaleId(wcsResource, wLocaleId ))
                {
                       hSrc = FindResource(hInst,pResource, _T("MOFDATA"));
                }
                else
                {
                    hSrc = FindResourceEx(hInst,pResource, _T("MOFDATA"),wLocaleId);
                }
                if( hSrc == NULL )
                {

                    FreeLibrary(hInst);
                    dwError = GetLastError();
                }
                if( NULL != hSrc)
                {
                    hResource = LoadResource( hInst,hSrc);
                    if( hResource )
                    {
                        pRes = (BYTE *)LockResource(hResource);
                        dwSize = SizeofResource(hInst,hSrc);
                        fRc = TRUE;
                    }
                }
            }
        }
#ifndef UNICODE
        SAFE_DELETE_ARRAY(pResource );
#endif

    }
    return fRc;
}
/////////////////////////////////////////////////////////////////////
BYTE * CWMIBinMof::DecompressBinaryMof(BYTE * pRes)
{

    DWORD dwCompType, dwCompressedSize, dwExpandedSize, dwSig, dwResSize;
    BYTE * pExpanded = NULL;

    //=========================================================
    // get the signature, compression type, and the sizes
    //=========================================================
    memcpy(&dwSig,pRes,sizeof(DWORD));
    pRes += sizeof( DWORD );

    memcpy(&dwCompType,pRes,sizeof(DWORD));
    pRes += sizeof( DWORD );

    memcpy(&dwCompressedSize,pRes,sizeof(DWORD));
    pRes += sizeof( DWORD );

    memcpy(&dwExpandedSize,pRes,sizeof(DWORD));
    pRes += sizeof( DWORD );

    //=========================================================
    // make sure the signature is valid and that the compression type is one
    // we understand!
    //=========================================================
    if(dwSig != BMOF_SIG ||dwCompType != 1){
        return NULL;
    }

    //=========================================================
    // Allocate storage for the compressed data and
    // expanded data
    //=========================================================
    try
    {
        pExpanded = (BYTE*)malloc(dwExpandedSize);
        if( pExpanded == NULL)
        {
            goto ExitDecompression;
        }
    }
    catch(...)
    {
        throw;
    }

    //=========================================================
    // Decompress the data
    //=========================================================
    CBaseMrciCompression  * pMrci = new CBaseMrciCompression;
    if( pMrci )
    {
        dwResSize = pMrci->Mrci1Decompress(pRes, dwCompressedSize, pExpanded, dwExpandedSize);
        if(dwResSize != dwExpandedSize)
        {
            SAFE_DELETE_PTR(pMrci);
            goto ExitDecompression;
        }
        SAFE_DELETE_PTR(pMrci);
    }


    //=========================================================
    //  Now, get out of here
    //=========================================================
    return pExpanded;

ExitDecompression:
    if( pExpanded )
        free(pExpanded);

    return NULL;

}
/////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::ExtractFileNameFromKey(wmilib::auto_buffer<TCHAR> & pKey,WCHAR * wcsKey,int cchSize)
{
    WCHAR *wcsToken = NULL;
    CAutoWChar wcsTmp(MAX_PATH * 4);
    BOOL fRc = FALSE;

    if( wcsTmp.Valid() )
    {
        if(wcsKey)
        {
            //======================================================
            // Get a ptr to the first [ , if there isn't one, then
            // just copy the whole thing.
            //======================================================
            if ( SUCCEEDED ( StringCchCopyW (wcsTmp,MAX_PATH*4,wcsKey) ) )
            {
                wcsToken = wcstok(wcsTmp, L"[" );
                if( wcsToken != NULL )
                {
                    StringCchCopyW(wcsTmp,MAX_PATH*4,wcsToken);
                }

                int cchSizeNew = lstrlenW ( wcsTmp ) + 1;
                pKey.reset(new TCHAR[cchSizeNew]);
                if(pKey.get())
                {
                    if ( SUCCEEDED ( StringCchCopyW (pKey.get(),cchSizeNew,wcsTmp) ) )
                    {
                        fRc = TRUE;
                    }
                }
            }
        }
    }
    return fRc;
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::CreateKey(WCHAR * wcsFileName, WCHAR * wcsResource,WCHAR * wcsKey, int cchSizeKey)
{
    return StringCchPrintfW(wcsKey,cchSizeKey,L"%s[%s]",wcsFileName, wcsResource );
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::SendToMofComp(DWORD dwSize,BYTE * pRes,WCHAR * wcsKey)
{
    HRESULT hr = WBEM_NO_ERROR;

    if(m_pCompiler == NULL)
    {
        hr = CoCreateInstance(CLSID_WinmgmtMofCompiler, 0, CLSCTX_INPROC_SERVER,IID_IWinmgmtMofCompiler, (LPVOID *) &m_pCompiler);
    }
    if(hr == WBEM_NO_ERROR)
    {

        WBEM_COMPILE_STATUS_INFO Info;
        memset(&Info,0,sizeof(WBEM_COMPILE_STATUS_INFO));

        hr = m_pCompiler->WinmgmtCompileBuffer	(
													dwSize,
													pRes,
													WBEM_FLAG_CONNECT_PROVIDERS,
													WBEM_FLAG_OWNER_UPDATE,
													WBEM_FLAG_OWNER_UPDATE,
													SERVICES,
													CONTEXT,
													&Info
												);
        if( hr != WBEM_NO_ERROR )
        {
            ERRORTRACE((THISPROVIDER,"***************************************\n"));
            ERRORTRACE((THISPROVIDER,"Mofcomp of binary mof failed for:\n"));
            TranslateAndLog(wcsKey);
            ERRORTRACE((THISPROVIDER,"WinmgmtCompileBuffer return value: %ld\n",hr));
            ERRORTRACE((THISPROVIDER,"***************************************\n"));
            ERRORTRACE((THISPROVIDER,"WBEM_COMPILE_STATUS_INFO:\n"));
            ERRORTRACE((THISPROVIDER,"\tphase:\t%d\n",Info.lPhaseError));
            ERRORTRACE((THISPROVIDER,"\thresult:\t0x%x\n",Info.hRes));
            ERRORTRACE((THISPROVIDER,"***************************************\n"));
            ERRORTRACE((THISPROVIDER,"Size of Mof: %ld\n",dwSize));
            ERRORTRACE((THISPROVIDER,"***************************************\n"));
        }
        else
        {
            DEBUGTRACE((THISPROVIDER,"***************************************\n"));
            DEBUGTRACE((THISPROVIDER,"Binary mof succeeded for:\n"));
            TranslateAndLog(wcsKey, TRUE);
            DEBUGTRACE((THISPROVIDER,"***************************************\n"));
        }
    }
    
    return hr;
}
/////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::ExtractBinaryMofFromFile(WCHAR * wcsFile, WCHAR * wcsResource,WCHAR * wcsKey, int cchSizeKey, BOOL & fMofHasChanged)
{
    HRESULT hr;
    BOOL fSuccess = FALSE;
    CAutoWChar wcsTmp(MAX_PATH*4);

	try
	{
		if( wcsTmp.Valid() )
		{
			ULONG lLowDateTime=0,lHighDateTime=0;
			//=====================================
			//  As long as we have a list, process
			//  one at a time
			//=====================================
			lLowDateTime = 0l;
			lHighDateTime = 0L;
			fMofHasChanged = FALSE;
			//==============================================
			//  Compare the file date/timestamp the date/timestamp is different, change
			//  it.
			//==============================================
			if ( SUCCEEDED ( StringCchCopyW(wcsTmp,MAX_PATH*4,wcsFile) ) )
			{
				if( GetFileDateAndTime(lLowDateTime,lHighDateTime,wcsTmp,MAX_PATH*4) )
				{
					if ( SUCCEEDED ( CreateKey(wcsTmp,wcsResource,wcsKey,cchSizeKey) ) )
					{
						if( NeedToProcessThisMof(wcsKey,lLowDateTime,lHighDateTime) )
						{
							fMofHasChanged = TRUE;

							if( m_fUpdateNamespace )
							{
								DWORD dwSize = 0;
								BYTE * pRes = NULL;
								HGLOBAL  hResource = NULL;
								HINSTANCE hInst = NULL;

								if( GetPointerToBinaryResource(pRes,dwSize,hResource,hInst,wcsResource,wcsKey,cchSizeKey) )
								{
									hr = SendToMofComp(dwSize,pRes,wcsKey);
									if(hr == WBEM_S_NO_ERROR )
									{
										if( UpdateMofTimestampInHMOM(wcsKey,lLowDateTime,lHighDateTime, TRUE) )
										{
											CNamespaceManagement Namespace(this);
											Namespace.CreateClassAssociationsToDriver(wcsKey,pRes,lLowDateTime,lHighDateTime);
											Namespace.DeleteOldClasses(wcsKey,CVARIANT((long)lLowDateTime),CVARIANT((long)lHighDateTime), TRUE);
											fSuccess = TRUE;
										}
										else
										{
											UpdateMofTimestampInHMOM(wcsKey,lLowDateTime,lHighDateTime,FALSE);
										}
									}
									else
									{
										UpdateMofTimestampInHMOM(wcsKey,lLowDateTime,lHighDateTime,FALSE);
									}
									UnlockResource(hResource);
									FreeResource(hResource);
									FreeLibrary(hInst);
								}
								else
								{
									ERRORTRACE((THISPROVIDER,"***************************************\n"));
									ERRORTRACE((THISPROVIDER,"Could not get pointer to binary resource for file:\n"));
									TranslateAndLog(wcsKey);
									ERRORTRACE((THISPROVIDER,"***************************************\n"));
									UpdateMofTimestampInHMOM(wcsKey,lLowDateTime,lHighDateTime,FALSE);
								}
							}
						}
						else
						{
							fSuccess = TRUE;
						}
					}
				}
				else
				{
					UpdateMofTimestampInHMOM(wcsFile,lLowDateTime,lHighDateTime,FALSE);
					StringCchCopyW(wcsKey, cchSizeKey, wcsFile);
				}
			}
		}
	}
	catch ( CHeap_Exception & exc )
	{
		fSuccess = FALSE ;
	}

    return fSuccess;
}
//////////////////////////////////////////////////////////////////////////
#define WDMPROV_REG_KEY L"Software\\Microsoft\\WBEM\\WDMProvider"
BOOL CWMIBinMof::UserConfiguredRegistryToProcessStrandedClassesDuringEveryInit(void)
{
    DWORD dwProcess = 0;
    CRegistry RegInfo ;

    DWORD dwRet = RegInfo.Open (HKEY_LOCAL_MACHINE, WDMPROV_REG_KEY, KEY_READ) ;
    if ( dwRet == ERROR_SUCCESS )
    {
        RegInfo.GetCurrentKeyValue ( L"ProcessStrandedClasses",dwProcess );
    }
    RegInfo.Close();

    return (BOOL) dwProcess;
}
///////////     //////////////////////////////////////////////////////////
void CWMIBinMof::ProcessListOfWMIBinaryMofsFromWMI()
{
    HRESULT hr = WBEM_E_FAILED;

	try
	{
		if( m_nInit == FULLY_INITIALIZED )
		{
			CAutoWChar wcsFileName(MAX_PATH*3);
			CAutoWChar wcsResource(MAX_PATH*3);

			if( wcsFileName.Valid() && wcsResource.Valid() )
			{
				KeyList ArrDriversInRegistry;
				//============================================================
				//  Get list of what is currently in the registry
				//============================================================
				GetListOfDriversCurrentlyInRegistry(WDM_REG_KEY,ArrDriversInRegistry);

				//======================================================================
				//  Initialize things
				//======================================================================
				BOOL fMofChanged = FALSE;
				m_fUpdateNamespace = TRUE;

				//======================================================================
				//  Allocate working classes
				//======================================================================
				CWMIStandardShell * pWMI = new CWMIStandardShell;
				if( pWMI )
				{
					ON_BLOCK_EXIT ( deletePtr < CWMIStandardShell >, pWMI ) ;

					hr = pWMI->Initialize	(
												NULL,
												FALSE,
												m_pWMI->HandleMap(),
												m_fUpdateNamespace,
												WMIGUID_QUERY,
												m_pWMI->Services(),
												m_pWMI->Repository(),
												m_pWMI->Handler(),
												m_pWMI->Context()
											);
					if( S_OK == hr )
					{

						CNamespaceManagement * pNamespace = new CNamespaceManagement(this);
						if( pNamespace )
						{
							ON_BLOCK_EXIT ( deletePtr < CNamespaceManagement >, pNamespace ) ;

							//=========================================
							//  Query the binary guid
							//=========================================
							if ( SUCCEEDED ( hr = pNamespace->InitQuery(L"select * from WMIBinaryMofResource where Name != ") ) )
							{
								pWMI->QueryAndProcessAllBinaryGuidInstances(*pNamespace, fMofChanged, &ArrDriversInRegistry);

								//=========================================
								//  Get a list of binary mofs from WMI
								//=========================================
								GetListOfBinaryMofs();
								ULONG nTmp=0;
								CAutoWChar wcsTmpKey(MAX_PATH*3);
								BOOL fProcessStrandedClasses = FALSE;                 
								if( wcsTmpKey.Valid() )
								{
									if( m_uResourceCount > 0 )
									{
										//===============================================================
										//  Go through and get all the resources to process one by one
										//===============================================================
										while( GetBinaryMofFileNameAndResourceName(wcsFileName,MAX_PATH*3,wcsResource,MAX_PATH*3) && SUCCEEDED ( hr ) )
										{
										//============================================================
											//  Process the binary mof
											//============================================================
											if( ExtractBinaryMofFromFile(wcsFileName,wcsResource,wcsTmpKey,MAX_PATH*3,fMofChanged))
											{
												hr = pNamespace->UpdateQuery(L" and Name != ",wcsTmpKey);
											}
											if( fMofChanged )            
											{                                
												fProcessStrandedClasses = TRUE;    
											}                            

											ArrDriversInRegistry.Remove(wcsTmpKey);
										}
									}
								}

								if ( SUCCEEDED ( hr ) )
								{
									pNamespace->DeleteOldDrivers(FALSE);
									//===========================================================================
									//  If we are not supposed to process stranded classes, check the reg key
									//  to see if it wants us to anyway
									//===========================================================================
									if( !fProcessStrandedClasses )
									{
										fProcessStrandedClasses = UserConfiguredRegistryToProcessStrandedClassesDuringEveryInit();
									}
									if( fProcessStrandedClasses )            
									{                                            
										pNamespace->DeleteStrandedClasses();    
									}                                            
									DeleteOldDriversInRegistry(ArrDriversInRegistry);
								}
								else
								{
									DEBUGTRACE((THISPROVIDER,"***************************************\n"));
									DEBUGTRACE((THISPROVIDER,"Failure in processing binary mofs\n"));
									DEBUGTRACE((THISPROVIDER,"Resources %d\n", m_uResourceCount));
									DEBUGTRACE((THISPROVIDER,"Current %d\n", m_uCurrentResource));
									DEBUGTRACE((THISPROVIDER,"***************************************\n"));
								}
							}
						}
					}
				}
				if( m_pMofResourceInfo )
				{
					WmiFreeBuffer( m_pMofResourceInfo );
				}
			}
		}
	}
	catch ( CHeap_Exception & exc )
	{
	}

    DEBUGTRACE((THISPROVIDER,"End of processing Binary MOFS\n"));
    DEBUGTRACE((THISPROVIDER,"***************************************\n"));
}
/////////////////////////////////////////////////////////////////////
//=============================================================
//  THE BINARY MOF GROUP
//=============================================================
BOOL CWMIBinMof::GetListOfBinaryMofs()
{
    BOOL fRc = TRUE;
    ULONG uRc;
    m_uCurrentResource = 0;

    m_pMofResourceInfo = NULL;
    m_uResourceCount = 0;

    try
    {
        uRc = WmiMofEnumerateResourcesW( 0, &m_uResourceCount, &m_pMofResourceInfo );
        if( uRc != ERROR_SUCCESS )
        {
            fRc = FALSE;
        }
    }
    catch(...)
    {
        fRc = FALSE;
        // don't throw
    }

    return fRc;
}
//=============================================================
BOOL CWMIBinMof::GetBinaryMofFileNameAndResourceName(WCHAR * pwcsFileName, int cchSizeFile, WCHAR * pwcsResource, int cchSizeResource )
{
    BOOL fRc = FALSE;

    //===================================================================
    //  There are a lot of tests in here, due to strange results from
    //  WDM Service under stress.
    //===================================================================
    if( m_uCurrentResource < m_uResourceCount ){

        if( m_pMofResourceInfo ){

            DWORD dwFileLen = wcslen(m_pMofResourceInfo[m_uCurrentResource].ImagePath);
            DWORD dwResourceLen = wcslen(m_pMofResourceInfo[m_uCurrentResource].ResourceName);

               if( IsBadReadPtr( m_pMofResourceInfo[m_uCurrentResource].ImagePath,dwFileLen) == 0 )
            {
                if ( SUCCEEDED ( StringCchCopyW( pwcsFileName, cchSizeFile, m_pMofResourceInfo[m_uCurrentResource].ImagePath ) ) )
                {
                       if( IsBadReadPtr( m_pMofResourceInfo[m_uCurrentResource].ResourceName,dwResourceLen) == 0 )
                    {
                        if ( SUCCEEDED ( StringCchCopyW ( pwcsResource, cchSizeResource, m_pMofResourceInfo[m_uCurrentResource].ResourceName ) ) )
                        {
                            m_uCurrentResource++;
                            fRc = TRUE;
                        }
                    }
                }
            }
        }
    }
    return fRc;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::ExtractBinaryMofFromDataBlock(BYTE * pByte,ULONG uInstanceSize, WCHAR * wcsKey, BOOL & fMofHasChanged)
{

    HRESULT hr = WBEM_E_FAILED;
    //===================================================
    //  Get the CRC of the data buffer
    //===================================================
    DWORD dwCRC = STARTING_CRC32_VALUE;

    if( IsBadReadPtr( pByte,uInstanceSize) != 0 ){
        return WBEM_E_INVALID_OBJECT;
    }

    dwCRC = UpdateCRC32(pByte,uInstanceSize, dwCRC);
    FINALIZE_CRC32(dwCRC);
       //=========================================================
    // get the size of the buffer to send
    //=========================================================
    DWORD dwCompressedSize;
    BYTE * pTmp = pByte;
    pTmp += sizeof( DWORD ) * 2;

    memcpy(&dwCompressedSize,pTmp,sizeof(DWORD));
    dwCompressedSize += 16;
    fMofHasChanged = FALSE;
    //===================================================
    //  See if we should process this class or not
    //===================================================
    ULONG lLow = dwCRC;
    ULONG lHigh = 0;

	try
	{
		if( NeedToProcessThisMof(wcsKey,lLow,lHigh))
		{
			if( !m_fUpdateNamespace )
			{
				fMofHasChanged = TRUE;
				hr = WBEM_NO_ERROR;
			}
			else
			{
				hr = SendToMofComp(dwCompressedSize,pByte,wcsKey);
				if( hr == WBEM_NO_ERROR )
				{
					if( UpdateMofTimestampInHMOM(wcsKey,lLow,lHigh, TRUE))
					{
						CNamespaceManagement Namespace(this);
						Namespace.CreateClassAssociationsToDriver(wcsKey,pByte,lLow,lHigh);
						Namespace.DeleteOldClasses(wcsKey,CVARIANT((long)lLow),CVARIANT((long)lHigh),TRUE);
					}
					else
					{
						UpdateMofTimestampInHMOM(wcsKey,lLow,lHigh,FALSE);
					}
				}
				else
				{
					UpdateMofTimestampInHMOM(wcsKey,lLow,lHigh,FALSE);
				}
			}
		}
		else
		{
			hr = WBEM_NO_ERROR;
		}
	}
	catch ( CHeap_Exception & exc )
	{
		hr = WBEM_E_OUT_OF_MEMORY ;
	}

    return hr;
}
////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::DeleteMofsFromEvent(CVARIANT & vImagePath,CVARIANT & vResourceName, BOOL & fMofHasChanged)
{
    HRESULT hr = WBEM_E_OUT_OF_MEMORY;
    CAutoWChar wcsTmp(MAX_PATH*2);

    if( wcsTmp.Valid() )
    {
        hr = WBEM_E_INVALID_OBJECT;
        //=========================================
        //  Initialize stuff
        //=========================================
        fMofHasChanged = FALSE;

		try
		{
			//=================================================================
			// if we have an image path and resource path we are working with
			// file, otherwise it is a binary guidd
			//=================================================================
			if((vResourceName.GetType() != VT_NULL ) && ( vImagePath.GetType() != VT_NULL  )){

				hr = CreateKey( vImagePath.GetStr(), vResourceName.GetStr(),wcsTmp, MAX_PATH*2 );
			}
			else if( vResourceName.GetType() != VT_NULL ){

				hr = SetBinaryMofClassName(vResourceName.GetStr(),wcsTmp, MAX_PATH*2);
			}

			if ( SUCCEEDED ( hr ) )
			{
				if( m_fUpdateNamespace )
				{

					CNamespaceManagement Namespace(this);

					if ( SUCCEEDED ( hr = Namespace.InitQuery(L"select * from WMIBinaryMofResource where Name = ") ) )
					{
						if ( SUCCEEDED ( hr = Namespace.UpdateQuery(L"",wcsTmp) ) )
						{
							if( Namespace.DeleteOldDrivers(FALSE) )
							{
								hr = WBEM_NO_ERROR;
								fMofHasChanged = TRUE;
							}
						}
					}
				}
				else
				{
					if( ThisMofExistsInRegistry(WDM_REG_KEY,wcsTmp, 0, 0, FALSE))
					{ 
						fMofHasChanged = TRUE;
					}
					hr = WBEM_NO_ERROR;
				}
			}
		}
		catch ( CHeap_Exception & exc )
		{
			hr = WBEM_E_OUT_OF_MEMORY ;
		}
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************************************
//  Functions for the Dredger
//**********************************************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// format of string containing mof info is:
// "WmiBinaryMofResource.HighDateTime=9999,LowDateTime=9999,Name="Whatever"
//
//    HKLM\Software\Microsoft\WBEM\WDM\WDMBinaryMofResource
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CWMIBinMof::AddThisMofToRegistryIfNeeded(WCHAR * wcsKey, WCHAR * wcsFileName, ULONG & lLowDateTime, ULONG & lHighDateTime, BOOL fSuccess)
{
    HRESULT hr = WBEM_E_FAILED;
    CRegistry RegInfo ;

    DWORD dwRet = RegInfo.CreateOpen (HKEY_LOCAL_MACHINE, wcsKey) ;
    if ( dwRet == ERROR_SUCCESS )
    {
        CAutoWChar wcsBuf(MAX_PATH);
        if( wcsBuf.Valid() )
        {

            if( fSuccess )
            {
                StringCchPrintfW(wcsBuf,MAX_PATH,L"LowDateTime:%ld,HighDateTime:%ld***Binary mof compiled successfully", lLowDateTime, lHighDateTime);
            }
            else
            {
                StringCchPrintfW(wcsBuf,MAX_PATH,L"LowDateTime:%ld,HighDateTime:%ld***Binary mof failed, see WMIPROV.LOG", lLowDateTime, lHighDateTime);
            }
            CHString sTmp = wcsBuf;

            if ( RegInfo.SetCurrentKeyValue ( wcsFileName,sTmp ) == ERROR_SUCCESS )
            {
                hr = WBEM_S_NO_ERROR ;
            }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    RegInfo.Close();
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::ThisMofExistsInRegistry(WCHAR * wcsKey,WCHAR * wcsFileName, ULONG lLowDateTime, ULONG lHighDateTime, BOOL fCompareDates)
{
    BOOL fExists = FALSE;
    CRegistry RegInfo ;

    DWORD dwRet = RegInfo.Open (HKEY_LOCAL_MACHINE, wcsKey, KEY_READ) ;
    if ( dwRet == ERROR_SUCCESS )
    {
        CHString chsValue;
        
        if ( RegInfo.GetCurrentKeyValue ( wcsFileName,chsValue ) == ERROR_SUCCESS )
        {
            if( fCompareDates )
            {
                CAutoWChar wcsIncomingValue(MAX_PATH);
                CAutoWChar wcsTmp(MAX_PATH);

                if( wcsIncomingValue.Valid() && wcsTmp.Valid() )
                {
                    if ( SUCCEEDED ( StringCchPrintfW (wcsIncomingValue, MAX_PATH, L"LowDateTime:%ld,HighDateTime:%ld", lLowDateTime, lHighDateTime ) ) )
                    {
                        WCHAR *wcsToken = NULL;
        
                        //======================================================
                        // Get a ptr to the first *** , if there isn't one, then
                        // we have a messed up key
                        //======================================================
                        if ( SUCCEEDED ( StringCchCopyW ( wcsTmp, MAX_PATH, (const WCHAR*)chsValue ) ) )
                        {
                            wcsToken = wcstok(wcsTmp, L"*" );
                            if( wcsToken != NULL )
                            {
                                if( wbem_wcsicmp(wcsToken, wcsIncomingValue) == 0 )
                                {
                                    fExists = TRUE;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                fExists = TRUE;
            }
        }
    }
    RegInfo.Close();
    return fExists;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::DeleteMofFromRegistry(WCHAR * wcsFileName)
{
    HRESULT hr = WBEM_E_FAILED;

    HKEY hKey;
    hr = RegOpenKey(HKEY_LOCAL_MACHINE, WDM_REG_KEY, &hKey);
    if(NO_ERROR == hr)
    {
        hr = RegDeleteValue(hKey,wcsFileName);
        CloseHandle(hKey);
    }
    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::DeleteOldDriversInRegistry(KeyList & ArrDriversInRegistry)
{
    int nSize = ArrDriversInRegistry.GetSize();
    for( int i=0; i < nSize; i++ )
    {
        DeleteMofFromRegistry(ArrDriversInRegistry.GetAt(i));
    }
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::CopyWDMKeyToDredgeKey()
{
    BOOL fSuccess = FALSE;
    //=======================================================================
    //  Open up the WDM Dredge Key and enumerate the keys, copy them into
    //  the DredgeReg key
    //=======================================================================
    CRegistry   WDMReg;
    CRegistry   WDMDregReg;

	try
	{
		if (ERROR_SUCCESS == WDMReg.Open(HKEY_LOCAL_MACHINE, WDM_REG_KEY, KEY_READ))
		{
			ON_BLOCK_EXIT_OBJ ( WDMReg, CRegistry::Close ) ;

			//===============================================================
			//  Clean up old stuff
			//  Note:  You need to open up the parent key, so you can delete
			//  the child DREDGE key
			//===============================================================
			if( ERROR_SUCCESS == WDMDregReg.Open(HKEY_LOCAL_MACHINE, WDM_REG_KEY, KEY_READ))
			{
				ON_BLOCK_EXIT_OBJ ( WDMDregReg, CRegistry::Close ) ;

				CHString pchs(DREDGE_KEY);
				WDMDregReg.DeleteKey ( &pchs ) ;
			}
			if( ERROR_SUCCESS == WDMDregReg.CreateOpen(HKEY_LOCAL_MACHINE, WDM_DREDGE_KEY))
			{
				ON_BLOCK_EXIT_OBJ ( WDMDregReg, CRegistry::Close ) ;

				//===============================================================
				//  Go through the loop, and copy the keys
				//===============================================================
				BYTE *pValueData = NULL ;
				WCHAR *pValueName = NULL ;
				fSuccess = TRUE;

				for(DWORD i = 0 ; i < WDMReg.GetValueCount(); i++)
				{
					DWORD dwRc = WDMReg.EnumerateAndGetValues(i, pValueName, pValueData) ;
					if( dwRc == ERROR_SUCCESS )
					{
						ON_BLOCK_EXIT ( deleteArray < TCHAR >, pValueName ) ;
						ON_BLOCK_EXIT ( deleteArray < BYTE >, pValueData ) ;

						CHString chsKey(pValueName);
						CHString chsValue((LPCWSTR)pValueData);
						if ( !WDMDregReg.SetCurrentKeyValue ( chsKey, chsValue ) == ERROR_SUCCESS )
						{
							fSuccess = FALSE;
						}          
					}
					else
					{
						fSuccess = FALSE;
					}
					if( !fSuccess )
					{
						break;
					}
				}
			}
		}
	}
	catch ( CHeap_Exception & exc )
	{
		fSuccess = FALSE ;
	}

    return fSuccess;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::GetListOfDriversCurrentlyInRegistry(WCHAR * wcsKey, KeyList & ArrDriversInRegistry)
{
    BOOL fSuccess = TRUE;
    //==========================================================
    // Open the key for enumeration and go through the sub keys.
    //==========================================================
    HKEY hKey = NULL;
    HRESULT hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wcsKey, 0, KEY_READ | KEY_QUERY_VALUE,&hKey);
    if( ERROR_SUCCESS == hr )
    {    
        WCHAR wcsKeyName[MAX_PATH+2];
        DWORD dwLen = 0;
        int i = 0;
        while( ERROR_SUCCESS == hr )
        {
            dwLen = MAX_PATH+2;
            hr = RegEnumValue(hKey,i,wcsKeyName, &dwLen,0,NULL,NULL,NULL);
            // If we are successful reading the name
            //=======================================  
            if(ERROR_SUCCESS == hr ) 
            {
                ArrDriversInRegistry.Add(wcsKeyName);
                i++;
            }
            else 
            {
                break;
            }
        }
        RegCloseKey(hKey);
    }
    else
    {
        fSuccess = FALSE;
    }
    return fSuccess;
}
/////////////////////////////////////////////////////////////////////
HRESULT CWMIBinMof::ProcessBinaryMofEvent(PWNODE_HEADER WnodeHeader )
{
    HRESULT hr = WBEM_E_FAILED;

    m_fUpdateNamespace = TRUE;
    if( m_nInit == FULLY_INITIALIZED )
    {
        CWMIStandardShell * pWMI = new CWMIStandardShell;
        
        if( pWMI )
        {
            //=======================================================
            //  See if a binary mof event is being added or deleted
            //=======================================================

			if( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_ADDED_GUID,WnodeHeader->Guid))
			{
				hr = pWMI->Initialize	(
											RUNTIME_BINARY_MOFS_ADDED,
											TRUE,
											m_pWMI->HandleMap(),
											m_fUpdateNamespace,
											WMIGUID_QUERY,
											m_pWMI->Services(),
											m_pWMI->Repository(),
											m_pWMI->Handler(),
											m_pWMI->Context()
										);
				if( S_OK == hr )
				{
					hr = pWMI->ProcessEvent(MOF_ADDED,WnodeHeader);
				}
			}
			else if( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_REMOVED_GUID,WnodeHeader->Guid))
			{
				hr = pWMI->Initialize	(
											RUNTIME_BINARY_MOFS_DELETED,
											TRUE,
											m_pWMI->HandleMap(),
											m_fUpdateNamespace,
											WMIGUID_QUERY,
											m_pWMI->Services(),
											m_pWMI->Repository(),
											m_pWMI->Handler(),
											m_pWMI->Context()
										);
				if( S_OK == hr )
				{
					hr = pWMI->ProcessEvent(MOF_DELETED,WnodeHeader);
				}
			}	

            SAFE_DELETE_PTR(pWMI);
        }
    }

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************************************
//  STUFF FOR DREDGE
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************************************
/////////////////////////////////////////////////////////////////////
//  DREDGE APIS - access ONLY the DREDGE KEY
/////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::BinaryMofEventChanged(PWNODE_HEADER WnodeHeader )
{
    BOOL fMofHasChanged = TRUE;

    if( m_nInit != NOT_INITIALIZED )
    {
        HRESULT hr = WBEM_E_NOT_FOUND;

        m_fUpdateNamespace = FALSE;
        CWMIStandardShell * pWMI = new CWMIStandardShell;

        if( pWMI )
        {
            //=======================================================
            //  See if a binary mof event is being added or deleted
            //=======================================================

			if( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_ADDED_GUID,WnodeHeader->Guid))
			{
				hr = pWMI->Initialize(RUNTIME_BINARY_MOFS_ADDED,
				                      TRUE, 
				                      NULL,
				                      m_fUpdateNamespace, 
				                      WMIGUID_QUERY,
									  NULL,
									  NULL,
									  NULL,
									  NULL);
				if( S_OK == hr )
				{
					hr = pWMI->ProcessEvent(MOF_ADDED,WnodeHeader);
				}
			}
			else if( IsBinaryMofResourceEvent(WMI_RESOURCE_MOF_REMOVED_GUID,WnodeHeader->Guid))
			{
				// DO NOTHING
				hr = pWMI->Initialize(RUNTIME_BINARY_MOFS_DELETED,TRUE, 
				                      NULL,
				                      m_fUpdateNamespace, 
				                      WMIGUID_QUERY,
									  NULL,
									  NULL,
									  NULL,
									  NULL);
				if( S_OK == hr )
				{
				// only provider will handle deletion of driver
				// hr = pWMI->ProcessEvent(MOF_DELETED,WnodeHeader);
				}
			}

            DEBUGTRACE((THISPROVIDER,"***************************************\n"));
            if( pWMI->HasMofChanged() )
            {
                DEBUGTRACE((THISPROVIDER,"BinaryMofEventChanged returned TRUE:\n"));
            }
            else
            {
                DEBUGTRACE((THISPROVIDER,"BinaryMofEventChanged returned FALSE:\n"));
            }
            fMofHasChanged = pWMI->HasMofChanged();
            SAFE_DELETE_PTR(pWMI);
        }

    }
    return fMofHasChanged;
}
/////////////////////////////////////////////////////////////////////
//  DREDGE APIS - access ONLY the DREDGE KEY
/////////////////////////////////////////////////////////////////////
BOOL CWMIBinMof::BinaryMofsHaveChanged()
{
    BOOL fBinaryMofHasChanged = FALSE;
    if( m_nInit != NOT_INITIALIZED )
    {
        KeyList ArrDriversInRegistry;
        HRESULT hr = WBEM_E_FAILED;
        m_fUpdateNamespace = FALSE;
        //============================================================
        //  Get list of what is currently in the registry
        //============================================================
        BOOL fRc = GetListOfDriversCurrentlyInRegistry(WDM_DREDGE_KEY,ArrDriversInRegistry);
        if( fRc )
        {
            //=====================================================================
            //  Get a list of binary mofs from WMI
            // Query WMIBinaryMofResource for list of static mofs
            //=====================================================================
            GetListOfBinaryMofs();
            if( m_uResourceCount > 0 )
            {
                //===============================================================
                //  Go through and get all the resources to process one by one
                //===============================================================
                CAutoWChar FileName(MAX_PATH*2);
                CAutoWChar Resource(MAX_PATH*2);
                CAutoWChar TmpKey(MAX_PATH*2);

                if( FileName.Valid() && Resource.Valid() && TmpKey.Valid() )
                {
                    while( GetBinaryMofFileNameAndResourceName(FileName,MAX_PATH*2,Resource,MAX_PATH*2))
                    {

                        //============================================================
                        //  Process the binary mof, keep going until one needs to
                        //  be processed
                        //============================================================
                        ExtractBinaryMofFromFile(FileName,Resource,TmpKey, MAX_PATH*2,fBinaryMofHasChanged );
                        if( fBinaryMofHasChanged )
                        {
                            break;
                        }
                        ArrDriversInRegistry.Remove(TmpKey);
                    }
                }
            }

            if( !fBinaryMofHasChanged )
            {
                //=========================================
                //  Query the binary guid
                //=========================================
                CNamespaceManagement * pNamespace = new CNamespaceManagement(this);
                if( pNamespace )
                {
                    if ( SUCCEEDED ( hr = pNamespace->InitQuery(L"select * from WMIBinaryMofResource where Name != ") ) )
                    {
                        CWMIStandardShell * pWMI = new CWMIStandardShell;


						if( pWMI )
						{
							hr = pWMI->Initialize(NULL, FALSE, NULL,m_fUpdateNamespace, WMIGUID_QUERY,NULL,NULL,NULL,NULL);
							if( S_OK == hr )
							{
								pWMI->QueryAndProcessAllBinaryGuidInstances(*pNamespace, fBinaryMofHasChanged,&ArrDriversInRegistry);
							}
							SAFE_DELETE_PTR(pWMI);
						}
					}
					SAFE_DELETE_PTR(pNamespace);
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}
/*			//============================================================
			//  If there are any drivers left in the list, then we need
			//  to say that the binary mofs have changed
			//============================================================
			if( !fBinaryMofHasChanged )
			{
				if( ArrDriversInRegistry.OldDriversLeftOver() )
				{
					fBinaryMofHasChanged = TRUE;
				}
			}
*/
        }
        else
        {
            //==============================================================================================
            // there is no key, so now we need to return that the registry has changed, so the copy of the 
            // keys will be kicked off
            //==============================================================================================
            fBinaryMofHasChanged = TRUE;
        }
        if( m_pMofResourceInfo )
        {
            WmiFreeBuffer( m_pMofResourceInfo );
        }

        DEBUGTRACE((THISPROVIDER,"***************************************\n"));
        if( fBinaryMofHasChanged )
        {
            DEBUGTRACE((THISPROVIDER,"BinaryMofsHaveChanged returned TRUE:\n"));
        }
        else
        {
            DEBUGTRACE((THISPROVIDER,"BinaryMofsHaveChanged returned FALSE:\n"));
        }
    }
    return fBinaryMofHasChanged;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************************************
//  Namespace Management Class
//**********************************************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CNamespaceManagement::CNamespaceManagement(CWMIBinMof * pOwner)
{
    m_pObj = pOwner;
    m_nSize = 0;
    m_pwcsQuery = NULL;
    m_fInit = 0;
    m_pwcsSavedQuery = NULL;
    m_fSavedInit = 0;
    m_nSavedSize = 0;

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CNamespaceManagement::~CNamespaceManagement()
{
    SAFE_DELETE_ARRAY( m_pwcsQuery );
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define SERVICES_PTR	m_pObj->WMI()->Services()
#define REPOSITORY_PTR	m_pObj->WMI()->Repository()
#define CONTEXT_PTR		m_pObj->WMI()->Context()

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// IsClassPseudoSystem
// ===================================
//
// returns false if class doesn't belong to set of
// pseudo system classes which should be not deleted
//
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CNamespaceManagement::IsClassPseudoSystem ( LPCWSTR wcsClass )
{
	BOOL fResult = FALSE ;

	if ( wcsClass )
	{
		static LPWSTR wcsPseudoSystem [] =	{
												L"WMIEvent",
												L"Win32_Perf",
												L"Win32_PerfRawData",
												L"Win32_PerfFormattedData"
											};

		static DWORD dwPseudoSystem = sizeof ( wcsPseudoSystem ) / sizeof ( wcsPseudoSystem [ 0 ] ) ;

		for ( DWORD dwIndex = 0; dwIndex < dwPseudoSystem; dwIndex++ )
		{
			if ( 0 == wbem_wcsicmp ( wcsClass, wcsPseudoSystem [ dwIndex ] ) )
			{
				fResult = TRUE ;
				break ;
			}
		}
	}

	return fResult ;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// IsClassAsociatedWithDifferentDriver
// ===================================
//
// returns false if there is no other driver referencing class
// we assume that there is driver when internally failing
//
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CNamespaceManagement::IsClassAsociatedWithDifferentDriver ( LPCWSTR wcsClass, LPCWSTR wcsDriverToCompare )
{
	BOOL fResult = TRUE ;
	BOOL fFind = FALSE ;

	HRESULT hr = S_OK ;

	CBSTR strQueryLang(L"WQL");

	LPCWSTR wcsQuery = L"\"" ;

	LPCWSTR query1 = L"select * from WDMClassesOfDriver where ClassName = \"" ;
	DWORD dwQuery1 = sizeof ( L"select * from WDMClassesOfDriver where ClassName = \"" ) / sizeof ( WCHAR ) ;
	DWORD dw1 = wcslen ( wcsClass ) + dwQuery1 + 1 ;

	LPWSTR wcsQuery1 = new WCHAR [ dw1 ] ;
	wmilib::auto_buffer < WCHAR > smartwcsQuery1 ( wcsQuery1 ) ;

	if ( SUCCEEDED ( hr = StringCchCopyW ( wcsQuery1, dw1, query1 ) ) )
	{
		if ( SUCCEEDED ( hr = StringCchCatW ( wcsQuery1, dw1, wcsClass ) ) )
		{
			hr = StringCchCatW ( wcsQuery1, dw1, wcsQuery ) ;
		}
	}

	if ( SUCCEEDED ( hr ) )
	{
		_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
		IEnumWbemClassObjectPtr pEnum;

		hr = REPOSITORY_PTR->ExecQuery ( strQueryLang, CBSTR ( wcsQuery1 ), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, CONTEXT_PTR, &pEnum );
		if ( SUCCEEDED ( hr ) )
		{
			DWORD uReturned = 0L ;

			_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
			IWbemClassObjectPtr pClass;

			LPCWSTR query2 = L"select * from WMIBinaryMofResource where Name = \"" ;
			DWORD dwQuery2 = sizeof ( L"select * from WMIBinaryMofResource where Name = \"" ) / sizeof ( WCHAR ) ;

			while ( WBEM_S_NO_ERROR == hr ) 
			{
				hr = pEnum->Next ( WBEM_INFINITE, 1, &pClass, &uReturned ) ;
				if ( WBEM_S_NO_ERROR == hr )
				{
					CVARIANT vDriver ;
					hr = pClass->Get ( L"Driver", 0, &vDriver, 0, 0 );
					if ( SUCCEEDED ( hr ) )
					{
						if ( wcsDriverToCompare )
						{
							if ( 0 == ( wbem_wcsicmp ( wcsDriverToCompare, vDriver.GetStr() ) ) )
							{
								//
								// we know that this driver has a class
								//

								continue ;
							}
						}

						DWORD dwDriver = 2 * ( wcslen ( vDriver.GetStr() ) + 1 ) ;
						CAutoWChar wcsDriver( dwDriver );

						if ( SUCCEEDED ( hr = ConvertStringToCTypeString ( wcsDriver, dwDriver, vDriver.GetStr() ) ) )
						{
							DWORD dw2 =  wcslen ( wcsDriver ) + dwQuery2 + 1;

							LPWSTR wcsQuery2 = new WCHAR [ dw2 ] ;
							wmilib::auto_buffer < WCHAR > smartwcsQuery2 ( wcsQuery2 ) ;

							if ( SUCCEEDED ( hr = StringCchCopyW ( wcsQuery2, dw2, query2 ) ) )
							{
								if ( SUCCEEDED ( hr = StringCchCatW ( wcsQuery2, dw2, wcsDriver ) ) )
								{
									hr = StringCchCatW ( wcsQuery2, dw2, wcsQuery ) ;
								}
							}

							if ( SUCCEEDED ( hr ) )
							{
								IEnumWbemClassObjectPtr pEnum1;
								hr = REPOSITORY_PTR->ExecQuery ( strQueryLang, CBSTR ( wcsQuery2 ), WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, CONTEXT_PTR, &pEnum1 );
								if ( SUCCEEDED ( hr ) )
								{
									DWORD uReturned1 = 0L ;
									IWbemClassObjectPtr pClass1;

									hr = pEnum1->Next ( WBEM_INFINITE, 1, &pClass1, &uReturned1 ) ;
									if ( WBEM_S_NO_ERROR == hr )
									{
										//
										// we are associated with some live driver for this class
										//

										fFind = TRUE ;
										break ;
									}
									else
									{
										if ( WBEM_S_FALSE == hr )
										{
											//
											// we get empty enumerator back (continue with other drivers)
											//

											hr = WBEM_S_NO_ERROR ;
										}
										else
										{
											if ( FAILED ( hr ) )
											{
												// get object failure
												ERRORTRACE ( ( THISPROVIDER, "QUERY:\n" ) ) ;
												TranslateAndLog ( wcsQuery2 ) ;
												ERRORTRACE ( ( THISPROVIDER, "Failure to get class object out of enumerator with error 0x%08lx\n", hr)); 
											}
										}
									}
								}
								else
								{
									// exec query failure
									ERRORTRACE ( ( THISPROVIDER, "Failed to execute following QUERY:\n" ) ) ;
									TranslateAndLog ( wcsQuery2 ) ;
									ERRORTRACE ( ( THISPROVIDER, "Error 0x%08lx\n", hr)); 
								}
							}
							else
							{
								// out of memory
								ERRORTRACE ( ( THISPROVIDER, "String creation failed: ", hr ) ) ;
								TranslateAndLog ( wcsQuery2 ) ;
								ERRORTRACE ( ( THISPROVIDER, "Error 0x%08lx\n", hr ) ) ;
							}
						}
						else
						{
							// convert failure
							ERRORTRACE ( ( THISPROVIDER, "Convertion failure ... probably OUT OF MEMORY !\n" ) ) ;
						}
					}
					else
					{
						// get property failed
						ERRORTRACE ( ( THISPROVIDER, "QUERY:\n" ) ) ;
						TranslateAndLog ( wcsQuery1 ) ;
						ERRORTRACE ( ( THISPROVIDER, "Failure to get property value from class object with error 0x%08lx\n", hr)); 
					}
				}
				else
				{
					if ( WBEM_S_FALSE == hr )
					{
						//
						// we did get empty enumerator back
						//

						if ( FALSE == fFind )
						{
							//
							// we didn't find live driver here
							//

							fResult = FALSE ;
						}
					}
					else
					{
						// get object failure
						ERRORTRACE ( ( THISPROVIDER, "QUERY:\n" ) ) ;
						TranslateAndLog ( wcsQuery1 ) ;
						ERRORTRACE ( ( THISPROVIDER, "Failure to get class object out of enumerator with error 0x%08lx\n", hr)); 
					}
				}
			}
		}
		else
		{
			// exec query failure
			ERRORTRACE ( ( THISPROVIDER, "Failed to execute following QUERY:\n" ) ) ;
			TranslateAndLog ( wcsQuery1 ) ;
			ERRORTRACE ( ( THISPROVIDER, "Error 0x%08lx\n", hr)); 
		}
	}
	else
	{
		// out of memory
		ERRORTRACE ( ( THISPROVIDER, "String creation failed: ", hr ) ) ;
		TranslateAndLog ( wcsQuery1 ) ;
		ERRORTRACE ( ( THISPROVIDER, "Error 0x%08lx\n", hr ) ) ;
	}

	return fResult ;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Delete stranded classes in the repository
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CNamespaceManagement::DeleteStrandedClasses(void)
{
    BOOL fRc = TRUE;
    HRESULT hr    = WBEM_NO_ERROR;
    IEnumWbemClassObject* pEnum = NULL;
    IEnumWbemClassObject* pEnumofStrandedClasses = NULL;
    // ==================================================================================
    //  Get list of drivers
    // ==================================================================================
    if ( SUCCEEDED ( hr = InitQuery(L"select * from WMIBinaryMofResource") ) )
    {
        CBSTR strQryLang(L"WQL");
        CBSTR cbstrQry(m_pwcsQuery);

		hr = REPOSITORY_PTR->ExecQuery(strQryLang,cbstrQry, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,CONTEXT_PTR,&pEnum);
		if( hr == WBEM_NO_ERROR )
		{
			unsigned long uReturned = 0;
			CVARIANT vDriver, vLow, vHigh;
			IWbemClassObject * pClass = NULL;
	    
			//================================================================================
			//  Initialize query for stranded classes as we go along and clean up the old 
			// classes
			//================================================================================
			if ( SUCCEEDED ( hr = InitQuery(L"select * from WDMClassesOfDriver where Driver != ") ) )
			{
				while ( TRUE )
				{
    				IWbemClassObject * pClass = NULL;

                    if( WBEM_NO_ERROR == (hr = pEnum->Next(2000, 1, &pClass, &uReturned)))
                    {
                        if( WBEM_NO_ERROR == (hr = pClass->Get(L"Name", 0, &vDriver, 0, 0)))
                        {
                            //============================================================
                            //  Correct the query syntax for next query
                            //============================================================
                            hr = UpdateQuery( L" and Driver != ",vDriver.GetStr());
                        }
                    }

                    SAFE_RELEASE_PTR(pClass );
                    if( hr != WBEM_NO_ERROR )
                    {
                        break;
                    }
                }
                //================================================================
                //  Ok, now go after the stranded classes, the ones that don't
                //  have any drivers for some reason
                //================================================================
                CBSTR strQryLang(L"WQL");
                CBSTR cbstr(m_pwcsQuery);


				hr = REPOSITORY_PTR->ExecQuery(strQryLang,cbstr, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,CONTEXT_PTR,&pEnumofStrandedClasses);
				if( hr == WBEM_NO_ERROR )
				{
					BOOL bDrivers = FALSE;
					while( TRUE )
					{
						if( WBEM_NO_ERROR == (hr = pEnumofStrandedClasses->Next(2000, 1, &pClass, &uReturned)))
						{
							CVARIANT vPath,vClass;
							pClass->Get(L"ClassName", 0, &vClass, 0, 0);
							if(SUCCEEDED(hr = pClass->Get(L"__RELPATH", 0, &vPath, 0, 0)))
							{
								//
								// we need to recognize if class is not associated with 
								// different driver prior to its deletion 
								//
								// (upgrade scenario where diff driver was exposing same classes)
								//

								BOOL fDeleteClass = ! IsClassAsociatedWithDifferentDriver ( vClass.GetStr() );

								//
								// we do not care if there was error in deletion
								// as it usually means there was no such a class
								// previously
								//

								hr = DeleteUnusedClassAndDriverInfo( fDeleteClass, vClass.GetStr(), vPath.GetStr() );
							}
							else
							{
								fRc = FALSE;
								break;
							}
						}
						SAFE_RELEASE_PTR(pClass);
						if( hr != WBEM_NO_ERROR )
						{
							break;
						}
					}
					
					SAFE_RELEASE_PTR(pEnumofStrandedClasses);
					if(!fRc)
					{
						if( hr != E_OUTOFMEMORY)
						{
							ERRORTRACE((THISPROVIDER,"Stranded instance exist in repository\n"));
						}
					}
				}
			}
		}
		SAFE_RELEASE_PTR(pEnum);
	}
	return fRc;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CNamespaceManagement::DeleteOldDrivers(BOOL fCompareDates)
{
    HRESULT hr = WBEM_E_FAILED;
    IEnumWbemClassObject* pEnum = NULL;
    BOOL fRc = TRUE;
    BSTR strQry = NULL;

    strQry = SysAllocString(m_pwcsQuery);
    if(strQry != NULL)
    {
        CBSTR strQryLang(L"WQL");

		hr = REPOSITORY_PTR->ExecQuery(strQryLang, strQry, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,CONTEXT_PTR,&pEnum);
		SysFreeString(strQry);
		strQry = NULL;
	}
	else
	{
		hr = E_OUTOFMEMORY;
		fRc = FALSE;
	}

    if( hr == WBEM_NO_ERROR )
    {
        IWbemClassObject * pClass = NULL;
        unsigned long uReturned = 0;
        CVARIANT vClass;
        hr = WBEM_NO_ERROR;

        //============================================================================================
        //  NOTE:  We only deal with drivers extracted from files here, if it is a guid as the result
        //  of an event this is handled elsewhere
        //============================================================================================
        while ( hr == WBEM_NO_ERROR )
        {
            IWbemClassObject * pClass = NULL;
            unsigned long uReturned = 0;

            hr = pEnum->Next(2000, 1, &pClass, &uReturned);
            if( hr == WBEM_NO_ERROR )
            {
                CVARIANT vLowDate, vHighDate, vName;

                if( WBEM_NO_ERROR != (hr = pClass->Get(L"Name", 0, &vName, 0, 0)))
                {
                    break;
                }

                if( fCompareDates )
                {
                    vLowDate.SetLONG(0);
                    vHighDate.SetLONG(0);
            
                    if( WBEM_NO_ERROR != (hr = pClass->Get(L"LowDateTime", 0, &vLowDate, 0, 0)))
                    {
                        break;
                    }

                    if( WBEM_NO_ERROR != (hr = pClass->Get(L"HighDateTime", 0, &vHighDate, 0, 0)))
                    {
                        break;
                    }
                }

                DEBUGTRACE((THISPROVIDER,"Deleting Old Drivers\n"));
                DEBUGTRACE((THISPROVIDER,"***************************************\n"));

                if( DeleteOldClasses((WCHAR *) vName.GetStr(),vLowDate,vHighDate,fCompareDates ))
                {
                    CVARIANT vPath;
    
                    hr = pClass->Get(L"__RELPATH", 0, &vPath, 0, 0);
                    if( hr == WBEM_NO_ERROR )
                    {
                        CBSTR cbstrPath(vPath.GetStr());
                        hr = REPOSITORY_PTR->DeleteInstance(cbstrPath,0,CONTEXT_PTR,NULL);

                        if ( FAILED ( hr ) )
                        {
                            ERRORTRACE((THISPROVIDER,"We have been requested to delete this instance:\n"));
                            TranslateAndLog(vPath.GetStr());
                            ERRORTRACE((THISPROVIDER,"It failed with 0x%08lx\n", hr));
                        }
                        else
                        {
                            DEBUGTRACE((THISPROVIDER,"We have been requested to delete this instance:\n"));
                            TranslateAndLog(vPath.GetStr(), TRUE);
                        }

                        if( WBEM_NO_ERROR == hr )
                        {
                            m_pObj->DeleteMofFromRegistry((WCHAR *) vName.GetStr());
                        }
                    }
                    else
                    {
                        ERRORTRACE((THISPROVIDER,"Get returned value: 0x%08lx\n",hr));
                    }
                }
            }
        }
        SAFE_RELEASE_PTR(pEnum);
    }
    else
    {
        ERRORTRACE((THISPROVIDER,"Cannot delete driver. ExecQuery return value: 0x%08lx\n",hr));
        ERRORTRACE((THISPROVIDER,"Current query: \n"));
        TranslateAndLog(m_pwcsQuery);
    }

    return fRc;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
// Function to delete Old classes for a particular driver
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CNamespaceManagement::DeleteOldClasses(WCHAR * wcsFileName,CVARIANT & vLow, CVARIANT & vHigh, BOOL fCompareDates)
{
    HRESULT hr = WBEM_E_FAILED;
    CAutoWChar wcsTranslatedKey(MAX_PATH*2);
    BOOL fRc = FALSE;
    IEnumWbemClassObject* pEnum = NULL;
    ULONG lHighDateTime = 0L;
    ULONG lLowDateTime = 0L;

    DEBUGTRACE((THISPROVIDER,"Deleting Old Classes for Driver\n"));
    TranslateAndLog(wcsFileName, TRUE);
    DEBUGTRACE((THISPROVIDER,"***************************************\n"));
        
    if( wcsTranslatedKey.Valid() )
    {
        //================================================================================
        //  Initialize everything we need to construct the query
        //================================================================================
        if( fCompareDates )
        {
            lLowDateTime= (ULONG)vLow.GetLONG();
            lHighDateTime= (ULONG)vHigh.GetLONG();
        }

        if ( SUCCEEDED ( hr = ConvertStringToCTypeString( wcsTranslatedKey,MAX_PATH*2,wcsFileName ) ) )
        {
            //================================================================================
            //  Now, pick up all the old classes for this driver
            //================================================================================
            if ( SUCCEEDED ( hr = InitQuery(L"select * from WDMClassesOfDriver where Driver = ") ) )
            {
                if ( SUCCEEDED ( hr = UpdateQuery(L"",wcsFileName) ) )
                {
                    if ( SUCCEEDED ( hr = UpdateQuery(L" and (HighDateTime != ",lHighDateTime) ) )
                    {
                        if ( SUCCEEDED ( hr = UpdateQuery(L" or LowDateTime != ", lLowDateTime) ) )
                        {
                            if ( SUCCEEDED ( hr = AddToQuery(L")") ) )
                            {
                                BSTR strTmp = NULL;
                                strTmp = SysAllocString(m_pwcsQuery);
                                if(strTmp != NULL)
                                {
                                    CBSTR strQryLang(L"WQL");

                                    hr = REPOSITORY_PTR->ExecQuery(strQryLang, strTmp, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,CONTEXT_PTR,&pEnum);
                                    SysFreeString(strTmp);
                                    strTmp = NULL;
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                    fRc = FALSE;
                                }

                                if( hr == WBEM_NO_ERROR )
                                {
                                    IWbemClassObject * pClass = NULL;
                                    unsigned long uReturned = 0;
                                    CVARIANT vClass;

                                    while ( TRUE )
                                    {
                                        hr = pEnum->Next(2000, 1, &pClass, &uReturned);
                                        if( hr!= WBEM_NO_ERROR )
                                        {
                                            break;
                                        }

                                        hr = pClass->Get(L"ClassName", 0, &vClass, 0, 0);
                                        if( hr != WBEM_NO_ERROR )
                                        {
											SAFE_RELEASE_PTR( pClass );
                                            break;
                                        }
                                        //===========================================================================
                                        //  Now, get this instance of tying the class with this  old date
                                        //===========================================================================
                                        CVARIANT vPath;
                                        hr = pClass->Get(L"__RELPATH", 0, &vPath, 0, 0);
                                        if( hr != WBEM_NO_ERROR )
                                        {
											SAFE_RELEASE_PTR( pClass );
                                            break;
                                        }
                                        //==========================================================================
                                        //  Now, just because we get a class name here doesn't mean we delete the
                                        //  class, this class could have been updated, in that case we just delete
                                        //  the instance of the WDMClassesOfDriver.
                                        //  Now, we need to check to see if this class really needs to be deleted
                                        //  or not
                                        //==========================================================================

										BOOL bProceedDeletion = FALSE ;
										BOOL fDeleteOldClass = TRUE ;
										if ( FALSE == fCompareDates )
										{
											//
											// we need to recognize if class is not associated with 
											// different driver prior to its deletion 
											//
											// (upgrade scenario where diff driver was exposing same classes)
											//

											fDeleteOldClass = ! IsClassAsociatedWithDifferentDriver ( vClass.GetStr(), wcsFileName );
											bProceedDeletion = TRUE ;
										}
										else
										{
											IWbemClassObject * pTmp = NULL;
											CBSTR bTmp = vClass.GetStr();
											if( bTmp )
											{
												CAutoWChar wcsObjectPath(MAX_PATH*4);
												if( wcsObjectPath.Valid() )
												{
													if ( SUCCEEDED ( hr = StringCchPrintfW(wcsObjectPath,MAX_PATH*4,L"WDMClassesOfDriver.ClassName=\"%s\",Driver=\"%s\",HighDateTime=%lu,LowDateTime=%lu",bTmp,wcsTranslatedKey,lHighDateTime,lLowDateTime) ) )
													{
														//===========================================================================
														//  this is simple, if we get an instance of WDMClassesOfDriver
														//  with the newer date, then we know it has been updated, so we don't
														//  delete the class
														//===========================================================================
														if ( WBEM_NO_ERROR == REPOSITORY_PTR->GetObject ( CBSTR ( wcsObjectPath ), 0, CONTEXT_PTR, &pTmp, NULL ) )
														{
															fDeleteOldClass = FALSE;
														}

														//===========================================================================
														// Now, delete the WDM Instance of the Old Driver
														//===========================================================================
														SAFE_RELEASE_PTR( pTmp );

														bProceedDeletion = TRUE ;
													}
												}
											}
										}

										if ( bProceedDeletion )
										{
											//
											// we do not care if there was error in deletion
											// as it usually means there was no such a class
											// previously
											//

											hr = DeleteUnusedClassAndDriverInfo( fDeleteOldClass, vClass.GetStr(), vPath.GetStr() );
										}

                                        SAFE_RELEASE_PTR( pClass );
                                        vClass.Clear();
                                    }

									SAFE_RELEASE_PTR(pEnum);
                                }
                            
                                if( hr == WBEM_NO_ERROR || hr == WBEM_S_NO_MORE_DATA || hr == WBEM_S_FALSE)
                                {
                                    fRc = TRUE;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return fRc;
}


/////////////////////////////////////////////////////////////////////
BOOL CNamespaceManagement::CreateInstance ( WCHAR * wcsDriver, WCHAR * wcsClass, ULONG lLowDateTime, ULONG lHighDateTime )
{
    IWbemClassObject * pInst = NULL, * pClass = NULL;

    //==================================================
    //  Get a pointer to a IWbemClassObject object
    //==================================================
    HRESULT hr;
    CVARIANT cvarName;
    cvarName.SetStr(L"WDMClassesOfDriver");

	hr = REPOSITORY_PTR->GetObject(cvarName, 0,CONTEXT_PTR, &pClass, NULL);        
    if(FAILED(hr)){
        return FALSE;
    }

       //=============================================================
    //  Spawn a new instance
    //=============================================================
    hr = pClass->SpawnInstance(0, &pInst);
    
    SAFE_RELEASE_PTR(pClass);
    if( FAILED(hr) ){
        return hr;
    }

       //=============================================================
    //  Put the data in the instance
    //=============================================================
    CVARIANT vClass, vDriver, vLow, vHigh;

    vClass.SetStr(wcsClass);
    vDriver.SetStr(wcsDriver);
    vLow.SetLONG(lLowDateTime);
    vHigh.SetLONG(lHighDateTime);

    hr = pInst->Put(L"Driver", 0, &vDriver, NULL);
    if( hr == WBEM_S_NO_ERROR )
    {
        hr = pInst->Put(L"ClassName", 0, &vClass, NULL);

        hr = pInst->Put(L"LowDateTime", 0, &vLow, NULL);

        hr = pInst->Put(L"HighDateTime", 0, &vHigh, NULL);
        if( hr == WBEM_S_NO_ERROR )
        {
            hr = REPOSITORY_PTR->PutInstance(pInst,WBEM_FLAG_CREATE_OR_UPDATE,CONTEXT_PTR,NULL);
        }
    }

    SAFE_RELEASE_PTR(pInst);
    if( WBEM_NO_ERROR == hr ){
        return TRUE;
    }
    return FALSE;

}
/////////////////////////////////////////////////////////////////////
void CNamespaceManagement::CreateClassAssociationsToDriver(WCHAR * wcsFileName, BYTE* pRes, ULONG lLowDateTime, ULONG lHighDateTime)
{

    CBMOFObjList * pol;
    CBMOFObj * po;

    //===========================================================================
    // Now use the helper functions from David's mofcomp stuff to extract the
    // class names we are going to add the Driver qualifier to.
    // list structure and use it to enumerate the objects.
    //===========================================================================
    BYTE * pByte = m_pObj->DecompressBinaryMof(pRes);
    if( pByte ){
        pol = CreateObjList(pByte);
        if(pol != NULL){
            ResetObjList (pol);
            while(po = NextObj(pol)){
                WCHAR * pName = NULL;
                if(GetName(po, &pName)){
                    //===============================================================        
                    //  Now, we have the name of the class in pName, we have the
                    //  name of the driver, in wcsFileName
                    //===============================================================        
                    CreateInstance(wcsFileName, pName, lLowDateTime, lHighDateTime );
                    BMOFFree(pName);
                }
                BMOFFree(po);
            }    
            BMOFFree(pol);
        }
    }
    else{
        ERRORTRACE((THISPROVIDER,"Could not tie classes to driver for file:\n"));
        TranslateAndLog(wcsFileName);
    }
    if( pByte ){
        free(pByte);
    }

}
/////////////////////////////////////////////////////////////////////
HRESULT CNamespaceManagement::AllocMemory(WCHAR *& p)
{
    HRESULT hr = WBEM_E_FAILED;

    p = ( WCHAR* ) new BYTE[m_nSize+4];
    if( p )
    {
        memset(p,NULL,m_nSize+4);
        hr = WBEM_NO_ERROR;
    }
    else
    {
        WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}
/////////////////////////////////////////////////////////////////////
HRESULT CNamespaceManagement::AddToQuery(WCHAR * p)
{
    HRESULT hr = WBEM_E_FAILED;

    int nNewSize = wcslen(p) * sizeof(WCHAR);
    int nCurrentBuf = 0;
    if( m_pwcsQuery )
    {
        nCurrentBuf = (int)(wcslen(m_pwcsQuery) + 1) * sizeof(WCHAR);
    }

    if( nNewSize >= (m_nSize - nCurrentBuf))
    {
        int nOldSize = m_nSize;
        WCHAR * pOld = m_pwcsQuery;
        m_nSize += MEMSIZETOALLOCATE;
        m_pwcsQuery = NULL;

        if( SUCCEEDED( hr = AllocMemory(m_pwcsQuery)))
        {
            memcpy(m_pwcsQuery,pOld,nOldSize);
        }
        SAFE_DELETE_ARRAY(pOld);
    }
    else
    {
        // no need to re-allocate
        hr = WBEM_S_FALSE;
    }

    if ( SUCCEEDED ( hr ) )
    {
        if( m_pwcsQuery )
        {
            if( wcslen(m_pwcsQuery) == 0 )
            {
                hr = StringCbCopyW(m_pwcsQuery,m_nSize,p);
            }
            else
            {
                hr = StringCbCatW(m_pwcsQuery,m_nSize,p);
            }
        }
        else
        {
            // this is so bad
            hr = WBEM_E_FAILED;
        }
    }

    return hr;
}
/////////////////////////////////////////////////////////////////////
HRESULT CNamespaceManagement::InitQuery(WCHAR * p)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    SAFE_DELETE_ARRAY(m_pwcsQuery);
    m_nSize = MEMSIZETOALLOCATE;
    m_fInit = TRUE;
    if(SUCCEEDED(hr = AllocMemory(m_pwcsQuery)))
    {
        hr = AddToQuery(p);
    }

    return hr;
}
/////////////////////////////////////////////////////////////////////
HRESULT CNamespaceManagement::UpdateQuery( WCHAR * pQueryAddOn, WCHAR * wcsParam )
{
    HRESULT hr = WBEM_E_OUT_OF_MEMORY;

    CAutoWChar wcsTranslatedKey(MAX_PATH*3);
    if( wcsTranslatedKey.Valid() )
    {
        if ( SUCCEEDED ( hr = ConvertStringToCTypeString( wcsTranslatedKey,MAX_PATH*3,wcsParam ) ) )
        {
            //=============================================
            // The first time only we DON'T add the query
            // add on string, otherwise, we do
            //=============================================
            if( !m_fInit )
            {
                hr = AddToQuery(pQueryAddOn);
            }

            if ( SUCCEEDED ( hr ) )
            {
                if ( SUCCEEDED ( hr = AddToQuery(L"\"") ) )
                {
                    if ( SUCCEEDED ( hr = AddToQuery(wcsTranslatedKey) ) )
                    {
                        if ( SUCCEEDED ( hr = AddToQuery(L"\"") ) )
                        {
                            m_fInit = FALSE;
                        }
                    }
                }
            }
        }
    }

    return hr;
}
/////////////////////////////////////////////////////////////////////
void CNamespaceManagement::SaveCurrentQuery()
{
    m_nSavedSize = m_nSize;
    m_fSavedInit = m_fInit;
    if( SUCCEEDED(AllocMemory(m_pwcsSavedQuery))){
        memcpy(m_pwcsSavedQuery,m_pwcsQuery,m_nSize);
    }
    SAFE_DELETE_ARRAY(m_pwcsQuery);
}
/////////////////////////////////////////////////////////////////////
void CNamespaceManagement::RestoreQuery()
{
    SAFE_DELETE_ARRAY(m_pwcsQuery);
    m_nSize = m_nSavedSize;
    m_fInit = m_fSavedInit;

    if( SUCCEEDED(AllocMemory(m_pwcsQuery))){
        memcpy(m_pwcsQuery, m_pwcsSavedQuery,m_nSize);
    }

    m_fSavedInit = 0;
    m_nSavedSize = 0;
    SAFE_DELETE_ARRAY(m_pwcsSavedQuery);
}
/////////////////////////////////////////////////////////////////////
HRESULT CNamespaceManagement::UpdateQuery( WCHAR * pQueryAddOn, ULONG lLong )
{
    HRESULT hr = WBEM_E_OUT_OF_MEMORY;

    CAutoWChar wcsBuf(MAX_PATH);
    if( wcsBuf.Valid() )
    {
        if ( SUCCEEDED ( hr = AddToQuery(pQueryAddOn) ) )
        {
             if ( SUCCEEDED ( hr = StringCchPrintfW(wcsBuf,MAX_PATH,L"%lu",lLong) ) )
            {
                if ( SUCCEEDED ( hr = AddToQuery(wcsBuf) ) )
                {
                    m_fInit = FALSE;
                }
            }
        }
    }

    return hr;
}
/////////////////////////////////////////////////////////////////////
HRESULT CNamespaceManagement::DeleteUnusedClassAndDriverInfo( BOOL fDeleteOldClass, WCHAR * wcsClass, WCHAR * wcsPath )
{
    HRESULT    hr = WBEM_NO_ERROR;

    if( fDeleteOldClass )
    {
		if ( FALSE == IsClassPseudoSystem ( wcsClass ) )
		{
			hr = SERVICES_PTR->DeleteClass(CBSTR(wcsClass),WBEM_FLAG_OWNER_UPDATE,CONTEXT_PTR,NULL);
			if( hr != WBEM_NO_ERROR )
			{
				if( WBEM_E_NOT_FOUND != hr )
				{
					ERRORTRACE((THISPROVIDER,"Tried to delete class but couldn't, return code: 0x%08lx for class: \n",hr));
					TranslateAndLog(wcsClass);
				}
				else
				{
					hr = WBEM_NO_ERROR;
				}
			}
		}
		else
		{
			DEBUGTRACE ( ( THISPROVIDER,"Tried to delete class but skipped: \n" ) );
			DEBUGTRACE ( ( THISPROVIDER,"%S is PSEUDO system class \n", wcsClass ) ); ;
		}
    }


    if( WBEM_NO_ERROR == hr )
    {
        // Ok, we may or may have not deleted the class, if it was tied to a different driver, we
        // shouldn't have deleted the class, but we want to delete the controlling instance, as
        // that driver is no longer there.
        hr = SERVICES_PTR->DeleteInstance(CBSTR(wcsPath),WBEM_FLAG_OWNER_UPDATE,CONTEXT_PTR,NULL);
        if( WBEM_NO_ERROR != hr )
        {
            if( hr != WBEM_E_NOT_FOUND )
            {
				ERRORTRACE((THISPROVIDER,"Tried to delete instance but couldn't, return code: 0x%08lx for instance: \n ",hr));
                TranslateAndLog(wcsPath);
            }
		}
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\wmimof.h ===
//***************************************************************************
//
// Copyright (c) 1997-2002 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************
#ifndef _WMIMOF_HEADER
#define _WMIMOF_HEADER

#include <autoptr.h>

#define NOT_INITIALIZED 0
#define PARTIALLY_INITIALIZED 1
#define FULLY_INITIALIZED 2

////////////////////////////////////////////////////////////////////
class CWMIBinMof 
{
    public:

        CWMIBinMof();
        ~CWMIBinMof();

        HRESULT Initialize( CWMIManagement* p, BOOL fUpdateNamespace); 
        HRESULT Initialize	(
								CHandleMap * pList,
								BOOL fUpdateNamespace,
								ULONG uDesiredAccess,
								IWbemServices   __RPC_FAR * pServices,
								IWbemServices   __RPC_FAR * pRepository,
								IWbemObjectSink __RPC_FAR * pHandler,
								IWbemContext __RPC_FAR *pCtx
							);

        //=====================================================================
        //  Public functions
        //=====================================================================
	void ProcessListOfWMIBinaryMofsFromWMI();
	BOOL UserConfiguredRegistryToProcessStrandedClassesDuringEveryInit(void);

	BOOL UpdateMofTimestampInHMOM(WCHAR * wcsFile,ULONG & lLowDateTime, ULONG & lHighDateTime, BOOL fSuccess );
	BOOL NeedToProcessThisMof(WCHAR * wcsFileName,ULONG & lLowDateTime, ULONG & lHighDateTime);
	BOOL ThisMofExistsInRegistry(WCHAR * wcsKey,WCHAR * wcsFileName, ULONG lLowDateTime, ULONG lHighDateTime, BOOL fCompareDates);
	BOOL GetListOfDriversCurrentlyInRegistry(WCHAR * wcsKey,KeyList & ArrDriversInRegistry);
	BOOL DeleteOldDriversInRegistry(KeyList & ArrDriversInRegistry);
	BOOL CopyWDMKeyToDredgeKey();
	HRESULT AddThisMofToRegistryIfNeeded(WCHAR * wcsKey, WCHAR * wcsFileName, ULONG & lLowDateTime, ULONG & lHighDateTime, BOOL fSuccess);
	HRESULT DeleteMofFromRegistry(WCHAR * wcsFileName);
	HRESULT ProcessBinaryMofEvent(PWNODE_HEADER WnodeHeader );
	BOOL BinaryMofsHaveChanged();
	BOOL BinaryMofEventChanged(PWNODE_HEADER WnodeHeader );


        inline CWMIManagement * WMI()   { return m_pWMI; }
		HRESULT InitializePtrs	(
									CHandleMap * pList,
									IWbemServices __RPC_FAR * pServices,	
									IWbemServices __RPC_FAR * pRepository,	
									IWbemObjectSink __RPC_FAR * pHandler,
									IWbemContext __RPC_FAR *pCtx
								);


    private:
	//======================================================
	//  For use with binary mof related items
	//======================================================
	BOOL					m_fUpdateNamespace;
	ULONG                   m_uCurrentResource;
	ULONG                   m_uResourceCount;
	int						m_nInit;
	MOFRESOURCEINFO       * m_pMofResourceInfo;
	CWMIManagement        * m_pWMI;
	IWinmgmtMofCompiler   * m_pCompiler;

	HRESULT OpenFileAndLookForItIfItDoesNotExist(wmilib::auto_buffer<TCHAR> & pFile, HANDLE & hFile );
        BOOL GetFileDateAndTime(ULONG & lLowDateTime, ULONG & lHighDateTime, WCHAR * p, int cchSize );
        BOOL GetPointerToBinaryResource(BYTE *& pRes,DWORD & dw, HGLOBAL & hResource, HINSTANCE & hInst,WCHAR * wcsResource, WCHAR * wcsKey, int cchSizeKey);

        //==========================================================
        //  Common function
        //==========================================================
        HRESULT SendToMofComp(DWORD dwSize,BYTE * pRes,WCHAR * wcs);

        //==========================================================
        //  Locale functions
        //==========================================================
        BOOL UseDefaultLocaleId(WCHAR * wcsFile, WORD & wLocalId);
        BOOL GetNextSectionFromTheEnd(WCHAR * pwcsTempPath, WCHAR * pwcsEnd, int cchSize);

        //==========================================================
        //  THE BINARY MOF GROUP
        //==========================================================
        BOOL GetListOfBinaryMofs();
        BOOL GetBinaryMofFileNameAndResourceName(WCHAR * pwcsFileName, int cchSizeFile, WCHAR * pwcsResource, int cchSizeResource);
		
        HRESULT CreateKey(WCHAR * wcsFileName, WCHAR * wcsResource,WCHAR * wcsKey, int cchSizeKey);
        BOOL ExtractFileNameFromKey(wmilib::auto_buffer<TCHAR> & pKey,WCHAR * wcsKey,int cchSize);
    public:
        HRESULT SetBinaryMofClassName( WCHAR * wcsIn, WCHAR * wcsOut, int cchSize )
		{
			return StringCchPrintfW ( wcsOut, cchSize, L"%s-%s",wcsIn,WMI_BINARY_MOF_GUID );
		}	
        //==========================================================
        //  THE BINARY MOF GROUP VIA Data blocks
        //==========================================================
        HRESULT ExtractBinaryMofFromDataBlock(BYTE * pByte, ULONG m,WCHAR *, BOOL & fMofHasChanged);
        
        //==========================================================
        //  Processing Binary Mofs via file
        //==========================================================
        BOOL ExtractBinaryMofFromFile(WCHAR * wcsFile, WCHAR * wcsResource,WCHAR * wcsKey, int cchSizeKey, BOOL & fMofChanged);
        BYTE * DecompressBinaryMof(BYTE * pRes);
        HRESULT DeleteMofsFromEvent(CVARIANT & vImagePath,CVARIANT & vResourceName, BOOL & fMofChanged);
};


class CNamespaceManagement
{

public:
    CNamespaceManagement(CWMIBinMof * pOwner);
    ~CNamespaceManagement();

	BOOL DeleteOldClasses(WCHAR * wcsFileName,CVARIANT & vLow, CVARIANT & vHi,BOOL fCompareDates);
    BOOL DeleteStrandedClasses();
    BOOL DeleteOldDrivers(BOOL);
	HRESULT DeleteUnusedClassAndDriverInfo(BOOL fDeleteOldClass, WCHAR * wcsClass, WCHAR * wcsPath);

    BOOL CreateInstance ( WCHAR * wcsDriver, WCHAR * wcsClass, ULONG lLowDateTime, ULONG lHighDateTime );
	void CreateClassAssociationsToDriver(WCHAR * wcsFileName, BYTE* pRes, ULONG lLowDateTime, ULONG lHighDateTime);


    HRESULT UpdateQuery( WCHAR * pQueryAddOn, WCHAR * Param );
    HRESULT UpdateQuery( WCHAR * pQueryAddOn, ULONG lLong );

    HRESULT InitQuery(WCHAR * p);
    HRESULT AddToQuery(WCHAR * p);

private:

	BOOL IsClassAsociatedWithDifferentDriver ( LPCWSTR wcsClass, LPCWSTR wcsDriver = NULL ) ;
	BOOL IsClassPseudoSystem ( LPCWSTR wcsClass ) ;

    void RestoreQuery();
    void SaveCurrentQuery();
    HRESULT AllocMemory(WCHAR * & p);
    WCHAR * m_pwcsQuery, *m_pwcsSavedQuery;

    CWMIBinMof * m_pObj;
    int m_nSize,m_nSavedSize;
    BOOL m_fInit,m_fSavedInit;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\wmi\wmiguid.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    wmiguid.h

Abstract:

    Defines GUIDs that represent data blocks that can be retrieved via WMI

Author:

    Alan Warwick (alanwar) 27-Jun-1997

Revision History:

--*/

#ifndef FAR
#define FAR
#endif

#ifndef DEFINE_GUID
#ifndef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID FAR name
#else // !defined(INITGUID)

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#endif // !defined(INITGUID)
#endif // !defined(DEFINE_GUID)

//
// This is WMI guid used to return disk performance information from 
// diskperf.sys (see DISK_PERFORMANCE data structure)

DEFINE_GUID (DiskPerfGuid, 0xBDD865D1,0xD7C1,0x11d0,0xA5,0x01,0x00,0xA0,0xC9,0x06,0x29,0x10);

DEFINE_GUID ( /* 3d6fa8d0-fe05-11d0-9dda-00c04fd7ba7c */
    ProcessGuid,
    0x3d6fa8d0,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d1-fe05-11d0-9dda-00c04fd7ba7c */
    ThreadGuid,
    0x3d6fa8d1,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d2-fe05-11d0-9dda-00c04fd7ba7c */ /* Not used */
    HardFaultGuid,
    0x3d6fa8d2,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d3-fe05-11d0-9dda-00c04fd7ba7c */
    PageFaultGuid,
    0x3d6fa8d3,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d4-fe05-11d0-9dda-00c04fd7ba7c */
    DiskIoGuid,
    0x3d6fa8d4,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 68fdd900-4a3e-11d1-84f4-0000f80464e3 */
    TraceHeaderGuid,
    0x68fdd900,
    0x4a3e,
    0x11d1,
    0x84, 0xf4, 0x00, 0x00, 0xf8, 0x04, 0x64, 0xe3
  );
DEFINE_GUID ( /* 90cbdc39-4a3e-11d1-84f4-0000f80464e3 */
    FileIoGuid,
    0x90cbdc39,
    0x4a3e,
    0x11d1,
    0x84, 0xf4, 0x00, 0x00, 0xf8, 0x04, 0x64, 0xe3
  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\wmi\wmistr.h ===
/*++                 

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Wmistr.h

Abstract:
    
    WMI structure definitions

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#ifndef _WMISTR_
#define _WMISTR_

//
// WNODE definition
typedef struct _WNODE_HEADER
{
    ULONG BufferSize;        // Size of entire buffer inclusive of this ULONG
    ULONG ProviderId;        // Provider Id of driver returning this buffer
    ULONG Version;           // Version number of data block
    union
    {
        ULONG Linkage;           // Linkage field reserved for WMI
        ULONG HistoricalContext; // Logger use
    };
    LARGE_INTEGER TimeStamp; // Timestamp as returned in units of 100ns
                             // since 1/1/1601
    GUID Guid;               // Guid for data block returned with results
    ULONG Reserved;          
    ULONG Flags;             // Flags, see below
} WNODE_HEADER, *PWNODE_HEADER;

//
// WNODE_HEADER flags are defined as follows
#define WNODE_FLAG_ALL_DATA        0x00000001 // set for WNODE_ALL_DATA
#define WNODE_FLAG_SINGLE_INSTANCE 0x00000002 // set for WNODE_SINGLE_INSTANCE
#define WNODE_FLAG_SINGLE_ITEM     0x00000004 // set for WNODE_SINGLE_ITEM
#define WNODE_FLAG_EVENT_ITEM      0x00000008 // set for WNODE_EVENT_ITEM

                                              // Set if data block size is 
                                              // identical for all instances 
                                              // (used with  WNODE_ALL_DATA 
                                              // only)
#define WNODE_FLAG_FIXED_INSTANCE_SIZE 0x00000010

#define WNODE_FLAG_TOO_SMALL           0x00000020 // set for WNODE_TOO_SMALL

                                 // Set when a data provider returns a 
                                 // WNODE_ALL_DATA in which the number of 
                                 // instances and their names returned
                                 // are identical to those returned from the 
                                 // previous WNODE_ALL_DATA query. Only data 
                                 // blocks registered with dynamic instance
                                 // names should use this flag.
#define WNODE_FLAG_INSTANCES_SAME  0x00000040

                                 // Instance names are not specified in 
                                 // WNODE_ALL_DATA; values specified at 
                                 // registration are used instead. Always 
                                 // set for guids registered with static 
                                 // instance names
#define WNODE_FLAG_STATIC_INSTANCE_NAMES 0x00000080

#define WNODE_FLAG_INTERNAL      0x00000100  // Used internally by WMI

                                 // timestamp should not be modified by
                                 // a historical logger
#define WNODE_FLAG_USE_TIMESTAMP 0x00000200

#define WNODE_FLAG_TRACED_GUID   0x00000400
                                 
#define WNODE_FLAG_TRACE_KERNEL  0x00000800 // Used to trace kernel

#define WNODE_FLAG_TRACE_EXTENDED 0x00001000 // Trace in extended mode

// Set for events that are WNODE_EVENT_REFERENCE
#define WNODE_FLAG_EVENT_REFERENCE 0x00002000

// Set if Instance names are ansi. Only set when returning from 
// WMIQuerySingleInstanceA and WMIQueryAllDataA
#define WNODE_FLAG_ANSI_INSTANCENAMES 0x00004000

// Set if WNODE is a method call
#define WNODE_FLAG_METHOD_ITEM     0x00008000

// Set if instance names originated from a PDO
#define WNODE_FLAG_PDO_INSTANCE_NAMES  0x00010000

// Mask for event severity level. Level 0xff is the most severe type of event
#define WNODE_FLAG_SEVERITY_MASK 0xff000000

//
// This structure is used within the WNODE_ALL_DATA when the data blocks 
// for the different instances are different lengths. If the data blocks
// for the different instances are identical lengths then 
// WNODE_FLAG_FIXED_INSTANCE_SIZE should be set and FixedInstanceSize
// set to the common data block size.
typedef struct 
{
    ULONG OffsetInstanceData;   // Offset from beginning of WNODE_ALL_DATA
                                // to Data block for instance
    ULONG LengthInstanceData;   // Length of data block for instance
} OFFSETINSTANCEDATAANDLENGTH, *POFFSETINSTANCEDATAANDLENGTH;

typedef struct tagWNODE_ALL_DATA
{
    struct _WNODE_HEADER WnodeHeader;

    ULONG DataBlockOffset;// Offset from begin of WNODE to first data block 
                      
    ULONG InstanceCount;  // Count of instances whose data follows. 

                      // Offset to an array of offsets to the instance names
    ULONG OffsetInstanceNameOffsets;

    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is set in Flags then 
    // FixedInstanceSize specifies the size of each data block. In this case
    // there is one ULONG followed by the data blocks.
    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is not set 
    // then OffsetInstanceDataAndLength
    // is an array of OFFSETINSTANCEDATAANDLENGTH that specifies the 
    // offsets and lengths of the data blocks for each instance. 
    union
    {
        ULONG FixedInstanceSize;
    	OFFSETINSTANCEDATAANDLENGTH OffsetInstanceDataAndLength[];
                                    /* [InstanceCount] */
    };
    
    // padding so that first data block begins on a 8 byte boundry

    // data blocks and instance names for all instances

} WNODE_ALL_DATA, *PWNODE_ALL_DATA;


typedef struct tagWNODE_SINGLE_INSTANCE
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_SINGLE_INSTANCE
                            // to instance name. Use when 
                            // WNODE_FLAG_STATIC_INSTANCE_NAMES is reset
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when 
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is set
    ULONG InstanceIndex;    // (Static Instance Names)

    ULONG DataBlockOffset;  // offset from beginning of WNODE to data block
    ULONG SizeDataBlock;    // Size of data block for instance

    UCHAR VariableData[];
    // instance names and padding so data block begins on 8 byte boundry

    // data block
} WNODE_SINGLE_INSTANCE, *PWNODE_SINGLE_INSTANCE;


typedef struct tagWNODE_SINGLE_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_SINGLE_INSTANCE
                            // to instance name. Examine when 
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is reset 
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when 
                            // WNODE_FLAG_STATIC_INSTANCE_NAME
    ULONG InstanceIndex;    //  set (Static Instance Names)

    ULONG ItemId;           // Item Id for data item being set

    ULONG DataBlockOffset;  // offset from WNODE begin to data item value
    ULONG SizeDataItem;     // Size of data item
    
    UCHAR VariableData[];
    // instance names and padding so data value begins on 8 byte boundry

    // data item value
} WNODE_SINGLE_ITEM, *PWNODE_SINGLE_ITEM;

typedef struct tagWNODE_METHOD_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_METHOD_ITEM
                            // to instance name. Examine when 
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is reset 
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when 
                            // WNODE_FLAG_STATIC_INSTANCE_NAME
    ULONG InstanceIndex;    //  set (Static Instance Names)

    ULONG MethodId;         // Method id of method being called

    ULONG DataBlockOffset;  // On Entry: offset from WNODE to input data 
                            // On Return: offset from WNODE to input and 
                            //            output data blocks
    ULONG SizeDataBlock;    // On Entry: Size of input data, 0 if no input 
                            //           data
                            // On Return: Size of output data, 0 if no output
                            //            data
    
    UCHAR VariableData[];
    // instance names and padding so data value begins on 8 byte boundry

    // data item value
} WNODE_METHOD_ITEM, *PWNODE_METHOD_ITEM;

typedef struct tagWNODE_EVENT_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

    // Different data could be here depending upon the flags set in the 
    // WNODE_HEADER above. If the WNODE_FLAG_ALL_DATA flag is set then the 
    // contents of a WNODE_ALL_DATA  (excluding WNODE_HEADER) is here. If the
    // WNODE_FLAG_SINGLE_INSTANCE flag is set then a WNODE_SINGLE_INSTANCE
    // (excluding WNODE_HEADER) is here. Lastly if the  WNODE_FLAG_SINGLE_ITEM
    // flag is set then a WNODE_SINGLE_ITEM (excluding WNODE_HEADER) is here.
} WNODE_EVENT_ITEM, *PWNODE_EVENT_ITEM;


//
// If a KM data provider needs to fire an event that is larger than the
// maximum size that WMI allows then it should fire a WNODE_EVENT_REFERENCE
// that specifies which guid and instance name to query for the actual data
// that should be part of the event.
typedef struct tagWNODE_EVENT_REFERENCE
{
    struct _WNODE_HEADER WnodeHeader;
    GUID TargetGuid;
    ULONG TargetDataBlockSize;
    union
    {
        ULONG TargetInstanceIndex;
        WCHAR TargetInstanceName[];
    };
} WNODE_EVENT_REFERENCE, *PWNODE_EVENT_REFERENCE;


typedef struct tagWNODE_TOO_SMALL
{
    struct _WNODE_HEADER WnodeHeader;
    ULONG SizeNeeded;                   // Size needed to build WNODE result
} WNODE_TOO_SMALL, *PWNODE_TOO_SMALL;


//
// Registration data structure definitions
typedef struct
{
    ULONG ProviderId; // Provider id (or device object pointer) of the data 
                      // provider whose instance names are to be copied.
    GUID Guid;        // Guid of data block provided by ProviderId whose 
                      // instance names are copied.
} WMIREGINSTANCEREF, *PWMIREGINSTANCEREF;

typedef struct
{
    GUID Guid;             // Guid of data block being registered or updated
    ULONG Flags;         // Flags

    ULONG InstanceCount; // Count of static instances names for the guid

    ULONG InstanceInfo;// Offset from beginning of the WMIREGINFO structure to
                     // more information about the static instance names being
                     // registered.
			     
                     // If WMIREG_FLAG_INSTANCE_LIST then this points to a
                     // list of InstanceCount counted UNICODE
                     // strings placed end to end.
			     
                     // If WMIREG_FLAG_INSTANCE_BASENAME then this points to a
                     // single counted UNICODE string that
                     // has the basename for the instance names.
                     // If WMIREG_FLAG_INSTANCE_REFERENCE then this points to 
                     // a WMIREGINSTANCEREF structure.
			     
                     // If WMIREG_FLAG_INSTANCE_PDO is set then InstanceInfo
                     // has the PDO whose device instance path will 
                     // become the instance name

} WMIREGGUIDW, *PWMIREGGUIDW;

typedef WMIREGGUIDW WMIREGGUID;
typedef PWMIREGGUIDW PWMIREGGUID;

// Set if collection must be enabled for the guid before the data provider
// can be queried for data.
#define WMIREG_FLAG_EXPENSIVE          0x00000001 

// Set if instance names for this guid are specified in a static list within
// the WMIREGINFO
#define WMIREG_FLAG_INSTANCE_LIST      0x00000004

// Set if instance names are to be static and generated by WMI using a 
// base name in the WMIREGINFO and an index
#define WMIREG_FLAG_INSTANCE_BASENAME  0x00000008

// Set if static instance names are taken by reference to another data 
// provider. This flag should only be used by kernel mode data providers.
#define WMIREG_FLAG_INSTANCE_REFERENCE 0x00000010
                                                  
							  
// Set if WMI should do automatic mapping of a PDO to device instance name
// as the instance name for the guid. This flag should only be used by
// kernel mode data providers.
#define WMIREG_FLAG_INSTANCE_PDO       0x00000020 
                                                    
// Note the flags WMIREG_FLAG_INSTANCE_LIST, WMIREG_FLAG_INSTANCE_BASENAME,
// WMIREG_FLAG_INSTANCE_REFERENCE and WMIREG_FLAG_INSTANCE_PDO are mutually
// exclusive.

//
// These flags are only valid in a response to WMI_GUID_REGUPDATE
#define WMIREG_FLAG_REMOVE_GUID       0x00010000 // Remove support for  guid
#define WMIREG_FLAG_ADD_GUID          0x00020000 // Add support for guid
#define WMIREG_FLAG_MODIFY_GUID       0x00040000 // Modify support for guid

// Set if guid is one that is written to trace log. WMI will send 
// ENABLE/DISABLE Collection to indicate whento start/stop trace logging. 
// This guid cannot be queried directly via WMI, but must be read using 
// logger apis.
#define WMIREG_FLAG_TRACED_GUID        0x00080000 

//
// Set if the guid is only used for firing events. Guids that can be queried
// and that fire events should not have this bit set.
#define WMIREG_FLAG_EVENT_ONLY_GUID    0x00000040

typedef struct
{
// Size of entire WMIREGINFO structure including this ULONG 	
// and any static instance names that follow
    ULONG BufferSize;

    ULONG NextWmiRegInfo;         // Offset to next WMIREGINFO structure

    ULONG RegistryPath; // Offset from beginning of WMIREGINFO structure to a 
                        // counted Unicode string containing
                        // the driver registry path (under HKLM\CCS\Services)
                        // This must be filled only by kernel mode data 
						// providers
							
// Offset from beginning of WMIREGINFO structure to a
// counted Unicode string containing
// the name of resource in driver file containing MOF info
    ULONG MofResourceName;

// Count of WMIREGGUID structures immediately following
    ULONG GuidCount;
    WMIREGGUIDW WmiRegGuid[];  // array of GuidCount WMIREGGUID structures
    // Variable length data including :
    //     Instance Names
} WMIREGINFOW, *PWMIREGINFOW;

typedef WMIREGINFOW WMIREGINFO;
typedef PWMIREGINFOW PWMIREGINFO;

//
// WMI request codes
typedef enum
{
#ifndef _WMIKM_
    WMI_GET_ALL_DATA = 0,
    WMI_GET_SINGLE_INSTANCE = 1,
    WMI_SET_SINGLE_INSTANCE = 2,
    WMI_SET_SINGLE_ITEM = 3,
    WMI_ENABLE_EVENTS = 4,
    WMI_DISABLE_EVENTS  = 5,
    WMI_ENABLE_COLLECTION = 6,
    WMI_DISABLE_COLLECTION = 7,
    WMI_REGINFO = 8,
    WMI_EXECUTE_METHOD = 9
#endif    
} WMIDPREQUESTCODE;

#if defined(_WINNT_) || defined(WINNT)
//
// WMI guid objects have the following rights
// WMIGUID_QUERY
// WMIGUID_SET
// WMIGUID_NOTIFICATION
// WMIGUID_READ_DESCRIPTION
// WMIGUID_EXECUTE
// TRACELOG_CREATE_REALTIME
// TRACELOG_CREATE_ONDISK
// TRACELOG_GUID_ENABLE
// TRACELOG_ACCESS_KERNEL_LOGGER

#define WMIGUID_QUERY                 0x0001
#define WMIGUID_SET                   0x0002
#define WMIGUID_NOTIFICATION          0x0004
#define WMIGUID_READ_DESCRIPTION      0x0008
#define WMIGUID_EXECUTE               0x0010
#define TRACELOG_CREATE_REALTIME      0x0020
#define TRACELOG_CREATE_ONDISK        0x0040
#define TRACELOG_GUID_ENABLE          0x0080
#define TRACELOG_ACCESS_KERNEL_LOGGER 0x0100

#define WMIGUID_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED |     \
                            WMIGUID_QUERY |                \
                            WMIGUID_SET |                  \
                            WMIGUID_NOTIFICATION |         \
                            WMIGUID_READ_DESCRIPTION |     \
                            WMIGUID_EXECUTE |              \
                            TRACELOG_CREATE_REALTIME |     \
                            TRACELOG_CREATE_ONDISK |       \
                            TRACELOG_GUID_ENABLE |         \
                            TRACELOG_ACCESS_KERNEL_LOGGER)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\wmi\wmium.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Wmium.h

Abstract:

    Public headers for WMI data consumers and providers

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#ifndef _WMIUM_
#define _WMIUM_

#ifndef MIDL_PASS
#ifdef _WMI_SOURCE_
#define WMIAPI __stdcall
#else
#define WMIAPI DECLSPEC_IMPORT __stdcall
#endif
#endif

#include <guiddef.h>

#include <basetsd.h>
#include <wmistr.h>

typedef PVOID WMIHANDLE, *PWMIHANDLE, MOFHANDLE, *PMOFHANDLE;


//
// When set the guid can be opened and accessed
#define MOFCI_RESERVED0  0x00000001

#define MOFCI_RESERVED1  0x00000002
#define MOFCI_RESERVED2  0x00000004

typedef struct
{
#ifdef MIDL_PASS
    [string] PDFTCHAR
#else
    LPWSTR
#endif
             ImagePath;        // Path to image containing MOF resource
#ifdef MIDL_PASS
    [string] PDFTCHAR
#else
    LPWSTR
#endif
             ResourceName;     // Name of resource in image
    ULONG    ResourceSize;     // Number of bytes in resource
#ifdef MIDL_PASS
    [size_is(0)] PDFBYTE
#else
    PUCHAR
#endif
             ResourceBuffer;    // Reserved
} MOFRESOURCEINFOW, *PMOFRESOURCEINFOW;


typedef struct
{
    LPSTR
             ImagePath;        // Path to image containing MOF resource
    LPSTR
             ResourceName;     // Name of resource in image
    ULONG    ResourceSize;     // Number of bytes in resource
    UCHAR
             *ResourceBuffer;   // Reserved
} MOFRESOURCEINFOA, *PMOFRESOURCEINFOA;

#ifdef UNICODE
typedef MOFRESOURCEINFOW MOFRESOURCEINFO;
typedef PMOFRESOURCEINFOW PMOFRESOURCEINFO;
#else
typedef MOFRESOURCEINFOA MOFRESOURCEINFO;
typedef PMOFRESOURCEINFOA PMOFRESOURCEINFO;
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Data consumer apis
ULONG
WMIAPI
WmiOpenBlock(
    IN GUID *Guid,
    IN ULONG DesiredAccess,
    OUT WMIHANDLE *DataBlockHandle
);

ULONG
WMIAPI
WmiCloseBlock(
    IN WMIHANDLE DataBlockHandle
);

ULONG
WMIAPI
WmiQueryAllDataA(
    IN WMIHANDLE DataBlockHandle,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );


ULONG
WMIAPI
WmiQueryAllDataW(
    IN WMIHANDLE DataBlockHandle,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );

#ifdef UNICODE
#define WmiQueryAllData WmiQueryAllDataW
#else
#define WmiQueryAllData WmiQueryAllDataA
#endif


ULONG
WMIAPI
WmiQueryAllDataMultipleA(
    IN WMIHANDLE *HandleList,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

ULONG
WMIAPI
WmiQueryAllDataMultipleW(
    IN WMIHANDLE *HandleList,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);
#ifdef UNICODE
#define WmiQueryAllDataMultiple WmiQueryAllDataMultipleW
#else
#define WmiQueryAllDataMultiple WmiQueryAllDataMultipleA
#endif


ULONG
WMIAPI
WmiQuerySingleInstanceA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );

ULONG
WMIAPI
WmiQuerySingleInstanceW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );
#ifdef UNICODE
#define WmiQuerySingleInstance WmiQuerySingleInstanceW
#else
#define WmiQuerySingleInstance WmiQuerySingleInstanceA
#endif


ULONG
WMIAPI
WmiQuerySingleInstanceMultipleW(
    IN WMIHANDLE *HandleList,
    IN PWCHAR *InstanceNames,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

ULONG
WMIAPI
WmiQuerySingleInstanceMultipleA(
    IN WMIHANDLE *HandleList,
    IN PCHAR *InstanceNames,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

#ifdef UNICODE
#define WmiQuerySingleInstanceMultiple WmiQuerySingleInstanceMultipleW
#else
#define WmiQuerySingleInstanceMultiple WmiQuerySingleInstanceMultipleA
#endif

ULONG
WMIAPI
WmiSetSingleInstanceA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

ULONG
WMIAPI
WmiSetSingleInstanceW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );
#ifdef UNICODE
#define WmiSetSingleInstance WmiSetSingleInstanceW
#else
#define WmiSetSingleInstance WmiSetSingleInstanceA
#endif

ULONG
WMIAPI
WmiSetSingleItemA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

ULONG
WMIAPI
WmiSetSingleItemW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );
#ifdef UNICODE
#define WmiSetSingleItem WmiSetSingleItemW
#else
#define WmiSetSingleItem WmiSetSingleItemA
#endif

ULONG
WMIAPI
WmiExecuteMethodA(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN PVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
    );

ULONG
WMIAPI
WmiExecuteMethodW(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCWSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN PVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
    );

#ifdef UNICODE
#define WmiExecuteMethod WmiExecuteMethodW
#else
#define WmiExecuteMethod WmiExecuteMethodA
#endif

// Set this Flag when calling NotficationRegistration to enable or
// disable a trace logging guid
#define NOTIFICATION_TRACE_FLAG       0x00010000

// Set this flag when enabling a notification that should be delivered via
// a direct callback. Any notifications received will be given their own
// thread and the callback function called immediately.
#define NOTIFICATION_CALLBACK_DIRECT  0x00000004

//
// Set this flag (and only this flag) when you want to only check if the 
// caller has permission to receive events for the guid
//
#define NOTIFICATION_CHECK_ACCESS 0x00000008

//
// Event notification callback function prototype
typedef void (
#ifndef MIDL_PASS
WINAPI
#endif
*NOTIFICATIONCALLBACK)(
    PWNODE_HEADER Wnode,
    UINT_PTR NotificationContext
    );

#ifndef MIDL_PASS
//
// This guid is for notifications of changes to registration
// {B48D49A1-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_REGISTRATION_CHANGE_NOTIFICATION,
0xb48d49a1, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

//
// This guid id for notifications of new mof resources being added
// {B48D49A2-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_MOF_RESOURCE_ADDED_NOTIFICATION,
0xb48d49a2, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

//
// This guid id for notifications of new mof resources being added
// {B48D49A3-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_MOF_RESOURCE_REMOVED_NOTIFICATION,
0xb48d49a3, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);
#endif

ULONG
WMIAPI
WmiNotificationRegistrationA(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    );

ULONG
WMIAPI
WmiNotificationRegistrationW(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    );
#ifdef UNICODE
#define WmiNotificationRegistration WmiNotificationRegistrationW
#else
#define WmiNotificationRegistration WmiNotificationRegistrationA
#endif

void
WMIAPI
WmiFreeBuffer(
    IN PVOID Buffer
    );


ULONG
WMIAPI
WmiEnumerateGuids(
    OUT LPGUID GuidList,
    IN OUT ULONG *GuidCount
    );

ULONG
WMIAPI
WmiMofEnumerateResourcesW(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFOW *MofResourceInfo
    );

ULONG
WMIAPI
WmiMofEnumerateResourcesA(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFOA *MofResourceInfo
    );
#ifdef UNICODE
#define WmiMofEnumerateResources WmiMofEnumerateResourcesW
#else
#define WmiMofEnumerateResources WmiMofEnumerateResourcesA
#endif

ULONG
WMIAPI
WmiFileHandleToInstanceNameA(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT CHAR *InstanceNames
    );

ULONG
WMIAPI
WmiFileHandleToInstanceNameW(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT WCHAR *InstanceNames
    );
#ifdef UNICODE
#define WmiFileHandleToInstanceName WmiFileHandleToInstanceNameW
#else
#define WmiFileHandleToInstanceName WmiFileHandleToInstanceNameA
#endif

#define WmiInsertTimestamp(WnodeHeader) \
    GetSystemTimeAsFileTime((FILETIME *)&((PWNODE_HEADER)WnodeHeader)->TimeStamp)

ULONG
WMIAPI
WmiDevInstToInstanceNameA(
    OUT CHAR *InstanceName,
    IN ULONG InstanceNameLength,
    IN CHAR *DevInst,
    IN ULONG InstanceIndex
    );

ULONG
WMIAPI
WmiDevInstToInstanceNameW(
    OUT WCHAR *InstanceName,
    IN ULONG InstanceNameLength,
    IN WCHAR *DevInst,
    IN ULONG InstanceIndex
    );
#ifdef UNICODE
#define WmiDevInstToInstanceName WmiDevInstToInstanceNameW
#else
#define WmiDevInstToInstanceName WmiDevInstToInstanceNameA
#endif

typedef struct _WMIGUIDINFORMATION
{
    ULONG Size;
    BOOLEAN IsExpensive;
    BOOLEAN IsEventOnly;
} WMIGUIDINFORMATION, *PWMIGUIDINFORMATION;


ULONG
WMIAPI
WmiQueryGuidInformation(
    IN WMIHANDLE GuidHandle,
    OUT PWMIGUIDINFORMATION GuidInfo
    );

#ifdef __cplusplus
}
#endif

#endif  // _WMIUM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wdmlib\wmi\wmiumkm.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    wmiumkm.h

Abstract:

    Private definitions for WMI communications between user and kernel modes

Author:

    AlanWar

Environment:

    Kernel and User modes

Revision History:


--*/

#ifndef _WMIUMKM_
#define _WMIUMKM_

//
// This defines the guid under which the default WMI security descriptor
// is maintained.
DEFINE_GUID(DefaultSecurityGuid, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
#define DefaultSecurityGuidName L"00000000-0000-0000-0000000000000000"

#ifndef _WMIKM_


//
// This defines the codes used to define what a request must do. These
// definitions must match the same in wmium.h
//

typedef enum tagWMIACTIONCODE
{
    WmiGetAllData = 0,
    WmiGetSingleInstance = 1,
    WmiChangeSingleInstance = 2,
    WmiChangeSingleItem = 3,
    WmiEnableEvents = 4,
    WmiDisableEvents  = 5,
    WmiEnableCollection = 6,
    WmiDisableCollection = 7,
    WmiRegisterInfo = 8,
    WmiExecuteMethodCall = 9
} WMIACTIONCODE;

#endif

#if defined(_WINNT_) || defined(WINNT)

typedef enum
{
    WmiStartLoggerCode = 32,
    WmiStopLoggerCode = 33,
    WmiQueryLoggerCode = 34,
    WmiTraceEventCode = 35,
    WmiUpdateLoggerCode = 36
} WMITRACECODE;
#endif

typedef enum
{
    WmiReadNotifications = 64,
    WmiGetNextRegistrant = 65,
    WmiOpenGuid = 66,
    WmiNotifyUser = 67,
    WmiGetAllRegistrant = 68,
    WmiGenerateEvent = 69,
    WmiAllocInstanceIdForGuid = 70,
    WmiTranslateFileHandle = 71,
    WmiGetVersion = 73
} WMISERVICECODES;

//
// This defines the name of the WMI device that manages service IOCTLS
#define WMIServiceDeviceObjectName       L"\\Device\\WMIServiceDevice"
#define WMIServiceDeviceName TEXT("\\\\.\\WMIServiceDevice")
#define WMIServiceSymbolicLinkName TEXT("\\DosDevices\\WMIServiceDevice")

#ifdef MEMPHIS
//
// This id the name of the device that handles query/set IOCTLS. On memphis
// it is the same as the service device name.
#define WMIDataDeviceObjectName       L"\\Device\\WMIDevice"
#define WMIDataDeviceName TEXT("\\\\.\\WMIServiceDevice")
#define WMIDataSymbolicLinkName TEXT("\\DosDevices\\WMIServiceDevice")
#else
//
// This id the name of the device that handles query/set IOCTLS. On NT it is
// a different device name than the service device. On NT the service
// device is an exclusive access device that can only be opened by the
// wmi service.
#define WMIDataDeviceObjectName       L"\\Device\\WMIDataDevice"
#define WMIDataDeviceName TEXT("\\\\.\\WMIDataDevice")
#define WMIDataSymbolicLinkName TEXT("\\DosDevices\\WMIDataDevice")
#endif

//
// This IOCTL will return when a KM notification has been generated that
// requires user mode attention.
//   BufferIn - Not used
//   BufferOut - Buffer to return notification information
#define IOCTL_WMI_READ_NOTIFICATIONS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiReadNotifications, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will return with the next set of unprocessed registration info
// BufferIn - Not used
// BufferOut - Buffer to return registration information
#define IOCTL_WMI_GET_NEXT_REGISTRANT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetNextRegistrant, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will return a handle to a guid
// BufferIn - WMIOPENGUIDBLOCK
// BufferOut - WMIOPENGUIDBLOCK
#define IOCTL_WMI_OPEN_GUID \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiOpenGuid, METHOD_BUFFERED, FILE_READ_ACCESS)

// This IOCTL will perform a query for all data items of a data block
// BufferIn - Incoming WNODE describing query. This gets filled in by driver
#define IOCTL_WMI_QUERY_ALL_DATA \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetAllData, METHOD_BUFFERED, FILE_READ_ACCESS)

// This IOCTL will query for a single instance
// BufferIn - Incoming WNODE describing query. This gets filled in by driver
#define IOCTL_WMI_QUERY_SINGLE_INSTANCE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetSingleInstance, METHOD_BUFFERED, FILE_READ_ACCESS)

// This IOCTL will set a single instance
// BufferIn - Incoming WNODE describing set.
#define IOCTL_WMI_SET_SINGLE_INSTANCE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiChangeSingleInstance, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will set a single item
// BufferIn - Incoming WNODE describing set.
#define IOCTL_WMI_SET_SINGLE_ITEM \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiChangeSingleItem, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will enable an event
// BufferIn - Incoming WNODE event item to enable
#define IOCTL_WMI_ENABLE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnableEvents, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will disable an event
// BufferIn - Incoming WNODE event item to disable
#define IOCTL_WMI_DISABLE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiDisableEvents, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will enable collection
// BufferIn - Incoming WNODE describing what to enable for collection
#define IOCTL_WMI_ENABLE_COLLECTION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiEnableCollection, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will disable collection
// BufferIn - Incoming WNODE describing what to disable for collection
#define IOCTL_WMI_DISABLE_COLLECTION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiDisableCollection, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will return the registration information for a specific provider
// BufferIn - Provider handle
// BufferOut - Buffer to return WMI information
#define IOCTL_WMI_GET_REGINFO \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiRegisterInfo, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will execute a method on a device
// BufferIn - WNODE_METHOD_ITEM
// BufferOut - WNODE_METHOD_ITEM
#define IOCTL_WMI_EXECUTE_METHOD \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiExecuteMethodCall, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will cause a registration notification to be generated
// BufferIn - Not used
// BufferOut - Not used
#define IOCTL_WMI_NOTIFY_USER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiNotifyUser, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This IOCTL will return with the all registration info
// BufferIn - Not used
// BufferOut - Buffer to return all registration information
#define IOCTL_WMI_GET_ALL_REGISTRANT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetAllRegistrant, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will cause certain data providers to generate events
// BufferIn - WnodeEventItem to use in firing event
// BufferOut - Not Used
#define IOCTL_WMI_GENERATE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGenerateEvent, METHOD_BUFFERED, FILE_WRITE_ACCESS)


// This IOCTL will allocate a range of instance ids for a specific guid
// BufferIn - incoming WMIALLOCINSTID structure
// BufferOut - outgoing WMIALLOCINSTID structure
#define IOCTL_WMI_ALLOCATE_INSTANCE_IDS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiAllocInstanceIdForGuid, METHOD_BUFFERED, FILE_WRITE_ACCESS)

// This IOCTL will translate a File Object into a device object
// BufferIn - pointer to incoming WMIFILETODEVICE structure
// BufferOut - outgoing WMIFILETODEVICE structure
#define IOCTL_WMI_TRANSLATE_FILE_HANDLE \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiTranslateFileHandle, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This IOCTL will check if the caller has desired access to the guid
// BufferIn - WMIOPENGUIDBLOCK
// BufferOut - WMIOPENGUIDBLOCK
#define IOCTL_WMI_CHECK_ACCESS \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiCheckAccess, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// This IOCTL will determine the version of WMI
// BufferIn - Not used
// BufferOut - WMIVERSIONINFO
#define IOCTL_WMI_GET_VERSION \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiGetVersion, METHOD_BUFFERED, FILE_READ_ACCESS)


#if defined(_WINNT_) || defined(WINNT)
//
// This IOCTL will start an instance of a logger
// BufferIn - Logger configuration information
// BufferOut - Updated logger information when logger is started
#define IOCTL_WMI_START_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiStartLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will stop an instance of a logger
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information when logger is stopped
#define IOCTL_WMI_STOP_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiStopLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will update an existing logger attributes
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information
#define IOCTL_WMI_UPDATE_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiUpdateLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will query a logger for its information
// BufferIn - Logger information structure with Handle set
// BufferOut - Updated logger information
#define IOCTL_WMI_QUERY_LOGGER \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiQueryLoggerCode, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// This IOCTL will synchronize a trace record to the logger
// BufferIn - Trace record, with handle set
// BufferOut - Not used
#define IOCTL_WMI_TRACE_EVENT \
          CTL_CODE(FILE_DEVICE_UNKNOWN, WmiTraceEventCode, METHOD_NEITHER, FILE_WRITE_ACCESS)

#endif // WINNT

//
// Notifications from kernel mode WMI to user mode WMI
typedef enum
{
    RegistrationAdd,		// A new data provider is being registered
    RegistrationDelete,		// A data provider is being removed
    RegistrationUpdate,		// A data provider is being updated
    EventNotification,      // An event is fired by a data provider
    RegChangeNotification
} NOTIFICATIONTYPES;


//
// This defines the maximum number of kernel mode data providers
#define MAXKMREGISTRANTS 32


//
// This is used in IOCTL_WMI_GET_ALL_REGISTRANT to report the list of
// registered KM data providers to the WMI service
typedef struct
{
    OUT UINT_PTR ProviderId;	// Provider Id (or device object pointer)
    OUT ULONG Flags;			// REGENTRY_FLAG_*
} KMREGINFO, *PKMREGINFO;

#define REGENTRY_FLAG_NEWREGINFO 0x00000004   // Entry has new registration info
#define REGENTRY_FLAG_UPDREGINFO 0x00000008   // Entry has updated registration info


//
// This structure is used in IOCTL_WMI_ALLOCATE_INSTANCE_IDS
typedef struct
{
    IN GUID Guid;              // Guid whose instance ids are allocated for
    IN ULONG InstanceCount;    // Number of instance ids to allocate
    OUT ULONG FirstInstanceId; // First instance id for guid
} WMIALLOCINSTID, *PWMIALLOCINSTID;

//
// This structure is used in IOCTL_WMI_TRANSLATE_FILE_HANDLE
typedef struct
{
    union
    {
        IN HANDLE FileHandle;      // File handle whose instance name is needed
        OUT ULONG SizeNeeded;      // If incoming buffer too small then this
                                   // returns with number bytes needed.
    };
    OUT USHORT InstanceNameLength; // Length of instance name in bytes
    OUT WCHAR InstanceNameBase[];  // Instance name in unicode
} WMIFHTOINSTANCENAME, *PWMIFHTOINSTANCENAME;


//
// This is used in IOCTL_WMI_OPEN_GUID
typedef struct
{
    IN GUID Guid;
    IN ACCESS_MASK DesiredAccess;
    OUT HANDLE Handle;
} WMIOPENGUIDBLOCK, *PWMIOPENGUIDBLOCK;


//
// This is used to retrieve the internal version of WMI in IOCTL_WMI_GET_VERSION

#define WMI_CURRENT_VERSION 1

typedef struct
{
    ULONG Version;
} WMIVERSIONINFO, *PWMIVERSIONINFO;

#if defined(_WINNT_) || defined(WINNT)
//
// The predefined event groups or families for NT subsystems
//

#define EVENT_TRACE_GROUP_HEADER               0x0000
#define EVENT_TRACE_GROUP_IO                   0x0100
#define EVENT_TRACE_GROUP_MEMORY               0x0200
#define EVENT_TRACE_GROUP_PROCESS              0x0300
#define EVENT_TRACE_GROUP_FILE                 0x0400
#define EVENT_TRACE_GROUP_THREAD               0x0500

//
// see evntrace.h for pre-defined generic event types (0-10)
//

// The actual buffer, the first two DWORDS used for header information
// defined below.

typedef struct _WMI_TRACE_BUFFER {
    WNODE_HEADER Wnode;
    char*   CurrentPointer;    // point to free data space; offset when logged
    ULONG   EventsLost;        // used to count events lost
    char*   Data;              // this is where data is written
} WMI_TRACE_BUFFER, *PWMI_TRACE_BUFFER;

typedef struct _WMI_TRACE_PACKET {   // must be ULONG!!
    USHORT  Size;
    UCHAR   Type;
    UCHAR   Group;
} WMI_TRACE_PACKET, *PWMI_TRACE_PACKET;

//
// Trace header for kernel events -- more compact
//
typedef struct _SYSTEM_TRACE_HEADER {
    union {
        ULONG            Header;    // both sizes must be the same!
        WMI_TRACE_PACKET Packet;
    };
    UINT_PTR        ThreadId;
    LARGE_INTEGER   SystemTime;
    ULONG           KernelTime;
    ULONG           UserTime;
} SYSTEM_TRACE_HEADER, *PSYSTEM_TRACE_HEADER;

#ifndef MEMPHIS
//
// Logger configuration and running statistics. This structure is used
// by WMI.DLL to convert to UNICODE_STRING
//
typedef struct _WMI_LOGGER_INFORMATION {
    WNODE_HEADER Wnode;       // Had to do this since wmium.h comes later
//
// data provider by caller
    ULONG BufferSize;                   // size of a buffer for logging
    ULONG MinimumBuffers;               // minimum to preallocate
    ULONG MaximumBuffers;               // maximum buffers allowed
    ULONG MaximumFileSize;              // maximum logfile size
    ULONG LogFileMode;                  // sequential, circular, or newfile
    ULONG FlushTimer;                   // buffer flush timer, in seconds
    ULONG ExtensionFlags;               // kernel subsystem extended mode

// data returned to caller
    ULONG NumberOfBuffers;              // no of buffers in use
    ULONG FreeBuffers;                  // no of buffers free
    ULONG EventsLost;                   // event records lost
    ULONG BuffersWritten;               // no of buffers written to file`
    UINT_PTR LoggerThreadId;            // thread id of Logger
    UNICODE_STRING LogFileName;         // Logfile name

// mandatory data provided by caller
    UNICODE_STRING LoggerName;          // Instance name for logger

    PVOID LoggerExtension;
} WMI_LOGGER_INFORMATION, *PWMI_LOGGER_INFORMATION;
#endif // !MEMPHIS

#endif // WINNT

#endif // _WMIUMKM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\actualparse.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ActualParse.H

Abstract:

    Declares the object path parser engine.

History:

    a-davj  11-feb-00       Created.

--*/

#ifndef _ACTUALPARSE_H_
#define _ACTUALPARSE_H_

#include "genlex.h"
#include "opathlex2.h"
#include <wmiutils.h>
//#include "wbemutil.h"
#include "wbemcli.h"
#include <flexarry.h>

// NOTE:
// The m_vValue in the CKeyRef may not be of the expected type, i.e., the parser
// cannot distinguish 16 bit integers from 32 bit integers if they fall within the
// legal subrange of a 16 bit value.  Therefore, the parser only uses the following
// types for keys:
//      VT_I4, VT_R8, VT_BSTR
// If the underlying type is different, the user of this parser must do appropriate
// type conversion.
//  

class  CActualPathParser
{
    LPWSTR m_pInitialIdent;
    int m_nCurrentToken;
    CGenLexer *m_pLexer;
    CDefPathParser *m_pOutput;
    CKeyRef *m_pTmpKeyRef;
    
    DWORD m_eFlags;

private:
    void Zero();
    void Empty();

    int begin_parse();

    int ns_or_server();
    int ns_or_class();
    int optional_scope_class_list();
    int objref();
    int ns_list();
    int ident_becomes_ns();
    int ident_becomes_class();
    int objref_rest();
    int ns_list_rest();
    int key_const();
    int keyref_list();
    int keyref();
    int keyref_term();
    int propname();    
    int optional_objref();

    int NextToken();
public:
    enum { NoError, SyntaxError, InvalidParameter, NoMemory };
    friend class AutoClear;
    CActualPathParser(DWORD eFlags);
   ~CActualPathParser();

    int Parse(LPCWSTR RawPath, CDefPathParser & Output);
    static LPWSTR GetRelativePath(LPWSTR wszFullPath);

};

class AutoClear
{
    private:
        CActualPathParser * m_pToBeCleared;
    public:
        AutoClear(CActualPathParser * pToBeCleared){m_pToBeCleared = pToBeCleared;};
        ~AutoClear()
            {
                if(m_pToBeCleared)
                {
                    m_pToBeCleared->Empty(); 
                    m_pToBeCleared->Zero();
                }
            };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\actualparse.cpp ===
/*++



// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    ActualParse.CPP

Abstract:

    Implements the object path parser engine

History:

    a-davj  11-feb-00       Created.

--*/

#include "precomp.h"
#include <genlex.h>
#include "opathlex2.h"
#include "PathParse.h"
#include "ActualParse.h"
#include "commain.h"
//#include "resource.h"
#include "wbemcli.h"
#include <stdio.h>
#include "helpers.h"



//***************************************************************************
//
//  CActualPathParser
//
//***************************************************************************



LPWSTR CActualPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    // We need the last colon, if any

    LPWSTR wszTemp = wcschr(wszFullPath, L':');
    while (wszTemp != NULL)
    {
        LPWSTR wszSave = wszTemp;
        wszTemp++;
        wszTemp = wcschr(wszTemp, L':'); 
        if (!wszTemp)
        {
            wszTemp = wszSave;
            break;
        }
    }

    if (wszTemp)
        return wszTemp + 1;
    else
        return NULL;
}

void CActualPathParser::Zero()
{
    m_nCurrentToken = 0;
    m_pLexer = 0;
    m_pInitialIdent = 0;
    m_pOutput = 0;
    m_pTmpKeyRef = 0;
}

CActualPathParser::CActualPathParser(DWORD eFlags)
    : m_eFlags(eFlags)
{
    Zero();
}

void CActualPathParser::Empty()
{
    delete m_pLexer;
    m_pLexer = NULL;
    delete m_pInitialIdent;
    m_pInitialIdent = NULL;
    delete m_pTmpKeyRef;
    m_pTmpKeyRef = NULL;
    // m_pOutput is intentionally left alone,
    // since all code paths delete this already on error, or
    // else the user acquired the pointer.
}

CActualPathParser::~CActualPathParser()
{
    Empty();
}

int CActualPathParser::Parse(
    LPCWSTR pRawPath,
    CDefPathParser & Output
    )
{
	DWORD dwTest = m_eFlags & ~WBEMPATH_TREAT_SINGLE_IDENT_AS_NS;
    if(dwTest != WBEMPATH_CREATE_ACCEPT_RELATIVE &&
       dwTest != WBEMPATH_CREATE_ACCEPT_ABSOLUTE &&
       dwTest != WBEMPATH_CREATE_ACCEPT_ALL)
        return CActualPathParser::InvalidParameter;

    if (pRawPath == 0 || wcslen(pRawPath) == 0)
        return CActualPathParser::InvalidParameter;

    // Check for leading / trailing ws.
    // ================================
    
    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0])) 
        return InvalidParameter;
    
     // These are required for multiple calls to Parse().
    // ==================================================
    Empty();
    Zero();

    m_pOutput = &Output;

    // Parse the server name (if there is one) manually
    // ================================================

    if ( (pRawPath[0] == '\\' && pRawPath[1] == '\\') ||
         (pRawPath[0] == '/' && pRawPath[1] == '/'))
    {
        const WCHAR* pwcStart = pRawPath + 2;

        // Find the next backslash --- it's the end of the server name
		// Since the next slash can be either, search for both and take
		// the first one.  If the first character is a '[', then then
		// end is indicated by a ']'
        // ============================================================

        WCHAR* pwcEnd = NULL;
		if(*pwcStart == L'[')
		{
			// look for the ']'
			
			WCHAR * pCloseBrace = wcschr(pwcStart, L']');
			if(pCloseBrace == NULL)
				return SyntaxError;
			pwcEnd = pCloseBrace+1;
		}
		else
		{
			WCHAR* pwcNextBack = wcschr(pwcStart, L'\\');
			WCHAR* pwcNextForward = wcschr(pwcStart, L'/');
			pwcEnd = pwcNextBack;
			if(pwcEnd == NULL)
				pwcEnd = pwcNextForward;
			else if(pwcNextForward && (pwcNextForward < pwcNextBack))
				pwcEnd = pwcNextForward;
		}   
        if (pwcEnd == NULL)
        {
            // If we have already exhausted the object path string,
            // a lone server name was all there was.
            // ====================================================

            if ((m_eFlags & WBEMPATH_CREATE_ACCEPT_ALL) == 0)
            {
                return SyntaxError;
            }
            else    // A lone server name is legal.
            {   
                m_pOutput->SetServer(pwcStart);
                return NoError;
            }
        }

        if(pwcEnd == pwcStart)
        {
            // No name at all.
            // ===============
            return SyntaxError;
        }

        WCHAR * wTemp = new WCHAR[pwcEnd-pwcStart+1];
		if(wTemp == NULL)
			return NoMemory;
        wcsncpy(wTemp, pwcStart, pwcEnd-pwcStart);
        wTemp[pwcEnd-pwcStart] = 0;
        m_pOutput->SetServer(wTemp, false, true);
        pRawPath = pwcEnd;
    }

    // Point the lexer at the source.
    // ==============================

    CTextLexSource src((LPWSTR)pRawPath);
    {
    	AutoClear ac(this);
	    m_pLexer = new CGenLexer(OPath_LexTable2, &src);
		if(m_pLexer == NULL)
			return NoMemory;
		Output.m_pGenLex = m_pLexer;				// TEST CODE
	    // Go.
	    // ===

	    int nRes = begin_parse();
	    if (nRes)
	    {
	        return nRes;
	    }

	    if (m_nCurrentToken != OPATH_TOK_EOF)
	    {
	        return SyntaxError;
	    }

	    if (m_pOutput->GetNumComponents() > 0 && !m_pOutput->HasServer())
	    {
	        if ( ! ( m_eFlags & WBEMPATH_CREATE_ACCEPT_RELATIVE ) && ! ( m_eFlags & WBEMPATH_CREATE_ACCEPT_ALL ) )
	        {
	            return SyntaxError;
	        }
	        else
	        {
	            // Local namespace --- set server to "."
	            // =====================================

	            m_pOutput->SetServer(L".", true, false);
	        }
	    }
    }
    Output.SortKeys();

    // Add in key refs.
    // ================
    return NoError;
}

BOOL CActualPathParser::NextToken()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == OPATH_TOK_ERROR)
        return FALSE;
    return TRUE;
}

//
//  <Parse> ::= BACKSLASH <ns_or_server>;
//  <Parse> ::= IDENT <ns_or_class>;
//  <Parse> ::= COLON <ns_or_class>;
//
int CActualPathParser::begin_parse()
{
    if (!NextToken())
        return SyntaxError;

    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_or_server();
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
    	m_pInitialIdent = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
		if(m_pInitialIdent == NULL)
			return NoMemory;
		if (!NextToken())
            return SyntaxError;

        // Copy the token and put it in a temporary holding place
        // until we figure out whether it is a namespace or a class name.
        // ==============================================================

        return ns_or_class();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        // A colon may indicate a namespace now...

        if (!NextToken())
            return SyntaxError;
        return ns_or_class();
    }

    // If here, we had a bad starter token.
    // ====================================

    return SyntaxError;
}

//
//  <ns_or_server> ::= IDENT <ns_list>;
//
int CActualPathParser::ns_or_server()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        // Actually, server names have been take care of, so this is a failure
        // ===================================================================

        return SyntaxError;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        return ns_list();
    }
    else 
        if (m_nCurrentToken == OPATH_TOK_EOF)
            return NoError;

    return SyntaxError;
}

//  <ns_or_class> ::= COLON <ident_becomes_ns> <objref> <optional_scope_class_list>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list>;
//  <ns_or_class> ::= <ident_becomes_ns> <objref_rest>;
//  <ns_or_class> ::= <ident_becomes_class> <objref_rest>;

int CActualPathParser::ns_or_class()
{
    if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        int nRes = objref();
        if (nRes)
            return nRes; 
        if ((m_nCurrentToken != OPATH_TOK_EOF))
            return optional_scope_class_list();
        return NoError;
    }
    else if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        return ns_list();
    }
	else if ((m_nCurrentToken == OPATH_TOK_EOF) && 
		     (m_eFlags & WBEMPATH_TREAT_SINGLE_IDENT_AS_NS))
	{
		return ident_becomes_ns();
	}
    // Else
    // ====
    ident_becomes_class();
    if(objref_rest())
        return SyntaxError;
    else
        return optional_scope_class_list();
}

//  <optional_scope_class_list> ::= COLON <objref> <optional_scope_class_list>
//  <optional_scope_class_list> ::= <>

int CActualPathParser::optional_scope_class_list()
{    
    if (m_nCurrentToken == OPATH_TOK_EOF)
        return NoError;
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        if (!NextToken())
            return SyntaxError;
        if (objref() == NoError)
            return optional_scope_class_list();
        return SyntaxError;

    }
    return NoError;
}

//
//  <objref> ::= IDENT <objref_rest>;  // IDENT is classname
//
int CActualPathParser::objref()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pOutput->AddClass(m_pLexer->GetTokenText());

    if (!NextToken())
        return SyntaxError;

    return objref_rest();
}

//
//  <ns_list> ::= IDENT <ns_list_rest>;
//
int CActualPathParser::ns_list()
{
    if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pOutput->AddNamespace(m_pLexer->GetTokenText());

        if (!NextToken())
            return SyntaxError;
        return ns_list_rest();
    }

    return SyntaxError;
}

//
//  <ident_becomes_ns> ::= <>;      // <initial_ident> becomes a namespace
//
int CActualPathParser::ident_becomes_ns()
{
    m_pOutput->AddNamespace(m_pInitialIdent);

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <ident_becomes_class> ::= <>;   // <initial_ident> becomes the class
//
int CActualPathParser::ident_becomes_class()
{
    m_pOutput->AddClass(m_pInitialIdent);

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <objref_rest> ::= EQUALS <key_const>;
//  <objref_rest> ::= EQUALS @;
//  <objref_rest> ::= DOT <keyref_list>;
//  <objref_rest> ::= <>;
//
int CActualPathParser::objref_rest()
{
    if (m_nCurrentToken == OPATH_TOK_EQ)
    {
        if (!NextToken())
            return SyntaxError;

        // Take care of the singleton case.  This is a path of the form
        // MyClass=@  and represents a singleton instance of a class with no
        // keys.


        if(m_nCurrentToken == OPATH_TOK_SINGLETON_SYM)
        {
            NextToken();
            m_pOutput->SetSingletonObj();
            return NoError;

        }

        m_pTmpKeyRef = new CKeyRef;
		if(m_pTmpKeyRef == NULL)
			return NoMemory;

        int nRes = key_const();
        if (nRes)
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return nRes;
        }

        m_pOutput->AddKeyRef(m_pTmpKeyRef);
        m_pTmpKeyRef = 0;
    }
    else if (m_nCurrentToken == OPATH_TOK_DOT)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
//  <ns_list_rest> ::= BACKSLASH <ns_list>;
//  <ns_list_rest> ::= COLON <objref> <optional_scope_class_list>;
//  <ns_list_rest> ::= <>;

int CActualPathParser::ns_list_rest()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_list();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        if (!NextToken())
            return SyntaxError;
        if (objref() == NoError)
            return optional_scope_class_list();
        return SyntaxError;
    }
    return NoError;
}

//
//  <key_const> ::= STRING_CONST;
//  <key_const> ::= INTEGRAL_CONST;
//  <key_const> ::= REAL_CONST;
//  <key_const> ::= IDENT;      // Where IDENT is "OBJECT" for singleton classes
//
int CActualPathParser::key_const()
{
    // If here, we have a key constant.
    // We may or may not have the property name
    // associated with it.
    // ========================================

    if (m_nCurrentToken == OPATH_TOK_QSTRING)
    {
        int iNumByte = 2*(wcslen(m_pLexer->GetTokenText()) +1);
        m_pTmpKeyRef->SetData(CIM_STRING, iNumByte, m_pLexer->GetTokenText());
    }
    else if (m_nCurrentToken == OPATH_TOK_REFERENCE)
    {
        int iNumByte = 2*(wcslen(m_pLexer->GetTokenText()) +1);
        m_pTmpKeyRef->SetData(CIM_REFERENCE, iNumByte, m_pLexer->GetTokenText());
    }
    else if (m_nCurrentToken == OPATH_TOK_INT)
    {
       	if(*(m_pLexer->GetTokenText()) == L'-')
		{
			__int64 llVal = _wtoi64(m_pLexer->GetTokenText());
			if(llVal > 2147483647 || llVal < -(__int64)2147483648) 
				m_pTmpKeyRef->SetData(CIM_SINT64, 8, &llVal);
			else
				m_pTmpKeyRef->SetData(CIM_SINT32, 4, &llVal);
		}
		else
		{
			unsigned __int64 ullVal;
			if(0 == swscanf(m_pLexer->GetTokenText(), L"%I64u", &ullVal))
				return SyntaxError;
			if(ullVal < 2147483648) 
				m_pTmpKeyRef->SetData(CIM_SINT32, 4, &ullVal);
			else if(ullVal > 0xffffffff) 
				m_pTmpKeyRef->SetData(CIM_UINT64, 8, &ullVal);
			else
				m_pTmpKeyRef->SetData(CIM_UINT32, 4, &ullVal);
		}
    }
    else if (m_nCurrentToken == OPATH_TOK_HEXINT)
    {
        unsigned __int64 ullVal;
        if(0 ==swscanf(m_pLexer->GetTokenText(),L"%I64x", &ullVal))
        	return SyntaxError;
        m_pTmpKeyRef->SetData(CIM_UINT64, 8, &ullVal);
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
       if (wbem_wcsicmp(m_pLexer->GetTokenText(), L"TRUE") == 0)
       {
            long lVal = 1;
            m_pTmpKeyRef->SetData(CIM_BOOLEAN, 4, &lVal);
        }
       else if (wbem_wcsicmp(m_pLexer->GetTokenText(), L"FALSE") == 0)
       {
            long lVal = 0;
            m_pTmpKeyRef->SetData(CIM_BOOLEAN, 4, &lVal);
       }
       else
            return SyntaxError;
    }
    else return SyntaxError;

    if (!NextToken())
        return SyntaxError;

    return NoError;
}

//
// <keyref_list> ::= <keyref> <keyref_term>;
//
int CActualPathParser::keyref_list()
{
    int nRes = keyref();
    if (nRes)
        return nRes;
    return keyref_term();
}

//
// <keyref> ::= <propname> EQUALS <key_const>;
//
int CActualPathParser::keyref()
{
    m_pTmpKeyRef = new CKeyRef;
	if(m_pTmpKeyRef == NULL)
		return NoMemory;

    int nRes = propname();

    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EQ)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    nRes = key_const();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    m_pOutput->AddKeyRef(m_pTmpKeyRef);
    m_pTmpKeyRef = 0;

    return NoError;
}

//
//  <keyref_term> ::= COMMA <keyref_list>;      // Used for compound keys
//  <keyref_term> ::= <>;
//
int CActualPathParser::keyref_term()
{
    if (m_nCurrentToken == OPATH_TOK_COMMA)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
// <propname>  ::= IDENT;
//
int CActualPathParser::propname()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pTmpKeyRef->m_pName = Macro_CloneLPWSTR(m_pLexer->GetTokenText());

    if (!m_pTmpKeyRef->m_pName)
        return NoMemory;

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    return NoError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\assocqp.cpp ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    ASSOCQP.CPP

Abstract:

    Association query parser

History:

    raymcc   04-Jul-99   Created.
    raymcc   14-Aug-99   Resubmit due to VSS problem.
    raymcc   11-Apr-00   Reworked for WMIUTILS

--*/

#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>

#include <wmiutils.h>
#include <genlex.h>
#include <assocqp.h>
#include <wbemcli.h>
#include <helpers.h>

#define ASSOC_QUERY_VERSION     2


// ==========================================================================
//                        ASSOCIATION QUERY PARSER.
// ==========================================================================


#define QASSOC_TOK_STRING       101
#define QASSOC_TOK_IDENT        102
#define QASSOC_TOK_DOT          103
#define QASSOC_TOK_EQU          104
#define QASSOC_TOK_COLON        105

#define QASSOC_TOK_ERROR        1
#define QASSOC_TOK_EOF          0

#define ST_IDENT                13
#define ST_STRING               19
#define ST_QSTRING              26
#define ST_QSTRING_ESC          30

// DFA State Table for Assoc query tokens.
// =======================================

LexEl AssocQuery_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'{',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,

/* 4 */  L'=',   GLEX_EMPTY, 0,  QASSOC_TOK_EQU, GLEX_ACCEPT|GLEX_RETURN,
/* 5 */  L'.',   GLEX_EMPTY, 0,  QASSOC_TOK_DOT, GLEX_ACCEPT|GLEX_RETURN,
/* 6 */  L':',   GLEX_EMPTY, 0,  QASSOC_TOK_COLON, GLEX_ACCEPT|GLEX_RETURN,

/* 7 */  L' ',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 8 */  L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 9 */  L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 10 */  L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 11 */  0,      GLEX_EMPTY, 0,  QASSOC_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 12 */  GLEX_ANY, GLEX_EMPTY, 0,        QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


/* ST_IDENT */

/* 13 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 14 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 15 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 16 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 17 */  GLEX_ANY, GLEX_EMPTY,  0,  QASSOC_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

/* ST_STRING */
/* 18 */  0, GLEX_EMPTY, 0,        QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,
/* 19 */  L'"', GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,
/* 20 */  L'}',  GLEX_EMPTY, 0, QASSOC_TOK_STRING, GLEX_RETURN,
/* 21 */  L' ',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 22 */  L'\r',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 23 */  L'\n',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 24 */  L'\t',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 25 */  GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

/* ST_QSTRING */
/* 26 */   0,    GLEX_EMPTY,   0, QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,
/* 27 */   L'"', GLEX_EMPTY,   ST_STRING, 0, GLEX_ACCEPT,
/* 28 */   L'\\', GLEX_EMPTY,   ST_QSTRING_ESC, 0, GLEX_ACCEPT,
/* 29 */   GLEX_ANY, GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,

/* ST_QSTRING_ESC */
/* 30 */   GLEX_ANY, GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,
};

/*----------------------------------------------------

References of {objpath} where
    ResultClass=XXX
    Role=YYY
    RequiredQualifier=QualifierName
    ClassDefsOnly

Associators of {objpath} where
    ResultClass=XXX
    AssocClass=YYY
    Role=PPP
    RequiredQualifier=QualifierName
    RequiredAssocQualifier=QualifierName
    ClassDefsOnly

------------------------------------------------------*/

static HRESULT ParseAssocQuery(
    IN  LPWSTR  Query,
    OUT LPWSTR *pTargetObj,
    OUT LPWSTR *pResultClass,
    OUT LPWSTR *pAssocClass,
    OUT LPWSTR *pRole,
    OUT LPWSTR *pResultRole,
    OUT LPWSTR *pRequiredQualifier,
    OUT LPWSTR *pRequiredAssocQualifier,
    OUT DWORD  *pdwQueryType
    )
{
    *pTargetObj = 0;
    *pResultClass = 0;
    *pAssocClass = 0;
    *pRole = 0;
    *pResultRole = 0;
    *pRequiredQualifier = 0;
    *pRequiredAssocQualifier = 0;
    *pdwQueryType = 0;

    CTextLexSource src(Query);
    CGenLexer Lexer(AssocQuery_LexTable, &src);
    if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY) return WBEM_E_OUT_OF_MEMORY;

    int nTok = 0;
    BOOL bHadTokens = FALSE;

    // Get first token.
    // TBD: Check for out-of-memory
    // =============================
    nTok = Lexer.NextToken();
    if (nTok != QASSOC_TOK_IDENT)
        goto Error;

    // REFERENCES or ASSOCIATORS
    // =========================
    if (wbem_wcsicmp(L"References", Lexer.GetTokenText()) == 0)
        *pdwQueryType |= WMIQ_ASSOCQ_REFERENCES;
    else if (wbem_wcsicmp(L"Associators", Lexer.GetTokenText()) == 0)
        *pdwQueryType |= WMIQ_ASSOCQ_ASSOCIATORS;
    else
        goto Error;

    // OF
    // ==
    nTok = Lexer.NextToken();
    if (nTok != QASSOC_TOK_IDENT)
        goto Error;
    if (wbem_wcsicmp(L"of", Lexer.GetTokenText()) != 0)
        goto Error;

    // {OBJECTPATH}
    // ============
    nTok = Lexer.NextToken();
    if (nTok != QASSOC_TOK_STRING)
        goto Error;

    *pTargetObj = Macro_CloneLPWSTR(Lexer.GetTokenText());
    if (!(*pTargetObj))
        goto Error;    

    // WHERE
    // =====
    nTok = Lexer.NextToken();
    if (nTok == QASSOC_TOK_EOF)
        goto Completed;

    if (nTok != QASSOC_TOK_IDENT)
        goto Error;

    if (wbem_wcsicmp(L"where", Lexer.GetTokenText()) != 0)
        goto Error;

    // Check for RESULTCLASS, ROLE, ASSOCCLASS, CLASSDEFSONLY,
    // REQUIREDQUALIFIER, REQUIREDASSOCQUALIFIER
    // ======================================================

    for (;;)
    {
        nTok = Lexer.NextToken();
        if (nTok == QASSOC_TOK_ERROR)
            goto Error;

        if (nTok == QASSOC_TOK_EOF)
        {
            if(!bHadTokens)
                goto Error;
            else
                goto Completed;
        }

        if (nTok != QASSOC_TOK_IDENT)
            goto Error;

        bHadTokens = TRUE;

        if (wbem_wcsicmp(L"RESULTCLASS", Lexer.GetTokenText()) == 0)
        {
            if(*pResultClass)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pResultClass = Macro_CloneLPWSTR(Lexer.GetTokenText());
            if (!(*pResultClass))
                goto Error;
            *pdwQueryType |= WMIQ_ASSOCQ_RESULTCLASS;
        }
        else if (wbem_wcsicmp(L"ROLE", Lexer.GetTokenText()) == 0)
        {
            if(*pRole)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pRole = Macro_CloneLPWSTR(Lexer.GetTokenText());
            if (!(*pRole))
                goto Error;
            *pdwQueryType |= WMIQ_ASSOCQ_ROLE;
        }
        else if (wbem_wcsicmp(L"RESULTROLE", Lexer.GetTokenText()) == 0)
        {
            if(*pResultRole)
                goto Error;
            if(*pdwQueryType & WMIQ_ASSOCQ_REFERENCES)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pResultRole = Macro_CloneLPWSTR(Lexer.GetTokenText());
            if (!(*pResultRole))
                goto Error;
            *pdwQueryType |= WMIQ_ASSOCQ_RESULTROLE;
        }
        else if (wbem_wcsicmp(L"ASSOCCLASS", Lexer.GetTokenText()) == 0)
        {
            if(*pAssocClass)
                goto Error;
            if(*pdwQueryType & WMIQ_ASSOCQ_REFERENCES)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pAssocClass = Macro_CloneLPWSTR(Lexer.GetTokenText());
            if (!(*pAssocClass))
                goto Error;
            *pdwQueryType |= WMIQ_ASSOCQ_ASSOCCLASS;
        }
        else if (wbem_wcsicmp(L"REQUIREDQUALIFIER", Lexer.GetTokenText()) == 0)
        {
            if(*pRequiredQualifier)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pRequiredQualifier = Macro_CloneLPWSTR(Lexer.GetTokenText());
            if (!(*pRequiredQualifier))
                goto Error;
            *pdwQueryType |= WMIQ_ASSOCQ_REQUIREDQUALIFIER;
        }
        else if (wbem_wcsicmp(L"REQUIREDASSOCQUALIFIER", Lexer.GetTokenText()) == 0)
        {
            if(*pRequiredAssocQualifier)
                goto Error;
            if(*pdwQueryType & WMIQ_ASSOCQ_REFERENCES)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pRequiredAssocQualifier = Macro_CloneLPWSTR(Lexer.GetTokenText());
            if (!(*pRequiredAssocQualifier))
                goto Error;
            *pdwQueryType |= WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER;
        }
        else if (wbem_wcsicmp(L"CLASSDEFSONLY", Lexer.GetTokenText()) == 0)
        {
            *pdwQueryType |= WMIQ_ASSOCQ_CLASSDEFSONLY;
        }
        else if (wbem_wcsicmp(L"KEYSONLY", Lexer.GetTokenText()) == 0)
        {
            *pdwQueryType |= WMIQ_ASSOCQ_KEYSONLY;
        }
        else if (wbem_wcsicmp(L"SCHEMAONLY", Lexer.GetTokenText()) == 0)
        {
            *pdwQueryType |= WMIQ_ASSOCQ_SCHEMAONLY;
        }
        else if (wbem_wcsicmp(L"CLASSREFSONLY", Lexer.GetTokenText()) == 0)
        {
            *pdwQueryType |= WMIQ_ASSOCQ_CLASSREFSONLY;
        }

        else
        {
            goto Error;
        }
    }


Completed:
    if( (*pdwQueryType & WMIQ_ASSOCQ_SCHEMAONLY) &&
        (*pdwQueryType & WMIQ_ASSOCQ_CLASSDEFSONLY))
    {
        goto Error;
    }
    return  S_OK;

Error:
    delete *pTargetObj;
    delete *pResultClass;
    delete *pAssocClass;
    delete *pRole;
    delete *pResultRole;
    delete *pRequiredQualifier;
    delete *pRequiredAssocQualifier;

    *pTargetObj = 0;
    *pResultClass = 0;
    *pAssocClass = 0;
    *pRole = 0;
    *pResultRole = 0;
    *pdwQueryType = 0;
    *pRequiredQualifier = 0;
    *pRequiredAssocQualifier = 0;

    return WBEM_E_INVALID_QUERY;
}

//***************************************************************************
//
//***************************************************************************

CAssocQueryParser::CAssocQueryParser()
{
    m_uVersion = ASSOC_QUERY_VERSION;
    m_uFeatureMask = 0;
    m_uAnalysisType = WMIQ_ANALYSIS_ASSOC_QUERY;
    m_pPath = 0;

    m_pszPath = 0;
    m_pszQueryText = 0;
    m_pszResultClass = 0;
    m_pszAssocClass = 0;
    m_pszRole = 0;
    m_pszResultRole = 0;
    m_pszRequiredQualifier = 0;
    m_pszRequiredAssocQualifier = 0;
}

//***************************************************************************
//
//***************************************************************************

CAssocQueryParser::~CAssocQueryParser()
{
    delete m_pszPath;
    delete m_pszQueryText;
    delete m_pszResultClass;
    delete m_pszAssocClass;
    delete m_pszRole;
    delete m_pszResultRole;
    delete m_pszRequiredQualifier;
    delete m_pszRequiredAssocQualifier;

    if (m_pPath)
        m_pPath->Release();
}

//***************************************************************************
//
//***************************************************************************
HRESULT CAssocQueryParser::Parse(LPCWSTR pszQuery)
{
    if (pszQuery == NULL)
        return WBEM_E_INVALID_QUERY;

    // Clone the query text for debugging.
    // ===================================
    int nLen = wcslen(pszQuery) + 1;
    m_pszQueryText = new wchar_t[nLen];
    if (m_pszQueryText == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(m_pszQueryText,nLen, pszQuery);

    // Parse it.
    // =========

    HRESULT res = ParseAssocQuery(
        m_pszQueryText,
        &m_pszPath,
        &m_pszResultClass,
        &m_pszAssocClass,
        &m_pszRole,
        &m_pszResultRole,
        &m_pszRequiredQualifier,
        &m_pszRequiredAssocQualifier,
        &m_uFeatureMask
        );

    if ( FAILED(res))
        return res;

    // Parse the object path.
    // ======================

    if (m_pszPath)
    {
    	HRESULT hRes= CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER, IID_IWbemPath, (LPVOID *) &m_pPath);
        if (FAILED(hRes))
            return WBEM_E_FAILED;
        hRes = m_pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, m_pszPath);
        if (FAILED(hRes))
            return WBEM_E_FAILED;
    }
    else
        return WBEM_E_INVALID_QUERY;

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\assocqp.h ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    ASSOCQP.H

Abstract:

    WQL association query parser

History:

    raymcc   04-Jul-99   Created.
    raymcc   14-Aug-99   Resubmit due to VSS problem.

--*/

#ifndef _ASSOCQP_H_
#define _ASSOCQP_H_


class CAssocQueryParser : public SWbemAssocQueryInf
{

public:
    CAssocQueryParser();
   ~CAssocQueryParser();

    HRESULT Parse(LPCWSTR Query);
        // Parses both query and target object path.
        // Returns:
        //      WBEM_E_INVALID_QUERY on syntax error
        //      WBEM_E_INVALID_OBJECT_PATH if the object
        //          path is syntactically invalid.
        //      WBEM_E_OUT_OF_MEMORY
        //      WBEM_S_NO_ERROR

    LPCWSTR GetQueryText() { return m_pszQueryText; }
    LPCWSTR GetTargetObjPath() { return m_pszPath; }
    LPCWSTR GetResultClass() { return m_pszResultClass; }
    LPCWSTR GetAssocClass() { return m_pszAssocClass; }
    LPCWSTR GetRole() { return m_pszRole; }
    LPCWSTR GetResultRole() { return m_pszResultRole; }
    LPCWSTR GetRequiredQual() { return m_pszRequiredQualifier; }
    LPCWSTR GetRequiredAssocQual() { return m_pszRequiredAssocQualifier; }
    DWORD   GetQueryType() { return m_uFeatureMask; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\helpers.h ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    helpers.h

Abstract:

    Generic helper code

History:

--*/

#ifndef _HELPERS_H_

#include <genutils.h>

#define LENGTH_OF(a) (sizeof(a)/sizeof(a[0]))

#ifndef _DBG_ASSERT
  #ifdef DBG
    #define _DBG_ASSERT(X) { if (!(X)) { DebugBreak(); } }
  #else
    #define _DBG_ASSERT(X)
  #endif
#endif


inline wchar_t *Macro_CloneLPWSTR(LPCWSTR src)
{
    if (NULL == src) return 0;
    size_t cchTmp = wcslen(src) + 1;
    wchar_t *dest = new wchar_t[cchTmp];
    if (dest) memcpy(dest,src,cchTmp * sizeof(WCHAR));
    return dest;
}

template<class T>
class CDeleteMe
{
protected:
    T* m_p;

public:
    CDeleteMe(T* p) : m_p(p){}
    ~CDeleteMe() {delete m_p;}
};

class CSysFreeMe
{
protected:
    BSTR m_str;

public:
    CSysFreeMe(BSTR str) : m_str(str){}
    ~CSysFreeMe() {SysFreeString(m_str);}
};


typedef LPVOID * PPVOID;

template<class TObj>
class CGenFactory : public IClassFactory
    {
    protected:
        long           m_cRef;
    public:
        CGenFactory(void)
        {
            m_cRef=0L;
            return;
        };

        ~CGenFactory(void)
        {
            return;
        }

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
        {
            *ppv=NULL;

            if (IID_IUnknown==riid || IID_IClassFactory==riid)
                *ppv=this;

            if (NULL!=*ppv)
            {
                ((LPUNKNOWN)*ppv)->AddRef();
                return NOERROR;
            }

            return ResultFromScode(E_NOINTERFACE);
        };

        STDMETHODIMP_(ULONG) AddRef(void)
        {
            return InterlockedIncrement(&m_cRef);
        };
        STDMETHODIMP_(ULONG) Release(void)
        {
            long lRet = InterlockedDecrement(&m_cRef);
            if (0 ==lRet)
                delete this;
            return lRet;
        };

        //IClassFactory members
        STDMETHODIMP         CreateInstance(IN LPUNKNOWN pUnkOuter, IN REFIID riid, OUT PPVOID ppvObj)
        {
            HRESULT    hr;

            *ppvObj=NULL;
            hr=E_OUTOFMEMORY;

            // This object doesnt support aggregation.

            if (NULL!=pUnkOuter)
                return ResultFromScode(CLASS_E_NOAGGREGATION);

            //Create the object passing function to notify on destruction.

            TObj * pObj = new TObj();

            if (NULL==pObj)
                return hr;

            // Setup the class all empty, etc.

            pObj->InitEmpty();
            hr=pObj->QueryInterface(riid, ppvObj);
            pObj->Release();
            return hr;
            
        };
        STDMETHODIMP         LockServer(BOOL fLock)
        {
            if (fLock)
                InterlockedIncrement((long *)&g_cLock);
            else
                InterlockedDecrement((long *)&g_cLock);
            return NOERROR;
        };
    };
class CReleaseMe
{
protected:
    IUnknown* m_pUnk;

public:
    CReleaseMe(IUnknown* pUnk) : m_pUnk(pUnk){}
    ~CReleaseMe() { release();}
    void release() { if(m_pUnk) m_pUnk->Release(); m_pUnk=0;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\localloc.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\like.h ===
//***************************************************************************
//
//   (c) 2000 by Microsoft Corp. All Rights Reserved.
//
//   like.h
//
//   a-davcoo     28-Feb-00       Implements the SQL like operation.
//
//***************************************************************************

#ifndef _LIKE_H_
#define _LIKE_H_


#include <string.h>


// The CLike class implements the SQL "like" operation.  To compare test strings
// to an expression, construct an instance of the CLike class using the expression
// and an optional escape character.  Then use the Match() method on that instance
// to test each string.  Note, this class makes it's own copy of the expression
// used to construct it.  This implementation supports the '%' and '_' wildard
// characters as well as the [] and [^] constructs for matching sets of characters
// and ranges of characters.
class CLike
{
	public:
		CLike (LPCWSTR expression, WCHAR escape='\0');
		~CLike (void);

		bool Match (LPCWSTR string);

	protected:
		LPWSTR m_expression;
		WCHAR m_escape;

		// Recursive function and helpers for performing like operation.
		bool DoLike (LPCWSTR pattern, LPCWSTR string, WCHAR escape);
		bool MatchSet (LPCWSTR pattern, LPCWSTR string, int &skip);
};


#endif // _LIKE_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\like.cpp ===
//***************************************************************************
//
//   (c) 2000 by Microsoft Corp. All Rights Reserved.
//
//   like.cpp
//
//   a-davcoo     28-Feb-00       Implements the SQL like operation.
//
//***************************************************************************


#include "precomp.h"
#include "like.h"


#define WILDCARD		L'%'
#define ANYSINGLECHAR	L'_'


CLike::CLike (LPCWSTR expression, WCHAR escape)
{
    size_t cchTmp = wcslen(expression)+1;
	m_expression = new WCHAR[cchTmp];
    if(m_expression)
	    StringCchCopyW(m_expression,cchTmp, expression);
	m_escape=escape;
}


CLike::~CLike (void)
{
	delete [] m_expression;
}


bool CLike::Match (LPCWSTR string)
{
    // m_expression might be NULL in out-of-memory
	return DoLike (m_expression, string, m_escape);
}


bool CLike::DoLike (LPCWSTR pattern, LPCWSTR string, WCHAR escape)
{
    // pattern might be NULL in out-of-memory
    if(pattern == NULL)
        return false;

	bool like=false;
	while (!like && *pattern && *string)
	{
		// Wildcard match.
		if (*pattern==WILDCARD)
		{
			pattern++;

			do
			{
				like=DoLike (pattern, string, escape);
				if (!like) string++;
			}
			while (*string && !like);
		}
		// Set match.
		else if (*pattern=='[')
		{
			int skip;
			if (MatchSet (pattern, string, skip))
			{
				pattern+=skip;
				string++;
			}
			else
			{
				break;
			}
		}
		// Single character match.
		else
		{
			if (escape!='\0' && *pattern==escape) pattern++;
			if (towupper(*pattern)==towupper(*string) || *pattern==ANYSINGLECHAR)
			{
				pattern++;
				string++;
			}
			else
			{
				break;
			}
		}
	}

	// Skip any trailing wildcard characters.
	while (*pattern==WILDCARD) pattern++;

	// It's a match if we reached the end of both strings, or a recursion 
	// succeeded.
	return (!(*pattern) && !(*string)) || like;
}


bool CLike::MatchSet (LPCWSTR pattern, LPCWSTR string, int &skip)
{
	// Skip the opening '['.
	LPCWSTR pos=pattern+1;

	// See if we are matching a [^] set.
	bool notinset=(*pos=='^');
	if (notinset) pos++;

	// See if the target character matches any character in the set.
	bool matched=false;
	WCHAR lastchar='\0';
	while (*pos && *pos!=']' && !matched)
	{
		// A range of characters is indicated by a '-' unless it's the first
		// character in the set (in which case it's just a character to be
		// matched.
		if (*pos=='-' && lastchar!='\0')
		{
			pos++;
			if (*pos && *pos!=']')
			{
				matched=(towupper(*string)>=lastchar && towupper(*string)<=towupper(*pos));
				lastchar=towupper(*pos);
				pos++;
			}
		}
		else
		{
			// Match a normal character in the set.
			lastchar=towupper(*pos);
			matched=(towupper(*pos)==towupper(*string));
			if (!matched) pos++;
		}
	}

	// Skip the trailing ']'.  If the set did not contain a closing ']'
	// we return a failed match.
	while (*pos && *pos!=']') pos++;
	if (*pos==']') pos++;
	if (!*pos) matched=false;

	// Done.
	skip=(int)(pos-pattern);
	return matched==!notinset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\opathlex2.h ===
/*++



// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    OPATHLEX2.H

Abstract:

    Object Path DFA Tokens

History:

--*/

#ifndef _OPATHLEX_H_

#define OPATH_TOK_EOF       0
#define OPATH_TOK_ERROR     1

#define OPATH_TOK_IDENT         100
#define OPATH_TOK_QSTRING       101
#define OPATH_TOK_INT           102
#define OPATH_TOK_HEXINT        103
#define OPATH_TOK_EQ            104

#define OPATH_TOK_DOT           105
#define OPATH_TOK_OPEN_PAREN    106
#define OPATH_TOK_CLOSE_PAREN   107
#define OPATH_TOK_SINGLETON_SYM 108
#define OPATH_TOK_COMMA         109

#define OPATH_TOK_BACKSLASH     110
#define OPATH_TOK_COLON         111
#define OPATH_TOK_REFERENCE     112

#define OPATH_SINGLETON_STRING  L"@"

extern LexEl OPath_LexTable2[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\precomp.h ===
/*++

Copyright (C) 1999-2002 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

History:

--*/
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#include <comdef.h>
#include <strsafe.h>

#include <helper.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\maindll.cpp ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    MAINDLL.CPP

Abstract:

    Contains DLL Entrypoints

History:

--*/

#include "precomp.h"
#include <wbemcli.h>
#include "pathparse.h"
#include "wbemerror.h"

#include <wmiutils.h>
#include <wbemint.h>
#include "genlex.h"
#include "assocqp.h"
#include "ql.h"
#include "wmiquery.h"
#include "statsync.h"

#include "helpers.h"
HINSTANCE g_hInstance;
long g_cLock;
long g_cObj;

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain(
                        IN HINSTANCE hInstance,
                        IN ULONG ulReason,
                        LPVOID pvReserved)
{
    if (DLL_PROCESS_DETACH == ulReason)
    {
        CWmiQuery::Shutdown();
    }
    else if (DLL_PROCESS_ATTACH == ulReason)
    {
        g_hInstance = hInstance;
	DisableThreadLibraryCalls ( hInstance ) ;

        CWmiQuery::Startup();

        if (CStaticCritSec::anyFailure())
        	return FALSE;
    }

    return TRUE;
}


//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//
//***************************************************************************

STDAPI DllGetClassObject(
                        IN REFCLSID rclsid,
                        IN REFIID riid,
                        OUT PPVOID ppv)
{
    HRESULT hr = WBEM_E_FAILED;

    IClassFactory * pFactory = NULL;
    if (CLSID_WbemDefPath == rclsid)
        pFactory = new CGenFactory<CDefPathParser>();
    else if (CLSID_WbemStatusCodeText == rclsid)
        pFactory = new CGenFactory<CWbemError>();

    else if (CLSID_WbemQuery == rclsid)
		pFactory = new CGenFactory<CWmiQuery>();

    if(pFactory == NULL)
        return E_FAIL;
    hr=pFactory->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pFactory;

    return hr;
}


//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;
    HRESULT hRes = CWmiQuery::CanUnload();

    if (hRes == S_FALSE)
        return S_FALSE;

    // It is OK to unload if there are no objects or locks on the
    // class factory.

    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;


    return ResultFromScode(sc);
}
POLARITY void RegisterUtilsDLL(IN HMODULE hModule, IN GUID guid, IN TCHAR * pDesc, TCHAR * pModel,
            TCHAR * pProgID)
{
    TCHAR      wcID[128];
    TCHAR      szCLSID[128];
    TCHAR      szModule[MAX_PATH+1];
    HKEY hKey1 = NULL;
    HKEY hKey2 = NULL;

    // Create the path.

    wchar_t strCLSID[128];
    if(0 ==StringFromGUID2(guid, strCLSID, 128)) return;
    StringCchCopyW(wcID,LENGTH_OF(wcID), strCLSID);
    
    StringCchCopy(szCLSID,LENGTH_OF(szCLSID), __TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    StringCchCat(szCLSID,LENGTH_OF(szCLSID), wcID);

    // Create entries under CLSID

    if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1)) return;
    OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm1(hKey1);    

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pDesc, (lstrlen(pDesc)+1) * sizeof(TCHAR));
    if(ERROR_SUCCESS != RegCreateKey(hKey1,__TEXT("InprocServer32"),&hKey2)) return;
    OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm2(hKey2);

    szModule[MAX_PATH] = L'0';
    if(0 == GetModuleFileName(hModule, szModule,  MAX_PATH)) return;

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule,
                                        (lstrlen(szModule)+1) * sizeof(TCHAR));
    RegSetValueEx(hKey2, __TEXT("ThreadingModel"), 0, REG_SZ,
                                       (BYTE *)pModel, (lstrlen(pModel)+1) * sizeof(TCHAR));

    // If there is a progid, then add it too
    if(pProgID)
    {
        HKEY hKey1In = NULL;
        HKEY hKey2In = NULL;

        // szModule used as storage here
        StringCchPrintf(szModule,LENGTH_OF(szModule), __TEXT("SOFTWARE\\CLASSES\\%s"), pProgID);
        
        if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, szModule, &hKey1In))
        {

            RegSetValueEx(hKey1In, NULL, 0, REG_SZ, (BYTE *)pDesc , (lstrlen(pDesc)+1) * sizeof(TCHAR));
            if(ERROR_SUCCESS == RegCreateKey(hKey1In,__TEXT("CLSID"),&hKey2In))
            {
                RegSetValueEx(hKey2In, NULL, 0, REG_SZ, (BYTE *)wcID,
                                        (lstrlen(wcID)+1) * sizeof(TCHAR));
                RegCloseKey(hKey2In);
                hKey2In = NULL;
            }
            RegCloseKey(hKey1In);
        }

    }
    return;
}

POLARITY void UnRegisterUtilsDLL(GUID guid, TCHAR * pProgID)
{
    TCHAR      wcID[128];
    TCHAR  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    wchar_t strCLSID[128];
    if(0 ==StringFromGUID2(guid, strCLSID, 128))
        return;

    StringCchCopyW(wcID,LENGTH_OF(wcID), strCLSID);

    StringCchCopy(szCLSID,LENGTH_OF(szCLSID), __TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    StringCchCat(szCLSID,LENGTH_OF(szCLSID), wcID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, __TEXT("InProcServer32"));
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\CLASSES\\CLSID"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,wcID);
        RegCloseKey(hKey);
    }

    if(pProgID)
    {
        HKEY hKey;

        StringCchCopy(szCLSID,LENGTH_OF(szCLSID), __TEXT("SOFTWARE\\CLASSES\\"));
        StringCchCat(szCLSID,LENGTH_OF(szCLSID), pProgID);
        
        DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
        if(dwRet == NO_ERROR)
        {
            RegDeleteKey(hKey, __TEXT("CLSID"));
            RegCloseKey(hKey);
        }
        RegDeleteKey(HKEY_LOCAL_MACHINE, szCLSID);

    }
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    RegisterUtilsDLL(g_hInstance, CLSID_WbemDefPath, __TEXT("WbemDefaultPathParser"), __TEXT("Both"), NULL);
    RegisterUtilsDLL(g_hInstance, CLSID_WbemStatusCodeText, __TEXT("WbemStatusCode"), __TEXT("Both"), NULL);
    RegisterUtilsDLL(g_hInstance, CLSID_WbemQuery, __TEXT("WbemQuery"), __TEXT("Both"), NULL);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    UnRegisterUtilsDLL(CLSID_WbemDefPath,NULL);
    UnRegisterUtilsDLL(CLSID_WbemStatusCodeText,NULL);
    UnRegisterUtilsDLL(CLSID_WbemQuery,NULL);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\opathlex2.cpp ===
/*++



// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

  OPATHLEX2.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  24-Jun-95       Created.
  14-Apr-98       Radical update for singly quoted strings, remove
                  unused tokens, add hex constants, etc.

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <opathlex2.h>             


#define ST_IDENT            24
#define ST_NUMERIC          30
#define ST_DECIMAL          32
#define ST_HEX              34
#define ST_SQ_STRING        38
#define ST_DQ_STRING        42
#define ST_DQ_STRING_ESC    45
#define ST_REFERENCE        48
#define ST_REFERENCE_ESC    51



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable2[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,
/* 21 */ L'{',   GLEX_EMPTY, ST_REFERENCE, 0,               GLEX_ACCEPT,
/* 22 */ L'{',   GLEX_EMPTY, ST_REFERENCE, 0,               GLEX_ACCEPT,    // Actually reserved for next new

    // All remaining unknown characters

/* 23 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

//TODO


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 24 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 27 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 28 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 29 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 30 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 31 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 32 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 33 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 34 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 36 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 37 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 38 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 39 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 40 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 41 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 42 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 43 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 44 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 45  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 46  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 47  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_DQ_REFERENCE
    //
    // A reference begins with '{' and ends with '}'.  Embedded
    // '}' are allowed if preceeded by '\':

/* 48 */   L'\\', GLEX_EMPTY, ST_REFERENCE_ESC, 0,                     GLEX_CONSUME,    // Escape
/* 49 */   L'}',  GLEX_EMPTY, 0,                OPATH_TOK_REFERENCE,   GLEX_ACCEPT,
/* 50 */   L'}',  GLEX_EMPTY, ST_REFERENCE,     0,                     GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_REFERENCE_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 51  */    L'\\', GLEX_EMPTY, ST_REFERENCE, 0,  GLEX_ACCEPT,
/* 52  */    L'}',  GLEX_EMPTY, ST_REFERENCE, 0,  GLEX_ACCEPT,
/* 53  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\resource.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    RESOURCE,H

Abstract:

	Resource definitions

History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by common.rc
//
#define IDS_FAC_WBEM                    450
#define IDS_FAC_ITF                     451
#define IDS_FAC_NULL                    452
#define IDS_FAC_RPC                     453
#define IDS_FAC_STORAGE                 454
#define IDS_FAC_DISPATCH                455
#define IDS_FAC_WIN32                   456
#define IDS_FAC_WINDOWS                 457
#define IDS_FAC_SSPI                    458
#define IDS_FAC_CONTROL                 459
#define IDS_FAC_CERT                    460
#define IDS_FAC_INET                    461
#define IDS_FAC_UNKNOWN                 462
#define IDS_SUBSYS                      463

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\pathparse.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PathParse.H

Abstract:

    Implements the default object path parser.

History:

    a-davj  5-feb-00       Created.

--*/

#ifndef _PATHPARSE_H_
#define _PATHPARSE_H_

#include "genlex.h"
#include <wmiutils.h>
#include <umi.h>
#include "wbemcli.h"
#include "flexarry.h"
typedef LPVOID * PPVOID;


class CSafeInCritSec : public  CInCritSec
{
public:
	CSafeInCritSec(CRITICAL_SECTION * pcs):CInCritSec(pcs){};
	~CSafeInCritSec(){};
    BOOL IsOK(){return true;};    
};


class CRefCntCS
{
private:
    long m_lRef;
    CRITICAL_SECTION m_cs;
    HRESULT m_Status;

public:
    CRefCntCS();
    ~CRefCntCS()
    {
        if(m_Status == S_OK)
            DeleteCriticalSection(&m_cs);
    }
    HRESULT GetStatus(){return m_Status;};
    long AddRef(void){long lRef = InterlockedIncrement(&m_lRef);return lRef;};
    long Release(void);
    CRITICAL_SECTION * GetCS(){return &m_cs;};
};


//***************************************************************************
//
//  STRUCT NAME:
//
//  CKeyRef
//
//  DESCRIPTION:
//
//  Holds information for a single key.  Includes name, data, and data type.
//
//***************************************************************************

struct CKeyRef
{
    LPWSTR  m_pName;
    DWORD m_dwType;
    DWORD m_dwSize;
    void * m_pData;

    CKeyRef();
    CKeyRef(LPCWSTR wszKeyName, DWORD dwType, DWORD dwSize, void * pData);
    HRESULT SetData(DWORD dwType, DWORD dwSize, void * pData);
   ~CKeyRef();

    // note that the caller is to free the returned string.
    LPWSTR GetValue(BOOL bQuotes=TRUE);
   
    DWORD GetValueSize();
    DWORD GetTotalSize();
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CParsedComponent
//
//  DESCRIPTION:
//
//  Each namespace, scope and the class is represented by an instance of this.  It holds 
//  an array of CKeyRef objects and supports the IWbemPathKeyList interface.
//
//***************************************************************************

class  CParsedComponent : public IWbemPathKeyList
{
public:
    CParsedComponent(CRefCntCS *);
    ~CParsedComponent();
	friend class CDefPathParser;
	friend class CUmiPathParser;
	void ClearKeys ();
    HRESULT GetName(BSTR *pName);
    HRESULT Unparse(BSTR *pKey, bool bGetQuotes, bool bUseClassName);
    HRESULT GetComponentType(DWORD &dwType);
    BOOL AddKeyRef(CKeyRef* pAcquireRef);
	bool IsPossibleNamespace();
    bool IsInstance();
	HRESULT SetNS(LPCWSTR pName);

    //IUnknown members

    STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
    {
        *ppv=NULL;

        if (IID_IUnknown==riid || IID_IWbemPathKeyList==riid)
            *ppv=this;
        else if (riid == IID_IMarshal && m_pFTM)
            return m_pFTM->QueryInterface(riid, ppv);
//postponed till Blackcomb        if (IID_IUmiURLKeyList==riid)
//postponed till Blackcomb			*ppv = &m_UmiWrapper;

        if (NULL!=*ppv)
        {
            AddRef();
            return NOERROR;
        }

        return E_NOINTERFACE;
    };

    STDMETHODIMP_(ULONG) AddRef(void)
    {    
        return InterlockedIncrement(&m_cRef);
    };
    STDMETHODIMP_(ULONG) Release(void)
    {
        long lRef = InterlockedDecrement(&m_cRef);
        if (0L == lRef)
            delete this;
        return lRef;
    };

    HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *puKeyCount);
        
    HRESULT STDMETHODCALLTYPE SetKey( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ LPVOID pKeyVal);

    HRESULT STDMETHODCALLTYPE SetKey2( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ VARIANT __RPC_FAR *pKeyVal);

    HRESULT STDMETHODCALLTYPE GetKey( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puKeyValBufSize,
            /* [out][in] */ LPVOID pKeyVal,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType);
        
    HRESULT STDMETHODCALLTYPE GetKey2( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ VARIANT __RPC_FAR *pKeyValue,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType);

    HRESULT STDMETHODCALLTYPE RemoveKey( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags);

    HRESULT STDMETHODCALLTYPE RemoveAllKeys( 
            /* [in] */ ULONG uFlags);
        
    HRESULT STDMETHODCALLTYPE MakeSingleton( boolean bSet);
        
    HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);

	HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out] */ LPWSTR pszText);


private:

    BSTR        m_sClassName;
    CFlexArray  m_Keys;
    bool        m_bSingleton;
    long        m_cRef;
    CRefCntCS * m_pCS;
    IUnknown * m_pFTM;

};



//***************************************************************************
//
//  CLASS NAME:
//
//  CDefPathParser
//
//  DESCRIPTION:
//
//  Provides the default wmi path parser.
//
//***************************************************************************

class CDefPathParser : public IWbemPath
{
    public:
        CDefPathParser(void);
        ~CDefPathParser(void);
		DWORD GetNumComponents();
		bool IsEmpty(void);
		long GetNumNamespaces();
		void Empty(void);
        enum Status {UNINITIALIZED, BAD_STRING, EXECEPTION_THROWN, OK, FAILED_TO_INIT};
        BOOL ActualRelativeTest(LPWSTR wszMachine,
                               LPWSTR wszNamespace,
                               BOOL bChildrenOK);
        void InitEmpty(){};

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
        {
            *ppv=NULL;

            if(m_dwStatus == FAILED_TO_INIT)
                return WBEM_E_OUT_OF_MEMORY;
            if(m_pCS == NULL)
                return E_NOINTERFACE;
            if (IID_IUnknown==riid || IID_IWbemPath==riid)
                *ppv=(IWbemPath *)this;
            else if (riid == IID_IMarshal && m_pFTM)
                return m_pFTM->QueryInterface(riid, ppv);
            if (NULL!=*ppv)
            {
                AddRef();
                return NOERROR;
            }

            return E_NOINTERFACE;
        };

        STDMETHODIMP_(ULONG) AddRef(void)
        {    
            return InterlockedIncrement(&m_cRef);
        };
        STDMETHODIMP_(ULONG) Release(void)
        {
            long lRef = InterlockedDecrement(&m_cRef);
            if (0L == lRef)
                delete this;
            return lRef;
        };

        virtual HRESULT STDMETHODCALLTYPE SetText( 
            /* [in] */ ULONG uMode,
            /* [in] */ LPCWSTR pszPath);
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out] */ LPWSTR pszText);

        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
         
        virtual HRESULT STDMETHODCALLTYPE SetServer( 
            /* [string][in] */ LPCWSTR Name);
        
        virtual HRESULT STDMETHODCALLTYPE GetServer( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out] */ LPWSTR pName);
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaceCount( 
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        virtual HRESULT STDMETHODCALLTYPE SetNamespaceAt( 
            /* [in] */ ULONG uIndex,
            /* [string][in] */ LPCWSTR pszName);

        virtual HRESULT STDMETHODCALLTYPE GetNamespaceAt( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out] */ LPWSTR pName);

        virtual HRESULT STDMETHODCALLTYPE RemoveNamespaceAt( 
            /* [in] */ ULONG uIndex);

		virtual HRESULT STDMETHODCALLTYPE RemoveAllNamespaces( void);
        
        virtual HRESULT STDMETHODCALLTYPE GetScopeCount( 
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        virtual HRESULT STDMETHODCALLTYPE SetScope(
            unsigned long,unsigned short *);

        virtual HRESULT STDMETHODCALLTYPE SetScopeFromText( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText);
        
        virtual HRESULT STDMETHODCALLTYPE GetScope( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [in] */ LPWSTR pszClass,
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pKeyList);

        virtual HRESULT STDMETHODCALLTYPE GetScopeAsText( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText);
        
        virtual HRESULT STDMETHODCALLTYPE RemoveScope( 
            /* [in] */ ULONG uIndex);

		virtual HRESULT STDMETHODCALLTYPE RemoveAllScopes( void);

        virtual HRESULT STDMETHODCALLTYPE SetClassName( 
            /* [string][in] */ LPCWSTR Name);
        
        virtual HRESULT STDMETHODCALLTYPE GetClassName( 
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out] */ LPWSTR pszName);
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyList( 
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pOut);

		virtual HRESULT STDMETHODCALLTYPE CreateClassPart( 
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClassPart( 
            /* [in] */ long lFlags);

        virtual BOOL STDMETHODCALLTYPE IsRelative( 
            /* [string][in] */ LPWSTR wszMachine,
            /* [string][in] */ LPWSTR wszNamespace);
        
        virtual BOOL STDMETHODCALLTYPE IsRelativeOrChild( 
            /* [string][in] */ LPWSTR wszMachine,
            /* [string][in] */ LPWSTR wszNamespace,
            /* [in] */ long lFlags);

        virtual BOOL STDMETHODCALLTYPE IsLocal( 
            /* [string][in] */ LPCWSTR wszMachine);

        virtual BOOL STDMETHODCALLTYPE IsSameClassName( 
            /* [string][in] */ LPCWSTR wszClass);


		HRESULT SetServer(LPCWSTR Name, bool m_bServerNameSetByDefault, bool bAcquire);
        BOOL HasServer(){return m_pServer != NULL;};
        LPWSTR GetPath(DWORD nStartAt, DWORD nStopAt,bool bGetServer = false);
        BOOL AddNamespace(LPCWSTR wszNamespace);
        BOOL AddClass(LPCWSTR lpClassName);
        BOOL AddKeyRef(CKeyRef* pAcquireRef);
        BOOL SetSingletonObj();
        LPWSTR GetNamespacePart(); 
	    LPWSTR GetParentNamespacePart(); 
        BOOL SortKeys();
		CParsedComponent * GetLastComponent();
		HRESULT GetComponentString(ULONG Index, BSTR * pUnparsed, WCHAR & wDelim);
		HRESULT AddComponent(CParsedComponent * pComp);
		CParsedComponent * GetClass();
        CRefCntCS * GetRefCntCS(){return m_pCS;};
        void * m_pGenLex;               // for test purposes only

    protected:
		bool		m_bSetViaUMIPath;
        long        m_cRef;
        LPWSTR      m_pServer;           // NULL if no server
		CFlexArray  m_Components;        // list of namespaces and scopes
//		CParsedComponent * m_pClass;  // the class
        DWORD       m_dwStatus;
		bool		m_bParent;			 // true if text is ".."
		LPWSTR	m_pRawPath;				// temporary fix for Raja
        CRefCntCS * m_pCS;
        LPWSTR m_wszOriginalPath;
		bool   m_bServerNameSetByDefault;
        IUnknown * m_pFTM;
        DWORD m_dwException;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\pathparse.cpp ===
/*++



// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    PathParse.CPP

Abstract:

    Implements the default object path parser/

History:

    a-davj  6-feb-00       Created.

--*/

#include "precomp.h"
#include <genlex.h>
#include <string.h>
#include "PathParse.h"
#include "ActualParse.h"
#include "commain.h"
#include "wbemcli.h"
#include <stdio.h>
#include <sync.h>
#include "helpers.h"

extern long g_cObj;

#ifndef STATUS_NO_MEMORY 
#define STATUS_NO_MEMORY                 ((DWORD)0xC0000017L)    // winnt
#endif

CRefCntCS::CRefCntCS() 
{
    m_lRef = 1; 
    m_Status = S_OK;
    __try
    {
        InitializeCriticalSection(&m_cs);
                
    } 
    __except ((STATUS_NO_MEMORY == GetExceptionCode())?EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
   	{
    	m_Status = WBEM_E_OUT_OF_MEMORY;
    }
}

long CRefCntCS::Release()
{
    long lRet = InterlockedDecrement(&m_lRef);
    if(lRet == 0)
        delete this;
    return lRet;
}

bool Equal(LPCWSTR first, LPCWSTR second, DWORD dwLen)
{
	if(first == NULL || second == NULL)
		return false;
	if(wcslen(first) < dwLen || wcslen(second) < dwLen)
		return false;
	for (DWORD dwCnt = 0; dwCnt < dwLen; dwCnt++, first++, second++)
	{
		if(towupper(*first) != towupper(*second))
			return false;
	}
	return true;
}

/*++

Routine Description:

  Determines the number of bytes needed to store data

Arguments:

  uCimType	- Cim type
  pKyeValue - pointer to data to be stored

Return Value:

  Number of bytes.  0 if an error
--*/

DWORD GetCIMSize(DWORD uCimType, void * pKeyVal)
{
    DWORD dwRet = 0;
    switch(uCimType)
    {
        case CIM_STRING:
        case CIM_REFERENCE:
        case CIM_DATETIME:
            dwRet = 2 * (wcslen((WCHAR *)pKeyVal) + 1);
            break;
        case CIM_UINT8:
        case CIM_SINT8:
            dwRet = 1;
            break;
        case CIM_SINT16:
        case CIM_UINT16:
        case CIM_CHAR16:
            dwRet = 2;
            break;
        case CIM_SINT32:
        case CIM_UINT32:
        case CIM_BOOLEAN:
            dwRet = 4;
            break;
        case CIM_SINT64:
        case CIM_UINT64:
            dwRet = 8;
            break;
    }
    return dwRet;
}

//***************************************************************************
//
//  CKeyRef Class.  Used to store a key name/value pair
//
//***************************************************************************

/*++

Routine Description:

  Default Constructor.

--*/

CKeyRef::CKeyRef()
{
    m_pName = 0;
    m_dwType = CIM_EMPTY;
    m_dwSize = 0;
    m_pData = NULL;
}

/*++

Routine Description:

  Constructor.

Arguments:

  wszKeyName	- name
  dwType		- cim type
  dwSize		- data size
  pData			- actual data
	
--*/

CKeyRef::CKeyRef(LPCWSTR wszKeyName, DWORD dwType, DWORD dwSize, void * pData)
{
    if(wszKeyName)
        m_pName = Macro_CloneLPWSTR(wszKeyName);
    else
        m_pName = NULL;
    m_pData = NULL;
    SetData(dwType, dwSize, pData);
}

/*++

Routine Description:

  Sets the data for a CKeyRef object.  Frees any existing data.

Arguments:

  dwType		- cim type
  dwSize		- data size
  pData			- actual data

Return Value:

  S_OK if all is well.
  WBEM_E_INVALID_PARAMETER if bad arg
  WBEM_E_OUT_OF_MEMORY if low memory problem

--*/

HRESULT CKeyRef::SetData(DWORD dwType, DWORD dwSize, void * pData)
{
    if(m_pData)
        delete m_pData;
    m_pData = NULL;
    m_dwType = CIM_EMPTY;
    m_dwSize = 0;
    if(dwSize && pData && GetCIMSize(dwType, pData))
    {
        m_pData = new byte[dwSize];
        if(m_pData)
        {
            m_dwType = dwType;
			m_dwSize = dwSize;
            memcpy(m_pData, pData, dwSize);
            return S_OK;
        }
        return WBEM_E_OUT_OF_MEMORY;
    }
    else
        return WBEM_E_INVALID_PARAMETER;
}

/*++

Routine Description:

  Destructor.
	
--*/

CKeyRef::~CKeyRef()
{
    if (m_pName)
        delete m_pName;

    if (m_pData)
        delete m_pData;
}


/*++

Routine Description:

  provide an estimate of how large the value could be once converted to 
  a character string.

Return Value:

  Limit on how many bytes are needed.
  
--*/



DWORD CKeyRef::GetValueSize()
{
	if(m_dwType == CIM_STRING || m_dwType == CIM_REFERENCE || m_dwType == CIM_DATETIME)
		return m_dwSize * 2 + 2;
	else if(m_dwSize == 8)
		return 21;
	else
		return 14;
}

/*++

Routine Description:

  Returns estimate of how large the key/value pair may be.

--*/

DWORD CKeyRef::GetTotalSize()
{
    DWORD dwSize = GetValueSize();
    if (m_pName)
        dwSize += wcslen(m_pName) +1;
    return dwSize;
}

/*++

Routine Description:

  Returns the value as text.

Arguments:

  bQuotes	- If true, the strings are enclosed in quotes

Return Value:

  Pointer to string.  Caller must free via delete.  NULL if error.

--*/

LPWSTR CKeyRef::GetValue(BOOL bQuotes)
{
    LPWSTR lpKey = NULL;
    DWORD dwSize, dwCnt;
    WCHAR * pFr, * pTo;
	unsigned __int64 * pull;
    pFr = (WCHAR *)m_pData;

    // For string, the size may need to be increaed for quotes

    if(m_dwType == CIM_STRING || m_dwType == CIM_REFERENCE)
    {
        dwSize = m_dwSize;
        if(bQuotes)
            dwSize+= 2;
    }
    else
        dwSize = 32;
    lpKey = new WCHAR[dwSize];
	if(lpKey == NULL)
		return NULL;

    switch(m_dwType)
    {
      case CIM_STRING:
      case CIM_REFERENCE:
        pTo = lpKey;
        if (bQuotes && m_dwType == CIM_STRING)
        {
            *pTo = '"';
            pTo++;
        }
        for(dwCnt = 0; dwCnt < m_dwSize && *pFr; dwCnt++, pFr++, pTo++)
        {
            if(*pFr == '\\' || *pFr == '"')
            {
                *pTo = '\\';
                pTo++;
            }

           *pTo = *pFr;
        }
        if (bQuotes && m_dwType == CIM_STRING)
        {
            *pTo = '"';
            pTo++;
        }
        *pTo = 0;
        break;
      case CIM_SINT32:
        StringCchPrintfW(lpKey,dwSize, L"%d", *(int *)m_pData);
        break;
      case CIM_UINT32:
        StringCchPrintfW(lpKey,dwSize, L"%u", *(unsigned *)m_pData);
        break;
      case CIM_SINT16:
        StringCchPrintfW(lpKey,dwSize, L"%hd", *(signed short *)m_pData);
        break;
      case CIM_UINT16:
        StringCchPrintfW(lpKey,dwSize, L"%hu", *(unsigned short *)m_pData);
        break;
      case CIM_SINT8:
        StringCchPrintfW(lpKey,dwSize, L"%d", *(signed char *)m_pData);
        break;
      case CIM_UINT8:
        StringCchPrintfW(lpKey,dwSize, L"%u", *(unsigned char *)m_pData);
        break;
      case CIM_UINT64:
        StringCchPrintfW(lpKey,dwSize, L"%I64u", *(unsigned __int64 *)m_pData);
        break;
      case CIM_SINT64:
        StringCchPrintfW(lpKey,dwSize, L"%I64d", *(__int64 *)m_pData);
        break;
      case CIM_BOOLEAN:
        if(*(int *)m_pData == 0)
            StringCchCopyW(lpKey,dwSize,L"false");
        else
            StringCchCopyW(lpKey,dwSize,L"true");
        break;
      default:
          *lpKey = 0;
        break;            
    }

    return lpKey;
}



//***************************************************************************
//
//  CParsedComponent
//
//***************************************************************************

/*++

Routine Description:

	Constructor.

--*/

CParsedComponent::CParsedComponent(CRefCntCS * pCS)
{
	m_bSingleton = false;
	m_cRef = 1;
	m_sClassName = NULL;
    m_pCS = pCS;
    if(m_pCS)
        m_pCS->AddRef();
   //// m_UmiWrapper.Set(m_hMutex);
   	m_pFTM = NULL;
    CoCreateFreeThreadedMarshaler((IWbemPath*)this, &m_pFTM);

}

/*++

Routine Description:

  Destructor.

--*/

CParsedComponent::~CParsedComponent()
{
    if(m_pCS)
        m_pCS->Release();
    ClearKeys();
	if(m_sClassName)
		SysFreeString(m_sClassName);
    m_pCS = NULL;
    if(m_pFTM)
    	m_pFTM->Release();
    
}
      
/*++

Routine Description:

  Retrieves the call name.

Arguments:

  pName	- Where the name is to be copied.  Note that the call must free via SysFreeString

Return Value:

  S_OK if all is well, else error

--*/

HRESULT CParsedComponent::GetName(BSTR *pName)
{
    HRESULT hr = 0;
    if (pName == NULL || m_sClassName == NULL)
		return WBEM_E_INVALID_PARAMETER;

	*pName = SysAllocString(m_sClassName);
    if(*pName)
		return S_OK;
	else
		return WBEM_E_OUT_OF_MEMORY;
}

/*++

Routine Description:

  returns the class/key info in standard format.  Ex;   class="hello" or
  class.key1=23,key2=[reference]

Arguments:

  pOutputKey	-   Where the value is to be copied.  Must be freed by the
					caller.
Return Value:
	
  S_OK if all is well, else an error code

--*/

HRESULT CParsedComponent::Unparse(BSTR *pOutputKey, bool bGetQuotes, bool bUseClassName)
{
    HRESULT hr = 0;
    if (pOutputKey)
    {
        int nSpace = 0;
		if(m_sClassName && bUseClassName)
			nSpace += wcslen(m_sClassName);
        nSpace += 10;
        DWORD dwIx;
        for (dwIx = 0; dwIx < (DWORD)m_Keys.Size(); dwIx++)
        {
            CKeyRef* pKey = (CKeyRef*)m_Keys[dwIx];
            nSpace += pKey->GetTotalSize();
        }

        LPWSTR wszPath = new WCHAR[nSpace];
		if(wszPath == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		CDeleteMe<WCHAR> dm1(wszPath);
		wszPath[0] = 0;
		if(m_sClassName && bUseClassName)
			StringCchCopyW(wszPath,nSpace, (const wchar_t *)m_sClassName);

        if (m_bSingleton)
			if(bUseClassName)
				StringCchCatW(wszPath,nSpace, L"=@");
			else
				StringCchCatW(wszPath,nSpace, L"@");

        for (dwIx = 0; dwIx < (DWORD)m_Keys.Size(); dwIx++)
        {
            CKeyRef* pKey = (CKeyRef *)m_Keys[dwIx];

            // We dont want to put a '.' if there isnt a key name,
            // for example, Myclass="value"
            if(dwIx == 0)
            {
                if((pKey->m_pName && (0 < wcslen(pKey->m_pName))) || m_Keys.Size() > 1)
                    if(bUseClassName)
						StringCchCatW(wszPath,nSpace, L".");
            }
            else
            {
                StringCchCatW(wszPath,nSpace, L",");
            }
            if(pKey->m_pName)
			{
                StringCchCatW(wszPath,nSpace, pKey->m_pName);
			}
            LPWSTR lpTemp = pKey->GetValue(bGetQuotes);
            if(lpTemp)
			{
				if(wcslen(wszPath))
					StringCchCatW(wszPath,nSpace, L"=");
				StringCchCatW(wszPath,nSpace, lpTemp);
				delete lpTemp;
			}
        }

        *pOutputKey = SysAllocString(wszPath);
        if (!(*pOutputKey))
        	return WBEM_E_OUT_OF_MEMORY;
    }
    else
        hr = WBEM_E_INVALID_PARAMETER;
    return hr;
}


/*++

Routine Description:

  Gets the number of keys.

Arguments:

  puKeyCount	-	Where the result is to be put.

Return Value:

  S_OK if all is well, else an error code.

--*/

HRESULT CParsedComponent::GetCount( 
            /* [out] */ ULONG __RPC_FAR *puKeyCount)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(puKeyCount == NULL)
        return WBEM_E_INVALID_PARAMETER;
    *puKeyCount = m_Keys.Size();
	return S_OK;

}
        
/*++

Routine Description:

  Sets the name/value pair for a key.  If the key exists, then it is
  replace.  If the name is empty, then all existing keys are deleted.

Arguments:

  wszName	-	Key name.  May be NULL	
  uFlags	-	not used for now
  uCimType	-	data type
  pKeyVal	-	pointer to the data

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CParsedComponent::SetKey( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ LPVOID pKeyVal)
{

    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    DWORD dwCnt = 0;
    CKeyRef * pKey; 
	m_bSingleton = false;
    DWORD dwSize = GetCIMSize(uCimType, pKeyVal);
    if(uFlags || pKeyVal == NULL || dwSize == 0)
        return WBEM_E_INVALID_PARAMETER;

    // If the current list has just a single unnamed entry, the delete it.

    if(m_Keys.Size() == 1)
    {
        pKey = (CKeyRef *)m_Keys[dwCnt];
        if(pKey->m_pName == NULL || pKey->m_pName[0] == 0)
            ClearKeys();
    }

    if(wszName == NULL || wcslen(wszName) < 1)
    {
        // If new key has null name, delete all existing entries.
    
        ClearKeys();
    }
    else
    {
        // If new key has name, look for current entry of same name

        for(dwCnt = 0; dwCnt < (DWORD)m_Keys.Size(); dwCnt++)
        {
            pKey = (CKeyRef *)m_Keys[dwCnt];
            if(pKey->m_pName && !wbem_wcsicmp(pKey->m_pName, wszName))
                break;
        }
    }

    // If current entry of same name exists, replace it

    if(dwCnt < (DWORD)m_Keys.Size())
    {
        // If it exists, replace it
    
        pKey->SetData(uCimType, dwSize, pKeyVal);
    }
    else
    {
        // otherwise, new entry
        CKeyRef * pNew = new CKeyRef(wszName, uCimType, dwSize, pKeyVal);
        if(pNew)
            m_Keys.Add(pNew);
		else
			return WBEM_E_OUT_OF_MEMORY;
    }
    return S_OK;
}

/*++

Routine Description:

  Converts a simple vartype to the cim equivalent

Arguments:

  vt	-	simple vartype

Return Value:

  valid cimtype.  CIM_EMPTY is returned if there is an error.
	
--*/

DWORD CalcCimType(VARTYPE vt)
{
    switch (vt)
    {
    case VT_I2:
    case VT_I4:
    case VT_R4:
    case VT_R8:
    case VT_BSTR:
    case VT_BOOL:
    case VT_UI1:
        return vt;
    default:
        return  CIM_EMPTY;
    }
}

/*++

Routine Description:

  Sets the name/value pair for a key.  If the key exists, then it is
  replace.  If the name is empty, then all existing keys are deleted.

Arguments:

  wszName	-	Key name.  May be NULL	
  uFlags	-	not used for now
  uCimType	-	data type
  pKeyVal	-	pointer to the data

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CParsedComponent::SetKey2( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCimType,
            /* [in] */ VARIANT __RPC_FAR *pKeyVal)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(uFlags != 0 || pKeyVal == NULL || wszName == 0)
		return WBEM_E_INVALID_PARAMETER;

    // special code for the provider team

    if(uCimType == CIM_ILLEGAL)
        uCimType = CalcCimType(pKeyVal->vt);
    if(uCimType == CIM_EMPTY)
        return WBEM_E_INVALID_PARAMETER;

	if(uCimType == CIM_SINT64)
	{
		__int64 llVal = _wtoi64(pKeyVal->bstrVal);
		return SetKey(wszName, uFlags, CIM_SINT64, &llVal);
	}
	else if(uCimType == CIM_UINT64)
	{
		unsigned __int64 ullVal;
		char cTemp[50];
		wcstombs(cTemp, pKeyVal->bstrVal,50);
		if(sscanf(cTemp, "%I64u", &ullVal) != 1)
            return WBEM_E_INVALID_PARAMETER;
		return SetKey(wszName, uFlags, CIM_UINT64, &ullVal);
	}
	else if(pKeyVal->vt == VT_BSTR)
	{
		return SetKey(wszName, uFlags, uCimType, pKeyVal->bstrVal);
	}
	else
	{
		DWORD dwSize = GetCIMSize(uCimType, &pKeyVal->lVal);
		if(dwSize == 0)
			return WBEM_E_INVALID_PARAMETER;
		return SetKey(wszName, uFlags, uCimType, &pKeyVal->lVal);
	}
}

/*++

Routine Description:

  Gets the key information based on the key's index.  Note that all return
  values are optional.

Arguments:

  uKeyIx			-	Zero based index of the desired key
  uNameBufSize		-	size of buffer in WCHAR of pszKeyName
  pszKeyName		-	where name is to be copied.  Can be NULL if not needed
  uKeyValBufSize	-	size of pKeyVal buffer in bytes
  pKeyVal			-	where data is to be copied.  Can be NULL if not needed
  puApparentCimType -	data type.  Can be NULL if not needed

Return Value:

  S_OK if all is well, else an error code.
	
--*/
        
HRESULT CParsedComponent::GetKey( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puKeyValBufSize,
            /* [in] */ LPVOID pKeyVal,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    bool bTooSmall = false;
    if(uKeyIx >= (DWORD)m_Keys.Size())
        return WBEM_E_INVALID_PARAMETER;
	if(uFlags != 0 && uFlags != WBEMPATH_TEXT && uFlags != WBEMPATH_QUOTEDTEXT)
        return WBEM_E_INVALID_PARAMETER;

    if(puNameBufSize && *puNameBufSize > 0 && pszKeyName == NULL)
        return WBEM_E_INVALID_PARAMETER;
	if(puKeyValBufSize && *puKeyValBufSize && pKeyVal == NULL)
        return WBEM_E_INVALID_PARAMETER;


    CKeyRef * pKey = (CKeyRef *)m_Keys[uKeyIx];
    if(puNameBufSize)
	{
        if(pKey->m_pName == NULL)
        {
            *puNameBufSize = 1;
            if(pszKeyName)
                pszKeyName[0] = 0;
        }
        else
        {
            DWORD dwSizeNeeded = wcslen(pKey->m_pName)+1;
		    if(*puNameBufSize < dwSizeNeeded && pszKeyName)
		    {
                bTooSmall = true;
			    *puNameBufSize = dwSizeNeeded;
		    }
            else
            {
                *puNameBufSize = dwSizeNeeded;
		        if(pszKeyName) 
		        {
			        StringCchCopyW(pszKeyName,dwSizeNeeded, pKey->m_pName);
		        }
            }
        }
	}

	if(puKeyValBufSize)
	{

		// get a pointer to the data and figure out how large it is

		DWORD dwSizeNeeded = 0;
		BYTE * pData = 0;
		bool bNeedToDelete = false;

		if(uFlags == 0)
		{
			dwSizeNeeded = pKey->m_dwSize;
			pData = (BYTE *)pKey->m_pData;
		}
		else
		{
			bool bQuoted = false;
			if(uFlags == WBEMPATH_QUOTEDTEXT)
				bQuoted = true;
			pData = (BYTE *)pKey->GetValue(bQuoted);
			if(pData == NULL)
				return WBEM_E_FAILED;
			bNeedToDelete = true;
			dwSizeNeeded = 2 * (wcslen((LPWSTR)pData)+1);
		}

		// Copy the data in

		if(*puKeyValBufSize < dwSizeNeeded && pKeyVal)
		{
			*puKeyValBufSize = dwSizeNeeded;
			if(bNeedToDelete)
				delete pData;
			return WBEM_E_BUFFER_TOO_SMALL;
		}
        *puKeyValBufSize = dwSizeNeeded;
		if(pData && pKeyVal)
			memcpy(pKeyVal, pData, dwSizeNeeded);
		if(bNeedToDelete)
			delete pData;
	}

    if(puApparentCimType)
        *puApparentCimType = pKey->m_dwType;
    if(bTooSmall)
        return WBEM_E_BUFFER_TOO_SMALL;
    else
        return S_OK;
}
  
/*++

Routine Description:

  Gets the key information based on the key's index.  Note that all return
  values are optional.

Arguments:

  uKeyIx			-	Zero based index of the desired key
  uNameBufSize		-	size of buffer in WCHAR of pszKeyName
  pszKeyName		-	where name is to be copied.  Can be NULL if not needed
  uKeyValBufSize	-	size of pKeyVal buffer in bytes
  pKeyVal			-	where data is to be copied.  Can be NULL if not needed
  puApparentCimType -	data type.  

Return Value:

  S_OK if all is well, else an error code.
	
--*/
        
HRESULT CParsedComponent::GetKey2( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufSize,
            /* [out][in] */ LPWSTR pszKeyName,
            /* [out][in] */ VARIANT __RPC_FAR *pKeyValue,
            /* [out] */ ULONG __RPC_FAR *puApparentCimType)
{

	DWORD dwSize = 50;
	WCHAR wTemp[50];

    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(uKeyIx >= (DWORD)m_Keys.Size() || pKeyValue == NULL || puApparentCimType == NULL)
        return WBEM_E_INVALID_PARAMETER;
    CKeyRef * pKey = (CKeyRef *)m_Keys[uKeyIx];

	if(pKey->m_dwType == CIM_STRING || pKey->m_dwType == CIM_REFERENCE || pKey->m_dwType == CIM_DATETIME)
		dwSize = pKey->m_dwSize * 4 + 2;
	char * pTemp = new char[dwSize];
	if(pTemp == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	CDeleteMe<char> dm(pTemp);
	HRESULT hr = GetKey(uKeyIx, uFlags, puNameBufSize,pszKeyName, &dwSize, 
							(void *)pTemp, puApparentCimType);
	if(FAILED(hr))
		return hr;

	__int64 temp64;
	// convert to cim type;

	VariantClear(pKeyValue);
	switch (*puApparentCimType)
	{
        case CIM_STRING:
        case CIM_REFERENCE:
        case CIM_DATETIME:
			pKeyValue->vt = VT_BSTR;
			pKeyValue->bstrVal = SysAllocString((LPWSTR)pTemp);
			if(pKeyValue->bstrVal == NULL)
				return WBEM_E_OUT_OF_MEMORY;
            break;
        case CIM_UINT8:
        case CIM_SINT8:
            pKeyValue->vt = VT_UI1;
			memcpy((void*)&pKeyValue->lVal, pTemp, 1);
            break;
        case CIM_SINT16:
        case CIM_CHAR16:
            pKeyValue->vt = VT_I2;
			memcpy((void*)&pKeyValue->lVal, pTemp, 2);
            break;
        case CIM_UINT16:
            pKeyValue->vt = VT_I4;
			memcpy((void*)&pKeyValue->lVal, pTemp, 2);
            break;
        case CIM_SINT32:
        case CIM_UINT32:
            pKeyValue->vt = VT_I4;
			memcpy((void*)&pKeyValue->lVal, pTemp, 4);
            break;
        case CIM_BOOLEAN:
            pKeyValue->vt = VT_BOOL;
			memcpy((void*)&pKeyValue->lVal, pTemp, 4);
            break;
        case CIM_SINT64:
        case CIM_UINT64:
			memcpy((void *)&temp64, pTemp, 8);
			if(*puApparentCimType == CIM_SINT64)
				_i64tow(temp64, wTemp, 10);
			else
				_ui64tow(temp64, wTemp, 10);
			pKeyValue->vt = VT_BSTR;
			pKeyValue->bstrVal = SysAllocString(wTemp);
			if(pKeyValue->bstrVal == NULL)
				return WBEM_E_OUT_OF_MEMORY;
            break;
	}
	return hr;
}
      
/*++

Routine Description:

  Removes a key from the key list.

Arguments:

  wszName		-	Name of the key to be delete.  Can be null if the key doesnt have a name.	
  uFlags		-	not currently used.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CParsedComponent::RemoveKey( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ ULONG uFlags)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    CKeyRef * pKey = NULL;
    bool bFound = false;
    DWORD dwCnt = 0;

    if(uFlags != 0)
        return WBEM_E_INVALID_PARAMETER;

    if(wszName == NULL || wszName[0] == 0)
    {

        // check for null key, it can match if single entry also null

        if(m_Keys.Size() == 1)
        {
            pKey = (CKeyRef *)m_Keys[dwCnt];
            if(pKey->m_pName == NULL || pKey->m_pName[0] == 0)
                bFound = true;
        }
    }
    else
    {

        // loop through and look for name match

        for(dwCnt = 0; dwCnt < (DWORD)m_Keys.Size(); dwCnt++)
        {
            pKey = (CKeyRef *)m_Keys[dwCnt];
            if(pKey->m_pName && !wbem_wcsicmp(pKey->m_pName, wszName))
            {
                bFound = true;
                break;
            }
        }
    }
    if(bFound)
    {
        delete pKey;
        m_Keys.RemoveAt(dwCnt);
        return S_OK;
    }
    else
        return WBEM_E_INVALID_PARAMETER;
}

/*++

Routine Description:

  Removes all keys from the key list.

Arguments:

  wszName		-	Name of the key to be delete.  Can be null if the key doesnt have a name.	
  uFlags		-	not currently used.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CParsedComponent::RemoveAllKeys( 
            /* [in] */ ULONG uFlags)
{

    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(uFlags != 0)
		return WBEM_E_INVALID_PARAMETER;
	ClearKeys();
	return S_OK;
}
  
/*++

Routine Description:

  Sets or unsets a key to be singleton.

Arguments:

  bSet		-	if true, then all keys are deleted and the singleton flag is set.
				if false, then the singleton flag is cleared.
Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CParsedComponent::MakeSingleton(boolean bSet)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(bSet)
	{
		ClearKeys();
		m_bSingleton = true;
	}
	else
		m_bSingleton = false;
	return S_OK;
}

       
/*++

Routine Description:

  Returns information about a particular key list.

Arguments:

  uRequestedInfo	-	Not currently used, should be set to zero	
  puResponse		-	any appropriate values will be OR'ed into this

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CParsedComponent::GetInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(uRequestedInfo != 0 || puResponse == NULL)
		return WBEM_E_INVALID_PARAMETER;
	*puResponse = 0;
	ULONG ulKeyCnt = m_Keys.Size();
	if(ulKeyCnt > 1)
		*puResponse |= WBEMPATH_INFO_IS_COMPOUND;


	for(DWORD dwKey = 0; dwKey < ulKeyCnt; dwKey++)
	{
		CKeyRef * pKey = (CKeyRef *)m_Keys[dwKey];
		if(pKey->m_pName == NULL || wcslen(pKey->m_pName) < 1)
			*puResponse |= WBEMPATH_INFO_HAS_IMPLIED_KEY;

		if(pKey->m_dwType == CIM_REFERENCE)
			*puResponse |= WBEMPATH_INFO_HAS_V2_REF_PATHS;
	}
    if(m_bSingleton)
		*puResponse |= WBEMPATH_INFO_CONTAINS_SINGLETON;
	return S_OK;
}

/*++

Routine Description:

  Returns text version of a particular key list.

Arguments:

  lFlags		- 0 is only current value
  uBuffLength	- number of WCHAR which can fit into pszText 
  pszText		- buffer supplied by caller where data is to be copied

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CParsedComponent::GetText( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out] */ LPWSTR pszText)
{

    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if((lFlags != 0 && lFlags != WBEMPATH_QUOTEDTEXT && lFlags != WBEMPATH_TEXT) || puBuffLength == NULL)
		return WBEM_E_INVALID_PARAMETER;

	BSTR data = NULL;
	bool bGetQuotes = false;
	if(lFlags & WBEMPATH_QUOTEDTEXT)
		bGetQuotes = true;

    HRESULT hr = Unparse(&data, bGetQuotes, false);
	if(FAILED(hr))
		return hr;
	if(data == NULL)
		return WBEM_E_FAILED;

	DWORD dwBuffSize = *puBuffLength;
	DWORD dwSizeNeeded = wcslen(data)+1;
	*puBuffLength = dwSizeNeeded;
	hr = S_OK;
	if(pszText)
	{
		if(dwSizeNeeded > dwBuffSize)
			hr = WBEM_E_BUFFER_TOO_SMALL;
		else
		{
			StringCchCopyW(pszText,dwSizeNeeded, data);
		}
	}
	SysFreeString(data);
	return hr;
}


/*++

Routine Description:

  Cleans out a key list.
	
--*/

void CParsedComponent::ClearKeys ()
{
    DWORD dwSize = m_Keys.Size();
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < dwSize ; 
            dwDeleteIndex ++ )
    {
        CKeyRef * pDel = (CKeyRef *)m_Keys[dwDeleteIndex];
		delete pDel;
    }
    m_Keys.Empty();
}

/*++

Routine Description:

  Determines if the key list could be for an instance.

Return Value:

  true if path has keys or is marked as singleton.

--*/

bool CParsedComponent::IsInstance()
{
	if(m_bSingleton || m_Keys.Size())
		return true;
	else
		return false;
}

/*++

Routine Description:

  Adds a key to the key list.

Arguments:

  CKeyRef	-	key to be added.  Note that it is now owned by the key list
				and should not be freed by the caller.

Return Value:

  TRUE if all is well.
	
--*/

BOOL CParsedComponent::AddKeyRef(CKeyRef* pAcquireRef)
{
	if(pAcquireRef == NULL)
		return FALSE;

    if(CFlexArray::no_error == m_Keys.Add(pAcquireRef))
		return TRUE;
	else
		return FALSE;
}

/*++

Routine Description:

  Tests a component to determine if it could be a namespace.  That is true
  only if it contains a single string value with no class name or key name.


Return Value:

  TRUE if it could be a namespace.
	
--*/

bool CParsedComponent::IsPossibleNamespace()
{
	if(m_sClassName && wcslen(m_sClassName))
		return false;
	if(m_Keys.Size() != 1)
		return false;

	CKeyRef * pKey = (CKeyRef *)m_Keys[0];
	if(pKey->m_pName && wcslen(pKey->m_pName))
		return false;
	if(pKey->m_dwType != CIM_STRING)
		return false;
	if(pKey->m_pData == NULL)
		return false;
	else
		return true;
}


/*++

Routine Description:

  Sets a component to be a namespace.

Arguments:

  pName	-		Name to be added.

Return Value:

  S_OK if all is well, else standard error code.
	
--*/

HRESULT CParsedComponent::SetNS(LPCWSTR pName)
{
	if(pName == NULL)
		return WBEM_E_INVALID_PARAMETER;

	CKeyRef * pNew = new CKeyRef;
	if(pNew == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	DWORD dwStrSize = wcslen(pName) + 1;	// one for the numm
	pNew->m_dwSize = 2 * dwStrSize;			// size is in byte, not unicode
    pNew->m_pData = new WCHAR[dwStrSize];
	if(pNew->m_pData == NULL)
    {
        delete pNew;
		return WBEM_E_OUT_OF_MEMORY;
    }

	StringCchCopyW((LPWSTR)pNew->m_pData,dwStrSize, pName);
    pNew->m_dwType = CIM_STRING;
	if(CFlexArray::no_error == m_Keys.Add(pNew))
		return S_OK;
	else
	{
		delete pNew;
		return WBEM_E_OUT_OF_MEMORY;
	}

}

//***************************************************************************
//
//  CDefPathParser
//
//***************************************************************************

/*++

Routine Description:

  Constructor.
	
--*/

CDefPathParser::CDefPathParser(void)
{
    m_cRef=1;
    m_pServer = 0;                  // NULL if no server
    m_dwStatus = OK;
	m_bParent = false;
	m_pRawPath = NULL;
    m_wszOriginalPath = NULL;
	m_bSetViaUMIPath = false;
    m_pCS = new CRefCntCS;
    if(m_pCS == NULL || FAILED(m_pCS->GetStatus()))
    	m_dwStatus = FAILED_TO_INIT;
    InterlockedIncrement(&g_cObj);
	m_bServerNameSetByDefault = false;
	m_pFTM = NULL;
    CoCreateFreeThreadedMarshaler((IWbemPath*)this, &m_pFTM);
	m_pGenLex = NULL; 
	m_dwException = 0;
    return;
};

/*++

Routine Description:

  Destructor.
	
--*/

CDefPathParser::~CDefPathParser(void)
{
	if(m_pCS)
        m_pCS->Release();
	Empty();
    m_pCS = NULL;
    if(m_pFTM)
    	m_pFTM->Release();
    InterlockedDecrement(&g_cObj);    
    return;
}

/*++

Routine Description:

  Gets the total number of namespaces, scopes, and class parts.

Return Value:

  Number of components.
	
--*/

DWORD CDefPathParser::GetNumComponents()
{
	int iSize = m_Components.Size();
	return iSize;
}

/*++

Routine Description:

  Determines if there is anything in the path.

Return Value:

  true if there is no server, namepace, scope or class part.

--*/

bool CDefPathParser::IsEmpty()
{
	if(m_pServer || GetNumComponents() || m_pRawPath)
		return false;
	else
		return true;
}

/*++

Routine Description:

  Cleans out the data.  Used by destructor.
	
--*/

void CDefPathParser::Empty(void)
{
	m_bSetViaUMIPath = false;
    delete m_pServer;
	m_bParent = false;
	m_pServer = NULL;
	delete m_pRawPath;
	m_pRawPath = NULL;
	delete m_wszOriginalPath;
	m_wszOriginalPath = NULL;
    for (DWORD dwIx = 0; dwIx < (DWORD)m_Components.Size(); dwIx++)
    {
        CParsedComponent * pCom = (CParsedComponent *)m_Components[dwIx];
        pCom->Release();
    }
	m_Components.Empty();
    return;
}

/*++

Routine Description:

  Gets the component string.  The string varies depending on if the component
  if a namepace, or scope or path.

Arguments:

  i				- zero based index
  pUnparsed		- where the string is returned.  The caller must free via SysFreeString.
  wDelim		- Delimiter for this type

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetComponentString(ULONG i, BSTR * pUnparsed, WCHAR & wDelim)
{

	DWORD dwNs = GetNumNamespaces();
	DWORD dwSc = m_Components.Size();
	if(i < dwNs)
	{
		CParsedComponent * pNS = (CParsedComponent *)m_Components[i]; 
		wDelim = L'\\';
		return pNS->Unparse(pUnparsed, false, true);
	}
	CParsedComponent * pInst = NULL;
	if(i < (dwSc))
		pInst = (CParsedComponent *)m_Components[i];
	if(pInst == NULL)
		return WBEM_E_INVALID_PARAMETER;
	wDelim = L':';
	HRESULT hRes;
	hRes = pInst->Unparse(pUnparsed, true, true);
	return hRes;
}

/*++

Routine Description:

  Returns the path

Arguments:

  nStartAt		-   first component to be added to the path
  nStopAt		-	last component to be added to the path.  Note that this is usually just set to
					the number of components.

Return Value:

  pointer to the string.  The caller must free this via delete.  If there is an Error, NULL is returned.
	
--*/

LPWSTR CDefPathParser::GetPath(DWORD nStartAt, DWORD nStopAt,bool bGetServer)
{

    DWORD dwSize = 1024, dwUsed = 0;
    if(bGetServer && m_pServer && wcslen(m_pServer) > 1000)
        dwSize = 2 * wcslen(m_pServer);

    LPWSTR wszOut = new WCHAR[dwSize];
    if(wszOut == NULL)
        return NULL;
    wszOut[0] = 0;
    bool bFirst = true;

    if(bGetServer && m_pServer && wcslen(m_pServer) < 1020)
    {
        int iLen = wcslen(m_pServer) + 3;	// allow for back slashes
        StringCchCopyW(wszOut,dwSize, L"\\\\");
        StringCchCatW(wszOut,dwSize, m_pServer);
        StringCchCatW(wszOut,dwSize, L"\\");
        dwUsed = iLen;
    }
    for (unsigned int i = nStartAt; (int)i < (int)nStopAt; i++)
    {
        BSTR sTemp = NULL;
        WCHAR wDel;
        HRESULT hRes = GetComponentString(i, &sTemp, wDel);
        if(FAILED(hRes))
        {
            delete wszOut;
            return NULL;
        }
        CSysFreeMe fm(sTemp);
        int iLen = wcslen(sTemp);
        if ((iLen + dwUsed) > (dwSize-2))
        {
            DWORD dwNewSize = 2*(dwSize + iLen);
            LPWSTR lpTemp = new WCHAR[dwNewSize];
            CDeleteMe<WCHAR> dm(wszOut);
            if(lpTemp == NULL)
                return NULL;
            memcpy(lpTemp,wszOut, dwSize * sizeof(WCHAR));
            dwSize = dwNewSize;
            wszOut = lpTemp;
        }

        if (!bFirst)
        {
            int n = wcslen(wszOut);
            wszOut[n] = wDel;
            wszOut[n+1] = '\0';
            iLen++;
        }
        bFirst = false;
        StringCchCatW(wszOut,dwSize, sTemp);
        dwUsed += iLen;
    }

    return wszOut;

}

/*++

Routine Description:

  Adds a namespace.

Arguments:

  wszNamespace		-	Name to be set into the namespace.

Return Value:

  TRUE if all is well.

--*/

BOOL CDefPathParser::AddNamespace(LPCWSTR wszNamespace)
{
    BOOL bRet = FALSE;
	DWORD dwNumNS = GetNumNamespaces();

    CParsedComponent *pNew = new CParsedComponent(m_pCS);
    if (pNew)
    {
        HRESULT hr = pNew->SetNS(wszNamespace);
		if(FAILED(hr))
		{
			delete pNew;
			return FALSE;
		}
        int iRet = m_Components.InsertAt(dwNumNS, pNew); 
        if(iRet != CFlexArray::no_error)
        {
			delete pNew;
			bRet = FALSE;
        }
        else 
        	bRet = TRUE;
    }

    return bRet;
}

/*++

Routine Description:

  This is used during the parsing of the path and is
  just a convenient way to get at the last scope.  Note 
  that during this phase, the class part is in the scope 
  list.

Return Value:

  pointer to last scope or NULL if there isnt one.
--*/

CParsedComponent * CDefPathParser::GetLastComponent()
{
    DWORD dwSize = m_Components.Size();
    if (dwSize > (DWORD)GetNumNamespaces())
        return (CParsedComponent *)m_Components[dwSize-1];
    else
        return NULL;
}

/*++

Routine Description:

  Adds new class.  This is used during the parsing stage when
  the class is just treated as the last scope.

Arguments:

  lpClassName		-	Name of the class

Return Value:

  TRUE if ok

--*/

BOOL CDefPathParser::AddClass(LPCWSTR lpClassName)
{
    BOOL bRet = FALSE;

    CParsedComponent *pNew = new CParsedComponent(m_pCS);
    if (pNew)
    {
        pNew->m_sClassName = SysAllocString(lpClassName);
		if(pNew->m_sClassName)
		{
			m_Components.Add(pNew);
			bRet = TRUE;
		}
		else
			delete pNew;
    }
    
    return bRet;
}

/*++

Routine Description:

  Adds a key/value pair.

Arguments:

  pKey		-	Data to be added.  Note that this is acquired by this routine.

Return Value:

  TRUE if all is well

--*/

BOOL CDefPathParser::AddKeyRef(CKeyRef *pRef)
{
    BOOL bRet = FALSE;
    CParsedComponent *pTemp = GetLastComponent();
    if (pTemp)
    {
        DWORD dwType = 0;
        bRet = pTemp->AddKeyRef(pRef);
    }
    return bRet;
}

/*++

Routine Description:

  Sets the most recent class to be singleton.

Return Value:

  TRUE if OK.

--*/

BOOL CDefPathParser::SetSingletonObj()
{
    BOOL bRet = FALSE;
    CParsedComponent *pTemp = GetLastComponent();
    if (pTemp)
            pTemp->MakeSingleton(true);
    return bRet;
}

/*++

Routine Description:

  Sets the path text.  This causes object to be emptied, the path to be parsed
  and the object be rebuilt.

Arguments:

  uMode			-	mode, can be 
			          WBEMPATH_CREATE_ACCEPT_RELATIVE
					  WBEMPATH_CREATE_ACCEPT_ABSOLUTE
					  WBEMPATH_CREATE_ACCEPT_ALL

  pszPath		- Path.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::SetText( 
            /* [in] */ ULONG uMode,
            /* [in] */ LPCWSTR pszPath) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(pszPath == NULL)
		return WBEM_E_INVALID_PARAMETER;

	if(!IsEmpty())
		Empty();

    if ((uMode & WBEMPATH_CREATE_ACCEPT_ALL) != 0 && wcslen (pszPath) == 0)
	return S_OK;

    try
    {
        size_t cchTmp = wcslen(pszPath)+1;
        m_wszOriginalPath = new WCHAR[cchTmp];

        if(m_wszOriginalPath)
        {
	        StringCchCopyW(m_wszOriginalPath,cchTmp, pszPath);

		    if(wcscmp(pszPath, L"..") == 0)
		    {
			    m_bParent = true;
	            m_dwStatus = OK;
	            return S_OK;
		    }

		    // normal case

	        CActualPathParser parser(uMode);
	        int iRet = parser.Parse(pszPath, *this);
	        if(iRet == 0)
	        {
	            m_dwStatus = OK;
	            return S_OK;
	        }
	        else
	        {
	            m_dwStatus = BAD_STRING;
	            return WBEM_E_INVALID_PARAMETER;
	        }
	    }
	    else
	    {
	        return WBEM_E_OUT_OF_MEMORY;
	    }
    }
    catch(...)
    {
        m_dwStatus = EXECEPTION_THROWN;
	    return WBEM_E_CRITICAL_ERROR;
    } 
}

/*++

Routine Description:

  Create a WMI path from the object

Arguments:

  lFlags		- 0
  uBuffLength	- number of WCHAR which can fit into pszText 
  pszText		- buffer supplied by caller where data is to be copied

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetText( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG * puBuffLength,
            /* [string][out] */ LPWSTR pszText) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(puBuffLength == NULL || (*puBuffLength > 0 &&pszText == NULL))
        return WBEM_E_INVALID_PARAMETER;

	if(lFlags != 0 && lFlags != WBEMPATH_GET_RELATIVE_ONLY && lFlags != WBEMPATH_GET_SERVER_TOO && 
	   lFlags != WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY && lFlags != WBEMPATH_GET_NAMESPACE_ONLY &&
	   lFlags != WBEMPATH_GET_ORIGINAL)
			return WBEM_E_INVALID_PARAMETER;

    if(lFlags == WBEMPATH_GET_ORIGINAL && m_wszOriginalPath)
    {
        DWORD dwSizeNeeded = wcslen(m_wszOriginalPath) + 1;
        DWORD dwBuffSize = *puBuffLength;
        *puBuffLength = dwSizeNeeded;
        if(pszText)
        {
            if(dwSizeNeeded > dwBuffSize)
                return WBEM_E_BUFFER_TOO_SMALL;
            StringCchCopyW(pszText,dwSizeNeeded, m_wszOriginalPath);
        }
        return S_OK;
    }
        
	LPWSTR pTemp = NULL;
	DWORD dwStartAt = 0;
	if(lFlags & WBEMPATH_GET_RELATIVE_ONLY)
		dwStartAt = GetNumNamespaces();
	bool bGetServer = false;
	if(lFlags & WBEMPATH_GET_SERVER_TOO || lFlags & WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY)
		bGetServer = true;

	DWORD dwNum;
	if(lFlags & WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY ||
        lFlags & WBEMPATH_GET_NAMESPACE_ONLY)
		dwNum = GetNumNamespaces();
	else
		dwNum = GetNumComponents();

	// If just a relative path is specified, then dont prepend the server since that
	// will create an invalid path

	if(bGetServer && GetNumNamespaces() == 0 && m_bServerNameSetByDefault == true)
		bGetServer = false;

	pTemp = GetPath(dwStartAt, dwNum, bGetServer);

	if(pTemp == NULL)
        return WBEM_E_FAILED;
    CDeleteMe<WCHAR> dm(pTemp);
	DWORD dwSizeNeeded = wcslen(pTemp) + 1;
	DWORD dwBuffSize = *puBuffLength;
	*puBuffLength = dwSizeNeeded;
	if(pszText)
	{
		if(dwSizeNeeded > dwBuffSize)
			return WBEM_E_BUFFER_TOO_SMALL;
		StringCchCopyW(pszText,dwSizeNeeded, pTemp);
	}
	return S_OK;
}

CParsedComponent * CDefPathParser::GetClass()
{
	DWORD dwNS = GetNumNamespaces();
	DWORD dwScopes = m_Components.Size() - dwNS;
	if(dwScopes < 1)
		return NULL;
	int iLast = m_Components.Size()-1;
	return (CParsedComponent *)m_Components.GetAt(iLast);
}


/*++

Routine Description:

  Gets information about the object path.

Arguments:

  uRequestedInfo	-	Must be zero for now
  puResponse		-	The various flags in tag_WMI_PATH_STATUS_FLAG are
						OR'ed in as appropriate.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetInfo(/* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(uRequestedInfo != 0 || puResponse == NULL)
		return WBEM_E_INVALID_PARAMETER;
	*puResponse = 0;

	// special case for ".." paths.

	if(IsEmpty() && m_bParent)
	{
		*puResponse |= WBEMPATH_INFO_IS_PARENT;
		return S_OK;
	}

	// bits for
    // WBEMPATH_INFO_NATIVE_PATH           = 0X8000,
    // WBEMPATH_INFO_WMI_PATH              = 0X10000,

	if(m_bSetViaUMIPath)
		*puResponse |= WBEMPATH_INFO_WMI_PATH;
	if(m_pRawPath)
		*puResponse |= WBEMPATH_INFO_NATIVE_PATH;

    // Bits for
    // WBEMPATH_INFO_ANON_LOCAL_MACHINE      <path has \\. as server name>
    // WBEMPATH_INFO_HAS_MACHINE_NAME        <not a dot>
	// WBEMPATH_INFO_PATH_HAD_SERVER		 <there is a path and it was not specified by default>

	if(m_pServer == NULL || !wbem_wcsicmp(m_pServer, L"."))
		*puResponse |= WBEMPATH_INFO_ANON_LOCAL_MACHINE;
	else
		*puResponse |= WBEMPATH_INFO_HAS_MACHINE_NAME;
	if(m_pServer && m_bServerNameSetByDefault == false)
		*puResponse |= WBEMPATH_INFO_PATH_HAD_SERVER;


	// WBEMPATH_INFO_HAS_SUBSCOPES           <true if a subscope is present

	DWORD dwNS = GetNumNamespaces();
	DWORD dwScopes = m_Components.Size() - dwNS;
	if(dwScopes)
		*puResponse |= WBEMPATH_INFO_HAS_SUBSCOPES;

    // Bits for
    // WBEMPATH_INFO_IS_CLASS_REF            <a path to a classs, not a path to an instance
    // WBEMPATH_INFO_IS_INST_REF             <a path to an instance


	CParsedComponent * pClass = GetClass();
    if (pClass)
    {
        DWORD dwType = 0;
        if(pClass->IsInstance())
            *puResponse |= WBEMPATH_INFO_IS_INST_REF;
		else
			*puResponse |= WBEMPATH_INFO_IS_CLASS_REF;
		if(pClass->m_bSingleton)
			*puResponse |= WBEMPATH_INFO_IS_SINGLETON;

    }
	else
		if(dwScopes == 0)
			*puResponse |= WBEMPATH_INFO_SERVER_NAMESPACE_ONLY;


	// loop through all the scopes and the class deff.
	// set the following
    // WBEMPATH_INFO_IS_COMPOUND             <true if compound key is used
    // WBEMPATH_INFO_HAS_V2_REF_PATHS        <true if V2-style ref paths are used
    // WBEMPATH_INFO_HAS_IMPLIED_KEY         <true if keynames are missing somewhere
    // WBEMPATH_INFO_CONTAINS_SINGLETON      <true if one or more singletons

	unsigned __int64 llRet = 0;

    for (unsigned int iCnt = dwNS; iCnt < (DWORD)m_Components.Size(); iCnt++)
    {
        CParsedComponent *pComp = (CParsedComponent *)m_Components[iCnt];
		pComp->GetInfo(0, &llRet);
		*puResponse |= llRet;
	}
	
	if(pClass)
	{
		pClass->GetInfo(0, &llRet);
		*puResponse |= llRet;
	}

	// For now, assume that v1 compilance means no scopes or new references

	bool bOK = (!IsEmpty() && m_dwStatus == OK);

	if(dwScopes == 0 && (*puResponse & WBEMPATH_INFO_HAS_V2_REF_PATHS) == 0 && bOK)
			*puResponse |= WBEMPATH_INFO_V1_COMPLIANT;

    // WBEMPATH_INFO_V2_COMPLIANT            <true if path is WMI-V2-compliant
    // WBEMPATH_INFO_CIM_COMPLIANT           <true if path is CIM-compliant

	if(bOK)
	{
		// todo, need to define cim compliance

		*puResponse |= WBEMPATH_INFO_V2_COMPLIANT;
		*puResponse |= WBEMPATH_INFO_CIM_COMPLIANT;
	}
 
    return S_OK;
}        
        
/*++

Routine Description:

  Sets the server portion of the path.

Arguments:

  Name			-	New server name.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::SetServer( 
            /* [string][in] */ LPCWSTR Name) 
{
	return SetServer(Name, false, false);
}

HRESULT CDefPathParser::SetServer( 
            /* [string][in] */ LPCWSTR Name, bool bServerNameSetByDefault, bool bAcquire) 
{
	m_bServerNameSetByDefault = bServerNameSetByDefault;     
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    delete m_pServer;
	m_pServer = NULL;
    if(Name == NULL)		// it is ok to have a null server an
        return S_OK; 

    if(bAcquire)
    {
        m_pServer = (LPWSTR)Name;
    }
    else
    {
        size_t cchTmp = wcslen(Name)+1;
        m_pServer = new WCHAR[cchTmp];
        if(m_pServer == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        StringCchCopyW(m_pServer,cchTmp, Name);
    }
    return S_OK;
}

/*++

Routine Description:

  Gets the server portion of the path

Arguments:

  puNameBufLength	- size of pName in WCHAR.  On return, set to size used or needed
  pName				- caller allocated buffer where date is to be copied

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetServer( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out] */ LPWSTR pName) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(puNameBufLength == 0 || (*puNameBufLength > 0 && pName == NULL))
        return WBEM_E_INVALID_PARAMETER;
	if(m_pServer == NULL)
        return WBEM_E_NOT_AVAILABLE;
	DWORD dwSizeNeeded = wcslen(m_pServer)+1;
	DWORD dwBuffSize = *puNameBufLength;
	*puNameBufLength = dwSizeNeeded;
	if(pName)
	{
		if(dwSizeNeeded > dwBuffSize)
			return WBEM_E_BUFFER_TOO_SMALL;
		StringCchCopyW(pName,dwSizeNeeded, m_pServer);
	}
    return S_OK;
}
        
/*++

Routine Description:

  Gets the number of namespaces

Arguments:

  puCount		-	Set to the number of namespaces.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetNamespaceCount( 
            /* [out] */ ULONG __RPC_FAR *puCount) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(puCount == NULL)
        return WBEM_E_INVALID_PARAMETER;
    
    *puCount = GetNumNamespaces();    
    return S_OK;
}

/*++

Routine Description:

  Inserts a namespace into the path.  An index of 0 inserts it
  at the front of the list.  The maximum allowed value is equal
  to the current number of namespaces which results in adding it
  to the end of the list.

Arguments:

  uIndex	-	See above
  pszName	-	Name of the new Namespace

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::SetNamespaceAt(/* [in] */ ULONG uIndex,
            /* [string][in] */ LPCWSTR pszName) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;

    // get the count.

	DWORD dwNSCnt = GetNumNamespaces();

	// check the parameters, index must be between 0 and count!

	if(pszName == NULL || uIndex > dwNSCnt)
		return WBEM_E_INVALID_PARAMETER;

	// add this in.

    CParsedComponent *pNew = new CParsedComponent(m_pCS);
    if (pNew == NULL)
		return WBEM_E_OUT_OF_MEMORY;
    
    HRESULT hr = pNew->SetNS(pszName);
	if(FAILED(hr))
	{
		delete pNew;
		return hr;
	}
	int iRet = m_Components.InsertAt(uIndex, pNew);
	if(iRet ==  CFlexArray::no_error)
	    return S_OK;
	else
	{
		delete pNew;
		return WBEM_E_OUT_OF_MEMORY;
	}
}

/*++

Routine Description:

  Gets a namespace name from the list

Arguments:

  uIndex			-	zero based index.  0 if the leftmost.
  uNameBufLength	-	size of pName in WCHAR
  pName				-	caller supplied buffer where the data is to be copied

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetNamespaceAt( 
            /* [in] */ ULONG uIndex,
            /* [in] */ ULONG * puNameBufLength,
            /* [string][out] */ LPWSTR pName)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    DWORD dwType;
    if(uIndex >= (DWORD)GetNumNamespaces() || puNameBufLength == NULL || (*puNameBufLength > 0 && pName == NULL))
        return WBEM_E_INVALID_PARAMETER;

    CParsedComponent *pTemp = (CParsedComponent *)m_Components[uIndex];
    BSTR bsName;
    SCODE sc = pTemp->Unparse(&bsName, false, true);
    if(FAILED(sc))
        return sc;
	CSysFreeMe fm(bsName);

	DWORD dwSizeNeeded = wcslen(bsName)+1;
	DWORD dwBuffSize = *puNameBufLength;
	*puNameBufLength = dwSizeNeeded;
	if(pName)
	{
		if(dwSizeNeeded > dwBuffSize)
			return WBEM_E_BUFFER_TOO_SMALL;
		StringCchCopyW(pName,dwSizeNeeded, bsName);
	}
    return S_OK;
}

/*++

Routine Description:

  Removes a namespace.

Arguments:

  uIndex			-	0 based index of namespace to be removed.  0 is the leftmost.
Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::RemoveNamespaceAt( 
            /* [in] */ ULONG uIndex) 
{

    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	DWORD dwNSCnt;
	GetNamespaceCount(&dwNSCnt);

	// check the parameter, index must be between 0 and count-1!

	if(uIndex >= dwNSCnt)
		return WBEM_E_INVALID_PARAMETER;

	// all is well, delete this

    CParsedComponent *pTemp = (CParsedComponent *)m_Components[uIndex];
	delete pTemp;
	m_Components.RemoveAt(uIndex);
    return S_OK;
}
 
/*++

Routine Description:

  Removes all namespaces.

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::RemoveAllNamespaces() 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	DWORD dwNum = GetNumNamespaces();
    for (DWORD dwIx = 0; dwIx < dwNum; dwIx++)
    {
        CParsedComponent * pNS = (CParsedComponent *)m_Components[0];
        delete pNS;
		m_Components.RemoveAt(0);
    }
	return S_OK;
}
       
/*++

Routine Description:

  Gets the number of scopes

Arguments:

  puCount		-	where the number is set.

Return Value:

  S_OK if all is well, else an error code.
	
--*/
     
HRESULT CDefPathParser::GetScopeCount(/* [out] */ ULONG __RPC_FAR *puCount) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(puCount == NULL)
		return WBEM_E_INVALID_PARAMETER;

	*puCount = m_Components.Size() - GetNumNamespaces();
    return S_OK;
}
        
/*++

Routine Description:

  Inserts a scope into the path.  An index of 0 inserts it
  at the front of the list.  The maximum allowed value is equal
  to the current number of scope which results in adding it
  to the end of the list.

Arguments:

  uIndex		-	See description
  pszClass		-	Name of the new scope

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::SetScope( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	DWORD dwScopeCnt = m_Components.Size();
	uIndex += GetNumNamespaces();
	if(pszClass == NULL || uIndex > dwScopeCnt)
		return WBEM_E_INVALID_PARAMETER;
    CParsedComponent *pNew = new CParsedComponent(m_pCS);
	if(pNew == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    pNew->m_sClassName = SysAllocString(pszClass);
	if(pNew->m_sClassName == NULL)
	{
		delete pNew;
		return WBEM_E_OUT_OF_MEMORY;
	}
	int iRet = m_Components.InsertAt(uIndex, pNew);
	if(iRet ==  CFlexArray::no_error)
	    return S_OK;
	else
	{
		delete pNew;
		return WBEM_E_OUT_OF_MEMORY;
	}
	return S_OK;
}
HRESULT CDefPathParser::SetScopeFromText( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText)
{
	return WBEM_E_NOT_AVAILABLE;
}

/*++

Routine Description:

  Retrieves scope information.

Arguments:

  uIndex			-	0 based index.  0 is the leftmost scope
  uClassNameBufSize	-	size of pszClass in WCHAR
  pszClass			-	Optional, caller supplied buffer where name is to be copied
  pKeyList			-	Optional, returns a pKeyList pointer.  Caller must call Release.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetScope( 
            /* [in] */ ULONG uIndex,
            /* [in] */ ULONG * puClassNameBufSize,
            /* [in] */ LPWSTR pszClass,
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pKeyList) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	DWORD dwScopeCnt = m_Components.Size();
	HRESULT hr = S_OK;
	uIndex += GetNumNamespaces();

	if(uIndex >= dwScopeCnt)
		return WBEM_E_INVALID_PARAMETER;

    if(puClassNameBufSize && (*puClassNameBufSize > 0 && pszClass == NULL))
        return WBEM_E_INVALID_PARAMETER;

    CParsedComponent *pTemp = (CParsedComponent *)m_Components[uIndex];
    if(puClassNameBufSize)
	{
		BSTR bsName;
		SCODE sc = pTemp->GetName(&bsName);
		if(FAILED(sc))
		{
			return sc;
		}
		CSysFreeMe fm(bsName);
        DWORD dwSizeNeeded = wcslen(bsName)+1;
		DWORD dwBuffSize = *puClassNameBufSize;
		*puClassNameBufSize = dwSizeNeeded;
		if(pszClass)
		{
			if(dwSizeNeeded > dwBuffSize)
				return WBEM_E_BUFFER_TOO_SMALL;
			StringCchCopyW(pszClass,dwSizeNeeded, bsName);
		}
	}
	if(pKeyList)
	{
		hr = pTemp->QueryInterface(IID_IWbemPathKeyList, (void **)pKeyList);
		if(FAILED(hr))
			return hr;
	}
	return S_OK;
}
HRESULT CDefPathParser::GetScopeAsText( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	DWORD dwScopeCnt = m_Components.Size();
	uIndex += GetNumNamespaces();

	if(uIndex >= dwScopeCnt || puTextBufSize == NULL)
		return WBEM_E_INVALID_PARAMETER;

	CParsedComponent *pTemp = (CParsedComponent *)m_Components[uIndex];
	
	BSTR bstr;
	HRESULT hr = pTemp->Unparse(&bstr, true, true);
	if(FAILED(hr))
		return hr;

	CSysFreeMe fm(bstr);
	DWORD dwBuffSize = *puTextBufSize;
	DWORD dwSizeNeeded = wcslen(bstr)+1;
	*puTextBufSize = dwSizeNeeded;
	if(pszText)
	{
		if(dwSizeNeeded > dwBuffSize)
			return WBEM_E_BUFFER_TOO_SMALL;
		StringCchCopyW(pszText,dwSizeNeeded, bstr);
	}
	return S_OK;
}
        
/*++

Routine Description:

  Removes a scope.

Arguments:

  uIndex		-	0 based index.  0 is the leftmost scope.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::RemoveScope(/* [in] */ ULONG uIndex) 
{
	HRESULT hr = S_OK;
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	bool bGotInterface = false;

	uIndex += GetNumNamespaces();
	if(uIndex >= (DWORD)m_Components.Size())
		return WBEM_E_INVALID_PARAMETER;

    CParsedComponent *pTemp = (CParsedComponent *)m_Components[uIndex];
	pTemp->Release();
	m_Components.RemoveAt(uIndex);
	return S_OK;
}

/*++

Routine Description:

  Removes all scopes.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::RemoveAllScopes( void)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    DWORD dwNumNS = GetNumNamespaces();
    for (DWORD dwIx = dwNumNS; dwIx < (DWORD)m_Components.Size(); dwIx++)
    {
        CParsedComponent * pCom = (CParsedComponent *)m_Components[dwNumNS];
        pCom->Release();
		m_Components.RemoveAt(dwNumNS);
    }
	return S_OK;
}

/*++

Routine Description:

  Sets the class name.

Arguments:

  Name			-	New class name.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::SetClassName( 
            /* [string][in] */ LPCWSTR Name) 
{

    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(Name == NULL)
        return WBEM_E_INVALID_PARAMETER;

    HRESULT hRes = WBEM_E_INVALID_OBJECT_PATH;
	CParsedComponent * pClass = GetClass();
    if (pClass)
    {
		if(pClass->m_sClassName)
            SysFreeString(pClass->m_sClassName);
		pClass->m_sClassName = NULL;
		pClass->m_sClassName = SysAllocString(Name);
        if(pClass->m_sClassName)
            hRes = S_OK;
        else
            hRes = WBEM_E_OUT_OF_MEMORY;
    }
	else
        hRes = CreateClassPart(0, Name);
    return hRes;
}
        
/*++

Routine Description:

  Gets the class name.

Arguments:

  uBuffLength		-	size of pszName in WCHAR
  pszName			-	caller supplied buffer where name is to be copied

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetClassName( 
            /* [in, out] */ ULONG * puBuffLength,
            /* [string][out] */ LPWSTR pszName) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    if(puBuffLength == NULL || (*puBuffLength > 0 && pszName == NULL))
        return WBEM_E_INVALID_PARAMETER;
    HRESULT hRes = WBEM_E_INVALID_OBJECT_PATH;
	CParsedComponent * pClass = GetClass();
    if (pClass && pClass->m_sClassName)
    {
        DWORD dwSizeNeeded = wcslen(pClass->m_sClassName) +1;
		DWORD dwBuffSize = *puBuffLength;
		*puBuffLength = dwSizeNeeded;
		if(pszName)
		{
			if(dwSizeNeeded > dwBuffSize)
				return WBEM_E_BUFFER_TOO_SMALL;
			StringCchCopyW(pszName,dwSizeNeeded, pClass->m_sClassName);
		}
        hRes = S_OK;
    }
    return hRes;
}
        
/*++

Routine Description:

  Gets the key list pointer for the class key list.

Arguments:

  pOut			-	Set to the key list.  Caller must call Release on this.

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::GetKeyList( 
            /* [out] */ IWbemPathKeyList __RPC_FAR *__RPC_FAR *pOut) 
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    HRESULT hRes = WBEM_E_NOT_AVAILABLE;
	CParsedComponent * pClass = GetClass();
	if(pOut == NULL || pClass == NULL)
		return WBEM_E_INVALID_PARAMETER;

    hRes = pClass->QueryInterface(IID_IWbemPathKeyList, (void **)pOut);
	return hRes;
}

/*++

Routine Description:

  Creates a class part of one does not exist.

Arguments:

  lFlags			-	not used for now, set to 0
  Name				-	name of the class

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::CreateClassPart( 
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	if(lFlags != 0 || Name == NULL)
		return WBEM_E_INVALID_PARAMETER;
	CParsedComponent * pClass = new CParsedComponent(m_pCS);
	if(pClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	
	pClass->m_sClassName = SysAllocString(Name);
	if(pClass->m_sClassName == NULL)
	{
		delete pClass;
		return WBEM_E_OUT_OF_MEMORY;
	}
	m_Components.Add(pClass);

	return S_OK;
}
        
/*++

Routine Description:

  Deletes the class part.

Arguments:

  lFlags			-	Not used for now, set to 0

Return Value:

  S_OK if all is well, else an error code.
	
--*/

HRESULT CDefPathParser::DeleteClassPart( 
            /* [in] */ long lFlags)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	CParsedComponent * pClass = GetClass();
	if(lFlags != 0)
		return WBEM_E_INVALID_PARAMETER;

	if(pClass == NULL)
		return WBEM_E_NOT_FOUND;
	pClass->Release();
	int iSize = m_Components.Size();
	m_Components.RemoveAt(iSize-1);
	return S_OK;
}

/*++

Routine Description:

  Does the actual work of the "Relative" tests.

Arguments:

  wszMachine			-	Local machine name
  wszNamespace          -   Namespace
  bChildreOK            -   If true, then it is OK if the obj
                            path has additional child namespaces

Return Value:

  TRUE if relative, else false
	
--*/

BOOL CDefPathParser::ActualRelativeTest( 
            /* [string][in] */ LPWSTR wszMachine,
            /* [string][in] */ LPWSTR wszNamespace,
                               BOOL bChildrenOK)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;

    if(!IsLocal(wszMachine))
        return FALSE;

    DWORD dwNumNamespaces = GetNumNamespaces();
    if(dwNumNamespaces == 0)
        return TRUE;

    size_t cchTmp = wcslen(wszNamespace) + 1;
    LPWSTR wszCopy = new wchar_t[cchTmp];
    if(wszCopy == NULL)return FALSE;
    StringCchCopyW(wszCopy,cchTmp, wszNamespace);
    LPWSTR wszLeft = wszCopy;
    WCHAR * pToFar = wszCopy + wcslen(wszCopy);

    BOOL bFailed = FALSE;
    for(DWORD i = 0; i < dwNumNamespaces; i++)
    {
		CParsedComponent * pInst = (CParsedComponent *)m_Components[i];

        if(pInst == NULL)
        {
            bFailed = TRUE;
            break;
        }
        
        BSTR bsNS = NULL;
        HRESULT hr = pInst->Unparse(&bsNS, false, true);
        if(FAILED(hr) || bsNS == NULL)
        {
            bFailed = TRUE;
            break;
        }
        CSysFreeMe fm(bsNS);

        if(bChildrenOK && wszLeft >= pToFar)
            return TRUE;

        unsigned int nLen = wcslen(bsNS);
        if(nLen > wcslen(wszLeft))
        {
            bFailed = TRUE;
            break;
        }
        if(i == dwNumNamespaces - 1 && wszLeft[nLen] != 0)
        {
            bFailed = TRUE;
            break;
        }
        if(i != dwNumNamespaces - 1 && wszLeft[nLen] != L'\\' && bChildrenOK == FALSE)
        {
            bFailed = TRUE;
            break;
        }

        wszLeft[nLen] = 0;
        if(wbem_wcsicmp(wszLeft, bsNS))
        {
            bFailed = TRUE;
            break;
        }
        wszLeft += nLen+1;
    }
    delete [] wszCopy;
    return !bFailed;

}

/*++

Routine Description:

  Tests if path is relative to the machine and namespace.

Arguments:

  wszMachine			-	Local machine name
  wszNamespace          -   Namespace

Return Value:

  TRUE if relative, else false
	
--*/

BOOL CDefPathParser::IsRelative( 
            /* [string][in] */ LPWSTR wszMachine,
            /* [string][in] */ LPWSTR wszNamespace)
{
    return ActualRelativeTest(wszMachine, wszNamespace, FALSE);

}

/*++

Routine Description:

  Tests if path is relative to the machine and namespace.

Arguments:

  wszMachine			-	Local machine name
  wszNamespace          -   Namespace
  lFlags                -   flags, not used for now.

Return Value:

  TRUE if relative, or a child namespace. else false
	
--*/

BOOL CDefPathParser::IsRelativeOrChild( 
            /* [string][in] */ LPWSTR wszMachine,
            /* [string][in] */ LPWSTR wszNamespace,
            /* [in] */ long lFlags)
{

    if(lFlags != 0)
        return FALSE;
    return ActualRelativeTest(wszMachine, wszNamespace, TRUE);
}
        
/*++

Routine Description:

  Tests if path is to local machine

Arguments:

  wszMachine			-	Local machine name

Return Value:

  TRUE if local, else false
	
--*/

BOOL CDefPathParser::IsLocal( 
            /* [string][in] */ LPCWSTR wszMachine)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
    return (m_pServer == NULL || !wbem_wcsicmp(m_pServer, L".") ||
        !wbem_wcsicmp(m_pServer, wszMachine));

}

/*++

Routine Description:

  Tests if class name matches test

Arguments:

  wszClassName			-	Local machine name

Return Value:

  TRUE if local, else false
	
--*/

BOOL CDefPathParser::IsSameClassName( 
            /* [string][in] */ LPCWSTR wszClass)
{
    CSafeInCritSec cs(m_pCS->GetCS());
    if(!cs.IsOK())
    	return WBEM_E_OUT_OF_MEMORY;
	CParsedComponent * pClass = GetClass();
    if (pClass == NULL || pClass->m_sClassName == NULL || wszClass == NULL)
        return FALSE;
    return !wbem_wcsicmp(pClass->m_sClassName, wszClass);
}
/*++

Routine Description:

  Returns just the namspace part of the path

Return Value:

  pointer to the result.  Null if failer.  Caller should free.

--*/

LPWSTR CDefPathParser::GetNamespacePart()
{
    LPWSTR lpRet = NULL;
    lpRet = GetPath(0, GetNumNamespaces());
    return lpRet;
}

/*++

Routine Description:

  Returns the parent namespace part.

Return Value:

  pointer to the result.  Null if failer.  Caller should free.
	
--*/

LPWSTR CDefPathParser::GetParentNamespacePart()
{
	DWORD dwNumNS = GetNumNamespaces();
    if (dwNumNS < 2)
        return NULL;
    LPWSTR lpRet = NULL;
    lpRet = GetPath(0, dwNumNS-1);
    return lpRet;
}

long CDefPathParser::GetNumNamespaces()
{
	long lRet = 0;
	for(DWORD dwCnt = 0; dwCnt < (DWORD)m_Components.Size(); dwCnt++)
	{
		CParsedComponent * pInst = (CParsedComponent *)m_Components[dwCnt];
		if(pInst->IsPossibleNamespace())
			lRet++;
		else
			break;
	}
	return lRet;
}


/*++

Routine Description:

  Sorts the keys based on the key name

Return Value:

  TRUE if OK.

--*/

BOOL CDefPathParser::SortKeys()
{
    // Sort the key refs lexically. If there is only
    // one key, there is nothing to sort anyway.
    // =============================================

    BOOL bChanges = FALSE;
    if (m_Components.Size())
    {
        CParsedComponent *pComp = GetLastComponent();
        if (pComp)
        {
            CParsedComponent *pInst = (CParsedComponent *)pComp;

            if (pInst->m_Keys.Size() > 1)
            {        
                while (bChanges)
                {
                    bChanges = FALSE;
                    for (DWORD dwIx = 0; dwIx < (DWORD)pInst->m_Keys.Size() - 1; dwIx++)
                    {
                        CKeyRef * pFirst = (CKeyRef *)pInst->m_Keys[dwIx];
                        CKeyRef * pSecond = (CKeyRef *)pInst->m_Keys[dwIx+1];
                        if (wbem_wcsicmp(pFirst->m_pName, pSecond->m_pName) > 0)
                        {
                            pInst->m_Keys.SetAt(dwIx, pSecond);
                            pInst->m_Keys.SetAt(dwIx+1, pFirst);
                            bChanges = TRUE;
                        }
                    }
                }
            }

        }
    }

    return bChanges;
}

HRESULT CDefPathParser::AddComponent(CParsedComponent * pComp)
{
	if (CFlexArray::no_error == m_Components.Add(pComp))
		return S_OK;
	else
		return WBEM_E_OUT_OF_MEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\wbemerror.cpp ===
/*++



// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    WBEMERROR.CPP

Abstract:

    Implements string table based, error msgs for all of wbem.

History:

    a-khint  5-mar-98       Created.

--*/

#include "precomp.h"
#include "WbemError.h"
#include "commain.h"
#include "resource.h"
#include "wbemcli.h"
#include <stdio.h>

extern HINSTANCE g_hInstance;


//-------------------------------------------------

bool LoadMyString(UINT ID, 
                  LPTSTR str, UINT size, 
                  LPCTSTR def)
{
    bool retval = true;
    if(str)
    {
//      TCHAR *szStr = new TCHAR[size];
        if (LoadString(g_hInstance, ID, str, size) == 0)
        {
            if(def)
                lstrcpyn(str, def, size);
        }
/*      else
        {
            mbstowcs(str, szStr, size);
            retval = true;
        }
*/
//      delete [] szStr;
    }
    return retval;
}

DWORD MyFormatMessage(DWORD dwFlags,
                      LPCVOID lpSource,
                      DWORD dwMessageId,
                      DWORD dwLanguageId,
                      PVOID* lpBuffer,
                      DWORD nSize,
                      va_list *Arguments)
{
    DWORD dwRet = 0;
    PVOID p;
    if(lpBuffer)
    {
        dwRet = FormatMessage(dwFlags|FORMAT_MESSAGE_ALLOCATE_BUFFER,lpSource,dwMessageId,dwLanguageId,(LPTSTR)lpBuffer,
                                nSize,Arguments);
    }
    return dwRet;
}
//-------------------------------------------------
DWORD WbemErrorString(SCODE sc, 
                   PVOID* errMsg, UINT errSize, DWORD dwFlags=FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_FROM_HMODULE)
{
    return MyFormatMessage(dwFlags,
                      g_hInstance, sc, 
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                      errMsg, errSize, NULL);
}

HRESULT CWbemError::GetErrorCodeText(HRESULT hRes,  LCID    LocaleId, long lFlags, BSTR * MessageText)
{
    PVOID errMsg = 0;
    int errSize = 256;
    DWORD dwMsgSize = 0;
    *MessageText = NULL;
	DWORD dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS;

    if(LocaleId != 0 )
        return WBEM_E_INVALID_PARAMETER;

	// If WBEMSTATUS_FORMAT_NO_NEWLINE is specified update FormatMessage mask
	if(lFlags==WBEMSTATUS_FORMAT_NO_NEWLINE)
		dwFlags|=FORMAT_MESSAGE_MAX_WIDTH_MASK;			// No newline mask for FormatMessage
	else if (lFlags!=WBEMSTATUS_FORMAT_NEWLINE)
		return WBEM_E_INVALID_PARAMETER;
	
    // If the facility code is wbem, try loading the error from the wbem strings

    if(SCODE_FACILITY(hRes) == FACILITY_ITF)
        dwMsgSize = WbemErrorString(hRes, &errMsg, errSize, dwFlags|FORMAT_MESSAGE_FROM_HMODULE);

    if(dwMsgSize == 0)
        dwMsgSize = MyFormatMessage(dwFlags|FORMAT_MESSAGE_FROM_SYSTEM,
                      NULL, hRes, 
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                      &errMsg, errSize, NULL);
    if(dwMsgSize > 0)
    {
        *MessageText = SysAllocString((LPCTSTR)errMsg);
	LocalFree(errMsg);
        if(*MessageText)
            return S_OK;
    }
    return WBEM_E_FAILED;
}

HRESULT CWbemError::GetFacilityCodeText(HRESULT sc, LCID    LocaleId, long lFlags, BSTR * MessageText)
{
    TCHAR facility[50];
    int facSize = 50;
    PVOID wTemp = 0;
    bool bLoaded = false;

    *MessageText = NULL;

    if(LocaleId != 0 || lFlags != 0)
        return WBEM_E_INVALID_PARAMETER;

    switch(SCODE_FACILITY(sc))
    {
    case FACILITY_ITF:
        if(WbemErrorString(sc, &wTemp, 256))
        {
            LocalFree(wTemp);
            bLoaded = LoadMyString(IDS_FAC_WBEM, 
                        facility, facSize,
                        __TEXT("WMI"));
            break;
        }
        else
            bLoaded = LoadMyString(IDS_FAC_ITF, 
                        facility, facSize,
                        __TEXT("Interface"));
        break;

    case FACILITY_NULL:
        bLoaded = LoadMyString(IDS_FAC_NULL, 
                    facility, facSize,
                    __TEXT("<Null>"));
        break;

    case FACILITY_RPC:
        bLoaded = LoadMyString(IDS_FAC_RPC, 
                    facility, facSize,
                    __TEXT("RPC"));
        break;

    case FACILITY_STORAGE:
        bLoaded = LoadMyString(IDS_FAC_STORAGE, 
                    facility, facSize,
                    __TEXT("Storage"));
        break;

    case FACILITY_DISPATCH:
        bLoaded = LoadMyString(IDS_FAC_DISPATCH, 
                    facility, facSize,
                    __TEXT("Dispatch"));
        break;

    case FACILITY_WIN32:
        bLoaded = LoadMyString(IDS_FAC_WIN32, 
                    facility, facSize,
                    __TEXT("Win32"));
        break;

    case FACILITY_WINDOWS:
        bLoaded = LoadMyString(IDS_FAC_WINDOWS, 
                    facility, facSize,
                    __TEXT("Windows"));
        break;

    case FACILITY_SSPI:
        bLoaded = LoadMyString(IDS_FAC_SSPI, 
                    facility, facSize,
                    __TEXT("SSPI"));
        break;

    case FACILITY_CONTROL:
        bLoaded = LoadMyString(IDS_FAC_CONTROL, 
                    facility, facSize,
                    __TEXT("Control"));
        // get error msg from the system.
        break;

    case FACILITY_CERT:
        bLoaded = LoadMyString(IDS_FAC_CERT, 
                    facility, facSize,
                    __TEXT("Cert"));
        break;

    case FACILITY_INTERNET:
        bLoaded = LoadMyString(IDS_FAC_INET, 
                    facility, facSize,
                    __TEXT("Internet"));
        break;

    default :
        bLoaded = LoadMyString(IDS_FAC_UNKNOWN, 
                    facility, facSize,
                    __TEXT("General"));
        break;
    } //endswitch

    if(bLoaded)
    {
        *MessageText = SysAllocString(facility);
        if(*MessageText)
            return  S_OK;
    }
    return WBEM_E_FAILED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\wbemerror.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMERROR.H

Abstract:

    Implements string table based, error msgs for all of wbem.

History:

    a-khint  5-mar-98       Created.

--*/

#include "wbemcli.h"
typedef LPVOID * PPVOID;

extern long g_cObj;

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemError
//
//  DESCRIPTION:
//
//  Provides error and facility code info.
//
//***************************************************************************

class CWbemError : IWbemStatusCodeText
{
    protected:
        long           m_cRef;
    public:
        CWbemError(void)
        {
            InterlockedIncrement(&g_cObj);
            m_cRef=1L;
            return;
        };

        ~CWbemError(void)
        {
            InterlockedDecrement(&g_cObj);
            return;
        }

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
        {
            *ppv=NULL;

            if (IID_IUnknown==riid || IID_IWbemStatusCodeText==riid)
                *ppv=this;

            if (NULL!=*ppv)
            {
                AddRef();
                return NOERROR;
            }

            return E_NOINTERFACE;
        };

        STDMETHODIMP_(ULONG) AddRef(void)
        {    
            return ++m_cRef;
        };
        STDMETHODIMP_(ULONG) Release(void)
        {
            long lRef = InterlockedDecrement(&m_cRef);
            if (0L == lRef)
                delete this;
            return lRef;
        };

        HRESULT STDMETHODCALLTYPE GetErrorCodeText(
            HRESULT hRes,
            LCID    LocaleId,
            long    lFlags,
            BSTR   * MessageText);

        HRESULT STDMETHODCALLTYPE GetFacilityCodeText(
            HRESULT hRes,
            LCID    LocaleId,
            long    lFlags,
            BSTR   * MessageText);

        void InitEmpty(){};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\wmiquery.h ===
//***************************************************************************
//
//  WMIQUERY.H
//
//  IWbemQuery, _IWmiQuery implementation
//
//  raymcc  10-Apr-00       Created
//
//***************************************************************************

#ifndef _WMIQUERY_H_
#define _WMIQUERY_H_


#include "genlex.h"
#include "assocqp.h"
#include "wqlnode.h"
#include "wql.h"



class CWmiQuery : public _IWmiQuery
{
    ULONG m_uRefCount;
    CTextLexSource *m_pLexerSrc;
    BOOL m_bParsed;
    CFlexArray m_aClassCache;
    CWQLParser *m_pParser;

    SWbemRpnEncodedQuery *m_pQuery;

    ULONG m_uRestrictedFeatures[WMIQ_LF_LAST];
    ULONG m_uRestrictedFeaturesSize;

public:
        //  IUnknown

        virtual ULONG STDMETHODCALLTYPE AddRef (void);
		virtual ULONG STDMETHODCALLTYPE Release (void);

		virtual HRESULT STDMETHODCALLTYPE QueryInterface (REFIID riid, void **ppv);

        // IWbemQuery

        virtual HRESULT STDMETHODCALLTYPE Empty( void);

        virtual HRESULT STDMETHODCALLTYPE SetLanguageFeatures(
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uArraySize,
            /* [in] */ ULONG __RPC_FAR *puFeatures);

        virtual HRESULT STDMETHODCALLTYPE TestLanguageFeatures(
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *uArraySize,
            /* [out] */ ULONG __RPC_FAR *puFeatures);

        virtual HRESULT STDMETHODCALLTYPE Parse(
            /* [in] */ LPCWSTR pszLang,
            /* [in] */ LPCWSTR pszQuery,
            /* [in] */ ULONG uFlags);

        virtual HRESULT STDMETHODCALLTYPE GetAnalysis(
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pAnalysis
            );

        virtual HRESULT STDMETHODCALLTYPE FreeMemory(
            LPVOID pMem
            );

        virtual HRESULT STDMETHODCALLTYPE GetQueryInfo(
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uInfoId,
            /* [in] */ ULONG uBufSize,
            /* [out] */ LPVOID pDestBuf);


        virtual HRESULT STDMETHODCALLTYPE Dump(LPSTR pszFile);

    CWmiQuery();
    void InitEmpty();   // Used by the CGenFactory<> class factory.


    static HRESULT Startup();
    static HRESULT Shutdown();
    static HRESULT CanUnload();

private:
   ~CWmiQuery();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\wmiquery.cpp ===
//***************************************************************************
//
//  WMIQUERY.CPP
//
//  Query parser implementation
//
//  raymcc      10-Apr-00       Created
//
//***************************************************************************

#include "precomp.h"
#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>
#include "sync.h"
#include "flexarry.h"

#include <wmiutils.h>
#include <wbemint.h>

#include "wmiquery.h"
#include "helpers.h"
#include <like.h>
#include <wqllex.h>

#include <stdio.h>
#include <string.h>
#include "statsync.h"

extern long g_cObj;

#define INVALID     0x3

CStaticCritSec  CS_UserMem;
CFlexArray g_pUserMem;
CStaticCritSec  g_csQPLock;

struct SWmiqUserMem
{
    DWORD  m_dwType;
    LPVOID m_pMem;
};

class BoolStack
{
    BOOL *m_pValues;
    int   nPtr;
public:
    enum { DefaultSize = 256 };

    BoolStack(int nSz)
    {
        m_pValues = new BOOL[nSz];
        nPtr = -1;
    }
    ~BoolStack() { delete m_pValues; }
    void Push(BOOL b){ m_pValues[++nPtr] = b; }
    BOOL Pop() { return m_pValues[nPtr--]; }
    BOOL Peek() { return m_pValues[nPtr]; }
};

//***************************************************************************
//
//***************************************************************************
//
CWmiQuery::CWmiQuery()
{
    m_uRefCount = 1;        // Required by helper in MainDLL.CPP.

    m_pParser = 0;
    m_pLexerSrc = 0;
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//***************************************************************************
//
CWmiQuery::~CWmiQuery()
{
    Empty();
    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
//
//***************************************************************************
//
void CWmiQuery::InitEmpty()
{
//    Empty();
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CWmiQuery::AddRef()
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CWmiQuery::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CWmiQuery::QueryInterface
//
//  Exports IWbemServices interface.
//
//***************************************************************************
//
HRESULT CWmiQuery::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemQuery==riid || IID__IWmiQuery==riid )
    {
        *ppvObj = (_IWmiQuery*)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiQuery::Empty()
{
    CInCritSec ics(&g_csQPLock);

    if (m_pParser)
        delete m_pParser;
    m_pParser = 0;

    if (m_pLexerSrc)
        delete m_pLexerSrc;
    m_pLexerSrc = 0;

    if (m_aClassCache.Size())
    {
        for (int i = 0; i < m_aClassCache.Size(); i++)
        {
            _IWmiObject *pObj = (_IWmiObject *) m_aClassCache[i];
            pObj->Release();
        }

        m_aClassCache.Empty();
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
// *

HRESULT CWmiQuery::SetLanguageFeatures(
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uArraySize,
            /* [in] */ ULONG __RPC_FAR *puFeatures
            )
{
    CInCritSec ics(&g_csQPLock);

    for (ULONG u = 0; u < uArraySize; u++)
    {
        m_uRestrictedFeatures[u] = puFeatures[u];
    }
    m_uRestrictedFeaturesSize = u;

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiQuery::TestLanguageFeatures(
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *uArraySize,
            /* [out] */ ULONG __RPC_FAR *puFeatures
            )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiQuery::Parse(
            /* [in] */ LPCWSTR pszLang,
            /* [in] */ LPCWSTR pszQuery,
            /* [in] */ ULONG uFlags
            )
{
    if (wbem_wcsicmp(pszLang, L"WQL") != 0 && wbem_wcsicmp(pszLang, L"SQL") != 0)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if (pszQuery == 0 || wcslen(pszQuery) == 0)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    CInCritSec ics(&g_csQPLock);

    HRESULT hRes;
    int nRes;

    Empty();

    try
    {
        // Get a text source bound to the query.
        // =====================================

        m_pLexerSrc = new CTextLexSource(pszQuery);
        if (!m_pLexerSrc)
            return WBEM_E_OUT_OF_MEMORY;

        // Check the first token and see which way to branch.
        // ==================================================

        m_pParser = new CWQLParser(LPWSTR(pszQuery), m_pLexerSrc);

        if (!m_pParser)
            return WBEM_E_OUT_OF_MEMORY;

        hRes = m_pParser->Parse();
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiQuery::GetAnalysis(
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pAnalysis
            )
{
    CInCritSec ics(&g_csQPLock);

    int nRes;

    if (!m_pParser)
        return WBEM_E_INVALID_OPERATION;

    if (uAnalysisType == WMIQ_ANALYSIS_RPN_SEQUENCE)
    {
        // Verify it was a select clause.
        // ==============================

        SWQLNode_QueryRoot *pRoot = m_pParser->GetParseRoot();
        if (pRoot->m_dwQueryType != SWQLNode_QueryRoot::eSelect)
            return WBEM_E_INVALID_OPERATION;

        // Encode and record it.
        // =====================

        nRes = m_pParser->GetRpnSequence((SWbemRpnEncodedQuery **) pAnalysis);
        if (nRes != 0)
            return WBEM_E_FAILED;

        SWmiqUserMem *pUM = new SWmiqUserMem;
        if (!pUM)
            return WBEM_E_OUT_OF_MEMORY;

        pUM->m_pMem = *pAnalysis;
        pUM->m_dwType = WMIQ_ANALYSIS_RPN_SEQUENCE;

        EnterCriticalSection(&CS_UserMem);
        g_pUserMem.Add(pUM);
        LeaveCriticalSection(&CS_UserMem);

        return WBEM_S_NO_ERROR;
    }

    else if (uAnalysisType == WMIQ_ANALYSIS_RESERVED)
    {
        SWQLNode *p = m_pParser->GetParseRoot();
        *pAnalysis = p;
        return WBEM_S_NO_ERROR;
    }

    else if (uAnalysisType == WMIQ_ANALYSIS_ASSOC_QUERY)
    {
        SWQLNode_QueryRoot *pRoot = m_pParser->GetParseRoot();
        if (pRoot->m_dwQueryType != SWQLNode_QueryRoot::eAssoc)
            return WBEM_E_INVALID_OPERATION;

        SWQLNode_AssocQuery *pAssocNode = (SWQLNode_AssocQuery *) pRoot->m_pLeft;
        if (!pAssocNode)
            return WBEM_E_INVALID_QUERY;

        SWbemAssocQueryInf *pAssocInf = (SWbemAssocQueryInf *) pAssocNode->m_pAQInf;
        if (!pAssocInf)
            return WBEM_E_INVALID_QUERY;

        *pAnalysis = pAssocInf;

        SWmiqUserMem *pUM = new SWmiqUserMem;
        if (!pUM)
            return WBEM_E_OUT_OF_MEMORY;
        pUM->m_pMem = *pAnalysis;
        pUM->m_dwType = WMIQ_ANALYSIS_ASSOC_QUERY;

        EnterCriticalSection(&CS_UserMem);
        g_pUserMem.Add(pUM);
        LeaveCriticalSection(&CS_UserMem);

        return WBEM_S_NO_ERROR;
    }

    else if (uAnalysisType == WMIQ_ANALYSIS_QUERY_TEXT)
    {
        LPWSTR pszQuery = Macro_CloneLPWSTR(m_pParser->GetQueryText());
        if (!pszQuery)
            return WBEM_E_OUT_OF_MEMORY;

        SWmiqUserMem *pUM = new SWmiqUserMem;
        if (!pUM)
            return WBEM_E_OUT_OF_MEMORY;
        pUM->m_pMem = pszQuery;
        pUM->m_dwType = WMIQ_ANALYSIS_QUERY_TEXT;

        EnterCriticalSection(&CS_UserMem);
        g_pUserMem.Add(pUM);
        LeaveCriticalSection(&CS_UserMem);

        *pAnalysis = pszQuery;

        return WBEM_S_NO_ERROR;
    }

    return WBEM_E_INVALID_PARAMETER;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiQuery::GetQueryInfo(
            /* [in] */ ULONG uAnalysisType,
            /* [in] */ ULONG uInfoId,
            /* [in] */ ULONG uBufSize,
            /* [out] */ LPVOID pDestBuf
            )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//
#ifdef _OLD_
HRESULT CWmiQuery::StringTest(
            /* [in] */ ULONG uTestType,
            /* [in] */ LPCWSTR pszTestStr,
            /* [in] */ LPCWSTR pszExpr
            )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (uTestType == WQL_TOK_LIKE)
    {
        CLike l (pszTestStr);
        BOOL bRet = l.Match(pszExpr);
        if(bRet)
        	hr = S_OK;
        else
        	hr = S_FALSE;
    }
    else
        hr = E_NOTIMPL;

    return hr;
}
#endif


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiQuery::FreeMemory(
    LPVOID pMem
    )
{
    CInCritSec ics(&g_csQPLock);

    // Check to ensure that query root isn't freed.
    // Allow a pass-through as if it succeeded.
    // ============================================

    SWQLNode *p = m_pParser->GetParseRoot();
    if (pMem == p)
        return WBEM_S_NO_ERROR;

    // Find and free the memory.
    // =========================

    HRESULT hRes = WBEM_E_NOT_FOUND;
    EnterCriticalSection(&CS_UserMem);
    for (int i = 0; i < g_pUserMem.Size(); i++)
    {
        SWmiqUserMem *pUM = (SWmiqUserMem *) g_pUserMem[i];
        if (pUM->m_pMem == pMem)
        {
            switch (pUM->m_dwType)
            {
                case WMIQ_ANALYSIS_RPN_SEQUENCE:
                    delete (CWbemRpnEncodedQuery *) pMem;
                    break;

                case WMIQ_ANALYSIS_ASSOC_QUERY:
                    break;

                case WMIQ_ANALYSIS_PROP_ANALYSIS_MATRIX:
                    break;

                case WMIQ_ANALYSIS_QUERY_TEXT:
                    delete LPWSTR(pMem);
                    break;

                case WMIQ_ANALYSIS_RESERVED:
                    // A copy of the internal parser tree pointer.
                    // Leave it alone! Don't delete it!  If you do, I will hunt you down.
                    break;
                default:
                    break;
            }

            delete pUM;
            g_pUserMem.RemoveAt(i);
            hRes = WBEM_S_NO_ERROR;
            break;
        }
    }
    LeaveCriticalSection(&CS_UserMem);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CWmiQuery::Dump(
    LPSTR pszFile
    )
{
    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiQuery::Startup()
{
    return S_OK;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiQuery::Shutdown()
{
    return S_OK;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiQuery::CanUnload()
{
    // Later, track outstanding analysis pointers
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\wql.cpp ===
//***************************************************************************
//
//  WQL.CPP
//
//  WQL Parser
//
//  Implements the LL(1) syntax described in WQL.BNF via a recursive
//  descent parser.
//
//  raymcc    14-Sep-97       Created for WMI/SMS.
//  raymcc    18-Oct-97       Additional extensions for SMS team.
//  raymcc    20-Apr-00       Whistler RPN extensions
//  raymcc    19-May-00       Whistler delete/insert/update extensions
//
//***************************************************************************
// TO DO:

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <flexarry.h>

#include <wqllex.h>

#include <wqlnode.h>
#include <wql.h>
#include <helpers.h>

#include "wmiquery.h"
#include <corex.h>
#include <memory>
#include <autoptr.h>
#include <math.h>
#include <comdef.h>


void __stdcall _com_issue_error(long hResult) { throw hResult;};

POLARITY BOOL ReadI64(LPCWSTR wsz, UNALIGNED __int64& ri64);
POLARITY BOOL ReadUI64(LPCWSTR wsz, UNALIGNED unsigned __int64& rui64);


//***************************************************************************
//
//   Misc
//
//***************************************************************************
//

static DWORD FlipOperator(DWORD dwOp);

#define trace(x) printf x

void StrArrayDelete(ULONG, LPWSTR *);

HRESULT StrArrayCopy(
    ULONG  uSize,
    LPWSTR *pSrc,
    LPWSTR **pDest
    );

//***************************************************************************
//
//  CloneLPWSTR
//
//***************************************************************************
//  ok
static LPWSTR CloneLPWSTR(LPCWSTR pszSrc)
{
    if (pszSrc == 0) return 0;
    size_t cchTmp = wcslen(pszSrc) + 1;
    LPWSTR pszTemp = new wchar_t[cchTmp];
    if (pszTemp ) memcpy(pszTemp, pszSrc,cchTmp*sizeof(wchar_t));
    return pszTemp;
}

static LPWSTR Clone(LPCWSTR pszSrc)
{
    if (pszSrc == 0) return 0;
    size_t cchTmp = wcslen(pszSrc) + 1;
    LPWSTR pszTemp = new wchar_t[cchTmp];
    if (pszTemp ) memcpy(pszTemp, pszSrc,cchTmp*sizeof(wchar_t));
    else throw CX_MemoryException();
    return pszTemp;
}

//***************************************************************************
//
//  CloneFailed
//
//***************************************************************************

bool inline CloneFailed(LPCWSTR p1, LPCWSTR p2)
{
	if (0 == p1 && 0 == p2 ) return false;
    if (p1 && p2) return false;
	return true;
}

//***************************************************************************
//
//  CWQLParser::CWQLParser
//
//  Constructor
//
//  Parameters:
//  <pSrc>          A source from which to lex from.
//
//***************************************************************************
//
CWQLParser::CWQLParser(
    LPWSTR pszQueryText,
    CGenLexSource *pSrc
    )
{
    if (pszQueryText == 0 || pSrc == 0)
        throw CX_Exception();

    m_pLexer = new CGenLexer(WQL_LexTable, pSrc);
    if (m_pLexer == 0)
        throw CX_Exception();

    m_pszQueryText = CloneLPWSTR(pszQueryText);
    if (m_pszQueryText == 0 && pszQueryText!=0 )
    {
        delete m_pLexer;
        m_pLexer = 0;
        throw CX_Exception();
    }

    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;

    m_uFeatures = 0I64;

    m_pQueryRoot = 0;
    m_pRootWhere = 0;
    m_pRootColList = 0;
    m_pRootFrom = 0;
    m_pRootWhereOptions = 0;
    m_nParseContext = Ctx_Default;

    m_bAllowPromptForConstant = false;
}

//***************************************************************************
//
//  CWQLParser::~CWQLParser
//
//***************************************************************************
//
CWQLParser::~CWQLParser()
{
    Empty();
    delete m_pLexer;
}

//***************************************************************************
//
//  CWQLParser::Empty
//
//***************************************************************************
// ok
void CWQLParser::Empty()
{
    m_aReferencedTables.Empty();
    m_aReferencedAliases.Empty();

    m_pTokenText = 0;   // We don't delete this, it was never allocated
    m_nLine = 0;
    m_nCurrentToken = 0;
    m_uFeatures = 0I64;

    delete m_pQueryRoot;    // Clean up previous query, if any

    m_pQueryRoot = 0;
    m_pRootWhere = 0;
    m_pRootColList = 0;
    m_pRootFrom = 0;
    m_pRootWhereOptions = 0;
    m_nParseContext = Ctx_Default;

    // For the next two, we don't delete the pointers since they
    // were copies of structs elsewhere in the tree.
    // =========================================================

    m_aSelAliases.Empty();
    m_aSelColumns.Empty();

    delete [] m_pszQueryText;
}

//***************************************************************************
//
//  CWQLParser::GetTokenLong
//
//  Converts the current token to a 32/64 bit integer.  Returns info
//  about the size of the constant.
//
//***************************************************************************
// ok
BOOL CWQLParser::GetIntToken(
    OUT BOOL *bSigned,
    OUT BOOL *b64Bit,
    OUT unsigned __int64 *pVal
    )
{
    BOOL bRes;

    if (m_pTokenText == 0 || *m_pTokenText == 0)
        return FALSE;

    if (*m_pTokenText == L'-')
    {
        __int64 Temp;
        bRes = ReadI64(m_pTokenText, Temp);
        if (bRes == FALSE)
            return FALSE;
        *bSigned = TRUE;
        if (Temp <  -2147483648I64)
        {
            *b64Bit = TRUE;
        }
        else
        {
            *b64Bit = FALSE;
        }
        *pVal = (unsigned __int64) Temp;
    }
    else
    {
        bRes = ReadUI64(m_pTokenText, *pVal);
        if (bRes == FALSE)
            return FALSE;
        *bSigned = FALSE;
        if (*pVal >> 32)
        {
            *b64Bit = TRUE;
            if (*pVal <= 0x7FFFFFFFFFFFFFFFI64)
            {
                *bSigned = TRUE;
            }
        }
        else
        {
            *b64Bit = FALSE;

            // See if we can dumb down to 32-bit VT_I4 for simplicity.
            // Much code recognizes VT_I4 and doesn't recognize VT_UI4
            // because it can't be packed into a VARIANT.  So, if there
            // are only 31 bits used, let's convert to VT_I4. We do this
            // by returning this as a 'signed' value (the positive sign :).

            if (*pVal <= 0x7FFFFFFF)
            {
                *bSigned = TRUE;
            }
        }
    }


    return TRUE;
}

//***************************************************************************
//
//  CWQLParser::GetReferencedTables
//
//  Creates an array of the names of the tables referenced in this query
//
//***************************************************************************
// ok
BOOL CWQLParser::GetReferencedTables(OUT CWStringArray& Tables)
{
    Tables = m_aReferencedTables;
    return TRUE;
}

//***************************************************************************
//
//  CWQLParser::GetReferencedAliases
//
//***************************************************************************
// ok
BOOL CWQLParser::GetReferencedAliases(OUT CWStringArray & Aliases)
{
    Aliases = m_aReferencedAliases;
    return TRUE;
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************
// ok
struct WqlKeyword
{
    LPWSTR m_pKeyword;
    int    m_nTokenCode;
};

static WqlKeyword KeyWords[] =      // Keep this alphabetized for binary search
{
    L"ALL",         WQL_TOK_ALL,
    L"AND",         WQL_TOK_AND,
    L"AS",          WQL_TOK_AS,
    L"ASC",         WQL_TOK_ASC,
    L"ASSOCIATORS", WQL_TOK_ASSOCIATORS,
    L"BETWEEN",     WQL_TOK_BETWEEN,
    L"BY",       WQL_TOK_BY,
    L"COUNT",    WQL_TOK_COUNT,
    L"DATEPART", WQL_TOK_DATEPART,
    L"DELETE",   WQL_TOK_DELETE,
    L"DESC",     WQL_TOK_DESC,
    L"DISTINCT", WQL_TOK_DISTINCT,
    L"FROM",     WQL_TOK_FROM,
    L"FULL",     WQL_TOK_FULL,
    L"GROUP",    WQL_TOK_GROUP,
    L"HAVING",   WQL_TOK_HAVING,
    L"IN",       WQL_TOK_IN,
    L"INNER",    WQL_TOK_INNER,
    L"INSERT",   WQL_TOK_INSERT,
    L"IS",   	 WQL_TOK_IS,    
    L"ISA",      WQL_TOK_ISA,
    L"ISNULL",   WQL_TOK_ISNULL,
    L"JOIN",     WQL_TOK_JOIN,
    L"LEFT",     WQL_TOK_LEFT,
    L"LIKE",     WQL_TOK_LIKE,
    L"LOWER",    WQL_TOK_LOWER,
    L"NOT",      WQL_TOK_NOT,
    L"NULL",     WQL_TOK_NULL,
    L"ON",       WQL_TOK_ON,
    L"OR",       WQL_TOK_OR,
    L"ORDER",    WQL_TOK_ORDER,
    L"OUTER",           WQL_TOK_OUTER,
    L"__QUALIFIER",     WQL_TOK_QUALIFIER,
    L"REFERENCES",      WQL_TOK_REFERENCES,
    L"RIGHT",           WQL_TOK_RIGHT,
    L"SELECT",   WQL_TOK_SELECT,
    L"__THIS",   WQL_TOK_THIS,
    L"UPDATE",   WQL_TOK_UPDATE,
    L"UPPER",    WQL_TOK_UPPER,
    L"WHERE",    WQL_TOK_WHERE
};

const int NumKeywords = sizeof(KeyWords)/sizeof(WqlKeyword);

BOOL CWQLParser::Next()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == WQL_TOK_ERROR
        || (m_nCurrentToken == WQL_TOK_PROMPT && !m_bAllowPromptForConstant))
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == WQL_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check. Do a binary search
    // on the keyword table.
    // =================================

    if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        int l = 0, u = NumKeywords - 1;

        while (l <= u)
        {
            int m = (l + u) / 2;
            if (wbem_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) < 0)
                u = m - 1;
            else if (wbem_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) > 0)
                l = m + 1;
            else        // Match
            {
                m_nCurrentToken = KeyWords[m].m_nTokenCode;
                break;
            }
        }
    }

    return TRUE;
}


//***************************************************************************
//
//  <parse> ::= SELECT <select_stmt>;
//          ::= DELETE <delete_stmt>;
//          ::= INSERT <insert_stmt>;
//          ::= UPDATE <update_stmt>;
//
//  Precondition: All cleanup has been performed from previous parse
//                by a call to Empty()
//
//***************************************************************************
// ok
HRESULT CWQLParser::Parse()
{
    HRESULT hRes = WBEM_E_INVALID_SYNTAX;

    m_pQueryRoot = new SWQLNode_QueryRoot;
    if (!m_pQueryRoot)
        return WBEM_E_OUT_OF_MEMORY;

    try
    {
        m_pLexer->Reset();

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        // See which kind of query we have.
        // ================================

        switch (m_nCurrentToken)
        {
            case WQL_TOK_SELECT:
                {
                    if (!Next())
                        return WBEM_E_INVALID_SYNTAX;

                    SWQLNode_Select *pSelStmt = 0;
                    hRes = select_stmt(&pSelStmt);
                    if (FAILED(hRes))
                        return hRes;
                    m_pQueryRoot->m_pLeft = pSelStmt;
                    m_pQueryRoot->m_dwQueryType = SWQLNode_QueryRoot::eSelect;
                }
                break;

            case WQL_TOK_ASSOCIATORS:
            case WQL_TOK_REFERENCES:
                {
                    SWQLNode_AssocQuery *pAQ = 0;
                    hRes = assocquery(&pAQ);
                    if (FAILED(hRes))
                        return hRes;
                    m_pQueryRoot->m_pLeft = pAQ;
                    m_pQueryRoot->m_dwQueryType = SWQLNode_QueryRoot::eAssoc;
                }
                break;

            case WQL_TOK_INSERT:
                {
                    if (!Next())
                        return WBEM_E_INVALID_SYNTAX;
                    SWQLNode_Insert *pIns = 0;
                    hRes = insert_stmt(&pIns);
                    if (FAILED(hRes))
                        return hRes;
                    m_pQueryRoot->m_pLeft = pIns;
                    m_pQueryRoot->m_dwQueryType = SWQLNode_QueryRoot::eInsert;
                }
                break;

            case WQL_TOK_DELETE:
                {
                    if (!Next())
                        return WBEM_E_INVALID_SYNTAX;

                    SWQLNode_Delete *pDel = 0;
                    hRes = delete_stmt(&pDel);
                    if (FAILED(hRes))
                        return hRes;
                    m_pQueryRoot->m_pLeft = pDel;
                    m_pQueryRoot->m_dwQueryType = SWQLNode_QueryRoot::eDelete;
                }
                break;

            case WQL_TOK_UPDATE:
                {
                    if (!Next())
                        return WBEM_E_INVALID_SYNTAX;

                    SWQLNode_Update *pUpd = 0;
                    hRes = update_stmt(&pUpd);
                    if (FAILED(hRes))
                        return hRes;
                    m_pQueryRoot->m_pLeft = pUpd;
                    m_pQueryRoot->m_dwQueryType = SWQLNode_QueryRoot::eUpdate;
                }
                break;

            default:
                return WBEM_E_INVALID_SYNTAX;
        }
    }
    catch (CX_MemoryException)
    {
        hRes = WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        hRes = WBEM_E_CRITICAL_ERROR;
    }

    return hRes;
}

//***************************************************************************
//
//  <select_stmt> ::=
//      <select_type>
//      <col_ref_list>
//      <from_clause>
//      <where_clause>
//
//***************************************************************************
// ok
int CWQLParser::select_stmt(OUT SWQLNode_Select **pSelStmt)
{
    int nRes = 0;
    int nType = 0;
    SWQLNode_FromClause *pFrom = 0;
    SWQLNode_Select *pSel = 0;
    SWQLNode_TableRefs *pTblRefs = 0;
    SWQLNode_WhereClause *pWhere = 0;

    *pSelStmt = 0;

    // Set up the basic AST.
    // =====================

    pSel = new SWQLNode_Select;
    if (!pSel)
        return WBEM_E_OUT_OF_MEMORY;
    pTblRefs = new SWQLNode_TableRefs;
    if (!pTblRefs)
    {
        delete pSel;
        return WBEM_E_OUT_OF_MEMORY;
    }
    pSel->m_pLeft = pTblRefs;

    // Get the select type.
    // ====================

    nRes = select_type(nType);
    if (nRes)
        goto Exit;

    pTblRefs->m_nSelectType = nType;        // ALL, DISTINCT

    // Get the selected list of columns.
    // =================================

    nRes = col_ref_list(pTblRefs);
    if (nRes)
        goto Exit;

    m_pRootColList = (SWQLNode_ColumnList *) pTblRefs->m_pLeft;

    // Get the FROM clause and patch it into the AST.
    // ===============================================

    nRes = from_clause(&pFrom);
    if (nRes)
        goto Exit;

    m_pRootFrom = pFrom;
    pTblRefs->m_pRight = pFrom;

    // Get the WHERE clause.
    // =====================

    nRes = where_clause(&pWhere);
    if (nRes)
        goto Exit;

    m_pRootWhere = pWhere;
    pSel->m_pRight = pWhere;

    // Verify we are at the end of the query.
    // ======================================

    if (m_nCurrentToken != WQL_TOK_EOF)
    {
        nRes = WBEM_E_INVALID_SYNTAX;
        goto Exit;
    }

    nRes = NO_ERROR;

Exit:
    if (nRes)
        delete pSel;
    else
    {
        *pSelStmt = pSel;
    }

    return nRes;
}

//***************************************************************************
//
//  CWQLParser::delete_stmt
//
//***************************************************************************
// ok
int CWQLParser::delete_stmt(OUT SWQLNode_Delete **pDelStmt)
{
    int nRes = 0;
    int nType = 0;
    SWQLNode_TableRef *pTblRef = 0;
    SWQLNode_WhereClause *pWhere = 0;

    // Default in case of error.
    // =========================

    *pDelStmt = 0;

    if (m_nCurrentToken != WQL_TOK_FROM)
        return WBEM_E_INVALID_SYNTAX;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    // Otherwise, traditional SQL.
    // ===========================

    nRes = single_table_decl(&pTblRef);
    if (nRes)
        return nRes;

    // Get the WHERE clause.
    // =====================

    nRes = where_clause(&pWhere);
    if (nRes)
    {
        delete pTblRef;
        return nRes;
    }

    // Verify we are at the end of the query.
    // ======================================

    if (m_nCurrentToken != WQL_TOK_EOF)
    {
        nRes = WBEM_E_INVALID_SYNTAX;
        delete pTblRef;
        delete pWhere;
    }
    else
    {
        // If here, everything is wonderful.
        // ==================================

        SWQLNode_Delete *pDel = new SWQLNode_Delete;
        if (!pDel)
        {
            // Except that we might have just run out of memory...
            // ====================================================

            delete pTblRef;
            delete pWhere;
            return WBEM_E_OUT_OF_MEMORY;
        }

        // Patch in the new node.
        // =====================

        pDel->m_pLeft = pTblRef;
        pDel->m_pRight = pWhere;
        *pDelStmt = pDel;
        nRes = WBEM_S_NO_ERROR;
    }

    return nRes;
}


//***************************************************************************
//
//  <select_type> ::= ALL;
//  <select_type> ::= DISTINCT;
//  <select_type> ::= <>;
//
//  Returns type through nSelType :
//      WQL_TOK_ALL or WQL_TOK_DISTINCT
//
//***************************************************************************
// done

int CWQLParser::select_type(int & nSelType)
{
    nSelType = WQL_FLAG_ALL;        // Default

    if (m_nCurrentToken == WQL_TOK_ALL)
    {
        nSelType = WQL_FLAG_ALL;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_DISTINCT)
    {
        nSelType = WQL_FLAG_DISTINCT;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        return NO_ERROR;
    }

    return NO_ERROR;
}

//***************************************************************************
//
//  <col_ref_list> ::= <col_ref> <col_ref_rest>;
//  <col_ref_list> ::= ASTERISK;
//  <col_ref_list> ::= COUNT <count_clause>;
//
//***************************************************************************
// ?
int CWQLParser::col_ref_list(
    IN OUT SWQLNode_TableRefs *pTblRefs
    )
{
    int nRes;
    DWORD dwFuncFlags = 0;

    // Allocate a new left node of type SWQLNode_ColumnList and patch it in
    // if it doesn't already exist.
    // =====================================================================

    SWQLNode_ColumnList *pColList = (SWQLNode_ColumnList *) pTblRefs->m_pLeft;

    if (pColList == NULL)
    {
        pColList = new SWQLNode_ColumnList;
        if (!pColList)
            return WBEM_E_OUT_OF_MEMORY;
        pTblRefs->m_pLeft = pColList;
    }


    // If here, it is a "select *..." query.
    // =====================================

    if (m_nCurrentToken == WQL_TOK_ASTERISK)
    {
        // Allocate a new column list which has a single asterisk.
        // =======================================================

        SWQLColRef *pColRef = new SWQLColRef;
        if (!pColRef)
            return WBEM_E_OUT_OF_MEMORY;

        pColRef->m_pColName = CloneLPWSTR(L"*");
        if (pColRef->m_pColName == 0)
        {
            delete pColRef;
            return WBEM_E_OUT_OF_MEMORY;
        }

        m_uFeatures |= WMIQ_RPNF_FEATURE_SELECT_STAR;

        pColRef->m_dwFlags = WQL_FLAG_ASTERISK;

        if (pColList->m_aColumnRefs.Add(pColRef) != CFlexArray::no_error)
        {
            delete pColRef;
            return WBEM_E_OUT_OF_MEMORY;
        };

        if (!Next())
        {
           return WBEM_E_INVALID_SYNTAX;
        }

        return NO_ERROR;
    }

    // If here, we have a "select COUNT..." operation.
    // ===============================================

    if (m_nCurrentToken == WQL_TOK_COUNT)
    {
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        SWQLQualifiedName *pQN = 0;
        nRes = count_clause(&pQN);
        if (!nRes)
        {
            pTblRefs->m_nSelectType |= WQL_FLAG_COUNT;

            SWQLColRef *pCR = 0;
            if (SUCCEEDED(nRes = QNameToSWQLColRef(pQN, &pCR)))
            {
                if (pColList->m_aColumnRefs.Add(pCR))
                {
                    delete pCR;
                    return WBEM_E_OUT_OF_MEMORY;
                }
            }

            return nRes;
        }
        else
        {
            // This may be a column named count
            // in which case the current token is
            // either an ident or "from"

            if (m_nCurrentToken == WQL_TOK_FROM ||
                m_nCurrentToken == WQL_TOK_COMMA)
            {
                wmilib::auto_ptr<SWQLColRef> pCR = wmilib::auto_ptr<SWQLColRef>(new SWQLColRef);

                if (pCR.get())
                {
                    pCR->m_pColName = CloneLPWSTR(L"count");
                    if (pCR->m_pColName == 0)
                        return WBEM_E_OUT_OF_MEMORY;
                    if (pColList->m_aColumnRefs.Add(pCR.get()) != CFlexArray::no_error)
                        return WBEM_E_OUT_OF_MEMORY;
                    pCR.release();
                }
                else
                    return WBEM_E_OUT_OF_MEMORY;

                if (WQL_TOK_FROM == m_nCurrentToken)
                    return 0;
                else
                {
                    return col_ref_rest(pTblRefs);
                }
            }
            else
                return WBEM_E_INVALID_SYNTAX;
        }
    }

    // Make a provision for wrapping the
    // column in a function all UPPER or LOWER
    // =======================================

    if (m_nCurrentToken == WQL_TOK_UPPER)
        dwFuncFlags = WQL_FLAG_FUNCTIONIZED | WQL_FLAG_UPPER;
    else if (m_nCurrentToken == WQL_TOK_LOWER)
        dwFuncFlags = WQL_FLAG_FUNCTIONIZED | WQL_FLAG_LOWER;

    if (dwFuncFlags)
    {
        // Common procedure for cases where UPPER or LOWER are used.

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return WBEM_E_INVALID_SYNTAX;

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
    }


    // If here, must be an identifier.
    // ===============================

    if (m_nCurrentToken != WQL_TOK_IDENT)
        return WBEM_E_INVALID_SYNTAX;

    SWQLQualifiedName *pInitCol = 0;

    nRes = col_ref(&pInitCol);
    if (nRes)
        return nRes;

    wmilib::auto_ptr<SWQLQualifiedName> initCol(pInitCol);

    SWQLColRef *pCR = 0;
    nRes = QNameToSWQLColRef(initCol.get(), &pCR);
    if (nRes)
    	return nRes;

    initCol.release();

    pCR->m_dwFlags |= dwFuncFlags;

    if (dwFuncFlags)
    {
        // If a function call was invoked, remove the trailing paren.
        // ==========================================================

        if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
            return WBEM_E_INVALID_SYNTAX;

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
    }

    pColList->m_aColumnRefs.Add(pCR);

    m_uFeatures |= WMIQ_RPNF_PROJECTION;

    return col_ref_rest(pTblRefs);
}


//***************************************************************************
//
//  <count_clause> ::= OPEN_PAREN <count_col> CLOSE_PAREN;
//  <count_col> ::= ASTERISK;
//  <count_col> ::= IDENT;
//
//  On NO_ERROR returns:
//  <bAsterisk> set to TRUE if a * occurred in the COUNT clause,
//  or <bAsterisk> set to FALSE and <pQualName> set to point to the
//  qualified name of the column referenced.
//
//***************************************************************************
// ok
int CWQLParser::count_clause(
    OUT SWQLQualifiedName **pQualName
    )
{
    int nRes;
    *pQualName = 0;

    // Syntax check.
    // =============
    if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    // Determine whether an asterisk was used COUNT(*) or
    // a col-ref COUNT(col-ref)
    // ==================================================

    if (m_nCurrentToken == WQL_TOK_ASTERISK)
    {
        SWQLQualifiedName *pQN = new SWQLQualifiedName;
        if (!pQN)
            return WBEM_E_OUT_OF_MEMORY;
        SWQLQualifiedNameField *pQF = new SWQLQualifiedNameField;
        if (!pQF)
        {
            delete pQN;
            return WBEM_E_OUT_OF_MEMORY;
        }
        pQF->m_pName = CloneLPWSTR(L"*");
        if (pQF->m_pName == 0)
        {
            delete pQN;
            delete pQF;
            return WBEM_E_OUT_OF_MEMORY;
        }
        pQN->Add(pQF);
        *pQualName = pQN;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        m_uFeatures |= WMIQ_RPNF_COUNT_STAR;
    }
    else if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        SWQLQualifiedName *pQN = 0;
        nRes = col_ref(&pQN);
        if (nRes)
            return nRes;
        *pQualName = pQN;
    }

    // Check for errors in syntax and clean up
    // if so.
    // =======================================

    if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
    {
        if (*pQualName)
            delete *pQualName;
        *pQualName = 0;
        return WBEM_E_INVALID_SYNTAX;
    }

    if (!Next())
    {
        if (*pQualName)
            delete *pQualName;
        *pQualName = 0;
        return WBEM_E_INVALID_SYNTAX;
    }

    return NO_ERROR;
}


//***************************************************************************
//
//  <col_ref_rest> ::= COMMA <col_ref_list>;
//  <col_ref_rest> ::= <>;
//
//***************************************************************************

int CWQLParser::col_ref_rest(IN OUT SWQLNode_TableRefs *pTblRefs)
{
    int nRes;

    if (m_nCurrentToken != WQL_TOK_COMMA)
        return NO_ERROR;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    nRes = col_ref_list(pTblRefs);
    return nRes;
}

//***************************************************************************
//
//  <from_clause> ::= <table_list>;
//  <from_clause> ::= <wmi_scoped_select>;
//
//  <table_list> ::= <single_table_decl> <optional_join>;
//
//  <optional_join> ::= <sql89_join_entry>;
//  <optional_join> ::= <sql92_join_entry>;
//
//  <optional_join> ::= <>;     // Unary query
//
//***************************************************************************

int CWQLParser::from_clause(OUT SWQLNode_FromClause **pFrom)
{
    int nRes = 0;
    SWQLNode_TableRef *pTbl = 0;
    std::auto_ptr<SWQLNode_FromClause> pFC (new SWQLNode_FromClause);
    if (pFC.get() == 0)
        return WBEM_E_OUT_OF_MEMORY;

    if (m_nCurrentToken != WQL_TOK_FROM)
    {
        return WBEM_E_INVALID_SYNTAX;
    }
    if (!Next())
    {
        return WBEM_E_INVALID_SYNTAX;
    }

    // Special case for WMI scope selections.
    // ======================================

    if (m_nCurrentToken == WQL_TOK_BRACKETED_STRING)
    {
        nRes = wmi_scoped_select (pFC.get ());
        *pFrom = pFC.release();
        return nRes;
    }

    // Otherwise, traditional SQL.
    // ===========================

    nRes = single_table_decl(&pTbl);
    if (nRes)
    {
        return nRes;
    }

    // Check for joins.
    // ===============

    if (m_nCurrentToken == WQL_TOK_COMMA)
    {
        SWQLNode_Sql89Join *pJoin = 0;
        nRes = sql89_join_entry(pTbl, &pJoin);
        if (nRes)
        {
            return nRes;
        }
        pFC->m_pLeft = pJoin;
    }
    else
    {

        if (m_nCurrentToken == WQL_TOK_INNER ||
            m_nCurrentToken == WQL_TOK_FULL  ||
            m_nCurrentToken == WQL_TOK_LEFT  ||
            m_nCurrentToken == WQL_TOK_RIGHT ||
            m_nCurrentToken == WQL_TOK_JOIN
            )
        {
            SWQLNode_Join *pJoin = 0;
            nRes = sql92_join_entry(pTbl, &pJoin);
            if (nRes)
            {
                return nRes;
            }
            pFC->m_pLeft = pJoin;
        }

        // Single table select (unary query).
        // ==================================
        else
        {
            pFC->m_pLeft = pTbl;
        }
    }

    *pFrom = pFC.release();

    return NO_ERROR;
}

//***************************************************************************
//
//  wmi_scoped_select
//
//  '[' objectpath ']'  <class-list>
//
//  <class-list> ::= CLASS
//  <class-list> ::= '{' class1, class2, ...classn '}'
//
//***************************************************************************
//
int CWQLParser::wmi_scoped_select(SWQLNode_FromClause *pFC)
{
    // Strip all input up to the next closing bracket.
    // ===============================================

    SWQLNode_WmiScopedSelect *pSS = new SWQLNode_WmiScopedSelect;
    if (!pSS)
        throw CX_MemoryException();

    pSS->m_pszScope = CloneLPWSTR(m_pTokenText);
    if (!pSS->m_pszScope)
    {
        delete pSS;
        throw CX_MemoryException();
    }

    if (!Next())
        goto Error;

    if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        // Get simple class name.
        // ======================

        LPWSTR pszTmp = CloneLPWSTR(m_pTokenText);
        if (pszTmp == 0)
        {
            delete pSS;
            return WBEM_E_OUT_OF_MEMORY;
        }
        pSS->m_aTables.Add(pszTmp);

        if (!Next())
            goto Error;
    }
    else if (m_nCurrentToken == WQL_TOK_OPEN_BRACE)
    {
        while(1)
        {
            if (!Next())
               goto Error;
            if (m_nCurrentToken == WQL_TOK_IDENT)
            {
                LPWSTR pszTmp = CloneLPWSTR(m_pTokenText);
                if (pszTmp == 0)
                {
                    delete pSS;
                    return WBEM_E_OUT_OF_MEMORY;
                }
                pSS->m_aTables.Add(pszTmp);
            }
            else
                goto Error;
            if (!Next())
               goto Error;
            if (m_nCurrentToken == WQL_TOK_CLOSE_BRACE)
                break;
            if (m_nCurrentToken == WQL_TOK_COMMA)
                continue;
        }
        if (!Next())
            goto Error;
    }

    // Patch in the node.
    // ==================

    pFC->m_pRight = pSS;
    return NO_ERROR;

Error:
    delete pSS;
    return WBEM_E_INVALID_SYNTAX;
}


//***************************************************************************
//
//  <sql89_join_entry> ::= COMMA <sql89_join_list>;
//
//***************************************************************************


int CWQLParser::sql89_join_entry(IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Sql89Join **pJoin )
{
    if (m_nCurrentToken != WQL_TOK_COMMA)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    return sql89_join_list(pInitialTblRef, pJoin);
}

//***************************************************************************
//
//  <sql89_join_list> ::= <single_table_decl> <sql89_join_rest>;
//
//  <sql89_join_rest> ::= COMMA <sql89_join_list>;
//  <sql89_join_rest> ::= <>;
//
//***************************************************************************

int CWQLParser::sql89_join_list(IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Sql89Join **pJoin )
{
    int nRes;

    SWQLNode_Sql89Join *p89Join = new SWQLNode_Sql89Join;
    if (!p89Join)
        return WBEM_E_OUT_OF_MEMORY;

    p89Join->m_aValues.Add(pInitialTblRef);

    while (1)
    {
        SWQLNode_TableRef *pTR = 0;
        nRes = single_table_decl(&pTR);
        if (nRes)
        {
            delete p89Join;
            return nRes;
        }
        p89Join->m_aValues.Add(pTR);
        if (m_nCurrentToken != WQL_TOK_COMMA)
            break;
        if (!Next())
        {
            delete p89Join;
            return WBEM_E_INVALID_SYNTAX;
        }
    }

    *pJoin = p89Join;

    return NO_ERROR;
}

//***************************************************************************
//
//  <where_clause> ::= WQL_TOK_WHERE <rel_expr> <where_options>;
//  <where_clause> ::= <>;          // 'where' is not required
//
//***************************************************************************
// done

int CWQLParser::where_clause(OUT SWQLNode_WhereClause **pRetWhere)
{
    SWQLNode_WhereClause *pWhere = new SWQLNode_WhereClause;
    if (!pWhere)
        return WBEM_E_OUT_OF_MEMORY;

    *pRetWhere = pWhere;
    SWQLNode_RelExpr *pRelExpr = 0;
    int nRes;

    // 'where' is optional.
    // ====================

    if (m_nCurrentToken == WQL_TOK_WHERE)
    {
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        m_uFeatures |= WMIQ_RPNF_WHERE_CLAUSE_PRESENT;

        // Get the primary relational expression for the 'where' clause.
        // =============================================================
        nRes = rel_expr(&pRelExpr);
        if (nRes)
        {
            delete pRelExpr;
            return nRes;
        }
    }

    // Get the options, such as ORDER BY, GROUP BY, etc.
    // =================================================

    SWQLNode_WhereOptions *pWhereOpt = 0;
    nRes = where_options(&pWhereOpt);
    if (nRes)
    {
        delete pRelExpr;
        delete pWhereOpt;
        return nRes;
    }

    pWhere->m_pLeft = pRelExpr;
    pWhere->m_pRight = pWhereOpt;
    m_pRootWhereOptions = pWhereOpt;

    return NO_ERROR;
}

//***************************************************************************
//
//  <where_options> ::=
//      <group_by_clause>
//      <order_by_clause>
//
//***************************************************************************
// done

int CWQLParser::where_options(OUT SWQLNode_WhereOptions **pRetWhereOpt)
{
    int nRes;
    *pRetWhereOpt = 0;

    SWQLNode_GroupBy *pGroupBy = 0;
    nRes = group_by_clause(&pGroupBy);
    if (nRes)
    {
        delete pGroupBy;
        return nRes;
    }

    SWQLNode_OrderBy *pOrderBy = 0;
    nRes = order_by_clause(&pOrderBy);
    if (nRes)
    {
        delete pOrderBy;
        delete pGroupBy;
        return nRes;
    }

    SWQLNode_WhereOptions *pWhereOpt = 0;

    if (pGroupBy || pOrderBy)
    {
        pWhereOpt = new SWQLNode_WhereOptions;
        if (!pWhereOpt)
        {
            delete pOrderBy;
            delete pGroupBy;
            return WBEM_E_OUT_OF_MEMORY;
        }
        pWhereOpt->m_pLeft = pGroupBy;
        pWhereOpt->m_pRight = pOrderBy;
    }

    *pRetWhereOpt = pWhereOpt;
    return NO_ERROR;
}


//***************************************************************************
//
//  <group_by_clause> ::= WQL_TOK_GROUP WQL_TOK_BY <col_list> <having_clause>;
//  <group_by_clause> ::= <>;
//
//***************************************************************************
// done

int CWQLParser::group_by_clause(OUT SWQLNode_GroupBy **pRetGroupBy)
{
    int nRes;
    *pRetGroupBy = 0;

    if (m_nCurrentToken != WQL_TOK_GROUP)
        return NO_ERROR;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;
    if (m_nCurrentToken != WQL_TOK_BY)
        return WBEM_E_INVALID_SYNTAX;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    // Get the guts of the GROUP BY.
    // =============================

    SWQLNode_GroupBy *pGroupBy = new SWQLNode_GroupBy;
    if (!pGroupBy)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    SWQLNode_ColumnList *pColList = 0;

    nRes = col_list(&pColList);
    if (nRes)
    {
        delete pGroupBy;
        delete pColList;
        return nRes;
    }

    pGroupBy->m_pLeft = pColList;

    // Check for the HAVING clause.
    // ============================
    SWQLNode_Having *pHaving = 0;
    nRes = having_clause(&pHaving);

    if (pHaving)
        pGroupBy->m_pRight = pHaving;

    *pRetGroupBy = pGroupBy;

    m_uFeatures |= WMIQ_RPNF_GROUP_BY_HAVING;

    return NO_ERROR;
}

//***************************************************************************
//
//  <having_clause> ::= WQL_TOK_HAVING <rel_expr>;
//  <having_clause> ::= <>;
//
//***************************************************************************
// done

int CWQLParser::having_clause(OUT SWQLNode_Having **pRetHaving)
{
    int nRes;
    *pRetHaving = 0;

    if (m_nCurrentToken != WQL_TOK_HAVING)
        return NO_ERROR;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    // If here, we have a HAVING clause.
    // =================================

    SWQLNode_RelExpr *pRelExpr = 0;
    nRes = rel_expr(&pRelExpr);
    if (nRes)
    {
        delete pRelExpr;
        return nRes;
    }

    SWQLNode_Having *pHaving = new SWQLNode_Having;
    if (!pHaving)
    {
        delete pRelExpr;
        return WBEM_E_OUT_OF_MEMORY;
    }
    pHaving->m_pLeft = pRelExpr;

    *pRetHaving = pHaving;

    return NO_ERROR;
}

//***************************************************************************
//
//  <order_by_clause> ::= WQL_TOK_ORDER WQL_TOK_BY <col_list>;
//  <order_by_clause> ::= <>;
//
//***************************************************************************
//  done

int CWQLParser::order_by_clause(OUT SWQLNode_OrderBy **pRetOrderBy)
{
    int nRes;

    if (m_nCurrentToken != WQL_TOK_ORDER)
        return NO_ERROR;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;
    if (m_nCurrentToken != WQL_TOK_BY)
        return WBEM_E_INVALID_SYNTAX;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    // If here, we have an ORDER BY clause.
    // ====================================

    m_uFeatures |= WMIQ_RPNF_ORDER_BY;

    SWQLNode_ColumnList *pColList = 0;
    nRes = col_list(&pColList);
    if (nRes)
    {
        delete pColList;
        return nRes;
    }

    SWQLNode_OrderBy *pOrderBy = new SWQLNode_OrderBy;
    if (!pOrderBy)
    {
        delete pColList;
        return WBEM_E_OUT_OF_MEMORY;
    }
    pOrderBy->m_pLeft = pColList;
    *pRetOrderBy = pOrderBy;

    return NO_ERROR;
}

//***************************************************************************
//
//  <single_table_decl> ::= <unbound_table_ident> <table_decl_rest>;
//
//  <unbound_table_ident> ::= IDENT;
//  <table_decl_rest> ::= <redundant_as> <table_alias>;
//  <table_decl_rest> ::= <>;
//  <table_alias> ::= IDENT;
//
//  <redundant_as> ::= AS;
//  <redundant_as> ::= <>;
//
//***************************************************************************
// done; no cleanup

int CWQLParser::single_table_decl(OUT SWQLNode_TableRef **pTblRef)
{
    if (pTblRef == 0)
        return WBEM_E_CRITICAL_ERROR;

    *pTblRef = 0;

    if (m_nCurrentToken != WQL_TOK_IDENT)
        return WBEM_E_INVALID_SYNTAX;

    SWQLNode_TableRef *pTR = new SWQLNode_TableRef;
    if (!pTR)
        return WBEM_E_OUT_OF_MEMORY;
    pTR->m_pTableName = CloneLPWSTR(m_pTokenText);
    if (pTR->m_pTableName == 0)
    {
        delete pTR;
        return WBEM_E_OUT_OF_MEMORY;
    }

    m_aReferencedTables.Add(m_pTokenText);

    if (!Next())
    {
        delete pTR;
        return WBEM_E_INVALID_SYNTAX;
    }

    if (m_nCurrentToken == WQL_TOK_AS)
    {
        // Here we have a redundant AS and an alias.
        // =========================================
        if (!Next())
        {
            delete pTR;
            return WBEM_E_INVALID_SYNTAX;
        }
    }


    // If no Alias was used, we simply copy the table name into
    // the alias slot.
    // ========================================================
    else
    {
        pTR->m_pAlias = CloneLPWSTR(pTR->m_pTableName);
        if (pTR->m_pAlias == 0)
        {
            delete pTR;
            return WBEM_E_OUT_OF_MEMORY;
        }
        m_aReferencedAliases.Add(pTR->m_pTableName);
    }

    // For the primary select, we are keeping a list of tables
    // we are selecting from.
    // =======================================================

    if ((m_nParseContext & Ctx_Subselect) == 0)
        m_aSelAliases.Add(pTR);

    // Return the pointer to the caller.
    // =================================

    *pTblRef = pTR;

    return NO_ERROR;
}



//***************************************************************************
//
//  SQL-92 Joins.
//
//  We support:
//  1. [INNER] JOIN
//  2. LEFT [OUTER] JOIN
//  3. RIGHT [OUTER] JOIN
//  4. FULL [OUTER] JOIN
//
//
//  <sql92_join_entry> ::= <simple_join_clause>;
//  <sql92_join_entry> ::= INNER <simple_join_clause>;
//  <sql92_join_entry> ::= FULL <opt_outer> <simple_join_clause>;
//  <sql92_join_entry> ::= LEFT <opt_outer> <simple_join_clause>;
//  <sql92_join_entry> ::= RIGHT <opt_outer> <simple_join_clause>;
//
//  <opt_outer> ::= WQL_TOK_OUTER;
//  <opt_outer> ::= <>;
//
//  <simple_join_clause> ::=
//    JOIN
//    <single_table_decl>
//    <on_clause>
//    <sql92_join_continuator>
//
//  <sql92_join_continuator> ::= <sql92_join_entry>;
//  <sql92_join_continuator> ::= <>;
//
//***************************************************************************

int CWQLParser::sql92_join_entry(
    IN  SWQLNode_TableRef *pInitialTblRef,      // inherited
    OUT SWQLNode_Join **pJoin                   // synthesized
    )
{
    int nRes;

    /* Build a nested join tree bottom up.  Currently, the tree is always left-heavy:

            JN = Join Noe
            JP = Join Pair
            OC = On Clause
            TR = Table Ref

                   JN
                  /  \
                JP    OC
               /  \
             JN    TR
            /   \
          JP     OC
         /  \
        TR   TR
    */

    // State 1: Attempting to build a new JOIN node.
    // =============================================

    std::auto_ptr<SWQLNode_Join> pCurrentLeftNode;
    SWQLNode_JoinPair *pBottomJP = 0;

    while (1)
    {
      std::auto_ptr<SWQLNode_Join> pJN (new SWQLNode_Join);
      if (pJN.get() == 0)
    return WBEM_E_OUT_OF_MEMORY;

        // Join-type.
        // ==========

        pJN->m_dwJoinType = WQL_FLAG_INNER_JOIN;    // Default

        if (m_nCurrentToken == WQL_TOK_INNER)
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            pJN->m_dwJoinType = WQL_FLAG_INNER_JOIN;
        }
        else if (m_nCurrentToken == WQL_TOK_FULL)
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            if (m_nCurrentToken == WQL_TOK_OUTER)
                if (!Next())
                    return WBEM_E_INVALID_SYNTAX;
            pJN->m_dwJoinType = WQL_FLAG_FULL_OUTER_JOIN;
        }
        else if (m_nCurrentToken == WQL_TOK_LEFT)
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            if (m_nCurrentToken == WQL_TOK_OUTER)
                if (!Next())
                    return WBEM_E_INVALID_SYNTAX;
            pJN->m_dwJoinType = WQL_FLAG_LEFT_OUTER_JOIN;
        }
        else if (m_nCurrentToken == WQL_TOK_RIGHT)
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            if (m_nCurrentToken == WQL_TOK_OUTER)
                if (!Next())
                    return WBEM_E_INVALID_SYNTAX;
            pJN->m_dwJoinType = WQL_FLAG_RIGHT_OUTER_JOIN;
        }

        // <simple_join_clause>
        // =====================

        if (m_nCurrentToken != WQL_TOK_JOIN)
        {
            return WBEM_E_INVALID_SYNTAX;
        }

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

    std::auto_ptr<SWQLNode_JoinPair> pJP (new SWQLNode_JoinPair);

    if (pJP.get() == 0)
            return WBEM_E_OUT_OF_MEMORY;

        // Determine the table to which to join.
        // =====================================

        SWQLNode_TableRef *pTR = 0;
        nRes = single_table_decl(&pTR);
        if (nRes)
            return nRes;

        pJP->m_pRight = pTR;
        pJP->m_pLeft = pCurrentLeftNode.release();

    pCurrentLeftNode = pJN;

    if (pBottomJP==0)
      pBottomJP = pJP.get();

        // If FIRSTROW is used, add it in.
        // ===============================

        if (m_nCurrentToken == WQL_TOK_IDENT)
        {
            if (wbem_wcsicmp(L"FIRSTROW", m_pTokenText) != 0)
                return WBEM_E_INVALID_SYNTAX;
            pCurrentLeftNode/*pJN*/->m_dwFlags |= WQL_FLAG_FIRSTROW;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
        }

        // Get the ON clause.
        // ==================
        SWQLNode_OnClause *pOC = 0;

        nRes = on_clause(&pOC);
        if (nRes)
            return nRes;

        pCurrentLeftNode/*pJN*/->m_pRight = pOC;    // On clause
        pCurrentLeftNode/*pJN*/->m_pLeft  = pJP.release();

        // sql92_join_continuator();
        // =========================

        if (m_nCurrentToken == WQL_TOK_INNER ||
            m_nCurrentToken == WQL_TOK_FULL  ||
            m_nCurrentToken == WQL_TOK_LEFT  ||
            m_nCurrentToken == WQL_TOK_RIGHT ||
            m_nCurrentToken == WQL_TOK_JOIN
            )
            continue;

        break;
    }

    // Return the join node to the caller.
    // ====================================
    //  Set
    pBottomJP->m_pLeft = pInitialTblRef;
    *pJoin = pCurrentLeftNode.release();

    return NO_ERROR;
}


//***************************************************************************
//
//  <on_clause> ::= ON <rel_expr>;
//
//***************************************************************************

int CWQLParser::on_clause(OUT SWQLNode_OnClause **pOC)
{
    if (m_nCurrentToken != WQL_TOK_ON)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    wmilib::auto_ptr<SWQLNode_OnClause> pNewOC( new SWQLNode_OnClause);
    if (NULL == pNewOC.get()) return WBEM_E_OUT_OF_MEMORY;

    SWQLNode_RelExpr *pRelExpr = 0;
    int nRes = rel_expr(&pRelExpr);
    if (nRes)
    {
        delete pRelExpr;
        return nRes;
    }

    pNewOC->m_pLeft = pRelExpr;
    *pOC = pNewOC.release();

    return NO_ERROR;
}

//***************************************************************************
//
//  <rel_expr> ::= <rel_term> <rel_expr2>;
//
//  We are creating a new expression or subexpression each time
//  we enter this recursively.   No inherited attributes are
//  propagated to this production.
//
//***************************************************************************

int CWQLParser::rel_expr(OUT SWQLNode_RelExpr **pRelExpr)
{
    int nRes;
    *pRelExpr = 0;

    // Get the new node.  This becomes a temporary root.
    // =================================================

    SWQLNode_RelExpr *pRE = 0;
    nRes = rel_term(&pRE);
    if (nRes)
        return nRes;

    // At this point, we have a possible root.  If
    // there are OR operations, the root will be
    // replaced by the next function.  Otherwise,
    // the call will pass through pRE into pNewRoot.
    // =============================================

    SWQLNode_RelExpr *pNewRoot = 0;
    nRes = rel_expr2(pRE, &pNewRoot);
    if (nRes)
        return nRes;

    // Return the expression to the caller.
    // ====================================

    *pRelExpr = pNewRoot;
    return NO_ERROR;
}



//***************************************************************************
//
//  <rel_expr2> ::= OR <rel_term> <rel_expr2>;
//  <rel_expr2> ::= <>;
//
//***************************************************************************
// done!

int CWQLParser::rel_expr2(
    IN OUT SWQLNode_RelExpr *pLeftSide,
    OUT SWQLNode_RelExpr **pNewRootRE
    )
{
    int nRes;
    *pNewRootRE = pLeftSide;            // Default for the nullable production

    while (1)
    {
        // Build a series of OR subtrees bottom-up.  We use iteration
        // and pointer juggling to simulate recursion.
        // ============================================================

        if (m_nCurrentToken == WQL_TOK_OR)
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            SWQLNode_RelExpr *pNewRoot = new SWQLNode_RelExpr;
            if (!pNewRoot)
                return WBEM_E_OUT_OF_MEMORY;

            pNewRoot->m_dwExprType = WQL_TOK_OR;
            pNewRoot->m_pLeft = pLeftSide;
            pLeftSide = pNewRoot;
            *pNewRootRE = pNewRoot;     // Communicate this fact to the caller

            SWQLNode_RelExpr *pRight = 0;

            if (nRes = rel_term(&pRight))
                return nRes;

            pNewRoot->m_pRight = pRight;
            // Right node becomes the new subexpr
        }
        else break;
    }

    return NO_ERROR;
}


//***************************************************************************
//
//  <rel_term> ::= <rel_simple_expr> <rel_term2>;
//
//***************************************************************************
// done!

int CWQLParser::rel_term(
    OUT SWQLNode_RelExpr **pNewTerm
    )
{
    int nRes;

    SWQLNode_RelExpr *pNewSimple = 0;
    if (nRes = rel_simple_expr(&pNewSimple))
        return nRes;

    SWQLNode_RelExpr *pNewRoot = 0;
    if (nRes = rel_term2(pNewSimple, &pNewRoot))
        return nRes;

    *pNewTerm = pNewRoot;

    return NO_ERROR;
}



//***************************************************************************
//
//  <rel_term2> ::= AND <rel_simple_expr> <rel_term2>;
//  <rel_term2> ::= <>;
//
//***************************************************************************
// done!

int CWQLParser::rel_term2(
    IN SWQLNode_RelExpr *pLeftSide,                 // Inherited
    OUT SWQLNode_RelExpr **pNewRootRE       // Synthesized
    )
{
    int nRes;
    *pNewRootRE = pLeftSide;            // Default for the nullable production

    while (1)
    {
        // Build a series of AND subtrees bottom-up.  We use iteration
        // and pointer juggling to simulate recursion.
        // ============================================================

        if (m_nCurrentToken == WQL_TOK_AND)
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            SWQLNode_RelExpr *pNewRoot = new SWQLNode_RelExpr;
            if (!pNewRoot)
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
            pNewRoot->m_dwExprType = WQL_TOK_AND;
            pNewRoot->m_pLeft = pLeftSide;
            pLeftSide = pNewRoot;
            *pNewRootRE = pNewRoot;     // Communicate this fact to the caller

            SWQLNode_RelExpr *pRight = 0;
            if (nRes = rel_simple_expr(&pRight))
                return nRes;

            pNewRoot->m_pRight = pRight;
        }
        else break;
    }

    return NO_ERROR;
}


//***************************************************************************
//
//  <rel_simple_expr> ::= NOT <rel_expr>;
//  <rel_simple_expr> ::= OPEN_PAREN <rel_expr> CLOSE_PAREN;
//  <rel_simple_expr> ::= <typed_expr>;
//
//***************************************************************************
// done!

int CWQLParser::rel_simple_expr(OUT SWQLNode_RelExpr **pRelExpr)
{
    int nRes;
    *pRelExpr = 0;  // Default

    // NOT <rel_expr>
    // ==============
    if (m_nCurrentToken == WQL_TOK_NOT)
    {
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        // Allocate a NOT root and place the NOTed subexpr
        // under it.
        // ===============================================

        SWQLNode_RelExpr *pNotRoot = new SWQLNode_RelExpr;
        if (!pNotRoot)
            return WBEM_E_OUT_OF_MEMORY;

        pNotRoot->m_dwExprType = WQL_TOK_NOT;

        SWQLNode_RelExpr *pRelSubExpr = 0;
        if (nRes = rel_expr(&pRelSubExpr))
            return nRes;

        pNotRoot->m_pLeft = pRelSubExpr;
        pNotRoot->m_pRight = NULL;   // intentional
        *pRelExpr = pNotRoot;

        return NO_ERROR;
    }

    // OPEN_PAREN <rel_expr> CLOSE_PAREN
    // =================================
    else if (m_nCurrentToken == WQL_TOK_OPEN_PAREN)
    {
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        SWQLNode_RelExpr *pSubExpr = 0;
        if (rel_expr(&pSubExpr))
            return WBEM_E_INVALID_SYNTAX;

        if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
            return WBEM_E_INVALID_SYNTAX;

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;

        *pRelExpr = pSubExpr;

        return NO_ERROR;
    }

    // <typed_expr>
    // ============

    SWQLNode_RelExpr *pSubExpr = 0;
    nRes = typed_expr(&pSubExpr);
    if (nRes)
        return nRes;
    *pRelExpr = pSubExpr;

    return NO_ERROR;
}

//***************************************************************************
//
//  <typed_expr> ::= <typed_subexpr> <rel_op> <typed_subexpr_rh>;
//
//***************************************************************************
// done

int CWQLParser::typed_expr(OUT SWQLNode_RelExpr **pRelExpr)
{
    int nRes;

    // Allocate a node for this typed expression.
    // There are no possible child nodes, so <pRelExpr> this becomes
    // a synthesized attribute.
    // =============================================================

    SWQLNode_RelExpr *pRE = new SWQLNode_RelExpr;
    if (!pRE)
        return WBEM_E_OUT_OF_MEMORY;

    pRE->m_dwExprType = WQL_TOK_TYPED_EXPR;
    *pRelExpr = pRE;

    SWQLTypedExpr *pTE = new SWQLTypedExpr;
    if (!pTE)
        return WBEM_E_OUT_OF_MEMORY;

    // Look at the left hand side.
    // ===========================
    nRes = typed_subexpr(pTE);
    if (nRes)
    {
        delete pTE;
        return nRes;
    }

    int nOperator;

    // Get the operator.
    // =================
    nRes = rel_op(nOperator);
    if (nRes)
        return nRes;

    pTE->m_dwRelOperator = DWORD(nOperator);


    if (nOperator == WQL_TOK_ISNULL || nOperator == WQL_TOK_NOT_NULL)
    {
        pRE->m_pTypedExpr = pTE;
        return NO_ERROR;
    }

    // Get the right-hand side.
    // ========================
    nRes = typed_subexpr_rh(pTE);
    if (nRes)
	{
        delete pTE;
        return nRes;
	}


    // Check for IN, NOT IN and a const-list, to change the operator
    // to a more specific variety.
    // =============================================================
    if (pTE->m_pConstList)
    {
        if (pTE->m_dwRelOperator == WQL_TOK_IN)
            pTE->m_dwRelOperator = WQL_TOK_IN_CONST_LIST;
        if (pTE->m_dwRelOperator == WQL_TOK_NOT_IN)
            pTE->m_dwRelOperator = WQL_TOK_NOT_IN_CONST_LIST;
    }

    // Post-processing.  If the left side is a const and the right
    // side is a col-ref, flip the operator and swap so that
    // such expressions are normalized with the constant on the
    // right hand side and the column on the left.
    // ============================================================

    if (pTE->m_pConstValue && pTE->m_pJoinColRef)
    {
        pTE->m_dwRelOperator = FlipOperator(pTE->m_dwRelOperator);

        pTE->m_pColRef = pTE->m_pJoinColRef;
        pTE->m_pTableRef = pTE->m_pJoinTableRef;
        pTE->m_pJoinTableRef = 0;
        pTE->m_pJoinColRef = 0;

        DWORD dwTmp = pTE->m_dwRightFlags;
        pTE->m_dwRightFlags = pTE->m_dwLeftFlags;
        pTE->m_dwLeftFlags = dwTmp;

        // Interchange function references.
        // ================================

        pTE->m_pIntrinsicFuncOnColRef = pTE->m_pIntrinsicFuncOnJoinColRef;
        pTE->m_pIntrinsicFuncOnJoinColRef = 0;
    }

    pRE->m_pTypedExpr = pTE;

    return NO_ERROR;
}

//***************************************************************************
//
//  <typed_subexpr> ::= <col_ref>;
//  <typed_subexpr> ::= <function_call>;
//  <typed_subexpr> ::= <typed_const>;
//
//***************************************************************************
// ok
int CWQLParser::typed_subexpr(
    SWQLTypedExpr *pTE
    )
{
    int nRes;
    BOOL bStripTrailingParen = FALSE;
    SWQLQualifiedName *pColRef = 0;
    wmilib::auto_buffer<wchar_t> pFuncHolder;

    // Check for <function_call>
    // =========================

    if (m_nCurrentToken == WQL_TOK_UPPER)
    {
        pTE->m_dwLeftFlags |= WQL_FLAG_FUNCTIONIZED;
        pFuncHolder.reset(CloneLPWSTR(L"UPPER"));

        if (pFuncHolder.get() == 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return WBEM_E_INVALID_SYNTAX;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        bStripTrailingParen = TRUE;
    }

    if (m_nCurrentToken == WQL_TOK_LOWER)
    {
        pTE->m_dwLeftFlags |= WQL_FLAG_FUNCTIONIZED;
        pFuncHolder.reset(CloneLPWSTR(L"LOWER"));
        if (pFuncHolder.get() == 0)
        {
           return WBEM_E_OUT_OF_MEMORY;
        }

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return WBEM_E_INVALID_SYNTAX;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        bStripTrailingParen = TRUE;
    }

    if (
        m_nCurrentToken == WQL_TOK_DATEPART  ||
        m_nCurrentToken == WQL_TOK_QUALIFIER ||
        m_nCurrentToken == WQL_TOK_ISNULL
        )
    {
        nRes = function_call(TRUE, pTE);
        if (nRes)
            return nRes;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_QSTRING ||
        m_nCurrentToken == WQL_TOK_INT     ||
        m_nCurrentToken == WQL_TOK_HEX_CONST ||
        m_nCurrentToken == WQL_TOK_REAL    ||
        m_nCurrentToken == WQL_TOK_CHAR    ||
        m_nCurrentToken == WQL_TOK_PROMPT  ||
        m_nCurrentToken == WQL_TOK_NULL
       )
    {
        SWQLTypedConst *pTC = 0;
        nRes = typed_const(&pTC);
        if (nRes)
            return nRes;
        pTE->m_pConstValue = pTC;
        pTE->m_dwLeftFlags |= WQL_FLAG_CONST;  // Intentional!
        pTE->m_pIntrinsicFuncOnConstValue = pFuncHolder.release();
        goto Exit;
    }

    // If here, must be a <col_ref>.
    // =============================

    nRes = col_ref(&pColRef);   // TBD
    if (nRes)
        return nRes;

    pTE->m_pIntrinsicFuncOnColRef = pFuncHolder.release();

    // Convert the col_ref to be part of the current SWQLTypedExpr.  We analyze the
    // qualified name and extract the table and col name.
    // ============================================================================

    if (pColRef->m_aFields.Size() == 1)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pColRef->m_aFields[0];
        pTE->m_pColRef = CloneLPWSTR(pCol->m_pName);
        if (pTE->m_pColRef == 0 && pCol->m_pName != 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pTE->m_dwLeftFlags |= WQL_FLAG_COLUMN;
        if (pCol->m_bArrayRef)
        {
            pTE->m_dwLeftFlags |= WQL_FLAG_ARRAY_REF;
            pTE->m_dwLeftArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    else if (pColRef->m_aFields.Size() == 2)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pColRef->m_aFields[1];
        SWQLQualifiedNameField *pTbl = (SWQLQualifiedNameField *) pColRef->m_aFields[0];

        pTE->m_pColRef = CloneLPWSTR(pCol->m_pName);
        if (pTE->m_pColRef == 0 && pCol->m_pName != 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pTE->m_pTableRef = CloneLPWSTR(pTbl->m_pName);  
        if (pTE->m_pTableRef == 0 && pTbl->m_pName != 0)
        {
           return WBEM_E_OUT_OF_MEMORY;
        }

        pTE->m_dwLeftFlags |= WQL_FLAG_TABLE | WQL_FLAG_COLUMN;
        if (pCol->m_bArrayRef)
        {
            pTE->m_dwLeftFlags |= WQL_FLAG_ARRAY_REF;
            pTE->m_dwLeftArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    // If UPPER or LOWER was used, we have to strip a trailing
    // parenthesis.
    // =======================================================

Exit:
    delete pColRef;

    if (bStripTrailingParen)
    {
        if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
            return WBEM_E_INVALID_SYNTAX;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
    }

    return NO_ERROR;
}



//***************************************************************************
//
//  <typed_subexpr_rh> ::= <function_call>;
//  <typed_subexpr_rh> ::= <typed_const>;
//  <typed_subexpr_rh> ::= <col_ref>;
//
//  <typed_subexpr_rh> ::= <in_clause>;   // Operator must be _IN or _NOT_IN
//
//***************************************************************************
int CWQLParser::typed_subexpr_rh(IN SWQLTypedExpr *pTE)
{
    int nRes;
    BOOL bStripTrailingParen = FALSE;
    SWQLQualifiedName *pColRef = 0;
    wmilib::auto_buffer<wchar_t> pFuncHolder;

    // Check for <function_call>
    // =========================

    if (m_nCurrentToken == WQL_TOK_UPPER)
    {
        pTE->m_dwRightFlags |= WQL_FLAG_FUNCTIONIZED;
        pFuncHolder.reset(CloneLPWSTR(L"UPPER"));
        if (pFuncHolder.get() == 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return WBEM_E_INVALID_SYNTAX;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        bStripTrailingParen = TRUE;
    }

    if (m_nCurrentToken == WQL_TOK_LOWER)
    {
        pTE->m_dwRightFlags |= WQL_FLAG_FUNCTIONIZED;
        pFuncHolder.reset(CloneLPWSTR(L"LOWER"));
        if (pFuncHolder.get() == 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
            return WBEM_E_INVALID_SYNTAX;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
        bStripTrailingParen = TRUE;
    }

    if (m_nCurrentToken == WQL_TOK_DATEPART  ||
        m_nCurrentToken == WQL_TOK_QUALIFIER ||
        m_nCurrentToken == WQL_TOK_ISNULL
        )
    {
        nRes = function_call(FALSE, pTE);
        if (nRes)
            return nRes;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_QSTRING ||
        m_nCurrentToken == WQL_TOK_INT     ||
        m_nCurrentToken == WQL_TOK_HEX_CONST  ||
        m_nCurrentToken == WQL_TOK_REAL    ||
        m_nCurrentToken == WQL_TOK_CHAR    ||
        m_nCurrentToken == WQL_TOK_PROMPT  ||
        m_nCurrentToken == WQL_TOK_NULL
       )
    {
		// If we already have a typed constant, then the expression doesn't
		// really make sense, trying to do a relop around two constants,
		// so we'll fail the operation here
		if ( NULL != pTE->m_pConstValue )
		{
			return WBEM_E_INVALID_SYNTAX;
		}
		
        SWQLTypedConst *pTC = 0;
        nRes = typed_const(&pTC);
        if (nRes)
            return nRes;
        pTE->m_pConstValue = pTC;
        pTE->m_dwRightFlags |= WQL_FLAG_CONST;
        pTE->m_pIntrinsicFuncOnConstValue = pFuncHolder.release();

        // Check for BETWEEN operator, since we have
        // the other end of the range to parse.
        // =========================================

        if (pTE->m_dwRelOperator == WQL_TOK_BETWEEN ||
            pTE->m_dwRelOperator == WQL_TOK_NOT_BETWEEN)
        {
            if (m_nCurrentToken != WQL_TOK_AND)
                return WBEM_E_INVALID_SYNTAX;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            SWQLTypedConst *pTC2 = 0;
            nRes = typed_const(&pTC2);
            if (nRes)
                return nRes;
            pTE->m_pConstValue2 = pTC2;
            pTE->m_dwRightFlags |= WQL_FLAG_CONST_RANGE;
        }

        goto Exit;
    }

    if (m_nCurrentToken == WQL_TOK_OPEN_PAREN)
    {
        // IN clause.
        nRes = in_clause(pTE);
        if (nRes)
            return nRes;
        goto Exit;
    }

    // If here, must be a <col_ref>.
    // =============================

    nRes = col_ref(&pColRef);
    if (nRes)
        return nRes;

    pTE->m_pIntrinsicFuncOnJoinColRef = pFuncHolder.release();

    // Convert the col_ref to be part of the current SWQLTypedExpr.  We analyze the
    // qualified name and extract the table and col name.
    // ============================================================================

    if (pColRef->m_aFields.Size() == 1)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pColRef->m_aFields[0];
        pTE->m_pJoinColRef = CloneLPWSTR(pCol->m_pName);
        if (pTE->m_pJoinColRef == 0 && pCol->m_pName != 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        pTE->m_dwRightFlags |= WQL_FLAG_COLUMN;
        if (pCol->m_bArrayRef)
        {
            pTE->m_dwRightFlags |= WQL_FLAG_ARRAY_REF;
            pTE->m_dwRightArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    else if (pColRef->m_aFields.Size() == 2)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pColRef->m_aFields[1];
        SWQLQualifiedNameField *pTbl = (SWQLQualifiedNameField *) pColRef->m_aFields[0];

        pTE->m_pJoinColRef = CloneLPWSTR(pCol->m_pName);
        if (pTE->m_pJoinColRef == 0 && pCol->m_pName != 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pTE->m_pJoinTableRef = CloneLPWSTR(pTbl->m_pName);
        if (pTE->m_pJoinTableRef == 0 && pTbl->m_pName != 0)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pTE->m_dwRightFlags |= WQL_FLAG_TABLE | WQL_FLAG_COLUMN;

        if (pCol->m_bArrayRef)
        {
            pTE->m_dwRightFlags |= WQL_FLAG_ARRAY_REF;
            pTE->m_dwRightArrayIndex = pCol->m_dwArrayIndex;
        }
    }

Exit:
    delete pColRef;

    if (bStripTrailingParen)
    {
        if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
            return WBEM_E_INVALID_SYNTAX;
        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
    }

    return NO_ERROR;
}




//*****************************************************************************************
//
//  <rel_op> ::= WQL_TOK_LE;
//  <rel_op> ::= WQL_TOK_LT;
//  <rel_op> ::= WQL_TOK_GE;
//  <rel_op> ::= WQL_TOK_GT;
//  <rel_op> ::= WQL_TOK_EQ;
//  <rel_op> ::= WQL_TOK_NE;
//  <rel_op> ::= WQL_TOK_LIKE;
//  <rel_op> ::= WQL_TOK_BETWEEN;
//  <rel_op> ::= WQL_TOK_IS <is_continuator>;
//  <rel_op> ::= WQL_TOK_ISA;
//  <rel_op> ::= WQL_TOK_IN;
//  <rel_op> ::= WQL_TOK_NOT <not_continuator>;
//
//  Operator type is returned via <nReturnedOp>
//
//*****************************************************************************************
// done

int CWQLParser::rel_op(OUT int & nReturnedOp)
{
    int nRes;
    nReturnedOp = WQL_TOK_ERROR;

    switch (m_nCurrentToken)
    {
        case WQL_TOK_LE:
            nReturnedOp = WQL_TOK_LE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_LT:
            nReturnedOp = WQL_TOK_LT;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_GE:
            nReturnedOp = WQL_TOK_GE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_GT:
            nReturnedOp = WQL_TOK_GT;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_EQ:
            nReturnedOp = WQL_TOK_EQ;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_NE:
            nReturnedOp = WQL_TOK_NE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_LIKE:
            nReturnedOp = WQL_TOK_LIKE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_BETWEEN:
            nReturnedOp = WQL_TOK_BETWEEN;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_IS:
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            nRes = is_continuator(nReturnedOp);
            return nRes;

        case WQL_TOK_ISA:
            nReturnedOp = WQL_TOK_ISA;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            m_uFeatures |= WMIQ_RPNF_ISA_USED;
            return NO_ERROR;

        case WQL_TOK_IN:
            nReturnedOp = WQL_TOK_IN;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_NOT:
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            nRes = not_continuator(nReturnedOp);
            return nRes;
    }

    return WBEM_E_INVALID_SYNTAX;
}

//*****************************************************************************************
//
//  <typed_const> ::= WQL_TOK_QSTRING;
//  <typed_const> ::= WQL_TOK_HEX_CONST;
//  <typed_const> ::= WQL_TOK_INT;
//  <typed_const> ::= WQL_TOK_REAL;
//  <typed_const> ::= WQL_TOK_PROMPT;
//  <typed_const> ::= WQL_TOK_NULL;
//
//*****************************************************************************************
// done

int CWQLParser::typed_const(OUT SWQLTypedConst **pRetVal)
{
    SWQLTypedConst *pNew = new SWQLTypedConst;
    if (!pNew)
        return WBEM_E_OUT_OF_MEMORY;
    *pRetVal = pNew;

    if (m_nCurrentToken == WQL_TOK_QSTRING
        || m_nCurrentToken == WQL_TOK_PROMPT)
    {
        pNew->m_dwType = VT_LPWSTR;
        pNew->m_bPrompt = (m_nCurrentToken == WQL_TOK_PROMPT);
        pNew->m_Value.m_pString = CloneLPWSTR(m_pTokenText);
        if (NULL == pNew->m_Value.m_pString)
            return WBEM_E_OUT_OF_MEMORY;
        if (!Next())
            goto Error;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_INT || m_nCurrentToken == WQL_TOK_HEX_CONST)
    {
        unsigned __int64 val = 0;
        BOOL bSigned = FALSE;
        BOOL b64Bit = FALSE;

        if (!GetIntToken(&bSigned, &b64Bit, &val))
            return WBEM_E_INVALID_SYNTAX;

        if (!b64Bit)
        {
            if (bSigned)
                pNew->m_dwType = VT_I4;
            else
                pNew->m_dwType = VT_UI4;

            pNew->m_Value.m_lValue = (LONG) val;
        }
        else    // 64 bit moved into string
        {
            if (bSigned)
                pNew->m_dwType = VT_I8;
            else
                pNew->m_dwType = VT_UI8;
            pNew->m_Value.m_i64Value = val;
        }

        if (!Next())
            goto Error;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_REAL)
    {
        pNew->m_dwType = VT_R8;
        wchar_t *pStopper = 0;
	BSTR bstrValue = SysAllocString(m_pTokenText);
        if (!bstrValue)
    	    return WBEM_E_OUT_OF_MEMORY;
	_variant_t varValue;
	V_VT(&varValue) = VT_BSTR;
	V_BSTR(&varValue) = bstrValue;

        if (FAILED(VariantChangeTypeEx(&varValue,&varValue, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), VARIANT_NOUSEROVERRIDE, VT_R8)))
	    	return WBEM_E_INVALID_SYNTAX;
        
        double d = varValue;
        
        pNew->m_Value.m_dblValue = d;
        if (!Next())
            goto Error;
        return NO_ERROR;
    }

    if (m_nCurrentToken == WQL_TOK_NULL)
    {
        pNew->m_dwType = VT_NULL;
        if (!Next())
            goto Error;
        return NO_ERROR;
    }

    // Unrecognized constant.
    // ======================
Error:
    *pRetVal = 0;
    delete pNew;

    return WBEM_E_INVALID_SYNTAX;
}

//*****************************************************************************************
//
//  <datepart_call> ::=
//    WQL_TOK_OPEN_PAREN
//    WQL_TOK_IDENT               // yy, mm,dd, hh, mm, ss, year, month, etc.
//    WQL_TOK_COMMA
//    <col_ref>
//    WQL_TOK_CLOSE_PAREN
//
//*****************************************************************************************

static WqlKeyword DateKeyWords[] =      // Keep this alphabetized for binary search
{
    L"DAY",      WQL_TOK_DAY,
    L"DD",       WQL_TOK_DAY,
    L"HH",       WQL_TOK_HOUR,
    L"HOUR",     WQL_TOK_HOUR,
    L"MI",       WQL_TOK_MINUTE,
    L"MILLISECOND", WQL_TOK_MILLISECOND,
    L"MINUTE",   WQL_TOK_MINUTE,
    L"MONTH",    WQL_TOK_MONTH,
    L"MM",       WQL_TOK_MONTH,
    L"MS",          WQL_TOK_MILLISECOND,
    L"YEAR",     WQL_TOK_YEAR,
    L"YY",       WQL_TOK_YEAR
};

const int NumDateKeywords = sizeof(DateKeyWords)/sizeof(WqlKeyword);

int CWQLParser::datepart_call(OUT SWQLNode_Datepart **pRetDP)
{
    DWORD dwDatepartTok = 0;
    int nRes;

    if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
        return WBEM_E_INVALID_SYNTAX;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;
    if (m_nCurrentToken != WQL_TOK_IDENT)
        return WBEM_E_INVALID_SYNTAX;

    // Ident must be one of the DATEPART identifiers.
    // ==============================================

    BOOL bFound = FALSE;
    int l = 0, u = NumDateKeywords - 1;
    while (l <= u)
    {
        int m = (l + u) / 2;
        if (wbem_wcsicmp(m_pTokenText, DateKeyWords[m].m_pKeyword) < 0)
             u = m - 1;
        else if (wbem_wcsicmp(m_pTokenText, DateKeyWords[m].m_pKeyword) > 0)
             l = m + 1;
        else        // Match
        {
           bFound = TRUE;
           dwDatepartTok = DateKeyWords[m].m_nTokenCode;
           break;
        }
    }

    if (!bFound)
        return WBEM_E_INVALID_SYNTAX;

    // If here, we know the date part.
    // ===============================

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;
    if (m_nCurrentToken != WQL_TOK_COMMA)
        return WBEM_E_INVALID_SYNTAX;
    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    SWQLQualifiedName *pQN = 0;
    nRes = col_ref(&pQN);
    if (nRes)
        return nRes;

    SWQLColRef *pCR = 0;
    nRes = QNameToSWQLColRef(pQN, &pCR);

    if (nRes)
    {
        delete pQN;
        return WBEM_E_INVALID_PARAMETER;
    }

    std::auto_ptr <SWQLColRef> _1(pCR);

    if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    // Return the new node.
    // ====================

    SWQLNode_Datepart *pDP = new SWQLNode_Datepart;
    if (!pDP)
        return WBEM_E_OUT_OF_MEMORY;

    _1.release();

    pDP->m_nDatepart = dwDatepartTok;
    pDP->m_pColRef = pCR;

    *pRetDP = pDP;

    return NO_ERROR;
}



//*****************************************************************************************
//
//  <function_call> ::= WQL_TOK_UPPER <function_call_parms>;
//  <function_call> ::= WQL_TOK_LOWER  <function_call_parms>;
//  <function_call> ::= WQL_TOK_DATEPART  <datepart_call>;
//  <function_call> ::= WQL_TOK_QUALIFIER  <function_call_parms>;
//  <function_call> ::= WQL_TOK_ISNULL <function_call_parms>;
//
//*****************************************************************************************

int CWQLParser::function_call(
    IN BOOL bLeftSide,
    IN SWQLTypedExpr *pTE
    )
{
    int nRes;
    SWQLNode_Datepart *pDP = 0;

    switch (m_nCurrentToken)
    {
        case WQL_TOK_DATEPART:
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            nRes = datepart_call(&pDP);

            if (nRes)
                return nRes;

            if (bLeftSide)
            {
                pTE->m_dwLeftFlags |= WQL_FLAG_FUNCTIONIZED;
                pTE->m_pLeftFunction = pDP;
                pTE->m_pIntrinsicFuncOnColRef = CloneLPWSTR(L"DATEPART");
                if (!pTE->m_pIntrinsicFuncOnColRef)
                    return WBEM_E_OUT_OF_MEMORY;
            }
            else
            {
                pTE->m_dwRightFlags |= WQL_FLAG_FUNCTIONIZED;
                pTE->m_pRightFunction = pDP;
                pTE->m_pIntrinsicFuncOnJoinColRef = CloneLPWSTR(L"DATEPART");
                if (!pTE->m_pIntrinsicFuncOnJoinColRef)
                    return WBEM_E_OUT_OF_MEMORY;
            }

            return NO_ERROR;
        }

        case WQL_TOK_QUALIFIER:
            trace(("EMIT: QUALIFIER\n"));
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            nRes = function_call_parms();
            return nRes;

        case WQL_TOK_ISNULL:
            trace(("EMIT: ISNULL\n"));
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            nRes = function_call_parms();
            return nRes;
    }

    return WBEM_E_INVALID_SYNTAX;
}

//*****************************************************************************************
//
//  <function_call_parms> ::=
//    WQL_TOK_OPEN_PAREN
//    <func_args>
//    WQL_TOK_CLOSE_PAREN
//
//*****************************************************************************************

int CWQLParser::function_call_parms()
{
    if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    int nRes = func_args();
    if (nRes)
        return nRes;

    if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    return NO_ERROR;
}

//*****************************************************************************************
//
//  <func_args> ::= <func_arg> <func_arg_list>;
//  <func_arg_list> ::= WQL_TOK_COMMA <func_arg> <func_arg_list>;
//  <func_arg_list> ::= <>;
//
//*****************************************************************************************

int CWQLParser::func_args()
{
    int nRes;

    while (1)
    {
        nRes = func_arg();
        if (nRes)
            return nRes;

        if (m_nCurrentToken != WQL_TOK_COMMA)
            break;

        if (!Next())
            return WBEM_E_INVALID_SYNTAX;
    }

    return NO_ERROR;
}

//*****************************************************************************************
//
//  <func_arg> ::= <typed_const>;
//  <func_arg> ::= <col_ref>;
//
//*****************************************************************************************

int CWQLParser::func_arg()
{
    SWQLQualifiedName *pColRef = 0;
    int nRes;

    if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        nRes = col_ref(&pColRef);
        return nRes;
    }

    SWQLTypedConst *pTC = 0;
    return typed_const(&pTC);
}


// Tokens which can follow IS
// ===========================

//*****************************************************************************************
//
//  <is_continuator> ::= WQL_TOK_LIKE;
//  <is_continuator> ::= WQL_TOK_BEFORE;
//  <is_continuator> ::= WQL_TOK_AFTER;
//  <is_continuator> ::= WQL_TOK_BETWEEN;
//  <is_continuator> ::= WQL_TOK_NULL;
//  <is_continuator> ::= WQL_TOK_NOT <not_continuator>;
//  <is_continuator> ::= WQL_TOK_IN;
//  <is_continuator> ::= WQL_TOK_A;
//
//*****************************************************************************************
// done

int CWQLParser::is_continuator(int & nReturnedOp)
{
    int nRes;

    nReturnedOp = WQL_TOK_ERROR;

    switch (m_nCurrentToken)
    {
        case WQL_TOK_LIKE:
            nReturnedOp = WQL_TOK_LIKE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_BEFORE:
            nReturnedOp = WQL_TOK_BEFORE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_AFTER:
            nReturnedOp = WQL_TOK_AFTER;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_BETWEEN:
            nReturnedOp = WQL_TOK_BETWEEN;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_NULL:
            nReturnedOp = WQL_TOK_ISNULL;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_NOT:
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
              nRes = not_continuator(nReturnedOp);
            return nRes;

        case WQL_TOK_IN:
            nReturnedOp = WQL_TOK_IN;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_A:
            nReturnedOp = WQL_TOK_ISA;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            m_uFeatures |= WMIQ_RPNF_ISA_USED;
            return NO_ERROR;
    }

    return WBEM_E_INVALID_SYNTAX;
}

//*****************************************************************************************
//
//  <not_continuator> ::= WQL_TOK_LIKE;
//  <not_continuator> ::= WQL_TOK_BEFORE;
//  <not_continuator> ::= WQL_TOK_AFTER;
//  <not_continuator> ::= WQL_TOK_BETWEEN;
//  <not_continuator> ::= WQL_TOK_NULL;
//  <not_continuator> ::= WQL_TOK_IN;
//
//  Returns WQL_TOK_NOT_LIKE, WQL_TOK_NOT_BEFORE, WQL_TOK_NOT_AFTER, WQL_TOK_NOT_BETWEEN
//          WQL_TOK_NOT_NULL, WQL_TOK_NOT_IN
//
//*****************************************************************************************
// done

int CWQLParser::not_continuator(int & nReturnedOp)
{
    nReturnedOp = WQL_TOK_ERROR;

    switch (m_nCurrentToken)
    {
        case WQL_TOK_LIKE:
            nReturnedOp = WQL_TOK_NOT_LIKE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_BEFORE:
            nReturnedOp = WQL_TOK_NOT_BEFORE;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_AFTER:
            nReturnedOp = WQL_TOK_NOT_AFTER;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_BETWEEN:
            nReturnedOp = WQL_TOK_NOT_BETWEEN;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_NULL:
            nReturnedOp = WQL_TOK_NOT_NULL;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_IN:
            nReturnedOp = WQL_TOK_NOT_IN;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;

        case WQL_TOK_A:
            nReturnedOp = WQL_TOK_NOT_A;
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;
            return NO_ERROR;
    }

    return WBEM_E_INVALID_SYNTAX;
}


//*****************************************************************************************
//
//  <in_clause> ::= WQL_TOK_OPEN_PAREN <in_type> WQL_TOK_CLOSE_PAREN;
//  <in_type> ::= <subselect_stmt>;
//  <in_type> ::= <const_list>;
//  <in_type> ::= <qualified_name>;
//
//*****************************************************************************************

int CWQLParser::in_clause(IN SWQLTypedExpr *pTE)
{
    int nRes;

    if (m_nCurrentToken != WQL_TOK_OPEN_PAREN)
        return WBEM_E_INVALID_SYNTAX;

    //int nStPos = m_pLexer->GetCurPos();

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    if (m_nCurrentToken == WQL_TOK_SELECT)
    {
        SWQLNode_Select *pSel = 0;
        nRes = subselect_stmt(&pSel);
        if (nRes)
            return nRes;

        // pSel->m_nStPos = nStPos;
        // pSel->m_nEndPos = m_pLexer->GetCurPos() - 1;

        // Translate the IN / NOT IN operator to the specific
        // case of subselects.
        // ==================================================

        if (pTE->m_dwRelOperator == WQL_TOK_IN)
            pTE->m_dwRelOperator = WQL_TOK_IN_SUBSELECT;
        else if (pTE->m_dwRelOperator == WQL_TOK_NOT_IN)
            pTE->m_dwRelOperator = WQL_TOK_NOT_IN_SUBSELECT;

        pTE->m_pSubSelect = pSel;
    }

    else if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        nRes = qualified_name(0);
        if (nRes)
            return nRes;
    }

    // If here, we must have a const-list.
    // ===================================

    else
    {
        SWQLConstList *pCL = 0;

        nRes = const_list(&pCL);
        if (nRes)
            return nRes;

        pTE->m_pConstList = pCL;
    }

    if (m_nCurrentToken != WQL_TOK_CLOSE_PAREN)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    return NO_ERROR;
}

//*****************************************************************************************
//
//  <const_list> ::= <typed_const> <const_list2>;
//  <const_list2> ::= WQL_TOK_COMMA <typed_const> <const_list2>;
//  <const_list2> ::= <>;
//
//*****************************************************************************************
// done

int CWQLParser::const_list(SWQLConstList **pRetVal)
{
    int nRes;
    SWQLConstList *pCL = new SWQLConstList;
    if (!pCL)
        return WBEM_E_OUT_OF_MEMORY;

    *pRetVal = 0;

    while (1)
    {
        if (m_nCurrentToken == WQL_TOK_QSTRING ||
            m_nCurrentToken == WQL_TOK_INT     ||
            m_nCurrentToken == WQL_TOK_HEX_CONST  ||
            m_nCurrentToken == WQL_TOK_REAL    ||
            m_nCurrentToken == WQL_TOK_CHAR    ||
            m_nCurrentToken == WQL_TOK_PROMPT  ||
            m_nCurrentToken == WQL_TOK_NULL
           )
        {
            SWQLTypedConst *pTC = 0;
            nRes = typed_const(&pTC);
            if (nRes)
            {
                delete pCL;
                return nRes;
            }

            pCL->Add(pTC);
        }

        if (m_nCurrentToken != WQL_TOK_COMMA)
            break;

        // If here, a comma, indicating a following constant.
        // ==================================================
        if (!Next())
        {
            delete pCL;
            return WBEM_E_INVALID_SYNTAX;
        }
    }

    *pRetVal = pCL;
    return NO_ERROR;
}

//*****************************************************************************************
//
//  QUALIFIED_NAME
//
//  This recognizes a name separated by dots, and recognizes any array references which
//  may occur with those names:
//      a
//      a.b
//      a[n].b[n]
//      a.b.c.d
//      a.b[2].c.d.e[3].f
//      ...etc.
//
//  <qualified_name> ::= WQL_TOK_IDENT <qualified_name2>;
//  <qualified_name2> ::= WQL_TOK_DOT WQL_TOK_IDENT <qualified_name2>;
//
//  <qualified_name2> ::=
//      WQL_TOK_OPEN_BRACKET
//      WQL_TOK_INT
//      WQL_TOK_CLOSEBRACKET
//      <qname_becomes_array_ref>
//      <qualified_name2>;
//
//  <qname_becomes_array_ref> ::= <>;   // Dummy to enforce array semantics
//
//  <qualified_name2> ::= <>;
//
//*****************************************************************************************
// done

int CWQLParser::qualified_name(OUT SWQLQualifiedName **pRetVal)
{
    if (pRetVal == 0)
        return WBEM_E_INVALID_PARAMETER;

    *pRetVal = 0;

    if (m_nCurrentToken != WQL_TOK_IDENT && m_nCurrentToken != WQL_TOK_COUNT)
        return WBEM_E_INVALID_SYNTAX;

    SWQLQualifiedName QN;
    SWQLQualifiedNameField *pQNF;

    pQNF = new SWQLQualifiedNameField;
    if (!pQNF)
        return WBEM_E_OUT_OF_MEMORY;

    pQNF->m_pName = CloneLPWSTR(m_pTokenText);
    if (pQNF->m_pName == 0 || QN.Add(pQNF))
    {
        delete pQNF;
        return WBEM_E_OUT_OF_MEMORY;
    }

    if (wbem_wcsicmp(m_pTokenText, L"__CLASS") == 0)
        m_uFeatures |= WMIQ_RPNF_SYSPROP_CLASS_USED;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    while (1)
    {
        if (m_nCurrentToken == WQL_TOK_DOT)
        {
            // Move past dot
            // ==============

            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            if (!(m_nCurrentToken == WQL_TOK_IDENT || m_nCurrentToken == WQL_TOK_ASTERISK))
                return WBEM_E_INVALID_SYNTAX;

            m_uFeatures |= WMIQ_RPNF_QUALIFIED_NAMES_USED;

            pQNF = new SWQLQualifiedNameField;
            if (!pQNF)
                return WBEM_E_OUT_OF_MEMORY;

            pQNF->m_pName = CloneLPWSTR(m_pTokenText);
            if (!pQNF->m_pName)
                return WBEM_E_OUT_OF_MEMORY;

            QN.Add(pQNF);

            if (wbem_wcsicmp(m_pTokenText, L"__CLASS") == 0)
                m_uFeatures |= WMIQ_RPNF_SYSPROP_CLASS_USED;

            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            continue;
        }

        if (m_nCurrentToken == WQL_TOK_OPEN_BRACKET)
        {
            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            if (m_nCurrentToken != WQL_TOK_INT)
                return WBEM_E_INVALID_SYNTAX;

            unsigned __int64 ArrayIndex = 0;
            BOOL bRes, b64Bit, bSigned;

            m_uFeatures |= WMIQ_RPNF_ARRAY_ACCESS_USED;

            bRes = GetIntToken(&bSigned, &b64Bit, &ArrayIndex);
            if (!bRes || b64Bit || bSigned)
                return WBEM_E_INVALID_SYNTAX;

            pQNF->m_bArrayRef = TRUE;
            pQNF->m_dwArrayIndex = (DWORD) ArrayIndex;

            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            if (m_nCurrentToken != WQL_TOK_CLOSE_BRACKET)
                return WBEM_E_INVALID_SYNTAX;

            if (!Next())
                return WBEM_E_INVALID_SYNTAX;

            continue;
        }

        break;
    }

    // Copy the object and return it.  We worked with the copy QN
    // throughout to avoid complicated cleanup problems on errors, since
    // we take advantage of the auto destructor of <QN> in cases
    // above where we return errors.
    // ==================================================================

    SWQLQualifiedName *pRetCopy = new SWQLQualifiedName(QN);
    if (!pRetCopy)
        return WBEM_E_OUT_OF_MEMORY;

    *pRetVal = pRetCopy;

    return NO_ERROR;
}


//*****************************************************************************************
//
//  col_ref
//
//*****************************************************************************************
// done

int CWQLParser::col_ref(OUT SWQLQualifiedName **pRetVal)
{
    return qualified_name(pRetVal);
}


//*****************************************************************************************
//
//  <col_list> ::= <col_ref> <col_list_rest>;
//  <col_list_rest> ::= WQL_TOK_COMMA <col_ref> <col_list_rest>;
//  <col_list_rest> ::= <>;
//
//*****************************************************************************************
// <status: SWQLColRef fields to be analyzed and filled in. Testable, though>

int CWQLParser::col_list(OUT SWQLNode_ColumnList **pRetColList)
{
    *pRetColList = 0;
    SWQLNode_ColumnList *pColList = new SWQLNode_ColumnList;

    if (!pColList)
        return WBEM_E_OUT_OF_MEMORY;

    while (1)
    {
        SWQLQualifiedName *pColRef = 0;

        int nRes = col_ref(&pColRef);
        if (nRes)
        {
            delete pColList;
            return nRes;
        }

        // If here, we have a legit column to add to the node.
        // ===================================================

        SWQLColRef *pCRef = 0;

        QNameToSWQLColRef(pColRef, &pCRef);

        pColList->m_aColumnRefs.Add(pCRef);

        // Check for sortation indication
        // ==============================

        if (m_nCurrentToken == WQL_TOK_ASC)
        {
            pCRef->m_dwFlags |= WQL_FLAG_SORT_ASC;
            if (!Next())
            {
                delete pColList;
                return WBEM_E_INVALID_SYNTAX;
            }
        }
        else if (m_nCurrentToken == WQL_TOK_DESC)
        {
            pCRef->m_dwFlags |= WQL_FLAG_SORT_DESC;
            if (!Next())
            {
                delete pColList;
                return WBEM_E_INVALID_SYNTAX;
            }
        }

        // Check for a continuation.
        // =========================

        if (m_nCurrentToken != WQL_TOK_COMMA)
            break;

        if (!Next())
        {
            delete pColList;
            return WBEM_E_INVALID_SYNTAX;
        }
    }

    *pRetColList = pColList;
    return NO_ERROR;
}


//*****************************************************************************************
//
//  <subselect_stmt> ::=
//      WQL_TOK_SELECT
//      <select_type>
//      <col_ref>                   // Must not be an asterisk
//      <from_clause>
//      <where_clause>
//
//*****************************************************************************************

int CWQLParser::subselect_stmt(OUT SWQLNode_Select **pRetSel)
{
    int nSelType;
    int nRes = 0;

    SWQLNode_FromClause *pFrom = 0;
    SWQLNode_Select *pSel = 0;
    SWQLNode_TableRefs *pTblRefs = 0;
    SWQLNode_WhereClause *pWhere = 0;

    *pRetSel = 0;

    // Verify that we are in a subselect.
    // ==================================

    if (m_nCurrentToken != WQL_TOK_SELECT)
        return WBEM_E_INVALID_SYNTAX;

    if (!Next())
        return WBEM_E_INVALID_SYNTAX;

    // This affects some of the productions, since they behave differently
    // in subselects than in primary selects.
    // ===================================================================

    m_nParseContext = Ctx_Subselect;

    // If here, we are definitely in a subselect, so
    // allocate a new node.
    // ==============================================

    pSel = new SWQLNode_Select;
    if (!pSel)
        return WBEM_E_OUT_OF_MEMORY;

    pTblRefs = new SWQLNode_TableRefs;
    if (!pTblRefs)
    {
        delete pSel;
        return WBEM_E_OUT_OF_MEMORY;
    }
    pSel->m_pLeft = pTblRefs;

    // Find the select type.
    // =====================

    nRes = select_type(nSelType);
    if (nRes)
        return nRes;

    pTblRefs->m_nSelectType = nSelType;        // ALL, DISTINCT

    // Get the column list.  In this case
    // it must be a single column and not
    // an asterisk.
    // ====================================

    nRes = col_ref_list(pTblRefs);
    if (nRes)
        return nRes;

    // Get the FROM clause and patch it in.
    // =====================================

    nRes = from_clause(&pFrom);
    if (nRes)
        return nRes;

    pTblRefs->m_pRight = pFrom;

    // Get the WHERE clause.
    // =====================

    nRes = where_clause(&pWhere);
    if (nRes)
        return nRes;

    pSel->m_pRight = pWhere;

    *pRetSel = pSel;

    m_nParseContext = Ctx_Default;     // No longer in a subselect

    return NO_ERROR;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Containers
//
/////////////////////////////////////////////////////////////////////////////

//***************************************************************************
//
//  SWQLTypedConst constructor
//
//***************************************************************************
// done

SWQLTypedConst::SWQLTypedConst()
{
    m_dwType = VT_NULL;
    m_bPrompt = false;
    memset(&m_Value, 0, sizeof(m_Value));
}

//***************************************************************************
//
//  SWQLTypedConst::operator =
//
//***************************************************************************
// done

SWQLTypedConst & SWQLTypedConst::operator = (SWQLTypedConst &Src)
{
    Empty();

    if (Src.m_dwType == VT_LPWSTR)
    {
        m_Value.m_pString = CloneLPWSTR(Src.m_Value.m_pString);
        if (CloneFailed(m_Value.m_pString,Src.m_Value.m_pString))
            throw CX_MemoryException();
    }
    else
    {
        m_Value = Src.m_Value;
    }

    m_dwType = Src.m_dwType;
    m_bPrompt = Src.m_bPrompt;

    return *this;
}

//***************************************************************************
//
//  SWQLTypedConst::Empty()
//
//***************************************************************************
// done

void SWQLTypedConst::Empty()
{
    if (m_dwType == VT_LPWSTR)
        delete [] m_Value.m_pString;
    m_bPrompt = false;
}



//***************************************************************************
//
//  SWQLConstList::operator =
//
//***************************************************************************
// done

SWQLConstList & SWQLConstList::operator = (SWQLConstList & Src)
{
    Empty();

    for (int i = 0; i < Src.m_aValues.Size(); i++)
    {
        SWQLTypedConst *pC = (SWQLTypedConst *) Src.m_aValues[i];
        m_aValues.Add(new SWQLTypedConst(*pC));
    }

    return *this;
}

//***************************************************************************
//
//  SWQLConstList::Empty
//
//***************************************************************************
// done

void SWQLConstList::Empty()
{
    for (int i = 0; i < m_aValues.Size(); i++)
        delete (SWQLTypedConst *) m_aValues[i];
    m_aValues.Empty();
}

//***************************************************************************
//
//  SWQLQualifiedName::operator =
//
//***************************************************************************
// done

SWQLQualifiedName & SWQLQualifiedName::operator = (SWQLQualifiedName &Src)
{
    Empty();

    for (int i = 0; i < Src.m_aFields.Size(); i++)
    {
        SWQLQualifiedNameField *pQN = new SWQLQualifiedNameField;
        if (!pQN)
            throw CX_MemoryException();

        *pQN = *(SWQLQualifiedNameField *) Src.m_aFields[i];
        m_aFields.Add(pQN);
    }

    return *this;
}

//***************************************************************************
//
//  SWQLQualifiedNameField::operator =
//
//***************************************************************************
// done


SWQLQualifiedNameField &
    SWQLQualifiedNameField::operator =(SWQLQualifiedNameField &Src)
{
    Empty();

    m_bArrayRef = Src.m_bArrayRef;
    m_pName = CloneLPWSTR(Src.m_pName);
    if (CloneFailed(m_pName,Src.m_pName))
        throw CX_MemoryException();
    m_dwArrayIndex = Src.m_dwArrayIndex;
    return *this;
}




//***************************************************************************
//
//  SWQLNode_ColumnList destructor
//
//***************************************************************************
// tbd


//***************************************************************************
//
//  QNameToSWQLColRef
//
//  Translates a qualified name to a SWQLColRef structure and embeds
//  the q-name into the struct (since that is a field).
//
//***************************************************************************

int CWQLParser::QNameToSWQLColRef(
    IN  SWQLQualifiedName *pQName,
    OUT SWQLColRef **pRetVal
    )
{
    *pRetVal = 0;
    if (pQName == 0 || pRetVal == 0)
        return WBEM_E_INVALID_PARAMETER;

    SWQLColRef *pCR = new SWQLColRef;
    if (!pCR)
        return WBEM_E_OUT_OF_MEMORY;

    // Algorithm: With a two name sequence, assume that the first name is
    // the table and that the second name is the column. If multiple
    // names occur, then we set the SWQLColRef type to WQL_FLAG_COMPLEX
    // and just take the last name for the column.
    // ==================================================================

    if (pQName->m_aFields.Size() == 2)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pQName->m_aFields[1];
        SWQLQualifiedNameField *pTbl = (SWQLQualifiedNameField *) pQName->m_aFields[0];

        pCR->m_pColName = CloneLPWSTR(pCol->m_pName);
        pCR->m_pTableRef = CloneLPWSTR(pTbl->m_pName);
        if (!pCR->m_pColName || !pCR->m_pTableRef)
            return WBEM_E_OUT_OF_MEMORY;

        pCR->m_dwFlags = WQL_FLAG_TABLE | WQL_FLAG_COLUMN;

        if (wbem_wcsicmp(L"*", pCol->m_pName) == 0)
            pCR->m_dwFlags |= WQL_FLAG_ASTERISK;

        if (pCol->m_bArrayRef)
        {
            pCR->m_dwFlags |= WQL_FLAG_ARRAY_REF;
            pCR->m_dwArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    else if (pQName->m_aFields.Size() == 1)
    {
        SWQLQualifiedNameField *pCol = (SWQLQualifiedNameField *) pQName->m_aFields[0];
        pCR->m_pColName = CloneLPWSTR(pCol->m_pName);
        if (!pCR->m_pColName)
            return WBEM_E_OUT_OF_MEMORY;

        pCR->m_dwFlags |= WQL_FLAG_COLUMN;

        if (wbem_wcsicmp(L"*", pCol->m_pName) == 0)
            pCR->m_dwFlags |= WQL_FLAG_ASTERISK;

        if (pCol->m_bArrayRef)
        {
            pCR->m_dwFlags |= WQL_FLAG_ARRAY_REF;
            pCR->m_dwArrayIndex = pCol->m_dwArrayIndex;
        }
    }

    // Complex case.
    // =============
    else
    {
        pCR->m_dwFlags = WQL_FLAG_COMPLEX_NAME;
    }

    // Copy the qualified name.
    // ========================

    pCR->m_pQName = pQName;

    *pRetVal = pCR;

    return NO_ERROR;;
}




//***************************************************************************
//
//  SWQLNode_ColumnList::DebugDump
//
//***************************************************************************
void SWQLNode_ColumnList::DebugDump()
{
    printf("---SWQLNode_ColumnList---\n");
    for (int i = 0; i < m_aColumnRefs.Size(); i++)
    {
        SWQLColRef *pCR = (SWQLColRef *) m_aColumnRefs[i];
        if (pCR)
            pCR->DebugDump();
    }

    printf("---End SWQLNode_ColumnList---\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_TableRefs::DebugDump()
{
    printf("********** BEGIN SWQLNode_TableRefs *************\n");
    printf("Select type = ");
    if (m_nSelectType & WQL_FLAG_COUNT)
        printf("WQL_FLAG_COUNT ");
    if (m_nSelectType & WQL_FLAG_ALL)
        printf("WQL_FLAG_ALL ");
    if (m_nSelectType & WQL_FLAG_DISTINCT)
        printf("WQL_FLAG_DISTINCT ");
    printf("\n");

    if (m_pLeft)
        m_pLeft->DebugDump();
    if (m_pRight)
        m_pRight->DebugDump();
    printf("********** END SWQLNode_TableRefs *************\n\n\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_FromClause::DebugDump()
{
    printf("---SWQLNode_FromClause---\n");

    if (m_pLeft == 0)
        return;
    m_pLeft->DebugDump();

    printf("---End SWQLNode_FromClause---\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_Select::DebugDump()
{
    printf("********** BEGIN SWQLNode_Select *************\n");
    if (m_pLeft)
        m_pLeft->DebugDump();
    if (m_pRight)
        m_pRight->DebugDump();
    printf("********** END SWQLNode_Select *************\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_WmiScopedSelect::DebugDump()
{
    printf("********** BEGIN SWQLNode_WmiScopedSelect *************\n");
    printf("Scope = %S\n", m_pszScope);
    for (int i = 0; i < m_aTables.Size(); i++)
    {
        printf("Selected table = %S\n", LPWSTR(m_aTables[i]));
    }
    printf("********** END SWQLNode_WmiScopedSelect *************\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_TableRef::DebugDump()
{
    printf("  ---TableRef---\n");
    printf("  TableName = %S\n", m_pTableName);
    printf("  Alias     = %S\n", m_pAlias);
    printf("  ---End TableRef---\n");
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_Join::DebugDump()
{
    printf("---SWQLNode_Join---\n");

    printf("Join type = ");

    switch (m_dwJoinType)
    {
        case WQL_FLAG_INNER_JOIN : printf("WQL_FLAG_INNER_JOIN "); break;
        case WQL_FLAG_FULL_OUTER_JOIN : printf("WQL_FLAG_FULL_OUTER_JOIN "); break;
        case WQL_FLAG_LEFT_OUTER_JOIN : printf("WQL_FLAG_LEFT_OUTER_JOIN "); break;
        case WQL_FLAG_RIGHT_OUTER_JOIN : printf("WQL_FLAG_RIGHT_OUTER_JOIN "); break;
        default: printf("<error> ");
    }

    if (m_dwFlags & WQL_FLAG_FIRSTROW)
        printf(" (FIRSTROW)");

    printf("\n");

    if (m_pRight)
        m_pRight->DebugDump();

    if (m_pLeft)
        m_pLeft->DebugDump();

    printf("---End SWQLNode_Join---\n");
}

//***************************************************************************
//
//  SWQLNode_Sql89Join::Empty
//
//***************************************************************************

void SWQLNode_Sql89Join::Empty()
{
    for (int i = 0; i < m_aValues.Size(); i++)
        delete (SWQLNode_TableRef *) m_aValues[i];
    m_aValues.Empty();
}

//***************************************************************************
//
//  SWQLNode_Sql89Join::DebugDump
//
//***************************************************************************

void SWQLNode_Sql89Join::DebugDump()
{
    printf("\n========== SQL 89 JOIN =================================\n");
    for (int i = 0; i < m_aValues.Size(); i++)
    {
        SWQLNode_TableRef *pTR = (SWQLNode_TableRef *) m_aValues[i];
        if (pTR)
            pTR->DebugDump();
    }
    printf("\n========== END SQL 89 JOIN =============================\n");

}


//***************************************************************************
//
//  SWQLNode_WhereClause::DebugDump
//
//***************************************************************************

void SWQLNode_WhereClause::DebugDump()
{
    printf("\n========== WHERE CLAUSE ================================\n");

    if (m_pLeft)
        m_pLeft->DebugDump();
    else
        printf(" <no where clause> \n");
    if (m_pRight)
        m_pRight->DebugDump();

    printf("============= END WHERE CLAUSE ============================\n");
}

//***************************************************************************
//
//  SWQLNode_WhereOptions::DebugDump
//
//***************************************************************************

void SWQLNode_WhereOptions::DebugDump()
{
    printf("---- Where Options ----\n");

    if (m_pLeft)
        m_pLeft->DebugDump();
    if (m_pRight)
        m_pRight->DebugDump();

    printf("---- End Where Options ----\n");
}

//***************************************************************************
//
//  SWQLNode_Having::DebugDump
//
//***************************************************************************

void SWQLNode_Having::DebugDump()
{
    printf("---- Having ----\n");

    if (m_pLeft)
        m_pLeft->DebugDump();
    if (m_pRight)
        m_pRight->DebugDump();

    printf("---- End Having ----\n");
}

//***************************************************************************
//
//  SWQLNode_GroupBy::DebugDump
//
//***************************************************************************

void SWQLNode_GroupBy::DebugDump()
{
    printf("---- Group By ----\n");

    if (m_pLeft)
        m_pLeft->DebugDump();
    if (m_pRight)
        m_pRight->DebugDump();

    printf("---- End Group By ----\n");
}


//***************************************************************************
//
//  SWQLNode_RelExpr::DebugDump
//
//***************************************************************************

void SWQLNode_RelExpr::DebugDump()
{
    if (m_pRight)
        m_pRight->DebugDump();

    printf("   --- SWQLNode_RelExpr ---\n");

    switch (m_dwExprType)
    {
        case WQL_TOK_OR:
            printf("    <WQL_TOK_OR>\n");
            break;

        case WQL_TOK_AND:
            printf("    <WQL_TOK_AND>\n");
            break;

        case WQL_TOK_NOT:
            printf("    <WQL_TOK_NOT>\n");
            break;

        case WQL_TOK_TYPED_EXPR:
            printf("    <WQL_TOK_TYPED_EXPR>\n");
            m_pTypedExpr->DebugDump();
            break;

        default:
            printf("    <invalid>\n");
    }

    printf("   --- END SWQLNode_RelExpr ---\n\n");

    if (m_pLeft)
        m_pLeft->DebugDump();

}

//***************************************************************************
//
//***************************************************************************

static LPWSTR OpToStr(DWORD dwOp)
{
    LPWSTR pRet = 0;

    switch (dwOp)
    {
        case WQL_TOK_EQ: pRet = L" '='   <WQL_TOK_EQ>"; break;
        case WQL_TOK_NE: pRet = L" '!='  <WQL_TOK_NE>"; break;
        case WQL_TOK_GT: pRet = L" '>'   <WQL_TOK_GT>"; break;
        case WQL_TOK_LT: pRet = L" '<'   <WQL_TOK_LT>"; break;
        case WQL_TOK_GE: pRet = L" '>='  <WQL_TOK_GE>"; break;
        case WQL_TOK_LE: pRet = L" '<='  <WQL_TOK_LE>"; break;

        case WQL_TOK_IN_CONST_LIST : pRet = L" IN <WQL_TOK_IN_CONST_LIST>"; break;
        case WQL_TOK_NOT_IN_CONST_LIST : pRet = L" NOT IN <WQL_TOK_NOT_IN_CONST_LIST>"; break;
        case WQL_TOK_IN_SUBSELECT : pRet = L" IN <WQL_TOK_IN_SUBSELECT>"; break;
        case WQL_TOK_NOT_IN_SUBSELECT : pRet = L" NOT IN <WQL_TOK_NOT_IN_SUBSELECT>"; break;

        case WQL_TOK_ISNULL: pRet = L"<WQL_TOK_ISNULL>"; break;
        case WQL_TOK_NOT_NULL: pRet = L"<WQL_TOK_NOT_NULL>"; break;

        case WQL_TOK_BETWEEN: pRet = L"<WQL_TOK_BETWEEN>"; break;
        case WQL_TOK_NOT_BETWEEN: pRet = L"<WQL_TOK_NOT_BETWEEN>"; break;

        default: pRet = L"   <unknown operator>"; break;
    }

    return pRet;
}

//***************************************************************************
//
//***************************************************************************

void SWQLTypedExpr::DebugDump()
{
    printf("        === BEGIN SWQLTypedExpr ===\n");
    printf("        m_pTableRef     = %S\n", m_pTableRef);
    printf("        m_pColRef       = %S\n", m_pColRef);
    printf("        m_pJoinTableRef = %S\n", m_pJoinTableRef);
    printf("        m_pJoinColRef   = %S\n", m_pJoinColRef);
    printf("        m_dwRelOperator = %S\n", OpToStr(m_dwRelOperator));
//    printf("        m_pSubSelect    = 0x%X\n", m_pSubSelect);
    printf("        m_dwLeftArrayIndex = %d\n", m_dwLeftArrayIndex);
    printf("        m_dwRightArrayIndex = %d\n", m_dwRightArrayIndex);

    printf("        m_pConstValue   = ");
    if (m_pConstValue)
        m_pConstValue->DebugDump();
    else
        printf("  NULL ptr \n");

    printf("        m_pConstValue2   = ");
    if (m_pConstValue2)
        m_pConstValue2->DebugDump();
    else
        printf("  NULL ptr \n");



    printf("        m_dwLeftFlags = (0x%X)", m_dwLeftFlags);
    if (m_dwLeftFlags & WQL_FLAG_COLUMN)
        printf(" WQL_FLAG_COLUMN");
    if (m_dwLeftFlags & WQL_FLAG_TABLE)
        printf(" WQL_FLAG_TABLE");
    if (m_dwLeftFlags & WQL_FLAG_CONST)
        printf(" WQL_FLAG_CONST");
    if (m_dwLeftFlags & WQL_FLAG_COMPLEX_NAME)
        printf(" WQL_FLAG_COMPLEX_NAME");
    if (m_dwLeftFlags & WQL_FLAG_SORT_ASC)
        printf(" WQL_FLAG_SORT_ASC");
    if (m_dwLeftFlags & WQL_FLAG_SORT_DESC)
        printf(" WQL_FLAG_SORT_DESC");
    if (m_dwLeftFlags & WQL_FLAG_FUNCTIONIZED)
        printf(" WQL_FLAG_FUNCTIONIZED (Function=%S)", m_pIntrinsicFuncOnColRef);
    if (m_dwLeftFlags & WQL_FLAG_ARRAY_REF)
        printf(" WQL_FLAG_ARRAY_REF");
    printf("\n");


    printf("        m_dwRightFlags = (0x%X)", m_dwRightFlags);
    if (m_dwRightFlags & WQL_FLAG_COLUMN)
        printf(" WQL_FLAG_COLUMN");
    if (m_dwRightFlags & WQL_FLAG_TABLE)
        printf(" WQL_FLAG_TABLE");
    if (m_dwRightFlags & WQL_FLAG_CONST)
        printf(" WQL_FLAG_CONST");
    if (m_dwRightFlags & WQL_FLAG_COMPLEX_NAME)
        printf(" WQL_FLAG_COMPLEX_NAME");
    if (m_dwLeftFlags & WQL_FLAG_SORT_ASC)
        printf(" WQL_FLAG_SORT_ASC");
    if (m_dwLeftFlags & WQL_FLAG_SORT_DESC)
        printf(" WQL_FLAG_SORT_DESC");
    if (m_dwRightFlags & WQL_FLAG_FUNCTIONIZED)
    {
        printf(" WQL_FLAG_FUNCTIONIZED");
        if (m_pIntrinsicFuncOnJoinColRef)
            printf("(On join col: Function=%S)", m_pIntrinsicFuncOnJoinColRef);
        if (m_pIntrinsicFuncOnConstValue)
            printf("(On const: Function=%S)", m_pIntrinsicFuncOnConstValue);
    }
    if (m_dwRightFlags & WQL_FLAG_ARRAY_REF)
        printf(" WQL_FLAG_ARRAY_REF");

    if (m_dwRightFlags & WQL_FLAG_CONST_RANGE)
        printf(" WQL_FLAG_CONST_RANGE");

    printf("\n");

    if (m_pLeftFunction)
    {
        printf("m_pLeftFunction: \n");
        m_pLeftFunction->DebugDump();
    }
    if (m_pRightFunction)
    {
        printf("m_pRightFunction: \n");
        m_pRightFunction->DebugDump();
    }

    if (m_pConstList)
    {
        printf("   ---Const List---\n");
        for (int i = 0; i < m_pConstList->m_aValues.Size(); i++)
        {
            SWQLTypedConst *pConst = (SWQLTypedConst *) m_pConstList->m_aValues.GetAt(i);
            printf("    ");
            pConst->DebugDump();
        }

        printf("   ---End Const List---\n");
    }

    // Subselects
    // ==========
    if (m_pSubSelect)
    {
        printf("    ------- Begin Subselect ------\n");
        m_pSubSelect->DebugDump();
        printf("    ------- End   Subselect ------\n");
    }

    printf("\n");

    printf("        === END SWQLTypedExpr ===\n");
}

//***************************************************************************
//
//***************************************************************************

SWQLTypedExpr::SWQLTypedExpr()
{
    m_pTableRef = 0;
    m_pColRef = 0;
    m_dwRelOperator = 0;
    m_pConstValue = 0;
    m_pConstValue2 = 0;
    m_pJoinTableRef = 0;
    m_pJoinColRef = 0;
    m_pIntrinsicFuncOnColRef = 0;
    m_pIntrinsicFuncOnJoinColRef = 0;
    m_pIntrinsicFuncOnConstValue = 0;
    m_pLeftFunction = 0;
    m_pRightFunction = 0;
    m_pQNRight = 0;
    m_pQNLeft = 0;
    m_dwLeftFlags = 0;
    m_dwRightFlags = 0;
    m_pSubSelect = 0;
    m_dwLeftArrayIndex = 0;
    m_dwRightArrayIndex = 0;
    m_pConstList = 0;
}

//***************************************************************************
//
//***************************************************************************

void SWQLTypedExpr::Empty()
{
    delete [] m_pTableRef;
    delete [] m_pColRef;

    delete m_pConstValue;
    delete m_pConstValue2;

    delete m_pConstList;

    delete [] m_pJoinTableRef;
    delete [] m_pJoinColRef;
    delete [] m_pIntrinsicFuncOnColRef;
    delete [] m_pIntrinsicFuncOnJoinColRef;
    delete [] m_pIntrinsicFuncOnConstValue;

    delete m_pLeftFunction;
    delete m_pRightFunction;
    delete m_pQNRight;
    delete m_pQNLeft;
    delete m_pSubSelect;
}

//***************************************************************************
//
//***************************************************************************
//
void SWQLNode_Delete::DebugDump()
{
    printf("Delete Node\n");

    printf("FROM:");
    if (m_pLeft)
        m_pLeft->DebugDump();
    printf("WHERE:");
    if (m_pRight)
        m_pRight->DebugDump();
}

//***************************************************************************
//
//***************************************************************************
SWQLNode_Delete::~SWQLNode_Delete()
{
    // nothing for now
}


//***************************************************************************
//
//***************************************************************************

void SWQLTypedConst::DebugDump()
{
    printf("   Typed Const <");

    switch (m_dwType)
    {
        case VT_LPWSTR:
            printf("%S", m_Value.m_pString);
            break;

        case VT_I4:
            printf("%d (0x%X)", m_Value.m_lValue, m_Value.m_lValue);
            break;

        case VT_R8:
            printf("%f", m_Value.m_dblValue);
            break;

        case VT_BOOL:
            printf("(bool) %d", m_Value.m_bValue);
            break;

        case VT_NULL:
            printf(" NULL");
            break;

        default:
            printf(" unknown");
    }

    printf(">\n");
}


//***************************************************************************
//
//***************************************************************************

static DWORD FlipOperator(DWORD dwOp)
{
    switch (dwOp)
    {
        case WQL_TOK_LT: return WQL_TOK_GT;
        case WQL_TOK_LE: return WQL_TOK_GE;
        case WQL_TOK_GT: return WQL_TOK_LT;
        case WQL_TOK_GE: return WQL_TOK_LE;
    }

    return dwOp; // Echo original
}

//***************************************************************************
//
//***************************************************************************

void SWQLNode_JoinPair::DebugDump()
{
    printf("---SWQLNode_JoinPair---\n");
    if (m_pRight)
        m_pRight->DebugDump();
    if (m_pLeft)
        m_pLeft->DebugDump();
    printf("---End SWQLNode_JoinPair---\n");
}

void SWQLNode_OnClause::DebugDump()
{
    printf("---SWQLNode_OnClause---\n");
    if (m_pLeft)
        m_pLeft->DebugDump();
    printf("---END SWQLNode_OnClause---\n");
}


//***************************************************************************
//
//***************************************************************************

void SWQLNode_OrderBy::DebugDump()
{
    printf("\n\n---- 'ORDER BY' Clause ----\n");
    if (m_pLeft)
        m_pLeft->DebugDump();
    printf("---- End 'ORDER BY' Clause ----\n\n");
}

//***************************************************************************
//
//***************************************************************************


const LPWSTR CWQLParser::AliasToTable(IN LPWSTR pAlias)
{
    const CFlexArray *pAliases = GetSelectedAliases();

    for (int i = 0; i < pAliases->Size(); i++)
    {
        SWQLNode_TableRef *pTR = (SWQLNode_TableRef *) pAliases->GetAt(i);

        if (wbem_wcsicmp(pTR->m_pAlias, pAlias) == 0)
            return pTR->m_pTableName;
    }

    return NULL;    // Not found
}


//***************************************************************************
//
//***************************************************************************
//

void SWQLNode_Datepart::DebugDump()
{
    printf("        ----Begin SWQLNode_Datepart----\n");

    switch (m_nDatepart)
    {
        case WQL_TOK_YEAR:   printf("       WQL_TOK_YEAR"); break;
        case WQL_TOK_MONTH:  printf("       WQL_TOK_MONTH"); break;
        case WQL_TOK_DAY:    printf("       WQL_TOK_DAY"); break;
        case WQL_TOK_HOUR:   printf("       WQL_TOK_HOUR"); break;
        case WQL_TOK_MINUTE: printf("       WQL_TOK_MINUTE"); break;
        case WQL_TOK_SECOND: printf("       WQL_TOK_SECOND"); break;
        case WQL_TOK_MILLISECOND: printf("      WQL_TOK_MILLISECOND"); break;
        default:
            printf("        -> No datepart specified\n");
    }

    printf("\n");

    if (m_pColRef)
        m_pColRef->DebugDump();

    printf("        ----End SWQLNode_Datepart----\n");
}


//***************************************************************************
//
//***************************************************************************
//

void SWQLNode_ColumnList::Empty()
{
    for (int i = 0; i < m_aColumnRefs.Size(); i++)
        delete (SWQLColRef *) m_aColumnRefs[i];
    m_aColumnRefs.Empty();
}


//***************************************************************************
//
//***************************************************************************
//

void StrArrayDelete(
    ULONG uSize,
    LPWSTR *pszArray
    )
{
    if (!pszArray)
    	return;
    for (unsigned u = 0; u < uSize; u++)
        delete  pszArray[u];
    delete pszArray;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT StrArrayCopy(
    ULONG  uSize,
    LPWSTR *pSrc,
    LPWSTR **pDest
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    LPWSTR *pFinal = new LPWSTR[uSize];
    if (pFinal)
    {
        for (ULONG u = 0; u < uSize; u++)
        {
            pFinal[u] = CloneLPWSTR(pSrc[u]);
            if (!pFinal[u])
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                break;
            }
        }

        if (SUCCEEDED(hr))
        {
            *pDest = pFinal;
        }
        else
        {
            for (ULONG u2 = 0; u2 < u; u2++)
            {
                delete pFinal[u];
            }
            delete [] pFinal;
        }
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

//***************************************************************************
//
//***************************************************************************
//

CWbemQueryQualifiedName::CWbemQueryQualifiedName()
{
    Init();
}

//***************************************************************************
//
//***************************************************************************
//

void CWbemQueryQualifiedName::Init()
{
    m_uVersion = 1;
    m_uTokenType = 1;

    m_uNameListSize = 0;
    m_ppszNameList = 0;

    m_bArraysUsed = 0;
    m_pbArrayElUsed = 0;
    m_puArrayIndex = 0;
}

//////////////////////////////////////////////////////////////////////////////////
// *

CWbemQueryQualifiedName::~CWbemQueryQualifiedName() { DeleteAll(); }

void CWbemQueryQualifiedName::DeleteAll()
{
    StrArrayDelete(m_uNameListSize, (LPWSTR *) m_ppszNameList);
    
    delete [] m_pbArrayElUsed;
    delete [] m_puArrayIndex;
}

//////////////////////////////////////////////////////////////////////////////////
//

CWbemQueryQualifiedName::CWbemQueryQualifiedName(CWbemQueryQualifiedName &Src)
{
    Init();
    *this = Src;
}

//////////////////////////////////////////////////////////////////////////////////
//

CWbemQueryQualifiedName& CWbemQueryQualifiedName::operator =(CWbemQueryQualifiedName &Src)
{
    DeleteAll();

    m_uVersion = Src.m_uVersion;
    m_uTokenType = Src.m_uTokenType;

    m_uNameListSize = Src.m_uNameListSize;

    m_ppszNameList = new LPCWSTR[m_uNameListSize];
    m_pbArrayElUsed = new BOOL[m_uNameListSize];
    m_puArrayIndex = new ULONG[m_uNameListSize];

    if (!m_ppszNameList || !m_pbArrayElUsed || !m_puArrayIndex)
        throw CX_MemoryException();

    for (unsigned u = 0; u < m_uNameListSize; u++)
    {
        m_pbArrayElUsed[u] = Src.m_pbArrayElUsed[u];
        m_puArrayIndex[u] = Src.m_puArrayIndex[u];
    }

    if (FAILED(StrArrayCopy(m_uNameListSize, (LPWSTR *) Src.m_ppszNameList, (LPWSTR **) &m_ppszNameList)))
	throw CX_MemoryException();

    return *this;
};

//////////////////////////////////////////////////////////////////////////////////
//

void CWbemRpnQueryToken::Init()
{
    m_uVersion = 1;
    m_uTokenType = 0;

    m_uSubexpressionShape = 0;
    m_uOperator = 0;

    m_pRightIdent = 0;
    m_pLeftIdent = 0;

    m_uConstApparentType = 0;  // VT_ type
    m_uConst2ApparentType  = 0;

    m_Const.m_uVal64 = 0;
    m_Const2.m_uVal64 = 0;

    m_pszLeftFunc = 0;
    m_pszRightFunc = 0;
}


///////////////////////////////////////////////////////////////////////////////////
//
//

CWbemRpnQueryToken::CWbemRpnQueryToken()
{
    Init();
}

///////////////////////////////////////////////////////////////////////////////////
//
//

void CWbemRpnEncodedQuery::DeleteAll()
{
    unsigned u = 0;

    for (u = 0; u < m_uSelectListSize; u++)
    {
        SWbemQueryQualifiedName *pQN = m_ppSelectList[u];
        CWbemQueryQualifiedName  *pTmp = (CWbemQueryQualifiedName*) pQN;
        delete pTmp;
    }

    delete [] m_puDetectedFeatures;
    delete [] m_ppSelectList;
    delete LPWSTR(m_pszOptionalFromPath);

    StrArrayDelete(m_uFromListSize, (LPWSTR *) m_ppszFromList);

    for (u = 0; u < m_uWhereClauseSize; u++)
    {
        CWbemRpnQueryToken *pTmp = (CWbemRpnQueryToken *) m_ppRpnWhereClause[u];
        delete pTmp;
    }

    m_uWhereClauseSize = 0;

    delete [] m_ppRpnWhereClause;
    StrArrayDelete(m_uOrderByListSize, (LPWSTR *) m_ppszOrderByList);
}

//////////////////////////////////////////////////////////////////////////////////
//

CWbemRpnQueryToken::~CWbemRpnQueryToken() { DeleteAll(); }

void CWbemRpnQueryToken::DeleteAll()
{
    delete (CWbemQueryQualifiedName *) m_pRightIdent;
    delete (CWbemQueryQualifiedName *) m_pLeftIdent;

    if (m_uConstApparentType == VT_LPWSTR)
    {
        delete (LPWSTR) m_Const.m_pszStrVal;
    }

    if (m_uConst2ApparentType == VT_LPWSTR)
    {
        delete (LPWSTR) m_Const2.m_pszStrVal;
    }


    delete LPWSTR(m_pszLeftFunc);
    delete LPWSTR(m_pszRightFunc);
}

//////////////////////////////////////////////////////////////////////////////////
//

CWbemRpnQueryToken::CWbemRpnQueryToken(CWbemRpnQueryToken &Src)
{
    Init();
    *this = Src;
}

//////////////////////////////////////////////////////////////////////////////////
//

CWbemRpnQueryToken& CWbemRpnQueryToken::operator =(CWbemRpnQueryToken &Src)
{
    // Kill old stuff.

    DeleteAll();

    // Copy new stuff.

    m_pRightIdent = (SWbemQueryQualifiedName *) new CWbemQueryQualifiedName(
        *(CWbemQueryQualifiedName *) Src.m_pRightIdent
        );

    m_pLeftIdent = (SWbemQueryQualifiedName *) new CWbemQueryQualifiedName(
        *(CWbemQueryQualifiedName *) Src.m_pLeftIdent
        );

    if (!m_pRightIdent || !m_pLeftIdent)
        throw CX_MemoryException();

    m_uConstApparentType = Src.m_uConstApparentType;
    m_uConst2ApparentType = Src.m_uConst2ApparentType;

    if (m_uConstApparentType == VT_LPWSTR)
    {
        m_Const.m_pszStrVal = CloneLPWSTR(Src.m_Const.m_pszStrVal);\
        if (!m_Const.m_pszStrVal)
            throw CX_MemoryException();
    }
    else
        m_Const = Src.m_Const;

    if (m_uConst2ApparentType == VT_LPWSTR)
    {
        m_Const2.m_pszStrVal = CloneLPWSTR(Src.m_Const2.m_pszStrVal);
        if (!m_Const2.m_pszStrVal)
            throw CX_MemoryException();
    }
    else
        m_Const2 = Src.m_Const2;

    m_pszLeftFunc = CloneLPWSTR(Src.m_pszLeftFunc);
    if (CloneFailed(m_pszLeftFunc,Src.m_pszLeftFunc))
        throw CX_MemoryException();
    m_pszRightFunc = CloneLPWSTR(Src.m_pszRightFunc);
    if (CloneFailed(m_pszRightFunc,Src.m_pszRightFunc))
        throw CX_MemoryException();

    return *this;
};

//////////////////////////////////////////////////////////////////////////////////

void CWbemRpnEncodedQuery::Init()
{
    m_uVersion = 1;
    m_uTokenType = 0;

    m_uParsedFeatureMask = 0I64;

    m_uDetectedArraySize = 0;
    m_puDetectedFeatures = 0;

    m_uSelectListSize = 0;
    m_ppSelectList = 0;

    // FROM clause
    // ===========

    m_uFromTargetType = 0;
    m_pszOptionalFromPath = 0;
    m_uFromListSize = 0;
    m_ppszFromList = 0;

    // Where clause
    // ============

    m_uWhereClauseSize = 0;
    m_ppRpnWhereClause = 0;

    // WITHIN value
    // ============

    m_dblWithinPolling = 0.0;
    m_dblWithinWindow = 0.0;

    // ORDER BY
    // ========

    m_uOrderByListSize = 0;
    m_ppszOrderByList = 0;
    m_uOrderDirectionEl = 0;
}


///////////////////////////////////////////////////////////////////////////////////
//
//

CWbemRpnEncodedQuery::CWbemRpnEncodedQuery()
{
    Init();
}

///////////////////////////////////////////////////////////////////////////////////
//
//


CWbemRpnEncodedQuery::~CWbemRpnEncodedQuery()
{
    DeleteAll();
}

///////////////////////////////////////////////////////////////////////////////////
//
//

CWbemRpnEncodedQuery::CWbemRpnEncodedQuery(CWbemRpnEncodedQuery &Src)
{
    Init();
    *this = Src;
}

///////////////////////////////////////////////////////////////////////////////////
//
//

CWbemRpnEncodedQuery& CWbemRpnEncodedQuery::operator=(CWbemRpnEncodedQuery &Src)
{
    unsigned u;

    // Kill old stuff.
    DeleteAll();

    // Clone new stuff.

    m_uVersion = Src.m_uVersion;
    m_uTokenType  = Src.m_uTokenType;

    // General query features
    // ======================

    m_uParsedFeatureMask = Src.m_uParsedFeatureMask;

    m_uDetectedArraySize = Src.m_uDetectedArraySize;
    m_puDetectedFeatures = new ULONG[Src.m_uDetectedArraySize];
    if (!m_puDetectedFeatures)
        throw CX_MemoryException();

    memcpy(m_puDetectedFeatures, Src.m_puDetectedFeatures, sizeof(ULONG) * Src.m_uDetectedArraySize);

    // Values being selected if WMIQ_RPNF_PROJECTION is set
    // =====================================================

    m_uSelectListSize = Src.m_uSelectListSize;

    m_ppSelectList = (SWbemQueryQualifiedName **) new CWbemQueryQualifiedName *[m_uSelectListSize];
    if (!m_ppSelectList)
        throw CX_MemoryException();

    for (u = 0; u < m_uSelectListSize; u++)
    {
        CWbemQueryQualifiedName *p = new CWbemQueryQualifiedName(*(CWbemQueryQualifiedName *) Src.m_ppSelectList[u]);
        if (!p)
            throw CX_MemoryException();

        m_ppSelectList[u] = (SWbemQueryQualifiedName *) p;
    }

    // FROM

    m_uFromTargetType = Src.m_uFromTargetType;
    m_pszOptionalFromPath = CloneLPWSTR(Src.m_pszOptionalFromPath);// NULL if not used
    if (CloneFailed(m_pszOptionalFromPath,Src.m_pszOptionalFromPath))
        throw CX_MemoryException();

    if (FAILED(StrArrayCopy(Src.m_uFromListSize, (LPWSTR *) Src.m_ppszFromList, (LPWSTR **) &m_ppszFromList)))
    	throw CX_MemoryException();

    m_uFromListSize = Src.m_uFromListSize;

    // Where clause
    // ============

    m_uWhereClauseSize = Src.m_uWhereClauseSize;
    m_ppRpnWhereClause = new SWbemRpnQueryToken *[m_uWhereClauseSize];
    if (!m_ppRpnWhereClause)
        throw CX_MemoryException();

    for (u = 0; u < m_uWhereClauseSize; u++)
    {
        CWbemRpnQueryToken *pTmp = new CWbemRpnQueryToken(* (CWbemRpnQueryToken *) Src.m_ppRpnWhereClause[u]);
        if (!pTmp)
            throw CX_MemoryException();

        m_ppRpnWhereClause[u] = (SWbemRpnQueryToken *) pTmp;
    }

    // WITHIN value
    // ============

    m_dblWithinPolling  = Src.m_dblWithinPolling;
    m_dblWithinWindow = Src.m_dblWithinWindow;


    // ORDER BY
    // ========

    if (FAILED(StrArrayCopy(Src.m_uOrderByListSize, (LPWSTR *) Src.m_ppszOrderByList, (LPWSTR **) &m_ppszOrderByList)))
    	throw CX_MemoryException();
    m_uOrderByListSize = Src.m_uOrderByListSize;

    m_uOrderDirectionEl = new ULONG[m_uOrderByListSize];
    if (!m_uOrderDirectionEl)
        throw CX_MemoryException();

    memcpy(m_uOrderDirectionEl, Src.m_uOrderDirectionEl, sizeof(ULONG) * m_uOrderByListSize);

    return *this;
}


///////////////////////////////////////////////////////////////////////////////////
//
//  Recursively rearranges the tokens from AST to RPN.
//  Nondestructive to the query itself; only stores the pointers.
//
//

HRESULT CWQLParser::BuildRpnWhereClause(
    SWQLNode *pCurrent,
    CFlexArray &aRpnReorg
    )
{
    if (pCurrent == 0)
        return WBEM_S_NO_ERROR;

    BuildRpnWhereClause(pCurrent->m_pLeft, aRpnReorg);
    BuildRpnWhereClause(pCurrent->m_pRight, aRpnReorg);
    aRpnReorg.Add(pCurrent);

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************
//
int CWQLParser::update_stmt(OUT SWQLNode_Update **pUpdStmt)
{
    return WBEM_E_INVALID_SYNTAX;
}

//***************************************************************************
//
//***************************************************************************
//
int CWQLParser::insert_stmt(OUT SWQLNode_Insert **pInsStmt)
{
    return WBEM_E_INVALID_SYNTAX;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWQLParser::BuildSelectList(CWbemRpnEncodedQuery *pQuery)
{
    SWQLNode_ColumnList *pCL = (SWQLNode_ColumnList *) GetColumnList();
    if (pCL == 0)
        return WBEM_E_INVALID_QUERY;

    ULONG uSize = (ULONG) pCL->m_aColumnRefs.Size();
    pQuery->m_uSelectListSize = uSize;

    pQuery->m_ppSelectList = (SWbemQueryQualifiedName  **)
        new CWbemQueryQualifiedName *[uSize];
    if (!pQuery->m_ppSelectList)
    {
        throw CX_MemoryException();
    }

    for (ULONG u = 0; u < uSize; u++)
    {
        SWQLColRef *pCol = (SWQLColRef *) pCL->m_aColumnRefs[u];
        SWbemQueryQualifiedName *pTemp = (SWbemQueryQualifiedName *) new CWbemQueryQualifiedName;
        if (!pTemp)
            throw CX_MemoryException();

        unsigned uNameListSize = 1;
        if (pCol->m_pTableRef)
            uNameListSize = 2;
        pTemp->m_uNameListSize = uNameListSize;
        pTemp->m_ppszNameList = (LPCWSTR *) new LPWSTR[uNameListSize];

        if (!pTemp->m_ppszNameList)
        {
            delete pTemp;
            throw CX_MemoryException();
        }

        if (uNameListSize == 1)
        {
            pTemp->m_ppszNameList[0] = CloneLPWSTR(pCol->m_pColName);
            if (!pTemp->m_ppszNameList[0])
            {
                delete pTemp;
                throw CX_MemoryException();
            }
        }
        else
        {
            pTemp->m_ppszNameList[0] = CloneLPWSTR(pCol->m_pTableRef);
            if (!pTemp->m_ppszNameList[0])
            {
                delete pTemp;
                throw CX_MemoryException();
            }
            pTemp->m_ppszNameList[1] = CloneLPWSTR(pCol->m_pColName);
            if (!pTemp->m_ppszNameList[1])
            {
                delete pTemp;
                throw CX_MemoryException();
            }
        }

        pQuery->m_ppSelectList[u] = pTemp;
    }

    return 0;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWQLParser::BuildFromClause(CWbemRpnEncodedQuery *pQuery)
{
    SWQLNode_FromClause *pFrom = (SWQLNode_FromClause *) GetFromClause();

    if (pFrom == NULL)
        return WBEM_E_INVALID_QUERY;

    // Check left node for traditional SQL
    // Check right node for WMI scoped select

    if (pFrom->m_pLeft)
    {
        SWQLNode_TableRef *pTR = (SWQLNode_TableRef *) pFrom->m_pLeft;
        pQuery->m_uFromTargetType |= WMIQ_RPN_FROM_UNARY;

        pQuery->m_uFromListSize = 1;
        pQuery->m_ppszFromList = (LPCWSTR *) new LPWSTR[1];
        if (!pQuery->m_ppszFromList)
            throw CX_MemoryException();

        pQuery->m_ppszFromList[0] = CloneLPWSTR(pTR->m_pTableName);
        if (!pQuery->m_ppszFromList[0])
        {
            delete pQuery->m_ppszFromList;
            throw CX_MemoryException();
        }
    }
    else if (pFrom->m_pRight)
    {
        SWQLNode_WmiScopedSelect *pSS = (SWQLNode_WmiScopedSelect *) pFrom->m_pRight;

        pQuery->m_uFromTargetType |= WMIQ_RPN_FROM_PATH;
        pQuery->m_pszOptionalFromPath = CloneLPWSTR(pSS->m_pszScope);
        if (pQuery->m_pszOptionalFromPath)
        {
            throw CX_MemoryException();
        }

        int nSz = pSS->m_aTables.Size();
        if (nSz == 1)
            pQuery->m_uFromTargetType |= WMIQ_RPN_FROM_UNARY;
        else if (nSz > 1)
            pQuery->m_uFromTargetType |= WMIQ_RPN_FROM_CLASS_LIST;


        pQuery->m_uFromListSize = (ULONG) nSz;
        pQuery->m_ppszFromList = (LPCWSTR *) new LPWSTR[nSz];
        if (!pQuery->m_ppszFromList)
            throw CX_MemoryException();

        for (int n = 0; n < nSz; n++)
        {
            pQuery->m_ppszFromList[n] = CloneLPWSTR(LPWSTR(pSS->m_aTables[n]));
            if (!pQuery->m_ppszFromList[n])
                throw CX_MemoryException();
        }
    }
    else
        return WBEM_E_INVALID_QUERY;

    return 0;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWQLParser::GetRpnSequence(OUT SWbemRpnEncodedQuery **pRpn)
{
    HRESULT hRes;

    try
    {
        CWbemRpnEncodedQuery *pNewRpn = new CWbemRpnEncodedQuery;
        if (!pNewRpn)
            return WBEM_E_OUT_OF_MEMORY;
	wmilib::auto_ptr<CWbemRpnEncodedQuery> delNewRpn(pNewRpn);


        // Copy detected features.
        // =======================

        pNewRpn->m_uParsedFeatureMask = m_uFeatures;

        // Do the SELECT LIST.
        // ===================
        BuildSelectList(pNewRpn);

        // Do the FROM list.
        // =================
        BuildFromClause(pNewRpn);

        // Do the WHERE clause.
        // ====================

        CFlexArray aRpn;
        SWQLNode *pWhereRoot = GetWhereClauseRoot();

        SWQLNode_RelExpr *pExprRoot = (SWQLNode_RelExpr *) pWhereRoot->m_pLeft;
        SWQLNode_WhereOptions *pOp = (SWQLNode_WhereOptions *) pWhereRoot->m_pRight;      // ORDER BY, etc.

        if (pExprRoot)
            hRes = BuildRpnWhereClause(pExprRoot, aRpn);

        // Now traverse the RPN form of the WHERE clause, if any.
        // ======================================================
        if (aRpn.Size())
        {
            pNewRpn->m_uWhereClauseSize = aRpn.Size();
            pNewRpn->m_ppRpnWhereClause = (SWbemRpnQueryToken **) new CWbemRpnQueryToken*[aRpn.Size()];
            if (!pNewRpn->m_ppRpnWhereClause)
                return WBEM_E_OUT_OF_MEMORY;
        }

        BOOL b_Test_AllEqualityTests = TRUE;
        BOOL b_Test_Disjunctive = FALSE;
        BOOL b_AtLeastOneTest = FALSE;

        for (int i = 0; i < aRpn.Size(); i++)
        {
            SWQLNode_RelExpr *pSrc = (SWQLNode_RelExpr *) aRpn[i];
            SWbemRpnQueryToken *pDest = (SWbemRpnQueryToken *) new CWbemRpnQueryToken;
            if (!pDest)
                return WBEM_E_OUT_OF_MEMORY;

            wmilib::auto_ptr<SWbemRpnQueryToken> delDest(pDest);
            hRes = BuildCurrentWhereToken(pSrc, pDest);
            delDest.release();
            
            pNewRpn->m_ppRpnWhereClause[i] = pDest;


            // Add in stats.
            // =============
            if (pDest->m_uTokenType == WMIQ_RPN_TOKEN_EXPRESSION)
            {
                if (pDest->m_uOperator != WMIQ_RPN_OP_EQ)
                    b_Test_AllEqualityTests = FALSE;
                b_AtLeastOneTest = TRUE;
            }
            else if (pDest->m_uTokenType != WMIQ_RPN_TOKEN_AND)
            {
                b_Test_Disjunctive = TRUE;
            }

            if (pDest->m_pRightIdent != 0 && pDest->m_pLeftIdent != 0)
            {
                pNewRpn->m_uParsedFeatureMask |= WMIQ_RPNF_PROP_TO_PROP_TESTS;
            }
        }

        if (b_Test_AllEqualityTests && b_AtLeastOneTest)
            pNewRpn->m_uParsedFeatureMask |= WMIQ_RPNF_EQUALITY_TESTS_ONLY;

        if (b_Test_Disjunctive)
            pNewRpn->m_uParsedFeatureMask |= WMIQ_RPNF_QUERY_IS_DISJUNCTIVE;
        else
            pNewRpn->m_uParsedFeatureMask |= WMIQ_RPNF_QUERY_IS_CONJUNCTIVE;

        *pRpn = pNewRpn;
	delNewRpn.release();
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;

    }
    catch (...)
    {
        return  WBEM_E_CRITICAL_ERROR;
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//

ULONG RpnTranslateExprFlags(SWQLTypedExpr *pTE)
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

ULONG RpnTranslateOperator(SWQLTypedExpr *pTE)
{
    ULONG uRes = WMIQ_RPN_OP_UNDEFINED;

    switch (pTE->m_dwRelOperator)
    {
        case WQL_TOK_LE:   uRes = WMIQ_RPN_OP_LE; break;
        case WQL_TOK_LT:   uRes = WMIQ_RPN_OP_LT; break;
        case WQL_TOK_GE:   uRes = WMIQ_RPN_OP_GE; break;
        case WQL_TOK_GT:   uRes = WMIQ_RPN_OP_GT; break;
        case WQL_TOK_EQ:   uRes = WMIQ_RPN_OP_EQ; break;
        case WQL_TOK_NE:   uRes = WMIQ_RPN_OP_NE; break;
        case WQL_TOK_LIKE: uRes = WMIQ_RPN_OP_LIKE; break;
        case WQL_TOK_ISA:  uRes = WMIQ_RPN_OP_ISA; break;
        case WQL_TOK_ISNULL:   uRes = WMIQ_RPN_OP_ISNULL; break;
        case WQL_TOK_NOT_NULL:   uRes = WMIQ_RPN_OP_ISNOTNULL; break;
    }

    return uRes;
}

//***************************************************************************
//
//***************************************************************************
//
SWbemQueryQualifiedName *RpnTranslateIdent(ULONG uWhichSide, SWQLTypedExpr *pTE)
{
    SWQLQualifiedName *pQN = 0;

    if (uWhichSide == WMIQ_RPN_LEFT_PROPERTY_NAME)
    {
         pQN = pTE->m_pQNLeft;
    }
    else
    {
         pQN = pTE->m_pQNRight;
    }

    if (pQN)
    {
        CWbemQueryQualifiedName *pNew = new CWbemQueryQualifiedName;
        if (!pNew)
            throw CX_MemoryException();

        pNew->m_uNameListSize = (ULONG) pQN->m_aFields.Size();
        pNew->m_ppszNameList = (LPCWSTR *) new LPWSTR *[pNew->m_uNameListSize];
        if (!pNew->m_ppszNameList)
        {
            delete pNew;
            throw CX_MemoryException();
        }

        for (int i = 0; i < pQN->m_aFields.Size(); i++)
        {
            SWQLQualifiedNameField *pField = (SWQLQualifiedNameField *) pQN->m_aFields[i];
            LPWSTR pszNewName = CloneLPWSTR(pField->m_pName);
            if (!pszNewName)
            {
                delete pNew;
                throw CX_MemoryException();
            }
            pNew->m_ppszNameList[i] = pszNewName;
        }
        return (SWbemQueryQualifiedName *) pNew;
    }

    else if (pTE->m_pColRef && WMIQ_RPN_LEFT_PROPERTY_NAME == uWhichSide)
    {
        CWbemQueryQualifiedName *pNew = new CWbemQueryQualifiedName;
        if (!pNew)
            throw CX_MemoryException();

        if (pTE->m_pTableRef)
        {
            pNew->m_uNameListSize = 2;
            pNew->m_ppszNameList = (LPCWSTR *) new LPWSTR *[2];
            if (!pNew->m_ppszNameList)
            {
                delete pNew;
                throw CX_MemoryException();
            }

            pNew->m_ppszNameList[0] = CloneLPWSTR(pTE->m_pTableRef);
            if (!pNew->m_ppszNameList[0])
            {
                delete pNew;
                throw CX_MemoryException();
            }
            pNew->m_ppszNameList[1] = CloneLPWSTR(pTE->m_pColRef);
            if (!pNew->m_ppszNameList[1])
            {
                delete pNew;
                throw CX_MemoryException();
            }
        }
        else
        {
            pNew->m_uNameListSize = 1;
            pNew->m_ppszNameList = (LPCWSTR *) new LPWSTR *[1];
            if (!pNew->m_ppszNameList)
            {
                delete pNew;
                throw CX_MemoryException();
            }

            pNew->m_ppszNameList[0] = CloneLPWSTR(pTE->m_pColRef);
            if (!pNew->m_ppszNameList[0])
            {
                delete pNew;
                throw CX_MemoryException();
            }
        }
        return (SWbemQueryQualifiedName *) pNew;
    }

    else if (pTE->m_pJoinColRef && WMIQ_RPN_RIGHT_PROPERTY_NAME == uWhichSide)
    {
        CWbemQueryQualifiedName *pNew = new CWbemQueryQualifiedName;
        if (!pNew)
            throw CX_MemoryException();

        if (pTE->m_pJoinTableRef)
        {
            pNew->m_uNameListSize = 2;
            pNew->m_ppszNameList = (LPCWSTR *) new LPWSTR *[2];
            if (!pNew->m_ppszNameList)
            {
                delete pNew;
                throw CX_MemoryException();
            }

            pNew->m_ppszNameList[0] = CloneLPWSTR(pTE->m_pJoinTableRef);
            if (!pNew->m_ppszNameList[0])
            {
                delete pNew;
                throw CX_MemoryException();
            }
            pNew->m_ppszNameList[1] = CloneLPWSTR(pTE->m_pJoinColRef);
            if (!pNew->m_ppszNameList[1])
            {
                delete pNew;
                throw CX_MemoryException();
            }
        }
        else
        {
            pNew->m_uNameListSize = 1;
            pNew->m_ppszNameList = (LPCWSTR *) new LPWSTR *[1];
            if (!pNew->m_ppszNameList)
            {
                delete pNew;
                throw CX_MemoryException();
            }

            pNew->m_ppszNameList[0] = CloneLPWSTR(pTE->m_pJoinColRef);
            if (!pNew->m_ppszNameList[0])
            {
                delete pNew;
                throw CX_MemoryException();
            }
        }
        return (SWbemQueryQualifiedName *) pNew;
    }
    else
        return 0;
}

//***************************************************************************
//
//***************************************************************************
//

SWbemQueryQualifiedName *RpnTranslateRightIdent(SWQLTypedExpr *pTE)
{
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//

SWbemRpnConst RpnTranslateConst(SWQLTypedConst *pSrc)
{
    SWbemRpnConst c;
    memset(&c, 0, sizeof(c));

    if (!pSrc)
        return c;

    switch (pSrc->m_dwType)
    {
        case VT_LPWSTR:
            c.m_pszStrVal = CloneLPWSTR(pSrc->m_Value.m_pString);
            // this will fail with an "empty" struct returned
            break;

        case VT_I4:
            c.m_lLongVal = pSrc->m_Value.m_lValue;
            break;

        case VT_R8:
            c.m_dblVal = pSrc->m_Value.m_dblValue;
            break;

        case VT_BOOL:
            c.m_bBoolVal = pSrc->m_Value.m_bValue;
            break;

        case VT_UI4:
            c.m_uLongVal = (unsigned) pSrc->m_Value.m_lValue;
            break;

        case VT_I8:
            c.m_lVal64 =  pSrc->m_Value.m_i64Value;
            break;

        case VT_UI8:
            c.m_uVal64 = (unsigned __int64) pSrc->m_Value.m_i64Value;
            break;

    }
    return c;
}

//***************************************************************************
//
//***************************************************************************
//

ULONG RpnTranslateConstType(SWQLTypedConst *pSrc)
{
    if (pSrc)
        return pSrc->m_dwType;
    else
        return VT_NULL;
}

//***************************************************************************
//
//***************************************************************************
//

LPCWSTR RpnTranslateLeftFunc(SWQLTypedExpr *pTE)
{
	return Clone(pTE->m_pIntrinsicFuncOnColRef);
}

//***************************************************************************
//
//***************************************************************************
//

LPCWSTR RpnTranslateRightFunc(SWQLTypedExpr *pTE)
{
	if (pTE->m_pIntrinsicFuncOnJoinColRef == 0)
		return Clone(pTE->m_pIntrinsicFuncOnConstValue);
	else
		return Clone(pTE->m_pIntrinsicFuncOnJoinColRef);
}


//***************************************************************************
//
//***************************************************************************
//

HRESULT CWQLParser::BuildCurrentWhereToken(
        SWQLNode_RelExpr *pSrc,
        SWbemRpnQueryToken *pDest
        )
{
    HRESULT hRes = WBEM_E_INVALID_QUERY;

    if (pSrc->m_dwExprType == WQL_TOK_OR)
    {
        pDest->m_uTokenType = WMIQ_RPN_TOKEN_OR;
    }
    else if (pSrc->m_dwExprType == WQL_TOK_AND)
    {
        pDest->m_uTokenType = WMIQ_RPN_TOKEN_AND;
    }
    else if (pSrc->m_dwExprType == WQL_TOK_NOT)
    {
        pDest->m_uTokenType = WMIQ_RPN_TOKEN_NOT;
    }
    else if (pSrc->m_dwExprType == WQL_TOK_TYPED_EXPR)
    {
        pDest->m_uTokenType = WMIQ_RPN_TOKEN_EXPRESSION;

        SWQLTypedExpr *pTmp = pSrc->m_pTypedExpr;

        pDest->m_uSubexpressionShape = RpnTranslateExprFlags(pTmp);
        pDest->m_uOperator = RpnTranslateOperator(pTmp);

	        pDest->m_pLeftIdent = RpnTranslateIdent(WMIQ_RPN_LEFT_PROPERTY_NAME, pTmp);
        pDest->m_pRightIdent = RpnTranslateIdent(WMIQ_RPN_RIGHT_PROPERTY_NAME, pTmp);

        pDest->m_uConstApparentType = RpnTranslateConstType(pTmp->m_pConstValue);
        pDest->m_Const = RpnTranslateConst(pTmp->m_pConstValue);

        pDest->m_uConst2ApparentType = RpnTranslateConstType(pTmp->m_pConstValue2);
        pDest->m_Const2 = RpnTranslateConst(pTmp->m_pConstValue2);

        pDest->m_pszLeftFunc = RpnTranslateLeftFunc(pTmp);
        pDest->m_pszRightFunc = RpnTranslateRightFunc(pTmp);

        if (pDest->m_pLeftIdent)
            pDest->m_uSubexpressionShape |= WMIQ_RPN_LEFT_PROPERTY_NAME;
        if (pDest->m_pRightIdent)
            pDest->m_uSubexpressionShape |= WMIQ_RPN_RIGHT_PROPERTY_NAME;
		
		// Special case NULL if there really is a const value with a type of NULL
        if ( (pDest->m_uConstApparentType != VT_NULL) || 
			( NULL != pTmp->m_pConstValue && pTmp->m_pConstValue->m_dwType == VT_NULL ) )
            pDest->m_uSubexpressionShape |= WMIQ_RPN_CONST;

		// Do the same for CONST2
        if ( (pDest->m_uConst2ApparentType != VT_NULL) ||
			( NULL != pTmp->m_pConstValue2 && pTmp->m_pConstValue2->m_dwType == VT_NULL ) )
            pDest->m_uSubexpressionShape |= WMIQ_RPN_CONST2;

        if (pDest->m_pszLeftFunc)
            pDest->m_uSubexpressionShape |= WMIQ_RPN_LEFT_FUNCTION;
        if (pDest->m_pszRightFunc)
            pDest->m_uSubexpressionShape |= WMIQ_RPN_RIGHT_FUNCTION;
        if (pDest->m_uOperator != 0)
            pDest->m_uSubexpressionShape |= WMIQ_RPN_RELOP;
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
int CWQLParser::assocquery(OUT SWQLNode_AssocQuery **pAssocQuery)
{
    HRESULT hRes;
    CAssocQueryParser AP;
    *pAssocQuery = 0;

    hRes = AP.Parse(m_pszQueryText);

    if (FAILED(hRes))  return hRes;

    // If here, extract the info and put it into a new node.
    // =====================================================

    wmilib::auto_ptr<SWQLNode_AssocQuery> pTmp(new SWQLNode_AssocQuery);
    if (0 == pTmp.get()) return WBEM_E_OUT_OF_MEMORY;

    pTmp->m_pAQInf = new CWbemAssocQueryInf;
    if (NULL == pTmp->m_pAQInf) return WBEM_E_OUT_OF_MEMORY;

    hRes = pTmp->m_pAQInf->CopyFrom((SWbemAssocQueryInf *) &AP);
    if (FAILED(hRes)) return hRes;
    
    *pAssocQuery = pTmp.release();

    return S_OK;
}

//***************************************************************************
//
//***************************************************************************
//
void SWQLNode_QueryRoot::DebugDump()
{
    if (m_pLeft)
        m_pLeft->DebugDump();
}

//***************************************************************************
//
//***************************************************************************
//
void SWQLNode_AssocQuery::DebugDump()
{
    printf("Association query info\n");

    printf("Version         = %u\n",  m_pAQInf->m_uVersion);
    printf("Analysis Type   = %u\n",  m_pAQInf->m_uAnalysisType);
    printf("Feature Mask    = 0x%X\n", m_pAQInf->m_uFeatureMask);

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_ASSOCIATORS)
        printf("    WMIQ_ASSOCQ_ASSOCIATORS\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_REFERENCES)
        printf("    WMIQ_ASSOCQ_REFERENCES\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_RESULTCLASS)
        printf("    WMIQ_ASSOCQ_RESULTCLASS\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_ASSOCCLASS)
        printf("    WMIQ_ASSOCQ_ASSOCCLASS\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_ROLE)
        printf("    WMIQ_ASSOCQ_ROLE\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_RESULTROLE)
        printf("    WMIQ_ASSOCQ_RESULTROLE\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_REQUIREDQUALIFIER)
        printf("    WMIQ_ASSOCQ_REQUIREDQUALIFIER\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER)
        printf("    WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_CLASSDEFSONLY)
        printf("    WMIQ_ASSOCQ_CLASSDEFSONLY\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_KEYSONLY)
        printf("    WMIQ_ASSOCQ_KEYSONLY\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_SCHEMAONLY)
        printf("    WMIQ_ASSOCQ_SCHEMAONLY\n");

    if (m_pAQInf->m_uFeatureMask & WMIQ_ASSOCQ_CLASSREFSONLY)
        printf("    WMIQ_ASSOCQ_CLASSREFSONLY\n");


    printf("IWbemPath pointer = 0x%I64X\n", (unsigned __int64) m_pAQInf->m_pPath);
    if (m_pAQInf->m_pPath)
    {
        printf("Path object has ");
        wchar_t Buf[256];
        ULONG uLen = 256;
        m_pAQInf->m_pPath->GetText(0, &uLen, Buf);
        printf("<%S>\n", Buf);
    }

    printf("m_pszQueryText              = %S\n", m_pAQInf->m_pszQueryText);
    printf("m_pszResultClass            = %S\n", m_pAQInf->m_pszResultClass);
    printf("m_pszAssocClass             = %S\n", m_pAQInf->m_pszAssocClass);
    printf("m_pszRole                   = %S\n", m_pAQInf->m_pszRole);
    printf("m_pszResultRole             = %S\n", m_pAQInf->m_pszResultRole);
    printf("m_pszRequiredQualifier      = %S\n", m_pAQInf->m_pszRequiredQualifier);
    printf("m_pszRequiredAssocQualifier = %S\n", m_pAQInf->m_pszRequiredAssocQualifier);

    printf("---end---\n");
}

//***************************************************************************
//
//***************************************************************************
//
CWbemAssocQueryInf::CWbemAssocQueryInf()
{
    Init();
}


//***************************************************************************
//
//***************************************************************************
//
CWbemAssocQueryInf::~CWbemAssocQueryInf()
{
    Empty();
}

//***************************************************************************
//
//***************************************************************************
//
void CWbemAssocQueryInf::Empty()
{
    if (m_pPath)
        m_pPath->Release();
    delete [] m_pszPath;
    delete [] m_pszQueryText;
    delete [] m_pszResultClass;
    delete [] m_pszAssocClass;
    delete [] m_pszRole;
    delete [] m_pszResultRole;
    delete [] m_pszRequiredQualifier;
    delete [] m_pszRequiredAssocQualifier;
    Init();
}

//***************************************************************************
//
//***************************************************************************
//
void CWbemAssocQueryInf::Init()
{
    m_uVersion = 0;
    m_uAnalysisType = 0;
    m_uFeatureMask = 0;
    m_pPath = 0;
    m_pszPath = 0;
    m_pszQueryText = 0;
    m_pszResultClass = 0;
    m_pszAssocClass = 0;
    m_pszRole = 0;
    m_pszResultRole = 0;
    m_pszRequiredQualifier = 0;
    m_pszRequiredAssocQualifier = 0;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemAssocQueryInf::CopyFrom(SWbemAssocQueryInf *pSrc)
{
    m_uVersion = pSrc->m_uVersion;
    m_uAnalysisType = pSrc->m_uAnalysisType;
    m_uFeatureMask = pSrc->m_uFeatureMask;
    m_pszPath = CloneLPWSTR(pSrc->m_pszPath);
    if (CloneFailed(m_pszPath,pSrc->m_pszPath))
        return WBEM_E_OUT_OF_MEMORY;

    if (m_pszPath)
    {
        HRESULT hRes= CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER, IID_IWbemPath, (LPVOID *) &m_pPath);
        if (SUCCEEDED(hRes))
        {
            hRes = m_pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, m_pszPath);
            if (FAILED(hRes))
            {
                m_pPath->Release();
                m_pPath = 0;
                return hRes;
            }
        }
        else
            return hRes;
    }

    m_pszQueryText = CloneLPWSTR(pSrc->m_pszQueryText);
    if (CloneFailed(m_pszQueryText,pSrc->m_pszQueryText))
        return WBEM_E_OUT_OF_MEMORY;
    m_pszResultClass = CloneLPWSTR(pSrc->m_pszResultClass);
    if (CloneFailed(m_pszResultClass,pSrc->m_pszResultClass))
        return WBEM_E_OUT_OF_MEMORY;
    m_pszAssocClass = CloneLPWSTR(pSrc->m_pszAssocClass);
    if (CloneFailed(m_pszAssocClass,pSrc->m_pszAssocClass))
        return WBEM_E_OUT_OF_MEMORY;
    m_pszRole = CloneLPWSTR(pSrc->m_pszRole);
    if (CloneFailed(m_pszRole,pSrc->m_pszRole))
        return WBEM_E_OUT_OF_MEMORY;
    m_pszResultRole = CloneLPWSTR(pSrc->m_pszResultRole);
    if (CloneFailed(m_pszResultRole,pSrc->m_pszResultRole))
        return WBEM_E_OUT_OF_MEMORY;
    m_pszRequiredQualifier = CloneLPWSTR(pSrc->m_pszRequiredQualifier);
    if (CloneFailed(m_pszRequiredQualifier,pSrc->m_pszRequiredQualifier))
        return WBEM_E_OUT_OF_MEMORY;
    m_pszRequiredAssocQualifier = CloneLPWSTR(pSrc->m_pszRequiredAssocQualifier);
    if (CloneFailed(m_pszRequiredAssocQualifier,pSrc->m_pszRequiredAssocQualifier))
        return WBEM_E_OUT_OF_MEMORY;

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\wql.h ===
//***************************************************************************
//
//  WQL.H
//
//  WQL 1.1 Parser
//
//  Implements the syntax described in WQL.BNF.
//
//  raymcc  19-Sep-97
//
//***************************************************************************


#ifndef _WQL__H_
#define _WQL__H_

#include <wmiutils.h>
#include <wbemint.h>



class CWbemQueryQualifiedName : public SWbemQueryQualifiedName
{
public:
    void Init();
    void DeleteAll();
    CWbemQueryQualifiedName();
   ~CWbemQueryQualifiedName();
    CWbemQueryQualifiedName(CWbemQueryQualifiedName &Src);
    CWbemQueryQualifiedName& operator =(CWbemQueryQualifiedName &Src);
};

class CWbemRpnQueryToken : public SWbemRpnQueryToken
{
public:
    void Init();
    void DeleteAll();
    CWbemRpnQueryToken();
   ~CWbemRpnQueryToken();
    CWbemRpnQueryToken(CWbemRpnQueryToken &);
    CWbemRpnQueryToken& operator =(CWbemRpnQueryToken&);
};


class CWbemRpnEncodedQuery : public SWbemRpnEncodedQuery
{
public:
    void Init();
    void DeleteAll();
    CWbemRpnEncodedQuery();
   ~CWbemRpnEncodedQuery();
    CWbemRpnEncodedQuery(CWbemRpnEncodedQuery &Src);
    CWbemRpnEncodedQuery& operator=(CWbemRpnEncodedQuery &Src);
};


class CWQLParser
{
    // Data.
    // =====

    CGenLexer    *m_pLexer;
    LPWSTR        m_pszQueryText;
    int           m_nLine;
    wchar_t      *m_pTokenText;
    int           m_nCurrentToken;
    unsigned __int64 m_uFeatures;
    CWStringArray m_aReferencedTables;
    CWStringArray m_aReferencedAliases;
    CFlexArray    m_aSelAliases;
    CFlexArray    m_aSelColumns;

    SWQLNode_QueryRoot      *m_pQueryRoot;
    SWQLNode_WhereClause    *m_pRootWhere;
    SWQLNode_ColumnList     *m_pRootColList;
    SWQLNode_FromClause     *m_pRootFrom;
    SWQLNode_WhereOptions   *m_pRootWhereOptions;

    CWbemRpnEncodedQuery    *m_pRpn;

    // Parse context. In some cases, there is a general
    // shift in state for the whole parser.  Rather than
    // pass this as an inherited attribute to each production,
    // it is much easier to have a general purpose state variable.
    // ============================================================

    enum { Ctx_Default = 0, Ctx_Subselect = 0x1 };

    int         m_nParseContext;

    bool m_bAllowPromptForConstant;

    // Functions.
    // ==========

    BOOL Next();
    BOOL GetIntToken(BOOL *bSigned, BOOL *b64Bit, unsigned __int64 *pVal);

    int QNameToSWQLColRef(
        IN  SWQLQualifiedName *pQName,
        OUT SWQLColRef **pRetVal
        );

    enum { eCtxLeftSide = 1, eCtxRightSide = 2 };

    // Non-terminal productions.
    // =========================
    int select_stmt(OUT SWQLNode_Select **pSelStmt);
    int delete_stmt(OUT SWQLNode_Delete **pDelStmt);
    int update_stmt(OUT SWQLNode_Update **pUpdStmt);
    int insert_stmt(OUT SWQLNode_Insert **pInsStmt);
    int assocquery(OUT SWQLNode_AssocQuery **pAssocQuery);

    int select_type(int & nSelType);
    int col_ref_list(IN OUT SWQLNode_TableRefs *pTblRefs);

    int from_clause(OUT SWQLNode_FromClause **pFrom);
    int where_clause(OUT SWQLNode_WhereClause **pRetWhere);
    int col_ref(OUT SWQLQualifiedName **pRetVal);
    int col_ref_rest(IN OUT SWQLNode_TableRefs *pTblRefs);

    int count_clause(
        OUT SWQLQualifiedName **pQualName
        );

    int wmi_scoped_select(SWQLNode_FromClause *pFC);

    int single_table_decl(OUT SWQLNode_TableRef **pTblRef);
    int sql89_join_entry(
        IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Sql89Join **pJoin  );
    int sql92_join_entry(
        IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Join **pJoin
        );

    int sql89_join_list(
        IN  SWQLNode_TableRef *pInitialTblRef,
        OUT SWQLNode_Sql89Join **pJoin  );
    int on_clause(OUT SWQLNode_OnClause **pOC);
    int rel_expr(OUT SWQLNode_RelExpr **pRelExpr);
    int where_options(OUT SWQLNode_WhereOptions **pWhereOpt0);
    int group_by_clause(OUT SWQLNode_GroupBy **pRetGroupBy);
    int having_clause(OUT SWQLNode_Having **pRetHaving);
    int order_by_clause(OUT SWQLNode_OrderBy **pRetOrderBy);
    int rel_term(OUT SWQLNode_RelExpr **pNewTerm);
    int rel_expr2(
        IN OUT SWQLNode_RelExpr *pLeftSide,
        OUT SWQLNode_RelExpr **pNewRootRE
        );
    int rel_simple_expr(OUT SWQLNode_RelExpr **pRelExpr);
    int rel_term2(
        IN SWQLNode_RelExpr *pLeftSide,
        OUT SWQLNode_RelExpr **pNewRootRE
        );

    int typed_expr(OUT SWQLNode_RelExpr **pRelExpr);
    int typed_subexpr_rh(SWQLTypedExpr *pTE);
    int typed_subexpr(IN SWQLTypedExpr *pTE);
    int typed_const(OUT SWQLTypedConst **pRetVal);

    int datepart_call(
        OUT SWQLNode_Datepart **pRetDP
        );


    int function_call(IN BOOL bLeftSide, IN SWQLTypedExpr *pTE);
    int function_call_parms();
    int func_args();
    int func_arg();

    int rel_op(int &);
    int is_continuator(int &);
    int not_continuator(int &);

    int in_clause(IN SWQLTypedExpr *pTE);
    int subselect_stmt(OUT SWQLNode_Select **pSel);
    int qualified_name(OUT SWQLQualifiedName **pHead);
    int const_list(OUT SWQLConstList **pRetVal);
    int col_list(OUT SWQLNode_ColumnList **pRetColList);

    void Empty();

public:
    enum
    {
        Feature_Refs    = 0x2,             // A WQL 'references of' query
        Feature_Assocs  = 0x4,             // A WQL 'associators of' query
        Feature_Events  = 0x8,             // A WQL event-related query

        Feature_Joins        = 0x10,       // One or more joins occurred

        Feature_Having       = 0x20,       // HAVING used
        Feature_GroupBy      = 0x40,       // GROUP BY used
        Feature_OrderBy      = 0x80,       // ORDER BY used
        Feature_Count        = 0x100,      // COUNT used

        Feature_SelectAll     = 0x400,     // select * from
        Feature_SimpleProject = 0x800,        // no 'where' clause, no join
        Feature_ComplexNames  = 0x1000,       // Names with long qualifications occurred, such
                                              // as array properties and embedded objects.
        Feature_WQL_Extensions = 0x80000000   // WQL-specific extensions

    }   QueryFeatures;

    DWORD GetFeatureFlags();

    BOOL GetReferencedTables(OUT CWStringArray & Tables);
    BOOL GetReferencedAliases(OUT CWStringArray & Aliases);

    const LPWSTR AliasToTable(IN LPWSTR pAlias);

    const CFlexArray *GetSelectedAliases() { return &m_aSelAliases; }
        // Array of ptrs to SWQLNode_TableRef structs; read-only

    const CFlexArray *GetSelectedColumns() { return &m_pRootColList->m_aColumnRefs; }
        // Array of ptrs to SWQLColRef structs; read-only

    // Manual traversal.
    // =================

    SWQLNode_QueryRoot *GetParseRoot() { return m_pQueryRoot; }
    SWQLNode *GetWhereClauseRoot() { return m_pRootWhere; }
    SWQLNode *GetColumnList() { return m_pRootColList; }
    SWQLNode *GetFromClause() { return m_pRootFrom; }
    SWQLNode *GetWhereOptions() { return m_pRootWhereOptions; }

    LPCWSTR GetQueryText() { return m_pszQueryText; }

    // Working
    // =======

    CWQLParser(LPWSTR pszQueryText, CGenLexSource *pSrc);
   ~CWQLParser();

    HRESULT Parse();

    void AllowPromptForConstant(bool bIsAllowed = TRUE) {m_bAllowPromptForConstant = bIsAllowed;}

    // Rpn Helpers.
    // ============

    HRESULT GetRpnSequence(
        OUT SWbemRpnEncodedQuery **pRpn
        );

    HRESULT BuildRpnWhereClause(
        SWQLNode *pRootOfWhere,
        CFlexArray &aRpnReorg
        );

    HRESULT BuildCurrentWhereToken(
        SWQLNode_RelExpr *pSrc,
        SWbemRpnQueryToken *pDest
        );

    HRESULT BuildSelectList(
        CWbemRpnEncodedQuery *pQuery
        );

    HRESULT BuildFromClause(
        CWbemRpnEncodedQuery *pQuery
        );
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\wqllex.cpp ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    WQLLEX.CPP

Abstract:

    WQL DFA Table

History:

    raymcc    14-Sep-97       Created.
    raymcc    06-Oct-97       Single quote support

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <wqllex.h>

#define ST_STRING        29
#define ST_IDENT         34
#define ST_GE            40
#define ST_LE            42
#define ST_NE            45
#define ST_NUMERIC       47
#define ST_REAL          54
#define ST_STRING2       60
#define ST_STRING_ESC    65
#define ST_STRING2_ESC   66
#define ST_SSTRING       67
#define ST_DOT           71
#define ST_BRACKETED_STR 74
#define ST_NEGATIVE_NUM  76
#define ST_POSITIVE_NUM  79
#define ST_HEX_CONST     82

// DFA State Table for QL Level 1 lexical symbols.
// ================================================

LexEl WQL_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,                     GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,                     GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,                     GLEX_ACCEPT,
/* 3 */  0x80,   0xfffd,     ST_IDENT,   0,                     GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,          WQL_TOK_OPEN_PAREN,    GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,          WQL_TOK_CLOSE_PAREN,   GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, ST_DOT,     0,                     GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,          WQL_TOK_ASTERISK,      GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,          WQL_TOK_EQ,            GLEX_ACCEPT,
/* 9 */  L'[',   GLEX_EMPTY, ST_BRACKETED_STR, 0,               GLEX_CONSUME,
/* 10 */  L']',  GLEX_EMPTY, 0,          WQL_TOK_CLOSE_BRACKET, GLEX_ACCEPT,
/* 11 */ L'{',   GLEX_EMPTY, 0,          WQL_TOK_OPEN_BRACE,    GLEX_ACCEPT,
/* 12 */ L'}',   GLEX_EMPTY, 0,          WQL_TOK_CLOSE_BRACE,   GLEX_ACCEPT,


/* 13 */  L'>',  GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 14 */  L'<',  GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 15 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 16 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 17 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 18 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 19 */ L'-',   GLEX_EMPTY, ST_NEGATIVE_NUM, 0,          GLEX_ACCEPT,
/* 20 */ L'\'',  GLEX_EMPTY, ST_SSTRING, 0,               GLEX_CONSUME,

    // Whitespace, newlines, etc.
/* 21 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 22 */ L'\t',  GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 23 */ L'\n',  GLEX_EMPTY, 0,          0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 24 */ L'\r',  GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 25 */ 0,      GLEX_EMPTY, 0,          WQL_TOK_EOF,     GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 26 */ L',',   GLEX_EMPTY, 0,          WQL_TOK_COMMA,   GLEX_ACCEPT,
/* 27 */ L'+',   GLEX_EMPTY, ST_POSITIVE_NUM, 0,          GLEX_CONSUME,

    // Unknown characters

/* 28 */ GLEX_ANY, GLEX_EMPTY, 0,        WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 29 */   L'\n',    GLEX_EMPTY, 0,              WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 30 */   L'\r',    GLEX_EMPTY, 0,              WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 31 */   L'"',     GLEX_EMPTY, 0,              WQL_TOK_QSTRING,  GLEX_CONSUME,
/* 32 */   L'\\',    GLEX_EMPTY, ST_STRING_ESC,  0,                GLEX_CONSUME,
/* 33 */   GLEX_ANY, GLEX_EMPTY, ST_STRING,      0,                GLEX_ACCEPT,

// ST_IDENT

/* 34 */  L'a',   L'z',          ST_IDENT,   0,              GLEX_ACCEPT,
/* 35 */  L'A',   L'Z',          ST_IDENT,   0,              GLEX_ACCEPT,
/* 36 */  L'_',   GLEX_EMPTY,    ST_IDENT,   0,              GLEX_ACCEPT,
/* 37 */  L'0',   L'9',          ST_IDENT,   0,              GLEX_ACCEPT,
/* 38 */  0x80,  0xfffd,         ST_IDENT,   0,              GLEX_ACCEPT,
/* 39 */  GLEX_ANY, GLEX_EMPTY,  0,          WQL_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 40 */  L'=',   GLEX_EMPTY,    0,  WQL_TOK_GE,  GLEX_ACCEPT,
/* 41 */  GLEX_ANY, GLEX_EMPTY,  0,  WQL_TOK_GT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 42 */  L'=',     GLEX_EMPTY,      0,  WQL_TOK_LE,  GLEX_ACCEPT,
/* 43 */  L'>',     GLEX_EMPTY,      0,  WQL_TOK_NE,  GLEX_ACCEPT,
/* 44 */  GLEX_ANY, GLEX_EMPTY,      0,  WQL_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 45 */  L'=',      GLEX_EMPTY,      0,  WQL_TOK_NE,     GLEX_ACCEPT,
/* 46 */  GLEX_ANY,  GLEX_EMPTY,      0,  WQL_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 47 */  L'0',     L'9',         ST_NUMERIC, 0,            GLEX_ACCEPT,
/* 48 */  L'.',     GLEX_EMPTY,   ST_REAL,    0,            GLEX_ACCEPT,
/* 49 */  L'E',     GLEX_EMPTY,   ST_REAL,    0,            GLEX_ACCEPT,
/* 50 */  L'e',     GLEX_EMPTY,   ST_REAL,    0,            GLEX_ACCEPT,
/* 51 */  L'x',     GLEX_EMPTY,   ST_HEX_CONST,  0,            GLEX_ACCEPT,
/* 52 */  L'X',     GLEX_EMPTY,   ST_HEX_CONST,  0,            GLEX_ACCEPT,
/* 53 */  GLEX_ANY, GLEX_EMPTY,   0,          WQL_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 54 */  L'0',     L'9',         ST_REAL, 0,            GLEX_ACCEPT,
/* 55 */  L'E',     GLEX_EMPTY,   ST_REAL, 0,            GLEX_ACCEPT,
/* 56 */  L'e',     GLEX_EMPTY,   ST_REAL, 0,            GLEX_ACCEPT,
/* 57 */  L'+',     GLEX_EMPTY,   ST_REAL, 0,            GLEX_ACCEPT,
/* 58 */  L'-',     GLEX_EMPTY,   ST_REAL, 0,            GLEX_ACCEPT,
/* 59 */  GLEX_ANY, GLEX_EMPTY,   0,       WQL_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 60 */   L'\n',  GLEX_EMPTY, 0,  WQL_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 61 */   L'\r',  GLEX_EMPTY, 0,  WQL_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 62 */   L'\'',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,   GLEX_CONSUME,
/* 63 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,    GLEX_CONSUME,
/* 64 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2,    0,    GLEX_ACCEPT,

// ST_STRING_ESC
/* 65 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

// ST_STRING2_ESC
/* 66 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,

// ST_SSTRING (Single quoted strings)
/* 67 */   L'\n', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 68 */   L'\r', GLEX_EMPTY, 0,  WQL_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 69 */   L'\'',  GLEX_EMPTY, 0,  WQL_TOK_QSTRING,  GLEX_CONSUME,
/* 70 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 71 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,

// ST_DOT
/* 72 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 73 */  GLEX_ANY,       GLEX_EMPTY,   0,     WQL_TOK_DOT, GLEX_PUSHBACK|GLEX_RETURN,

// ST_BRACKETED_STRING
/* 74 */   L']',  GLEX_EMPTY, 0,  WQL_TOK_BRACKETED_STRING,  GLEX_CONSUME,
/* 75 */   GLEX_ANY, GLEX_EMPTY, ST_BRACKETED_STR, 0,        GLEX_ACCEPT,

// ST_NEGATIVE_NUM - Strips whitespace after '-'
/* 76 */ L' ', GLEX_EMPTY, ST_NEGATIVE_NUM, 0, GLEX_CONSUME,
/* 77 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 78 */ GLEX_ANY, GLEX_EMPTY, 0, WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_POSITIVE_NUM - Strips whitespace after '+'
/* 79 */ L' ', GLEX_EMPTY, ST_POSITIVE_NUM, 0, GLEX_CONSUME,
/* 80 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 81 */ GLEX_ANY, GLEX_EMPTY, 0, WQL_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_HEX_CONST - Recognizes 0x hex constants
/* 82 */ L'0', L'9',       ST_HEX_CONST, 0, GLEX_ACCEPT,
/* 83 */  GLEX_ANY, GLEX_EMPTY,   0,          WQL_TOK_HEX_CONST,  GLEX_PUSHBACK|GLEX_RETURN,
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\wqllex.h ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    WQLLEX.H

Abstract:

	WQL DFA Table & Tokenizer

History:

	raymcc    14-Sep-97       Created.

--*/

#ifndef _WQLLEX_H_

#include <genlex.h>

#define WQL_TOK_EOF           0
#define WQL_TOK_ERROR         1

#define WQL_TOK_SELECT                      256
#define WQL_TOK_ALL                         257
#define WQL_TOK_DISTINCT                    258
#define WQL_TOK_OPTIONS_DUMMY               259
#define WQL_TOK_ASTERISK                    260
#define WQL_TOK_COUNT                       261
#define WQL_TOK_COMMA                       262
#define WQL_TOK_OPEN_PAREN                  263
#define WQL_TOK_CLOSE_PAREN                 264
#define WQL_TOK_IDENT                       265
#define WQL_TOK_DOT                         266
#define WQL_TOK_FROM                        267
#define WQL_TOK_AS                          268
#define WQL_TOK_INNER                       269
#define WQL_TOK_FULL                        270
#define WQL_TOK_LEFT                        271
#define WQL_TOK_RIGHT                       272
#define WQL_TOK_OUTER                       273
#define WQL_TOK_JOIN                        274
#define WQL_TOK_ON                          275
#define WQL_TOK_WHERE                       276
#define WQL_TOK_GROUP                       277
#define WQL_TOK_BY                          278
#define WQL_TOK_HAVING                      279
#define WQL_TOK_ORDER                       280
#define WQL_TOK_OR                          281
#define WQL_TOK_AND                         282
#define WQL_TOK_NOT                         283
#define WQL_TOK_LE                          284
#define WQL_TOK_LT                          285
#define WQL_TOK_GE                          286
#define WQL_TOK_GT                          287
#define WQL_TOK_EQ                          288
#define WQL_TOK_NE                          289
#define WQL_TOK_LIKE                        290
#define WQL_TOK_IS                          291
#define WQL_TOK_BEFORE                      292
#define WQL_TOK_AFTER                       293
#define WQL_TOK_BETWEEN                     294
#define WQL_TOK_QSTRING                     295
#define WQL_TOK_INT                         296
#define WQL_TOK_REAL                        297
#define WQL_TOK_CHAR                        298
#define WQL_TOK_NULL                        299
#define WQL_TOK_OPEN_BRACKET                300
#define WQL_TOK_CLOSE_BRACKET               301
#define WQL_TOK_ISA                         302
#define WQL_TOK_A                           303
#define WQL_TOK_DAY                         304
#define WQL_TOK_MONTH                       305
#define WQL_TOK_YEAR                        306
#define WQL_TOK_HOUR                        307
#define WQL_TOK_MINUTE                      308
#define WQL_TOK_SECOND                      309
#define WQL_TOK_MILLISECOND                 310

#define WQL_TOK_UPPER                       311
#define WQL_TOK_LOWER                       312
#define WQL_TOK_DATEPART                    313
#define WQL_TOK_QUALIFIER                   314
#define WQL_TOK_ISNULL                      315
#define WQL_TOK_IN                          316

#define WQL_TOK_NOT_LIKE                    317
#define WQL_TOK_NOT_BEFORE                  318
#define WQL_TOK_NOT_AFTER                   319
#define WQL_TOK_NOT_BETWEEN                 320
#define WQL_TOK_NOT_NULL                    321
#define WQL_TOK_NOT_IN                      322
#define WQL_TOK_NOT_A                       323

#define WQL_TOK_TYPED_EXPR                  324


#define WQL_TOK_IN_SUBSELECT                325
#define WQL_TOK_NOT_IN_SUBSELECT            326
#define WQL_TOK_IN_CONST_LIST               327
#define WQL_TOK_NOT_IN_CONST_LIST           328

#define WQL_TOK_ASC                         329
#define WQL_TOK_DESC                        330
#define WQL_TOK_AGGREGATE                   331
#define WQL_TOK_FIRSTROW                    332

#define WQL_TOK_PROMPT                      333
#define WQL_TOK_UNION                       334

#define WQL_TOK_OPEN_BRACE                  335
#define WQL_TOK_CLOSE_BRACE                 336
#define WQL_TOK_BRACKETED_STRING            337

#define WQL_TOK_INSERT                      338
#define WQL_TOK_UPDATE                      339
#define WQL_TOK_DELETE                      340
#define WQL_TOK_ASSOCIATORS                 341
#define WQL_TOK_REFERENCES                  342
#define WQL_TOK_THIS                        343
#define WQL_TOK_ISNOTA                      344
#define WQL_TOK_HEX_CONST                   345

extern LexEl WQL_LexTable[];




#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\wqlnode.h ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    WQLNODE.H

Abstract:

	WMI SQL Parse Node Definitions

History:

	raymcc      29-Sep-97       Created

--*/

#ifndef _WQLNODE_H_
#define _WQLNODE_H_


#define  WQL_FLAG_ALIAS          0x1
#define  WQL_FLAG_TABLE          0x2
#define  WQL_FLAG_ASTERISK       0x4
#define  WQL_FLAG_DISTINCT       0x8
#define  WQL_FLAG_ALL            0x10
#define  WQL_FLAG_COUNT          0x20
#define  WQL_FLAG_CONST          0x40
#define  WQL_FLAG_COLUMN         0x80
#define  WQL_FLAG_COMPLEX_NAME   0x100
#define  WQL_FLAG_FUNCTIONIZED   0x200
#define  WQL_FLAG_ARRAY_REF      0x400
#define  WQL_FLAG_UPPER          0x800
#define  WQL_FLAG_LOWER          0x1000
#define  WQL_FLAG_FIRSTROW       0x2000
#define  WQL_FLAG_CONST_RANGE    0x4000
#define  WQL_FLAG_SORT_ASC       0x8000
#define  WQL_FLAG_SORT_DESC      0x10000
#define  WQL_FLAG_AGGREGATE      0x20000
#define  WQL_FLAG_NULL           0x40000

#define WQL_FLAG_INNER_JOIN         1
#define WQL_FLAG_LEFT_OUTER_JOIN    2
#define WQL_FLAG_RIGHT_OUTER_JOIN   3
#define WQL_FLAG_FULL_OUTER_JOIN    4

#define WQL_TOK_BASE            100

#include <wmiutils.h>


class CWbemAssocQueryInf : public SWbemAssocQueryInf
{
public:
    CWbemAssocQueryInf();
   ~CWbemAssocQueryInf();
    void Empty();
    void Init();
    HRESULT CopyFrom(SWbemAssocQueryInf *pSrc);
};


//***************************************************************************
//
//  SWQLNode
//
//  Base node type for all parser output.
//
//***************************************************************************

struct SWQLNode
{
    DWORD        m_dwNodeType;
    SWQLNode    *m_pLeft;
    SWQLNode    *m_pRight;

    SWQLNode() { m_pLeft = 0; m_pRight = 0; m_dwNodeType = 0; }
    virtual ~SWQLNode() { if (m_pLeft) delete m_pLeft; if (m_pRight) delete m_pRight; }
    virtual void DebugDump() = 0;
};


//***************************************************************************
//
//   SWQLNode_QueryRoot
//
//   This is the root of the parse tree.  The child nodes are for one of
//  SELECT, INSERT, UPDATE, DELETE.
//
//                SWQLQueryRoot
//               /               \
//      SWQLNode_Select         NULL
//   or SWQLNode_Insert
//   or SWQLNode_Delete
//   or SWQLNode_Update
//   or SWQLNode_AssocQuery
//
//***************************************************************************
#define TYPE_SWQLNode_QueryRoot       (WQL_TOK_BASE + 1)

struct SWQLNode_QueryRoot : SWQLNode
{
    enum { eInvalid = 0, eSelect, eInsert, eDelete, eUpdate, eAssoc };
    DWORD m_dwQueryType;

    SWQLNode_QueryRoot() { m_dwNodeType = TYPE_SWQLNode_QueryRoot; m_dwQueryType = 0; }
   ~SWQLNode_QueryRoot() {}
    void DebugDump();
};


//***************************************************************************
//
//  SWQLTypedConst
//
//  Typed constant container (similar to OA VARIANT).
//
//***************************************************************************

union UWQLTypedConst
{
    LPWSTR  m_pString;       // VT_LPWSTR for WQL_TOK_QSTRING and WQL_TOK_PROMPT
    LONG    m_lValue;        // VT_LONG
    double  m_dblValue;      // VT_DOUBLE
    __int64 m_i64Value;     // VT_I8, VT_UI8
    BOOL    m_bValue;        // VT_BOOL, use TRUE/FALSE (not VARIANT_TRUE, VARIANT_FALSE)
};

struct SWQLTypedConst
{
    DWORD m_dwType;             // A VT_ type,  VT_UI4, VT_I8, VT_UI8 all supported
    UWQLTypedConst m_Value;     // One of the union fields
    bool m_bPrompt;             // Only true if token was WQL_TOK_PROMPT

    SWQLTypedConst();
    SWQLTypedConst(SWQLTypedConst &Src) { m_dwType = VT_NULL; *this = Src; }
    SWQLTypedConst & operator = (SWQLTypedConst &Src);
   ~SWQLTypedConst() { Empty(); }
    void Empty();
    void DebugDump();
};

struct SWQLConstList
{
    CFlexArray m_aValues;       // ptrs to SWQLTypedConst

    SWQLConstList() {}
    SWQLConstList(SWQLConstList &Src) { *this = Src; }
    SWQLConstList & operator = (SWQLConstList & Src);
   ~SWQLConstList() { Empty(); }
    int Add(SWQLTypedConst *pTC) { return m_aValues.Add(pTC); }
    void Empty();
};



struct SWQLQualifiedNameField
{
    LPWSTR  m_pName;         // Name
    BOOL    m_bArrayRef;     // TRUE if this is an array reference
    DWORD   m_dwArrayIndex;  // If <m_bArrayRef == TRUE> this is the array index

    SWQLQualifiedNameField() { m_pName = 0; m_bArrayRef = 0; m_dwArrayIndex = 0; }
    SWQLQualifiedNameField(SWQLQualifiedNameField &Src) { m_pName = 0; *this = Src; }
    SWQLQualifiedNameField & operator = (SWQLQualifiedNameField &Src);

   ~SWQLQualifiedNameField() { Empty(); }
private:
    void Empty() { delete [] m_pName; m_pName = 0; }
};

struct SWQLQualifiedName
{
    CFlexArray m_aFields;       // [0] =  left most, last entry is column

    SWQLQualifiedName() {}
    SWQLQualifiedName(SWQLQualifiedName &Src) { *this = Src; }
    SWQLQualifiedName & operator = (SWQLQualifiedName &Src);
   ~SWQLQualifiedName() { Empty(); }

    int GetNumNames() { return m_aFields.Size(); }

    const LPWSTR GetName(int nIndex)
    {
        return (LPWSTR) ((SWQLQualifiedNameField*) m_aFields[nIndex])->m_pName;
    }

    int Add(SWQLQualifiedNameField *pQN) { return m_aFields.Add(pQN); }
    void Empty()
    {
        for (int i = 0; i < m_aFields.Size(); i++)
	     delete (SWQLQualifiedNameField *) m_aFields[i];
    }
};




//***************************************************************************
//
//   SWQLNode_Select
//
//   This is the root of the parse tree or the root of a subselect.
//
//                SWQLNode_Select
//               /               \
//      SWQLNode_TableRefs     SWQLNode_WhereClause
//     /                \      /                   \
//    x                  x    x                     x
//
//***************************************************************************

#define TYPE_SWQLNode_Select        (WQL_TOK_BASE + 2)

struct SWQLNode_Select : SWQLNode
{
    // Left  Node is of type SWQLNode_TableRefs
    // Right Node is of type SWQLNode_WhereClause

    int m_nStPos;
    int m_nEndPos;

    SWQLNode_Select() : m_nStPos(-1), m_nEndPos(-1) { m_dwNodeType = TYPE_SWQLNode_Select; }
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_TableRefs
//
//  This contains everything prior to the WHERE clause: the target
//  column list and the FROM clause.
//
//  Also contains the SELECT type, i.e., ALL vs. DISTINCT vs. COUNT.
//
//                SWQLNode_TableRefs
//               /               \
//      SWQLNode_ColumnList     SWQLNode_FromClause
//
//  In all cases, SWQLNode_ColumnList is present.  Note that if the
//  user did a "select *...", then the SWQLNode_ColumnList will only
//  have a single column in it clearly marked as an asterisk.  If
//  a "select count(...) " was done, then m_nSelectType is set to
//  WQL_FLAG_COUNT and the SWQLNode_ColumnList will have a single
//  column in it, whether an * or a qualified name.
//
//***************************************************************************

#define TYPE_SWQLNode_TableRefs      (WQL_TOK_BASE + 3)

struct SWQLNode_TableRefs : SWQLNode
{
    // Left  Node is SWQLNode_ColumnList
    // Right Node is SWQLNode_FromClause

    int m_nSelectType;       // WQL_FLAG_ALL means ALL was used.
                             // WQL_FLAG_DISTINCT means DISTINCT was used.
                             // WQL_FLAG_COUNT means COUNT was used.

    SWQLNode_TableRefs()
        { m_nSelectType = WQL_FLAG_ALL;
          m_dwNodeType = TYPE_SWQLNode_TableRefs;
        }

   ~SWQLNode_TableRefs() {}
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_ColumnList
//
//  This contains the selected list of columns.
//
//                SWQLNode_ColumnList
//               /                 \
//              NULL               NULL
//
//***************************************************************************

#define TYPE_SWQLNode_ColumnList   (WQL_TOK_BASE + 4)

struct SWQLNode_ColumnList : SWQLNode
{
    // Left  Node is NULL
    // Right Node is NULL

    CFlexArray m_aColumnRefs ;   // Pointers to SWQLColRef entries.

    SWQLNode_ColumnList() { m_dwNodeType = TYPE_SWQLNode_ColumnList; }
   ~SWQLNode_ColumnList() { Empty(); }
    void Empty();
    void DebugDump();
};


struct SWQLColRef
{
    LPWSTR m_pColName;      // The column name or "*" or NULL
    LPWSTR m_pTableRef;     // The table/alias name or NULL if there is none
    DWORD  m_dwArrayIndex;
    DWORD  m_dwFlags;       // WQL_FLAG_TABLE bit set if m_pTableRef
                            //   is a table name
                            // WQL_FLAG_ALIAS bit set if m_pTableRef
                            //   is a table alias
                            // WQL_FLAG_ASTERISK bit set if m_pColName is
                            //   * (this is faster than to check than a
                            //   string compare on <m_pColName> for "*".
                            // WQL_FLAG_NULL if the column name was "NULL"
                            // WQL_FLAG_FUNCTIONIZED is set if the column
                            //    is wrapped in a function call.
                            //    The function bits WQL_FLAG_UPPER or
                            //    WQL_FLAG_LOWER will be set.
                            // WQL_FLAG_ARRAY_REF is set if the column
                            //    is an array column, in which case
                            //    m_dwArrayIndex is set to the array offset.
                            // WQL_FLAG_COMPLEX_NAME is set if the name
                            //  is qualified in a deeply nested way,
                            //  which requires examination of the <QName>
                            //  object.  In this case <m_pColName> is
                            //  set to the last name, but m_pTableRef
                            //  is left blank.
                            // WQL_FLAG_SORT_ASC to sort ascending (Order by only)
                            // WQL_FLAG_SORT_DESC to sort descending (Order by only)

    SWQLQualifiedName *m_pQName;    // The full qualified name

    SWQLColRef() { m_pColName = NULL; m_pTableRef = 0;
        m_dwFlags = 0; m_dwArrayIndex = 0; m_pQName = 0;
        }

   ~SWQLColRef() { delete [] m_pColName; delete [] m_pTableRef; delete m_pQName; }
    //
    // we are inlining to remove a compiler dependency in wbemcomn
    //
    void DebugDump()
    {
	    printf("  ---SWQLColRef---\n");
	    printf("  Col Name    = %S\n",   m_pColName);
	    printf("  Table       = %S\n",   m_pTableRef);
	    printf("  Array Index = %d\n", m_dwArrayIndex);
	    printf("  Flags       = 0x%X ", m_dwFlags);

	    if (m_dwFlags & WQL_FLAG_TABLE)
	        printf("WQL_FLAG_TABLE ");
	    if (m_dwFlags & WQL_FLAG_COLUMN)
	        printf("WQL_FLAG_COLUMN ");
	    if (m_dwFlags & WQL_FLAG_ASTERISK)
	        printf("WQL_FLAG_ASTERISK ");
	    if (m_dwFlags & WQL_FLAG_NULL)
	        printf("WQL_FLAG_NULL ");
	    if (m_dwFlags & WQL_FLAG_FUNCTIONIZED)
	        printf("WQL_FLAG_FUNCTIONIZED ");
	    if (m_dwFlags & WQL_FLAG_COMPLEX_NAME)
	        printf("WQL_FLAG_COMPLEX_NAME ");
	    if (m_dwFlags & WQL_FLAG_ARRAY_REF)
	        printf(" WQL_FLAG_ARRAY_REF");
	    if (m_dwFlags & WQL_FLAG_UPPER)
	        printf(" WQL_FLAG_UPPER");
	    if (m_dwFlags & WQL_FLAG_LOWER)
	        printf(" WQL_FLAG_LOWER");
	    if (m_dwFlags & WQL_FLAG_SORT_ASC)
	        printf(" WQL_FLAG_SORT_ASC");
	    if (m_dwFlags & WQL_FLAG_SORT_DESC)
	        printf(" WQL_FLAG_SORT_DESC");

	    printf("\n");

	    printf("  ---\n\n");
	}    	
    	
};



//***************************************************************************
//
//   SWQLNode_FromClause
//
//   The subtree containing the tables selected from and any joins.
//
//                SWQLNode_FromClause
//               /                   \
//             SWQLNode_TableRef      SWQLNode_WmiScopedSelect
//          or SWQLNode_Join
//          or SWQLNode_Sql89Join
//
//  Note that left and right nodes are mutually exclusive.  Either
//  the left side is used for traditional SQL or the right side is
//  used for the WMI scoped select.
//
//***************************************************************************

#define TYPE_SWQLNode_FromClause  (WQL_TOK_BASE + 5)

struct SWQLNode_FromClause : SWQLNode
{
    // Left is SWQLNode_TableRef or SWQLNode_Join
    // Right is NULL

    SWQLNode_FromClause() { m_dwNodeType = TYPE_SWQLNode_FromClause; }
   ~SWQLNode_FromClause() {}
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_WmiScopedSelect
//
//                SWQLNode_WmiScopedSelect
//               /                   \
//             NULL                  NULL
//
//
//   Contains a special-case selection for WMI v2.  The syntax is
//
//      FROM '['<object path>']' <class-list>
//
//   ...where <class-list> is either a single class or a curly-bracket-delimited
//   list of classes, separated by commas:
//
//          FROM [scope.p1=2] MyClass
//          FROM [scope.p1=2] {MyClass}
//          FROM [scope.p1=2] {MyClass, MyClass2}
//
//
//***************************************************************************


#define TYPE_SWQLNode_WmiScopedSelect (WQL_TOK_BASE + 6)

struct SWQLNode_WmiScopedSelect : SWQLNode
{
    LPWSTR m_pszScope;
    CFlexArray m_aTables;

    SWQLNode_WmiScopedSelect()
        { m_dwNodeType = TYPE_SWQLNode_FromClause;
          m_pszScope = 0;
        }

   ~SWQLNode_WmiScopedSelect()
        {
            for (int i = 0; i < m_aTables.Size(); i++)
                delete LPWSTR(m_aTables[i]);
            delete m_pszScope;
        }

    void DebugDump();
};


//***************************************************************************
//
//  SWQLNode_Sql89Join
//
//  A subtree which expresses a SQL-89 join.
//
//                SWQLNode_Sql89Join
//               /             \
//             NULL             NULL
//
//***************************************************************************

#define TYPE_SWQLNode_Sql89Join     (WQL_TOK_BASE + 7)

struct SWQLNode_Sql89Join : SWQLNode
{
    CFlexArray m_aValues;           // Array of pointers to SWQLNode_TableRef
                                    // objects

    SWQLNode_Sql89Join() { m_dwNodeType = TYPE_SWQLNode_Sql89Join; }
    ~SWQLNode_Sql89Join() {Empty();};
    void DebugDump();
    void Empty();
};



//***************************************************************************
//
//  SWQLNode_Join
//
//  A subtree which expresses a join.
//
//                SWQLNode_Join
//               /              \
//       SWQLNode_JoinPair       SWQLNode_OnClause or NULL.
//
//***************************************************************************

#define TYPE_SWQLNode_Join  (WQL_TOK_BASE + 8)

struct SWQLNode_Join : SWQLNode
{
    // Left ptr is SWQLNode_JoinPair
    // Right ptr is ON clause.  If NULL, there is no ON clause
    // and the JOIN was a SQL-89 style join with the join condition
    // present in the WHERE clause.

    DWORD m_dwJoinType;
            // One of WQL_FLAG_INNER_JOIN, WQL_FLAG_LEFT_OUTER_JOIN,
            // WQL_FLAG_RIGHT_OUTER_JOIN or WQL_FLAG_FULL_OUTER_JOIN
    DWORD m_dwFlags;
        // Contains WQL_FLAG_FIRSTROW if used

    SWQLNode_Join() { m_dwNodeType = TYPE_SWQLNode_Join; m_dwJoinType = m_dwFlags = 0; }
   ~SWQLNode_Join() {}
    void DebugDump();
};


//***************************************************************************
//
//  SWQLNode_JoinPair
//
//                SWQLNode_JoinPair
//               /                 \
//        <SWQLNode_Join or SWQLNode_TableRef>
//
//***************************************************************************
#define TYPE_SWQLNode_JoinPair   (WQL_TOK_BASE + 9)

struct SWQLNode_JoinPair : SWQLNode
{
    // Left ptr is SWQLNode_Join or SWQLNode_TableRef
    // Right ptr is SWQLNodeNode_Join or SWQL_NodeTableRef

    SWQLNode_JoinPair() { m_dwNodeType = TYPE_SWQLNode_JoinPair; }
   ~SWQLNode_JoinPair() {}

    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_TableRef
//
//  A node representing a table name and its alias, if any.
//
//                SWQLNode_TableRef
//               /                 \
//             NULL               NULL
//
//***************************************************************************

#define TYPE_SWQLNode_TableRef  (WQL_TOK_BASE + 10)

struct SWQLNode_TableRef : SWQLNode
{
    LPWSTR m_pTableName;        // The table
    LPWSTR m_pAlias;            // Table alias. NULL if not used.

    SWQLNode_TableRef() { m_pTableName = 0; m_pAlias = 0; m_dwNodeType = TYPE_SWQLNode_TableRef; }
    ~SWQLNode_TableRef() { delete [] m_pTableName; delete [] m_pAlias; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_OnClause
//
//                SWQLNode_OnClause
//               /                 \
//        <SWQLNode_RelExpr>        NULL
//
//***************************************************************************
#define TYPE_SWQLNode_OnClause   (WQL_TOK_BASE + 11)

struct SWQLNode_OnClause : SWQLNode
{
    // Left ptr is <SWQLNode_RelExpr> which contains the ON clause.
    // Right ptr is always NULL.

    SWQLNode_OnClause() { m_dwNodeType = TYPE_SWQLNode_OnClause; }
   ~SWQLNode_OnClause() {}
    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_WhereClause
//
//                SWQLNode_WhereClause
//               /                 \
//        SWQLNode_RelExpr         SWQLNode_WhereOptions or NULL
//        or
//        NULL if no conditions
//
//***************************************************************************

#define TYPE_SWQLNode_WhereClause  (WQL_TOK_BASE + 12)

struct SWQLNode_WhereClause : SWQLNode
{
    // Left ptr is SWQLNode_RelExpr.
    // Right ptr is SQLNode_QueryOptions or NULL if none

    SWQLNode_WhereClause() { m_dwNodeType = TYPE_SWQLNode_WhereClause; }
   ~SWQLNode_WhereClause() {}

    void DebugDump();
};

//***************************************************************************
//
//  struct SWQLTypedExpr
//
//  This represents a typed subexpression in a where clause:
//
//      mycol < 2
//      33 <= tbl1.col2
//      tbl3.col4 = tbl4.col5
//      ...etc.
//
//***************************************************************************

struct SWQLTypedExpr
{
    LPWSTR         m_pTableRef;         // For qualified column names,
                                        //   NULL if not used
    LPWSTR         m_pColRef;           // Column name

    DWORD          m_dwRelOperator;     // The operator used: WQL_TOK_LE,
                                        //  WQL_TOK_GE, WQL_TOK_LIKE etc.
                                        //  WQL_TOK_IN_CONST_LIST
                                        //  WQL_TOK_NOT_IN_CONST_LIST
                                        //  WQL_TOK_IN_SUBSELECT
                                        //  WQL_TOK_NOT_IN_SUBSELECT

    SWQLTypedConst *m_pConstValue;     // A const value
    SWQLTypedConst *m_pConstValue2;    // The other const value used with BETWEEN

    LPWSTR         m_pJoinTableRef;     // The joined table name or its alias,
                                        //   NULL if not used
    LPWSTR         m_pJoinColRef;       // The joined column name

    LPWSTR         m_pIntrinsicFuncOnColRef;
    LPWSTR         m_pIntrinsicFuncOnJoinColRef;
    LPWSTR         m_pIntrinsicFuncOnConstValue;

    SWQLNode      *m_pLeftFunction;         // More detail for DATEPART, etc.
    SWQLNode      *m_pRightFunction;        // More detail for DATEPART, etc.

    DWORD          m_dwLeftArrayIndex;
    DWORD          m_dwRightArrayIndex;

    SWQLQualifiedName *m_pQNRight;
    SWQLQualifiedName *m_pQNLeft;

    DWORD          m_dwLeftFlags;
    DWORD          m_dwRightFlags;
        // Each of the above to Flags shows the expression layout on each side
        // of the operator.
        //  WQL_FLAG_CONST        = A typed constant was used
        //  WQL_FLAG_COLUMN       = Column field was used
        //  WQL_FLAG_TABLE        = Table/Alias was used
        //  WQL_FLAG_COMPLEX      = Complex qualified name and/or array was used
        //  WQL_FLAG_FUNCTIONIZED = Function was applied over the const or col.


    // For IN and NOT IN clauses.
    // ==========================

    SWQLNode       *m_pSubSelect;

    SWQLConstList  *m_pConstList;   // For IN clause with constant-list

    /*
    (1) If a const is tested against a column, then <m_pConstValue> will
        be used to represent it, and the table+col referenced will be in
        <m_pTableRef> and <m_pColRef>.

    (2) If a join occurs, then <m_pConstValue> will be NULL.

    (3) Intrinsic functions (primarily UPPER() and LOWER()) can be applied
        to the column references  or the constant.  The function names will
        be placed in the <m_pIntrinsic...> pointers when applied.

    (4) If <m_dwRelOperator> is WQL_TOK_IN_CONST_LIST or WQL_TOK_NOT_IN_CONST_LIST
        then <m_aConstSet> is an array of pointers to SWQLTypedConst structs representing
        the set of constants that the referenced column must intersect with.

    (5) If <m_dwRelOperator> is WQL_TOK_IN_SUBSELECT or WQL_TOK_NOT_IN_SUBSELECT
        then m_pSubSelect is a pointer to an embedded subselect tree in the form
        of a SWQLNode_Select struct, beginning the root of an entirely new select
        statement.
    */

    SWQLTypedExpr();
   ~SWQLTypedExpr() { Empty(); }
    void DebugDump();
    void Empty();
};



//***************************************************************************
//
//  SWQLNode_RelExpr
//
//                SWQLNode_RelExpr
//               /                \
//        SWQLNode_RelExpr        SWQLNode_RelExpr
//        or NULL                 or NULL
//
//***************************************************************************

#define TYPE_SWQLNode_RelExpr   (WQL_TOK_BASE + 13)

struct SWQLNode_RelExpr : SWQLNode
{
    DWORD m_dwExprType;  // WQL_TOK_OR
                         // WQL_TOK_AND
                         // WQL_TOK_NOT
                         // WQL_TOK_TYPED_EXPR

    SWQLTypedExpr *m_pTypedExpr;

    /*
    (1) If the <m_dwExprType> is WQL_TOK_AND or WQL_TOK_OR, then each of
        the two subnodes are themselves SWQLNode_RelExpr nodes and
        <m_pTypedExpr> points to NULL.

    (2) If <m_dwExprType> is WQL_TOK_NOT, then <m_pLeft> points to a
        SWQLNode_RelExpr containing the subclause to which to apply the NOT
        operation and <m_pRight> points to NULL.

    (3) If <m_dwExprType> is WQL_TOK_TYPED_EXPR, then <m_pLeft> and
        <m_pRight> both point to NULL, and <m_pTypedExpr> contains a typed
        relational subexpression.

    (4) Parentheses have been removed and are implied by the nesting.
    */

    SWQLNode_RelExpr() { m_dwNodeType = TYPE_SWQLNode_RelExpr; m_pTypedExpr = 0; m_dwExprType = 0; }
   ~SWQLNode_RelExpr() { delete m_pTypedExpr; }
    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_WhereOptions
//
//                SWQLNode_WhereOptions
//               /                 \
//           SWQLNode_GroupBy      SWQLNode_OrderBy
//
//***************************************************************************

#define TYPE_SWQLNode_WhereOptions (WQL_TOK_BASE + 14)

struct SWQLNode_WhereOptions : SWQLNode
{
    // left ptr is SWQLNode_GroupBy, or NULL if not used
    // right ptr is SWQLNode_OrderBy, or NULL if not used

    SWQLNode_WhereOptions() { m_dwNodeType = TYPE_SWQLNode_WhereOptions; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_GroupBy
//
//                SWQLNode_GroupBy
//               /                \
//        SWQLNode_ColumnList    SWQLNode_Having
//                               or NULL
//
//***************************************************************************

#define TYPE_SWQLNode_GroupBy (WQL_TOK_BASE + 15)

struct SWQLNode_GroupBy : SWQLNode
{
    // left ptr is SWQLNode_ColumnList of columns to group by
    // right ptr is Having clause, if any

    SWQLNode_GroupBy() { m_dwNodeType = TYPE_SWQLNode_GroupBy; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_Having
//
//                SWQLNode_Having
//               /               \
//           SWQLNode_RelExpr    NULL
//
//***************************************************************************

#define TYPE_SWQLNode_Having (WQL_TOK_BASE + 16)

struct SWQLNode_Having : SWQLNode
{
    // left ptr is SQLNode_RelExpr pointing to HAVING expressions
    // right ptr is NULL

    SWQLNode_Having() { m_dwNodeType = TYPE_SWQLNode_Having; }
    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_OrderBy
//
//                SWQLNode_OrderBy
//               /                \
//      SWQLNode_ColumnList       NULL
//
//***************************************************************************

#define TYPE_SWQLNode_OrderBy (WQL_TOK_BASE + 17)

struct SWQLNode_OrderBy : SWQLNode
{
    // left ptr is SWQLNode_ColumnList
    // right ptr is NULL
    SWQLNode_OrderBy() { m_dwNodeType = TYPE_SWQLNode_OrderBy; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_Datepart
//
//  Contains a datepart call.
//
//***************************************************************************
#define TYPE_SWQLNode_Datepart  (WQL_TOK_BASE + 18)

struct SWQLNode_Datepart : SWQLNode
{
    int m_nDatepart;        // One of WQL_TOK_YEAR, WQL_TOK_MONTH,
                            // WQL_TOK_DAY, WQL_TOK_HOUR, WQL_TOK_MINUTE
                            // WQL_TOK_SECOND

    SWQLColRef *m_pColRef;  // The column to which DATEPART applies

    SWQLNode_Datepart() { m_dwNodeType = TYPE_SWQLNode_Datepart; m_nDatepart = 0; }
   ~SWQLNode_Datepart() { delete m_pColRef; }

    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_Delete
//
//   This is the root of a parse tree for delete.
//
//                SWQLNode_Delete
//               /               \
//      SWQLNode_TableRef   vSWQLNode_WhereClause
//     /                \
//    x                  x
//
//***************************************************************************

#define TYPE_SWQLNode_Delete        (WQL_TOK_BASE + 19)

struct SWQLNode_Delete : SWQLNode
{
    // Left  Node is of type SWQLNode_TableRef
    // Right Node is of type SWQLNode_WhereClause

    SWQLNode_Delete() { m_dwNodeType = TYPE_SWQLNode_Delete; }
   ~SWQLNode_Delete();
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_Insert
//
//   This is the root of an INSERT
//
//                SWQLNode_Delete
//               /               \
//      SWQLNode_TableRef       SWQLNode_InsertValues
//     /                \
//    x                  x
//
//***************************************************************************

#define TYPE_SWQLNode_Insert        (WQL_TOK_BASE + 20)

struct SWQLNode_Insert : SWQLNode
{
    SWQLNode_Insert() { m_dwNodeType = TYPE_SWQLNode_Insert; }
   ~SWQLNode_Insert();
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_Update
//
//   This is the root of an INSERT
//
//                SWQLNode_Update
//               /               \
//      SWQLNode_SetClause      SWQLNode_WhereClause
//
//***************************************************************************

#define TYPE_SWQLNode_Update        (WQL_TOK_BASE + 21)

struct SWQLNode_Update : SWQLNode
{
    SWQLNode_Update() { m_dwNodeType = TYPE_SWQLNode_Update; }
   ~SWQLNode_Update();
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_AssocQuery
//
//                SWQLNode_AssocQuery
//               /               \
//             NULL             NULL
//
//***************************************************************************

#define TYPE_SWQLNode_AssocQuery        (WQL_TOK_BASE + 22)

struct SWQLNode_AssocQuery : SWQLNode
{
    CWbemAssocQueryInf *m_pAQInf;

    SWQLNode_AssocQuery() { m_pAQInf = 0; m_dwNodeType = TYPE_SWQLNode_AssocQuery; }
    ~SWQLNode_AssocQuery() { delete m_pAQInf; }
    void DebugDump();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\wqlscan.h ===
/*++



// Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    WQLSCAN.H

Abstract:

    WQL Prefix Scanner

History:

	raymcc  26-Mar-98

--*/

#ifndef _WQLSCAN_H_
#define _WQLSCAN_H_


struct WSLexToken
{
    int      m_nToken;
    wchar_t *m_pszTokenText;

    WSLexToken() { m_pszTokenText = 0; }
    ~WSLexToken() { delete [] m_pszTokenText; }
};

typedef WSLexToken *PWSLexToken;

struct WSTableRef
{
    wchar_t *m_pszTable;    
    wchar_t *m_pszAlias;    // Can be NULL if no alias specified

    WSTableRef() { m_pszTable = m_pszAlias = 0; }
   ~WSTableRef() { delete [] m_pszTable; delete [] m_pszAlias; }
};

typedef WSTableRef * PWSTableRef;

class CWQLScanner
{
    // Data.
    // =====

    CGenLexer    *m_pLexer;
    int           m_nLine;
    wchar_t      *m_pTokenText;
    int           m_nCurrentToken;
    BOOL          m_bCount;

    CFlexArray m_aTokens;       // Array of ptrs to WSLexToken structs.
    CFlexArray m_aPropRefs;     // Array of ptrs to SWQLColRef structs.
    CFlexArray m_aTableRefs;    // Ptrs to WSTableRef structs.
    
    // Local functions.
    // ==================

    BOOL Next();
    PWSLexToken ExtractNext();
    void Pushback(PWSLexToken);

    BOOL StripWhereClause();
    BOOL SelectList();
    BOOL ReduceSql92Joins();
    BOOL ReduceSql89Joins();
    BOOL ExtractSelectType();

    void ClearTableRefs();
    void ClearPropRefs();
    void ClearTokens();

    BOOL BuildSWQLColRef(
        CFlexArray &aTokens,
        SWQLColRef  &ColRef      // Empty on entry
        );

public:
    enum { 
        SUCCESS,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL,
        INVALID_PARAMETER,
        INTERNAL_ERROR
    };

    const LPWSTR AliasToTable(LPWSTR pszAlias);

    BOOL GetReferencedAliases(CWStringArray &aClasses);
    BOOL GetReferencedTables(CWStringArray &aClasses);
    BOOL CountQuery() {return m_bCount;}

    CWQLScanner(CGenLexSource *pSrc);
   ~CWQLScanner(); 
    int Parse();
    
    void Dump();

    const CFlexArray *GetSelectedColumns() { return &m_aPropRefs; }
        // Returns pointer to array of SWQLColRef*

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\common\wmiutils\wqlscan.cpp ===
/*++



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 

Module Name:

    WQLSCAN.CPP

Abstract:

    WQL Prefix Scanner

    This module implements a specially cased shift-reduce parser to
    parse out selected columns, JOINed tables and aliases, while ignoring
    the rest of the query.

History:

    raymcc    17-Oct-97       SMS extensions.

--*/


#include "precomp.h"
#include <stdio.h>

#include <flexarry.h>
#include <wqllex.h>
#include <wqlnode.h>
#include <wqlscan.h>

#include <helpers.h>

#define trace(x) printf x


class CTokenArray : public CFlexArray
{
public:
    ~CTokenArray() { Empty(); }
    void Empty()
    {
        for (int i = 0; i < Size(); i++) delete PWSLexToken(GetAt(i));
        CFlexArray::Empty();
    }
};

//***************************************************************************
//
//  CWQLScanner::CWQLScanner
//
//  Constructor
//
//  Parameters:
//  <pSrc>          A source from which to lex from.
//
//***************************************************************************

CWQLScanner::CWQLScanner(CGenLexSource *pSrc)
{
    m_pLexer = new CGenLexer(WQL_LexTable, pSrc);
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;
    m_bCount = FALSE;
}

//***************************************************************************
//
//  CWQLScanner::~CWQLScanner
//
//***************************************************************************


CWQLScanner::~CWQLScanner()
{
    delete m_pLexer;

    ClearTokens();
    ClearTableRefs();
    ClearPropRefs();
}

//***************************************************************************
//
//***************************************************************************

BOOL CWQLScanner::GetReferencedAliases(CWStringArray &aAliases)
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        aAliases.Add(pTRef->m_pszAlias);
    }
    return TRUE;
}
//***************************************************************************
//
//***************************************************************************

BOOL CWQLScanner::GetReferencedTables(CWStringArray &aClasses)
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        aClasses.Add(pTRef->m_pszTable);
    }
    return TRUE;
}

//***************************************************************************
//
//***************************************************************************
void CWQLScanner::ClearTokens()
{
    for (int i = 0; i < m_aTokens.Size(); i++)
        delete (WSLexToken *) m_aTokens[i];
}

//***************************************************************************
//
//***************************************************************************
void CWQLScanner::ClearPropRefs()
{
    for (int i = 0; i < m_aPropRefs.Size(); i++)
        delete (SWQLColRef *) m_aPropRefs[i];
}

//***************************************************************************
//
//***************************************************************************

void CWQLScanner::ClearTableRefs()
{
    for (int i = 0; i < m_aTableRefs.Size(); i++)
        delete (WSTableRef *) m_aTableRefs[i];
    m_aTableRefs.Empty();
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

struct WqlKeyword
{
    LPWSTR m_pKeyword;
    int    m_nTokenCode;
};

static WqlKeyword KeyWords[] =      // Keep this alphabetized for binary search
{
    L"ALL",      WQL_TOK_ALL,
    L"AND",      WQL_TOK_AND,
    L"AS",       WQL_TOK_AS,
    L"BETWEEN",  WQL_TOK_BETWEEN,
    L"BY",       WQL_TOK_BY,
    L"COUNT",    WQL_TOK_COUNT,
    L"DATEPART", WQL_TOK_DATEPART,
    L"DISTINCT", WQL_TOK_DISTINCT,
    L"FIRSTROW", WQL_TOK_FIRSTROW,
    L"FROM",     WQL_TOK_FROM,
    L"FULL",     WQL_TOK_FULL,
    L"GROUP",    WQL_TOK_GROUP,
    L"HAVING",   WQL_TOK_HAVING,
    L"IN",       WQL_TOK_IN,
    L"INNER",    WQL_TOK_INNER,
    L"IS",       WQL_TOK_IS,
    L"ISA",      WQL_TOK_ISA,
    L"ISNULL",   WQL_TOK_ISNULL,
    L"JOIN",     WQL_TOK_JOIN,
    L"LEFT",     WQL_TOK_LEFT,
    L"LIKE",     WQL_TOK_LIKE,
    L"LOWER",    WQL_TOK_LOWER,
    L"NOT",      WQL_TOK_NOT,
    L"NULL",     WQL_TOK_NULL,
    L"ON",       WQL_TOK_ON,
    L"OR",       WQL_TOK_OR,
    L"ORDER",    WQL_TOK_ORDER,
    L"OUTER",    WQL_TOK_OUTER,
    L"QUALIFIER", WQL_TOK_QUALIFIER,
    L"RIGHT",    WQL_TOK_RIGHT,
    L"SELECT",   WQL_TOK_SELECT,
    L"UNION",    WQL_TOK_UNION,
    L"UPPER",    WQL_TOK_UPPER,
    L"WHERE",    WQL_TOK_WHERE

};

const int NumKeywords = sizeof(KeyWords)/sizeof(WqlKeyword);

BOOL CWQLScanner::Next()
{
    if (!m_pLexer)
        return FALSE;

    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == WQL_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == WQL_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check. Do a binary search
    // on the keyword table.
    // =================================

    if (m_nCurrentToken == WQL_TOK_IDENT)
    {
        int l = 0, u = NumKeywords - 1;

        while (l <= u)
        {
            int m = (l + u) / 2;
            if (wbem_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) < 0)
                u = m - 1;
            else if (wbem_wcsicmp(m_pTokenText, KeyWords[m].m_pKeyword) > 0)
                l = m + 1;
            else        // Match
            {
                m_nCurrentToken = KeyWords[m].m_nTokenCode;
                break;
            }
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  CWQLScanner::ExtractNext
//
//***************************************************************************

PWSLexToken CWQLScanner::ExtractNext()
{
    if (m_aTokens.Size() == 0)
        return NULL;

    PWSLexToken pTok = PWSLexToken(m_aTokens[0]);
    m_aTokens.RemoveAt(0);
    return pTok;
}

//***************************************************************************
//
//  CWQLScanner::Pushback
//
//***************************************************************************

void CWQLScanner::Pushback(PWSLexToken pPushbackTok)
{
    m_aTokens.InsertAt(0, pPushbackTok);
}

//***************************************************************************
//
//  Shift-reduce parser entry.
//
//***************************************************************************

int CWQLScanner::Parse()
{
    int nRes = SYNTAX_ERROR;
    if (m_pLexer == NULL)
        return FAILED;

    m_pLexer->Reset();

    if (!Next())
        return LEXICAL_ERROR;


    // Completely tokenize the entire query and build a parse-stack.
    // =============================================================

    if (m_nCurrentToken == WQL_TOK_SELECT)
    {
        while (1)
        {
            WSLexToken *pTok = new WSLexToken;
            if (!pTok)
                return FAILED;

            pTok->m_nToken = m_nCurrentToken;
            pTok->m_pszTokenText = Macro_CloneLPWSTR(m_pTokenText);

            if (!pTok->m_pszTokenText)
                return FAILED;

            m_aTokens.Add(pTok);

            if (m_nCurrentToken == WQL_TOK_EOF)
                break;

            if (!Next())
                return LEXICAL_ERROR;
        }
    }
    else
        return SYNTAX_ERROR;

    // Reduce by extracting the select type keywords if possible.
    // ==========================================================

    nRes = ExtractSelectType();
    if (nRes)
        return nRes;

    // Eliminate all tokens from WHERE onwards.
    // ========================================

    StripWhereClause();

    // Reduce by extracting the select list.
    // =====================================

    if (!m_bCount)
    {
        nRes = SelectList();
        if (nRes != 0)
            return nRes;
    }
    else
    {
        // Strip everything until the FROM keyword is encountered.
        // =======================================================

        WSLexToken *pTok = ExtractNext();


        while (pTok)
        {
            if (pTok->m_nToken == WQL_TOK_FROM)
            {
                Pushback(pTok);
                break;
            }
            // Bug #46728: the count(*) clause
            // can be the only element of the select clause.

            else if (!wcscmp(pTok->m_pszTokenText, L","))
            {
                delete pTok;
                return SYNTAX_ERROR;
            }

            delete pTok;
            pTok = ExtractNext();
        }
        if (pTok == 0)
            return SYNTAX_ERROR;
    }

    // Extract tables/aliases from JOIN clauses.
    // =========================================

    if (ReduceSql89Joins() != TRUE)
    {
        ClearTableRefs();
        if (ReduceSql92Joins() != TRUE)
            return SYNTAX_ERROR;
    }


    // Post process select clause to determine if
    // columns are tables or aliases.
    // ==========================================
    for (int i = 0; i < m_aPropRefs.Size(); i++)
    {
        SWQLColRef *pCRef = (SWQLColRef *) m_aPropRefs[i];
        if (pCRef->m_pTableRef != 0)
        {
            LPWSTR pTbl = AliasToTable(pCRef->m_pTableRef);
            if (pTbl == 0)
                continue;

            if (wbem_wcsicmp(pTbl, pCRef->m_pTableRef) == 0)
                pCRef->m_dwFlags |= WQL_FLAG_TABLE;
            else
                pCRef->m_dwFlags |= WQL_FLAG_ALIAS;
        }
    }


    if (m_aTableRefs.Size() == 0)
        return SYNTAX_ERROR;


    return SUCCESS;
}

//***************************************************************************
//
//  CWQLScanner::StripWhereClause
//
//  If present, removes the WHERE or ORDER BY clause.  Because
//  of SQL Syntax, stripping the first of {ORDER BY, WHERE} will automatically
//  get rid of the other.
//
//***************************************************************************
BOOL CWQLScanner::StripWhereClause()
{
    for (int i = 0; i < m_aTokens.Size(); i++)
    {
        WSLexToken *pCurrent = (WSLexToken *) m_aTokens[i];

        // If a WHERE token is found, we have something to strip.
        // ======================================================

        if (pCurrent->m_nToken == WQL_TOK_WHERE ||
            pCurrent->m_nToken == WQL_TOK_ORDER)
        {
            int nNumTokensToRemove = m_aTokens.Size() - i - 1;
            for (int i2 = 0; i2 < nNumTokensToRemove; i2++)
            {
                delete PWSLexToken(m_aTokens[i]);
                m_aTokens.RemoveAt(i);
            }
            return TRUE;
        }
    }

    return FALSE;
}


//***************************************************************************
//
//  CWQLScanner::ExtractSelectType
//
//  Examines the prefix to reduce the query by eliminating the SELECT
//  and select-type keywords, such as ALL, DISTINCT, FIRSTROW, COUNT
//
//  If COUNT is used, move past the open-close parentheses.
//
//***************************************************************************

int CWQLScanner::ExtractSelectType()
{
    // Verify that SELECT is the first token.
    // ======================================

    WSLexToken *pFront = ExtractNext();

    if (pFront == 0 || pFront->m_nToken == WQL_TOK_EOF)
    {
        delete pFront;
        return SYNTAX_ERROR;
    }

    if (pFront->m_nToken != WQL_TOK_SELECT)
    {
        delete pFront;
        return SYNTAX_ERROR;
    }

    delete pFront;

    // Check for possible select-type and extract it.
    // ==============================================

    pFront = ExtractNext();
    if (pFront == 0)
        return SYNTAX_ERROR;

    if (pFront->m_nToken == WQL_TOK_COUNT)
    {
        delete pFront;
        m_bCount = TRUE;
    }
    else if (pFront->m_nToken == WQL_TOK_ALL ||
        pFront->m_nToken == WQL_TOK_DISTINCT ||
        pFront->m_nToken == WQL_TOK_FIRSTROW
       )
        delete pFront;
    else
        Pushback(pFront);

    return SUCCESS;
}

//***************************************************************************
//
//  CWQLScanner::SelectList
//
//  Extracts all tokens up to the FROM keyword and builds a list
//  of selected properties/columns.  FROM is left on the parse-stack on exit.
//
//***************************************************************************

int CWQLScanner::SelectList()
{
    // If the first token is FROM, then we have a SELECT FROM <rest>
    // which is the same as SELECT * FROM <rest>.  We simply
    // alter the parse-stack and let the following loop handle it.
    // =============================================================

    WSLexToken *pTok = ExtractNext();

    if (pTok->m_nToken == WQL_TOK_FROM)
    {
        WSLexToken *pAsterisk = new WSLexToken;
        if (pAsterisk == NULL)
            return FAILED;

        pAsterisk->m_nToken = WQL_TOK_ASTERISK;
        pAsterisk->m_pszTokenText = Macro_CloneLPWSTR(L"*");
        if (!pAsterisk->m_pszTokenText)
            return FAILED;
        Pushback(pTok);
        Pushback(pAsterisk);
    }
    else
        Pushback(pTok);

    // Otherwise, some kind of column selection is present.
    // ====================================================

    BOOL bTerminate = FALSE;

    while (!bTerminate)
    {
        pTok = ExtractNext();
        if (pTok == 0)
            return SYNTAX_ERROR;

        // We must begin at a legal token.
        // ===============================

        if (pTok->m_nToken != WQL_TOK_EOF)
        {
            CTokenArray Tokens;
            Tokens.Add(pTok);

            while (1)
            {
                pTok = ExtractNext();
                if (pTok == 0 || pTok->m_nToken == WQL_TOK_EOF)
                {
                    delete pTok;
                    return SYNTAX_ERROR;
                }
                if (pTok->m_nToken == WQL_TOK_FROM)
                {
                    Pushback(pTok);
                    bTerminate = TRUE;
                    break;
                }
                else if (pTok->m_nToken == WQL_TOK_COMMA)
                {
                    delete pTok;
                    break;
                }
                else
                    Tokens.Add(pTok);
            }

            SWQLColRef *pColRef = new SWQLColRef;
            if (pColRef == 0)
                return FAILED;

            BOOL bRes = BuildSWQLColRef(Tokens, *pColRef);
            if (bRes)
                m_aPropRefs.Add(pColRef);
            else
            {
                delete pColRef;
                return SYNTAX_ERROR;
            }
        }

        // Else an illegal token, such as WQL_TOK_EOF.
        // ===========================================
        else
        {
            delete pTok;
            return SYNTAX_ERROR;

        }
    }

    return SUCCESS;
}



//***************************************************************************
//
//  CWQLScanner::ReduceSql89Joins
//
//  Attempts to reduce the FROM clause, assuming it is based on SQL-89
//  join syntax or else a simple unary select.
//
//  The supported forms are:
//
//      FROM x
//      FROM x, y
//      FROM x as x1, y as y1
//      FROM x x1, y y1
//
//  If incompatible tokens are encountered, the entire function
//  returns FALSE and the results are ignored, and the parse-stack
//  is unaffected, in essence, allowing backtracking to try the SQL-92
//  syntax branch instead.
//
//***************************************************************************
BOOL CWQLScanner::ReduceSql89Joins()
{
    int i = 0;

    // Parse the FROM keyword.
    // =======================

    WSLexToken *pCurr = (WSLexToken *) m_aTokens[i++];
    if (pCurr->m_nToken != WQL_TOK_FROM)
        return FALSE;

    pCurr = (WSLexToken *) m_aTokens[i++];

    while (1)
    {
        if (pCurr->m_nToken != WQL_TOK_IDENT)
            return FALSE;

        // If here, we are looking at the beginnings of a table ref.
        // =========================================================

        WSTableRef *pTRef = new WSTableRef;
        if (pTRef == 0)
            return FALSE;

        pTRef->m_pszTable = Macro_CloneLPWSTR(pCurr->m_pszTokenText);
        if (!pTRef->m_pszTable)
            return FALSE;
        pTRef->m_pszAlias = Macro_CloneLPWSTR(pCurr->m_pszTokenText);
        if (!pTRef->m_pszAlias)
            return FALSE;
        m_aTableRefs.Add(pTRef);

        // Attempt to recognize an alias.
        // ==============================

        pCurr = (WSLexToken *) m_aTokens[i++];
        if (pCurr == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken == WQL_TOK_AS)
            pCurr = (WSLexToken *) m_aTokens[i++];

        if (pCurr->m_nToken == WQL_TOK_COMMA)
        {
            pCurr = (WSLexToken *) m_aTokens[i++];
            continue;
        }

        if (pCurr->m_nToken == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken != WQL_TOK_IDENT)
            return FALSE;

        delete [] pTRef->m_pszAlias;
        pTRef->m_pszAlias = Macro_CloneLPWSTR(pCurr->m_pszTokenText);
        if (!pTRef->m_pszAlias)
            return FALSE;

        // We have completely parsed a table reference.
        // Now we move on to the next one.
        // ============================================

        pCurr = (WSLexToken *) m_aTokens[i++];

        if (pCurr->m_nToken == WQL_TOK_EOF || pCurr->m_nToken == WQL_TOK_UNION)
            break;

        if (pCurr->m_nToken != WQL_TOK_COMMA)
            return FALSE;

        pCurr = (WSLexToken *) m_aTokens[i++];
    }

    if (m_aTableRefs.Size())
        return TRUE;

    return FALSE;
}

//***************************************************************************
//
//  CWQLScanner::ReduceSql92Joins
//
//  This scans SQL-92 JOIN syntax looking for table aliases.   See the
//  algorithm at the end of this file.
//
//***************************************************************************

BOOL CWQLScanner::ReduceSql92Joins()
{
    WSLexToken *pCurrent = 0, *pRover = 0, *pRight = 0, *pLeft;
    int nNumTokens = m_aTokens.Size();
    DWORD dwNumJoins = 0;
    int iCurrBase = 0;

    for (int i = 0; i < nNumTokens; i++)
    {
        pCurrent = (WSLexToken *) m_aTokens[i];

        // If a JOIN token is found, we have a candidate.
        // ==============================================

        if (pCurrent->m_nToken == WQL_TOK_JOIN)
        {
            dwNumJoins++;

            // Analyze right-context.
            // ======================

            if (i + 1 < nNumTokens)
                pRover = PWSLexToken(m_aTokens[i + 1]);
            else
                pRover = NULL;

            if (pRover && pRover->m_nToken == WQL_TOK_IDENT)
            {
                // Check for aliased table by checking for
                // AS or two juxtaposed idents.
                // =======================================

                if (i + 2 < nNumTokens)
                    pRight = PWSLexToken(m_aTokens[i + 2]);
                else
                    pRight = NULL;


                if (pRight && pRight->m_nToken == WQL_TOK_AS)
                {
                    if (i + 3 < nNumTokens)
                        pRight = PWSLexToken(m_aTokens[i + 3]);
                    else
                        pRight = NULL;
                }

                if (pRight && pRight->m_nToken == WQL_TOK_IDENT)
                {
                    WSTableRef *pTRef = new WSTableRef;
                    if (pTRef == 0)
                        return FALSE;
                    pTRef->m_pszAlias = Macro_CloneLPWSTR(pRight->m_pszTokenText);
                    if (!pTRef->m_pszAlias)
                        return FALSE;
                    pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    if (!pTRef->m_pszTable)
                        return FALSE;
                    m_aTableRefs.Add(pTRef);
                }
                else    // An alias wasn't used, just a simple table ref.
                {
                    WSTableRef *pTRef = new WSTableRef;
                    if (pTRef == 0)
                        return FALSE;

                    pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    if (!pTRef->m_pszAlias)
                        return FALSE;
                    pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                    if (!pTRef->m_pszTable)
                        return FALSE;
                    m_aTableRefs.Add(pTRef);
                }
                // discontinue analysis of right-context.
            }


            // Analyze left-context.
            // =====================

            int nLeft = i - 1;

            if (nLeft >= 0)
                pRover = PWSLexToken(m_aTokens[nLeft--]);
            else
                continue;   // No point in continuing

            // Verify the ANSI join syntax.

            if (nLeft)
            {
                int iTemp = nLeft;
                WSLexToken *pTemp = pRover;
                bool bInner = false;
                bool bDir = false;
                bool bOuter = false;
                bool bFail = false;
                bool bIdent = false;
                while (iTemp >= iCurrBase)
                {
                    if (pTemp->m_nToken == WQL_TOK_INNER)
                    {
                        if (bOuter || bIdent || bInner)
                            bFail = TRUE;
                        bInner = true;
                    }
                    else if (pTemp->m_nToken == WQL_TOK_OUTER)
                    {
                        if (bInner || bIdent || bOuter)
                            bFail = TRUE;
                        bOuter = true;
                    }
                    else if (pTemp->m_nToken == WQL_TOK_FULL  ||
                        pTemp->m_nToken == WQL_TOK_LEFT  ||
                        pTemp->m_nToken == WQL_TOK_RIGHT
                        )
                    {
                        if (bDir || bIdent)
                            bFail = TRUE;
                        bDir = true;
                    }
                    else
                        bIdent = TRUE;

                    // We are trying to enforce correct ANSI-92 joins
                    // even though we don't support them ourselves:
                    // OK:  LEFT OUTER JOIN
                    //      OUTER LEFT JOIN
                    //      LEFT JOIN
                    //      INNER JOIN
                    // NOT: LEFT LEFT JOIN
                    //      LEFT INNER JOIN
                    //      LEFT RIGHT JOIN
                    //      OUTER INNER JOIN
                    //      OUTER LEFT OUTER JOIN
                    //      OUTER GARBAGE LEFT JOIN
                    //      (no right side)

                    if ((bDir && bInner) || bFail)
                        return FALSE;

                    pTemp = PWSLexToken(m_aTokens[iTemp--]);
                }

            }

            // Skip past potential JOIN modifiers : INNER, OUTER,
            // FULL, LEFT, RIGHT
            // ==================================================

            if (pRover->m_nToken == WQL_TOK_INNER ||
                pRover->m_nToken == WQL_TOK_OUTER ||
                pRover->m_nToken == WQL_TOK_FULL  ||
                pRover->m_nToken == WQL_TOK_LEFT  ||
                pRover->m_nToken == WQL_TOK_RIGHT
                )
            {
                if (nLeft >= 0)
                    pRover = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pRover = 0;
            }

            if (pRover->m_nToken == WQL_TOK_INNER ||
                pRover->m_nToken == WQL_TOK_OUTER ||
                pRover->m_nToken == WQL_TOK_FULL  ||
                pRover->m_nToken == WQL_TOK_LEFT  ||
                pRover->m_nToken == WQL_TOK_RIGHT
                )
            {
                if (nLeft >= 0)
                    pRover = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pRover = 0;
            }

            // Now we look to see if the roving pointer is pointing
            // to an ident.
            // ====================================================

            if (pRover && pRover->m_nToken != WQL_TOK_IDENT)
            {
                // No chance that we are looking at an aliased
                // table in a JOIN clause.
                // ===========================================
                continue;
            }

            iCurrBase = i;

            // If here, we are now possibliy looking at the second half
            // of an alias, the 'alias' name proper.  We mark this
            // by leaving pRover alone and continue to move into the
            // left context with a different pointer.
            // ========================================================

            if (nLeft >= 0)
                pLeft = PWSLexToken(m_aTokens[nLeft--]);
            else
                pLeft = 0;

            if (pLeft && pLeft->m_nToken == WQL_TOK_AS)
            {
                if (nLeft >= 0)
                    pLeft = PWSLexToken(m_aTokens[nLeft--]);
                else
                    pLeft = 0;
            }

            // The critical test.  Are we at an ident?
            // =======================================

            if (pLeft && pLeft->m_nToken == WQL_TOK_IDENT)
            {
                WSTableRef *pTRef = new WSTableRef;
                if (pTRef == 0)
                    return FALSE;

                pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                if (!pTRef->m_pszAlias)
                    return FALSE;
                pTRef->m_pszTable = Macro_CloneLPWSTR(pLeft->m_pszTokenText);
                if (!pTRef->m_pszTable)
                    return FALSE;
                m_aTableRefs.Add(pTRef);
            }
            else if (pLeft && pLeft->m_nToken == WQL_TOK_FROM)
            {
                WSTableRef *pTRef = new WSTableRef;
                if (pTRef == 0)
                    return FALSE;

                pTRef->m_pszAlias = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                if (!pTRef->m_pszAlias)
                    return FALSE;
                pTRef->m_pszTable = Macro_CloneLPWSTR(pRover->m_pszTokenText);
                if (!pTRef->m_pszTable)
                    return FALSE;
                m_aTableRefs.Add(pTRef);
                if (nLeft >= 0)
                {
                    pLeft = PWSLexToken(m_aTokens[nLeft--]);
                    if (pLeft && pLeft->m_nToken == WQL_TOK_FROM)
                        return FALSE;
                }
            }
        }

        // Find next JOIN occurrence
    }

    // Make sure there are two sides to every join reference.

    if (dwNumJoins+1 != (DWORD)m_aTableRefs.Size())
        return FALSE;

    return TRUE;
}


//***************************************************************************
//
//***************************************************************************
void CWQLScanner::Dump()
{
    WSLexToken *pCurrent = 0;

    printf("---Token Stream----\n");

    for (int i = 0; i < m_aTokens.Size(); i++)
    {
        pCurrent = (WSLexToken *) m_aTokens[i];

        printf("Token %d <%S>\n", pCurrent->m_nToken, pCurrent->m_pszTokenText);
    }

    printf("---Table Refs---\n");

    for (i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        printf("Table = %S  Alias = %S\n", pTRef->m_pszTable, pTRef->m_pszAlias);
    }


    if (!m_bCount)
    {
        printf("---Select List---\n");

        for (i = 0; i < m_aPropRefs.Size(); i++)
        {
            SWQLColRef *pCRef = (SWQLColRef *) m_aPropRefs[i];
            pCRef->DebugDump();
        }
    }
    else
        printf(" -> COUNT query\n");

    printf("\n\n---<end of dump>---\n\n");
}


/*---------------------------------------------------------------------------

   Algorithm for detecting aliased tables in SQL-92 join syntax.

   The JOIN keyword must appear.

   It may appear in several contexts which are not
   relevant to the aliasing problem, such as the following:

     select distinct t1a.name, t2a.id, t3.value from
       (t1 as t1a join t2 as t2a on t1a.name = t2a.name)
       join
       (t1 as t1b join t3 on t1b.id = t3.id and (t3.id = t1b.id or t1b.id = t3.id))
       on
       t1a.id = t3.id
     where a = b and c = d

   where the middle join is against anonymous result sets.

   When analyzing the JOIN, we can easily parse the right-context.  Either
   an identifier follows (possibly further followed by AS),and an optional
   identifier if the JOIN is aliased.  Otherwise, we hit ON immediately, or
   a parenthesis.

   The problem is the left-context of the JOIN token.

   For an alias to occur, an identifier must appear immediately to
   the left of the JOIN.

     id JOIN id2 as id3 ON ...
     ^

   If here, there is a chance we are looking at the left hand side of a
   SQL92 join, a table reference.  However, we might be looking at the end of
   an ON clause which ends in an identifier:

     idx = id JOIN id2 as id3 ON...
         ^
   To disambiguate, we have to do further analysis of left context.

   Consider the follow left-context possibilities:

        (1) t1 AS id JOIN id2 as id3 ON
               ^
        (2) t1 id JOIN id2 as id3 ON
            ^
        (3) <keyword (except AS)> id JOIN id2 as id3 ON
             ^
        (4) on x <rel op> id JOIN id2 as id3 ON
                  ^

   Once we have identified <id>, we have to consider the above cases.

   (1) Case 1 is easy.  An AS clearly tells us we have an alias
       and we know how to get at the table and alias names.

   (2) Case 2 is easy.  Two juxtaposed identifiers to the left always
       indicates an alias.

   In all other cases, like (3) and (4), etc., the table is not
   aliased anyway.  Therefore, we only have to determine whether we
   are looking at an unaliased table name or the trailing end of
   another construct like an ON clause.  This is easy.  Only the
   FROM keyword can precede <id> if <id> is a simple table name.

---------------------------------------------------------------------------
*/


//***************************************************************************
//
//  CWQLScanner::BuildSWQLColRef
//
//***************************************************************************

BOOL CWQLScanner::BuildSWQLColRef(
    IN  CFlexArray     &aTokens,
    IN OUT SWQLColRef  &ColRef      // Empty on entry
    )
{
    if (aTokens.Size() == 0)
        return FALSE;
    int nCurrent = 0;
    WSLexToken *pTok = PWSLexToken(aTokens[nCurrent++]);

    // Initial state: single asterisk or else prop name.
    // =================================================

    if (pTok->m_nToken == WQL_TOK_ASTERISK && aTokens.Size() == 1)
    {
        ColRef.m_pColName = Macro_CloneLPWSTR(L"*");
        if (!ColRef.m_pColName)
            return FALSE;
        ColRef.m_dwFlags = WQL_FLAG_ASTERISK;
        ColRef.m_pQName = new SWQLQualifiedName;
        if (ColRef.m_pQName == 0)
            return FALSE;
        SWQLQualifiedNameField *pField = new SWQLQualifiedNameField;
        if (pField == 0)
            return FALSE;

        pField->m_pName = Macro_CloneLPWSTR(L"*");
        if (!pField->m_pName)
            return FALSE;
        ColRef.m_pQName->Add(pField);
        return TRUE;
    }

    // If not an identifier, we have an error.
    // =======================================

    else if (pTok->m_nToken == WQL_TOK_EOF)
        return FALSE;

    // If here, we have an identifier.
    // ===============================

    ColRef.m_pQName = new SWQLQualifiedName;
    if (ColRef.m_pQName == NULL)
        return FALSE;
    SWQLQualifiedNameField *pField = new SWQLQualifiedNameField;
    if (pField == 0)
        return FALSE;

    pField->m_pName = Macro_CloneLPWSTR(pTok->m_pszTokenText);
    if (!pField->m_pName)
        return FALSE;
    ColRef.m_pQName->Add(pField);

    // Subsequent states.
    // ==================

    while (1)
    {
        if (nCurrent == aTokens.Size())
            break;

        pTok = PWSLexToken(aTokens[nCurrent++]);

        if (pTok->m_nToken == WQL_TOK_DOT)
        {
            pField = new SWQLQualifiedNameField;
            if (pField == 0)
                return FALSE;

            ColRef.m_pQName->Add(pField);

            if (nCurrent == aTokens.Size())
                return FALSE;
            pTok = PWSLexToken(aTokens[nCurrent++]);
            if (pTok->m_nToken != WQL_TOK_IDENT &&
                pTok->m_nToken != WQL_TOK_ASTERISK
                )
                return FALSE;

            pField->m_pName = Macro_CloneLPWSTR(pTok->m_pszTokenText);
            if (!pField->m_pName)
                return FALSE;
        }
        else if (pTok->m_nToken == WQL_TOK_OPEN_BRACKET)
        {
            return FALSE; // Not supported at present!
        }
        else // illegal token
            return FALSE;
    }

    // Post-process.  If the name is not complex, then we
    // can fill out fields of ColRef.
    // ==================================================
    if (ColRef.m_pQName->GetNumNames() == 2)
    {
        ColRef.m_pTableRef = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(0));
        if (!ColRef.m_pTableRef)
            return FALSE;
        ColRef.m_pColName  = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(1));
        if (!ColRef.m_pColName)
            return FALSE;
        if (wbem_wcsicmp(ColRef.m_pColName, L"NULL") == 0)
            ColRef.m_dwFlags |= WQL_FLAG_NULL;
    }
    else if (ColRef.m_pQName->GetNumNames() == 1)
    {
        LPWSTR pName = ColRef.m_pQName->GetName(0);
        ColRef.m_pColName  = Macro_CloneLPWSTR(pName);
        if (!ColRef.m_pColName)
            return FALSE;
        if (wbem_wcsicmp(ColRef.m_pColName, L"NULL") == 0)
            ColRef.m_dwFlags |= WQL_FLAG_NULL;
    }
    else
    {
        ColRef.m_pTableRef = Macro_CloneLPWSTR(ColRef.m_pQName->GetName(0));
        if (!ColRef.m_pTableRef)
            return FALSE;
        ColRef.m_dwFlags = WQL_FLAG_COMPLEX_NAME;
    }

    return TRUE;
}




const LPWSTR CWQLScanner::AliasToTable(LPWSTR pszAlias)
{
    if (pszAlias == 0)
        return 0;

    for (int i = 0; i < m_aTableRefs.Size(); i++)
    {
        WSTableRef *pTRef = (WSTableRef *) m_aTableRefs[i];
        if (wbem_wcsicmp(pszAlias, pTRef->m_pszAlias) == 0)
            return pTRef->m_pszTable;

        if (wbem_wcsicmp(pszAlias, pTRef->m_pszTable) == 0)
            return pTRef->m_pszTable;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\policman\mof\makefile.inc ===
$(O)\PolicMan.mof: PolicMan.mof
    copy copyright.mof+PolicMan.mof+PolicMan.mfl $(O)\PolicMan.mof
$(O)\PolicMan.mfl: PolicMan.mfl
    copy copyright.mof+PolicMan.mfl $(O)\PolicMan.mfl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\policman\utility.h ===
#ifndef __WBEM_UTILITY__H_
#define __WBEM_UTILITY__H_

#include "iads.h"
#undef _ASSERT
#include <wbemcli.h>
#include <wbemprov.h>
#include <wbemcomn.h>
#include <atlbase.h>
#include <activeds.h>
#include <WinNTSec.h>

// **** default min, max and default 

#define SINT_MIN 0xffffffff
#define SINT_MAX 0xefffffff
#define SINT_DEFAULT 0x0

#define UINT_MIN 0x0
#define UINT_MAX 0xffffffff
#define UINT_DEFAULT 0x0

#define REAL_MIN (double)(0xffffffffffffffff)
#define REAL_MAX (double)(0xefffffffffffffff)
#define REAL_DEFAULT 0x0

// retrieve namespace with given name
HRESULT GetNamespace(BSTR namespaceName, IWbemServices*& pNamespace, bool bInProc);

// make sure that the ID property of pObj has a value
// will generate GUID if not
// assumes property is a BSTR!
// if pName == NULL, assumes property name is "ID"
// returns WBEM_S_NO_ERROR if ID generated
//         WBEM_S_FALSE if no ID generated (already has a value)
//         WBEM_E_NOT_FOUND if ID property is not
//         some error if error of some sort
HRESULT EnsureID(IWbemClassObject* pObj, WCHAR* pName);

// init ADS_ATTR_INFO structure
void Init_AdsAttrInfo(ADS_ATTR_INFO *pAdsAttrInfo,
                        LPWSTR bstrName,
                        DWORD control,
                        ADSTYPE type,
                        PADSVALUE pVals,
                        DWORD nVals);

template <class ElementType, VARTYPE vt> class SafeArray
{
private:

  long
    m_IndexMin, 
    m_IndexMax, 
    m_Size;

  ElementType
    *m_pElementType;

  SAFEARRAY
    *m_pSafeArray;

  void _EmptyInit(void)
  {
    m_IndexMin = -1;
    m_IndexMax = -1;
    m_Size = 0;
    m_pElementType = NULL;
    m_pSafeArray = NULL;
  }

  void _ArrayInit(void)
  {
    HRESULT hres;

    hres = SafeArrayGetUBound(m_pSafeArray, 1, &m_IndexMax);
    if(FAILED(hres))
      return;

    hres = SafeArrayGetLBound(m_pSafeArray, 1, &m_IndexMin);
    if(FAILED(hres))
      return;

    m_Size = m_IndexMax - m_IndexMin + 1;

    m_pElementType = NULL;
    hres = SafeArrayAccessData(m_pSafeArray, (void **)&m_pElementType);
    if(FAILED(hres))
      return;
  }

public:

  SafeArray(void)
  {
    _EmptyInit();
  }

  // **** empty array creation

  SafeArray(long LowerBound, long ArgSize)
  {
    HRESULT hres;

    SAFEARRAYBOUND
      arrayBounds[1];

    // **** check for valid size

    if(LowerBound < 0)
      return;

    if(ArgSize < 0)
      return;

    // **** create empty array

    if(0 == ArgSize)
    {
      _EmptyInit();
    }
    else
    {
      arrayBounds[0].lLbound = LowerBound;
      arrayBounds[0].cElements = ArgSize;

      m_pSafeArray = SafeArrayCreate(vt, 1, arrayBounds);
      if(NULL == m_pSafeArray)
        return;

      _ArrayInit();
    }
  }

  // **** creation/init SafeArray from VARIANT

  SafeArray(VARIANT *v)
  {
    HRESULT hres;

    // **** first ensure that the contained object is valid

    if(NULL == v)
      return;

    if((V_VT(v) == VT_NULL) || (V_VT(v) == VT_EMPTY))
    {
      _EmptyInit();
    }
    else
    {
      if(V_VT(v) != (VT_ARRAY | vt))
        return;

      // **** copy to SafeArray contents of variant

      m_pSafeArray = NULL;
      hres = SafeArrayCopy(V_ARRAY(v), &m_pSafeArray);
      if(FAILED(hres))
        return;

      _ArrayInit();
    }
  }

  SafeArray &operator =(const VARIANT *Source)
  {
    HRESULT hres;

    // **** first ensure that the contained object is valid

    if((NULL == Source) || (V_VT(Source) != (VT_ARRAY | vt)))
      return *this;

    // **** get SAFEARRAY dimensions

    if(NULL != m_pSafeArray)
    {
      hres = SafeArrayUnaccessData(m_pSafeArray);
      hres = SafeArrayDestroy(m_pSafeArray);
    }

    hres = SafeArrayCopy(V_ARRAY(Source), &m_pSafeArray);
    if(FAILED(hres))
    {
      _EmptyInit();
      return *this;
    }

    _ArrayInit();

    return *this;
  }

  // **** creation/init SafeArray from SafeArray

  SafeArray(const SafeArray &Source)
  {
    HRESULT hres;

    if(NULL == Source.m_pSafeArray)
    {
      _EmptyInit();
    }
    else
    {
      // **** copy to SafeArray contents of variant

      m_pSafeArray = NULL;
      hres = SafeArrayCopy(Source.m_pSafeArray, &m_pSafeArray);
      if(FAILED(hres))
        return;

      _ArrayInit();
    }
  }

  SafeArray &operator = (const SafeArray &Source)
  {
    HRESULT hres;

    if(NULL == Source.m_pSafeArray)
    {
      _EmptyInit();
    }
    else
    {
      if(NULL != m_pSafeArray)
      {
        hres = SafeArrayUnaccessData(m_pSafeArray);
      }

      // **** copy to SafeArray contents of variant

      hres = SafeArrayCopy(Source.m_pSafeArray, &m_pSafeArray);
      if(FAILED(hres))
        return;

      _ArrayInit();
    }

    return *this;
  }

  ~SafeArray(void)
  {
    if(NULL != m_pSafeArray)
    {
      SafeArrayUnaccessData(m_pSafeArray);
      SafeArrayDestroy(m_pSafeArray);
    }

    _EmptyInit();
  }

  // **** Misc functions

  VARTYPE Type(void) { return vt; }
  long Size(void) { return m_Size; }
  long IndexMin(void) { return m_IndexMin; }
  long IndexMax(void) { return m_IndexMax; }

  SAFEARRAY *Data(void)
  { 
    HRESULT hres;
    SAFEARRAY *pArrayCopy = NULL;

    if(NULL != m_pSafeArray)
    {
      hres = SafeArrayCopy(m_pSafeArray, &pArrayCopy);
      if(FAILED(hres))
        return NULL;
    }

    return pArrayCopy; 
  }

  long ReDim(long LowerBound, long ArgSize)
  {
    HRESULT hres;

    SAFEARRAYBOUND arrayBounds[1];

    // **** check to see that Index is within range

    if((LowerBound != m_IndexMin) || ((LowerBound + ArgSize - 1) != m_IndexMax))
    {
      m_IndexMin = LowerBound;

      if(ArgSize < 1)
      {
        if(NULL != m_pSafeArray)
        {
          SafeArrayUnaccessData(m_pSafeArray);
          SafeArrayDestroy(m_pSafeArray);
        }

        _EmptyInit();
      }
      else
      {
        m_IndexMax = LowerBound + ArgSize - 1;
        m_Size = m_IndexMax - m_IndexMin + 1;

        arrayBounds[0].lLbound = LowerBound;
        arrayBounds[0].cElements = m_Size;

        if(NULL == m_pSafeArray)
        {
          m_pSafeArray = SafeArrayCreate(vt, 1, arrayBounds);
        }
        else
        {
          hres = SafeArrayUnaccessData(m_pSafeArray);
          hres = SafeArrayRedim(m_pSafeArray, arrayBounds);
        }

        m_pElementType = NULL;
        hres = SafeArrayAccessData(m_pSafeArray, (void **)&m_pElementType);
      }
    }

    // **** return reference to Index element

    return m_Size;
  }

  ElementType& operator[](long Index)
  {
    // **** return reference to Index element

    return m_pElementType[Index];
  }
};

template<class T> struct ADsStruct
{
  T *m_pADsMem;

  ADsStruct(void)
  { m_pADsMem = NULL; }
  ~ADsStruct(void)
  { if(NULL != m_pADsMem)  FreeADsMem(m_pADsMem); }

  operator T*(void) const { return m_pADsMem; }
  T** operator&(void) { return &m_pADsMem; }

  bool operator==(T *x) { return m_pADsMem == x; }
  bool operator!=(T *x) { return m_pADsMem != x; }

  T* & operator->(void) { return m_pADsMem; }
  // T* operator+(unsigned long x) { return m_pADsMem + x; }

  ADsStruct<T>& operator=(ADsStruct<T> &x)
  { return; }

  ADsStruct<T>& operator=(T* x)
  { if(NULL != m_pADsMem) FreeADsMem(m_pADsMem); m_pADsMem = x; return *this; }
};

template<class T> struct AutoDelete
{
  T **m_pTheThingToDelete;

  AutoDelete(void)
  { m_pTheThingToDelete = NULL; }

  AutoDelete(T **x)
  { m_pTheThingToDelete = x; }

  ~AutoDelete(void)
  { if((NULL != m_pTheThingToDelete) && (NULL != *m_pTheThingToDelete)) delete *m_pTheThingToDelete;}
};

class ADsObjAutoDelete
{
  CComPtr<IADsDeleteOps>
    m_pDelObj;

public:

  HRESULT Attach(IDispatch *pDisp) 
  { return pDisp->QueryInterface(IID_IADsDeleteOps, (void**)&m_pDelObj); }

  void Detach(void) 
  { if(m_pDelObj != NULL) m_pDelObj = NULL; }

  ~ADsObjAutoDelete(void) 
  { if(m_pDelObj != NULL) m_pDelObj->DeleteObject(0); }
};

extern BSTR

  // **** misc names

  g_bstrEmptyString,
  g_bstrEmptyDate,

  // **** AD schema names

  g_bstrADAuthor,
  g_bstrADChangeDate,
  g_bstrADClassDefinition,
  g_bstrADCreationDate,
  g_bstrADDescription,
  g_bstrADIntDefault,
  g_bstrADInt8Default,
  g_bstrADID,
  g_bstrADIntMax,
  g_bstrADInt8Max,
  g_bstrADIntMin,
  g_bstrADInt8Min,
  g_bstrADIntValidValues,
  g_bstrADName,
  g_bstrADNormalizedClass,
  g_bstrADObjectClass,
  g_bstrADParam2,
  g_bstrADPolicyType,
  g_bstrADPropertyName,
  g_bstrADQuery,
  g_bstrADQueryLanguage,
  g_bstrADStringDefault,
  g_bstrADStringValidValues,
  g_bstrADSourceOrganization,
  g_bstrADTargetClass,
  g_bstrADTargetNameSpace,
  g_bstrADTargetObject,
  g_bstrADTargetPath,
  g_bstrADTargetType,

  // **** AD class names

  g_bstrADClassMergeablePolicy,
  g_bstrADClassRangeParam,
  g_bstrADClassRangeSint32,
  g_bstrADClassRangeUint32,
  g_bstrADClassRangeReal,
  g_bstrADClassParamUnknown,
  g_bstrADClassSetSint32,
  g_bstrADClassSetUint32,
  g_bstrADClassSetString,
  g_bstrADClassSimplePolicy,
  g_bstrADClassRule,
  g_bstrADClassSom,
  g_bstrADClassPolicyType,
  g_bstrADClassWMIGPO,

  // **** CIM schema names

  g_bstrAuthor,
  g_bstrChangeDate,
  g_bstrClassDefinition,
  g_bstrCreationDate,
  g_bstrDefault,
  g_bstrDescription;

extern BSTR
  g_bstrDsPath,
  g_bstrDomain,
  g_bstrID,
  g_bstrMax,
  g_bstrMin,
  g_bstrName,
  g_bstrPolicyType,
  g_bstrPropertyName,
  g_bstrQuery,
  g_bstrQueryLanguage,
  g_bstrRangeSettings,
  g_bstrRules,
  g_bstrSourceOrganization,
  g_bstrTargetClass,
  g_bstrTargetNameSpace,
  g_bstrTargetObject,
  g_bstrTargetPath,
  g_bstrTargetType,
  g_bstrValidValues,

  // **** CIM class names

  g_bstrClassMergeablePolicy,
  g_bstrClassRangeParam,
  g_bstrClassRangeSint32,
  g_bstrClassRangeUint32,
  g_bstrClassRangeReal,
  g_bstrClassSetSint32,
  g_bstrClassSetUint32,
  g_bstrClassSetString,
  g_bstrClassSimplePolicy,
  g_bstrClassRule,
  g_bstrClassSom,
  g_bstrClassSomFilterStatus,
  g_bstrClassPolicyType,
  g_bstrClassWMIGPO,

  // **** CIM standard names

  g_bstrMISCclassSchema,
  g_bstrMISCContainer,
  g_bstrMISCschemaNamingContext,
  g_bstrMISCdefaultNamingContext,
  g_bstrMISCWQL,
  g_bstrMISCQuery;

void InitGlobalNames(void);
void FreeGlobalNames(void);
HRESULT DomainNameFromDistName(CComBSTR &DomainName, CComBSTR &DistName);
HRESULT DistNameFromDomainName(CComBSTR &DomainName, CComBSTR &DistName);
HRESULT ADSIToWMIErrorCodes(HRESULT hresAD);
IsEmpty(VARIANT &);

typedef HRESULT (*functTyp)(IWbemClassObject * *,
                            IDirectoryObject*,
                            IWbemServices*);

class CPolicySOM;

HRESULT ExecuteWQLQuery(CPolicySOM *, 
                        wchar_t *wcsWQLStmt, 
                        IWbemObjectSink *pResponseHandler, 
                        IWbemServices *pWbemServices,
                        BSTR bstrADClassName,
                        functTyp pf_ADToCIM);

// **** PolicyTemplate

HRESULT Policy_CIMToAD(long, IWbemClassObject *, IDirectoryObject *pDestContainer);
HRESULT Policy_ADToCIM(IWbemClassObject **, IDirectoryObject *, IWbemServices *);
HRESULT Policy_Merge(SafeArray<IUnknown*, VT_UNKNOWN> &PolicyArray,
                     CComPtr<IWbemClassObject> &pMergedPolicy,
                     IWbemServices *pDestCIM);

// **** RangeSint32

HRESULT Range_Sint32_Verify(IWbemClassObject*);
HRESULT Range_Sint32_ADToCIM(IWbemClassObject * *, IDirectorySearch*, ADS_SEARCH_HANDLE, IWbemServices*);
HRESULT Range_Sint32_Merge(SafeArray<IUnknown *, VT_UNKNOWN> &, CComPtr<IWbemClassObject> &, int &);

// **** RangeUint32

HRESULT Range_Uint32_Verify(IWbemClassObject*);
HRESULT Range_Uint32_ADToCIM(IWbemClassObject * *, IDirectorySearch*, ADS_SEARCH_HANDLE, IWbemServices*);
HRESULT Range_Uint32_Merge(SafeArray<IUnknown *, VT_UNKNOWN> &, CComPtr<IWbemClassObject> &, int &);

// **** RangeReal

HRESULT Range_Real_Verify(IWbemClassObject*);
HRESULT Range_Real_ADToCIM(IWbemClassObject * *, IDirectorySearch*, ADS_SEARCH_HANDLE, IWbemServices*);
HRESULT Range_Real_Merge(SafeArray<IUnknown *, VT_UNKNOWN> &, CComPtr<IWbemClassObject> &, int &);

// **** SetSint32

HRESULT Set_Sint32_Verify(IWbemClassObject*);
HRESULT Set_Sint32_ADToCIM(IWbemClassObject * *, IDirectorySearch*, ADS_SEARCH_HANDLE, IWbemServices*);
HRESULT Set_Sint32_Merge(SafeArray<IUnknown *, VT_UNKNOWN> &, CComPtr<IWbemClassObject> &, int &);

// **** SetUint32

HRESULT Set_Uint32_Verify(IWbemClassObject*);
HRESULT Set_Uint32_ADToCIM(IWbemClassObject * *, IDirectorySearch*, ADS_SEARCH_HANDLE, IWbemServices*);
HRESULT Set_Uint32_Merge(SafeArray<IUnknown *, VT_UNKNOWN> &, CComPtr<IWbemClassObject> &, int &);

// **** SetString

HRESULT Set_String_Verify(IWbemClassObject*);
HRESULT Set_String_ADToCIM(IWbemClassObject * *, IDirectorySearch*, ADS_SEARCH_HANDLE, IWbemServices*);
HRESULT Set_String_Merge(SafeArray<IUnknown *, VT_UNKNOWN> &, CComPtr<IWbemClassObject> &, int &);

// **** ParamUnknown

HRESULT Param_Unknown_Verify(IWbemClassObject*);
HRESULT Param_Unknown_ADToCIM(IWbemClassObject * *, IDirectorySearch*, ADS_SEARCH_HANDLE*, IWbemServices*);

// **** SOM

HRESULT Som_CIMToAD(IWbemClassObject *pSrcPolicyObj, IDirectoryObject *pDestContainer, long lFlags);
HRESULT Som_ADToCIM(IWbemClassObject **, IDirectoryObject *pSrcPolicyObj, IWbemServices *pDestCIM);

// **** WMIGPO

HRESULT WMIGPO_CIMToAD(IWbemClassObject *pSrcPolicyObj, IDirectoryObject *pDestContainer, long lFlags);
HRESULT WMIGPO_ADToCIM(IWbemClassObject **, IDirectoryObject *pSrcPolicyObj, IWbemServices *pDestCIM);

// **** PolicyType

HRESULT PolicyType_CIMToAD(IWbemClassObject *pSrcPolicyObj, IDirectoryObject *pDestContainer);
HRESULT PolicyType_ADToCIM(IWbemClassObject**, IDirectoryObject *pSrcPolicyObj, IWbemServices *pDestCIM);

// **** Security Manipulation

HRESULT CreateDefaultSecurityDescriptor(CNtSecurityDescriptor& cSD);

HRESULT GetOwnerSecurityDescriptor(CNtSecurityDescriptor& SD);

PSECURITY_DESCRIPTOR GetADSecurityDescriptor(IDirectoryObject *pIDirectoryObject);

#endif __WBEM_UTILITY__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\policman\utility.cpp ===
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500

#include <wbemcli.h>
#include <wbemprov.h>
#include <atlbase.h>
#include <stdio.h>      // fprintf
#include <stdlib.h>
#include <locale.h>

#include <genlex.h>
#include <qllex.h>
#include <ql.h>
#include <ntdsapi.h>

#include "objpath.h"
#include "iads.h"
#include "adshlp.h"

#include "Utility.h"
#include "policsom.h"
#include <SDDL.H>


BSTR
  // **** misc names

  g_bstrEmptyString = NULL,
  g_bstrEmptyDate = NULL;

  // **** AD schema names

BSTR
  g_bstrADAuthor = NULL,
  g_bstrADChangeDate = NULL,
  g_bstrADClassDefinition = NULL,
  g_bstrADCreationDate = NULL,
  g_bstrADDescription = NULL,
  g_bstrADIntDefault = NULL,
  g_bstrADInt8Default = NULL,
  g_bstrADID = NULL,
  g_bstrADIntMax = NULL,
  g_bstrADInt8Max = NULL,
  g_bstrADIntMin = NULL,
  g_bstrADInt8Min = NULL,
  g_bstrADIntValidValues = NULL,
  g_bstrADName = NULL,
  g_bstrADNormalizedClass = NULL,
  g_bstrADObjectClass = NULL,
  g_bstrADParam2 = NULL,
  g_bstrADPolicyType = NULL,
  g_bstrADPropertyName = NULL,
  g_bstrADQuery = NULL,
  g_bstrADQueryLanguage = NULL,
  g_bstrADSourceOrganization = NULL,
  g_bstrADStringDefault = NULL,
  g_bstrADStringValidValues = NULL,
  g_bstrADTargetClass = NULL,
  g_bstrADTargetNameSpace = NULL,
  g_bstrADTargetObject = NULL,
  g_bstrADTargetPath = NULL,
  g_bstrADTargetType = NULL;

  // **** AD class names

BSTR
  g_bstrADClassMergeablePolicy = NULL,
  g_bstrADClassRangeParam = NULL,
  g_bstrADClassRangeSint32 = NULL,
  g_bstrADClassRangeUint32 = NULL,
  g_bstrADClassRangeReal = NULL,
  g_bstrADClassParamUnknown = NULL,
  g_bstrADClassSetSint32 = NULL,
  g_bstrADClassSetUint32 = NULL,
  g_bstrADClassSetString = NULL,
  g_bstrADClassSimplePolicy = NULL,
  g_bstrADClassRule = NULL,
  g_bstrADClassSom = NULL,
  g_bstrADClassPolicyType = NULL,
  g_bstrADClassWMIGPO = NULL;

  // **** CIM schema names

BSTR
  g_bstrAuthor = NULL,
  g_bstrChangeDate = NULL,
  g_bstrClassDefinition = NULL,
  g_bstrCreationDate = NULL,
  g_bstrDefault = NULL,
  g_bstrDescription = NULL,
  g_bstrDsPath = NULL,
  g_bstrDomain = NULL,
  g_bstrID = NULL,
  g_bstrMax = NULL,
  g_bstrMin = NULL,
  g_bstrName = NULL,
  g_bstrPolicyType = NULL,
  g_bstrPropertyName = NULL,
  g_bstrQuery = NULL,
  g_bstrQueryLanguage = NULL,
  g_bstrRangeSettings = NULL,
  g_bstrRules = NULL,
  g_bstrSourceOrganization = NULL,
  g_bstrTargetClass = NULL,
  g_bstrTargetNameSpace = NULL,
  g_bstrTargetObject = NULL,
  g_bstrTargetPath = NULL,
  g_bstrTargetType = NULL,
  g_bstrValidValues = NULL;

  // **** CIM class names

BSTR
  g_bstrClassMergeablePolicy = NULL,
  g_bstrClassRangeParam = NULL,
  g_bstrClassRangeSint32 = NULL,
  g_bstrClassRangeUint32 = NULL,
  g_bstrClassRangeReal = NULL,
  g_bstrClassSetSint32 = NULL,
  g_bstrClassSetUint32 = NULL,
  g_bstrClassSetString = NULL,
  g_bstrClassSimplePolicy = NULL,
  g_bstrClassRule = NULL,
  g_bstrClassSom = NULL,
  g_bstrClassSomFilterStatus = NULL,
  g_bstrClassPolicyType = NULL,
  g_bstrClassWMIGPO = NULL;

  // **** CIM standard names

BSTR
  g_bstrMISCclassSchema = NULL,
  g_bstrMISCContainer = NULL,
  g_bstrMISCdefaultNamingContext = NULL,
  g_bstrMISCschemaNamingContext = NULL,
  g_bstrMISCWQL = NULL,
  g_bstrMISCQuery = NULL;

void InitGlobalNames(void)
{
  // **** misc names

  g_bstrEmptyString =          SysAllocString(L" ");
  g_bstrEmptyDate =            SysAllocString(L"00000000000000.000000-000");

  // **** AD schema names

  g_bstrADAuthor =             SysAllocString(L"msWMI-Author");
  g_bstrADChangeDate =         SysAllocString(L"msWMI-ChangeDate");
  g_bstrADClassDefinition =    SysAllocString(L"msWMI-ClassDefinition"),
  g_bstrADCreationDate =       SysAllocString(L"msWMI-CreationDate");
  g_bstrADDescription =        SysAllocString(L"msWMI-Parm1");
  g_bstrADIntDefault =         SysAllocString(L"msWMI-IntDefault");
  g_bstrADInt8Default =        SysAllocString(L"msWMI-Int8Default");
  g_bstrADID =                 SysAllocString(L"msWMI-ID");
  g_bstrADIntMax =             SysAllocString(L"msWMI-IntMax");
  g_bstrADInt8Max =            SysAllocString(L"msWMI-Int8Max");
  g_bstrADIntMin =             SysAllocString(L"msWMI-IntMin");
  g_bstrADInt8Min =            SysAllocString(L"msWMI-Int8Min");
  g_bstrADIntValidValues =     SysAllocString(L"msWMI-IntValidValues");
  g_bstrADName =               SysAllocString(L"msWMI-Name");
  g_bstrADNormalizedClass =    SysAllocString(L"msWMI-NormalizedClass");
  g_bstrADObjectClass =        SysAllocString(L"objectClass");
  g_bstrADParam2 =             SysAllocString(L"msWMI-Parm2");
  g_bstrADPolicyType =         SysAllocString(L"msWMI-PolicyType");
  g_bstrADPropertyName =       SysAllocString(L"msWMI-PropertyName");
  g_bstrADQuery =              SysAllocString(L"msWMI-Query");
  g_bstrADQueryLanguage =      SysAllocString(L"msWMI-QueryLanguage");
  g_bstrADStringDefault =      SysAllocString(L"msWMI-StringDefault");
  g_bstrADStringValidValues =  SysAllocString(L"msWMI-StringValidValues");
  g_bstrADSourceOrganization = SysAllocString(L"msWMI-SourceOrganization");
  g_bstrADTargetClass =        SysAllocString(L"msWMI-TargetClass");
  g_bstrADTargetNameSpace =    SysAllocString(L"msWMI-TargetNameSpace");
  g_bstrADTargetObject =       SysAllocString(L"msWMI-TargetObject");
  g_bstrADTargetPath =         SysAllocString(L"msWMI-TargetPath");
  g_bstrADTargetType =         SysAllocString(L"msWMI-TargetType");

  // **** AD class names

  g_bstrADClassMergeablePolicy = SysAllocString(L"msWMI-MergeablePolicyTemplate");
  g_bstrADClassRangeParam =      SysAllocString(L"msWMI-RangeParam");
  g_bstrADClassRangeSint32 =     SysAllocString(L"msWMI-IntRangeParam");
  g_bstrADClassRangeUint32 =     SysAllocString(L"msWMI-UintRangeParam");
  g_bstrADClassRangeReal =       SysAllocString(L"msWMI-RealRangeParam");
  g_bstrADClassParamUnknown =    SysAllocString(L"msWMI-UnknownRangeParam");
  g_bstrADClassSetSint32 =       SysAllocString(L"msWMI-IntSetParam");
  g_bstrADClassSetUint32 =       SysAllocString(L"msWMI-UintSetParam");
  g_bstrADClassSetString =       SysAllocString(L"msWMI-StringSetParam");
  g_bstrADClassSimplePolicy =    SysAllocString(L"msWMI-SimplePolicyTemplate");
  g_bstrADClassRule =            SysAllocString(L"msWMI-Rule");
  g