	edi,[ebx].MG_Target
	mov	[eax].MBSRC_GSEL,esi
	mov	[eax].MBTAR_GSEL,edi

	mov	esi,[ebx].MG_Source[4]
	mov	edi,[ebx].MG_Target[4]
	mov	[eax].MBSRC_GSEL[4],esi
	mov	[eax].MBTAR_GSEL[4],edi

	mov	ax,MBSRC_GSEL
	verr	ax		;Q: source selector valid ?
	jnz	MBExcpError	; N: return exception error

	mov	ax,MBTAR_GSEL
	verw	ax		;Q: target selector valid ?
	jnz	MBExcpError	; N: return exception error
;
;  Load 32bit pointers into ESI and EDI
;
	rol	esi,8			; bits 24.31 and 16.23 in DI
	rol	si,8			; swap bytes
	shl	esi,16			; high word
	mov	si,word ptr [ebx].MG_Source[2]	; low word

	rol	edi,8			; bits 24.31 and 16.23 in DI
	rol	di,8			; swap bytes
	shl	edi,16			; high word
	mov	di,word ptr [ebx].MG_Target[2]	; low word
;
;  Check for read or write from/to diag byte location (not both)
;
	test	[bp].MBFlags,fMBDiagSrc+fMBDiagTrg	;Q: Diag on 386s?
	jnz	MBDiag  				; Y: use 386s port
;
;  Check for read/write to/from HMA
;
	btr	[bp].MBFlags,fMBHMABit	;Q: Using HMA?
	jnc	short MBwriteProt	; N: let it procede

	assume	ds:R_CODE
	test	[edx][Current_State],fState_A20Ena;Q: Is A20 enabled
	jnz	short MBWeitek			  ; Y: check WEITEK map
	or	[bp].MBFlags,fMBA20		  ; N: restore A20

MBWeitek:
	test	[edx][Weitek_State],fWeitek_Map	;Q: WEITEK mapped?
	jz	short MBUpdate			; N: need to update
	or	[bp].MBFlags,fMBWeitek		; Y: restore Weitek

MBUpdate:
	test	[bp].MBFlags,fMBA20+fMBWeitek	;Q: Need to update HMA?
	jz	short MBwriteProt		; N: let it procede
;
;  Either a disabled A20 or a mapped Weitek is in effect. Access HMA
;
	or	[edx][Current_State],fState_A20Ena  ; enable A20
	and	[edx][Weitek_State],not fWeitek_Map ; unmap Weitek
	or	[bp].MBFlags,fMBHMA		    ; remember to restore HMA
	call	UpdateHMA			    ; fix up HMA
;
;  Make sure nothing is written into a write protected page
;
MBwriteProt:
	shl	ecx,1
	call	CheckPageProt
 	shr	ecx,1			; M014: restore cx. cx has size of
					; M014: Xfer in words.
	jcxz	short MBexit

;
;  Finally, do the move block! (dwords)
;
MBOddMove:
	test	cx,01h			;Q: move an odd # of words?
	jz	short MBMoveD		;  N: move dwords
MBMoveW:
	MOVS_WORD_USING_DS_ESI		;  Y: move the first one => dwords now
MBMoveD:
	shr	cx,1			; move CX dwords...
	REP_MOVS_DWORD_USING_DS_ESI
MBrepMovD:
MBExit:
	test	[bp].MBFlags,fMBHMA	;Q: Fix HMA
	jz	short MBLeave		; N: let it procede

	test	[bp].MBFlags,fMBA20		      ;Q: Is A20 disabled?
	jz	short MBWeitekX			      ; N: check WEITEK map
	and	[edx][Current_State],not fState_A20Ena;Y: disable A20

MBWeitekX:
	test	[bp].MBFlags,fMBWeitek		;Q: Is Weitek mapped?
	jz	short MBUpdateX			; N: update
	or	[edx][Weitek_State],fWeitek_Map	; Y: map WEITEK

MBUpdateX:
	call	UpdateHMA			; fix up HMA

MBLeave:
	pop	edi
	pop	esi
	pop	ecx
	pop	ebx
	pop	eax
	mov	ah,[bp].MBStat
;
;  Set return flags
;
	or	[bp][MBData][VTFO].VMTF_EFLAGS,FLAGS_ZF
	and	[bp][MBData][VTFO].VMTF_EFLAGS,not FLAGS_CF

	or	ah,ah		;Q: error occured ?
	jz	short MBRet	;  N: continue
				;  Y: set error in client's flags
	and	[bp][MBData][VTFO].VMTF_EFLAGS,not FLAGS_ZF
	or	[bp][MBData][VTFO].VMTF_EFLAGS,FLAGS_CF

MBRet:
	ret

MBExcpError:
	mov	[bp].MBStat,2
	jmp	short MBExit

;===============================================================================
;==
;==  On 386s, a read/write from diag port is rerouted from memory to IO map.
;==	memory map: 80C00000h --> IO map: port 878h
;==
;==  Enter:  DS:ESI = Source buffer
;==	     ES:EDI = Target buffer
;==	     DS:EDX = R_CODE
;==
;===============================================================================
MBDiag:
	push	bx
	push	dx
	pushf

	cli				; no interrupts
	shl	cx,1			; byte count
	mov	dx,PORT386s		; 386s I/O port
;
; assume diag is target
;
	mov	bx,di
	test	[bp].MBFlags,fMBDiagSrc	;Q: Is diag the source?
	jz	short MBDdesc		; N: assumption correct
	mov	bx,si			; Y: source work descriptor in GDT

MBDdesc:
	add	dx,bx
	call	DisableNMI		; disable NMI

	test	[bp].MBFlags,fMBDiagTrg	;Q: Is diag the target?
	jnz	short MBWriteDiag	; Y: write to proper ports

MBReadDiag:
	cmp	dx,PORT386s+7 		;Q: 80C00000-80C00007h?
	ja	short MBDexit		; N: port is invalid
	db 67h				; ** USE ES:EDI **
	insb				; Y: read next I/O port value
	inc	dx			; next port
	loop	MBReadDiag
	jmp	short MBDexit

MBWriteDiag:
	cmp	dx,PORT386s+3 		;Q: 80C00000-80C00003h?
	ja	short MBDexit		; N: port is invalid
	db 67h				; ** USE DS:ESI **
	outsb				; Y: read next I/O port value
	inc	dx			; next port
	loop	MBWriteDiag

MBDexit:
	call	EnableNMI

	popf				; restore interrupts
	pop	dx
	pop	bx
	jmp	MBExit

MoveBlock	endp

;===============================================================================
;==
;==  DiagsOn386SX : Check if trying to access diagnostic register on a COMPAQ
;==		    386SX machine.
;==
;==  ENTER: DS:ESI = GDT selector
;==	    DS:EDX = R_CODE
;==
;==  EXIT: NC = no conflict
;==        CY = conflict
;==
;===============================================================================
DiagsOn386SX	proc	near
	assume	ds:R_CODE

	test	[edx][GenFlags],f386SX ;Q: is it a COMPAQ 386SX base machine?
	jz	short DO386SXno	       ; N: continue

	cmp	byte ptr [esi][7],080h ;Q: Is it diag address port (80C00000h)
	jne	short DO386SXno	       ; N: continue

	cmp	byte ptr [esi][4],0C0h ;Q: Is it diag address port (80C00000h)
	jne	short DO386SXno	       ; N: continue

	stc
	ret

DO386SXno:
	clc
	ret
DiagsOn386SX	endp

;===============================================================================
;==
;==  HMARegion : Check if trying to access the HMA region
;==
;==  ENTER: DS:ESI = GDT selector
;==
;==  EXIT: NC = not in HMA region
;==        CY = in HMA region
;==
;===============================================================================
HMARegion proc	near

	cmp	byte ptr [esi][4],11h ;Q: Is it above HMA (>110000h)
	jae	short HMARnoHMA	      ; Y: continue

	cmp	byte ptr [esi][4],0Fh ;Q: Is it below HMA (<100000h)
	jbe	short HMARnoHMA	      ; Y: continue

	cmp	byte ptr [esi][7],0   ;Q: Is it HMA (100000h-110000h)
	jne	short HMARnoHMA	      ; Y: continue

	stc
	ret

HMARnoHMA:
	clc
	ret
HMARegion	endp

;===============================================================================
;==
;==  DisableNMI : Disables NMI interrupt via external HW registers/gates.
;==
;===============================================================================
DisableNMI proc	near
	push	ax

	in	al,NMI386s
	mov	[bp].MBStat,al		; save status for NMI port
	or	al,08h			; disable IOCHK and NMI
	out	NMI386s,al

	pop	ax
	ret
DisableNMI	endp

;===============================================================================
;==
;==  EnableNMI : Enables NMI interrupt via external HW registers/gates.
;==
;===============================================================================
EnableNMI proc	near
	push	ax

	xor	ax,ax
	xchg	al,[bp].MBStat		; get NMI status and clear status
	out	NMI386s,al		; restore IOCHK and NMI

	pop	ax
	ret
EnableNMI	endp

;===============================================================================
;==
;==  MoveBlockParity: Parity error handler during MoveBlock routine.
;==                   This routine writes to the parity error location to
;==                   clear the parity error on the memory board, then it
;==		      clears the parity error on the system board.
;==
;==  Entry: (Protectyed Mode)
;==	ESI = pointing to word/dword after the location which caused the error
;==	DS = DATA32_GSEL
;==	ES = DATA32_GSEL
;==
;===============================================================================
MoveBlockParity:
	pop	ebp

	dec	si
	dec	si		; DS:SI pts to address causing parity error

	mov	ax,[esi] 	; retrieve value and write it back
	mov	[esi],ax 	; to reset parity on memory board.

	in	al,PPI		; get parity error flags, reset then set
	xchg	ah,al
	in	al,80h		; delay with dummy IN
	xchg	al,ah
;
;  Dissable IOCHECK & PCHECK
;
	or	al,PPO_MASK_IOCHECK+PPO_MASK_PCHECK
	out	PPO,al		; disable them
	xchg	ah,al
	in	al,80h		; delay with dummy IN
	xchg	al,ah
;
;   Enable IOCHECK & PCHECK
;
	and	al,NOT (PPO_MASK_IOCHECK+PPO_MASK_PCHECK)
	out	PPO,al		; enable them: system board parity now reset

	mov	[bp].MBStat,1	; set parity error
	add	sp,12		; remove NMI stuff from stack
	jmp	MBExit	 	; and exit move block

;===============================================================================
;==
;==  InUMBs: checks to see if 32 bit address in ebx is in UMBs or not
;==
;==  Entry: (Protectyed Mode)
;==	DS = DATA32_GSEL
;==	EDX = 32bit pointer to R_CODE
;==
;===============================================================================

InUMBs 	proc	near

	push	edi
	push	esi
	push	eax
	push	ecx

	cmp	[edx][UMBptr],0		;Q: UMB ARENAs on the system?
	je	IUexit			; N: exit


	movzx	edi,[edx][UMBptr]
	shl	edi,4				; offset to first ARENA
	mov	eax,edi				;
IUloop:
	cmp	[edi].Sig,'M'			;Q: Is it an ARENA?
	je	short IUcont			; Y: OK
	cmp	[edi].Sig,'Z'			;Q: Is it an ARENA?
	jne	short IUexit			; N: exit, corruption
;
;  Valid ARENA: Get starting paragraph and length
;
IUcont:
	add	eax, 010h			; add size of arena
	movzx	ecx,[edi].Len			; get length in paras
	shl	ecx, 4				; length in bytes

	mov	esi, eax			; eax = start of block
	add	esi, ecx			; esi -> next arena

	cmp	[edi].Own,InvMem		;Q: Is it a UMB?
	je	short IUnext			; N: get next ARENA

	cmp	ebx, eax			; Q: is ebx below start
	jb	IUexit				; Y: done

	cmp	ebx, esi			; Q: is ebx below end of block
	jb	IUdone				; Y: CY SET. exit

IUnext:
	mov	eax,esi				; eax = next ARENA
	cmp	[edi].Sig,'Z'			;Q: Is it end of ARENA chain?
	je	short IUexit			; Y: exit

	mov	edi,eax
	jmp	short IUloop

IUexit:
	clc
IUdone:
	pop	ecx
	pop	eax
	pop	esi
	pop	edi
	ret
InUMBs	endp

_TEXT	ends

;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
R_CODE	segment
	assume	cs:R_CODE, ds:_DATA, es:_DATA
;==============================================================================
;==
;==  rINT15hHandler: Traps CTRL-ALT-DEL and returns system to real mode.
;==		     Reports free extedned memory.
;==		     If move block, sets a trap flag so CEMM handles it in
;==	             the protected mode Int 15h handler.
;==
;==
;==  Entry: (Real/Virtual Mode)
;==
;==  Exit:  (Real/Virtual Mode)
;==
;==============================================================================
.8086 ; **NOTE** Some programs (i.e. PC-ANYWHERE) emulate 8086 instructions
      ; and will break if 386 instructions are inserted in this code.*910408*
rINT15hHandler	proc	far
	cli				; in case of pushf/call far
	pushf				; save entry flags
;
;  Move Block
;
	cmp	ah,87h			;Q: Move block?
	je	short rI15MoveBlock	; Y: emulate move block
;
;  Extended Memory Size
;
	cmp	ah,88h			;Q: extended memory size ?
	je	short rI15MemSize	; Y: return memory size
;
;  System Configuration Parameters: Needed due to a Win 3.0 EBIOS bug!!!!
;
	cmp	ah,0C0h			;Q: Configuration sense?
	je	short rI15Config	; Y: check if it's Win 3.0

; Ctrl+Alt+Del keyboard intercept?

	.erre	fTurnOff AND 0FF00h			 ;Q: Ctrl+Alt+Del kbd
	test	byte ptr cs:[genflags+1], fTurnOff SHR 8 ;   intercept?
	jnz	short rI15CAD		; Y: check if shut down now or later

rI15oldHandler:
	popf				; retrieve entry flags
	jmp	cs:[PrevInt15]		; chain to previous handler

rI15CAD:
	.erre	fTurnOff AND 0FF00h				; clr flag for
	and	byte ptr cs:[genflags+1], NOT (fTurnOff SHR 8)	;   next time

	.erre	fTurnOffNOW AND 0FF00h			    ;Q: shutdown b4
	test	byte ptr cs:[genflags+1], fTurnOffNOW SHR 8 ;  chaining on?
	jz	short rI15oldHandler

	call	ShutDown		; Y: turn off, about to reboot

	jmp	short rI15oldHandler	; chain to previous interrrupt

;==============================================================================
;==  Emulate Move Block
;==============================================================================
rI15MoveBlock:
	test	cs:[Current_State],fState_Active;Q: In Virtual mode ?
	jz	short rI15oldHandler		; N: jmp to old handler

	or	cs:[TrapFlags],fI15trap		; Y: trap flag

	popf				; retrieve entry flags
	int	15h			; emulate move block

	push	bp			; save bp
	mov	bp,sp

	push	ax			; save ax
	pushf
	pop	ax			; return flags

	xchg	ax,[bp].INT_FLAGS	; entry flag in AX, return flags on stack

	and	ax,FLAGS_IF		; restore entry IF
	or	[bp].INT_FLAGS,ax

	pop	ax
	pop	bp
	iret

;==============================================================================
;==  Extended memory size
;==============================================================================
rI15MemSize:
	popf				; restore flags

	push	bp			; save bp
	mov	bp,sp

	push	ds

;910408	push	seg R_CODE		; access R_CODE
;910408	pop	ds
	mov	ax,seg R_CODE		; access R_CODE
	mov	ds,ax
	assume	ds:R_CODE

	mov	ax,[ext_rem]		; return remaining extended memory
	and	[bp].INT_FLAGS,NOT FLAGS_CF ; return no carry

	pop	ds
	assume	ds:_DATA
	pop	bp
	iret
;==============================================================================
;==  System Configuration Parameter: Due to Win 3.0 bug
;==
;==  Win 3.0 EBIOS VxD is unable to cope with the XBDA relocated below
;==  itself.  The problem is that the Win 3.0 EBIOS will declare the 4K page in
;==  which the XBDA resides as PRIVATE, thus preventing instance data within the
;==  page.  Unfortuantely, DOS loads FILES and BUFFERS in memory after the last
;==  installable device driver.  If the last installable device driver is CEMM,
;==  the EBIOS driver will prevent Windows from instancing the FILES and BUFFERS
;==  data.  This handler fixes the problem by telling the Win 3.0 EBIOS VxD that
;==  no XBDA exists if it has relocated it to low memory.  Since low memory is
;==  global, by default, the XBDA is treated correctly by Win 3.0.
;==
;==============================================================================
.386p
rI15Config:
	test	cs:[GenFlags],fWin30	;Q: Win 3.0 broadcast occurred?
	jz	short rI15oldHandler	; N: jmp to old handler

	test	cs:[GenFlags],fXBDAnotRel	;Q: XBDA not relocated?
	jnz	short rI15oldHandler		; Y: jmp to old handler

	call	cs:[PrevInt15]		; chain to previous handler
	pushf
	push	eax
	push	si
	cmp	es:[bx].SDVcount,8	;Q: Is SysDescVec larger than buffer size
	ja	short rI15Cexit		; Y: don't mess with it
	lea	si,[SysDescVec]		; N: copy to local buffer
;
;  Copy System Descrition Vector
;
	mov	eax,es:[bx]
	mov	cs:[si],eax
	mov	eax,es:[bx][4]
	mov	cs:[si][4],eax
	mov	ax,es:[bx][8]
	mov	cs:[si][8],ax
;
;  Change ES:BX and reset XBDA flag
;
	mov	bx,si
	mov	si,cs
	mov	es,si
	and	es:[bx].SDVInfoFlgs,not SDVInfoXBDA

rI15Cexit:
	pop	si
	pop	eax
	popf
	retf	2

rINT15hHandler	endp
.386p
;==============================================================================
;==
;==  rINT19hHandler: Return to real mode and clear int 67 vector.
;==
;==
;==  Entry: (Real/Virtual Mode)
;==
;==  Exit:  (Real/Virtual Mode)
;==
;==============================================================================
rINT19hHandler	proc	far

	cli

	test	cs:[Current_State],fState_Active ;Q: in virtual mode?
	jz	short rI19OldHandler		 ; N: chain to previous handler

	and	cs:[Current_State], not fState_Active
					; clear our flag so that we pass on
					; in our int 13 hook. Note that we
					; we are always behind smartdrive's
					; int 13 hook.
	call	ShutDown

ifdef 901004

	or	cs:[Current_State],fState_WinCntrl
					; we shall set this flag so that set
					; and get a20cnt routines in util.asm
					; do not do xms calls. We do not care
					; about resetting this bit as we are
					; going to reboot any way.

	push	ax			; virtual to real mode
	mov	al,0Fh
	out	84h,al			; port 84/85 return to real sequence
	mov	al,00h
	out	85h,al
	jmp	$+2			; clear prefetch/avoid race cond
	pop	ax
endif
rI19oldHandler:
	xor	eax,eax
	mov	es, ax
	assume	es:ABS0			; clear int 67h vector
	mov	dword ptr es:[int67], eax

	jmp	cs:[PrevInt19]		; chain to previous handler

rINT19hHandler	endp

;==============================================================================
;
;	Control is obtained here if a ctrl-alt-del or a ctrl-alt-ins (on a
;	Zenith is detected). See the protected mode int 15 handler for more
;	details. At this point the int 15 ah=4f call has been processed and
;	the stack is right for us to return to the caller. 
;
;	We now check to see 
;
;		if the carry is clear. If so somebode along the chain wants
; 		the BIOS to ignore the keystroke and hence the BIOS is not 
;		going to reboot. Hence we don't turn off.
;
;		else if the scan code in al has changed. If so somebody 
;		along the chain has effectively changed the keystroke and
;		so the BIOS will not reboot. Hence we don't turn off.
;
;	NOTE: If some one changes the scan code to INS we'll still turn off
;	as we don not check to see if this is a Zenith machine here. We could
;	if we wanted with a few bytes of code. Since a lot of machines use 
;	ctrl-alt-ins to bring up their ROM BIOS setup we do not excpect that 
;	a program will change the DEL to an INS in order to avoid rebooting.
;	
;==============================================================================
.8086

public	rI15KeyBoard
rI15KeyBoard:

	jnc	rI15ret			; if nc return.

	pushf
	cmp	al, SC_DEL		; Q: scan code still del
	je	rI15off			; Y: turn off
	cmp	al, SC_INS		; Q: scan code still ins
	jne	rI15quit		; N: just return
rI15off:
	call	ShutDown		; N: turn ourselves off
rI15quit:
	popf
rI15ret:
	retf	2

R_CODE	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\iotrap.asm ===
.386p
page	58,132
;******************************************************************************
	title	IOTRAP.ASM - Dispatches I/O trap handlers
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
;   Module:   IOTRAP.ASM - Dispatches I/O trap handlers
;
;   Version:  2.00
;
;   Date:     July 1, 1986
;
;   Author:   Steve Preston
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   07/01/86  0.03	From ELIMTRAP.ASM (SBP).
;   07/03/86  0.03	Added handlers for 84,85,60, & 64 (SBP).
;   07/06/86  0.04	Changed assume to _DATA (SBP).
;   07/02/87  2.00	Add DMA channel 0 support (SBP).
;   07/13/88  3.31 (*C) Change handling of port 92h for 386s (RDV).
;   01/15/89  4.00 (*D) Generic 8042 detect added (RDV)
;
;   02/21/91  M011	Do not simulate IO address wrap
;
;******************************************************************************
;
;   Functional Description:
;
;	This routine is called by all I/O space trap handlers to allow
;   emulation/monitoring of I/O address reads and writes.  When a GP fault
;   occurs due to I/O to an address trapped in the I/O Bit Map, the I/O
;   instruction emulation routine in VMINST calls this routine.  This
;   routine calls the appropriate I/O trap handler for the I/O address.
;
;******************************************************************************
.lfcond 				; list false conditionals
	page
;******************************************************************************
;			P U B L I C   D E C L A R A T I O N S
;******************************************************************************
;
	public	IO_Trap 		; dispatches I/O trap handlers
	public	DMATable

	page
;******************************************************************************
;			L O C A L   C O N S T A N T S
;******************************************************************************
;
	include VDMseg.inc
	include VDMsel.inc
	include desc.inc
	include dma.inc
	include page.inc
	include oemdep.inc
	include vm386.inc
	include emmfunct.inc
	include emmdata.inc
	include emm386.inc
;
;******************************************************************************
;			E X T E R N A L   R E F E R E N C E S
;******************************************************************************
;

_TEXT	segment

;
;   Return to Real Handlers	(rrtrap.asm)
;
extrn	P84_Handler:near
extrn	P85_Handler:near

ifdef PICtrap
;
;  PIC trapping ports		(pictrap.asm)
;
extrn	PICCommand1:near
extrn	PICCommand2:near
extrn	PICData1:near
extrn	PICData2:near
endif

;
;   A20 watch handlers	(a20trap.asm)
;
extrn	P60_Handler:near	; Kybd Data port - A20 watch
extrn	P64_Handler:near	; Kybd Cmd port - A20 watch

;
;  LIM related handlers (elimtrap.asm)
;
extrn	DMABase0:near		;  DMA base register for Channel 0
extrn	DMABase1:near		;  DMA base register for Channel 1
extrn	DMABase2:near		;  DMA base register for Channel 2
extrn	DMABase3:near		;  DMA base register for Channel 3
extrn	DMABase5:near		;  DMA base register for Channel 5
extrn	DMABase6:near		;  DMA base register for Channel 6
extrn	DMABase7:near		;  DMA base register for Channel 7
extrn	DMACnt0:near		;  DMA count register for Channel 0
extrn	DMACnt1:near		;  DMA count register for Channel 1
extrn	DMACnt2:near		;  DMA count register for Channel 2
extrn	DMACnt3:near		;  DMA count register for Channel 3
extrn	DMACnt5:near		;  DMA count register for Channel 5
extrn	DMACnt6:near		;  DMA count register for Channel 6
extrn	DMACnt7:near		;  DMA count register for Channel 7
extrn	DMAEISACnt0:near	;  DMA EISA high count register for Channel 0
extrn	DMAEISACnt1:near	;  DMA EISA high count register for Channel 1
extrn	DMAEISACnt2:near	;  DMA EISA high count register for Channel 2
extrn	DMAEISACnt3:near	;  DMA EISA high count register for Channel 3
extrn	DMAEISACnt5:near	;  DMA EISA high count register for Channel 5
extrn	DMAEISACnt6:near	;  DMA EISA high count register for Channel 6
extrn	DMAEISACnt7:near	;  DMA EISA high count register for Channel 7
extrn	DMAPg0:near		;  DMA page register for Channel 0
extrn	DMAPg1:near		;  DMA page register for Channel 1
extrn	DMAPg2:near		;  DMA page register for Channel 2
extrn	DMAPg3:near		;  DMA page register for Channel 3
extrn	DMAPg5:near		;  DMA page register for Channel 5
extrn	DMAPg6:near		;  DMA page register for Channel 6
extrn	DMAPg7:near		;  DMA page register for Channel 7
extrn	DMAEISAPg0:near		;  DMA EISA high page register for Channel 0
extrn	DMAEISAPg1:near		;  DMA EISA high page register for Channel 1
extrn	DMAEISAPg2:near		;  DMA EISA high page register for Channel 2
extrn	DMAEISAPg3:near		;  DMA EISA high page register for Channel 3
extrn	DMAEISAPg5:near		;  DMA EISA high page register for Channel 5
extrn	DMAEISAPg6:near		;  DMA EISA high page register for Channel 6
extrn	DMAEISAPg7:near		;  DMA EISA high page register for Channel 7
extrn	DMARequest1:near	;  DMA S/W request for controller 1
extrn	DMARequest2:near	;  DMA S/W request for controller 2
extrn	DMAStat1:near  		;  DMA status for controller 1
extrn	DMASinMsk1:near		;  DMA Single Mask for controller 1
extrn	DMAMode1:near  		;  DMA Mode register for controller 1
extrn	DMAEISAExt1:near  	;  DMA EISA Extended Mode register/controller 1
extrn	DMAEISAChain1:near  	;  DMA EISA Chain Mode register for controller 1
extrn	DMAClrFF1:near 		;  DMA clear FF cmd for controller 1
extrn	DMAReset1:near 		;  DMA Reset for controller 1
extrn	DMAResMsk1:near		;  DMA Reset Mask for controller 1
extrn	DMAMask1:near  		;  DMA Mask for controller 1
extrn	DMAStat2:near  		;  DMA status for controller 2
extrn	DMASinMsk2:near		;  DMA Single Mask for controller 2
extrn	DMAMode2:near  		;  DMA Mode register for controller 2
extrn	DMAEISAExt2:near  	;  DMA EISA Extended Mode register/controller 2
extrn	DMAEISAChain2:near  	;  DMA EISA Chain Mode register for controller 2
extrn	DMAClrFF2:near 		;  DMA clear FF cmd for controller 2
extrn	DMAReset2:near 		;  DMA Reset for controller 2
extrn	DMAResMsk2:near		;  DMA Reset Mask for controller 2
extrn	DMAMask2:near  		;  DMA Mask for controller 2
extrn	DMA_FuncReg:near
extrn	DMA_ExecFunc:near
extrn	P92_Handler:near

_TEXT	ends

;******************************************************************************
;			S E G M E N T	D E F I N I T I O N
;******************************************************************************

;
;------------------------------------------------------------------------------
_TEXT	segment
	assume	cs:_TEXT, ds:_DATA, es:_DATA, gs:R_CODE, ss:_DATA
;
;   DMATable
;	One entry per port in the I/O space from 00h to FFh.
;
DMATable label	 word
	dw	offset _TEXT:DMABase0  ;  0 DMA base register for Channel 0
	dw	offset _TEXT:DMACnt0   ;  1 DMA count register for Channel 0
	dw	offset _TEXT:DMABase1  ;  2 DMA base register for Channel 1
	dw	offset _TEXT:DMACnt1   ;  3 DMA count register for Channel 1
	dw	offset _TEXT:DMABase2  ;  4 DMA base register for Channel 2
	dw	offset _TEXT:DMACnt2   ;  5 DMA count register for Channel 2
	dw	offset _TEXT:DMABase3  ;  6 DMA base register for Channel 3
	dw	offset _TEXT:DMACnt3   ;  7 DMA count register for Channel 3
	dw	offset _TEXT:DMAStat1  ;  8 DMA status for controller 1
	dw	offset _TEXT:DMARequest1; 9 DMA S/W request for controller 1
	dw	offset _TEXT:DMASinMsk1;  a DMA Single Mask for controller 1
	dw	offset _TEXT:DMAMode1  ;  b DMA Mode register for controller 1
	dw	offset _TEXT:DMAClrFF1 ;  c DMA clear FF cmd for controller 1
	dw	offset _TEXT:DMAReset1 ;  d DMA Reset for controller 1
	dw	offset _TEXT:DMAResMsk1;  e DMA Reset Mask for controller 1
	dw	offset _TEXT:DMAMask1  ;  f DMA Mask for controller 1
	dw	offset _TEXT:IOT_BadT  ; 10
	dw	offset _TEXT:IOT_BadT  ; 11
	dw	offset _TEXT:IOT_BadT  ; 12
	dw	offset _TEXT:IOT_BadT  ; 13
	dw	offset _TEXT:IOT_BadT  ; 14
	dw	offset _TEXT:IOT_BadT  ; 15
	dw	offset _TEXT:IOT_BadT  ; 16
	dw	offset _TEXT:IOT_BadT  ; 17
	dw	offset _TEXT:DMA_FuncReg ; 18
	dw	offset _TEXT:IOT_BadT  ; 19
	dw	offset _TEXT:DMA_ExecFunc; 1a
	dw	offset _TEXT:IOT_BadT  ; 1b
	dw	offset _TEXT:IOT_BadT  ; 1c
	dw	offset _TEXT:IOT_BadT  ; 1d
	dw	offset _TEXT:IOT_BadT  ; 1e
	dw	offset _TEXT:IOT_BadT  ; 1f
ifdef PICtrap
	dw	offset _TEXT:PICCommand1; 20 Master PIC (A0=0)
	dw	offset _TEXT:PICData1	; 21 Master PIC (A0=1)
else
	dw	offset _TEXT:IOT_BadT  ; 20
	dw	offset _TEXT:IOT_BadT  ; 21
endif
	dw	offset _TEXT:IOT_BadT  ; 22
	dw	offset _TEXT:IOT_BadT  ; 23
	dw	offset _TEXT:IOT_BadT  ; 24
	dw	offset _TEXT:IOT_BadT  ; 25
	dw	offset _TEXT:IOT_BadT  ; 26
	dw	offset _TEXT:IOT_BadT  ; 27
	dw	offset _TEXT:IOT_BadT  ; 28
	dw	offset _TEXT:IOT_BadT  ; 29
	dw	offset _TEXT:IOT_BadT  ; 2a
	dw	offset _TEXT:IOT_BadT  ; 2b
	dw	offset _TEXT:IOT_BadT  ; 2c
	dw	offset _TEXT:IOT_BadT  ; 2d
	dw	offset _TEXT:IOT_BadT  ; 2e
	dw	offset _TEXT:IOT_BadT  ; 2f
	dw	offset _TEXT:IOT_BadT  ; 30
	dw	offset _TEXT:IOT_BadT  ; 31
	dw	offset _TEXT:IOT_BadT  ; 32
	dw	offset _TEXT:IOT_BadT  ; 33
	dw	offset _TEXT:IOT_BadT  ; 34
	dw	offset _TEXT:IOT_BadT  ; 35
	dw	offset _TEXT:IOT_BadT  ; 36
	dw	offset _TEXT:IOT_BadT  ; 37
	dw	offset _TEXT:IOT_BadT  ; 38
	dw	offset _TEXT:IOT_BadT  ; 39
	dw	offset _TEXT:IOT_BadT  ; 3a
	dw	offset _TEXT:IOT_BadT  ; 3b
	dw	offset _TEXT:IOT_BadT  ; 3c
	dw	offset _TEXT:IOT_BadT  ; 3d
	dw	offset _TEXT:IOT_BadT  ; 3e
	dw	offset _TEXT:IOT_BadT  ; 3f
	dw	offset _TEXT:IOT_BadT  ; 40
	dw	offset _TEXT:IOT_BadT  ; 41
	dw	offset _TEXT:IOT_BadT  ; 42
	dw	offset _TEXT:IOT_BadT  ; 43
	dw	offset _TEXT:IOT_BadT  ; 44
	dw	offset _TEXT:IOT_BadT  ; 45
	dw	offset _TEXT:IOT_BadT  ; 46
	dw	offset _TEXT:IOT_BadT  ; 47
	dw	offset _TEXT:IOT_BadT  ; 48
	dw	offset _TEXT:IOT_BadT  ; 49
	dw	offset _TEXT:IOT_BadT  ; 4a
	dw	offset _TEXT:IOT_BadT  ; 4b
	dw	offset _TEXT:IOT_BadT  ; 4c
	dw	offset _TEXT:IOT_BadT  ; 4d
	dw	offset _TEXT:IOT_BadT  ; 4e
	dw	offset _TEXT:IOT_BadT  ; 4f
	dw	offset _TEXT:IOT_BadT  ; 50
	dw	offset _TEXT:IOT_BadT  ; 51
	dw	offset _TEXT:IOT_BadT  ; 52
	dw	offset _TEXT:IOT_BadT  ; 53
	dw	offset _TEXT:IOT_BadT  ; 54
	dw	offset _TEXT:IOT_BadT  ; 55
	dw	offset _TEXT:IOT_BadT  ; 56
	dw	offset _TEXT:IOT_BadT  ; 57
	dw	offset _TEXT:IOT_BadT  ; 58
	dw	offset _TEXT:IOT_BadT  ; 59
	dw	offset _TEXT:IOT_BadT  ; 5a
	dw	offset _TEXT:IOT_BadT  ; 5b
	dw	offset _TEXT:IOT_BadT  ; 5c
	dw	offset _TEXT:IOT_BadT  ; 5d
	dw	offset _TEXT:IOT_BadT  ; 5e
	dw	offset _TEXT:IOT_BadT  ; 5f
	dw	offset _TEXT:P60_Handler	; A20 watch on kybd data port
	dw	offset _TEXT:IOT_BadT  ; 61
	dw	offset _TEXT:IOT_BadT  ; 62
	dw	offset _TEXT:IOT_BadT  ; 63
	dw	offset _TEXT:P64_Handler	; A20 watch on kybd cmd port
	dw	offset _TEXT:IOT_BadT  ; 65
	dw	offset _TEXT:IOT_BadT  ; 66
	dw	offset _TEXT:IOT_BadT  ; 67
	dw	offset _TEXT:IOT_BadT  ; 68
	dw	offset _TEXT:IOT_BadT  ; 69
	dw	offset _TEXT:IOT_BadT  ; 6a
	dw	offset _TEXT:IOT_BadT  ; 6b
	dw	offset _TEXT:IOT_BadT  ; 6c
	dw	offset _TEXT:IOT_BadT  ; 6d
	dw	offset _TEXT:IOT_BadT  ; 6e
	dw	offset _TEXT:IOT_BadT  ; 6f
	dw	offset _TEXT:IOT_BadT  ; 70
	dw	offset _TEXT:IOT_BadT  ; 71
	dw	offset _TEXT:IOT_BadT  ; 72
	dw	offset _TEXT:IOT_BadT  ; 73
	dw	offset _TEXT:IOT_BadT  ; 74
	dw	offset _TEXT:IOT_BadT  ; 75
	dw	offset _TEXT:IOT_BadT  ; 76
	dw	offset _TEXT:IOT_BadT  ; 77
	dw	offset _TEXT:IOT_BadT  ; 78
	dw	offset _TEXT:IOT_BadT  ; 79
	dw	offset _TEXT:IOT_BadT  ; 7a
	dw	offset _TEXT:IOT_BadT  ; 7b
	dw	offset _TEXT:IOT_BadT  ; 7c
	dw	offset _TEXT:IOT_BadT  ; 7d
	dw	offset _TEXT:IOT_BadT  ; 7e
	dw	offset _TEXT:IOT_BadT  ; 7f
	dw	offset _TEXT:IOT_BadT  ; 80
	dw	offset _TEXT:DMAPg2    ; 81 DMA page register for Channel 2
	dw	offset _TEXT:DMAPg3    ; 82 DMA page register for Channel 3
	dw	offset _TEXT:DMAPg1    ; 83 DMA page register for Channel 1
	dw	offset _TEXT:P84_Handler	; return to real port
	dw	offset _TEXT:P85_Handler	; return to real port
	dw	offset _TEXT:IOT_BadT  ; 86
	dw	offset _TEXT:DMAPg0    ; 87 DMA page register for Channel 0
	dw	offset _TEXT:IOT_BadT  ; 88
	dw	offset _TEXT:DMAPg6    ; 89 DMA page register for Channel 6
	dw	offset _TEXT:DMAPg7    ; 8a DMA page register for Channel 7
	dw	offset _TEXT:DMAPg5    ; 8b DMA page register for Channel 5
	dw	offset _TEXT:IOT_BadT  ; 8c
	dw	offset _TEXT:IOT_BadT  ; 8d
	dw	offset _TEXT:IOT_BadT  ; 8e
	dw	offset _TEXT:IOT_BadT  ; 8f
	dw	offset _TEXT:IOT_BadT  ; 90
	dw	offset _TEXT:DMAPg2    ; 91 DMA page register for Channel 2
	dw	offset _TEXT:IOT_Chk92 ; 92 real 92/DMA pg 3/or A20 for PS2
	dw	offset _TEXT:DMAPg1    ; 93 DMA page register for Channel 1
	dw	offset _TEXT:IOT_BadT  ; 94
	dw	offset _TEXT:IOT_BadT  ; 95
	dw	offset _TEXT:IOT_BadT  ; 96
	dw	offset _TEXT:DMAPg0    ; 97 DMA page register for Channel 0
	dw	offset _TEXT:IOT_BadT  ; 98
	dw	offset _TEXT:DMAPg6    ; 99 DMA page register for Channel 6
	dw	offset _TEXT:DMAPg7    ; 9a DMA page register for Channel 7
	dw	offset _TEXT:DMAPg5    ; 9b DMA page register for Channel 5
	dw	offset _TEXT:IOT_BadT  ; 9c
	dw	offset _TEXT:IOT_BadT  ; 9d
	dw	offset _TEXT:IOT_BadT  ; 9e
	dw	offset _TEXT:IOT_BadT  ; 9f
ifdef PICtrap
	dw	offset _TEXT:PICCommand2; a0 Slave PIC (A0=0)
	dw	offset _TEXT:PICData2	; a1 Slave PIC (A0=1)
else
	dw	offset _TEXT:IOT_BadT  ; a0
	dw	offset _TEXT:IOT_BadT  ; a1
endif
	dw	offset _TEXT:IOT_BadT  ; a2
	dw	offset _TEXT:IOT_BadT  ; a3
	dw	offset _TEXT:IOT_BadT  ; a4
	dw	offset _TEXT:IOT_BadT  ; a5
	dw	offset _TEXT:IOT_BadT  ; a6
	dw	offset _TEXT:IOT_BadT  ; a7
	dw	offset _TEXT:IOT_BadT  ; a8
	dw	offset _TEXT:IOT_BadT  ; a9
	dw	offset _TEXT:IOT_BadT  ; aa
	dw	offset _TEXT:IOT_BadT  ; ab
	dw	offset _TEXT:IOT_BadT  ; ac
	dw	offset _TEXT:IOT_BadT  ; ad
	dw	offset _TEXT:IOT_BadT  ; ae
	dw	offset _TEXT:IOT_BadT  ; af
	dw	offset _TEXT:IOT_BadT  ; b0
	dw	offset _TEXT:IOT_BadT  ; b1
	dw	offset _TEXT:IOT_BadT  ; b2
	dw	offset _TEXT:IOT_BadT  ; b3
	dw	offset _TEXT:IOT_BadT  ; b4
	dw	offset _TEXT:IOT_BadT  ; b5
	dw	offset _TEXT:IOT_BadT  ; b6
	dw	offset _TEXT:IOT_BadT  ; b7
	dw	offset _TEXT:IOT_BadT  ; b8
	dw	offset _TEXT:IOT_BadT  ; b9
	dw	offset _TEXT:IOT_BadT  ; ba
	dw	offset _TEXT:IOT_BadT  ; bb
	dw	offset _TEXT:IOT_BadT  ; bc
	dw	offset _TEXT:IOT_BadT  ; bd
	dw	offset _TEXT:IOT_BadT  ; be
	dw	offset _TEXT:IOT_BadT  ; bf
	dw	offset _TEXT:IOT_BadT  ; c0 DMA base register for Channel 4
	dw	offset _TEXT:IOT_BadT  ; c1
	dw	offset _TEXT:IOT_BadT  ; c2 DMA count register for Channel 4
	dw	offset _TEXT:IOT_BadT  ; c3
	dw	offset _TEXT:DMABase5  ; c4 DMA base register for Channel 5
	dw	offset _TEXT:IOT_BadT  ; c5
	dw	offset _TEXT:DMACnt5   ; c6 DMA count register for Channel 5
	dw	offset _TEXT:IOT_BadT  ; c7
	dw	offset _TEXT:DMABase6  ; c8 DMA base register for Channel 6
	dw	offset _TEXT:IOT_BadT  ; c9
	dw	offset _TEXT:DMACnt6   ; ca DMA count register for Channel 6
	dw	offset _TEXT:IOT_BadT  ; cb
	dw	offset _TEXT:DMABase7  ; cc DMA base register for Channel 7
	dw	offset _TEXT:IOT_BadT  ; cd
	dw	offset _TEXT:DMACnt7   ; ce DMA count register for Channel 7
	dw	offset _TEXT:IOT_BadT  ; cf
	dw	offset _TEXT:DMAStat2  ; d0 DMA Status for controller 2
	dw	offset _TEXT:IOT_BadT  ; d1
	dw	offset _TEXT:DMARequest2;d2 DMA S/W request for controller 2
	dw	offset _TEXT:IOT_BadT  ; d3
	dw	offset _TEXT:DMASinMsk2; d4 DMA Single Mask for controller 2
	dw	offset _TEXT:IOT_BadT  ; d5
	dw	offset _TEXT:DMAMode2  ; d6 DMA Mode for controller 2
	dw	offset _TEXT:IOT_BadT  ; d7
	dw	offset _TEXT:DMAClrFF2 ; d8 DMA clear FF cmd for controller 2
	dw	offset _TEXT:IOT_BadT  ; d9
	dw	offset _TEXT:DMAReset2 ; da DMA Reset for controller 2
	dw	offset _TEXT:IOT_BadT  ; db
	dw	offset _TEXT:DMAResMsk2; dc DMA Reset Mask for controller 2
	dw	offset _TEXT:IOT_BadT  ; dd
	dw	offset _TEXT:DMAMask2  ; de DMA Mask for controller 2
	dw	offset _TEXT:IOT_BadT  ; df
	dw	offset _TEXT:IOT_BadT  ; e0
	dw	offset _TEXT:IOT_BadT  ; e1
	dw	offset _TEXT:IOT_BadT  ; e2
	dw	offset _TEXT:IOT_BadT  ; e3
	dw	offset _TEXT:IOT_BadT  ; e4
	dw	offset _TEXT:IOT_BadT  ; e5
	dw	offset _TEXT:IOT_BadT  ; e6
	dw	offset _TEXT:IOT_BadT  ; e7
	dw	offset _TEXT:IOT_BadT  ; e8
	dw	offset _TEXT:IOT_BadT  ; e9
	dw	offset _TEXT:IOT_BadT  ; ea
	dw	offset _TEXT:IOT_BadT  ; eb
	dw	offset _TEXT:IOT_BadT  ; ec
	dw	offset _TEXT:IOT_BadT  ; ed
	dw	offset _TEXT:IOT_BadT  ; ee
	dw	offset _TEXT:IOT_BadT  ; ef
	dw	offset _TEXT:IOT_BadT  ; f0
	dw	offset _TEXT:IOT_BadT  ; f1
	dw	offset _TEXT:IOT_BadT  ; f2
	dw	offset _TEXT:IOT_BadT  ; f3
	dw	offset _TEXT:IOT_BadT  ; f4
	dw	offset _TEXT:IOT_BadT  ; f5
	dw	offset _TEXT:IOT_BadT  ; f6
	dw	offset _TEXT:IOT_BadT  ; f7
	dw	offset _TEXT:IOT_BadT  ; f8
	dw	offset _TEXT:IOT_BadT  ; f9
	dw	offset _TEXT:IOT_BadT  ; fa
	dw	offset _TEXT:IOT_BadT  ; fb
	dw	offset _TEXT:IOT_BadT  ; fc
	dw	offset _TEXT:IOT_BadT  ; fd
	dw	offset _TEXT:IOT_BadT  ; fe
	dw	offset _TEXT:IOT_BadT  ; ff

;
;   DMAEISATable
;	One entry per port in the I/O space from 400h to 4FFh.
;
DMAEISATable label	 word

 dw DMA_E_CH1,offset _TEXT:DMAEISAChain1 ;40A EISA DMA Chain/controller 1
 dw DMA_E_CH2,offset _TEXT:DMAEISAChain2 ;4D4 EISA DMA Chain/controller 2
 dw DMA_E_EM1,offset _TEXT:DMAEISAExt1   ;40B EISA DMA Extended/controller 1
 dw DMA_E_EM2,offset _TEXT:DMAEISAExt2   ;4D6 EISA DMA Extended/controller 2

 dw DMA_E_C0,offset _TEXT:DMAEISACnt0 ;401 EISA DMA high count/Channel 0
 dw DMA_E_C1,offset _TEXT:DMAEISACnt1 ;403 EISA DMA high count/Channel 1
 dw DMA_E_C2,offset _TEXT:DMAEISACnt2 ;405 EISA DMA high count/Channel 2
 dw DMA_E_C3,offset _TEXT:DMAEISACnt3 ;407 EISA DMA high count/Channel 3
 dw DMA_E_C5,offset _TEXT:DMAEISACnt5 ;4C6 EISA DMA high count/Channel 5
 dw DMA_E_C6,offset _TEXT:DMAEISACnt6 ;4CA EISA DMA high count/Channel 6
 dw DMA_E_C7,offset _TEXT:DMAEISACnt7 ;4CE EISA DMA high count/Channel 7

 dw DMA_E_P0,offset _TEXT:DMAEISAPg0  ;487 EISA DMA high page/Channel 0
 dw DMA_E_P1,offset _TEXT:DMAEISAPg1  ;483 EISA DMA high page/Channel 1
 dw DMA_E_P2,offset _TEXT:DMAEISAPg2  ;481 EISA DMA high page/Channel 2
 dw DMA_E_P3,offset _TEXT:DMAEISAPg3  ;482 EISA DMA high page/Channel 3
 dw DMA_E_P5,offset _TEXT:DMAEISAPg5  ;48B EISA DMA high page/Channel 5
 dw DMA_E_P6,offset _TEXT:DMAEISAPg6  ;489 EISA DMA high page/Channel 6
 dw DMA_E_P7,offset _TEXT:DMAEISAPg7  ;48A EISA DMA high page/Channel 7

TOTAL_EISA_EXTENDED_DMA_PORTS equ ($-DMAEISATable)/4

	page
;******************************************************************************
;   IO_Trap - Dispatches trap handler for an I/O address
;
;   ENTRY: Protected Mode Ring 0
;		AL = byte to output to port.
;		DX = port address for I/O.
;		SS:BP = points to stack frame on entry to GP fault handler
;		BX = 0 => Emulate Input.
;		   <>0 => Emulate Output.
;
;   EXIT:  Protected Mode Ring 0
;		AL = emulated input value from port.
;		CLC => I/O emulated by LIM_Trap.
;		STC => I/O NOT emulated by LIM_Trap.
;
;   USED:  Flags
;   STACK:
;------------------------------------------------------------------------------
IO_Trap proc	near
;
	push	dx
	push	ds
	push	gs

	push	VDMD_GSEL
	pop	ds			; set DS = _DATA
	push	RCODEA_GSEL
	pop	gs			; set GS = R_CODE

	cmp	dx,0100h		;Q: I/O Addr < 0100h (system brd port)?
	jae	SHORT IOT_NotISASys	;  N: check mapping regs
IOT_Sys:				;  Y: dispatch I/O trap handler
	xchg	bx, dx			; BL = port address
	shl	bx,1			; BX = BX*2 (word table)
	call	cs:DMATable[bx] 	; call handler
					;   ENTRY: entry DX,DS on stack
					;   DS = _DATA selector
					;   BX = port address in 0100h range
					;   DX = input/output flag

	xchg	bx,dx		; reset bx
	pop	gs
	pop	ds		;
	pop	dx		; reset dx
	ret

;
;    Address >= 0100h
;
IOT_NotISASys:
	test	gs:[GenFlags],fEISA   ;Q: EISA system?
	jz	short IOT_NotMap      ; N: reflect in first 1K IO address space
	push	ecx
	mov	ecx,TOTAL_EISA_EXTENDED_DMA_PORTS
IOT_EISAloop:
	cmp	dx,DMAEISATable[ECX*4-4];Q: This EISA port?
	je	short IOT_EISAPort	; Y: trap the EISA port
	loop	IOT_EISAloop		; N: try next EISA port
	pop	ecx
	xchg	bx,dx		; put Input/Output flag in DX for IOT_BadT
	push	ax		; push junk for return address
	jmp	short IOT_BadT	;  and fall thru to IOT_BadT

IOT_EISAPort:
	xchg	bx,dx			; BL = port address
	shl	bx,1			; BX = BX*2 (word table)
	call	cs:DMAEISATable[ecx*4-2]; call handler
					;   ENTRY: entry DX,DS on stack
					;   DS = _DATA selector
					;   BX = port address*2
					;   DX = input/output flag
	xchg	bx,dx		; reset bx
	pop	ecx
	pop	gs
	pop	ds		;
	pop	dx		; reset dx
	ret

;
;   Here if I/O Address >= 0100h and not a mapping register
;	map it into 1k and try system board ports again (NOT EISA or MCA)
;
IOT_NotMap:

ifdef	IOWRAP			; M011 - Start

	;
	;  Test for MCA: If so, don't wrap!
	;

	test	gs:[GenFlags], fMCA	; Q: MCA system
	jnz	short IOT_NoMap		; N: PS2 machine, don't wrap

	and	dx,3FFh 	; map address into 1k range
	cmp	dx,0100h	;Q: I/O Addr < 0100h (system brd port)?
	jb	IOT_Sys 	;  Y: check system ports
				;  N: Unknown port - signal error

endif				; M011 - End

IOT_NoMap:
	xchg	bx,dx		; put Input/Output flag in DX for IOT_BadT
	push	ax		;   push junk for return address
				;  and fall thru to IOT_BadT
;
;   IOT_BadT - GP fault on Unknown I/O address
;		**** return not emulated for now ****
;	ENTRY:	entry DX,DS,ret address on stack
;		DX = entry BX
;
IOT_BadT:
	pop	bx		; dump return address
	mov	bx,dx		; restore BX
	pop	gs
	pop	ds		; restore DS
	pop	dx		; reset port address
	stc			; port not emulated !
	ret			; and return

IOT_Chk92: 		   
			; Port 92h not 82h on password 8042 or PS2s
ifdef	ROMIDMCA
	push	VDMD_GSEL	; _DATA segment
	pop	ds
	cmp	[ROMID],ROMIDPS2;Q: PS2 (A20 toggle)?
	je	short P92_Handler
				; Y: A20 toggle mechanism
endif
	test	gs:[GenFlags], fMCA; Q: MCA (A20 toggle) ?
	jnz	P92_Handler	; Y: A20 toggle mechanism
				
ifndef	MSFLAG
				; N: Check for password 8042 system
				;Q: Is port 92h used to toggle A20?
	test	gs:[GenFlags],fP92 
	jnz	P92_Handler	; Y: virtualize IO

	test	gs:[GenFlags],fP8042 ;Q: Password 8042 but no A20 toggle?
	jne	IOT_BadT	  ; Y: then do real I/O
	jmp	DMAPg3		  ; N: emulate wrap to port 82h
else
	jmp	IOT_BadT	; N: then do real I/O			     *C
endif	

IOTPS2:				; PS2 A20 toggle mechanism
	jmp	P92_Handler

IO_Trap endp

_TEXT	ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\init.asm ===
.386p
page 58,132
;******************************************************************************
	TITLE	INIT - initialization code for CEMM
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:	EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
;   Module:	INIT - initialization code for CEMM
;
;   Version:	2.02
;
;   Date:	May 24,1986
;
;   Author:	Steve Preston,Brad Tate
;
;******************************************************************************
;
;	Change Log:
;
;	DATE	 REVISION	Description
;	-------- --------	--------------------------------------------
;	05/24/86 Original
;	06/18/86 0.01		Added AUTO as a valid config line parameter.
;	06/25/86 0.02		Added call to debug init.
;	06/27/86 0.02		Check for Mx length = 2 and only 2 (SBP).
;	06/28/86 0.02		Change name from CEMM386 to CEMM (SBP).
;	06/29/86 0.02		Size > 8192 were used instead of converted
;				to 256 (SBP).
;	07/03/86 0.04		Added TEXT_Seg (SBP).
;	07/06/86 0.04		changed assume to _DATA (SBP).
;	07/06/86 0.04		moved init messages to LAST (SBP).
;	07/10/86 0.05		added int15 patch and int67 patch here (SBP).
;	07/11/86 0.06		check processor type before checking for
;				install (SBP).
;	01/09/87 0.10 (*A)  GE	Set flag to disable RAM search if M1-M5 is specified
;	05/18/87 2.00		New state variables for CEMM state/modes and
;				reworked AUTO/ON/OFF init code.
;	05/29/87 2.00		Reworked Page Frame selection logic (SBP).
;	06/07/87 2.00		Add Weitek detection & arguments WON/WOFF (SBP).
;	02/20/88 3.30 (*B)	Init check for P9 processor (RDV)
;	07/14/88 3.31 (*C)	Init check for Taurus and Horizon (RDV)
;				Add WAIT (pause routine) for init errors (RDV).
;				Move DOS version chk to cemm386.asm (stratini).
;	01/12/89 4.00 (*D)	User aborted install added (RDV)
;				Generic 8042 detect and flag
;	08/07/89 4.10   	Add DEB386 support (LC).
;	08/07/89 4.10		Add CEMM to the int 2Fh chain (HKN&LC)
;	08/23/89 4.10		New memory allocation (INT15h,BIM,XMS) (LC)
;
;	02/13/91 M008		Detect a Compaq Deskpro 386/16 or a Compaq
;				portable 386.
;
;	02/14/91 M010		Added support for Y path parameter for
;			  	load hi Vxd.
;
;******************************************************************************
;   Functional Description:
;	This module allocates the pool of extended memory to be used for
;   expanded memory, then call routines to initialize the data structures
;   for EMM and VDM.
;
;******************************************************************************
.lfcond
	page
;******************************************************************************
;			P U B L I C   D E C L A R A T I O N S
;******************************************************************************
;
	public	Init_CEMM386
	public	EndDriver
	public	parser
	public	Pn
	public	PnSet
	public	EstWorkSpace

	public	eXcSet
	public	IncSet
	public	DfltSet
	public	VGAROM
	public	E000ROM
	public	ROMparm
	public	RAMSet
	public	ROMSet
	public	EMSSet
	public	WINset
	public	HighSet

	public	max_pool_size
	public	min_pool_size
	public	high_memory_address
	public	ext_memory_address
	public	ext_size
	public	hi_size
	public	ext_mem
	public	UMBset
	public	HMAonSet
	public	Highscan
	public	NoTR

	public 	pCOMPAQ
	public	szCOMPAQ
	public	CDPSCSI

	public	XmmControlBase
	public	XmmControlJmpVal

	public	DOS_version
	public	XMMHookAddr

	page
;******************************************************************************
;			L O C A L   C O N S T A N T S
;******************************************************************************
	include vdmseg.inc
	include emm386.inc
	include driver.equ
	include driver.inc
	include ascii_sm.equ
	include	emmfunct.inc
	include	emmdata.inc
	include	winemm.inc
	include allocmem.inc
	include dma.inc
	include vdmsel.inc

;******************************************************************************
;			E X T E R N A L    R E F E R E N C E S
;******************************************************************************
R_CODE	segment
	EXTRN	DDT: WORD
	EXTRN	ttl_hndls: WORD
	extrn	DEVHEAD:word
	extrn	DEVHEAD2:word
	extrn	rINT13hHandler:near	; int13h patch code
	extrn	rINT15hHandler:near	; int15h patch code
	extrn	rINT19hHandler:near	; int19h patch code
;;	extrn	rINT4BhHandler:near	; int4Bh patch code
	extrn	EMM_rEntry:near 	; int67h patch code
	extrn	FarGoVirtual:far	; go to virtual mode
	extrn	Devname:byte
	extrn	MasterPICVec:word
	extrn	SlavePICVec:word

;;	extrn	b2asc10_far:far
;;	extrn	b2ascHEX_far:far
;;	extrn	I_Message_Display:far
;;	extrn	E_XStatus_Display:far

	extrn 	rINT2FhHandler:near
;;	extrn	XMMAllocateHMA:far
;;	extrn	check_XMM:far
;;	extrn	chk_machine_state:far

	extrn	EMM_rFarEntry:word
	extrn	end_of_R1_CODE:byte
	extrn	UMBFARTABLE:word
	extrn	UMBADDRLEN:abs
	extrn	checkXMMFar:dword
	extrn	chkMcStateFar:dword

CDPSCSI	db	0  ; A CDP (Columbia Data Products) SCSI fixed drive is detected.

R_CODE	ends

R1_CODE	segment

	extrn	rINT4BhHandler:near	; int4Bh patch code
	extrn	OldInt13:dword
	extrn	PrevInt4B:dword
	extrn	rXMMentry:far
	extrn	PrevInt10:dword
	extrn	PrevInt11:dword

R1_CODE	ends

_DATA	segment
	extrn	HMAmin:word
_DATA	ends

GDT	segment
	extrn	GDTLEN:abs
GDT	ends

IDT	segment
	extrn	IDTLEN:abs
IDT	ends

ifdef TSSQLEO
TSS	segment
	extrn	TSSLEN:abs
TSS	ends
endif

LAST	segment
	extrn	Inst_chk:near		; check for CEMM already installed
	extrn	r_cmos:near
	extrn	InstallMess:byte
	extrn	ISizeMess:byte
	extrn	ActiveMess:byte
	extrn	InactiveMess:byte
	extrn	OFFMess:byte
	extrn	AutoMess:byte
	extrn	InvParm:byte
	extrn	InvPFBA:byte
	extrn	InvMRA:byte
	extrn	Adj_Size:byte
	extrn	InsfMem:byte
	extrn	Incorrect_DOS:byte
	extrn	Incorrect_PRT:byte
	extrn	Already_Inst:byte
	extrn	No_PF_Avail:byte
	extrn	PFWarning:byte
	extrn	NoWeitek:byte
	EXTRN	PF_not_3_2: BYTE
	extrn	HMAonMsg:byte
	extrn	NumOfUMBwindows:byte
	extrn	UMBmemMsg:byte
	extrn	OverlapWarn:byte
	extrn	WeitekONMess:byte
	extrn	WeitekOFFMess:byte
	extrn	WeitekNAMess:byte
	extrn	UserAbortMsg:byte
	extrn	OF_won_err:byte
	extrn	PFB_warning:word
	extrn	bad_mc_state:near
	extrn	Inv_DOS_msg:near
	extrn	Is386:far		; check for 386
	extrn	Is386s:far		;
	extrn	IsP8042:far		; generic check for password 8042
	extrn	EMM_Init:near		; initialization for EMM data structs
	extrn	DMAInit:near
	extrn	PICVecInit:near
	extrn	VDM_Init:near		; initialize VDM
	extrn	WSInit:near
	extrn	WSMove:near
	extrn	FindWindowLocations:near ; look for option roms in PF area
	extrn	InitDeb:near
	extrn	MemInit:near
	extrn	MemGet:near
	extrn	MemExit:near
	extrn	GetPathName:near
	extrn	StorePath:near		; M010
	extrn	NoXMM:byte
	extrn	OtherEMM:byte
	extrn	BadXMM:byte
	extrn	XMMcheck:near
	extrn	get_XMM_ver:near
	extrn	XMMQueryExtended:near
	extrn	IsCompaq:near
	extrn	segfixup:near
	extrn	UMBlink:near
	extrn	NoResetRoutine:near
	extrn	Page4K:byte
	extrn	handle0_PTEs:word
	extrn	DoMoveBlock:near

ifdef ROMcomp
	extrn	FixROMptrs:near
	extrn	FixIVTptrs:near
endif

	extrn	b2asc10:near
	extrn	b2ascHEX:near
	extrn	I_Message_Display:near
	extrn	E_XStatus_Display:near
	extrn	wait_key:near

ifdef DEBUG
	extrn	DebDefineSeg:near
endif

LAST	ends

TB			EQU	09h
MIN_SIZE 		EQU	64
MAX_ALT_REG_SETS	EQU	254

LAST	SEGMENT				; (PIW)
switch	DD	Invalid_Parameter	;	0
	DD	Get_P_Handle_Page_Frame	; /     1
	DD	Get_Size		; 0     2
	DD	Get_Size		; 1     3
	DD	Get_Size		; 2     4
	DD	Get_Size		; 3     5
	DD	Get_Size		; 4     6
	DD	Get_Size		; 5     7
	DD	Get_Size		; 6     8
	DD	Get_Size		; 7     9
	DD	Get_Size		; 8    10
	DD	Get_Size		; 9     1
	DD	Get_Mode_Alt_Reg_Sets	; A     2
	DD	Get_Lowest_Frame	; B     3
	DD	Get_DMA_Buffer_Size	; D     4
	DD	Get_Page_Frame		; F     5
	DD	Get_H			; H     6
	DD	Get_Left_Alone_Size	; L     7
	DD	Get_M			; M	8
	DD	Get_On_Off_Mode		; O     9
	DD	Get_I_Page_Frame	; P    20
	DD	Get_Wetek_Mode		; W     1
	DD	GetExcludeRange		; X     2
	DD	GetRAM			; R     3
	DD	NoMoveXBDA		; N     4
	DD	GetIncludeRange		; I	5
	DD	EMSInts			; E	6
	DD	GetFullPath		; Y	7  (M010)
	DD	Vir8042Parm		; V	8  (LC910611)
case	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,01	; /
	DB	02,03,04,05,06,07,08,09,10,11,00,00,00,00,00,00	; 0123456789
	DB	00,12,13,00,14,26,15,00,16,25,00,00,17,18,24,19	; ABDEFHILMNO
	DB	20,00,23,00,00,00,28,21,22,27,00,00,00,00,00,00 ; PQRVWXY
	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
	DB	00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
$Hset	DB	0
altRset	DB	0
baseset	DB	0
bDMAset	DB	0

;------------------------------------------------------------------------
; Keep all parameter ranges together here so they can be saved/restored
; together.

	public	RangeSets, RANGESIZE, RangeSave

RangeSets label byte
eXcSet	dw	EXCLUDE shl 8 + 2, 24 dup (0)	; eXclude range specified by user
IncSet	dw	RAM 	shl 8 + 2, 24 dup (0)	; Include range specified by user
RAMSet	dw	RAM   	shl 8 + 2, 24 dup (0)	; RAM range specified by user
EMSSet	dw	EMS   	shl 8 + 2, 24 dup (0)	; EMS range specified by user
ROMSet	dw	ROM   	shl 8 + 2+4*1
	dw	0FF00h,0FF00h,24 dup (0)	; ROM range specified by user
WINset	dw	WIN	shl 8 + 2, 24 dup (0)	; Win range specified by user
HighSet dw	2, 24 dup (0)			; Highscan detected ranges

DfltSet dw	INUSE 	shl 8 + 2+3*4
	dw	00001h				; from 1
Bparm	dw	03FFFh				; to   3fffh
	dw	0A000h				; from a000
VGAROM	dw	0BFFFh				; to   bfffh
E000ROM	dw	0F000h, 0FFFFh			; exc f000h - ffffh
	dw	0,0				; Terminating zeroes
RANGESIZE equ	$-RangeSets

RangeSave db	RANGESIZE dup (?)

;------------------------------------------------------------------------

frames	DW	0C000h			; M1
	DW	0C400h			; M2
	DW	0C800h			; M3
	DW	0CC00h			; M4
	DW	0D000h			; M5
	DW	0D400h			; M6
	DW	0D800h			; M7
	DW	0DC00h			; M8
	DW	0E000h			; M9
	DW	08000h			; M10
	DW	08400h			; M11
	DW	08800h			; M12
	DW	08C00h			; M13
	DW	09000h			; M14
numFram	EQU	($-frames) SHR 1
	DW	09400h			; Pddd
	DW	09800h			; Pddd
	DW	09C00h			; Pddd
	DW	0E400h			; Pddd
	DW	0E800h			; Pddd
	DW	0EC00h			; Pddd
numPFrm	EQU	($-frames) SHR 1
framadr		DD	frames
tknBuf		DB	128 DUP (0)
op_on		DB	"ON", 0
ONLEN		EQU	$-op_on
op_off		DB	"OFF", 0
OFFLEN		EQU	$-op_off
op_auto		DB	"AUTO", 0
AUTOLEN		EQU	$-op_auto
frame$		DB	"FRAME="
framLen		EQU	$-frame$
ROMCompParm	db	"ROMCOMPRESS"
ROMCompLen	equ	$-ROMCompParm
verbose$	db	"VERBOSE", 0
verboseLen	equ	$-verbose$
ext_mem		dd	FREE
Pn		DB	6 DUP (FREE)
PnSet		DW	FALSE
UMBset		dw	FALSE
UMBman		dw	FALSE
HMAonSet 	db	FALSE
ROMparm		db	FALSE
NoPFCset	db	FALSE
NoHigh		db	FALSE
Highscan	db	FALSE
Verbose 	db	FALSE
NoVCPI		db	FALSE
NoTR		db	FALSE

smartdrv_status	status	<>
smartdrv_name	db	'SMARTAAR',0
CACHEname	db	'CACHCMPQ',0
CACHEIOCTL	dw	1
		dd	0
		dd	0

min_pool_set		db	FALSE
max_pool_set		db	FALSE
min_pool_size		dw	256
max_pool_size		dw	0
high_memory_address     dd	0
ext_memory_address      dd	0
ext_size                dw	0
hi_size                 dw	0

set_int13	label	byte
		dw	000dh	; cmd byte for setting Smartdrv's old int 13
		dd	?	; address to which Smartdrv's old int 13 s
				; should be set

EndDriver	dw	0	; last segment of driver to load

XmmControlBase	label	dword	; base address of XMM control headers
		dw	-1
		dw	-1

XmmControlJmpVal db	?	; offset byte of short jmp instruction

SYSSS		dw	?
SYSSP		dw	?

DOS_version	dw	0
XMMHookAddr	dd	0

; Toshiba specific data items

	public	HRAMSet
	public	BRAMSet
	public	ToshSet
	public	toshiba_machine
	public	TOSHbeg
	public	TOSHend

HRAMSet dw	INUSE	shl 8 + 2+1*4		; Toshiba Hard Ram exclusions
HRAMbeg	dw	0h				; HardRAM Win begin (e000 dflt)	
HRAMend	dw	0h				; HardRAM Win end   (e800 dflt)
	dw	0,0				; Terminating zeroes

BRAMSet dw	INUSE	shl 8 + 2+1*4		; Toshiba Backup Ram exclusions
BRAMbeg	dw	0h				; Bkup RAM begin (e800 dflt) 	
BRAMend	dw	0h				; Bkup RAM end   (efff dflt)
	dw	0,0				; Terminating zeroes

ToshSet dw	INUSE	shl 8 + 2+1*4		; Toshiba Misc. exclusions
TOSHbeg	dw	0h				; Misc. Toshiba resrvd area begin (e000 dflt) 	
TOSHend	dw	0h				; Misc. Toshiba resrvd area end   (efff dflt)
	dw	0,0				; Terminating zeroes	

pTOSHIBA	label	dword		; Pointer to TOSHIBA signature
		dw	0E010h
		dw	0F000h

szTOSHIBA	db     'TOSHIBA '	; TOSHIBA signature

toshiba_machine db	0		; NZ if on a Toshiba machine

LAST	ENDS

LAST	segment
	assume	cs:LAST


pCOMPAQ 	label	dword		; Pointer to COMPAQ signature
		dw	0FFE8h
		dw	0F000h

szCOMPAQ    	db     '03COMPAQ'	; COMPAQ signature

pZENITH 	label	dword		; Pointer to ZENITH signature
		dw	0800Ch
		dw	0F000h

szZENITH    	db     'ZDS'		; ZENITH signature

;   local data
;
pEISAROM	label	dword
		dw	0FFD9h		; "EISA" in ROM
		dw	0F000h

AUTO_parm	db	"auto"
AUTO_LEN	equ	$-AUTO_parm

msg_tbl 	label	word
		dw	offset LAST:OverlapWarn ; User specified ranges overlap
		dw	offset LAST:Incorrect_DOS ; Incorrect Version of DOS
		dw	offset LAST:InsfMem	; Insufficient Memory
		dw	offset LAST:Already_Inst; Already Installed
		dw	offset LAST:No_PF_Avail ; No Page Frame Space Avail
		dw	offset LAST:Adj_Size	; Pool Size Adjusted
		dw	offset LAST:InvPFBA	; Page Frame Base Addr Adjusted
		dw	offset LAST:InvMRA	; Map Register Adjusted
		dw	offset LAST:InvParm	; Invalid Parameter msg
		dw	offset LAST:PFWarning	; Page Frame warning message
		dw	offset LAST:NoWeitek	; Weitek not installed
		dw	offset LAST:NoXMM	; XMS manager not installed
		dw	offset LAST:BadXMM	; Possible bad HIMEM version
		dw	offset LAST:OF_won_err	; Unable to enable WEITEK
		dw	OFFSET LAST:PF_not_3_2	; Use Pn without a page frame
		dw	offset LAST:OtherEMM	; Other EMM on system already
		dw	offset LAST:HMAonMsg 	; Virtual HMA is invalid
		dw	offset LAST:UMBmemMsg 	; No more UMB/HMA memory
		dw	offset LAST:UserAbortMsg; User aborted installation
MAX_MSG 	equ	(this byte - msg_tbl)/2 ; # of messages to display

	;   macro for printing messages located in LAST segment
	;	ENTRY: DX = offset LAST:message
PRINT_MSG	macro
	push	ds
	mov	ax,seg LAST
	mov	ds,ax		; ds = LAST
	mov	ah,PRINT_STRING
	int	MS_DOS		; output init message
	pop	ds
ENDM

page
;******************************************************************************
;	Init - Initialization routine for CEMM.
;
;	ENTRY: DS:BX pts to INIT request header.
;
;	EXIT:  AX = INIT status for request header
;		if NO errors :
;			CEMM initialized.
;			if [ON] parameter specified on command line
;			    exit in Virtual mode and CEMM active.
;			else ( [OFF] parameter specified )
;			    exit in Real mode and CEMM inactive.
;		if errors:
;			Real Mode
;	USED: none
;
;******************************************************************************
Init_CEMM386	proc	far
.8086				; 8086 code only
	mov	cs:[SYSSS],ss
	mov	cs:[SYSSP],sp

	mov	ax,seg L_STACK
	mov	ss,ax
	lea	sp,L_STACK:[LastStackTop]

	push	bx		; BP+10
	push	dx		; BP+8
	push	bp		; BP+6
	push	di		; BP+4
	push	ds		; BP+2
	push	es		; BP+0
	mov	bp,sp

;
;  initialize debugger ***** this assumes we are on a 386 *****
;
	mov	ax,seg _DATA
	mov	ds,ax
	assume	ds:_DATA

ifdef	BugMode
	mov	al,0FFh
	call	InitDeb
endif
ifdef DEBUG
	call	InitDeb
endif
;
;	initialize break address to not install
;
	mov	bx,[bp+2]		; get entry DS from stack
	mov	es,bx
	assume	es:ABS0
	mov	bx,[bp+10]		; ES:BX pts to req hdr
	mov	word ptr es:[bx.BRK_OFF],0000	; set it
	mov	ax,seg R_CODE		; get brk addr segment
     ;;;inc	ax			; reserve dos link pointer
	mov	es:[bx.BRK_SEG],ax	; break addr = cs - don't install
	mov	byte ptr es:[bx.NUM_UNITS],0	; 0 - don't install
	mov	ax,seg STACK
	mov	cs:[EndDriver],ax

;
;  verify DOS version
;
	call	chk_DOS
	jnc	short IE_proc
	jmp	ICinvdos

IE_proc:
;
;  verify processor type
;
	call	Is386			;Q: is this a 386 ?
	jnc	short IE_state 		; Y: check machine state
	jmp	ICnon386 		; N: no, set error
ifdef 910318
	jc	short inc_prc 		;  N: no, set error
                                        ;  Y: check machine state
endif
IE_state:
;
;  verify machine state
;
	push	es
	mov	ax,seg R_CODE
	mov	es,ax
	call	dword ptr es:[chkMcStateFar]
	pop	es
					;Q: is the machine in real mode
	jnc	short IE_machine	; Y: check machine type
	jmp	ICbadstate 		; N: no, set error
ifdef 910318
        jc      short IE_badstate       ; N: error
endif

.386P					; atleast a 386 at this point
IE_machine:
	mov	ax,X_HI_MEM_SEG 	; ROM segment
	mov	es,ax			; into es
	assume	es:ABS0
	mov	ax,es:X_MT_AT		; get machine type
	mov	[ROMID],al		; save machine type

ifdef 910318
	jmp	short IE_EISACheck

ifdef	ROMIDMCA
	cmp	al,ROMIDISA 		;Q: Is this an ISA/EISA class machine?
	je	short IE_EISACheck	; Y: continue
	cmp	al,ROMIDPS2		;Q: Is this a PS2 with 386 proc?
	je	short IE_EISACheck	; Y: continue
endif

inc_prc:
	jmp	ICnon386

;;IE_badstate:
;;	jmp	ICbadstate

.386P					; atleast a 386 at this point
IE_EISACheck:
endif

ifdef MSFLAG
	call	segfixup		; fix up GS & FS (see segfix.asm)
endif
	mov	ax,seg _DATA		; setup new segments
	mov	ds,ax
	mov	ax,seg R_CODE
	mov	gs,ax
	ASSUME	ds:_DATA
	ASSUME	gs:R_CODE

	call	EISACheck		; check if this is an EISA machine

	call	MCACheck		; check if this is an MCA machine

	call	IsZenith		; check to see if this is a ZENITH

IE_UserAbort:
;
;  check if special key-sequence is being pressed - if so, don't load
;
	call    Check_Install_Abort	;Q: Is user requesting an abort?
	jnc	short IE_otherEMM	; N: check for another EMM
	or	gs:[msg_flag],UserAbort_MSG
	jmp	IE_exit

IE_otherEMM:
;
;  Verify CEMM is not installed or another EMM is present
;
	call	Inst_chk
	or	ax,ax			;Q: Int 67h vector zero?
	jz	short IE_chk_pt		; Y: OK

	or	al,al			;Q: CEMM Already installed?
	jnz	short IECEMMInstalled	; Y: error, exit
;
;  Check if another EMM is already on system.
;
	mov	ah,40h			; get status function
	int	67h
	or	ax,ax			;Q: Other EMM already installed?
	jnz	short IE_chk_pt		; N: OK
	or	gs:[msg_flag],OTHER_EMM_MSG
	jmp	IE_exit
IECEMMinstalled:
	or	gs:[msg_flag],INS_ERR_MSG	; y: error
	jmp	IE_exit 		; quit
IE_chk_pt:
	call	Is386s			;Q: Is it a COMPAQ 386SX based machine?
	jne	short IE_chk_pt1	; N: no, continue
	or	gs:[GenFlags],f386SX	; Y: set flag
IE_chk_pt1:

	; Detect if channel 6 of 8237 is connected to a Columbia Data
	; Products SCSI drive.

	mov	ax, 0100h
	mov	si, 6a6ah
	xor	di,di
	int	11h
	cmp	di, 6a6ah		; Q: did DI come back with 6a6a
	jne	IE_no_CDP_SCSI		; N: No CDP SCSI
	cmp	ah, 33h			; Y: is the version > 33h
	ja	IE_no_CDP_SCSI		; Y: the drive's softare will use
					;    VDS
	mov	gs:[CDPSCSI], 1		; N: set flag to indicate that a CDP
					;    SCSI is on channel 6. Setting
					;    this flag indicates that the
					;    initial values of base,page and
					;    count on channel 6 as maintained
					;    by our data structures will be 0.
IE_no_CDP_SCSI:

					; M008 - Start
	call	IsCompaq		;Q: is it a Compaq 386
	jnz	IE_Weitek_chk		; N: no, continue
	call	IsCPQ16			; Set bit if it is a 386/16
					; M008 - end

ifndef	MSFLAG
ifdef 900105
	call	NoResetRoutine		; Y: don't need a reset routine
endif
 	call	IsP8042			;Q: Is this a password 8042 machine?
	jne	short IE_Weitek_chk	; N: no, continue
	or	gs:[GenFlags],fP8042	; Y: set flag
	mov	al,26h			; check if A20 is toggled via port 92h
	out	70h,al			; byte 26h contains CMOS bit
	in	al,71h			; get CMOS value
	test	al,20h			;Q: Port 92h used in A20 toggle?
	jz	short IE_Weitek_chk	; N: continue
	or	gs:[GenFlags],fP92	; Y: set flag
endif

IE_Weitek_chk:
	xor	eax,eax			; clear high word of AX
	int	11h
	test	eax,fI11h_Weitek_Inst SHL 16	;Q: Weitek installed ?
	jz	short IE_Toshiba		; N: check for Toshiba stuff
	or	gs:[Weitek_State],fWeitek_Inst	; Y: set installed flag

; Do Toshiba specific checks to exclude some upper memory regions
; that are used by their BIOS and power management hardware.

IE_Toshiba:
	call	SetToshibaOptions
;
;  parse command line for
;	(1) requested size for expanded memory
;	(2) page frame base address
;	(3) I/O addresses for board emulations
;	(4) Driver exit mode (virtual or real)
;
IE_parse:
	mov	bx,[bp+2]		; get entry DS from stack
	mov	es,bx
	assume	es:ABS0
	mov	bx,[bp+10]		; ES:BX pts to req hdr
	les	di,ES:[bx.ARG_PTR]	; ES:DI pts to config.sys command
					;	line parameters

	call	GetPathName		; get drivers path and name
	call	parser			; parse the parameters

	mov	ah, 2			; Force VERBOSE mode if user is
	int	16h			;   holding down the Alt key
	test	al, 08h 		; Int 16h/2 == Get Keyboard Flags
	jz	short @f		;   08h set if Alt key down
	mov	[Verbose], TRUE
@@:
	test	gs:[msg_flag],KILLER_MSG; Q: any killer messages?
	JNZ	IE_exit			; Y: exit with error

;
;  Check for memory above 16 meg on Compaq ISA systems, must buffer DMA
;  above 16 meg on these systems
;
	call	IsCompaq		; Is this a Compaq?
	jnz	IE_xmm_check

	mov	ax, 0E801h		; Compaq Get Memory Size Function
	int	15h
	jc	short IE_xmm_check	; If not supported, continue
	or	dx,dx			;Q: Is there memory configured >16MB?
	jz	short IE_xmm_check	; N: continue
	or	gs:[genflags],fabove16M ; Y:Set flag to indicate support>16M

IE_xmm_check:
	call	$chkCPQxmm		; activate non CPQ XMMs on EISA machines

	call	XMMcheck
	test	gs:[msg_flag],KILLER_MSG; Q: any killer messages?
	jnz	IE_exit			; Y: exit with error

;
;  Setup for extended memory allocation
;
IE_alloc:
;
;  Estimate amount of memory needed in extended memory!
;
	movzx	eax,cs:[max_pool_size]
	shl	eax,10			; requested EMS pool

	mov	ebx,eax
	shr	ebx,10			; memory needed for PHs
	add	eax,ebx			; 4K per PH
	add	eax,7*1024*4		; space for PTs(4),PFs(2),PD(1)

	add	eax,[DMABufferSize]	; space for DMA buffer
	movzx	ebx,[NumOfUMBwindows]	; number of UMBs
	shl	ebx,12			; each UMB is 4K
	add	eax,ebx

	cmp	cs:[HMAonSet],TRUE	;Q: Virtual HMA required?
	jne	short IEmemInit		; N: continue
	add	eax,10000h		; Y: add 64K for a virtual HMA
IEmemInit:
	call	EstWorkSpace		; EBX = estimated work space (code/data)
	add	eax,ebx
	add	eax,10000h		; leave HMA area available

	call	MemInit			; free memory in system (above 1M)
	mov	[TopOfPhysicalMemory],eax ; save top of memory
	add	eax,1000h-1		; next 4K page
	shr	eax,12			; number of PTE's needed
	mov	[MaxPTEIndex],eax 	; save max PTE index
	or	eax,eax			;Q: Atleast 4K free above 1M?
	jnz	short IE_got_mem	; Y: continue
	or	gs:[msg_flag],MEM_ERR_MSG;N: do not load
	jmp	IE_exit 		;
IE_got_mem:

; Now that memory size is know, check that min_pool_size <= max_pool_size <=
; total free memory.

	call	TotalFreeMem		; make sure max_pool <= free mem size
	shr	eax, 10 		; in k
	and	al, 0F0h		; round down to nearest 16k
	cmp	eax, MAX_SIZE
	jbe	short cmp_max_to_free
	mov	ax, MAX_SIZE
cmp_max_to_free:
	cmp	ax, [max_pool_size]
	jae	short cmp_min
	mov	[max_pool_size], ax
	cmp	[max_pool_set], TRUE	; if max was explictly set, tell user
	jne	short cmp_min		;   we changed it
	or	gs:[msg_flag], SIZE_ADJ_MSG
cmp_min:
	cmp	ax, [min_pool_size]	; check that min_pool <= free mem size
	jae	short in_range
	mov	[min_pool_size], ax
	cmp	[min_pool_set], TRUE
	jne	short in_range
	or	gs:[msg_flag], SIZE_ADJ_MSG
in_range:


ifdef ROMcomp
IE_ROMcompress:
;
; If necessary, fix all ROM pointers
;
	call	FixROMptrs
endif
;
;  Get DMA buffer and initialize for virtualizing DMA chips
;
IE_DMABuffer:
	call	DMAInit			; initialize DMA support
	test	gs:[msg_flag],KILLER_MSG;Q: Enough memory?
	jz	short IE_InitVDM	; Y: init VDM
	jmp	IE_exit			; N: do not load

;
;  Init VDM - GDT,IDT,TSS,Page Tables, WEITEK
;
IE_InitVDM:
	call	VDM_Init
	test	gs:[msg_flag],KILLER_MSG	;Q: any killer messages?
	JNZ	IE_exit	 			;  Y: exit
;
;  Allocate work space and update GDT entries.
;
IE_InitWS:
	call	WSInit
	test	gs:[msg_flag],KILLER_MSG	;Q: any killer messages?
	JNZ	IE_exit	 			;  Y: exit

IE_InitPool:
	call	GetEMSPool
	test	gs:[msg_flag],KILLER_MSG	;Q: any killer messages?
	JNZ	IE_exit	 			;  Y: exit
;
;  init EMM data
;
IE_InitEMM:
	call	EMM_Init
	test	gs:[msg_flag],KILLER_MSG	;Q: any killer messages?
ifdef	BugMode
	jz	short IE_MoveWS			;  N: move work space
else
	jz	short IE_InitDEB		;  N: init debugger
endif
	jmp	IE_exit	 			;  Y: exit
ifndef	BugMode
;
; initailize variables for debugger
;
IE_InitDEB:
ifndef DEBUG
	;call	 InitDeb
endif
endif
;
;  Move work space up to extended memory.
;
IE_MoveWS:
	call	WSMove
	test	gs:[msg_flag],KILLER_MSG	;Q: any killer messages?
	JNZ	IE_exit	 			;  Y: exit

IFDEF	QHKN
IE_chkbase:

	call	MoveExtBIOS		; move extended BIOS data area
	xor	eax,eax			; clear high order word
	int	12h			; get base memory size
	push	ax			; save it

		; The end of the driver's resident part is rounded up to
		; a 1k boundary.
	mov	ax,cs:[EndDriver]
	add	ax,40h - 1
	shr	eax,6
	add	ax,DOS3X_ADJ + 64 	; add in dos 3.xx adjustment and 64k
	pop	dx			; get base memory back
	cmp	dx,ax			; q: do we have enough?
	jae	short IE_setbrk		; y: continue
	or	gs:[msg_flag],MEM_ERR_MSG	; n: set memory error
	jmp	short IE_exit 		;    and exit

;
;   set driver break addr in Init Request Header
;
IE_setbrk:
	mov	bx,[bp+2]			; get entry DS from stack
	mov	es,bx
	assume	es:ABS0
	mov	bx,[bp+10]			; ES:BX pts to req hdr
	mov	ES:[bx.BRK_OFF],10h		; set it
	mov	ax,cs:[EndDriver]		; get brk addr segment
	mov	ES:[bx.BRK_SEG],ax		; set it
ENDIF

;
; Allocate all extended memory used
;
	xor	eax,eax				; normal allocation
	call	MemExit				; allocate all memory
	call	dword ptr gs:[checkXMMFar]	; check XMM status

ifdef	BugMode
;
;  initialize debugger before going to virtual/protected mode
;
	mov	al,0FFh
	call	InitDeb
endif
;
;   Check exit status of VDM/CEMM
;   and set CEMM active/inactive depending on the
;   mode (ON/OFF/AUTO) selected by the user.
;   In Auto Mode,
;	Weitek mapped => always ON.
;
	; default to inactive
	mov	gs:[Auto_State],0			; default to AUTO & inactive
	and	gs:[Current_State],NOT fState_Active

	; Weitek mapped ?
	test	gs:[Weitek_State],fWeitek_Map	;Q: Weitek mapping selected?
	jz	short IE_InitState		;  N: AUTO => inactive
	or	gs:[Auto_State],fAuto_Weitek	;  Y: AUTO => active

IE_InitState:
	mov	al,gs:[Initial_Mode]		; get initial mode
	mov	gs:[Current_Mode],al		; set it

	cmp	al,MODE_AUTO			;Q: exit in Auto mode ?
	jne	short IE_ModeChkOFF		;  N: check for mode = OFF
	cmp	gs:[Auto_State],0		;  Y: Q: go active ?
	je	short IE_ModeSet		;	N: ok, mode is set
	jmp	short IE_ModeActive		;	Y: go active now ...

IE_ModeChkOFF:
	cmp	al,MODE_OFF			;Q: exit mode is OFF ?
	jne	short IE_ModeActive		;  N: mode is ON, turn CEMM on
	mov	[Devname],'$'
	jmp	short IE_ModeSet		;  Y: ok, mode is set
IE_ModeActive:
	call	FarGoVirtual			; go to virtual mode
	jc	ICnon386
	or	gs:[Current_State],fState_Active; set active flag

IE_ModeSet:
;
;  exit - display status messages and set exit status
;
IE_exit:
;
;  display signon message first
;
	mov	ax,R_CODE
	mov	ds,ax
	assume	ds:R_CODE
	cmp	[msg_flag], 0		; Q: any msgs to display?
	jnz	short disp_signon	; Y: disp signon msg even if !verbose
	cmp	[Verbose], TRUE 	; N: skip signon unless verbose mode
	jnz	short skip_signon
disp_signon:
	mov	[Verbose], TRUE
	call	I_Message_Display
skip_signon:

;
; check for messages to display
;
	mov	ecx,MAX_MSG		; number of potential msgs
	mov	si,offset msg_tbl	; table of messages
	mov	ebx,1			;
m_loop:
	test	[msg_flag],ebx		; q:is this one set?
	jz	short m_inc_ptr		; n: increment table pointer
	mov	dx,cs:[si]		; y: display message
	PRINT_MSG
m_inc_ptr:
	ADD	SI, 2			; Increment msg table ptr
	shl	ebx,1			; Look for next flag
	loop	m_loop

	TEST	[msg_flag],KILLER_MSG	;Q: Is there a killer?
	jnz	IE_not_installed	; Y: Don't install

	CMP	[msg_flag], 0		; Q: Is there a warning?
	JE	SHORT no_KLLR_MSG	; N: Continue
	CALL	wait_key		; Wait for 10 seconds

no_KLLR_MSG:

ifdef DEBUG
	bt	[GenFlags],fDebugActiveBit
	jnc	IE_NoDebug

	or	[TrapFlags],fpModeDebInit	; protected mode debugger
	int	ProtTrap			;   initialization

IE_NoDebug:
endif
	pushf
	cli
;
; Initialize Virtual HMA
;
	call	VirHMAinit
;
; Add real mode interrupt handlers
;
	call	PICVecInit

ifdef ROMcomp
;
; Fixup IVT for ROM compression
;
	call	FixIVTptrs
endif
	xor	ax,ax
	mov	es,ax
	ASSUME	es:ABS0

; Add an INT 15h handler
	mov	ax,seg R_CODE
	shl	eax,16
	mov	ax,offset R_CODE:rINT15hHandler
	xchg	es:[int15],eax
	mov	[PrevInt15],eax

; Add CEMM to INT 19h chain.
	mov	ax,seg R_CODE
	shl	eax,16
	mov	ax,offset R_CODE:rINT19hHandler
	xchg	es:[int19],eax
	mov	[PrevInt19],eax

; Add CEMM to INT 2Fh chain.
	mov	ax,seg R1_CODE
	mov	fs, ax
	shl	eax,16
	mov	ax,offset R1_CODE:rINT2FhHandler
	xchg	es:[int2f],eax
	mov	dword ptr fs:[PrevInt2f],eax

; Add CEMM to INT 4Bh chain.
	mov	ax,seg R1_CODE
	shl	eax,16
	mov	ax,offset R1_CODE:rINT4BhHandler
	xchg	es:[int4B],eax
	mov	fs:[PrevInt4B],eax

; The int 67h vector is now patched out with CEMM's routine.
	mov	es:[int67],offset R_CODE:EMM_rEntry
	mov	es:[int67+2],seg R_CODE

; Add an INT 13h handler
	call	Install_I13handler

;
; Chain possible UMB links
;
	call	UMBlink

	call	MovUmbSeg
	popf				; restore interrupt flag state

	call	MoveExtBIOS		; move extended BIOS data area
	xor	eax,eax			; clear high order word
	int	12h			; get base memory size
	push	ax			; save it

		; The end of the driver's resident part is rounded up to
		; a 1k boundary.
	mov	ax,cs:[EndDriver]
	add	ax,40h - 1
	shr	eax,6
	add	ax,DOS3X_ADJ + 64 	; add in dos 3.xx adjustment and 64k
	pop	dx			; get base memory back
	cmp	dx,ax			; q: do we have enough?
	jae	short IE_setbrk		; y: continue
	or	gs:[msg_flag],MEM_ERR_MSG	; n: set memory error
	jmp	IE_exit 		;    and exit

;
;   set driver break addr in Init Request Header
;
IE_setbrk:
	mov	bx,[bp+2]			; get entry DS from stack
	mov	es,bx
	assume	es:ABS0
	mov	bx,[bp+10]			; ES:BX pts to req hdr
	mov	ES:[bx.BRK_OFF],10h		; set it
	mov	ax,cs:[EndDriver]		; get brk addr segment
	mov	ES:[bx.BRK_SEG],ax		; set it

	cmp	[Verbose], TRUE 		; Exit vocally?
	jnz	IE_Success			;  N: keep quiet

	mov	ax,seg LAST
	mov	es,ax
	assume	es:LAST                 ; destination of message

	mov	dx,offset LAST:InstallMess
	PRINT_MSG

	mov	ax,R_CODE
	mov	ds,ax
	assume	ds:R_CODE

	call	E_XStatus_Display
	;
	; output messages displaying state of Weitek support
	;
	test	[Weitek_State],fWeitek_Inst	;Q: Weitek installed ?
	jz	short prnw_done			;  N: no messages then
	mov	dx,offset LAST:WeitekONMess	;  Y: assume Weitek ON
	test	[Weitek_State],fWeitek_Map	;Q: Weitek enabled ?
	jnz	short print_weitek			;  Y: display message
	mov	dx,offset LAST:WeitekOFFMess	;  N: assume OFF
print_weitek:
	PRINT_MSG

	; chk for Weitek not accessible
	cmp	[Initial_Mode],MODE_OFF 	;Q: CEMM OFF specified ?
	jne	short prnw_done			;  N: no more messages
	mov	dx,offset LAST:WeitekNAMess	;  Y: W not accessible
	PRINT_MSG
prnw_done:
;
;   output messages displaying current mode
;
	mov	dx,offset LAST:OFFMess
	cmp	[Current_Mode],MODE_OFF		;Q: OFF mode ?
	je	short print_mode		;  Y: print it's message

	cmp	[Current_Mode],MODE_AUTO	;Q: auto mode ?
	jne	short print_ONOFF		;  N: check for ON/OFF
	mov	dx,offset LAST:AutoMess 	;  Y: display AUTO mode message
	PRINT_MSG				;

print_ONOFF:
	mov	dx,offset LAST:InactiveMess	; assume inactive
	test	[Current_State],fState_Active	;Q: Active ?
	jz	short print_mode		;   N: display OFF message
	mov	dx,offset LAST:ActiveMess	;   Y: display ON message
print_mode:
	PRINT_MSG
;
; all done with no errors
;
IE_Success:
	xor	ax,ax			; NO errors
;
.8086					; Must be in 8086 instructions
IE_leave:
	pop	es
	pop	ds
	pop	di
	pop	bp
	pop	dx
	pop	bx

	mov	ss,cs:[SYSSS]	; restore DOS stack
	mov	sp,cs:[SYSSP]

	ret
;
.386p
IE_not_installed:
	mov	eax,-1			; abort in progress
	call	MemExit			; put back memory we took

.8086					; Must be in 8086 instructions
ICerror:
	call	ErrorExit		; Clean up on error condition
ICerror1:
	call	wait_key		; pause to let user read error

	mov	ax,ERROR		; error return
	jmp	short IE_leave

ICnon386:
	mov	dx,offset LAST:Incorrect_PRT
        jmp     short ICmessPrint

ICinvdos:
	mov	dx, offset LAST:Inv_DOS_msg
	jmp	short ICmessPrint

ICbadstate:
	mov	dx, offset LAST:bad_mc_state

ICmessPrint:
	PRINT_MSG
        jmp     short ICerror1
;
Init_CEMM386	endp


.386p					; Here can be 386P?
page
;******************************************************************************
;
;	parser - parse out CEMM parameters and set appropriate values.
;
;			entry:	es:di ==  config.sys command line parameters
;				ds = _DATA
;                     		386 systems only
;			exit:	[min/max_pool_size] = expanded memory sizes
;				[Initial_Mode] = mode for driver exit
;				[msg_flag] = appropriate messages to display
;				... many others ...
;
;			used:	none
;
;******************************************************************************
;
	ASSUME	CS: LAST, DS: _DATA, GS: R_CODE
Parser	PROC
	PUSHA
	PUSH	DS
	PUSH	ES
	PUSH	FS
	MOV	SI, _DATA
	MOV	FS, SI
	ASSUME	FS: _DATA

	MOV	SI, DI
	MOV	DI, ES			; Move ES:DI to DS:SI
	MOV	DS, DI

	MOV	DI, LAST		; ES:DI points to token buffer
	MOV	ES, DI
	ASSUME	ES: LAST

	MOV	DI, OFFSET tknBuf
	CLD				; Direction set to increment
	CALL	Get_Token		; Skip the first token
	JCXZ	no_token
nexToken:
;
; CX = Get_Token(DS:SI, ES:DI);
;
	CALL	Get_Token
	JCXZ	no_token
	CALL	Parse_Token
	JMP	nexToken
no_token:
	MOV	AX, _DATA
	MOV	DS, AX
	ASSUME	DS: _DATA

	cmp	gs:[Initial_Weitek],0FFh; Q: did they specifiy Weitek mode ?
	je	short def_mode		; N: ok, leave it off
	test	gs:[Weitek_State],fWeitek_Inst	;Q: Weitek installed ?
	jz	short setwm_notpres		;  N: set msg flag
	cmp	gs:[Initial_Weitek],0		;  Y:Q: Weitek OFF ?
	je	short setwm_done		;      Y: leave flag off
	or	gs:[Weitek_State],fWeitek_Map	;      N: set flag -> ON
	jmp	SHORT setwm_done
setwm_notpres:
	or	gs:[msg_flag],W_NI_MSG	; warning flag set
setwm_done:

def_mode:
	cmp	gs:[Initial_Mode],0FFh		;Q: did they specify mode ?
	jne	short def_mode2			; Y: ok ...
ifdef MSFLAG
	mov	gs:[Initial_Mode],MODE_ON	; N: default is ON MODE (MS)
else
	mov	gs:[Initial_Mode],MODE_AUTO	; N: default is AUTO MODE (CPQ)
endif
def_mode2:
	cmp	byte ptr cs:[RAMset],2	;Q: RAM specified?
	jne	short def_ON		; Y: turn CEMM ON
ifdef 901022
	cmp	byte ptr cs:[ROMset],2	;Q: ROM specified?
	jne	short def_ON		; Y: turn CEMM ON
endif
	cmp	cs:[UMBset],TRUE	;Q: RAM specified?
	je	short def_ON		; Y: turn CEMM ON
	cmp	cs:[HMAonSet],TRUE	;Q: Virtual HMA requested?
	je	short def_ON		; Y: turn CEMM ON
	cmp	gs:[NoPFset],TRUE	;Q: FRAME=NONE specified?
	je	short def_ON		; Y: turn CEMM ON
	cmp	gs:[NoEMSset],TRUE	;Q: NoEMS specified?
	jne	short def_size		; Y: turn CEMM ON
def_ON:
	mov	gs:[UMBHMA],TRUE	; CEMM is providing UMBs or an HMA
	mov	gs:[Initial_Mode],MODE_ON; turn CEMM ON

def_size:
ifdef 910611
	cmp	cs:[pool_size],0	;Q: Did user specify size?
	jnz	short P_locate_windows	; Y: OK
	mov	cs:[pool_size],256	; N: default to 256K
P_locate_windows:
endif

	call	NoEMScheck

;  Make sure that the MIN and MAX EMS pool sizes make sense.  The
;  min_pool_size must be <= max_pool_size which must be <= total free memory.
;  If the max or min need to be adjusted from a value explictly set by the
;  user, flag the SIZE_ADJ_MSG.  Either or both parameters can be defaulted,
;  and if the user selects a min > max, raise the max.	We don't know how
;  much free memory is available at this time so that needs to be checked
;  later.

	mov	ax, [min_pool_size]	; make sure min_pool_size <= max_pool
	cmp	ax, [max_pool_size]
	jbe	short sizes_ok
	cmp	[min_pool_set], TRUE	; if MIN=size explictly given, adjust
	je	short adj_max		;   the max value up
	mov	ax, [max_pool_size]	; otherwise adjust the defaulted min
	mov	[min_pool_size], ax	;   value down
	jmp	short sizes_ok
adj_max:
	mov	[max_pool_size], ax
	cmp	[max_pool_set], TRUE	; if max was explictly set, tell user
	jne	short sizes_ok		;   we changed it
	or	gs:[msg_flag], SIZE_ADJ_MSG
sizes_ok:

;
; The EMS windows are located and the page frame is selected.
;
	call	FindWindowLocations
	cmp	gs:[PF_Base], FREE
	jne	SHORT P_check_for_warning

	cmp	gs:[NoEMSset],TRUE	;Q: NoEMS set?
	je	short parse_xit		; Y: continue

	cmp	gs:[NoPFset],TRUE	;Q: FRAME=NONE set?
	je	short parse_xit		; Y: continue

		; If this is reached then there are no valid page frames
	CMP	[xma2ems], TRUE		; Q: Is it in XMA2EMS mode?
	JNE	SHORT no_PF_no_XMA	; N: Bad!
	OR	GS:[msg_flag], NO_LIM_PF_MSG ; Set error flag
	JMP	SHORT P_check_for_warning
no_PF_no_XMA:
		; Set the message flag and load with NOEMS
	OR	GS:[msg_flag], NO_PF_MSG

	mov	gs:[NoEMSset], TRUE	; set NOEMS mode
	JMP	def_mode		; and try again

		; If the user supplied page frame has ROM in it then print
		; out a warning to him.
P_check_for_warning:
	cmp	cs:[PFB_warning],FALSE
	je	short parse_xit
	or	gs:[msg_flag],PF_WARN_MSG
parse_xit:				; restore registers and exit

	POP	FS
	POP	ES
	POP	DS
	POPA
	RET
Parser	ENDP

;******************************************************************************
;   Get_Token - Retrieves a token from DS:SI and stores it at ES:DI
;
;   ENTRY:	DS:SI points to string where a token is to be retrieved
;		ES:DI points to a buffer where a token is to be stored
;   EXIT:	DS:SI points to string where tokens remain to be retrieved
;		CX is the number of characters in ES:DI
;   USED:	CX, SI
;   STACK:	<amount of stack used by routine>
;------------------------------------------------------------------------------
	public	Get_Token
Get_Token	PROC
	PUSH	AX
	PUSH	DI
;
; while (DS[SI] == ' ' || DS[SI] == '\t') SI++;
;
SPorTB:					; Skip all white characters
	LODSB				; Get a character
	CMP	AL, ' '			; Q: Is it a space?
	JE	SPorTB			; Y: Skip it
	CMP	AL, TB			; Q: Is it a tab?
	JE	SPorTB			; Y: Skip it
;
; CX = 0;
; do {
;   if (DS[SI] == CR || DS[SI] == LF || DS[SI] == ' ' || DS[SI] == '\t')
;     break;
;   CX++;
;   ES[DI++] = toupper(DS[SI++]);
; } while (1);
; ES[DI++] = '\0';
;
	XOR	CX, CX			; Initialize counter
checkCH:
	CMP	AL, CR			; Q: Is this character a CR?
	JE	SHORT EOToken		; Y: it's the end of the token
	CMP	AL, LF			; Q: Is this character a LF?
	JE	SHORT EOToken		; Y: it's the end of the token
	CMP	AL, ' '			; Q: Is this character a space?
	JE	SHORT EOToken		; Y: it's the end of the token
	CMP	AL, TB			; Q: Is this character a tab?
	JE	SHORT EOToken		; Y: it's the end of the token
	INC	CX			; N: it's a valid character in token
	CMP	AL, 'a'			; Q: Is it less than 'a'?
	JB	SHORT storeAL		; Y: not 'a'..'z'
	CMP	AL, 'z'			; Q: Is it greater than 'z'?
	JA	SHORT storeAL		; Y: not 'a'..'z'
	AND	AL, NOT 20h		; Convert to 'A'..'Z'
storeAL:
	STOSB				; Store the character
	LODSB				; Retrieve another character
	JMP	checkCH
EOToken:
	XOR	AL, AL			; End of string
	STOSB
	POP	DI
	POP	AX
	RET
Get_Token	ENDP

;******************************************************************************
;   Parse_Token - Checks the validity of a token, and keeps it when valid
;
;   ENTRY:	ES:DI points to a buffer where a token is stored
;   EXIT:
;   USED:
;   STACK:	<amount of stack used by routine>
;------------------------------------------------------------------------------
	public	Parse_Token
Parse_Token	PROC
	PUSHAD
	PUSH	DS
	MOV	AX, LAST
	MOV	DS, AX
	ASSUME	DS: LAST

	MOV	SI, DI
	LODSB				; Get a character
	MOVZX	BX, AL
	MOVZX	EBX, BYTE PTR case[BX]
	JMP	switch[EBX*4]

Get_H:
	cmp	dword ptr ds:[si-1], 'HGIH' ; Q: HIGHSCAN?
	jne	HMAonParm
	cmp	dword ptr ds:[si+3], 'NACS'
	jne	HMAonParm
	mov	cs:[Highscan], TRUE
	add	si, 7
	jmp	PT_exit

HMAonParm:
	cmp	dword ptr ds:[si],'NOAM';Q: Is it HMAon parameter?
	je	short HMAon		; Y: process it
	LODSB
	CMP	AL, '='			; Is it H=ddd?
	JNE	inv_parm
is_$H:
;
; DX:AX = Get_Decimal(DS:SI);
;
	CMP	[$Hset], 0
	JNE	inv_parm
	CALL	Get_Decimal
	JC	inv_parm
	OR	DX, DX
	JNZ	inv_parm
	CMP	AX, 2
	JB	inv_parm
	CMP	AX, 255
	JA	inv_parm
	MOV	FS:[total_handles], AX
	MOV	GS:[ttl_hndls], AX
	MOV	[$Hset], NOT 0
	JMP	PT_exit
HMAon:
	add	si,4
	lodsb
	cmp	al,'='			;Q:HMAon=n?
	jne	short HoCont		; N: continue
	call	Get_Decimal		; Y: get minimum HMA size for allocation
	jc	inv_parm
	or	dx,dx			;Q: Invalid number (0<=n<=63)
	jnz	inv_parm		; Y: invalid parameter
	cmp	ax,63                   ;Q: Valid range (0<=n<=63)?
	ja	inv_parm		; N: invalid parameter
	shl	ax,10			; Y: mult by 1024 (1K)
	mov	fs:[HMAmin],ax		; and save for HMA min alloc size
;
;  Make sure this machine needs a virtual HMA
;
HoCont:
	mov	cs:[HMAonSet],TRUE
	mov	ax,8800h
	int	15h
	or	ax,ax
	jnz	short HoMsg
	mov	al,31h
	call	r_cmos
	mov	ah,al
	mov	al,30h
	call	r_cmos
	or	ah,al
	jnz	short HoMsg
	jmp	PT_exit
HoMsg:
	or	gs:[msg_flag],HMAon_MSG
	mov	cs:[HMAonSet],FALSE
	jmp	PT_exit

Get_P_Handle_Page_Frame:		; /
	LODSB
	CMP 	AL,'H'   		; Is it /Hddd?
	je	is_$H
	cmp	al,'P'			; Is it /Phhhh?
	je	short check_$P
	movzx	bx,al			; skip the "/" and continue processing
	movzx	ebx,byte ptr case[bx]
	jmp	switch[ebx*4]

check_$P:
	CMP	AL, 'P'			; Is it /Phhhh?
	JNE	inv_parm
;
; DX:AX = Get_Hexadecimal(DS:SI);
;
	CMP	GS:[PF_Base], FREE	; Q: Has the page frame been set?
	JNE	inv_parm		; Y: bad!
is_$P:
	CALL	Get_Hexadecimal
	JC	inv_parm
	OR	DX, DX
	JNZ	inv_parm
;
; ZF = Frame_Check(AX, CX);
;
	cmp	cs:[NoPFCset],TRUE	;Q: Check for valid page frame?
	je	short is_$P1		; N: skip check
	mov	cx,numFram		; Total number of valid page frames
	CALL	Frame_Check
	JNZ	inv_parm
is_$P1:
	MOV	GS:[PF_Base], AX
	JMP	PT_exit

Get_Size:				; 0123456789
	cmp	cs:[max_pool_set], TRUE ; Q: Has the max pool size been set?
	je	inv_parm		; Y: error
	DEC	SI
	CALL	Get_Decimal
	JC	inv_parm
	OR	DX, DX
	JZ	SHORT checkAX
	MOV	AX, MAX_SIZE
	JMP	SHORT size_err
checkAX:
	CMP	AX, MIN_SIZE
	JAE	SHORT check_MAX
	MOV	AX, MIN_SIZE
	JMP	SHORT size_err
check_MAX:
	CMP	AX, MAX_SIZE
	JA	SHORT use_MAX
	TEST	AL, 0Fh 		; Q: Is it a multiple of 16K?
	JZ	SHORT size_ok		; Y: Set pool size
	AND	AL, NOT 0Fh		; N: Round it down
	JMP	SHORT size_err
use_MAX:
	MOV	AX, MAX_SIZE
size_err:
	OR	GS:[msg_flag], SIZE_ADJ_MSG
size_ok:
	MOV	cs:[max_pool_size], AX
	mov	cs:[max_pool_set], TRUE
	JMP	PT_exit

Get_Mode_Alt_Reg_Sets:			; A
	LODSB
	CMP	AL, '='
	JNE	SHORT AltBootParm
	CMP	[altRset], 0
	JNE	inv_parm
	CALL	Get_Decimal
	JC	inv_parm
	OR	DX, DX
	JNZ	inv_parm
	CMP	AX, MAX_ALT_REG_SETS
	JA	inv_parm
	INC	AX
	MOV	FS:[total_register_sets], AL
	MOV	[altRset], NOT 0
	JMP	PT_exit

AltBootParm:
	cmp	dword ptr ds:[si-1], 'OBTL' ; Q: ALTBOOT?
	jne	short check_AUTO
	cmp	word ptr ds:[si+3], 'TO'
	jne	short check_AUTO
	.erre	fTurnOffNOW AND 0FF00h
	or	byte ptr gs:[genflags+1], fTurnOffNOW SHR 8
	add	si, 6
	jmp	PT_exit

check_AUTO:
	CMP	GS:[Initial_Mode], FREE	; Q: Has the mode been set?
	JNE	inv_parm		; Y: bad!
	SUB	SI, 2
	MOV	DI, OFFSET op_auto
	MOV	CX, AUTOLEN
	REPE	CMPSB
	JNZ	inv_parm
	MOV	GS:[Initial_Mode], MODE_AUTO
	JMP	PT_exit
Get_Lowest_Frame:			; B
	CMP	[baseset], 0
	JNE	inv_parm
	LODSB
	CMP	AL, '='
	JNE	inv_parm
	int	12h			; Get conventional memory size QLEO
	shl	ax,6			; In paragraph                 QLEO
	mov	bx,ax			;			       QLEO
	CALL	Get_Hexadecimal
	JC	inv_parm
	OR	DX, DX
	JNZ	inv_parm
	CMP	AX, 1000h		; At least 1000h
	JB	inv_parm
	cmp	ax,bx			;Q: Check upper limit?         QLEO
	jbe	short GLFcont		; N: OK, continue              QLEO
	mov	ax,bx                   ; Y: Use INT 12h size	       QLEO
;QLEO	CMP	AX, 04000h		; At most 4000h                QLEO
;QLEO	JA	inv_parm                                               QLEO
GLFcont:				;                              QLEO

	ADD	AX, 3FFh		; In case it's between 16K frames
	AND	AX, NOT 3FFh		; Must be 16K increment
	XOR	EBX, EBX
	MOV	BX, R_CODE
	SHL	EBX, 4
	ADD	BX, OFFSET end_of_R_CODE
	SHR	EBX, 4
	ADD	EBX, 3FFh
	AND	EBX, NOT 3FFh
	CMP	BX, AX			; Q: Is the B= below R_CODE?
	JB	SHORT use_original	; N: Use B=
	MOV	AX, BX			; Y: Use window above R_CODE
use_original:
	dec	ax
	mov	cs:[Bparm],ax
	inc	ax
	SHR	AX, 8
	MOV	FS:[strtng_bs_wndw_PTE], AX
	MOV	[baseset], NOT 0
	JMP	PT_exit
Get_DMA_Buffer_Size:			; D
	cmp	dword ptr ds:[si],'TXAM'; DMAXT?
	jne	short GDBScont
	or	fs:[DMAFlags],fDMABuffXT; put DMA buffer in first meg
	add	si,4
	jmp	PT_exit

GDBScont:
	CMP	[bDMAset], 0
	JNE	inv_parm
	LODSB
	CMP	AL, '='
	JNE	inv_parm
	XOR	EAX, EAX
	CALL	Get_Decimal
	JC	inv_parm
	OR	DX, DX
	JNZ	inv_parm
	CMP	AX, 16
	JB	inv_parm
	CMP	AX, 256
	JA	inv_parm
	SHL	EAX, 10			; In bytes
	MOV	FS:[DMABufferSize], EAX
	MOV	[bDMAset], NOT 0
	JMP	PT_exit
Get_Page_Frame:				; F
	CMP	GS:[PF_Base], FREE	; Q: Has the page frame been set?
	JNE	inv_parm		; Y: Bad!
	DEC	SI			; Compare the whole "FRAME=" string
	MOV	DI, OFFSET frame$
	MOV	CX, framLen
	REPE	CMPSB
	JNZ	inv_parm
	cmp	dword ptr [si],'ENON'	;Q: "FRAME=NONE"
	jne	is_$P			; N: try hexadecimal number
	mov	gs:[NoPFset],TRUE	; Y: mark no page frame
	add	si,4
	jmp	PT_exit
Get_Left_Alone_Size:			; L
	CMP	[ext_mem], FREE
	JNE	inv_parm
	LODSB
	CMP	AL, '='
	JNE	inv_parm
	CALL	Get_Decimal
	JC	inv_parm
	test	dx,not 3Fh		;Q: Greater than 4GB (in KB increments)?
	JNZ	inv_parm		; Y: invalid!
	or	dx,dx			;Q: Greater than 64MB?
	jnz	short GLASok		; Y: OK
	OR	AX, AX			; At least 1 KB
	JZ	inv_parm
GLASok:
	MOV	word ptr [ext_mem], AX
	MOV	word ptr [ext_mem][2],dx
	JMP	PT_exit
NoMoveXBDA:				  ; N undocumented NOMOVEXTBIOS
	cmp	dword ptr ds:[si-1],'OMON';Q: correct switch?
	jne	short NoEMS		  ; N: check for "NOEMS"
	cmp	dword ptr ds:[si+3],'BXEV';Q: correct switch?
	jne	inv_parm		  ; N: Bad!
	cmp	word ptr ds:[si+7],'AD'	  ;Q: correct switch?
	jne	inv_parm		  ; N: Bad!
	or	gs:[GenFlags],fXBDAnotRel ; Y: don't move Extended BIOS data area
	add	si,9
	JMP	PT_exit
NoEMS:
	cmp	dword ptr ds:[si],'SMEO';Q: "NOEMS"?
	jne	short NoINTparm		; N: Check if "NoINT parameter is indicated
	mov	gs:[NoEMSset],TRUE	; Y: set flag
	add	si,4
	jmp	PT_Exit
NoINTparm:
	cmp	dword ptr ds:[si],'TNIO';Q: correct switch?
	jne	short NoLocUMBparm	; N: Check for "NoLocUMBs" parameter.
	or	gs:[GenFlags],fNoINT	; Y: set flag for no interrupts
	add	si,4
	jmp	PT_exit
NoLocUMBparm:
ifndef MSFLAG
	cmp	dword ptr ds:[si],'COLO'  ;Q: correct switch?
	jne	short NoPFCparm		  ; N: Check for "NoPFC" parameter.
	cmp	dword ptr ds:[si+4],'SBMU';Q: correct switch?
	jne	short NoPFCparm		  ; N: Check for "NoPFC" parameter.
	or	gs:[GenFlags],fNoLocUMB   ; Y: set flag for no interrupts
	add	si,8
	jmp	PT_exit
endif
NoPFCparm:
	cmp	dword ptr ds:[si],'CFPO';Q: correct switch?
	jne	NoA20TrapParm		; N: Bad!
	mov	cs:[NoPFCset],TRUE	; Y: Don't check page frame addresses
	add	si,4
	jmp	PT_exit

ifndef LC910611
NoA20TrapParm:
	cmp	dword ptr ds:[si],'02AO'  ;Q: correct switch?
	jne	short NoVCPIparm	  ; N:
	cmp	dword ptr ds:[si+4],'PART';Q: correct switch?
	jne	short NoVCPIparm	  ; N:
	or	gs:[GenFlags],fNoA20Trap  ; Y: don't trap A20 line
	add	si,8
	jmp	PT_exit
endif

NoVCPIparm:
	cmp	dword ptr ds:[si], 'PCVO'   ; Q: NOVCPI?
	jne	short NoHighparm
	cmp	byte ptr ds:[si+4],'I'
	jne	short NoHighparm
	mov	cs:[NoVCPI], TRUE
	add	si, 5
	jmp	PT_exit

NoHighparm:
	cmp	dword ptr ds:[si],'IHO';Q: "NOHI"?
	jne	NoTRparm
	mov	cs:[NoHigh],TRUE	; Y: set flag
	add	si,3
	jmp	PT_Exit

NoTRparm:
	cmp	dword ptr ds:[si],'RTO' ; Q: NOTR?
	jne	inv_parm		; N: Bad!
	mov	cs:[NoTR], TRUE
	add	si, 3
	jmp	PT_exit

Get_M:					; M
	cmp	word ptr ds:[si],'NI'	; Q: MIN=?
	jne	Get_Window_Frame
	add	si, 2
	lodsb
	cmp	al, '='
	jne	inv_parm
	cmp	cs:[min_pool_set], TRUE ; Q: already set min pool size?
	je	inv_parm		; Y: error
	call	Get_Decimal
	jc	inv_parm
	or	dx, dx
	jz	checkMinAX
	mov	ax, MAX_SIZE
	jmp	short min_size_err
checkMinAX:
	cmp	ax, MAX_SIZE
	ja	useMaxPool
	test	al, 0Fh
	jz	short min_size_ok
	and	al, NOT 0Fh
	jmp	short min_size_err
useMaxPool:
	mov	ax, MAX_SIZE
min_size_err:
	or	gs:[msg_flag], SIZE_ADJ_MSG
min_size_ok:
	mov	cs:[min_pool_size], ax
	mov	cs:[min_pool_set], TRUE
	jmp	PT_exit

Get_Window_Frame:			; Mx
	CMP	GS:[PF_Base], FREE	; Q: Has the page frame been set?
	JNE	inv_parm		; Y: Bad!
	CALL	Get_Decimal
	JC	inv_parm
	OR	DX, DX
	JNZ	inv_parm
	OR	AX, AX			; At least 1
	JZ	inv_parm
	CMP	AX, 14			; At most 14
	JA	inv_parm
	MOV	BX, LAST
	MOV	DS, BX
	ASSUME	DS: LAST

	DEC	AX
	ADD	AX, AX
	MOV	BX, AX
	ADD	BX, OFFSET frames
	MOV	AX, [BX]
	MOV	GS:[PF_Base], AX
	JMP	PT_exit
Get_On_Off_Mode:			; O
	CMP	GS:[Initial_Mode], FREE	; Q: Has the mode been set?
	JNE	inv_parm		; Y: Bad!
	DEC	SI			; Retrieve last character
	MOV	BX, SI			; Save SI in case it's not ON
	MOV	DI, OFFSET op_on
	MOV	CX, ONLEN
	REPE	CMPSB
	JNZ	SHORT check_off
	MOV	GS:[Initial_Mode], MODE_ON
	JMP	PT_exit
check_off:
	MOV	SI, BX			; Retrieve SI
	MOV	DI, OFFSET op_off
	MOV	CX, OFFLEN
	REPE	CMPSB
	JNZ	inv_parm
	MOV	GS:[Initial_Mode], MODE_OFF
	JMP	PT_exit
Get_I_Page_Frame:			; P
	CALL	Get_Decimal
	JNC	inv_parm
	CMP	AX, 3			; Q: Is this P0..P3?
	JNA	SHORT check_equal	; Y:
check_254:
	CMP	AX, 254			; Q: Is this in P254..P255?
	JB	inv_parm		; N:
	OR	AH, AH			; Q: Is this in P254..P255?
	JNZ	inv_parm		; N:
	SUB	AX, 250			; Get the proper index
check_equal:
ifdef PICtrap
	cmp	word ptr ds:[si-1],'CI'	;Q: Undocumented "PIC" switch?
	je	short PICVec		; Y: get values
endif
	MOV	BX, AX
	CMP	pn[BX], FREE		; Q: Is this P already set?
	JNE	inv_parm		; Y: error
	CMP	BYTE PTR DS:[SI-1], '='	; Q: Is '=' present?
	JNE	inv_parm		; N: error
	CALL	Get_Hexadecimal		; Retrieve the number following '='
	JC	inv_parm		; If number is invalid, error
	OR	DX, DX			; Q: Is number too big?
	JNZ	inv_parm		; Y: error
	cmp	cs:[NoPFCset],TRUE	;Q: Check for valid page frame?
	je	short PFok		; N: skip check
	MOV	CX, numPFrm		; Total number of valid windows
	CALL	Frame_Check		; Q: Is this P valid?
	JNZ	inv_parm		; N: error
PFok:
	XCHG	AH, AL
	MOV	CX, 6			; Compare this P with others
	MOV	DI, OFFSET pn
	REPNE	SCASB			; Q: Is this P a duplicate?
	JE	inv_parm		; Y: error
pn_okay:
	MOV	Pn[BX], AL		; N: store this P
	BTS	[PnSet], BX		; Set flag for this Pn
	JMP	PT_exit			; Done for this parameter
ifdef PICtrap
PICVec:
	cmp	word ptr ds:[si+1],':S'	;Q: Undocumented "PICS:" switch?
	je	short PICSVec		; Y: get values
	cmp	word ptr ds:[si+1],':M'	;Q: Undocumented "PICM:" switch?
	jne	inv_parm		; N: error
	add	si,3
	call	Get_Hexadecimal
	jc	inv_parm
	mov	gs:[MasterPICVec],ax
	jmp	PT_exit
PICSVec:
	add	si,3
	call	Get_Hexadecimal
	jc	inv_parm
	mov	gs:[SlavePICVec],ax
	jmp	PT_exit
endif

EMSInts:				  ; EMS=FROM-TO
	cmp	dword ptr ds:[si],'NISM'  ;Q: "EMSINTS" switch?
	jne	short EMSrange		  ; N: "EMS=" parameter?
	cmp	word ptr ds:[si+4],'ST'	  ;Q: "EMSINTS" switch?
	jne	short EMSrange		  ; N: "EMS=" parameter?
	add	si,6			  ; Y: get to "=" sign
	and	gs:[GenFlags],not fNoEMSInt ; clear flag for no EMS interrupts
	jmp	PT_exit
EMSrange:				  ; EMS=FROM-TO
	cmp	dword ptr ds:[si-1],'=SME';Q: "EMS=" switch?
	jne	inv_parm		  ; N: invalid parameter
	add	si,2			  ; Y: get to "=" sign
	lea	bx,[EMSSet]
	jmp	GetRange

GetRAM:
	cmp	dword ptr ds:[si-1],'=MOR';Q: "ROM=" switch?
	je	short ROMrange		  ; Y: get range
	cmp	dword ptr ds:[si-1],'=MAR';Q: "RAM=" switch?
	je	short RAMrange		  ; Y: get range
	cmp	word ptr ds:[si],'MO'	;Q: "ROM" switch?
	je	short ROMparam		  ; Y: get range
	cmp	word ptr ds:[si],'MA'	;Q: "RAM" switch?
	jne	inv_parm		; N: invalid parameter
	mov	cs:[UMBset],TRUE
	add	si,3
	jmp	PT_exit
RAMrange:           			; RAM=FROM-TO
	add	si,2			; get to "=" sign
	lea	bx,[RAMSet]
	jmp	GetRange
ROMrange:           			; ROM=FROM-TO
	add	si,2			; get to "=" sign
	lea	bx,[ROMSet]
	jmp	GetRange
ROMparam:           			; ROM(COMPRESS)
	dec	si			; start at "R" again
	mov	cs:[ROMparm],TRUE	; assume it compares
	push	es			; save current ES
	push	cs			; make ES:DI point to "ROMCOMPRESS"
	pop	es
	lea	di,ROMCompParm
	mov	cx,ROMCompLen		; length of string
	cld
      	rep cmpsb			;Q: Does it match
	pop	es
	jz	PT_exit			; Y: OK
	dec	si			; N: check why not
	cmp	byte ptr ds:[si],' '	;Q: Was it due to a space?
	je	PT_exit			; Y: OK
	cmp	byte ptr ds:[si],'0'	;Q: Was it another character
	jb	PT_exit			; N: OK
	cmp	byte ptr ds:[si],'Z'
	ja	PT_exit
	mov	cs:[ROMparm],FALSE	; bad parameter
	jmp	inv_parm
Get_Wetek_Mode: 			; W
	cmp	byte ptr ds:[si], '='
	jne	WinParm
	CMP	GS:[Initial_Weitek], FREE; Q: Has the weitek been set?
	JNE	inv_parm		; Y: Bad!
	inc	si
	MOV	BX, SI
	MOV	DI, OFFSET op_on
	MOV	CX, ONLEN
	REPE	CMPSB
	JNE	SHORT check_woff
	MOV	GS:[Initial_Weitek], 1
	JMP	PT_exit
check_woff:
	MOV	SI, BX
	MOV	DI, OFFSET op_off
	MOV	CX, OFFLEN
	REPE	CMPSB
	JNZ	inv_parm
	MOV	GS:[Initial_Weitek], 0
	JMP	PT_exit

WinParm:
	cmp	dword ptr ds:[si-1], '=NIW'	;Q: WIN=?
	jne	inv_parm
	add	si,2			; get to "=" sign
	lea	bx,[WINset]
	jmp	GetRange

GetFullPath:				; M010 - Start
	lodsb
	cmp	al, '='
	jne	inv_parm
	call	StorePath		; save user specified path in CEMMPath
	jmp	PT_exit			; M010 - End

Vir8042Parm:
	cmp	dword ptr ds:[si],'08RI'  ;Q: correct switch?
	jne	VerboseParm		  ; N:
	cmp	word ptr ds:[si+4],'24'	  ;Q: correct switch?
	jne	VerboseParm		  ; N:
	or	gs:[GenFlags],fVir8042	  ; Y: virtualize 8042 (keyboard)
	add	si,6
	jmp	PT_exit

VerboseParm:
	dec	si			; backup to 'V'
	mov	di, OFFSET verbose$	; 'VERBOSE'
	mov	cx, verboseLen
	repe cmpsb
	jz	got_verbose
	cmp	byte ptr ds:[si-1], 0	; allow V, VE, VER, ... VERBOSE
	jnz	inv_parm
got_verbose:
	mov	cs:[Verbose], TRUE
	jmp	PT_exit

GetExcludeRange:			; X=FROM-TO
	lea	bx,[eXcSet]
	jmp	short GetRange

GetIncludeRange:			; I=FROM-TO
	lea	bx,[IncSet]
	jmp	short GetRange


;==============================================================================
;==
;==  GetRange:  Routine which extracts the range from a parameter of the form:
;==
;==		[variable]=xxxx-yyyy (xxxx/yyyy: hexadecimal segment values)
;==
;==  Enter:
;==	DS:SI	pointer to parameter at "=" sign.
;==	DS:[BX]	pointer to a word array which will store the range information.
;==
;==  Exit:
;==	DS:SI	points to blank after the parameter
;==	DS:[BX] array is updated to include the range.
;==
;==============================================================================
	public	GetRange
GetRange:
	lodsb
	cmp	al,'='			;Q: Possible range?
	jne	short inv_parm		; N: invalid parameter
	int	12h			; Get conventional memory size
	shl	ax,6			; In paragraph
	mov	cx,ax
	call	Get_Hexadecimal		; Get FROM
	or	dx,dx
	jnz	short inv_parm
	cmp	ax,cx			; Valid range: INT 12h-FFFF
	jb	short inv_parm

	movzx	di,byte ptr [bx]
	mov	[bx][di],ax		; save from value

	cmp	byte ptr ds:[si-1], '-'	;Q: Is there a TO?
	jne	short GFskipTO		; N: TO = FROM
	mov	cx,ax			; Save FROM
	call	Get_Hexadecimal		; Y: Get TO
	jc	short GFuseFROM
	or	dx,dx
	jnz	short GFuseFROM
	cmp	ax,cx			;Q: TO > FROM?
	jb	short GFuseFROM		; N: TO cannot be less tham FROM

GFskipTO:
	add	di,2
	add	byte ptr [bx],4
	mov	[bx][di],ax
	jmp	short PT_exit

GFuseFROM:
	mov	ax,cx
	or	gs:[msg_flag],INV_PARM_MSG ; set invalid parameter flag
	jmp	short GFskipTO


Invalid_Parameter:
inv_parm:
	OR	GS:[msg_flag], INV_PARM_MSG ; set invalid parameter flag
PT_exit:
	POP	DS
	POPAD
	RET
Parse_Token	ENDP

;
; DX:AX = Get_Decimal
;
;******************************************************************************
;   Get_Decimal - Translates ASCII decimal numbers
;
;   ENTRY:	DS:SI points to a buffer where a string is to be translated
;   EXIT:	DX:AX stores the number
;		CY is set if error detected
;   USED:
;   STACK:	<amount of stack used by routine>
;------------------------------------------------------------------------------
	public	Get_Decimal
Get_Decimal	PROC
	push	ebx
	push	eax

	xor	eax,eax			; clear sum and current digit
	xor	ebx,ebx
	LODSB
	OR	AL, AL			;Q: Anything there?
	JZ	SHORT invalid_ddd	; N: error
	JMP	SHORT check_AL		; Y: check if it's a digit

next_ddd:
	LODSB				; get next digit
	OR	AL, AL			;Q: Anything there?
	jnz	short check_AL		; Y: check if it's a digit
	pop	eax			; N: return total in DX:AX
	mov	ax,bx			; low order word in AX
	shr	ebx,16			; high order word in DX
	mov	dx,bx
	clc
	jmp	short GDexit

check_AL:
	CMP	AL, '0'			;Q: Is it an ASCII digit?
	JB	SHORT invalid_ddd       ; N: error
	CMP	AL, '9'			;Q: Is it an ASCII digit?
	JA	SHORT invalid_ddd	; N: error
	SUB	AL, '0'			; make it an integer
	add	ebx,ebx			; multiply current total by two
	test	ebx,0E0000000h		;Q: Reaching overflow of 32-bits?
	jnz	short invalid_ddd	; Y: must be an error! (number too large)
	lea	ebx,[ebx*4+ebx]		; N: multiply total by ten
	add	ebx,eax			; add new digit to total
	JMP	next_ddd

invalid_ddd:
	pop	eax
	mov	ax,bx
	shr	ebx,16
	mov	dx,bx
	STC

GDexit:
	pop	ebx
	ret
Get_Decimal	ENDP

;
; DX:AX = Get_Hexadecimal
;
;******************************************************************************
;   Get_Hexadecimal - Translates ASCII hexadecimal numbers
;
;   ENTRY:	DS:SI points to a buffer where a string is to be translated
;   EXIT:	DX:AX stores the number
;		CY is set if error detected
;   USED:
;   STACK:	<amount of stack used by routine>
;------------------------------------------------------------------------------
	public	Get_Hexadecimal
Get_Hexadecimal	PROC
	PUSH	BX
	PUSH	CX
	XOR	AX, AX			; bottom part of result
	LODSB
	OR	AL, AL
	JZ	SHORT invalid_hhh
	XOR	BX, BX			; Sum
	XOR	DX, DX			; top part of result
	MOV	CX, 16			; Hexadecimal
	JMP	SHORT check_hh
next_hhh:
	LODSB
	OR	AL, AL			; also clears carry
	JZ	SHORT no_hhh
check_hh:
	CMP	AL, 'A'
	JB	SHORT check_dd
	CMP	AL, 'F'
	JA	SHORT invalid_hhh
	SUB	AL, 'A'
	ADD	AL, 10
	JMP	SHORT calculator
check_dd:
	CMP	AL, '0'
	JB	SHORT invalid_hhh
	CMP	AL, '9'
	JA	SHORT invalid_hhh
	SUB	AL, '0'
calculator:
	XCHG	AX, BX
	MUL	CX
	ADD	AX, BX
	ADC	DX, 0
	XCHG	AX, BX
	JMP	next_hhh
invalid_hhh:
	STC
no_hhh:
	XCHG	AX, BX
	POP	CX
	POP	BX
	RET
Get_Hexadecimal	ENDP

;
; ZF = Frame_Check(AX);
;
;******************************************************************************
;   Frame_Check - Checks if the page frame is valid
;
;   ENTRY:	ED:DI points to a buffer where valid frames are stored
;		AX stores the number to be checked
;   EXIT:	ZR is frame is invalid
;   USED:
;   STACK:	<amount of stack used by routine>
;------------------------------------------------------------------------------
	public	Frame_Check
Frame_Check	PROC
	PUSH	ES
	PUSH	DI
	LES	DI, framadr
	CLD
	REPNE	SCASW
	POP	DI
	POP	ES
	RET
Frame_Check	ENDP

;==============================================================================
;==
;==  NoEMScheck: If the [NoEMS] parameter is chosen.  Changes all the defaults
;==		 to a minimum configuration.
;==
;==
;==============================================================================
	public	NoEMScheck
	assume	cs:LAST,ds:_DATA,gs:R_CODE
NoEMScheck proc	near

	cmp	gs:[NoEMSset],TRUE	; Q: Was [NoEMS] set?
	je	NEcCont			; Y: continue
	cmp	cs:[max_pool_size],0	; Q: Did user specify size?
	jnz	short NEcDone		; Y: OK
	mov	cs:[max_pool_size], MAX_SIZE	; default to large EMS size
NEcDone:
	ret

NEcCont:

	; Since noems has been specifed we need to setup with frame=none
	; parms and also provide a 0 pool size if the user has not specifed
	; any.

	mov	gs:[NoEMSset], FALSE
	mov	gs:[NoPFset], TRUE

	;
	; set up VCPIset to imply the foll.
	;
	; 	VCPIset = -1 => NOEMS has not been specifed (default)
	;	VCPIset = TRUE	=> NOEMS has been specifed
	;	VCPIset = FALSE => NOEMS+NOVCPI has been specifed
	;
	mov	gs:[VCPIset], FALSE	; assume NOEMS + NOVCPI

	cmp	cs:[NoVCPI], TRUE	; Q: did user disable VCPI too?
	je	short NEcSetNoems	; Y:

	mov	gs:[VCPIset], TRUE	; N: VCPI = TRUE

	cmp	cs:[min_pool_set], TRUE ; default min pool size with NOEMS
	je	short NEcMinSet 	;   is 0
	mov	cs:[min_pool_size], 0
NEcMinSet:
	cmp	cs:[max_pool_set], TRUE ; default to large EMS/VCPI size
	je	short NEcMaxSet 	;     if VCPI support enabled
	mov	cs:[max_pool_size], MAX_SIZE
NEcMaxSet:

	; Note: we'll set up the device name to EMMQXXX. This will enable
	; Lotus 123 to work with noems option.

	mov	gs:[DevName+3],'Q'

	; Some programs can't detect EMM386 when it's installed with the
	; 'EMMQXXX0' name, so when this name is used add a second device
	; driver header with the name '$MMXXXX0' that these programs do
	; know to detect.

	mov	gs:[DEVHEAD], offset R_CODE:DEVHEAD2	;link in second header
	ret


	; User doesn't want EMS or VCPI, must be a UMB only type of guy.

NEcSetNoems:

ifdef QLEO
	or	ax,ax
	jz	short NEcAltRegSets
	or	gs:[msg_flag],NoEMS_MSG
NEcAltRegSets:
endif

	mov	ds:[total_register_sets],2

ifdef QLEO
	cmp	cs:[altRset],0
	je	short NEcHandle
	or	gs:[msg_flag],NoEMS_MSG
NEcHandle:
endif

	mov	[total_handles],2
	mov	gs:[ttl_hndls],2

ifdef QLEO
	cmp	cs:[$Hset],0
	je	short NEcBase
	or	gs:[msg_flag],NoEMS_MSG
NEcBase:
	cmp	cs:[baseset],0
	je	short NEcPn
	or	gs:[msg_flag],NoEMS_MSG
NEcPn:
	cmp	cs:[PnSet],0
	je	short NEcFrame
	or	gs:[msg_flag],NoEMS_MSG
NEcFrame:
	cmp	gs:[PF_Base],FREE
	je	short NEcExit
	or	gs:[msg_flag],NoEMS_MSG
endif
	mov	gs:[DevName],'$'
NEcExit:
	ret
NoEMScheck	endp

;==============================================================================
;==
;==  GetEMSPool: This subroutine preallocates the EMS pool for CEMM.
;==
;==  Entry: (Real Mode)
;==	CS:[min_pool_size] = minimum EMS pool size requested
;==
;==  Exit:
;==	CS:[min_pool_size]	= preallocated EMS pool size
;==	CS:[ext_size]  	        = extended memory pool size (size of pool 1)
;==	CS:[hi_size]   	        = BIM pool size             (size of pool 2)
;==	CS:[ext_memory_address] = extended pool address (address of pool 1)
;==	CS:[high_memory_address]= BIM pool address	(address of pool 2)
;==
;==============================================================================
	public	GetEMSPool
	assume	ds:_DATA,es:ABS0,gs:R_CODE
GetEMSPool proc	near
;
;  Initialize variables
;
	xor	eax,eax
	mov	cs:[ext_memory_address],eax
	mov	cs:[high_memory_address],eax
	mov	cs:[ext_size],ax
	mov	cs:[hi_size],ax
;
;  Leave atleast L=nnn extended memory after CEMM installs (default: L=0)
;
;+++
	CMP	CS:[ext_mem], FREE	; Q: Is L=ddd set?
	JE	SHORT skip_left_alone	; N: Skip these steps
	CALL	TotalFreeMem		; EAX = TotalFreeMem();
	JC	GEPerror
	SHR	EAX, 10			; In K bytes
	MOV	EBX, CS:[ext_mem]
	SUB	EAX, EBX
	JBE	GEPerror
	MOVZX	EBX, cs:[max_pool_size]
	CMP	EAX, EBX
	JAE	SHORT skip_left_alone
	CMP	AX, MIN_SIZE
	JB	GEPerror
	AND	AX, NOT 0Fh		; Round it down to multiple 16K	;@PIW
	OR	GS:[msg_flag], SIZE_ADJ_MSG; Memory size adjusted message;@PIW
	MOV	cs:[max_pool_size], AX
	cmp	ax, cs:[min_pool_size]	; Max EMS pool size adjusted, don't
	jae	skip_left_alone 	;   let Min size be larger than Max
	mov	cs:[min_pool_size], ax
skip_left_alone:
;+++
;
;  Try get all of preallocated EMS pool from BIM
;
	xor	ebx,ebx
	movzx	eax,cs:[min_pool_size]	; size of preallocated pool requested
	or	ax,ax			;Q: Any EMS pool needed?
	jz	short GEPcont		; N: no memory used
	shl	eax,10			; in bytes
	mov	bx,fBIMMem
	shl	ebx,16
	mov	bx,EMS_BOUNDARY		; EMS bound and BIM

	call	MemGet			;Q: Enough BIM for EMS pool?
	jc      short GEPnotEnoughBIM	; N: not enough
GEPcont:				; Y: save starting address
	mov	[high_memory_address],ebx
	shr	eax,10			; size in Kbytes
	mov	[hi_size],ax

	jmp	GEPexit

;
; Try get what is available from BIM
;
GEPnotEnoughBIM:
	and	eax,not (4000h-1)	; round down to 16 Kbytes
	or	eax,eax			;Q: Any BIM available?
	jnz	short GEPhi		; Y: allocate all of it?
	movzx	eax,cs:[min_pool_size]	; N: allocate any type of memory
	shl	eax,10			; size in bytes
	mov	ebx,EMS_BOUNDARY	; must be 4K aligned

GEPhi:
	and	eax,not (4000h-1)	; round down to 16 Kbytes
	or	eax,eax			;Q: Any memory to allocate?
	jz	short GEPerror		; N: no memory available

	call	MemGet			;Q: Allocate hi memory?
	jc	GEPhi			; N: try hi memory one more time?
	mov	[high_memory_address],ebx;Y: save starting address

	shr	eax,10			; size in 1 Kbytes
	mov	[hi_size],ax
	sub	ax,cs:[min_pool_size]	; check if any more is needed
	neg	ax
	shl	eax,10			; memory still needed

	or	eax,eax			;Q: Any more needed?
	jz	short GEPexit           ; N: exit, all memory allocated

GEPlo:
	and	eax,not (4000h-1)	; round down to 16 Kbytes
	or	eax,eax			;Q: Any memory to allocate?
	jz	short GEPless		; N: report less memory allocated

	mov	ebx,EMS_BOUNDARY	; must be 4K aligned

	call	MemGet			;Q: Get the rest needed?
	jc	short GEPlo		; N: get what ever you can
	mov	cs:[ext_memory_address],ebx; Y: save starting address
	shr	eax,10			; size in Kbytes
	mov	cs:[ext_size],ax
	add	ax,cs:[hi_size]		; total allocated

	cmp	ax,MIN_SIZE		;Q: Did we get atleast 64K?
	jb	short GEPerror		; N: exit, not enough memory
	cmp	ax,cs:[min_pool_size]	;Q: Did we get all we needed?
	jae	short GEPexit		; Y: exit, all memory allocated

;
;  All memory was not allocated
;
GEPless:
	mov	ax,cs:[hi_size]  		; amount allocated
	add	ax,cs:[ext_size]
	mov	cs:[min_pool_size],ax
	mov	cs:[max_pool_size],ax
	or	gs:[msg_flag],SIZE_ADJ_MSG ; memory size adjusted message
	jmp	short GEPexit

;
;  No memory was allocated
;
GEPerror:
	or	gs:[msg_flag],MEM_ERR_MSG ; no memory available

GEPexit:
	mov	ax, cs:[max_pool_size]	; save Min/Max EMS pool sizes for
	mov	gs:[MaxEMSpool], ax	;   IOCTL interface reporting
	mov	ax, cs:[min_pool_size]
	mov	gs:[MinEMSpool], ax

	call	UpdateHandleSpace
	ret
GetEMSPool 	endp

;==============================================================================
;==
;==  UpdateHandleSpace: This subroutine updates the handle space with the free
;==			EMS memory allocated in GetEMSPool.
;==
;==  Entry: (Real Mode)
;==	CS:[ext_size]  	        = extended memory pool size (size of pool 1)
;==	CS:[hi_size]   	        = BIM pool size             (size of pool 2)
;==	CS:[ext_memory_address] = extended pool address (address of pool 1)
;==	CS:[ext_memory_address] = BIM pool address      (address of pool 2)
;==
;==  Exit:
;==	handle space updated
;==
;==============================================================================
	public	UpdateHandleSpace
UpdateHandleSpace proc	near
;
;  Initialize the handle space management data structures
;
	mov	bx, cs:[handle0_PTEs]
	add	bx, FIRST_HANDLE_PTE

	mov	ax, cs:[max_pool_size]		; TopOfHandleSpace has to map
	shr	ax, 2				;   the max amount of EMS space
	add	ax, bx				;   that can be allocated
	mov	[TopOfHandleSpace], ax
	mov	[BotOfVCPIspace], ax		; No VCPI space initially

	mov	ax,cs:[min_pool_size]		; KB of preallocated EMS memory
	shr	ax,2                            ; 4 KB size
	add	ax, bx				; size of total EMS pool
	mov	[TopOfFreeEMSspace],ax		; existing but free EMS memory

	mov	ax,cs:[handle0_PTEs]		; EMS 4K pages already allocated
	mov	[TopOfUsedEMSspace],ax
	add	[TopOfUsedEMSspace],FIRST_HANDLE_PTE
	shr	ax,2
	mov	[UsedEMSPages],ax		; EMS memory allocated by handle 0
;
;  Get destination address
;
	movzx	edi,cs:[handle0_PTEs]
	add	di,FIRST_HANDLE_PTE
	shl	edi,2
	add	edi,[page_directory]
;
;  Update with hi pool first
;
	mov	esi,cs:[high_memory_address]
	shr	esi,10				; PTE offset into page tables
	add	esi,[page_tables]
	movzx	ecx,cs:[hi_size]		; size in KB, also number of byte to tx
	jcxz	short UHSgetExt
	call	DoMoveBlock
	jc	short UHSerror
	add	edi,ecx
;
;  Now, update with ext pool
;
UHSgetExt:
	mov	esi,cs:[ext_memory_address]
	shr	esi,10				; PTE offset into page tables
	add	esi,[page_tables]
	movzx	ecx,cs:[ext_size]			; size in KB, also number of byte to tx
	jcxz	short UHSexit
	call	DoMoveBlock
	jc	short UHSerror
UHSexit:
	ret
UHSerror:
	or	gs:[msg_flag],MEM_ERR_MSG
	jmp	short UHSexit
UpdateHandleSpace 	endp
;==============================================================================
;==
;==  EstWorkSpace: Estimates amount of work space.
;==
;==  Enter:
;==
;==  Exit:
;==	EBX = estimate size of memory required for work space: data/code (bytes)
;==
;==============================================================================
EstWorkSpace	proc	near
	push	eax
	push	edx

	mov	bx,gs:[total_handles]
	mov	eax,size HandleTable_struc+size HandleName_struc+size HandleSaveMap_struc+size save_flag+size EMM_Handle
;QEMS	mov	eax,size HandleTable_struc+size HandleName_struc+size EMS_window_struc * TOTAL_PF_WINDOWS+size save_flag+size EMM_Handle
	mul	bl			; Size of handle related data
	mov	edx,eax
	mov	bl,size RegisterSet_struc
	mov	al,[total_register_sets]
	mul	bl			; Size of total_register_sets
	add	eax,edx
	add	eax,offset _DATA:[end_of_DATA]
	add	eax,offset _TEXT:[end_of_TEXT]
	add	eax,offset STACK:[end_of_STACK]
;TSSQLEO add	eax,TSSLEN
	add	eax,IDTLEN
	add	eax,GDTLEN		; space for TSS,IDT, & GDT
	mov	ebx,eax

	pop	edx
	pop	eax
	ret
EstWorkSpace	endp

;==============================================================================
;==
;==  EISACheck: This routine checks if the machine is EISA.
;==
;==============================================================================
	public	EISACheck
EISACheck proc	near
	push	es

	cmp	[ROMID],ROMIDISA	;Q: ISA/EISA machine?
	jne	short ECexit		; N: exit

	mov	eax,'ASIE'		; "EISA"
	les	di,cs:[pEISAROM]	; possible "EISA" in ROM

	cmp	eax,es:[di]		;Q: EISA machine?
	jne	short ECexit		; N: not on EISA box
	or	gs:[GenFlags],fEISA	; Y: set flag

ECexit:
	pop	es
	ret
	assume	fs:nothing
EISACheck	endp

;==============================================================================
;==
;==  MCACheck: This routine checks if the machine is MCA.
;==
;==  Input: GS = R_CODE
;==
;==  Output: bit in GenFlags set
;==
;==  Uses: AX, ES, BX
;==
;==============================================================================
	public	MCACheck
MCACheck 	proc   near

	mov     ah,0c0h		; Get System Description Vector
	stc
	int	15h
	jc	MCNoMCA  	; Error?  Not an MCA
;
;  Do we have a "Micro Channel" computer?
;
	mov     al,byte ptr es:[bx+5] ; Get "Feature Information Byte 1"
	test    al,00000010b    ; Test the "Micro Channel Implemented" bit
				; Q: is this an MCA machine
	jz	MCNoMCA		; N: clear ax and ret
	or	gs:[GenFlags],fMCA
				; Y: MCA set flag
MCNoMCA:
	ret

MCACheck	endp

;==============================================================================
;==
;==  VirHMAinit: This routine checks if a virtual HMA is being provided.
;==		 And if so, adds 64K to the int 15h handler if no XMM is
;==		 on the system.
;==
;==============================================================================
	public	VirHMAinit
VirHMAinit proc	near

	cmp	gs:[HMAptr],100000h		;Q: Virtual HMA?
	je	short VHexit			; N: don't process
	test	gs:[GenFlags],fXMM		;Q: XMM on the system?
	jnz	short VHexit			; Y: virtual HMA
	mov	gs:[ext_rem],64			; N: add 64K to INT 15h memory
VHexit:
	ret
VirHMAinit	endp

;==============================================================================
;==
;==  MoveExtBIOS: This routine moves the extended BIOS area (XBDA) to below
;==		  the lowest EMS window.
;==
;==============================================================================
assume cs:LAST
ArenaStruc	struc
  ArenaID	db	?	; Arena ID (i.e., 'Z', 'M')
  ArenaOwn	dw	?	; Arena owner (segment of)
  ArenaSize	dw	?	; Arena size (size in paragraphs)
ArenaStruc	ends

	public	MoveExtBIOS

MoveExtBIOS	proc	near
	push	ax
	push	bx
	push	cx
	push	si
	push	di
	push	ds
	push	es
	push	fs
	pushf				; no interrupts while transferring data
	cli

;
;  Check to see if Extended BIOS should be moved
;
	test	gs:[GenFlags],fXBDAnotRel	;Q: Move extended BIOS?
	jne	short MEBexit		 	; N: exit
	mov	ax,romdata		 	; Y: get pointer to BIOS data area
	mov	fs,ax
	assume 	fs:romdata

	int	12h			; get amount of INT 12 memory (1K)
	mov	cx,ax
	and	ax,0Fh			; check if extended BIOS machine
	cmp	al,0Fh			;Q: 1K less than a 16K multiple?
	jne	short MEBexit		; N: exit

	shl	cx,6			; convert to paragraphs
	mov	ds,cx			; current Extended BIOS area
	cmp	fs:[pExtBIOS],cx	;Q: Extended BIOS machine?
	jne	short MEBexit		; N: exit
;
;  Change Extended BIOS pointers and add 1K to Int 12h memory
;
	mov	ax,cs:[EndDriver]	; get current end of resident CEMM
	mov	fs:[pExtBIOS],ax	; place pointer in BIOS data area
	mov	es,ax			; new Extended BIOS area
	add	fs:[Int12hMem],1	; increment INT 12h by 1K
	add	ax,40h			; add 1K in paragraphs
	mov	cs:[EndDriver],ax	; add 1K to base memory usage
;
;  Move data to new location
;
	xor	si,si			; set up for 1K transfer
	xor	di,di
	mov	cx,100h			; move entire extended BIOS area
	rep movsd			; from old to new position
;
;  Add 1K to last ARENA header so DOS will use it!
;
	mov	bx,-1			; sanity checker
	mov	ax,5200h		; add 1K to arena header
	int	21h                     ; get SYSINIT variables
	cmp	bx,-1			;Q: Did the call work?
	je	short MEBexit		; N: don't add 1K to arena
	mov	bx,es:[bx][-2]		; Y: UNDOCUMENTED start of arena chain
	xor	si,si
MEBloop:
	mov	ds,bx			; access current arena
	add	bx,[si].ArenaSize	; get segment to next arena
	jc	short MEBexit		; if overflow, incorrect chain - EXIT!
	inc	bx
	cmp	[si].ArenaID,'Z'	;Q: Last arena header?
	jne	short MEBloop		; N: check next arena
	add	[si].ArenaSize,40h	; Y: add 1K to last arena (in paragraphs)

MEBexit:
	popf				; restore flags
	pop	fs
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	cx
	pop	bx
	pop	ax
	ret
	assume es:nothing
MoveExtBIOS	endp

;----------------------------------------------------------------------------
;
; Procedure Name : IsZenith
;
;	Input  : gs -> R_CODE
;	Output : set's fzenith bit in genflags if zenith machine
;
;  Check to see if we're on a ZENITH machine
;
;----------------------------------------------------------------------------
	public	IsZenith
IsZenith 	proc near

	push	es
	push	ds
	push	di
	push	si
	push	cx

	les	di,cs:[pZENITH]		; es:di points to possible COMPAQ signature
	push	cs
	pop	ds
	mov	si,offset szZENITH 	; "ZDS"
	mov	cx,3
	cld
	rep	cmpsb			;Q: ZENITH machine?

	jnz	iz_notzen		; N:
	or	gs:[GenFlags], fzenith	; Y: set flag

iz_notzen:

	pop	cx
	pop	si
	pop	di
	pop	ds
	pop	es

	ret

IsZenith	endp

;-------------------------------------------------------------------------
;
;	M008:
;
;	Procedure Name	: IsCPQ16
;
;	Input		: gs -> R_CODE
;	Output		: set fCPQ16 bit in genflags if
;
;   	Determine if this system is a COMPAQ Deskpro 386/16 or
;       a COMPAQ Portable 386.  If so, the SHADOW ROM unmapping should not
;       be allowed because of a bug in these machines.
;
;--------------------------------------------------------------------------

CMOS_CPQ_DP38616        equ     31h     ; CMOS ID byte for COMPAQ DP386/16
CMOS_CPQ_P386           equ     33h     ; CMOS ID byte for COMPAQ P386

	public	IsCPQ16

IsCPQ16 proc near
        push    ax                      ; save register

        ; Read CMOS configuration to see if
        ;  the machine ID matches the ID for
        ;  DP 386/16 or P386
        ;-----------------------------------
        mov     al, 24h                 ; point to CMOS index for ID byte
        out     70h, al                 ; byte to get
        jmp     $+2                     ; delay I/O for 286
        jmp     $+2                     ;  ...
        in      al, 71h                 ; get byte from CMOS
        cmp     al, CMOS_CPQ_DP38616    ; Is this a DP386/16 ?
        je      C386_YES                ; Y: return
        cmp     al, CMOS_CPQ_P386       ; Is this a P386 ?
        jne     C386_NO                 ; N:

C386_YES:
	or	gs:[GenFlags], fCPQ16	; Y: set flag

C386_NO:
        pop     ax                      ; restore registers
        ret                             ;   and return

IsCPQ16 endp

;-------------------------------------------------------------------------
;
;	Install_I13handler:
;
;	If smartdrv present install emm386's int13 hook in front of smartdrv
;
;	HKN 11/02/89
;
;--------------------------------------------------------------------------
	public	Install_I13handler

Install_I13handler	proc	near

	push	cx
	push	dx
	push	bx
	push	ax
	push	ds
	push	gs
	push	fs
	push	di

	push	ds
	pop	gs

	mov	dx, word ptr gs:[EMM_rFarEntry+2]
	mov	fs, dx		; fs = R1_CODE seg
	assume	fs:R1_CODE

; Open smartdrv
	push	cs
	pop	ds
	mov	dx, offset cs:smartdrv_name
	call	IOCTLOpen
	cmp	bx,-1
	je	no_smartdrv


; Read Smartdrv's OLD int 13 handler
				; handle in BX
	mov	cx, SIZE smartdrv_status
	mov	dx, offset cs:smartdrv_status
	call	IOCTLRead
	cmp	ax, -1
	je	no_smartdrv

; EMM386's OLD int 13 handler should be SMartdrv's OLD
	mov	di, dx
	mov	eax, ds:[di.old_int13]
	mov	gs:[PrevInt13],eax
	mov	fs:[OldInt13], eax

; Smartdrv's OLD int 13 handler should be EMM386's int 13 handler
	mov	di, offset set_int13
	mov	ax, seg R_CODE
	shl	eax, 16
	mov	ax, offset R_CODE:rINT13hHandler
	mov	dword ptr ds:[di+2], eax
	mov	dx, di
	mov	cx, 5
	call	IOCTLWrite
	cmp	ax, -1
	jne	Install_I13_done

no_smartdrv:
	call	IOCTLClose	; ignore error from close
;
;  Check for CACHE.EXE on the system
;
	lea	dx,[CACHEname]
	call	IOCTLOpen
	cmp	bx,-1
	je	short II13noCACHE

;
; Give CACHE CEMM's INT 13h handler & Get CACHE's OLD INT 13h handler: handle in BX
;
	mov	ax,seg R_CODE
	shl	eax,16
	lea	ax,R_CODE:rINT13hHandler
	mov	dword ptr [CACHEIOCTL][2],eax

	mov	cx,10
	lea	dx,[CACHEIOCTL]
	call	IOCTLRead
	cmp	ax,-1
	je	short II13noCACHE

;
; CEMM's OLD int 13 handler should be CACHE's OLD
;
	lea	ax,R_CODE:rINT13hHandler
	cmp	ax,[CACHEIOCTL][2]
	jne	short II13noCACHE

	cmp	dword ptr [CACHEIOCTL][6],0
	je	short II13noCACHE

	mov	eax,dword ptr [CACHEIOCTL][6]
	mov	gs:[PrevInt13],eax
	mov	fs:[OldInt13], eax

	jmp	short Install_I13_done

II13noCACHE:
	mov	ax, seg R_CODE
	shl	eax, 16
	mov	ax, offset R_CODE:rINT13hHandler
	xchg	es:[int13],eax
	mov	gs:[PrevInt13],eax
	mov	fs:[OldInt13], eax


Install_I13_done:
;				; handle in BX
;	mov	cx, SIZE smartdrv_status
;	mov	dx, offset cs:smartdrv_status
;	call	IOCTLRead
;
	call	IOCTLClose	; ignore error from close
	pop	di
	pop	fs
	pop	gs
	pop	ds
	pop	ax
	pop	bx
	pop	dx
	pop	cx

	assume	fs:nothing

	ret

Install_I13handler	endp

;--------------------------------------------------------------------------
;
;	IOCTLOpen - Open the indicated device and make sure it's a device
;
;  ENTRY:
;	DS:DX Pointer to name of device
;  EXIT:
;	BX = -1 if error, device not opened
;	else BX = handle of open device
;
;----------------------------------------------------------------------------
	public	IOCTLOpen

IOCTLOpen	proc	near

	MOV	AX,3D02H
	INT	21H		; Open the device
	JC	NO_DEV_ERR	; No device
	MOV	BX,AX
	MOV	AX,4400H
	INT	21H		; Make sure it IS a device
	JC	CLOSE_NO_DEV
	TEST	DX,4080H
	jnz	short PXDONE

CLOSE_NO_DEV:
	mov	ax,3e00H	; Close
	int	21H
NO_DEV_ERR:
	mov	bx,-1
PXDONE:
	ret

IOCTLOpen	endp

;--------------------------------------------------------------------------
;	IOCTLClose - Close the indicated handle
;
;  ENTRY:
;	Handle
;  EXIT:
;	None
;
;---------------------------------------------------------------------------
	public	IOCTLClose

IOCTLClose	proc	near

	cmp	bx,-1		;Q: Is there a handle?
	je	short @f	; N: exit
	MOV	AX,3E00H
	INT	21H		; close the device
@@:
	ret
IOCTLClose	endp

;--------------------------------------------------------------------------
;	IOCTLWrite - Perform IOCTLWrite to device handle
;
;  ENTRY:
;	BX = Handle to open device
;	DS:DX -> Pointer to data to write
;	CX = Count in bytes of data to write
;  EXIT:
;	AX = -1 error
;	else AX = input count
;
;--------------------------------------------------------------------------
	public	IOCTLWrite

IOCTLWrite	proc	near

	MOV	AX,4403H	; IOCTL Write
	INT	21H
	JC	Werr
	CMP	AX,CX
	jz	short WDONE

WERR:
	mov	ax,-1
WDONE:
	ret

IOCTLWrite 	endp


;----------------------------------------------------------------------------
;	IOCTLRead - Perform IOCTLRead to device handle
;
;  ENTRY:
;	BX = Handle to open device
;	DS:DX -> Pointer to data area to read into
;	CX = Count in bytes of size of data area
;  EXIT:
;	AX = -1 error
;	else AX = input count
;-----------------------------------------------------------------------------
	public	IOCTLRead

IOCTLRead	proc	near

	MOV	AX,4402H	; IOCTL Read
	INT	21H
	JC	Rerr
	CMP	AX,CX
	jz	short RDONE

RERR:
	mov	ax,-1
RDONE:
	ret

IOCTLRead	endp

;******************************************************************************
;	ErrorExit - clean up after init error encountered
;
;	When an initialization error occurs which prevents CEMM from loading,
;	this routine is responsible for "cleaning" up before CEMM's driver
;	init routine returns to DOS.  This involves
;	    (1) if EGAmove has been initialized, then
;		    unpatch int10h vector.
;	    (2) if Weitek installed, upatch int11h vector.
;
;	ENTER: REAL mode
;
;	EXIT: REAL mode
;
;	USED: high word of EAX
;
;******************************************************************************
	public	ErrorExit

ErrorExit	proc	near
	push	ax
	push	es
	push	ds
	push	fs

	mov	ax,R1_CODE
	mov	fs,ax
	ASSUME	fs:R1_CODE

	mov	ax,R_CODE
	mov	ds,ax
	ASSUME	ds:R_CODE


	; Fool the system that we are a block driver, so it will remove the
	; whole program, not leaving a trace.
	AND	[DDT], NOT CHAR_DEV


    	; Remove ourselves from the XMM control chain if XmmControlBase is
	; not -1.
	;
    	; We assume that no one has hooked us, since we're still in driver
    	; initialization.
    	;

	cmp	word ptr cs:[XmmControlBase],-1
	jne	UnhookXmm
	cmp	word ptr cs:[XmmControlBase+2],-1
	je	EE_chki10		; we didn't hook- don't unhook
UnhookXmm:
	mov	al,0EBh			; AL = opcode for short jump
	mov	ah,cs:[XmmControlJmpVal]; AH = displacement for short jump
	les	bx,cs:[XmmControlBase]	; ES:BX = ptr to previous XMM header
	mov	word ptr es:[bx],ax	; restore previous XMM's short jump
	mov	word ptr es:[bx+2],9090h;  followed by nop's
	mov	byte ptr es:[bx+4],90h


EE_chki10:

	xor	ax,ax
	mov	es,ax				; ES-> 0
	ASSUME	ES:ABS0


	;
	; check for Int10h patched
	;
	test	[Current_State],fState_CEGAmove ;Q: EGA ROM moved ?
	jz	short EE_chki11			;  N: chk for int11 patch
	mov	eax,[Int10_Save]	; EAX = initial int 10h vector
	mov	dword ptr es:[int10],eax		; set it back

	;
	; check for Int11h patched
	;
EE_chki11:
	test	[Weitek_State],fWeitek_Inst	;Q: Weitek installed ?
	jz	short EE_exit 			;  N: leave now
						;  Y: unpatch int11h vector
	mov	eax,fs:[PrevInt11] 		; EAX = initial int 11h vector
	or	eax,eax				; Q: eax=0 ?
	jz	short EE_exit 			;   Y: don't unpatch
	mov	dword ptr es:[int11],eax		; set it back

EE_exit:
	pop	fs
	pop	ds
	pop	es
	pop	ax
	ret
	assume	ds:_DATA
	assume	es:_DATA
	assume	fs:nothing

ErrorExit	endp

;;--------------------------------------------------------------------------
;;  $chkCPQxmm:  This routine checks for a COMPAQ HIMEM.SYS.  If an EISA machine
;;		 is detected, any XMM other than COMPAQ will be activated.
;;
;;  (The routine preserves all registers)
;;--------------------------------------------------------------------------
$ROMSEG		equ	0F000h
$EISAOFF	equ	0FFD9h
$ROMEISA label	dword
		dw	$EISAOFF
		dw	$ROMSEG
$CPQOFFS	equ	1Ch
$CPQEPOFFS	equ	104h
$XMMcontrol	dd	0

	public	$chkCPQxmm

$chkCPQxmm proc	near
    push      es                            ;;
    push      bx                            ;;
    push      ax                            ;;
;
;  Check if this is an EISA machine
;
    les	      bx,[$ROMEISA]		    ;; address for "EISA" string
    cmp	      es:[bx],'IE'		    ;;Q: "EI" part of EISA?
    jne	      $no_XMM			    ;; N: not an EISA machine
    cmp	      es:[bx+2],'AS'		    ;;Q: "SA" part of EISA?
    jne	      $no_XMM			    ;; N: not an EISA machine
;
;  Check if XMM is on system
;
    mov       ax,4300h                      ;; function for XMS detect
    int       2fh                           ;; check for XMS driver
    cmp       al,80h                        ;; Q: Is XMS installed?
    jne       $no_XMM                       ;;  N: XMS not in use, not enough
;
;  Get entry point of XMM
;
    mov       ax,4310h                      ;; Get XMS routine address
    int       2fh                           ;;
    mov       word ptr cs:[$XMMcontrol],bx  ;; Save XMS routine address
    mov       word ptr cs:[$XMMcontrol+2],es;; (offset), (segment)
;
;  Is it a COMPAQ XMM?
;
    cmp	      word ptr es:[$CPQOFFS],'oC'   ;;Q: "Co" of COMPAQ?
    jne	      $chk2_50			    ;; N: check CPQ ver 2.50
    cmp	      word ptr es:[$CPQOFFS+2],'pm' ;;Q: "Comp" of COMPAQ?
    jne	      $chk2_50			    ;; N: check CPQ ver 2.50
    cmp	      word ptr es:[$CPQOFFS+4],'qa' ;;Q: "Compaq" of COMPAQ?
    je	      $no_XMM			    ;; Y: don't activate CPQ XMM
;
;  Check if it is a COMPAQ HIMEM version 2.50
;
$chk2_50:
    mov       ah,0                          ;; Get XMS version number
    call      cs:[$XMMcontrol]              ;; Call XMM
    cmp       ax,200h                       ;;Q: Version = 2.00?
    jne       $ActivateXMM                  ;; N: foreign XMM, activate it!
    cmp       bx,250h                       ;;Q: Revision 2.50?
    jne       $ActivateXMM                  ;; N: foreign XMM, activate it!

    cmp       word ptr cs:[$XMMcontrol],$CPQEPOFFS;;Q: CPQ ver 2.50?
    je	      short $no_XMM		 	  ;; Y: don't activate XMM
;
;  Not a COMPAQ XMM driver, activate it!
;
$ActivateXMM:
    mov       ah,8                          ;; How much extended memory is
    call      cs:[$XMMcontrol]              ;; ..... available in Kbytes?
$no_XMM:                                     ;;
    pop       ax                            ;;
    pop       bx                            ;; restore bx
    pop       es                            ;; restore es
    ret                                     ;;
$chkCPQxmm    endp 	                    ;;

;*****************************************************************************
;
; Synopsis    : Check_Install_Abort()
;
; Description : Check if the "installation abort hotkey" is being pressed
;                   Hotkey for abort is: L-SHIFT + R-SHIFT + "-" (minus key)
;
; Returns     : CY = 0 if program should continue to install
;                  = 1 if program should abort installation
;
; Alters      : None
;
; Calls       : BIOS
;
; History     : Kelan Silvester 02/27/91
;                       original entry
;
;*****************************************************************************/
	public	Check_Install_Abort

Check_Install_Abort 	proc	near

        mov     ah,1                ; check keyboard request
        int     16H                 ; call BIOS
        jz      install_OK          ; if keyboard buffer empty -->

        cmp     ah, 0Ch             ; Is the hotkey (minus "-") being pressed ?
        jne     install_OK          ;  N:
        mov     ah, 2               ; get shift status
        int     16H                 ; call BIOS

	and	al,011b		    ; concerned with shift status only
        cmp     al,011b		    ; Are both shift keys pressed ?
        jne     install_OK          ;  N:
        stc			    ;  Y: set return flag
        ret

install_OK:
        clc			    ; return
        ret

Check_Install_Abort endp

;*************************************************************************** 
;     Chk_DOS - check DOS version to be >= 3.1                               
;		- must be in this seg since the rest is still packed	     
;
;	EXIT: carry set if DOS < 3.1, otherwise carry clear		     
;									     
;	USED: ax							     
;									     
;*************************************************************************** 
	public	Chk_DOS

Chk_DOS proc near				;			     

	mov	ah,GET_VERSION		;get DOS version #	     
	int	MS_DOS			;			     
	mov	cs:[DOS_version],ax
	cmp	al,10			; Q: OS/s DOS?
	jae	short C_bad_DOS		;  Y
	cmp	al,3			;Q: >= DOS 3.10 ?	     
	jb	short C_bad_DOS		;  N: won't work             
	ja	short Chk_ok		;  higher is ok
	cmp	ah,10			;Q: DOS >= 3.10 ?	     
	jb	short C_bad_DOS		;  N: won't work            
Chk_ok:
	clc				;clear carry for no error   
	ret				;			     
C_bad_DOS:				;handle invalid DOS version 
	stc
	ret
Chk_DOS endp				;	       


;===========================================================================
;
;
; 	Procedure Name 	: MovUmbSeg
;
;	Entry		: GS = R_CODE
;			: V86 MODE
;
;	Exit		:
;
;	Uses		: ax, bx, cx, dx, es, ds, di, si
;
;===========================================================================

	public	MovUmbSeg

MovUmbSeg	proc	near

	cmp	cs:[NoHigh], TRUE	; Q: NOHI specified
	je	short MUSquit		; Y: do not mov r1_code into UMB
	cmp	cs:[UMBset], TRUE	; Q: RAM option specified
	je	short MUScont		; Y: UMBs available
	cmp	gs:[VCPIset], -1	; Q: NOEMS option specfied
	jne	short MUScont		; Y: UMBs available

MUSquit:
	ret

MUScont:
	mov	dx, OFFSET R1_CODE:end_of_R1_CODE
	mov	cx, dx			; cx = length of R1_CODE in bytes
	add	dx, 0fh			; round up to para boundary
	shr	dx, 4
	mov	ah, 10h			; ah = request UMB
	call	rXMMentry		; Make our own XMS call
	or	ax, ax			; Q: was the request successful
	jz	MUSquit			; N: quit
					; Y: dx is the size of block in paras

	sub	cs:[EndDriver], dx	; Update EndDriver size
	mov	es, bx
	assume	es:R1_CODE
	xor	di, di			; es:di is the UMB seg
	mov	ax, seg R1_CODE
	mov	ds, ax
	mov	si, di			; ds:si is start of R1_CODE
					; cx already set up
rep	movsb				; move it

	;
	; Update INT 2Fh, 4Bh, int 10 and int 11 hooks.
	;

	xor	ax,ax
	mov	fs,ax
	ASSUME	fs:ABS0

	mov	word ptr fs:[int2f+2], bx
	mov	word ptr fs:[int4B+2],bx

	cmp	word ptr fs:[int10+2], seg R1_CODE
	jne	short MUSchki11
	mov	word ptr fs:[int10+2],bx
MUSchki11:
	cmp	word ptr fs:[int11+2], seg R1_CODE
	jne	short MUSfixup
	mov	word ptr fs:[int11+2],bx
MUSfixup:	

	;
	; We now need to patch in the segment address in the UMBFARTABLE
	; in umbseg.asm
	;

	xor	eax, eax
	mov	ax, gs
	mov	es, ax 			; es = R_CODE
	mov	cx, UMBADDRLEN		; cx = number of segments to patch
	mov	ax, bx			; ax = the UMB seg where R1_CODE is.
	mov	di, OFFSET R_CODE:UMBFARTABLE
	add	di, 2
MUSpatch:
	stosw
	add	di, 2
	loop	MUSpatch

	; Update word containing segment address of R1_CODE

	assume	es:R_CODE
	mov	es:[segR1_CODE], ax
	assume	es:NOTHING

	;
	; We now need to update our XMS entry point segment in the XMS 
	; chain. Note that we have saved the address at which we patched
	; rXMMentry's seg address in XMMHookAddr (xms.asm)
	;
	les	di, cs:[XMMHookAddr]
	stosw
	; 
	; We now need to set up the RDSdata in Win386VxdRefDat. Since this 
	; is in the _DATA segment we have to swicth to protct mode. This has 
	; to be initialized to InstanceData. The latter is defined in the 
	; R1_CODE seg that has just been moved to UMB. The segment of this 
	; UMB is passed in ax to the int protTrap handler defined in 
	; pictrap.asm. Also this call will update the GDT entries for R1_CODE
	; to the new base address.
	;

ifdef DEBUG
	push	ax			; save UMB segment on stack
endif

	or	gs:[TrapFlags],fSetInstPtr
					; dispatch to set inst ptr
	int	ProtTrap		; enter protected mode


	; The R1_CODE segment has been moved to the UMB.  Tell the debugger
	; where it now resides.

ifdef DEBUG
	mov	al, 40h 		; code segment & selector
	mov	bx, seg R1_CODE 	; bx = segment to define
	pop	cx			; cx = UMB segment addr
	mov	dx, R1CODE_GSEL 	; dx = selector
	call	DebDefineSeg
endif

	ret

MovUmbSeg	endp	


;******************************************************************************
;
; Code from Toshiba to set upper memory exclusion areas on some Toshiba
; systems.

RESUME_SEG	equ	0F000H					
RESUME_ID_OFF	equ	0E024H					

BACKUP_RAM_SIZE	equ	0E02AH
BACKUP_RAM_STRT	equ	0E02BH
HARD_RAM_SIZE	equ	0E02DH
HARD_RAM_STRT	equ	0E02EH

RESUME_ID_1st	equ	'R'					

HARD_RAM_TYPE	equ	70H					

SetToshibaOptions proc near

	call	IsToshiba		; Is this a Toshiba machine?
	jnz	sto_ret 		;   no, exit this routine

;	Check which type of machine we are running EMM386 on.
;	This is important, since certain segments are used by resume
;	& hardRAM machines, and therefore cannot be used
;	as EMM pages.

	push	es						
	mov	ax,RESUME_SEG					
	mov	es,ax		     
				
	push	bx

;	Now second byte of Resume ID may contain flag bits, so check for
;	each byte separate (Rx).  "R" indicates resume machine, second byte,
;	if not 0 contains NMI, HardRAM, Backup RAM mapping info.

	cmp	byte ptr es:[RESUME_ID_OFF], RESUME_ID_1st ; check for 'R'		

	jne	IE_resume_e				   

;	Pick up Backup RAM mapping info from Resume ID area (if new
;	machine type -- T3300SL); otherwise set exclude areas to defaults.

	bt	word ptr es:[RESUME_ID_OFF + 1],2 ; test if Bkup RAM @ dflt loc: e800-efff
	jc	short IE_BRAM_Mapped		; brif Bckup RAM mapping defined (NOT e000-e7ff)
	mov	word ptr cs:[BRAMbeg],0E800h	; Backup RAM is @ default loc: E800-EFFF
	mov	word ptr cs:[BRAMend],0Efffh
	jmp	short IE_resume_e
IE_BRAM_Mapped:
	mov	bx,word ptr es:[BACKUP_RAM_STRT]	; get Bkup RAM start seg
	mov	ax,word ptr es:[BACKUP_RAM_SIZE]	; get Bkup RAM size in KB
	shl	ax,6				; Bkup RAM size in bytes
	add	ax,bx				; size + beg = Bkup RAM end seg
	dec	ax				; back off to xfff
	mov	cs:[BRAMbeg],bx			; save beg to exclude Bkup RAM
	mov	cs:[BRAMend],ax			; save end to exclude Bkup RAM

IE_resume_e:							

	push	cx						
	push	dx						

	mov	dl,80H						
	mov	ah,21						
	int	13H						
	jc	IE_hard_ram_1					
	cmp	ah,HARD_RAM_TYPE				
	je	IE_hard_ram_2					
IE_hard_ram_1:							
	mov	dl,81H						
	mov	ah,21						
	int	13H						
	jc	IE_hard_ram_e					
	cmp	ah,HARD_RAM_TYPE				
	jne	IE_hard_ram_e					
IE_hard_ram_2:							

;	Pick up HardRAM mapping info from Resume ID area (if new
;	machine type -- T3300SL); otherwise set exclude areas to defaults.

	bt	word ptr es:[RESUME_ID_OFF+1],3 ; test if Hard RAM @ dflt loc: e000-e7ff
	jc	short IE_HRAM_Mapped		; brif Hard RAM mapping defined (NOT e000-e7ff)
	mov	word ptr cs:[HRAMbeg],0E000h	; Hard RAM is @ default loc: E000-E7FF
	mov	word ptr cs:[HRAMend],0E7ffh
	jmp	short IE_hard_ram_e
IE_HRAM_Mapped:
	mov	bx,word ptr es:[HARD_RAM_STRT]	; get Hard RAM start seg
	mov	ax,word ptr es:[HARD_RAM_SIZE]	; get Hard RAM size in KB
	shl	ax,6				; Hard RAM size in bytes
	add	ax,bx				; size + beg = Hard RAM end seg
	dec	ax				; back off to xfff
	mov	cs:[HRAMbeg],bx			; save beg to exclude Hard RAM
	mov	cs:[HRAMend],ax			; save end to exclude Hard RAM

IE_hard_ram_e:							
	pop	dx						
	pop	cx						
	pop	bx

	pop	es

sto_ret:
	ret

SetToshibaOptions endp

;******************************************************************************
;
; IsToshiba - check to see if we're on a Toshiba 386 machine
;
;	in:   none
;	out:  toshiba_machine = 1 and Z flag set if Toshiba
;	used: flags
;

IsToshiba proc	near

	push	es
	push	ds
	push	di
	push	si
	push	cx

	les	di, pToshiba		;es:di -> possible Toshiba signature
	push	cs
	pop	ds
	mov	si, offset szToshiba	; "TOSHIBA "
	mov	cx, 8
	cld
	rep cmpsb

	pop	cx
	pop	si
	pop	di
	pop	ds
	pop	es

	jnz	it_ret
	mov	toshiba_machine, 1

it_ret:
	ret

IsToshiba endp

LAST	ends				; End of segment
	end				; End of module
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\kbd.asm ===
.386p
page	58,132
;******************************************************************************
	title	KBD.ASM - - protected mode AT keyboard driver
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386D.EXE - MICROSOFT Expanded Memory Manager 386 DEBUG Driver
;
;   Module:   KBD.ASM - - protected mode AT keyboard driver for debugger
;
;   Version:  0.04
;
;   Date:     January 31, 1986
;
;   Author:
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   01/31/86  Original
;	      A-WCC	Removed STIs and changed CLI/STIs to keep interrupt
;			status stable (OFF) during debugger execution.	The
;			specific problem was in reporting unexpected traps
;			fielded from Virtual Mode during DOS execution,
;			e.g. timer ticks.
;	      B-WCC	Fixed Ctrl-NumLock, Ctrl-Alt-Del, Ctrl-Break, and
;			Shift-PrtSc
;   05/12/86  C-RRH	Cleanup and segment reorganization
;   06/28/86  0.02	Name changed from CEMM386 to CEMM (SBP).
;   07/05/86  0.04	Moved to DCODE segment (SBP).
;
;******************************************************************************
;
;   Functional Description:
;
;	THIS CODE IS USED BY THE DEBUGGER ONLY !
;
;	This is a PC/AT keyboard driver capable of running
;	in protected mode. It does not require any ROM support.
;
;	The major modifications are:
;
;		- Remove foreign tables, use US only
;		- Hard code machine type rather than looking in ROM
;		- hard code BeepFreq, BeepDur
;		- removed KeyVector, put read-only data in CS
;		- removed Accent stuff, which had code writes
;		- removed code writes in foreign kbd
;		- removed INT 15h sysreq and post
;		- removed T&SR stuff, added buffer read routine "getc"
;		- made it polled, removed all interrupt stuff
;		- changed "data" segment to "romdata"
;
;
;	SCCSID = @(#)keybxx.asm 4.1 85/10/09
;------------------------------------------------------
;
;	KEYBXX - foreign keyboard driver.
;
;	April 1985 by Michael Hanson
;	Copyright 1985 by Microsoft Corporation
;
;	KeybXX is a keyboard handling program using tables
;	supplied in a separate file to do foreign language
;	keyboard support. It is the basis for the KEYB??.EXE
;	programs which use this program and the corresponding
;	table defined in KEYB??.ASM.
;
;	KeybXX.OBJ must be linked with one of the Keyb??.OBJ
;	programs to work, the KEYB?? file must be first.
;	See the accompanying makefile for examples.
;
;	Note: KEYB?? refers to any of KEYBFR ( French ),
;		KEYBGR (German), KEYBUK (United Kingdom),
;		KEYBIT (Italian), KEYBSP (Spanish) and
;		KEYBDV (Dvorak).  These are the currently
;		defined data tables for KEYBXX.
;
;	Compatability notes:
;	1.	The IBM foreign keyboard drivers don't return
;		anything for a CTRL-ALT space.	This is not
;		what I expect from the manuals, but for
;		compatibility, KEYBXX doesn't return anything
;		in this case either.
;
;	2.	For the AT the keyboard driver should do a post
;		call (int 15).	The ROM keyboard driver does, but
;		IBM's foreign keyboard drivers appear not to.
;		Currently KEYBXX does a post code, though only
;		one is issued at any one time (that is, only 1 post
;		call for the 2 characters returned by an illegal
;		accent combination).
;
;	This program is a modified version of the keyboard handler from -
;
;	Microsoft Mach 10 Enhancement Software
;
;	Copyright 1984 by Microsoft Corporation
;	Written June 1984 by Chris Peters
;
;******************************************************************************
.lfcond 				; list false conditionals

include vdmseg.inc
include desc.inc
include kbd.inc
include oemdep.inc

;
;***	Routines used by data table modules (Keyb??)
;
public	SpecKey
public	AlphaKey
public	NormalKey
public	Keys$2$13
public	CapKey
public	Cap$2$13
public	FuncKey
public	PadKey
public	NumKey
public	SpaceKey
public	ShiftKey
public	ScrollKey
public	StateKey
public	AltShiftKey
public	BufferFull
public	ReBoot
public	XBoot
public	PrintScreen
public	SysReq

DCODE	 segment
	assume	cs:DCODE,ds:romdata,es:nothing

;***	Tables for foreign language key layout
;	See Keyb?? files for more details

;*	Tables to map CNTRL ALT char
AltChrs 	label	byte
AltChrsEnd	label	byte
AltMap		label	byte

;*	Tables to map accented characters
AccentChTbl	label	word

AccentMpTbl	label	word

;*	Table of accent characters, shifted, ALTed and CTRLed.
;	defined using the AccChStruc struct
AccChTbl	label	word

;***	Internal variables used by KEYBXX interrupt handler
PCType		db	0fch	; type of PC running on

PC_AT	= 0FCh			;if anything else, assume PC/XT

BeepFreq	dw	ATBeepFreq	;Count for beep half-cycle
BeepDur 	dw	ATBeepDur	;Count of half-cycles to beep

;***	Normal keyboard table, used in CTRL-ALT F1 mode
;
;	See Keyb?? files for structure information.
;
ForeignTable	label	word
KeyMapTable	label	word
	public	KeyMapTable

	db	0,0			;0
	dw	BufferFull
	db	escape,escape 		;1
	dw	SpecKey
	db	"1","!" 		;2
	dw	Keys$2$13
	db	"2","@" 		;3
	dw	Keys$2$13
	db	"3","#" 		;4
	dw	Keys$2$13
	db	"4","$" 		;5
	dw	Keys$2$13
	db	"5","%" 		;6
	dw	Keys$2$13
	db	"6","^" 		;7
	dw	Keys$2$13
	db	"7","&" 		;8
	dw	Keys$2$13
	db	"8","*" 		;9
	dw	Keys$2$13
	db	"9","(" 		;10
	dw	Keys$2$13
	db	"0",")" 		;11
	dw	Keys$2$13
	db	"-","_" 		;12
	dw	Keys$2$13
	db	"=","+" 		;13
	dw	Keys$2$13
	db	8,127			;14
	dw	SpecKey
	db	9,0			;15
	dw	NormalKey
	db	"q","Q" 		;16
	dw	AlphaKey
	db	"w","W" 		;17
	dw	AlphaKey
	db	"e","E" 		;18
	dw	AlphaKey
	db	"r","R" 		;19
	dw	AlphaKey
	db	"t","T" 		;20
	dw	AlphaKey
	db	"y","Y" 		;21
	dw	AlphaKey
	db	"u","U" 		;22
	dw	AlphaKey
	db	"i","I" 		;23
	dw	AlphaKey
	db	"o","O" 		;24
	dw	AlphaKey
	db	"p","P" 		;25
	dw	AlphaKey
	db	"[","{" 		;26
	dw	NormalKey
	db	"]","}" 		;27
	dw	NormalKey
	db	13,10			;28
	dw	SpecKey
	db	CtrlShift,(255-CtrlShift)
	dw	ShiftKey
	db	"a","A" 		;30
	dw	AlphaKey
	db	"s","S" 		;31
	dw	AlphaKey
	db	"d","D" 		;32
	dw	AlphaKey
	db	"f","F" 		;33
	dw	AlphaKey
	db	"g","G" 		;34
	dw	AlphaKey
	db	"h","H" 		;35
	dw	AlphaKey
	db	"j","J" 		;36
	dw	AlphaKey
	db	"k","K" 		;37
	dw	AlphaKey
	db	"l","L" 		;38
	dw	AlphaKey
	db	";",":" 		;39
	dw	NormalKey
	db	"'",'"' 		;40
	dw	NormalKey
	db	"`","~" 		;41
	dw	NormalKey
	db	LeftShift,(255-LeftShift)
	dw	ShiftKey
	db	"\","|"                 ;43
	dw	NormalKey
	db	"z","Z" 		;44
	dw	AlphaKey
	db	"x","X" 		;45
	dw	AlphaKey
	db	"c","C" 		;46
	dw	AlphaKey
	db	"v","V" 		;47
	dw	AlphaKey
	db	"b","B" 		;48
	dw	AlphaKey
	db	"n","N" 		;49
	dw	AlphaKey
	db	"m","M" 		;50
	dw	AlphaKey
	db	",","<" 		;51
	dw	NormalKey
	db	".",">" 		;52
	dw	NormalKey
	db	"/","?" 		;53
	dw	NormalKey
	db	RightShift,(255-RightShift)
	dw	ShiftKey
	db	"*",114 		;55
	dw	PrintScreen
	db	AltShift,(255-AltShift) ;56
	dw	AltShiftKey
	db	" "," " 		;57
	dw	SpaceKey
	db	CapsState,(255-CapsState)
	dw	StateKey
	db	1,1			;59
	dw	FuncKey
	db	2,2			;60
	dw	FuncKey
	db	3,3			;61
	dw	FuncKey
	db	4,4			;62
	dw	FuncKey
	db	5,5			;63
	dw	FuncKey
	db	6,6			;64
	dw	FuncKey
	db	7,7			;65
	dw	FuncKey
	db	8,8			;66
	dw	FuncKey
	db	9,9			;67
	dw	FuncKey
	db	0,0			;68
	dw	FuncKey
	db	NumState,(255-NumState) ;69
	dw	NumKey
	db	ScrollState,(255-ScrollState)
	dw	ScrollKey
	db	0,"7"			;71
	dw	PadKey
	db	1,"8"			;72
	dw	PadKey
	db	2,"9"			;73
	dw	PadKey
	db	3,"-"			;74
	dw	PadKey
	db	4,"4"			;75
	dw	PadKey
	db	5,"5"			;76
	dw	PadKey
	db	6,"6"			;77
	dw	PadKey
	db	7,"+"			;78
	dw	PadKey
	db	8,"1"			;79
	dw	PadKey
	db	9,"2"			;80
	dw	PadKey
	db	10,"3"			;81
	dw	PadKey
	db	11,"0"			;82
	dw	PadKey
	db	12,"."			;83
	dw	ReBoot
	db	0, 0			;84 (On AT only)
	dw	SysReq

;***	Tables for keypad with ALT and control
;	Same for foreign as normal
AltKeyPad	label	byte
	db	7,8,9,-1
	db	4,5,6,-1
	db	1,2,3
	db	0,-1

CtrlKeyPad	label	byte
	db	119,-1,132,-1
	db	115,-1,116,-1
	db	117,-1,118
	db	-1,-1

;***	Table for ALT alphabetical character
;
;	Since uses alpha char as index, this is the same
;	for normal and foreign keyboards.
;
AltTable label	byte
;		 a, b, c, d, e, f, g, h, i, j, k, l, m
	db	30,48,46,32,18,33,34,35,23,36,37,38,50
;		 n, o, p, q, r, s, t, u, v, w, x, y, z
	db	49,24,25,16,19,31,20,22,47,17,45,21,44

	SUBTTL Keyboard Interrupt Handler
;***	Keyboard interrupt handler
;
handler proc	near

KbInt:
	cld
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	ds
	push	es

;	First see if there is any data in the kbd buffer.
;	Return to caller if not.

	in	al, KbStatus
	test	al, 1
	JZ	RestoreRegs
;	jnz	intr1			
intr1:
	mov	ax,romdata
	mov	ds,ax
	call	GetSCode		;Get scan code from keyboard in al
	mov	ah,al			;(ah) = scan code
	cmp	al,-1
;	jnz	KbI1
	JZ	BufferFull		;go handle overrun code
KbI1:
	mov	bx,ax
	and	bx,7fh			;(bl) = scan code without break bit
	cmp	bl,84
;	jle	KBI2
	JG	KeyRet			;ignore code if not in range
KBI2:
	shl	bx,2			;index into lookup table
;	shl	bx,1
	jmp	SHORT KbI23

;*	map CTRL-ALT char
;	look up chars in table, if found then put out corresponding
;	entry from map table.
	mov	si, offset AltChrs - 1	;Set up index to lookup
KbI21:
	inc	si			; Advance to next entry
	cmp	si, offset AltChrsEnd
	jae	SHORT KbI22		;at end of table, so no remap
	cmp	ah, cs:[si]
	jne	KbI21			;this isn't it so loop
;	Found character, so do the mapping
	sub	si, offset AltChrs
	add	si, offset AltMap	;get index into remaped table
	pop	ax			;get scan code
	mov	al, cs:[si]		;get new character to use
	jmp	PutKRet
KbI22:
	pop	ax
KbI23:
	mov	si, offset KeyMapTable
	mov	cx,cs:[si+bx]		;(cx) = lc, uc bytes
	mov	al,cl			;(al) = lc code for key
	mov	dl,[KeyState]		;(dl) = keyboard flags
	jmp	word ptr cs:[si+bx+2]	;Call appropriate key handler
;***
;	for all key handler routines,
;
;	(CX) = uc, lc code bytes from table
;	(DL) = keyboard flags byte (see equates above for bits)
;	(AL) = lc code from cl
;	(AH) = scan code from keyboard

handler endp

	SUBTTL	Key Routines
;***	Key handling routines, called as specified by the key table
;------------------------------------------------------
;
;  Alphabetical key, caps lock works as do CTRL and ALT
;
AlphaKey:
	call	NoBreak
	test	dl,AltShift
	jz	SHORT ak1
	cbw
	add	bx,ax
	mov	ah,[AltTable+bx-"a"]
	jmp	MakeAlt

ak1:	test	dl,CtrlShift
	jz	SHORT ak2
	sub	al,"a"-1
	jmp	PutKRet

ak2:	xor	bh,bh
	test	dl,RightShift+LeftShift
	jz	SHORT ak3
	or	bh,CapsState
ak3:	mov	cl,dl
	and	cl,CapsState
	xor	bh,cl
	jz	SHORT ak4
	mov	al,ch
ak4:	jmp	PutKRet

;------------------------------------------------------
;
;  Keys that do something different when CTRL is down
;
SpecKey:
	call	NoAlt
	test	dl,CtrlShift
	jz	SHORT bsp1
	mov	al,ch
bsp1:	jmp	PutKRet

;-----------------------------------------------------
;
;   Normal, Non Alphabetic key
;
NormalKey:			;These return nothing on ALT
	call	NoAlt
	test	dl,CtrlShift
	jz	SHORT nk0
	jmp	short Ca20 ;ky21

Keys$2$13:			;Keys #2 - 13 have ALT codes 120,...
	call	NoBreak
	test	dl,AltShift
	jz	SHORT Ky2
	add	ah,120-2
	jmp	MakeAlt

ky2:	test	dl,CtrlShift
	jnz	SHORT Ca20	;handle CTRL key same as for CapKey
nk0:
	test	dl,RightShift+LeftShift
	jz	SHORT nk1
	mov	al,ch
nk1:	jmp	PutKRet

;-----------------------------------------------------
;
;   Non Alphabetic key for which cap lock works
;
CapKey: 			; CAPLOCK works, ALT doesn't
	call	NoAlt
	test	dl,CtrlShift
	jz	SHORT ca5
	jmp	short ca20 ;ca3

Cap$2$13:			; KEYS 2-13 with CAPLOCK working
	call	NoBreak
	test	dl,AltShift
	jz	SHORT ca2
	add	ah,120-2
	jmp	MakeAlt

ca2:	test	dl,CtrlShift
	jz	SHORT ca5
ca20:	cmp	ah, 3		;Keep CTRL keys at same scan code locations
	jnz	SHORT ca21
	jmp	MakeAlt
ca21:	cmp	ah, 7
	jnz	SHORT ca22
	mov	al, 30
	jmp	short ca7
ca22:	cmp	ah, 26
	jnz	SHORT ca23
	mov	al, 27
	jmp	short ca7
ca23:	cmp	ah, 27
	jnz	SHORT ca24
	mov	al, 29
	jmp	short ca7
ca24:
	cmp	ah, 43
	jnz	SHORT ca25
	mov	al, 28
	jmp	short ca7
ca25:	cmp	al, '-' 	;Except for - key, which moves around.
	jnz	SHORT ca26
	mov	al, 31
	jmp	short ca7
ca26:	jmp	KeyRet


ca5:	xor	bh,bh
	test	dl,RightShift+LeftShift
	jz	SHORT ca6
	or	bh,CapsState
ca6:	mov	cl,dl
	and	cl,CapsState
	xor	bh,cl
	jz	SHORT ca7
	mov	al,ch
ca7:	jmp	PutKRet

;---------------------------------------------------
;
;  Scroll Lock, Caps Lock, Num Lock
;
ScrollKey:
	test	ah,80h
	jnz	SHORT stk0
	test	dl,CtrlShift
	jz	SHORT stk1
	mov	ax,[KbStart]
	mov	[KbHead],ax
	mov	[KbTail],ax
	mov	[fBreak],80h
	call	EnableKB
	mov	ax,0003 		;*a simulate ^C
	jmp	PutKRet
NumKey: 				; NUM LOCK key
	test	ah,80h
	jnz	SHORT stk0
	test	dl,CtrlShift
	jz	SHORT stk1
	or	[BreakState],HoldState	; CTRL NUMLOCK
	call	VideoOn
nlk1:
	call	handler 		;*a (look for key since no interrupts)
	test	[BreakState],HoldState	; Wait for a key press
	jnz	nlk1
	jmp	RestoreRegs

StateKey:				; Toggle key
	test	ah,80h
	jz	SHORT stk1
stk0:	and	[BreakState],ch 	; Indicate key no longer held down
	jmp	short shf4

stk1:	mov	ah,al
	and	al,[BreakState]
	jnz	SHORT shf4		; Ignore if key already down
	or	[BreakState],ah 	; Indicate key held down
	xor	dl,ah			; Toggle bit for this key
	jmp	short shf3		; And go store it.

;---------------------------------------------------
;
;  Alt Shift
;
AltShiftKey:
	test	ah,80h
	jz	SHORT shf2		; Indicate that ALT key down
	xor	al,al
	xchg	al,[AltKey]		; Find numeric code entered
	or	al,al
	jz	SHORT shf1		; Just reset indicator if none
	and	[KeyState],ch
	xor	ah,ah			; Make it a key with 0 scan code
	jmp	PutKRet

;----------------------------------------------------
;
;  Shift, Ctrl
;
ShiftKey:
	test	ah,80h
	jz	SHORT shf2
shf1:	and	dl,ch			; Unset indicator bit for break code
	jmp	short shf3
shf2:	or	dl,al			; Set indicator bit for make code
shf3:	mov	[KeyState],dl
shf4:	jmp	KeyRet

;----------------------------------------------------
;
;  Reboot System?
;
ReBoot: call	NoBreak 	; Del key pressed, check CTRL ALT DEL
	test	dl,AltShift
	jz	SHORT pdk2
	test	dl,CtrlShift
	jz	SHORT pdkx
XBoot:		     			; Reboot system.
	mov	ax,romdata		; ds = romdata segment
	mov	ds,ax
	mov	[fReset],1234h
;*a
;*a  02/12/86 wcc - use shutdown code 10 and [40:67] to return to real mode
;*a		    and enter the ROM at the CTRL-ALT-DEL entry point
;*a
	cli				; make sure
	mov	al,0Fh or 80h		; shutdown byte address/disable NMI
	out	70h,al			; write CMOS address
	jmp	short $+2		; (delay)
	mov	al,0Ah			; Shutdown code 10 = jump [dword @40:67]
	out	71h,al			; write shutdown code to shutdown byte
;
;   Set up entry point after the reset
;
	mov	ds:[67h],0EA81h 	; offset of CTRL-ALT-DEL entry point
	mov	ds:[67h+2],0F000h	; segment of CTRL-ALT-DEL entry point
;
;   Reset the CPU
;
	mov	al,0FEh 		; FEh = pulse output bit 0 (286 reset)
	out	64h,al			; command to 8042
	hlt				; don't want to coast

;----------------------------------------------------
;
;  Key Pad Key
;
PadKey:
	mov	bl,[AltKey]
	call	NoBreak2
	test	dl,AltShift
	jz	SHORT pdk2		; Not entering a character number
	xor	bx,bx
	mov	bl,cl
	mov	cl,cs:AltKeyPad[bx]	; Get numeric value for this key
	cmp	cl,-1
	jz	SHORT pdk0		; Start over if non-digit key
	mov	al,10
	mul	[AltKey]
	add	al,cl
	jmp	short pdk1
pdk0:	xor	ax,ax
pdk1:	mov	[AltKey],al
pdkx:	jmp	KeyRet

pdk2:	mov	al,0
	test	dl,CtrlShift
	jz	SHORT pdk3
	xor	bx,bx		; Lookup CTRL keypad key code
	mov	bl,cl
	mov	ah,cs:CtrlKeyPad[bx]
	jmp	short pdk6
pdk3:	cmp	ah,74		; - key independent of shift state
	jz	SHORT pdk41
	cmp	ah,78		; + key independent of shift state
	jz	SHORT pdk41
	xor	bx,bx
	test	dl,RightShift+LeftShift
	jz	SHORT pdk4
	or	bh,NumState
pdk4:	mov	cl,dl
	and	cl,NumState
	xor	bh,cl
	jz	SHORT pdk5
pdk41:	mov	al,ch		; use char2 if shifted or in numlock
pdk5:	or	al,al
	jnz	SHORT pdk7
pdk6:	cmp	ah,-1
	jz	SHORT pdk8	; Ignore CTRL with keypad 2, etc.
	cmp	ah,76
	jz	SHORT pdk8
pdk7:	jmp	PutKRet
pdk8:	jmp	KeyRet

;----------------------------------------------------
;
;  Function Key
;
FuncKey:
	call	NoBreak
	test	dl,AltShift+CtrlShift+LeftShift+RightShift
	jz	SHORT fk1		; Normal function key
	add	ah,84-59
	test	dl,AltShift+CtrlShift
	jz	SHORT fk1		; Shifted function key
	add	ah,10
	test	dl,AltShift
	jz	SHORT fk1		; Just CTRL function key
	add	ah,10
	test	dl,CtrlShift
	jz	SHORT fk1		; Just ALT  function key
	mov	bx,offset KeyMapTable
	cmp	ah,104			; CTRL ALT f1 to use normal keyboard
	jz	SHORT fk01
	cmp	ah,105			; CTRL ALT f2 for foreign keyboard
	jnz	SHORT fk1		; if not F1 or F2 then treat as ALT
	mov	bx,offset ForeignTable
fk01:
	cli				; Change translation table used
	jmp	KeyRet

fk1:	jmp	SHORT MakeAlt

;--------------------------------------------------------------------
;
;  Print Screen Key
;
PrintScreen:
	call	NoAlt
	test	dl,CtrlShift
	jz	SHORT ps1
	mov	ah,ch
	jmp	fk1
ps1:	test	dl,LeftShift+RightShift
	jz	pdk7
	call	VideoOn 	;CTRL PrtSc - enable video and do Print Screen
	jmp	SHORT RestoreRegs

;--------------------------------------------------------------------
;
;  Space Key
;
SpaceKey:
	call	NoBreak
	test	dl, CtrlShift
	jz	SHORT sp1
	test	dl, AltShift
;	jz	SHORT sp1
	JNZ	SHORT KeyRet		; Don't return anything on CTRL-ALT space
sp1:
	jmp	SHORT PutKRet

;
;  System Request Key
;
SysReq:
	test	ah, 80h
	jnz	SHORT sys2		;this is break code
	test	BreakState, SysShift
;	jz	sys1
	JNZ	SHORT KeyRet		;Ignore if SysReq already down

sys1:
	or	BreakState, SysShift		;set held down flag
	mov	ax, 08500h
	jmp	short sys3
sys2:
	and	BreakState, Not SysShift	;turn off held down flag
	mov	ax, 08501h
sys3:
	push	ax				; Save SysReq action number
	mov	al,20h				; EOI to control port
	call	EnableKB
	pop	ax
	jmp	SHORT RestoreRegs

;***	Finish up processing of interrupt
;
;*	Make this an ALT seq by removing chr code (ret scan code, 0)
MakeAlt:mov	al,0

;*	Put Key in buffer and return
PutKRet:
	call	PutKey
	cmp	[PCType],PC_AT
	jnz	SHORT KeyRet		; just return for non-AT
	cli
	mov	al,20h			; EOI to control port
	call	EnableKB
	jmp	SHORT RestoreRegs

;*	Common validity check routines (Check for ALT, ignore break codes)
;

NoAlt:	test	dl,AltShift		; Don't allow ALT with this key
	jnz	SHORT IgB1
NoBreak:				; Ignore break code for this key
	mov	bl,0
NoBreak2:
	test	ah,80h
	jnz	SHORT IgB1
	test	[BreakState],HoldState	; in hold state?
	jz	SHORT IgB0		; no...
	and	[BreakState],(255-HoldState)
	jmp	short IgB1
IgB0:	mov	[AltKey],bl
	ret
IgB1:	pop	ax		; pop off return address
	jmp	short KeyRet

;*	buffer is full, beep the speaker and return from interrupt
BufferFull:
	cli
	mov	al,20h
	call	ErrBeep
	jmp	short KeyRet1

;*	Normal return from interrupt, handle EOI and enable KB
KeyRet:
	cli
	mov	al,20h
KeyRet1:
	call	EnableKB
RestoreRegs:
	cli
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
ppp	proc	near
	ret
ppp	endp

	SUBTTL Subroutines
;***	VideoOn - enable keyboard and video
;
;	ENTRY:	Nothing
;
;	EXIT:	(dx), (al) destroyed.
;
VideoOn proc near
	mov	al,20h		; EOI to control port
	call	EnableKB	; Enable AT keyboard
	cmp	[VidMode],7
	jz	SHORT vdo1	; Do nothing for monochrome monitor
	mov	al,[VidReg]
	mov	dx,3d8h
	out	dx,al		; Enable video controller
vdo1:	ret
VideoOn endp

;***	EnableKB - Enable the keyboard interface on an AT, no effect on PC/XT.
;
;	ENTRY:	Nothing
;
;	EXIT:	(al) destroyed
;
;	EFFECTS:	Enables the Keyboard interface.
;
EnableKB	proc near
	cmp	[PCType], PC_AT
	jne	SHORT ena1		;for non-AT simply ignore
	pushf			;* save interrupt status
	cli
	call	WaitStatus
	mov	al,0AEh 	;output enable keyboard command
	out	KbStatus,al
	popf			;* restore original interrupt status
ena1:
	ret
EnableKB	endp

;***	DisableKB - Disable the keyboard interface on an AT, no effect on PC/XT
;
;	ENTRY:	Nothing
;
;	EXIT:	(al) destroyed
;
;	EFFECTS: Disables the Keyboard interface.
;
DisableKB	proc near
	cmp	[PCType], PC_AT
	jne	SHORT dis1		; Ignore if not an AT
	pushf			;* save interrupt status
	cli
	call	WaitStatus
	mov	al,0ADh 	;output disable command
	out	KBStatus, al
	popf			;* restore original interrupt status
dis1:
	ret
DisableKB	endp

;***	ErrBeep - beep the speaker
;
;	ENTRY:	Nothing
;
;	EXIT:	Nothing
;
;	USES:	(ax) - to access I/O port
;		(bx) - length of beep in cycles
;		(cx) - counter for cycle length
;
;	EFFECTS: Speaker is beeped
;
;	WARNING: Uses in/out to keyboard port to beep speaker directly.
;
ErrBeep proc near
	push	ax
	push	bx
	push	cx
	mov	bx,BeepDur	; count of speaker cycles
	in	al,KbCtl
	push	ax
	and	al,0fch 	; turn off bits 0 and 1 (speaker off)
bee1:	xor	al,2		; toggle speaker bit
	out	KbCtl,al
	mov	cx,BeepFreq
bee2:	loop	bee2		; wait for half cycle
	dec	bx
	jnz	bee1		; keep cycling speaker
	pop	ax		; restore speaker/keyboard port value
	out	KbCtl,al
	pop	cx
	pop	bx
	pop	ax
	ret
ErrBeep endp

;***	PutKey - put key in the buffer
;
;	ENTRY:	(ax) = key code and scn code to go in buffer
;
;	EXIT:	(si), (di) destroyed.
;		ints disabled.
;
;	EFFECTS: KbTail updated
;		(ax) put in buffer at end.
;		On AT - do post call.
;
;	If it isn't possible to put key in buffer (full) then beep
;	and ignore.
;	If (ax) = -1 then the key is not put in buffer.
;
PutKey	proc near
	cmp	ax, -1			; Code to ignore a key
	jz	SHORT put2
	cli				; Make sure only ones using buffer now
	mov	si,[KbTail]
	mov	di,si			; Get old buffer end and save it
	inc	si			; Advance pointer
	inc	si
	cmp	si,[KbEnd]
	jb	SHORT put01
	mov	si,[KbStart]		; Wrap to beginning if at end
put01:
	cmp	si,[KbHead]
	jnz	SHORT put1		; Buffer not Full
	pop	ax			; Drop return address
	jmp	BufferFull		; Go beep and return from interrupt
put1:
	mov	[di],ax 		; Put key in buffer at end
	mov	[KbTail],si
put2:
	ret
PutKey	endp

;***	GetSCode - read the scan code from the keyboard
;
;	ENTRY:	nothing
;
;	EXIT:	(al) = key scan code from keyboard
;		(ah) destroyed
;
;	USES:	PCType - to use PC/AT sequence, for AT - handles LEDs
;
GetSCode	proc near
	cmp	[PCType], PC_AT
	je	SHORT gsc1		;handle AT differently
	in	al,KbData		;get key code
	xchg	bx,ax			;save scan code
	in	al,KbCtl		;acknowledge to keyboard
	mov	ah,al
	or	al,80h
	out	KbCtl,al
	xchg	ah,al
	out	KbCtl,al
	xchg	ax,bx			;(al) = scan code
	ret
gsc1:					;have to do handshake
	call	DisableKB
	pushf				;* save interrupt status
	cli
	call	WaitStatus
	in	al,KbData		;read in character
	popf				;* restore original interrupt status

;	check for and flag control bytes from keyboard
	cmp	al,ATResend
	jne	SHORT gsc2		;it isn't a resend
	cli
	or	[ATKbFlags], KbResend
	pop	bx			;throw away return address
	jmp	KeyRet			;and don't do anything more with key
gsc2:
	cmp	al,ATAck
	jne	SHORT gsc3		;it isn't an ack
	cli
	or	[ATKbFlags], KBAck
	pop	bx			;throw away return address
	jmp	KeyRet			;and don't do anything more with key
gsc3:
	call	UpdateLeds		;update AT's leds
	ret
GetSCode	endp

;***	Don't need to keep code after here when not running on an AT
xt_endcode:

;***	UpdateLeds - update the leds on the AT keyboard
;
;	ENTRY:	Nothing
;
;	EXIT:	All regs preserved
;
;	EFFECTS: Sets the keyboard LEDs according to the status byte.
;
;	WARNING: Assumes it is operating on an AT, must not be called for a PC.
;
UpdateLeds	proc	near
	pushf				;* save interrupt status
	push	ax
	cli
	mov	ah, KeyState		; get the toggle key states
	and	ah, CapsState + NumState + ScrollState
	rol	ah, 1
	rol	ah, 1
	rol	ah, 1
	rol	ah, 1			; in format for ATKbFlags
	mov	al, ATKbFlags
	and	al, 07h
	cmp	ah, al
	jz	SHORT Updn1		; No change in leds, so don't update
	test	ATKbFlags, KBSndLed
	jnz	SHORT Updn1		; Already updating, so don't update
	or	ATKbFlags, KBSndLed
	mov	al, 20h
	mov	al, 0EDh		; Set indicators command
	call	SendByte
	test	ATKbFlags, KBErr
	jnz	SHORT Updn2
	mov	al, ah			; Send indicator values
	call	SendByte
	test	ATKbFlags, KBErr
	jnz	SHORT Updn2
	and	ATKbFlags, 0F8h
	or	ATKbFlags, ah		; Record indicators
Updn2:
	and	ATKbFlags, Not (KBSndLed + KBErr)
Updn1:
	pop	ax
	popf				;* restore original interrupt status
	ret
UpdateLeds	endp

;***	SendByte - send a byte to the keyboard
;
;	ENTRY:	(al) - command/data to send
;
;	EXIT:	BreakState flags set according to success of operation.
;		Ints disabled on completion.
;
;	USES:	(al) - byte to send.
;		(ah) - count of retries.
;		(cx) - time out counter on wait for response.
;
;	Send the byte in al to the AT keyboard controller, and
;	do handshaking to make sure they get there OK.
;	Must not be called for the PC.
;
SendByte	proc near
	push	ax
	push	cx
	mov	ah, 03		; Set up count of retries
Sen1:
	pushf				;* save interrupt status
	cli
	and	ATKbFlags, Not (KBResend + KBAck + KBErr)
	push	ax		; save byte to send
	call	WaitStatus	; Wait for keyboard ready
	pop	ax
	out	KbData, al	; Send byte to keyboard
	popf				;* restore original interrupt status
	mov	cx,2000h	; Time out length, Approximate value for AT ROM
Sen2:				; Wait for ACK
	call	handler 		;*a (look for key since no interrupts)
	test	ATKbFlags, KBResend + KBAck
	jnz	SHORT Sen4
	loop	Sen2
Sen3:				; Timed out - try to resend
	dec	ah
	jnz	Sen1
	or	ATKbFlags, KBErr
	jmp	SHORT Sen5
Sen4:
	call	handler 		;*a (look for key since no interrupts)
	test	ATKbFlags, KBResend
	jnz	Sen3
Sen5:
	cli
	pop	cx
	pop	ax
	ret
SendByte	endp

;***	WaitStatus - wait for status to indicate ready for new command
;
;	ENTRY:	Nothing
;
;	EXIT:	(AL) Destroyed.
;
WaitStatus	proc near
	push	cx
	xor	cx,cx
wai1:				;wait for empty buffer
	in	al,KbStatus
	test	al,BufFull
	loopnz	wai1
	pop	cx
	ret
WaitStatus	endp

	SUBTTL Initialization
;*	Initialization, called when run by DOS, doesn't stay resident.
;
init_bios:
	mov	al,0ffh 		; all OFF
	out	MASTER_IMR,al

	push	ds
	push	cs
	pop	ds		; establish segment, since offsets are from cs
	mov	dx,offset Kbint
	mov	ax,2509h
	int	21h		;Set interrupt 9 (keyboard) vector

	mov	ax, romdata
	mov	ds, ax
init1:	cmp	[KbStart],0
	jnz	SHORT init2		;New PC/AT - KbStart already initialized
	pushf				;* save interrupt status
	cli			;For old PC - initialize pointers to KbBuffer
	mov	ax,offset KbBuffer
	mov	[KbStart],ax
	mov	[KbHead],ax
	mov	[KbTail],ax
	mov	[KbEnd],offset KbBufferEnd
	popf				;* restore original interrupt status
init2:				; Start up in Foreign keyboard mode

	assume	ds:romdata
	pop	ds

	mov	ah, 14
	mov	al, 'i'
	int	10h
ini1:
	call	handler
	jz	ini1
	mov	ah, 14
	int	10h
	jmp	ini1

DCODE	 ends

;***	getc - read character out of keyboard buffer
;
;	This routine gets characters from the buffer
;	in the ROM data area.
;
;	ENTRY
;
;	EXIT	AL - character
;		AH - scan code
;		'Z' = 0
;
;		or 'Z' = 1 if no code available
;
;	USES	flags
;

DCODE	 segment

	assume	cs:DCODE, ds:nothing, es:nothing, ss:nothing

	public	kgetc
kgetc	proc	far

	push	bx
	push	cx
	push	dx
	push	si
	push	di

	mov	bx, 202h
	mov	cx, 303h
	mov	dx, 404h
	mov	si, 505h
	mov	di, 606h

	call	handler 		; pull data into kbd buffer

	mov	bx, 2020h
	mov	cx, 3030h
	mov	dx, 4040h
	mov	si, 5050h
	mov	di, 6060h

	push	ds			; save caller's regs
	push	bx

	mov	bx, romdata
	mov	ds, bx			; DS -> ROM data area

	cli
	mov	bx, ds:[KbHead] 	; bx = start of buffer
	cmp	bx, ds:[KbTail] 	; is buffer empty
	jz	SHORT ge1

	cli
	mov	ax, [bx]		; AX = character and scan code
	add	bx, 2			; step buffer pointer
	cmp	bx, ds:[KbEnd]		; is it at end of buffer
	jne	SHORT ge2
	mov	bx, ds:[KbStart]	; move it back to start
ge2:
	mov	ds:[KbHead], bx 	; store new start pointer
	and	bx, 0ffffh		; just to clear zero flag
ge1:
	pop	bx
	pop	ds

	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx

	ret

kgetc	endp

DCODE	 ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\memmonf.asm ===
.386p
page	58,132
;******************************************************************************
	title	MEMMONF - ON/OFF module for EMM386
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386.EXE - MICROSOFT Expanded Memory Manager 386
;
;   Module:   MEMMONF - parse for on/off/auto and perform the function
;
;   Version:  2.00
;
;   Date:     June 4, 1986
;
;   Author:   Brad Tate
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION                  DESCRIPTION
;   --------  --------  -------------------------------------------------------
;   06/04/86  Original
;   06/28/86  0.02	Name change from CEMM386 to CEMM (SBP).
;   07/14/86  0.06	displays inaccessible message (SBP).
;   06/07/87  2.00	Added Weitek switches (SBP).
;   07/27/87  2.02	Changed Weitek switches to W=ON/W=OFF.
;			Also updated get_token to only convert chars to lower
;			case (SBP).
;
;******************************************************************************
;
;   Functional Description:
;	CEMMONF is used by CEMM.EXE UTILITY code and CEMM.COM to parse
;   the command line for ON, OFF, AUTO, W=ON, or W=OFF and perform the function
;   via a call to ELIM_Entry.  This utility can also enable or disable
;   the Weitek Coprocessor support for a system which has a Weitek installed.
;   It also displays the appropriate message depending on the results of
;   the parsing and call to ELIM_Entry.
;
;******************************************************************************
.lfcond					; list false conditionals
	page
;******************************************************************************
;			P U B L I C   D E C L A R A T I O N S
;******************************************************************************
;
	public	onf_func
	public	get_token
;
;******************************************************************************
;			E X T E R N A L   R E F E R E N C E S
;******************************************************************************
include vdmseg.inc
include	emm386.inc
include	desc.inc


R_CODE	segment

	extrn	UMBHMA:byte
	extrn	Current_State:word

R_CODE	ends

LAST	segment
 	extrn 	Inst_chk:near
	extrn	ELIM_link:near
;***************************************************************************
;	external messages
;***************************************************************************
 	extrn 	OF_not_there:byte
 	extrn 	OF_vmode:byte
 	extrn 	OF_rmode:byte
 	extrn 	OF_inaccess:byte
 	extrn 	OF_amode:byte
 	extrn 	OF_verror:byte
 	extrn 	OF_rerr:byte
 	extrn 	OF_aerr:byte
 	extrn 	OF_won_mode:byte
 	extrn 	OF_woff_mode:byte
 	extrn 	OF_won_err:byte
 	extrn 	OF_woff_err:byte
 	extrn 	OF_w_not_inst:byte
 	extrn 	OF_w_inaccess:byte
 	extrn 	OF_parmerr:byte
	extrn	OF_invparm:byte
	extrn	OF_proterr:byte

	extrn	FarLink:dword
	extrn	I_Message_Display:near
	extrn	E_XStatus_Display:near

LAST	ends

;
	page
;******************************************************************************
;			L O C A L   C O N S T A N T S
;******************************************************************************
	include	ascii_sm.equ
	include emmfunct.inc
;
MSDOS		equ	21h			; MS-DOS function call
;
;  AX values for CEMM functions
;
CEMMF_SETON	equ	0100h		; set mode to ON
CEMMF_SETOFF	equ	0101h		; set mode to OFF
CEMMF_SETAUTO	equ	0102h		; set mode to AUTO

CEMMF_SENSEW	equ	0200h
CEMMF_SETWON	equ	0201h		; set Weitek support ON
CEMMF_SETWOFF	equ	0202h		; set Weitek support OFF

;******************************************************************************
;			S E G M E N T   D E F I N I T I O N
;******************************************************************************
;
LAST	segment
	assume	cs:LAST, ds:LAST, es:NOTHING, ss:NOTHING
;
;******************************************************************************
;			L O C A L   D A T A   A R E A
;******************************************************************************
;
;
mode_msg_tbl		label	word	; table of mode status messages
		dw	offset OF_vmode	; on
		dw	offset OF_rmode	; off
		dw	offset OF_amode	; auto

;
; local storage for get_token tokens
;
arg_str		db	max_arg_len	dup(0)

;
;	the valid arguments
;
on_arg		db	"on"		; CEMM -> ON mode
on_len		equ	(this byte - on_arg)

off_arg		db	"off"		; CEMM -> OFF mode
off_len		equ	(this byte - off_arg)

auto_arg	db	"auto"		; CEMM -> AUTO Mode
auto_len	equ	(this byte - auto_arg)

won_arg		db	"w=on"		; CEMM Weitek support on
won_len		equ	(this byte - won_arg)

woff_arg	db	"w=off"		; CEMM Weitek support on
woff_len	equ	(this byte - woff_arg)

help_arg	db	"/?"		; help text
help_len	equ	(this byte - help_arg)


;
; Tables of valid arguments and their lengths
;
arg_tbl		label	word
INDEX_ON	equ	(this byte - arg_tbl)
		dw	offset	on_arg
INDEX_OFF	equ	(this byte - arg_tbl)
		dw	offset	off_arg
INDEX_AUTO	equ	(this byte - arg_tbl)
		dw	offset	auto_arg
INDEX_WON	equ	(this byte - arg_tbl)
		dw	offset	won_arg
INDEX_WOFF	equ	(this byte - arg_tbl)
		dw	offset	woff_arg
INDEX_HELP	equ	(this byte - arg_tbl)
		dw	offset	help_arg
max_args	equ	(this byte - arg_tbl)
;
arg_len		label	word		; table of argument lengths
		dw	on_len
		dw	off_len
		dw	auto_len
		dw	won_len
		dw	woff_len
		dw	help_len
;
; flags for arguments - set when arg found
;
arg_flag	label	word
		dw	FALSE		; on_arg
		dw	FALSE		; off_arg
		dw	FALSE		; auto_arg
		dw	FALSE		; won_arg
		dw	FALSE		; woff_arg
		dw	FALSE		; help_arg
;
; State of parsing
;
arg_state	db	0
;
; flag bits for parsing state
;
fArg_Found	equ	00000001b	; Argument found
fMode_Arg	equ	00000010b	; Mode argument encountered
fWeitek_Arg	equ	00000100b	; Weitek arg encountered
fParmError	equ	00001000b	; Bad parameter(s) found

;
OFF_mode	db	0		; non-zero => CEMM OFF

page
;******************************************************************************
;	onf_func - Check command line for ON OFF or AUTO and perform function
;
;	ENTRY: es:di points to command line terminated by CR or LF
;		DS = CS
;
;	EXIT: The appropriate message is displayed
;
;	USED: none
;
;******************************************************************************
onf_func	proc	near


.8086
	push	ax
	push	dx
	push	di
	push	ds

	cld

	call	parse_args		; parse command line
	cmp	[arg_flag+INDEX_HELP],TRUE
					;Q: /? arg specified ?
	je	of_usage1		;  Y: display help text

	test	[arg_state],fParmError	;Q: any invalid args ?
	JNZ	of_invmsg1		;  Y: display msg and leave

;
; check for driver installed
;
	call	Inst_chk		; al = 0/1 => isn't/is installed
	or	al,al			; q: is it installed?
	jnz	short drvr_installed
	mov	dx,offset OF_not_there	; Not installed message
 	jmp	of_err_msg		; display message and quit
;

of_usage1:
	jmp	of_usage

of_invmsg1:
	jmp	of_invmsg

.386p
drvr_installed:



	test	[arg_state],fArg_Found	;Q: any cmd line args found ?
	JNZ	chk_mode_cmds		;  Y: check them out


	mov	ax, word ptr cs:[FarLink+2]
	mov	ds, ax	   		; ds = R_CODE
	assume	ds: NOTHING

;;	mov	ah,4			; display extended status
;;	call	ELIM_link
	call	I_Message_Display

;;	mov	ah,5			; display extended status
;;	call	ELIM_link
	call	E_XStatus_Display

	mov	ax, cs
	mov	ds, ax			; restore ds = LAST
	assume	ds:LAST
	jmp	of_status

;
; check command line args
;
;	call	parse_args		; parse command line
;	test	[arg_state],fArg_Found	;Q: any cmd line args found ?
;	JZ	of_status		;  N: display current status
;					;  Y: check for invalid parms
;of_chkprm:				;
;	test	[arg_state],fParmError	;Q: any invalid args ?
;	JNZ	of_usage		;  Y: display usage msg and leave
;					;  N: execute user's commands
;
; check for Mode commands
;
chk_mode_cmds:
	test	[arg_state],fMode_Arg		;Q: mode arg given ?
	jz	SHORT of_chkWeitek		;  N: check Weitek args
						;  Y: check mode arg
	cmp	[arg_flag+INDEX_ON],TRUE	;Q: ON arg specified ?
	jne	SHORT of_chkOFF			;  N: check for OFF arg

	mov	ax, word ptr cs:[FarLink+2]
	mov	ds, ax
	assume	ds: R_CODE
	test	ds:[Current_State],fState_Active	; Q: are we active
	mov	ax, cs
	mov	ds, ax			; restore ds 
	assume	ds:LAST
	jnz	of_on				; Y: turn on
	
	smsw	ax
	test 	ax, MSW_PROTECT			; Q: is the mc in real mode
	jz	of_on				; Y: turn on
	mov	dx, offset OF_proterr		
	jmp	of_err_msg

of_on:	
	mov	ax,CEMMF_SETON			;  Y: turn CEMM ON
	call	ELIM_link			;Q: CEMM -> ON mode ?
	jnc	SHORT of_chkWeitek		;  Y: chk Weitek cmds
	mov	dx,offset OF_verror		;  N: report error and stop
	jmp	of_err_msg
of_chkOFF:
	cmp	[arg_flag+INDEX_OFF],TRUE	;Q: OFF arg specified ?
	jne	SHORT of_chkAUTO		;  N: check for AUTO arg
	mov	[OFF_mode],0FFh			;  Y: set OFF flag & do OFF cmd
	mov	ax,CEMMF_SETOFF			; turn CEMM OFF
	call	ELIM_link			;Q: CEMM -> OFF mode ?
	jnc	SHORT of_chkWeitek		;  Y: chk Weitek cmds
	mov	dx, offset OF_rerr		;  N: report error and stop
	jmp	of_err_msg
of_chkAUTO:
	cmp	[arg_flag+INDEX_AUTO],TRUE	;Q: AUTO arg ?
	jne	SHORT of_chkWeitek		;  N: chk Weitek args
	mov	ax,CEMMF_SETAUTO		;  Y: CEMM to AUTO mode
	call	ELIM_link			;Q: CEMM -> AUTO mode ?
	jnc	SHORT of_chkWeitek		;  Y: chk Weitek cmds
	mov	dx,offset OF_aerr		;  N: report error and stop
	jmp	of_err_msg

;
; check for Weitek commands
;
of_chkWeitek:
	test	[arg_state],fWeitek_Arg		;Q: any Weitek arg ?
	jz	SHORT of_status			;  N: display current status
	mov	ax,CEMMF_SENSEW			;  Y: chk for Weitek installed
	call	ELIM_link
	test	al,1				;Q: Weitek installed ?
	jnz	SHORT of_chkWON			;  Y: chk Weitek arg
	mov	dx,offset OF_w_not_inst		;  N: Weitek not installed msg
	jmp	of_err_msg			;     & leave
of_chkWON:
	cmp	[arg_flag+INDEX_WON],TRUE	;Q: Weitek support ON ?
	jne	SHORT of_WOFF			;  N: must be OFF flag
	mov	ax,CEMMF_SETWON			;  Y: turn in on
	call	ELIM_link			;Q: Weitek support ON ?
	jnc	SHORT of_status			;  Y: display status
	mov	dx,offset OF_won_err		;  N: report error and stop
	jmp	SHORT of_err_msg
of_WOFF:
	mov	ax,CEMMF_SETWOFF
	call	ELIM_link		;Q: Weitek support OFF ?
	jnc	SHORT of_status		;  Y: display status
	mov	dx,offset OF_woff_err	;  N: report error and stop
	jmp	SHORT of_err_msg

;
; return current status of CEMM
;
of_status:
	xor	ah,ah			; get status
	call	ELIM_link		; status in ah
	mov	al,ah
	xor	ah,ah			; status in ax
	cmp	ax,1			; q: OFF (no auto) ?
	jne	SHORT chk_auto		;   n: check for auto mode
	mov	[OFF_mode],0FFh		;   y: set flag
chk_auto:
	cmp	ax,2			; q: auto mode?
	jb	SHORT mode_msg_disp	;   n: display mode
	push	ax			; save current mode
	mov	dx,offset OF_amode
	mov	ah,9
	int	MSDOS			; print auto mode
	pop	ax			; restore mode
	sub	ax,2			; get on or off indicator
mode_msg_disp:
	shl	ax,1
	mov	di,ax
	mov	dx,mode_msg_tbl[di]		; DS:DX -> status message
	mov	ah,9
	int	MSDOS			; display message
;
	cmp	[OFF_mode],0		; q: OFF mode ?
	je	SHORT w_status		; n: display weitek status
	mov	dx,offset OF_inaccess	; y: display inaccessible message also
	mov	ah,9
	int	MSDOS
	;
	; now display Weitek state msg
	;
w_status:
	mov	ax,CEMMF_SENSEW		;check for Weitek installed
	call	ELIM_link
	test	al,1			;Q: Weitek installed ?
	jz	SHORT exit		;  N: no message
					;  Y: display current Weitek state
	mov	dx,offset OF_won_mode	; assume Weitek support on
	test	al,2			;Q: Weitek support on ?
	jnz	SHORT disp_wmode	;  Y: display on msg
	mov	dx,offset OF_woff_mode	;  N: display off msg
disp_wmode:
	mov	ah,9
	int	MSDOS			; display message

	cmp	[OFF_mode],0		;Q: OFF mode ?
	je	SHORT exit		; N: leave
	mov	dx,offset OF_w_inaccess	; Y: display inaccessible message also
	mov	ah,9
	int	MSDOS
;
; leave onf
;
exit:
	pop	ds
	pop	di
	pop	dx
	pop	ax
	ret
;
; here for invalid args.  display usage message and leave
;

.8086
of_usage:
	mov	dx,offset OF_parmerr	; USAGE message
of_err_msg:
	mov	ah,9
	int	MSDOS			; display message
	jmp	exit			; leave

of_invmsg:
	mov	dx, offset OF_invparm	
	mov	ah, 9
	int	MSDOS

	mov	byte ptr es:[di], 0dh
	mov	byte ptr es:[di+1], 0ah
	mov	byte ptr es:[di+2], '$'
	sub	di, cx
	mov	dx, di
	push	es
	pop	ds
	mov	ah, 9
	int	MSDOS
	jmp	exit

	
onf_func	endp

	page
;******************************************************************************
;	parse_args - Parse command line for args
;
;	ENTRY: ES:DI points to command line terminated by CR or LF
;
;	EXIT:   DS -> CS
;		CS:state = flags set here
;		CS:arg_flags = flags set here for args found
;
;	      ES:DI points to end of parsed string
;
;	USED: flags
;
;******************************************************************************
parse_args 	proc		near
;

.386p
	push	bx
	push	si

;
; get a token from command line
;
pa_loop:
	mov	si,offset arg_str	; DS:SI = storage for argument
	mov	cx,max_arg_len		; maximum argument length
	call	get_token		; get an argument
	or	cx,cx			;Q: token found?
	jz	SHORT pa_exit		; N: quit
	or	[arg_state],fArg_Found	; Y: ok, look for it in parm table
;
; look for it in table of valid args...
;
	call	chk_token		;Q: valid arg ?
	jc	SHORT pa_invprm		;  N: set error and leave
	mov	arg_flag[bx],TRUE	;  Y: set flag for this arg

;
; check for multiple/inconsistent args
;
	cmp	bx,INDEX_AUTO		;Q: mode argument ?
	ja	SHORT pa_chkwa		;  N: check for Weitek arg
	test	[arg_state],fMode_Arg	;  Y: Q: mode arg already given ?
	jnz	SHORT pa_invprm		;       Y: invalid parameter
	or	[arg_state],fMode_Arg	;       N: set flag
	jmp	SHORT pa_next
pa_chkwa:
	cmp	bx,INDEX_WOFF		;Q: Weitek argument ?
	ja	SHORT pa_next		;  N: this arg is OK ...
	test	[arg_state],fWeitek_Arg	;  Y: Q: Weitek arg already given ?
	jnz	SHORT pa_invprm		;       Y: invalid parameter
	or	[arg_state],fWeitek_Arg	;       N: set flag

pa_next:
	jmp	pa_loop		; look for next arg

pa_exit:
	pop	si
	pop	bx
	ret

pa_invprm:
	or	[arg_state],fParmError	; set error flag
	jmp	pa_exit			; and leave
parse_args	endp

	page
;******************************************************************************
;	chk_token - is this a valid token/argument ?
;
;	ENTRY:  DS:SI points to token from command line
;		CX = length of token
;
;	EXIT:  if token found,
;		BX = offset in argument table
;		CLC
;	       else,
;		STC
;
;	USED: BX,flags
;
;******************************************************************************
chk_token	proc	near
	push	di
	push	es
	mov	bx,cs
	mov	es,bx		;  ES -> local data
;
	xor	bx,bx		; index into parameter table
ct_loop:
	cmp	cx,arg_len[bx]	;Q: lengths equal?
	jne	SHORT ct_notyet	; N: keep looking
	mov	di,arg_tbl[bx]	; Y: get destination address
	push	si		; save source string addr
	cld			;   foward
	push	cx		;   save arg length
	repe	cmpsb		;Q: is this a valid argument?
	pop	cx		;   restore arg length
	pop	si		;     restore source string address (command line)
	je	SHORT ct_found 	; Y: matched one
ct_notyet:			; N: try next arg in table
	inc	bx
	inc	bx		; update table pointer
	cmp	bx,max_args	;Q: have we done them all yet?
	jne	ct_loop		;  N: keep looking
	stc			;  Y: return not found
	jmp	SHORT ct_exit
;
ct_found:
	clc
ct_exit:
	pop	es
	pop	di
	ret
chk_token	endp

	page
;******************************************************************************
;	get_token - Retrieve a non-white-space string from a source string
;
;	ENTRY: es:di points to command line terminated by CR or LF
;	       ds:si points to storage for token
;	       cx = maximum length to store
;
;	EXIT: cx = length of token (0 => end of source string)
;	      es:di points to first char after new token in source string
;	      string of length cx stored in ds:si (and converted to lower case)
;
;	USED: see above
;
;******************************************************************************
get_token 	proc		near
	push	si		; save storage area
	push	bx
	push	ax
;
	cld
;
	mov	bx,cx		; number to store
	xor	cx,cx		; no chars found so far
;
; go to first non-blank character
;
gloop1:
	mov	al,es:[di]	; get a character
	inc	di		; point to next
	cmp	al,' '		; Q: space ?
	je	gloop1		; y: skip it
	cmp	al,TAB		; Q: TAB ?
	je	gloop1		; y: skip it
	dec	di		; N: start parsing and reset di
gloop2:
	mov	al,es:[di]	; get next char
	cmp	al,CR		; q: carriage return?
	je	SHORT token_xit	; y: quit
	cmp	al,LF		; q: line feed?
	je	SHORT token_xit	; y: quit
	cmp	al,' '		; Q: space ?
	je	SHORT token_xit	; y: quit
	cmp	al,TAB		; Q: TAB ?
	je	SHORT token_xit	; y: quit
	inc	di		; n: point to next
	inc	cx		; increment number of chars found
	cmp	cx,bx		; q: have we stored our limit yet?
	ja	gloop2		; y: don't store any more
	cmp	al,'A'		;Q: upper case ?
	jb	SHORT token_storeit	;  N: store it now
	cmp	al,'Z'		;  Y: maybe Q: Upper case ?
	ja	SHORT token_storeit	;     N: no conversion
	or	al,20h		;             Y: make it lower case
token_storeit:
	mov	ds:[si],al	; store it
	inc	si		; and point to next
	jmp	short gloop2	; continue
token_xit:
;
	pop	ax
	pop	bx
	pop	si
	ret
get_token	endp


LAST	ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\kbd.inc ===
ifndef INC_LIST
.xlist
endif
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386 - MICROSOFT Expanded Memory Manager 386
;
;   Module:   KBD.INC - KBD.ASM Structures and Equates
;
;   Version:  0.02
;
;   Date:     January 31, 1986
;
;   Author:
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   01/31/86  Original
;   05/12/86  A-RRH	Cleanup and segment reorganization
;   06/28/86  0.02	Name change from CEMM386 to CEMM (SBP).
;
;******************************************************************************
;
;   Functional Description:
;
;******************************************************************************

;	SCCSID = @(#)keybxx.inc 1.1 85/10/09
;------------------------------------------------------
;
;   Keybxx.inc - Define struct and equates for KeybXX and Keyb??.ASM .
;   April 1985 by Michael Hanson
;
;	Keyb?? - denotes any of the files keybfr, keybgr, keybit, keybuk,
;		keybsp or keybdv (Dvorak keyboard).
;


escape		equ	1bh


KbData		equ	60h	; I/O Ports for keyboard
KbCtl		equ	61h
KbStatus	equ	64h

PCBeepFreq	equ	48h	; Count for Beep frequency
PCBeepDur	equ	105h	; Number of Beep half cycles
ATBeepFreq	equ	0CEh	; Use larger values since AT faster
ATBeepDur	equ	82h

InsState	equ	80h	; Bit values for BreakState and KeyState
CapsState	equ	40h
NumState	equ	20h
ScrollState	equ	10h
HoldState	equ	08h


AltShift	equ	08h	; Bit values for KeyState
CtrlShift	equ	04h
LeftShift	equ	02h
RightShift	equ	01h


BufFull 	equ	02h	; Bit value for KbStatus port


ATResend	equ	0FEh	; AT keyboard commands
ATAck		equ	0FAh


KBErr		equ	080h	; Bit values for ATKbFlags
KBSndLed	equ	040h
KBResend	equ	020h
KBAck		equ	010h
SysShift	equ	004h	;SysReq key held down


;***	AccChStruc - Structure for information about accent keys
;
;	Contains scan and char codes returned for all shift combinations
;	with an accent key.
;
;	Note: an accent key is an accent in both normal and shifted mode.
;
AccChStruc	struc
normal	dw	0	;chr & scan code for unshifted accent key
shift	dw	0	; "     "     "  for shifted      "    "
ctrl	dw	-1
alt	dw	-1
AccChStruc	ends

.list 		; end of KBD.INC

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\memm_msg.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;	Title:	EMM386 - MICROSOFT Lightning EMM device driver
;
;	Module: MEMM_MSG.INC - messages for ON/OFF/AUTO utility
;
;	Version: 2.04
;
;	Date:	June 7,1986
;
;	Author: Brad Tate
;
;******************************************************************************
;
;	Change Log:
;
;	DATE	 REVISION	Description
;	-------- --------	--------------------------------------------
;	06/07/86 Original
;	06/28/86 0.02		Name change from CEMM386 to CEMM (SBP).
;	07/14/86 0.06		Added Inaccessible message (SBP).
;	06/07/87 2.00		Added Weitek message (SBP).
;	08/20/87 2.04		Fixed "CEMM is in Auto mode" message (SBP).
;	04/13/88 3.30  (*B)	Change error messages to match doc's (RDV).
;
;******************************************************************************
;
not_there	db	"CEMM driver not installed.",CR,LF,"$"

vmode		db	"CEMM Active.",CR,LF,"$"

rmode		db	"CEMM Inactive.",CR,LF,"$"

inaccess	db	"Expanded memory data is inaccessible until CEMM is"
		db	" re-activated.",CR,LF,"$"

amode		db	"CEMM is in Auto mode.",CR,LF,"$"

verror		db	"Unable to activate CEMM.",CR,LF,"$"

rerr		db	"Unable to de-activate CEMM.",CR,LF,"$"         ;*B

aerr		db	"Unable to place CEMM in Auto mode.",CR,LF,"$"

won_mode	db	"Weitek Coprocessor support is enabled.",CR,LF,"$"  ;*B

woff_mode	db	"Weitek Coprocessor support is disabled.",CR,LF,"$"

won_err 	db	"Unable to enable Weitek Coprocessor support"
		db	CR,LF,"$"

woff_err	db	"Unable to disable Weitek Coprocessor support"
		db	CR,LF,"$"

w_not_inst	db	"Weitek Coprocessor not installed.",CR,LF,"$"

w_inaccess	db	"Weitek Coprocessor is inaccessible until CEMM is"
		db	" re-activated.",CR,LF,"$"

parmerr 	db	"Usage: CEMM [ ON | OFF | AUTO ] [ W=ON | W=OFF ]"
		db	CR,LF,"$"


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\modesw.asm ===
.386p
page	58,132
;******************************************************************************
	title	MODESW.ASM - 386 Mode Switching Support Routines
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
;   Module:   MODESW.ASM - PC/AT Mode Switching Support Routines
;
;   Version:  2.02
;
;   Date:     January 31, 1986
;
;   Author:
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   01/31/86  Original
;   02/10/86  A-WCC	Removed STI in Enable/Disable A20 to keep debugger sane
;   05/12/86  B-RRH	Cleanup and segment reorganization
;   06/21/86  0.02	Added CLD.
;   06/28/86  0.02	Name changed from CEMM386 to CEMM (SBP).
;   07/05/86  0.04	Removed Real286
;   07/06/86  0.04	changed assume to _DATA (SBP).
;   05/08/87  2.00	moved to R_CODE segment (SBP) and added
;			GoProtMode, GoRealMode, GoVirtualMode
;   07/13/87  2.01	Fixed bug-> was not setting DS -> R_CODE before
;			calling CheckLock (SBP).
;   08/05/87  2.02	Fixed bug-> GoProt was not clearing ECX before saving
;			stack segment (SBP).
;   07/22/88  3.31 (*C) Fix 8042 handling for non-password machines (RDV).
;   01/15/89  4.00 (*D) Added generic 8042 detect (RDV)
;
;******************************************************************************
;
;   Functional Description:
;
;	This file contains routines for switching the Deskpro 386 between
;	real, protected, and virtual modes.  In general these routines
;	preserve the current register contents and maintain the current stack.
;
;******************************************************************************
.lfcond 				; list false conditionals

	public	GoProtMode
	public	GoRealMode
	public	GoVirtualMode
	public	EnableA20
	public	DisableA20
;******************************************************************************
;	D E F I N E S
;******************************************************************************

	include VDMseg.inc
	include VDMsel.inc
	include desc.inc
	include oemdep.inc
	include emm386.inc
	include emmfunct.inc
	include	emmdata.inc
	include	xmm.inc
	include	vm386.inc

;******************************************************************************
;	E X T E R N A L   R E F E R E N C E S
;******************************************************************************
R_CODE	SEGMENT
	extrn	SelToSeg:near
	extrn	XMMcontrol:dword					;HKN
ifdef MSFLAG
	extrn 	GetA20cnt:near
	extrn 	SetA20cnt:near
endif
R_CODE	ENDS

	page
R_CODE	SEGMENT
	assume cs:R_CODE,ds:R_CODE,es:R_CODE

;******************************************************************************
;	GoProtMode - go to 386 protected mode
;
;	The following CPU registers are changed to have values
;	appropriate to protected mode operation:
;
;		CS, DS, ES, SS, TR, LDT, Flags, MSW, GDT, IDT
;
;    ENTRY:	Real Mode
;		CLI
;		R_CODE:[PageD_Addr] = dword physical address of page directory
;		R_CODE:[GDT_Ptr] = GDT pointer for LGDT
;		R_CODE:[IDT_Ptr] = IDT pointer for LIDT
;
;    EXIT:	PROTECTED MODE
;		CLI
;		CS = RCODE_GSEL
;		DS,ES,FS,GS = RCODEA_GSEL
;		SS = selector for entry real mode SS segment
;		A20 enabled
;		high system memory LOCKED
;
;    USED:	flags
;
;******************************************************************************
GoProtMode	proc	near
	push	eax
	push	bx
	push	ecx

;QLEO	call	CheckLOCK		; check on initial state of table lock
;
;  A20 line must be on while in protected mode
;
	test	cs:[Current_State],fState_A20Ena;Q: A20 enabled?
ifdef MSFLAG
	jnz	GPM_getcount		; Y: don't need to enable it!
else
	jnz	short GPMcont		; Y: don't need to enable it!
endif
	call	EnableA20		; N: enable A20 address line
	jc	short GPMexit		; could not enable A20

GPMcont:
;
;    load CR3 register for paging
;
	mov	eax,cr3
	and	eax,0FFFh		; clear address
	or	eax,cs:[PageD_Addr]	; EAX = 32-bit address of Page Dir
	mov	cr3,eax
;
;Disable NMIs ...
;
	mov	al,DISABLE_NMI
	out	NMI_CMD,al

;
;   load gdt and ldt base registers  (DB 66h needed for 32 bit address)
;
	db	66h
	lgdt	fword ptr CS:[GDT_ptr]
	db	66h
	lidt	fword ptr CS:[IDT_ptr]
;
;   go protected and enable paging - turn on bits in CR0
;
	mov	eax,cr0

	or	eax,(80000000h + MSW_PROTECT) ; or EAX,imm32
		; - enable PE bit - PROT MODE, enable PG bit - PAGING

	mov	cr0,eax

;	far jump to flush prefetch, and reload CS

	db	0eah			; far jmp opcode
	dw	offset R_CODE:pm1	; offset
	dw	RCODE_GSEL		; selector
pm1:
;
;   We are now protected, set the Task Register and LDT Register
;
	mov	ax,TSS_GSEL
	ltr	ax

	xor	ax, ax			; LDT is null, not needed
	lldt	ax
;
;  Insure that CR2 is 0: This allows determination of Page Faults
;
	xor	ecx,ecx
	mov	cr2,ecx
;
; set up SS to entry stack
;
	;
	; save entry SS,SP
	;
;QLEO	xor	ecx,ecx		; clear high word
	mov	bx,sp		; save SP
	mov	cx,ss		; and SS

	;
	;  reset SS,SP -> entry stack
	;  set base of RSS_GSEL segment -> real mode SS segment
	;	entry: CX = segment of entry stack
	;	       BX = SP for entry stack
GPM_setRSS:
	mov	ax,GDTD_GSEL
	mov	ds,ax			; DS -> GDT
	shl	ecx,4			; CX = low word of base addr
	mov	DS:[RSS_GSEL][2],cx	; set low word of base addr
	shr	ecx,16			; CH = high byte of base addr
	mov	ds:[RSS_GSEL][4],cl	; set high byte of base
	mov	ds:[RSS_GSEL][7],ch	; set high byte of base

	mov	ax,RSS_GSEL
	mov	ss,ax		; set SS and
	mov	sp,bx		; entry SP

;
;...Enable NMIs again
;
GPM_ENMI:
	mov	al,ENABLE_NMI
	out	NMI_CMD,al

;
;  set DS,ES -> RCODE segment
;
	mov	ax,RCODEA_GSEL
	mov	ds,ax
	mov	es,ax
	mov	fs,ax
	mov	gs,ax
	clc

GPMexit:
	pop	ecx
	pop	bx
	pop	eax
	ret

ifdef	MSFLAG
GPM_getcount:
	call	GetA20cnt
	jmp	GPMcont
endif

;
GoProtMode	endp

;******************************************************************************
;	GoRealMode - go to 386 real mode
;
;	The following CPU registers are changed to have values
;	appropriate to real mode operation:
;
;		CS, DS, ES, SS, Flags, MSW, IDT
;
;    ENTRY:	PROTECTED MODE
;		CLI
;		CS = RCODE_GSEL
;		SS - base addr pts to a real mode segment (para boundary)
;		A20 enabled
;
;    EXIT:	REAL MODE
;		CLI
;		CS = R_CODE
;		DS,ES,FS,GS = R_CODE
;		SS = same segment as entry SS
;		A20 disabled
;		high system memory LOCKED
;
;
;    USED:	flags
;
;******************************************************************************
GoRealMode	proc	near
	push	eax
	push	bx
;
;
;   reset TSS busy bit before returning to Real Mode
;
	mov	ax, GDTD_GSEL
	mov	es, ax			; ES:0 = ptr to gdt
	and	byte ptr ES:[TSS_GSEL + 5], 11111101B

;
;	First save return ss:sp. We have to translate
;	the current ss (a selector) into a segment number.
;	Calculate a real mode segment corresponding to the
;	current protected mode stack selector base address.
;
;	We get the base address from the descriptor table,
;	and convert it to a paragraph number.
;
	mov	bx,ss			; bx = selector for stack
	call	SelToSeg		; AX = segment number for SS
	mov	bx,ax			; BX = setup stack segment
;
;
;  Intel shows DS,ES,FS,GS,and SS set up to make sure 'Real Mode' type
;  access rights, and limit are installed.  In this program, that happens
;  to already be the case, but for general purposeness, VDMD_GSEL fits
;  the bill.
;
	mov	ax,VDMD_GSEL		; selector with real mode attributes
	mov	ds,ax
	mov	es,ax
	mov	ss,ax
	mov	fs,ax
	mov	gs,ax

;
;Disable NMIs ...
;
	mov	al,DISABLE_NMI
	out	NMI_CMD,al

;
;    reset the PE bit ...
;
	mov	eax,cr0			;  get CR0
	and	eax,07FFFFFFEh		; force real mode and shut down paging
	mov	cr0,eax			; set CR0

					; flush prefetched instructions with:
	db	0EAh			; Far Jump opcode
	dw	offset R_CODE:rl386_b	; destination offset
	dw	R_CODE			; destination segment
rl386_b:
	lidt	fword ptr cs:[real_idt]

	mov	eax,cr3			; get CR3
	mov	cr3,eax			; set CR3 => clear TLB

	mov	ss,bx			; ss = real mode stack segment
	mov	ax,R_CODE
	mov	ds,ax
	mov	es,ax
	mov	fs,ax
	mov	gs,ax

;
;...Enable NMIs again
;
	mov	al,ENABLE_NMI
	out	NMI_CMD,al

ifdef	MSFLAG
	and	[Current_State],NOT fState_Active
						; MAchine is in real mode; BUGBUG
	call	SetA20cnt			; restore XMM enable count
else
	test	[GenFlags],fShutDown            ;Q: Is this a shutdown?	   910316
	jnz	short GRMexit			; Y: don't bother with A20 910316

	test	[Current_State],fState_A20Ena  	;Q: Is A20 enabled?
	jnz	short GRMexit			; Y: don't disable it

	test	[GenFlags],fXMM			;Q: Need to keep XMS coherent?
	jz	short GRMDisableA20		; N: XMM not being used
	call	EnableA20			; Y: enable count coherency

GRMDisableA20:
	call	DisableA20  			; disable A20 line

GRMexit:

endif
	pop	bx
	pop	eax
	ret
;
GoRealMode	endp

;******************************************************************************
;	GoVirtualMode - go to 386 virtual mode
;
;	The following CPU registers are changed to have values
;	appropriate to real mode operation:
;
;		CS, DS, ES, SS, Flags, MSW, IDT
;
;    ENTRY:	PROTECTED MODE
;		CLI
;		CS = RCODE_GSEL
;		SS - base addr pts to a real mode segment (para boundary)
;		A20 enabled
;
;    EXIT:	VIRTUAL MODE
;		CLI
;		CS = R_CODE
;		DS,ES,FS,GS = R_CODE
;		SS = same segment as entry SS
;		high system memory LOCKED
;
;
;    USED:	flags
;
;******************************************************************************
GoVirtualMode	proc	near
	push	ax
	push	bx
	push	cx
;
; reset NT bit so IRET won't attempt a task switch
;
	pushf
	pop	ax
	and	ax,0FFFh
	push	ax
	popf

;	Calculate a real mode segment corresponding to the
;	current protected mode stack selector base address.
;
;	We get the base address from the descriptor table,
;	and convert it to a paragraph number.
;
	mov	bx,ss			; bx = selector for stack
	call	SelToSeg		; AX = segment number for SS
	mov	bx,ax			; BX = setup stack segment

	mov	cx,sp			; save sp here
;
; build stack frame for IRET into virtual mode
;
	push	0
	push	seg R_CODE		; GS
	push	0
	push	seg R_CODE		; FS
	push	0
	push	seg R_CODE		; DS	(_DATA for variable access)
	push	0
	push	seg R_CODE		; ES

	push	0
	push	bx			;* virtual mode SS

	push	0
	push	cx			;* virtual mode ESP

	push	FLAGS_VM		; EFlags high, VM bit set
	push	3000h			;* EFlags low, NT = 0, IOPL=3, CLI

	push	0
	push	seg R_CODE			; CS
	push	0
	push	offset R_CODE:VM_return 	; IP

	iretd		; 32 bit operand size override

;
;	Enter Virtual Mode here
;
VM_return:
	or	[Current_State],fState_Active; set active flag; BUGBUG

;
; Need to maintain A20 coherency with the XMM
;
	test	[GenFlags],fXMM			;Q: XMM present?
	jz	short VMexit			; N: no coherency problem

	test	[Current_State],fState_A20Ena	;Q: Virtual A20 disabled?
	jnz	short VMexit			; N: virtual & XMM are in sync
	call	DisableA20			; Y: virtually disable A20

VMexit:
	pop	cx
	pop	bx
	pop	ax
	ret
;
GoVirtualMode	endp

ifdef 900722
ifdef MSFLAG

;******************************************************************************
;	Prot_to_Virt - go to 386 virtual mode
;
;	The following CPU registers are changed to have values
;	appropriate to real mode operation:
;
;		CS, DS, ES, SS, Flags, MSW, IDT
;
;    ENTRY:	PROTECTED MODE
;		CLI
;		CS = RCODE_GSEL
;		SS - base addr pts to a real mode segment (para boundary)
;
;    EXIT:	VIRTUAL MODE
;		CLI
;		CS = R_CODE
;		DS,ES,FS,GS = R_CODE
;		SS = same segment as entry SS
;		high system memory LOCKED
;
;
;    USED:	flags
;
;******************************************************************************
Prot_to_Virt	proc	near
	push	ax
	push	bx
	push	cx
;
; reset NT bit so IRET won't attempt a task switch
;
	pushf
	pop	ax
	and	ax,0FFFh
	push	ax
	popf

;	Calculate a real mode segment corresponding to the
;	current protected mode stack selector base address.
;
;	We get the base address from the descriptor table,
;	and convert it to a paragraph number.
;
	mov	bx,ss			; bx = selector for stack
	call	SelToSeg		; AX = segment number for SS
	mov	bx,ax			; BX = setup stack segment

	mov	cx,sp			; save sp here
;
; build stack frame for IRET into virtual mode
;
	push	0
	push	seg R_CODE		; GS
	push	0
	push	seg R_CODE		; FS
	push	0
	push	seg R_CODE		; DS	(_DATA for variable access)
	push	0
	push	seg R_CODE		; ES

	push	0
	push	bx			;* virtual mode SS

	push	0
	push	cx			;* virtual mode ESP

	push	FLAGS_VM		; EFlags high, VM bit set
	push	3000h			;* EFlags low, NT = 0, IOPL=3, CLI

	push	0
	push	seg R_CODE			; CS
	push	0
	push	offset R_CODE:PV_return 	; IP

	iretd		; 32 bit operand size override

;
;	Enter Virtual Mode here
;
PV_return:

	or	[Current_State],fState_Active; set active flag; BUGBUG

	pop	cx
	pop	bx
	pop	ax
	ret
;
Prot_to_Virt	endp


;******************************************************************************
;	Virt_to_Prot - go form 386 virtual mode to protect mode
;
;
;    ENTRY:	VIRTUAL MODE
;		CLI
;		CS = RCODE_GSEL
;		SS - base addr pts to a real mode segment (para boundary)
;		A20 enabled
;
;    EXIT:	PROTECT MODE
;		CLI
;		CS = R_CODE
;		DS,ES,FS,GS = R_CODE
;		SS = same segment as entry SS
;
;    USED:
;
;******************************************************************************


Virt_to_Prot	proc	near

	push	eax
	push	bx
	push	ecx
	push	si


	arpl	ax,ax

	;
	; VM1_GSEL -> client's stack
	; VM2_GSEL -> client's code
	;
;
; setup SS,SP,BP to point to client's stack before going to real mode
;
	mov	si, bp
	push	ss
	pop	ds				; DS:SI -> Ring 0 stack	VMTF
	push	VM1_GSEL
	pop	ss
	mov	sp, [si.VTFOE+VMTF_ESP]		; ES:DI -> client's stack


;
;  set DS,ES,FS,GS -> RCODE segment
;
	mov	ax,RCODEA_GSEL
	mov	ds,ax
	mov	es,ax
	mov	fs,ax
	mov	gs,ax


	pop	si
	pop	ecx
	pop	bx
	pop	eax

	ret

Virt_to_prot	endp

endif
endif

;******************************************************************************
;***	EnableA20 - switch 20th address line
;
;	This routine is used to enable the 20th address line in
;	the system.
;
;	ENTRY	none		;ds = DATA
;	EXIT	A20 line enabled
;	USES	ax, flags modified
;
;******************************************************************************
	assume	ds:nothing
EnableA20 proc near

	mov	ah,0dfh 		; code for enable
	test	cs:[GenFlags],fXMM	;Q: Is XMM installed
	jz	short a20common		; N: jump to common code
	mov	ah,XMM_LOCAL_ENABLE_A20 ; Y: enable function
	jmp	SHORT do_xms_a20

EnableA20 endp

;******************************************************************************
;***	DisableA20 - switch 20th address line
;
;	This routine is used to disable the 20th address line in
;	the system.
;
;	ENTRY	none		;ds = DATA
;	EXIT	A20 line disabled
;	USES	ax, flags modified
;******************************************************************************
DisableA20 proc near

	mov	ah,0ddh 		; code for disable
	test	cs:[GenFlags],fXMM	;Q: Is XMM installed
	jz	short a20common		; N: jump to common code
	mov	ah,XMM_LOCAL_DISABLE_A20; Y: disable function
	jmp	SHORT do_xms_a20

DisableA20 endp

;******************************************************************************
; a20common
;
;	This is entered via a jmp from one of the two procedural
;	entry points above.
;******************************************************************************
a20common proc near
	test	cs:[GenFlags],fP8042	;Q: Password 8042 system?
	jne	short a20j1		; Y: don't need to flush buffer
	call	empty_8042		; ensure 8042 input buffer empty
	jnz	short com1			; 8042 error return
a20j1:	mov	al,0d1h 		; 8042 cmd to write output port
	out	KYBD_CMD,al		; send cmd to 8042
	test	cs:[GenFlags],fP8042	;Q: Password 8042 system?
	jne	short a20j2		; Y: don't need to flush buffer
	call	empty_8042		; wait for 8042 to accept cmd
	jnz	short com1			; 8042 error return
a20j2:	mov	al,ah			; 8042 port data
	out	KYBD_DATA,al		; output port data to 8042
	test	cs:[GenFlags],fP8042	;Q: Password 8042 system?
	jne	short a20j3		; Y: don't need to flush buffer
	call	empty_8042
	jnz	short com1
a20j3:	mov	al,NULL_8042_CMD	; output null cmd
	out	KYBD_CMD,al
	test	cs:[GenFlags],fP8042	;Q: Password 8042 system?
	jne	short com1		; Y: don't need to flush buffer
	call	empty_8042		; and wait for it to finish
com1:
	clc
	ret

do_xms_a20:
	push	dx			;QLEO: HIMEM messes up DX
	call	cs:[XMMcontrol]
	pop	dx			;QLEO: need to fix HIMEM.SYS
	or	ax,ax
	jz	SHORT XMMerror
	clc
	ret
XMMerror:
	stc
	ret
a20common endp

;******************************************************************************
;***	empty_8042 - wait for 8042 input buffer to drain
;
;	ENTRY	none
;	EXIT	al=0, ZF => 8042 input buffer empty
;		al=2, NZ => timeout, input buffer full
;	USES	none
;******************************************************************************
empty_8042 proc near
	push	cx			; save it
	sub	cx,cx			; cx = 0, timeout loop counter
emp1:
	in	al,KYBD_STATUS		; read 8042 status port
	and	al,IN_BUF_FULL		; test buffer full bit
	loopnz	emp1
	pop	cx
	ret
empty_8042 endp

ifdef 900722
;******************************************************************************
;	CheckLOCK - Check current state of Table lock
;
;    ENTRY:	Real Mode
;
;    EXIT:	Real Mode
;		CS:[LockState] = LOCK_ROM if ROM is locked
;			       = UNLOCK_ROM if ROM is unlocked
;
;    USED:	flags
;
;******************************************************************************
CheckLOCK	proc	near
	push	ax
	push	bx
	push	es
;
	mov	cs:[LockState],LOW LOCK_ROM; default is locked
	mov	ax,X_HI_MEM_SEG
	mov	es,ax			; ES -> ROM
	mov	bx,X_MT_386		; ES:BX -> machine type byte
	mov	ax,ES:[bx]		; AX = ROM contents
	xor	ES:[bx],0FFFFh		; flip all bits in ROM
	xor	ax,0FFFFh		; AX = "flipped" value
	cmp	ax,ES:[bx]		;Q: flipped value in ROM ?
	jne	short gv_locked		;   N: ROM is LOCKED
	mov	cs:[LockState],LOW UNLOCK_ROM ;Y: ROM is UNLOCKED
gv_locked:
	xor	ES:[bx],0FFFFh		; restore ROM contents (if changed)
;
	pop	es
	pop	bx
	pop	ax
	ret
CheckLOCK	endp
endif

R_CODE	ENDS

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\memm386.asm ===
page 58,132
;******************************************************************************
	title	MEMM386 - main module for EMM386
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;	Title:	EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
;	Module: MEMM386 - main module
;
;	Version: 2.02
;
;	Date:	May 24,1986
;
;	Author: Steve Preston
;
;******************************************************************************
;
;	Change Log:
;
;	DATE	 REVISION	Description
;	-------- --------	--------------------------------------------
;	04/24/86 Original	From EMML LIM driver.
;	06/26/86 0.02		Put CLD in Inst_Chk (SBP).
;	06/28/86 0.02		Name change from CEMM386 to CEMM.
;	07/05/86 0.04		Changed segment to R_CODE (SBP).
;	07/27/87 2.02		Updated comments to include Weitek support
;				and page frames M6 - M14 (SBP).
;	03/12/88 3.30 (*B)	Convert to packed version w/unpack exec (RDV).
;				and no unpack when old DOS < 3.10
;	07/14/88 3.31 (*C)	Change DOS version check for >3.1 and <4.99
;				Change Inst_chk to use EMS device open (RDV).
;				Add banner and copyright message display (RDV).
;				Add call to chka20 & disabla20 (EXEPACK) (RDV).
;				Add chk for DOS 3.00 to not use waitkey (RDV).
;	10/12/88 3.32 (*D)	VCPI added (DJM).
;	01/09/88 4.00 (*E)	Version changed to 4.00 (RDV)
;				Abort install if CTRL-ALT-SHFT held down
;	02/12/89 4.00      	Remove VDISK header
;
;	02/13/91 M008		Do not make int 16s on a Compaq Deskpro
;				386/16 or a Compaq portable 386.
;
;******************************************************************************
;   Functional Description:
;	CEMM is an Expanded Memory Manager which implements expanded memory
;   on the COMPAQ Lightning machine.  CEMM uses Virtual mode and paging on
;   the 386 to make Extended memory useable as expanded memory.  The are two
;   basic functional parts of CEMM;  the Virtual DOS Monitor (VDM) and the
;   Expanded Memory Manager (EMM).  VDM simulates the 386 Real mode under the
;   386 Virtual mode.  EMM provides the software functionality for a EMM as
;   described in the Lotus-Intel-Microsoft (LIM) specification for expanded
;   memory.  EMM also emulates the necessary expanded memory hardware.
;   CEMM also provides support for the Weitek coprocessor when the Weitek
;   is installed.
;	This module contains the Device Driver header, stategy, and interrupt
;   routines required by a LIM standard EMM.
;	This device driver is a .EXE file and may be invoked as a DOS utility
;   program as well as loaded as a device driver.  When it is loaded as a
;   DOS utility, CEMM has three command line options: ON,OFF and AUTO.
;   The OFF options disables CEMM and exits to MS-DOS in real mode.
;   The ON option enables CEMM and exits to MS-DOS in virtual mode (only
;   if the CEMM.EXE driver has been loaded).  The AUTO option puts
;   CEMM in "auto mode".  In this mode, CEMM will enable and disable
;   itself automatically, depending on accesses to the EMM functions.
;	The general device driver CONFIG.SYS options are described below.
;
;    Syntax:
;
;		device=[d]:[<path>]CEMM.EXE [SIZE] [Mx] [ON | OFF | AUTO]
;						[W=ON | W=OFF]
;						[Iz] [Iz] [Iz] [Iz]
;
;    The following sections describe the optional arguments which the
;    user may specify for CEMM.EXE at load time (in the CONFIG.SYS
;    file).  These arguments are placed after the device driver name
;    in the CONFIG.SYS file.
;
;    CEMM arguments in the CONFIG.SYS file must be separated by spaces
;    or tabs.  Arguments may appear in any order; however, any redundant
;    or excessive instances are ignored and only the first valid instance
;    of an argument is used.  Invalid or extraneous arguments produce an
;    error message.
;
;    [SIZE]
;
;    The argument SIZE is the amount of expanded memory desired in
;    K bytes.  The default amount of expanded memory, 256K, is available
;    without using any extended memory.  To use more than 256K of
;    expanded memory, the 386 system must have extended memory.  When
;    CEMM uses extended memory it may reserve 4K for itself.  Thus, if
;    512K of expanded memory is requested, CEMM may actually use 260k
;    (256K + 4K) of extended memory.  If there is not enough memory available
;    to provide SIZE kbytes of expanded memory, CEMM will adjust SIZE to
;    provide as much expanded memory as possible.
;
;	- The valid range for SIZE is 16K - 8192K.  Value outside this range
;	  are converted to the default of 256K.
;
;	- If SIZE is not a multiple of 16K (size of an EMM page), then SIZE
;	  is rounded down to the nearest multiple of 16K.
;
;    [Mx]
;
;    The argument [Mx] specifies the address of the 64k EMM page frame.
;    This argument is optional since CEMM can choose an appropriate
;    location for the page frame when it is loaded. To choose a location
;    the 386 EMM driver scans memory addresses above video memory for
;    an appropriate 64K address range for the EMM page frame.  For a
;    default page frame base address CEMM looks for option ROMs and
;    RAM in the EMM addressing range and chooses a 64K slot of memory
;    for the page frame which apparently does not confict with existing
;    memory.  The user may override the 386 EMM driver's choice by
;    specifying the beginning address with the Mx argument.  If the
;    user specifies a page frame base address which conflicts with an
;    option ROM or RAM, CEMM displays a warning message and uses the
;    specified page frame base address.
;
;    The following options are possible:
;			Page Frame Base Address
;		M1 => 0C0000 Hex
;		M2 => 0C4000 Hex
;		M3 => 0C8000 Hex
;		M4 => 0CC000 Hex
;		M5 => 0D0000 Hex
;		M6 => 0D4000 Hex
;		M7 => 0D8000 Hex
;		M8 => 0DC000 Hex
;		M9 => 0E0000 Hex
;		M10 => 080000 Hex
;		M11 => 084000 Hex
;		M12 => 088000 Hex
;		M13 => 08C000 Hex
;		M14 => 090000 Hex
;
;    [ ON | OFF | AUTO ]
;
;    The argument [ON | OFF | AUTO] specifies the state of the 386 when
;    CEMM returns to DOS after the driver INIT routine finishes.  If this
;    argument is ON, then CEMM returns to DOS in virtual mode and
;    expanded memory is available.  If this argument is OFF, then CEMM
;    returns to DOS in real mode and expanded memory is not available
;    until CEMM is turned ON.  The default for this argument is AUTO
;    mode.  In AUTO mode, the CEMM.EXE device driver will exit to
;    DOS in the OFF state; afterwards, CEMM will enable and disable
;    itself automatically.   In the AUTO mode, CEMM will be enabled
;    only while the expanded memory manager is in use.
;
;    [W=ON | W=OFF]
;
;    This argument enables or disables the Weitek coprocessor support.
;    The COMPAQ Weitek 1167 Programming Information document describes
;    the MS-DOS real mode interface provided by CEMM.  If no Weitek is
;    installed in the system, these arguments are invalid.
;
;    [Iz]
;
;    The argument [Iz] specifies the I/O addresses for the expanded
;    memory board mapping registers emulated by CEMM.  Since up
;    to four expanded memory boards can be placed in one system,
;    CEMM will emulate up to four sets of mapping registers.
;    The user may specify the mapping register I/O addresses emulated
;    by CEMM by including up to four instances of the argument [Iz].
;    The default I/O addresses are I0, I1, I5, and I6; for the first,
;    second, third, and fourth boards respectively. The following
;    table lists the I/O addresses represented by each possible value
;    for 'z'.
;
;	z | I/O Addresses for Mapping registers (in Hex)
;	------------------------------------------------
;	0 | 0208h   4208h   8208h   C208h
;	1 | 0218h   4218h   8218h   C218h
;	5 | 0258h   4258h   8258h   C258h
;	6 | 0268h   4268h   8268h   C268h
;	A | 02A8h   42A8h   82A8h   C2A8h
;	B | 02B8h   42B8h   82B8h   C2B8h
;	E | 02E8h   42E8h   82E8h   C2E8h
;
;
;******************************************************************************
.lfcond
	page
;******************************************************************************
;			P U B L I C   D E C L A R A T I O N S
;******************************************************************************

;
;   R_CODE publics
;
	public	DEVHEAD 		; Device driver header
	public	DEVHEAD2		; Second device header
	PUBLIC	DDT			; Device driver type
	public	strategy		; normal strategy routine	     *B
	public	interrupt
	public	CEMM_Entry
	public	Devname			;EMS header device name
	public	Cache_Off		; Added for others
	public	wait_key
	public	SIG_LENGTH
;;	public	Dos_version

;
;   LAST publics
;
	public	ELIM_link
	public	ELIM_EXE		; .EXE execution entry point
	public	Inst_chk		; Check to see if CEMM already installed
	public	FarLink
	public	Linkbuf_length


	page
;******************************************************************************
;			L O C A L   C O N S T A N T S
;******************************************************************************
;
.386p
	include vdmseg.inc
	include oemdep.inc
	include driver.equ
	include ascii_sm.equ
	include emmfunct.inc
	include	emmdata.inc
	include emm386.inc
	include	winemm.inc
.8086

MS_DOS		equ	21h			; DOS interrupt
PRINT_STRING	equ	09h			;			     *B
GET_VERSION	equ	30h			;			     *B
GET_PSP 	equ	62h			; get program segment prefix
NULL		EQU		0FFFFH			;Null address pointer

dospsp_str	struc
		db	80h dup (?)
cmd_len 	db	?		; length of command line
cmd_line	db	?		; commande line
dospsp_str	ends

;******************************************************************************
;			E X T E R N A L    R E F E R E N C E S
;******************************************************************************
;
LAST	segment
	extrn	onf_func:near		; perform on/off/auto checking
	extrn	Any_key:byte
	extrn	DOS_version:word
LAST	ends

R_CODE	segment
	extrn	ELIM_Entry:far		; general entry for CEMM functions

	extrn	StrategyEntry:dword
	extrn	InterruptEntry:dword
	extrn	ReqPtr:word


R_CODE	ends

R_CODE	segment
	assume	cs:R_CODE, ds:R_CODE, es:R_CODE, ss:R_CODE

Start:
;******************************************************************************
;  Device driver header
;******************************************************************************
;
DEVHEAD DD		NULL
DDT	DW		CHAR_DEV+IOCTL_SUP	;Attribute - Char
Strato	DW		OFFSET STRATEGY 	;Strategy routine entry      *B
Intero	DW		OFFSET INTERRUPT	;Interrupt routine entry
Devname DB		'EMMXXXX0'              ;Character device name
;
;******************************************************************************
;		GENERAL FUNCTIONS ENTRY POINT
;	R_CODE:ELIM_Entry is a entry point for executing general CEMM
;			functions. (e.g. ON, OFF function).
;******************************************************************************
;
CEMM_Entry	dw	offset	ELIM_Entry		; general entry point

;******************************************************************************
;	       MEMM signature
;******************************************************************************
cemmsig db	'MICROSOFT EXPANDED MEMORY MANAGER 386'
SIG_LENGTH	equ	(this byte - cemmsig)

;;DOS_version	dw	0

;******************************************************************************
;  Second device driver header
;
;  Some programs cannot detect EMM386 when it uses the 'EMMQXXX0' device
;  name (No EMS, but VCPI supported).  To allow these programs to detect
;  EMM386, a second device header is added with the name '$MMXXXX0'.  This
;  header is only used when the primary name is 'EMMQXXX0'.
;
;******************************************************************************

	align	2

DEVHEAD2 DD		NULL
	 DW		CHAR_DEV+IOCTL_SUP	;Attribute - Char
	 DW		OFFSET STRATEGY 	;Strategy routine entry
	 DW		OFFSET INTERRUPT	;Interrupt routine entry
	 DB		'$MMXXXX0'		;Character device name

	page
;******************************************************************************
;			L O C A L   D A T A   A R E A
;******************************************************************************

;*************************************************************************** *B
;	STRATINI/STRATEGY - Initial strategy routine & normal strategy	     *B
;									     *B
;	ENTRY: ES:BX = pointer to Request Header			     *B
;									     *B
;	EXIT: CS:ReqOff, CS:ReqSeg - saved pointer to Request Header	     *B
;	      UNPACK executed if found					     *B
;									     *B
;	USED: 11 stack words						     *B
;									     *B
;	This is the initial STRATEGY routine for first time execution as a   *B
;	device driver. It is replaced with the normal STRATEGY routine below.*B
;	It searches the code segment for the unpack routine appended by the  *B
;	EXEPACK link option or EXEPACK program. If it finds the code it      *B
;	executes it as an EXE program. The original first instruction	     *B
;	pointer is patched to return to this routine before continuing full  *B
;	execution of the program after unpack. The seg regs must be loaded   *B
;	with a fake value. They normally point to the PSP, but there is none.*B
;	Nothing is used from or done to the PSP so it is okay.		     *B
;	Cacheing must be turned off on a 386/20 while unpacking, and this    *B
;	is done by calling the ROM BIOS Int 15h Move Block function.	     *B
;	The UNPACKER expands the image to it's original unpacked state and   *B
;	everything is back to normal. STRATEGY then returns to DOS which     *B
;	calls the INTERRUPT routine initialization code.		     *B
;									     *B
;	This code must be at the beginning of the program so that no packing *B
;	takes place until after it.					     *B
;									     *B
;*************************************************************************** *B

STRATEGY proc	far			 ;find and execute UNPACKER  *B

	jmp	cs:[StrategyEntry]


STRATEGY endp


;***************************************************************************
;	Cache_off - check presense and turn off cache if on
;		  - check A20 status and disable if neeeded
;
;	ENTRY: none
;
;	EXIT: BX = entry status of cache controller
;		   0E201h = on, anything else is off or not present
;	USED: ES, BX, AX
;
;***************************************************************************
Cache_Off proc near				 ;
	push	di			 ;int 16h chgs es:di
	push	es			 ;
	mov	bx,0F000h		 ;look at ROM mem struct
	mov	es,bx			 ;ROM seg

	cmp	word ptr es:[0FFE9h],'C3';Q: ROM ID Compaq 386?
	jne	short Nocache 		 ; N: can't have cache then

	;
	; M008
	;
	; We now test bit 17 of the dword GenFlags under .8086. Hence the
	; .errnz.
	;
	test	word ptr cs:[GenFlags+2], 02h
	.errnz	fCPQ16Bit-17		 ; Q: is this a Compaq deskpro 386/16
	jnz	Nocache			 ; Y: no cache

	mov	ax,0F400h		 ;cache controller status
	int	16h			 ;
	mov	bx,ax			 ;save status
	cmp	ax,0E201h		 ;Q: cache cntrller enabled?
	jne	short Nocache 		 ; N: nothing to do

	mov	ax,0F402h		 ;turn cache controller off
	int	16h			 ;no coherency problem
Nocache:pop	es			 ;
	pop	di			 ;
	ret				 ;returns bx=cache status
Cache_Off endp				 ;

	page
;******************************************************************************
;	Interrupt - device driver interrupt routine for CEMM
;
;	ENTRY: CS:ReqPtr = pointer to request header.
;
;	EXIT: Request completed.
;
;	USED: none
;
;******************************************************************************
Interrupt	proc		far

	jmp	cs:[InterruptEntry]

Interrupt	endp


R_CODE	ends

	page
;******************************************************************************
;
;	LAST Code Segment
;
;******************************************************************************
LAST	segment
	assume	cs:LAST, ds:LAST, es:LAST, ss:LAST

CEMM:
;******************************************************************************
;
;	ELIM_EXE - .EXE entry point - when CEMM.EXE is invoked as a DOS
;		   utility.
;
;******************************************************************************
ELIM_EXE	proc	near
	push	cs
	pop	ds
	assume	ds:LAST
	mov	ah,GET_PSP		; get segment of PSP
	int	MS_DOS
	mov	es,bx			; DOS call returned seg in bx
	mov	di,cmd_line		; es:di = command line               *E
	call	onf_func		; look for on, off, or auto

	mov	ax,4c00h		; exit to DOS
	int	MS_DOS

ELIM_EXE	endp

;******************************************************************************
;	ELIM_link - Link to Installed CEMM's ELIM_Entry
;
;	ENTRY: see ELIM_Entry
;		and
;		LAST:[FarLink] = far address of installed CEMM ELIM_Entry
;
;	EXIT: see ELIM_Entry
;
;	USED: none
;
;******************************************************************************
FarLink dd	0		; far pointer to installed cemm386 entry point
				; OK as writeable because it is only used
				; during .EXE execution.
ELIM_link	proc	near
	call	CS:[FarLink]
	ret
ELIM_link	endp

Linkbuf		dw	0,0,0
Linkbuf_length	equ	6
emmname		db	'EMMXXXX0',0	; std name for EMS device

; OLD INSTALL CHECK SUPPLIMENTED WITH ONE THAT USES EMS DEVICE OPEN AND
; IOCTL COMMANDS TO COMMUNICATE WITH THE RESIDENT COPY OF CEMM.EXE
; **THIS ISN'T INTERFERED WITH BY PROGRAMS THAT STEAL INT 67H**
;****************************************************************************
;	Inst_chk - Check to see if CEMM is already installed
;
;	ENTRY: int 67 vector
;
;	EXIT: al = 0 if not already installed
;		ah = 0 if no int 67h vector is detected (no EMM)
;		ah = 1 if int 67h vector is detected (another EMM)
;	      al = 1 if CEMM is already installed
;		ah = 0 always
;	      	LAST:[FarLink] = far address for installed CEMM entry point
;
;	USED: none
;
;****************************************************************************
Inst_chk	proc	near

	push	di			; save di
	push	si			; and si
	push	ds			; and ds
	push	es			; and es
	push	bx
	push	cx			; and cx
	push	dx

	xor	ax,ax			; put segment 0000h in ds
	mov	ds,ax
	ASSUME	DS:abs0 		; assume ds is abs0
	mov	ax,[int67+2]		; get segment pointed to by int 67
	or	ax,ax
	jz	short Inst_exit		; not install if int 67h is not used
	mov	es,ax
	ASSUME	ES:R_CODE

	mov	ax,seg R_CODE
	mov	ds,ax			; set DS = R_CODE
	assume	DS:R_CODE		; update assume

	mov	di,offset cemmsig	; cemm386 signature
	mov	si,di			; save for source string
	mov	ax,100h			; initialize to not found
	mov	cx,SIG_LENGTH		; length to compare
	cld				;  strings foward
	repe	cmpsb			;q: is the cemm386 signature out there?
	jne	short Inst_chk_again	; n: return zero

	mov	cx,ES:[CEMM_Entry]	; get offset for far call
Inst_okay:
	inc	ax			; y: return one
	mov	word ptr cs:[FarLink+2],es	; set segment of far call
	mov	word ptr cs:[FarLink],cx	; set offset of far call
Inst_exit:
	pop	dx
	pop	cx
	pop	bx
	pop	es
	pop	ds
	pop	si
	pop	di
	ret

Inst_chk_again:			       ; try other method when old fails
	push	cs		       ; ensure addressability
	pop	ds
	assume	ds:LAST
	mov	ax,3D00h	       ; open device - any EMS device
	mov	dx,offset emmname      ; check for device of std name
	int	MS_DOS		       ;
	jc	short Inst_notfound    ; open failed

	mov	bx,ax		       ; open ok, save handle

	mov	ax,4400h	       ; get device info - all EMS drivers
	int	MS_DOS
	jc	short Inst_notfound    ; function call error
	test	dx,80h		       ; Q: character device ? (ISDEV bit)
	jz	short Inst_notfound    ;  N: can't be ours

	mov	ax,4407h	       ; get output stat - all EMS drivers
	mov	cx,0
	int	MS_DOS
	jc	short Inst_notfound    ; function call error
	cmp	al,0ffh 	       ; Q: ready?
	jne	short Inst_notfound    ;  N: can't be ours

	mov	ax,4402h	       ; get input - only CEMM has this
	mov	dx,offset LAST:Linkbuf
	mov	cx,Linkbuf_length      ; ask for 6 bytes
	int	MS_DOS
	jc	short Inst_notfound    ; function call error
	cmp	ax,Linkbuf_length      ; Q: input what we asked for?
	jne	short Inst_notfound    ;  N: can't be ours
	cmp	Linkbuf[0],SIG_LENGTH  ; Q: signature len = ours?
	jne	short Inst_notfound    ;       N: no
	mov	cx,Linkbuf[4]
	mov	es,cx		       ; set segment of far call
	mov	cx,Linkbuf[2]	       ; get link address to elim func's
	mov	ah,3eh		       ; close device
	int	MS_DOS
	mov	ax,100h
	jmp	short Inst_okay

Inst_notfound:
	mov	ah,3eh		       ; close device
	int	MS_DOS

	mov	ax,0FFA5h		; special function call
	int	67h
	cmp	ax,845Ah		; invalid function w/ ROR AL,4
	mov	ax,100h
	jne	short Inst_exit
					; BX:CX=far entry point
	mov	es,bx
	jmp	short Inst_okay		; ES:CX=far entry point
Inst_chk	endp


;*****************************************************************************C
;	wait_key - wait for keyboard input or 10 seconds and return.	     *C
;		- must be in this seg since the rest is still packed	     *C
;	ENTRY: none
;									     *C
;	EXIT: none							     *C
;*****************************************************************************C
; This routine waits for keyboard input or 10 seconds before returning.      *C
; It should be called after displaying an error message during initialization*C
; of a device driver.							     *C
;									     *C
; Get keyboard input if module doesn't load. Shows: Press any key when ready *C
;									     *C
;*****************************************************************************C
wait_key	proc	near
	cmp	cs:[DOS_version],3
	jnb	short wait_cont
	ret
wait_cont:
	push	ds			;				     *C
	push	si
	push	ax			;save registers 		     *C
	push	bx			;	"                            *C
	push	cx			;	"                            *C
	push	dx			;	"                            *C

	push	cs			;				     *C
	pop	ds			; set ds==cs			     *C
	mov	dx,offset LAST:Any_key	;print "any key to continue"         *C
	mov	ah,9h			;print function 		     *C
	int	21h			;				     *C

	mov	si,182
	xor     ah,ah			;  read tick counter request
        int     1AH                     ;  call BIOS
keepDX:
        mov     bx,dx			;  establish base tick count
waittick:
        mov     ah,1			; check keyboard status request
        int     16H			;Q: Any characters?
        jnz	short ClearBuff		; Y: clear buffer
        xor     ah, ah                  ; N: read tick counter request
        int     1AH                     ;  call BIOS
	cmp	dx,bx			;Q: Has a tick ocurred?
	jz	short waittick		; N: continue
	sub	si,1			; Y: decrement tick count
	jz	short waitexit		; if zero, timeout
	jmp	short keepDX		; if not, loop again

ClearBuff:
        xor     ah,ah			;  else, get key from buffer
        int     16H                     ;  call BIOS
        mov     ah,1			;Q: buffer clear?
        int     16H
        jnz     short ClearBuff         ; N: clear buffer

waitexit:
	pop	dx			;restore registers
	pop	cx			;restore registers
	pop	bx			;restore registers
	pop	ax			;	"
	pop	si
	pop	ds			;
	ret
wait_key	endp

LAST    ends
	end	CEMM

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\page.inc ===
ifndef INC_LIST
.xlist
endif
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386 - MICROSOFT Expanded Memory Manager 386
;
;   Module:   PAGE.INC - Definitions for paging on 386
;
;   Version:  0.02
;
;   Date:     January 31, 1986
;
;   Author:
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   01/31/86  Original
;   05/12/86  A-RRH	Cleanup and segment reorganization
;   06/28/86  0.02	Name change from CEMM386 to CEMM (SBP).
;
;******************************************************************************
;
;   Functional Description:
;
;******************************************************************************

P_SHIFT		equ	12							; page shift
P_SIZE		equ	(1 SHL P_SHIFT)	; page size

P_PRES		equ	01h		; page present bit
P_WRITE 	equ	02h		; write access bit
P_USER		equ	04h		; access bit for User mode
P_PWT		equ	08h		; page write transparent bit (only)
P_PCD		equ	10h		; page cache disable bit (486 only)
P_ACC		equ	20h		; page accessed bit
P_DIRTY 	equ	40h		; page dirty bit


P_AVAIL 	equ	(P_PRES+P_WRITE+P_USER+P_ACC+P_DIRTY) ; avail to everyone & present


;******************************************************************************
;	MACROS
;******************************************************************************
PAGE_ENTRY	macro	addr,stat
		dd	addr		; access & status in low 12
					; address in high 20
endm

;************************
; PDOff - page dir offset
;   ENTRY: (E)reg = register containing 32 bit linear addr
;	       = AX,BX,CX,DX,SI,DI
;   EXIT: (E)reg = offset for page dir entry for this addr
;************************
PDOff	macro	reg
	shr	E&reg,22	; EREG[0:9] = EREG[22:31] = high 10 bits
	shl	&reg,2		; *4 for dword indexing into table
endm

;************************
; PTOff - page table offset
;   ENTRY: (E)reg = register containing 32 bit linear addr
;	       = AX,BX,CX,DX,SI,DI
;   EXIT: (E)reg = offset for page table entry for this addr
;************************
PTOff	macro	reg
	shr	E&reg,12	; EREG[0:9] = EREG[12:21] = middle 10 bits
	and	&reg,3FFh ; only EREG[0:9]
	shl	&reg,2		; *4 for dword indexing into table
endm

.list		; end of PAGE.INC

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\pagetrap.asm ===
.386p
	page 58,132
;=============================================================================
	title	P A G E T R A P - traps page faults and writes into shadow ROMs
;=============================================================================
;==
;== (C) Copyright MICROSOFT Corp. 1990-1991
;== (C) Copyright COMPAQ Computer Corp. 1990-1991
;==
;==	Title:	EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;==
;==	Module: PageTrap  - Traps page faults and writes into shadow ROMs
;==
;==	Version: 1.00
;==
;==	Date:	September 30,1990
;==
;==	Author: Leo Cohen (original page fault handler: Patrick Wu & Leo Cohen)
;==
;=============================================================================
;==
;==	Change Log:
;==
;==	DATE	 TAG 		Description
;==	-------- --------	--------------------------------------------
;==     09/30/90 0.00	        Original
;==
;==	01/09/91 M000		clear int flag at page fault time and restore
;==				it in trapwrites. Also clear the Trap flag on
;==				on the stack in trapwrites before restoring 
;==				it from PFWflags.
;==
;=============================================================================
;==
;==   Functional Description:
;==
;==   This module monitors page faults:
;==
;==   1) If a page fault occurs due to a missing page, a page table is
;==	 created dynamically.  This emulates the ROMs moveblock which has
;==	 no boundary checking.
;==
;==   2) If a page fault occurs due to a write protection violation:
;==	 a) The PTE is modified inorder to allow the write to occur.
;==	 b) The data which will be modified by the write is saved.
;==	 c) The trap flag is set inorder to get control after the write
;==	    instruction.
;==	 d) After getting control again, the data is restored.
;==	 e) The PTE is write-protected again.
;==
;==   3) Unknown page fault - shutdown.
;==
;=============================================================================
;==	P U B L I C   D E C L A R A T I O N S
;=============================================================================
	public	PageFaultHandler
	public	TrapWrites
	public	CheckPageProt
	public	SaveResetVector
ifdef	ROMCOMP
	public	FixIVTptrs
	public	FixROMptrs
endif
	public	InitReset
	public	ResetRoutine
	public	ShutDown
	public	RestoreIVT
	public	NoResetRoutine
;=============================================================================
;==	L O C A L   C O N S T A N T S
;=============================================================================
	include vdmseg.inc
	include vdmsel.inc
	include dma.inc
	include page.inc
	include vm386.inc
	include	emm386.inc
	include	emmdata.inc
	include desc.inc

;=============================================================================
;==	E X T E R N A L   R E F E R E N C E S
;=============================================================================
_TEXT	segment
	extrn	ExceptHandler1:near
_TEXT	ends
LAST	segment

ifdef	ROMCOMP
	extrn	UnProtectROM:near
	extrn	ProtectROM:near
	extrn	ROMstart:word
endif

	extrn	ROMSet:word
LAST	ends
;=============================================================================
;==	L O C A	L   D A T A
;=============================================================================
_DATA	segment

PFTindex	dw	0		; index of last referenced PFT
PFTaddr		dw	1000h		; PFT0 offset from page directory
		dw	2000h		; PFT1 offset from page directory
PFTuser		dw	0		; owner of page fault table (PFT) 0
   		dw	0		; owner of page fault table (PFT) 1

PFWdata		dd	0		; data to restore on a write
PFWaddr		dd	0		; address to restore on a write
PFWPTE		dd	0		; write protected PTE address
PFWflags	dw	0		; save user flags

IDT1Save	dd	0,0		; saved interrupt descriptor for IDT 1
IDT1 label dword
IDT_ENTRY VDMC_GSEL,<offset _TEXT:ExceptHandler1>,D_386INT3 ; 01 Debug

pResetVec	dd	(0F000h shl 16)+0FFF0h

NumOfVectors	equ	80h
OldIVT		dd	NumOfVectors dup (0)

_DATA	ends

R_CODE	segment

OldResetVec	dd	TRUE

R_CODE	ends

ifdef	ROMCOMP
LAST	segment
ROMptrs	dw	09FA8h
	dw	0DB59h
	dw	0DB73h
	dw	0ED03h
	dw	0ED14h
	dw	0F8E9h
	dw	0FEF3h
	dw	0FEF3h
	dw	0FFE0h
	dw	0FFE2h
NumROMptrs	equ	($-ROMptrs)/2
LAST	ends
endif

;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
_TEXT	segment
	assume	cs:_TEXT
;==============================================================================
;==
;==  PageFaultHandler: This procedure handles all page faults
;==
;==  Entry: (Protected Mode)
;==	SS:[BP]	= pointer to exception IRETD image.
;==
;==  Exit:  (Protected Mode)
;==	NC	= no error
;==	CY	= error, exception is unexplained - shutdown the system.
;==
;==============================================================================
PageFaultHandler proc	near
	pushad
	push	ds
	push	es
	push	fs
;
;  Setup selectors
;
	mov	ax,VDMD_GSEL
	mov	ds,ax
	mov	bx,PAGED_GSEL
	mov	es,bx
	mov	cx,DATA32_GSEL
	mov	fs,cx
	mov	dx,RCODEA_GSEL
	mov	gs,dx
	assume	ds:_DATA,es:nothing,fs:nothing,gs:R_CODE
;
;  Get faulting linear address
;
	xor	ebx,ebx
	mov	eax,cr2			; get linear address
	mov	cr2,ebx			; clear CR2

	mov	ebx,eax
	shr	eax,22			; directory index
;
;  Check to see if table/page was present
;
	test	word ptr es:[eax*4],P_PRES ;Q: Is the table present?
	jnz	short PFHwrite		   ; Y: check for write fault

;------------------------------------------------------------------------
;
; We shall not check the error code on the stack as in some cases this
; may not be reliable. Note that we have already ensured that the page 
; directory and hence the page table entry associated with faulting page
; is not present. 
;
;	test	dword ptr [bp][VTFO],P_PRES ;Q: Error code: present page?
;	jnz	PFHerror		    ; Y: should never happen
;
;------------------------------------------------------------------------

;
;  Get a page fault table to dynamically set up
;
	movzx	ebx,[PFTindex]		; index to the user pointer
	movzx	edx,[PFTuser][ebx*2]
	movzx	edi,[PFTaddr][ebx*2]	; get page fault table address
	xor	[PFTindex],1		; set index of table to be used next
	or	dx,dx			;Q: Is the table free?
	jz	short PFHsetupTable	; Y: setup table
	mov	dword ptr es:[edx*4],0	; N: free the page table
;
;  Setup the page fault table
;
PFHsetupTable:
	mov	[PFTuser][ebx*2],ax	; mark table user
	mov	ebx,cr3			; address of page directory
	and	bx,0F000h
	add	ebx,edi			; address of page fault table
	or	bx,P_AVAIL
	mov	es:[eax*4],ebx		; set up page table in directory
;
;  Initialize tables with address equal to linear address
;
	shl	eax,22
	or	ax,P_AVAIL		; set page attribute
	mov	ecx,P_SIZE/4		; initialize all entries
	cld
PFHnextEntry:
	stosd
	add	eax,P_SIZE
	loop	PFHnextEntry
	clc				; no error
	jmp	short PFHexit
;
;  Check if fault was due to write protection
;
PFHwrite:

;------------------------------------------------------------------------
;
; We shall not check the error code on the stack as in some cases this
; may not be reliable. Note that we have already ensured that the page 
; directory and hence the page table entry associated with the faulting page
; is present. We shall just check the corresponding PTE to ensure that the
; fault was caused due to a write into a READ ONLY page.
;
;	test	dword ptr [bp][VTFO],P_PRES ;Q: Error code: present page?
;	jz	short PFHerror		    ; N: should never happen
;
;	test	dword ptr [bp][VTFO],P_WRITE ;Q: Check error code for write fault?
;	jz	short PFHerror		     ; N: cannot fix!
;
;--------------------------------------------------------------------------

;
;  Save value which will be destroyed
;
	mov	edx,fs:[ebx]		; get value being destroyed
	mov	[PFWdata],edx		; save it
	mov	[PFWaddr],ebx		; save address
;
;  Get and save PTE address
;
	mov	edx,es:[eax*4]		; get page table address
	and	dx,0F000h

	mov	eax,ebx
	shl	eax,10
	shr	eax,22
	lea	eax,fs:[edx][eax*4]
	mov	[PFWPTE],eax

	test	word ptr fs:[eax],P_WRITE  ;Q: Is the page writable?
	jnz	PFHerror		   ; Y: should never happen

;
;  Allow write to occur
;
	or	word ptr fs:[eax],P_WRITE

;  
;  Save user flags and set trap flag
; 
	mov	bx, [bp][VTFOE].VMTF_EFLAGS 
	mov	[PFWflags], bx
					; save user flags
	or	[bp][VTFOE].VMTF_EFLAGS,FLAGS_TF

	and	[bp][VTFOE].VMTF_EFLAGS, not FLAGS_IF
					; M000: clear IF so that an int 
					; M000: does not overwrite this page
	
;
;  Make sure Single Step exception belongs to correct handler
;
	mov	ebx,gs:[pIDT]		; get 32-bit address of IDT
	mov	edx,[IDT1]		; get correct IDT 1 descriptor
	xchg	edx,fs:[ebx][1*8]	; save current INT 1 descriptor
	mov	[IDT1save],edx
	mov	edx,[IDT1][4]		; get correct IDT 1 descriptor
	xchg	edx,fs:[ebx][1*8+4]	; save current INT 1 descriptor
	mov	[IDT1save][4],edx
	clc

PFHexit:
	mov	ebx,cr3			; clear TLB
	mov	cr3,ebx

	pop	fs
	pop	es
	pop	ds
	popad
	ret

PFHerror:
	stc				; error
	jmp	short PFHexit
	assume	ds:nothing
PageFaultHandler 	endp

;==============================================================================
;==
;==  TrapWrites: This procedure determines if the trap ocurred due to a write.
;==
;==  Entry: (Protected Mode)
;==	SS:[BP]	= pointer to exception IRETD image.
;==
;==  Exit:  (Protected Mode)
;==	NC	= continue
;==	CY	= trap due to write - return to client.
;==
;==============================================================================
TrapWrites proc	near
	push	eax
	push	ebx
	push	edx
	push	ds
	push	es
	push	fs
;
;  Setup selectors
;
	mov	ax,VDMD_GSEL
	mov	ds,ax
	mov	bx,DATA32_GSEL
	mov	fs,bx
	mov	ax,RCODEA_GSEL
	mov	gs,ax
	assume	ds:_DATA,es:nothing,fs:nothing,gs:R_CODE
;
;  Check for trap due to a write
;
	xor	eax,eax
	xchg	eax,[PFWPTE]
	or	eax,eax			;Q: Write?
	jz	short TWexit	        ; N: exit
;
;  Restore PTE, Trap Flag, IF, data, and Single Step Exception descriptor
;
	and	word ptr fs:[eax],not P_WRITE ; PTE is write protected again

					; M000: reset trap flag
	and	[bp][VTFO].VMTF_EFLAGS,not FLAGS_TF 

	mov	bx, [PFWflags]
	and	bx, FLAGS_TF+FLAGS_IF	; M000: restore trap flag and IF
	or	[bp][VTFO].VMTF_EFLAGS, bx
					; restore user flags

	mov	ebx,[PFWaddr]		; address of data which was written
	mov	eax,[PFWdata]		; get previous value
	mov	fs:[ebx],eax		; restore previous value

	mov	ebx,gs:[pIDT]		; get 32-bit address of IDT
	mov	edx,[IDT1save]		; get saved IDT 1 descriptor
	mov	fs:[ebx][1*8],edx	; restore INT 1 descriptor
	mov	edx,[IDT1save][4]	; get saved IDT 1 descriptor
	mov	fs:[ebx][1*8+4],edx	; restore INT 1 descriptor

	mov	eax, cr3		; reload cr3 to flush TLB
	mov	cr3, eax		

	test	[PFWflags], FLAGS_TF	; Q: was TF set at page fault time
	jnz	short TWexit		; Y: flag was set. Note that carry
					;    has been cleared by test inst.
					;    except1_handler will reflect 
					;    thru real mode IDT

	stc				; indicate return to client
TWexit:
	pop	fs
	pop	es
	pop	ds
	pop	edx
	pop	ebx
	pop	eax
	ret
TrapWrites	endp

;===============================================================================
;==
;==  CheckPageProt : Check if trying to write into a write protected page.
;==		     If starting page is write protected - skip it.
;==		     if a write protected page is encountered - adjust ECX to
;==		     stop EDI->EDI+ECX short of the page.
;==		     (It may be necessary in the future to skip write protected
;==		      pages, but continue with the write operation if a
;==		      non-write protected page exists in the buffer after it)
;==
;==  Entry: (Protected Mode)
;==	ES  = zero based - 4GB selector
;==	ESI = source buffer pointer
;==	EDI = destination buffer pointer (checked for write protection)
;==	ECX = size of buffer in bytes
;==
;==  Exit:  (Protected Mode)
;==	ECX = size of transfer (bytes) not affected by write protection
;==
;===============================================================================
CheckPageProt	proc	near
	push	edx
;
;  Check if buffer is below 1MB
;
	cmp	edi,100000h		;Q: Is buffer in first meg?
	jae	short CPPexit		; N: no more checking necessary

	lea	edx,es:[edi+ecx]	; end of buffer

	cmp	edx,80000h		;Q: Is buffer below 512K?
	jbe	short CPPexit		; N: no more checking necessary
;
;  Further checking is needed
;
	push	eax
	push	ebx
;
;  Get PT0 address
;
	mov	eax,cr3			; get address of page directory
	and	ax,0F000h
	mov	eax,es:[eax]		; page table 0 address
	and	ax,0F000h
;
;  Get PTE index
;
CPPindex:
	lea	edx,es:[edi+ecx]	; again (might have skipped first page)
	mov	ebx,edi			; pointer to buffer
	shl	ebx,10			; get PTE index to start of buffer
	shr	ebx,22
	shl	edx,10			; get PTE index to end if buffer
	shr	edx,22

	sub	dx,bx			; number of PTEs spanned
	inc	dx
CPPloop:
	test	word ptr es:[eax][ebx*4],P_WRITE
	jz	short CPPwrite
	inc	bx
	dec	dx
	jnz	short CPPloop

CPPok:
	pop	ebx
	pop	eax
CPPexit:
	pop	edx
	ret
;
;  A write protected page has been detected: return size of allowable transfer
;
CPPwrite:
	shl	ebx,12			; end of buffer
	sub	ebx,edi			;Q: Size of buffer > 0?
	jbe	short CPPfirstPage	; N: first page is write protected
	mov	ecx,ebx
	jmp	short CPPok
;
;  The first page is write protected - skip it
;
CPPfirstPage:
	add	ebx,P_SIZE		; number of bytes in first page
	add	edi,ebx			; skip to next page
	add	esi,ebx			; increment source buffer accordingly
	sub	ecx,ebx			;Q: Last page?
	ja	short CPPindex		; N: skip first page
	xor	ecx,ecx			; Y: return with zero sized buffer
	jmp	short CPPok

CheckPageProt	endp

;==============================================================================
;==
;==  InitReset: This routine points the reset vector at F000:FFF0 to
;==		the ResetRoutine and saves the state of the IVT.
;==
;==  Entry: (Protected Mode)
;==	DS	= VDMD_GSEL
;==	FS	= DATA32_GSEL
;==	GS	= RCODEA_GSEL
;==
;==  Exit:  (Protected Mode)
;==
;==============================================================================
InitReset proc	near
	push	eax

	call	SaveIVT

	cmp	gs:[OldResetVec],FALSE	;Q: Using a ResetRoutine?
	je	short IRexit		; N: don't change ROM

	mov	ax,seg R_CODE
	shl	eax,16
	lea	ax,gs:[ResetRoutine]
	mov	fs:[0FFFF0h][1],eax
IRexit:
	pop	eax
	ret
InitReset	endp

;==============================================================================
;==
;==  SaveIVT: This routine saves the state of the IVT at the time CEMM
;==	      becomes active.
;==
;==  Entry: (Protected Mode)
;==	DS	= _DATA
;==	FS	= DATA32_GSEL
;==
;==  Exit:  (Protected Mode)
;==
;==============================================================================
SaveIVT proc	near

	test	gs:[Current_State],fState_WinCntrl
				;Q: is this due to windows shutting down
	jz	SIcont		;N: Save the int vector table
	ret			;Y: return
SIcont:

	push	eax
	push	ecx

	mov	ecx,NumOfVectors
SIloop:
	mov	eax,fs:[ecx*4-4]
	mov	ds:[OldIVT][ecx*4-4],eax
	loop	SIloop

	pop	ecx
	pop	eax
	ret
SaveIVT	endp

;==============================================================================
;==
;==  RestoreIVT: This routine restores the state of the IVT to the state it
;==	         was at the time CEMM became active.
;==
;==  Entry: (Protected Mode)
;==	DS	= _DATA
;==	FS	= DATA32_GSEL
;==
;==  Exit:  (Protected Mode)
;==
;==============================================================================
RestoreIVT proc	near
	push	eax
	push	ecx

	mov	ecx,NumOfVectors
RIloop:
	mov	eax,ds:[OldIVT][ecx*4-4]
	mov	fs:[ecx*4-4],eax
	loop	RIloop

	pop	ecx
	pop	eax
	ret
RestoreIVT	endp

_TEXT	ends
;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
R_CODE	segment
	assume	cs:R_CODE
;==============================================================================
;==
;==  ResetRoutine: This routine returns to real mode - and returns to the ROM
;==		   reset routine.
;==
;==  Entry: (Real Mode)
;==
;==  Exit:  (Real Mode)
;==
;==============================================================================
ResetRoutine	proc	near

	;
	; Change to EMM386's real mode stack. We know at this point we are
	; going to reboot and hence are going to turn off. If the user had
	; done a jmp ffff:0 with his stack in a UMB we'd be hosed if we
	; don't change stacks.
	;
	push	seg R_STACK
	pop	ss
	lea	sp,R_STACK:RealStackTop

	call	Shutdown
	jmp	cs:[OldResetVec]

ResetRoutine	endp
;==============================================================================
;==
;==  ShutDown: This routine returns to real mode and restores the interrupt
;==	       vectors to a pre-CEMM condition.  This is to prevent vectors
;==	       from pointing to the UMB region which disappears after CEMM
;==	       returns to real mode.
;==
;==  Entry: (Real Mode)
;==
;==  Exit:  (Real Mode)
;==
;==============================================================================
ShutDown proc	near
	push	ax
	pushf
	cli

	or	cs:[Current_State],fState_WinCntrl
					; we shall set this flag so that set
					; and get a20cnt routines in util.asm
					; do not do xms calls. We do not care
					; about resetting this bit as we are
					; going to reboot any way.


;
;  Indicate a CPU shutdown - restore IVT to avoid vectors pointing to UMB region
;
	or	cs:[GenFlags],fShutDown

	mov	al,0Fh
	out	84h,al		; port 84/85 return to real sequence
	mov	al,00h
	out	85h,al
	jmp	$+2		; clear prefetch/avoid race cond

	popf
	pop	ax
	ret
ShutDown	endp


R_CODE	ends
;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
LAST	segment
	assume	cs:LAST,ds:_DATA,gs:R_CODE

ifdef	ROMCOMP

;==============================================================================
;==
;==  FixIVTptrs: Fixes pointers on IVT for ROM compression on CPQ machines.
;==
;== 		  32K ROMs F000:0    - F000:7FFF = mirror image of
;==			   F000:8000 - F000:FFFF
;==
;==   		    	386G  Deskpr 386/16, 386/20, 386/25
;==   			386F  Deskpro 386s
;==   			386H  Deskpro 386/20e (Horizon only)
;==
;== 		  40K ROMs F000:0    - F000:5FFF   junk
;==			   F000:6000 - F000:FFFF = system ROM
;==
;==   			386H  Deskpro 386/20e (Gambler only)
;==   			386H  Deskpro 386/25e
;==   			386L  Deskpro 386/33
;==
;==		  64K ROMs F000:0    - F000:FFFF
;==
;==	   		386P  Portable 386
;==			386E  Systempro/Deskpro 486/25
;==			386D  Deskpro 386n
;==
;==  		  The pointers which need to be changed in order to
;==		  reclaim the lower 32K space include:
;==
;==			1BD0	dummy end of interrupt handler
;==			1C1F	IRQ 9 entry point
;==			1C28	287 error entry point
;==			20FB	diskette parameter table entry point
;==			2E12	fixed disk BIOS entry point
;==			2FA4	old fixed disk hardware entry point
;==			3343	fixed disk hardware entry point
;==			4A97	real-time clock entry point
;==
;==  Entry: (Real Mode)
;==
;==  Exit:
;==
;==============================================================================
FixIVTptrs proc	near
	pusha
	push	ds
	push	es
	push	fs

ifdef 901023
	test	gs:[GenFlags],fROMComp	;Q: ROM compression on this machine?
	jz	FIpExit			; N: can't use ROM space
	mov	cx,cs:[ROMstart]	; Y: start of ROM after compression

;
;  Make sure BIOS points to INT 13h entry point on upper 32K image by making an
;  INT 2Fh AH=13h (DOS 3.20 and later): changes the INT 13h calls from IBMBIO.
;  Note: Does not affect DOS 3.00-3.10, but valid only on DOS 3.20 and later.
;
	mov	ah,13h		; get current int 13h vectors
	int	2fh
	cmp	dx,cx		;Q: Does INT 13h need updating?
	jae	short FIpSetI13h; N: continue
	or	bx,8000h	; Y: int 13h vector used by boot.
	or	dx,8000h	; int 13h handler
FIpSetI13h:
	mov	ah,13h		; restore Int 13h pointer
	int	2fh		; make sure they are pointing to upper 32K image

	mov	bx,cx		; start of ROMs in BX
;
;  Point all vectors of IVT to actual ROM (image above F000:8000)
;QLEO: Need to do this after we know for sure that CEMM will load????
;
	xor	di,di
	mov	fs,di
	mov	cx,256
FIpLoop:
	cmp	word ptr fs:[di][2],0F000h ;Q: Vector pointing to System ROM
	jne	short FIpContLoop	   ; N: continue
	cmp	word ptr fs:[di],bx	   ;Q: Invalid region of System ROM?
	jae	short FIpContLoop	   ; N: continue
	add	word ptr fs:[di],8000h	   ; Y: reflect to image above 32K!
FIpContLoop:
	add	di,4			; next vector
	loop	FIpLoop			; get all 256 of them

endif	; 901023
FIpExit:
	pop	fs
	pop	es
	pop	ds
	popa
	ret
FixIVTptrs	endp

;==============================================================================
;==
;==  FixROMptrs: Fixes pointers in the ROM for ROM compression on CPQ machines.
;==
;== 		  32K ROMs F000:0    - F000:7FFF = mirror image of
;==			   F000:8000 - F000:FFFF
;==
;==   		    	386G  Deskpr 386/16, 386/20, 386/25
;==   			386F  Deskpro 386s
;==   			386H  Deskpro 386/20e (Horizon only)
;==
;== 		  40K ROMs F000:0    - F000:5FFF   junk
;==			   F000:6000 - F000:FFFF = system ROM
;==
;==   			386H  Deskpro 386/20e (Gambler only)
;==   			386H  Deskpro 386/25e
;==   			386L  Deskpro 386/33
;==
;==		  64K ROMs F000:0    - F000:FFFF
;==
;==	   		386P  Portable 386
;==			386E  Systempro/Deskpro 486/25
;==			386D  Deskpro 386n
;==
;==  		  The pointers which need to be checked/changed in order to
;==		  reclaim the lower 32K space include:
;==
;==				      9FA8
;==                                   DB59
;==				      DB73
;==				      ED03
;==				      ED14
;==				      F8E9
;==				      FEF3
;==				      FEF3
;==			BIM pointer @ FFE0
;==			CPU type ptr@ FFE2
;==
;==  Entry: (Real Mode)
;==	BX = Start of ROM after compression.
;==	FS = F000h
;==
;==  Exit:
;==
;==============================================================================
FixROMptrs proc	near
	pusha
	pushf
	cli

ifdef 901023
	test	gs:[GenFlags],fROMComp	;Q: ROM compression on this machine?
	jz	FRpExit			; N: can't use ROM space
	mov	cx,cs:[ROMstart]	; Y: start of ROM after compression

	call	UnProtectROM		; unwrite protect the Shadow ROM

	mov	ax,0F000h
	mov	fs,ax

	xor	si,si
	mov	cx,NumROMptrs
FRpLoop:
	mov	di,cs:[ROMptrs][si]
	cmp	word ptr fs:[di],bx
	jae	short FRpNext
	or	word ptr fs:[di],8000h
FRpNext:
	add	si,2
	loop	FRpLoop

ifdef 901021
	cmp	fs:[0FFE0h],bx	;Q: BIM data structure OK?
	jb	short FRpFixPtrs; N: fix it
	cmp	fs:[0FFE2h],bx	;Q: Is this pointer OK?
	jae	short FRpExit	; Y: continue

FRpFixPtrs:
	call	UnProtectROM	; unwrite protect the Shadow ROM
	or	word ptr fs:[0FFE2h],8000h ; point to upper image
	mov	di,fs:[0FFE0h]	; get address of BIM data structure
	cmp	di,bx		;Q: Need to fix BIM data structure?
	jae	short FRpChkSum	; N: ROM check sum
	or	word ptr fs:[0FFE0h],8000h ; Y: point to upper image

ifdef 901015 ; check sum on BIM data structure will change as memory is allocated
	mov	cx,4		; 4 words
FRpBIM:
	mov	ax,fs:[di]	; move BIM data structure to upper image
	mov	fs:[8000h][di],ax
	add	di,2
	loop	FRpBIM
endif
FRpChkSum:
ifdef 901015 ; check sum on BIM data structure will change as memory is allocated
	mov	di,bx		; start of ROM
	xor	dx,dx		; check sum init
	xor	cx,cx		; assume 64K ROM
	sub	cx,bx		; actual size ROM
	dec	cx		; don't include check sum
FPrChkSumLoop:
	add	dl,fs:[di]	; calculate Check Sum
	inc	di		; next byte
	loop	FPrChkSumLoop
	neg	dl
	mov	fs:[0FFFFh],dl	; save check sum
endif
endif	;901021


	call	ProtectROM	; protect Shadow ROM from writes

endif	;901023
FRpExit:
	popf
	popa
	ret
FixROMptrs	endp

endif	; ROMCOMP

;==============================================================================
;==
;==  NoResetRoutine: No ResetRoutine is required on COMPAQ machines because
;==		     CEMM is turned off by an OUT 84,0Fh and OUT 85h,0 sequence.
;==
;==  Entry: (Real Mode)
;==
;==  Exit:
;==
;==============================================================================
NoResetRoutine proc	near
	push	ebx
	push	es

	mov	byte ptr cs:[ROMSet],2	   ; no ROM alias at F000:F000
	mov	dword ptr cs:[ROMSet][2],0 ; .. is needed

	mov	gs:[OldResetVec],FALSE	; no reset routine will be used

	pop	es
	pop	ebx
	ret
NoResetRoutine	endp
;==============================================================================
;==
;==  SaveResetVector: This routine saves the ROM reset vector. This is the
;==		      location which is jumped to by the ROM at F000:FFF0.
;==
;==  Entry: (Real Mode)
;==
;==  Exit:
;==
;==============================================================================
SaveResetVector	proc	near
	push	ebx
	push	es

	cmp	gs:[OldResetVec],TRUE	;Q: Using a ResetRoutine?
	jne	short SRVexit		; N: exit

	les	bx,[pResetVec]		; get address of jump instruction
	mov	ebx,es:[bx][1]		; get address jumped to
	mov	gs:[OldResetVec],ebx	; save this address

SRVexit:
	pop	es
	pop	ebx
	ret
SaveResetVector	endp
LAST	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\pictrap.asm ===
.386p
	page 58,132
;=============================================================================
	title	P I C T R A P - traps, programs and fields 8259 PIC functions
;=============================================================================
;==
;== (C) Copyright MICROSOFT Computer Corp. 1990-1991
;== (C) Copyright COMPAQ Computer Corp. 1990-1991
;==
;==	Title:	EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;==
;==	Module: PICTrap  - Programs PIC, traps PIC programming, and fields
;==			   H/W interrupts caused by PIC.
;==
;==	Version: 1.00
;==
;==	Date:	March 10,1990
;==
;==	Author: Leo Cohen
;==
;=============================================================================
;==
;==	Change Log:
;==
;==	DATE	 REVISION	Description
;==	-------- --------	--------------------------------------------
;==     03/10/90 0.00	        Original
;==	04/18/90 		Added handlers for 25h, 26h, 2fh, 2ah, 33h
;==				and 5ch.
;==
;=============================================================================
;==
;==   Functional Description:
;==
;==   This module is responsible for fielding interrupts and then reflecting
;==   them to the virtual 8086 mode interrupt service routines.  It allows
;==   interrupts and reentrancy in protected mode to a nested level limited
;==   only by the stack size.
;==
;==   The algorithm design is based on servicing a H/W interrupt while a
;==   protected	mode service is in progress.  The interrupt must be reflected
;==   to the V86 interrupt service routine, and then return to the interrupted
;==   instruction in the protected mode service.  Because the V86 interrupt
;==   service routine may use a protected mode service, the process must be
;==   reentered multiple times; thus, the nesting level is limited only by the
;==   size of the stack.
;==
;==    PMTF processing (PMTF - Protected Mode Trap Frame)
;==
;== 1) Push segment registers.
;== 2) Subtract size of VMTF from ESP. (VMTF - Virtual Mode Trap Frame)
;== 3) Create dummy VMTF for IRETD. (returns to V86 interrupt service routine)
;== 4) Force real mode stack return to dummy HWInterEnd. (inc real mode SP first!)
;== 5) Push ESP0 into nest stack. (inc nest SP first!)
;== 6) Place ESP plus size of VMTF into ESP0 in TSS.
;== 7) IRETD
;==
;==    HWInterEnd processing
;==
;== 1) Add size of VMTF to ESP (throw VMTF away).
;== 2) Pop nest stack. (dec nest SP AFTER getting value!)
;== 3) Place nest stack value into ESP0 of TSS.
;==
;==    SS:SP (ring 0)     Nest Stack             TSS
;==
;==               
;==       VMTF              a                      
;==  a                       
;==     * local *           b                      
;==                          
;==       PMTF              c                      
;==               
;==      Seg Regs                        ESP0 = x  
;==               
;==       VMTF                    
;==  b                 
;==     * local *                 
;==                    
;==       PMTF                    
;==         
;==      Seg Regs 
;==    
;==       VMTF    
;==  c 
;==     * local * 
;==    
;==       PMTF    
;==    
;==      Seg Regs 
;==  x 
;==               
;==               
;==    
;==
;=============================================================================
;==
;==	P U B L I C   D E C L A R A T I O N S
;=============================================================================
ifdef PICtrap
	public	EnterVirtPIC
	public	ExitVirtPIC
	public	ProgramPIC
endif
	public	PICInit
	public	PICVecInit

	public	MasterPICVec
	public	SlavePICVec

ifdef PICtrap
	public	VirMasterPICVec
	public	VirSlavePICVec
	public	PICCommand1
	public	PICCommand2
	public	PICData1
	public	PICData2
	public	MasterIS
	public	LastOCW3
endif
	public	pLastVMTF
	public	LastVMTF

	public	ReflectInterrupt
	public	pIRQHandlerMaster
	public	pIRQHandler
	public	pIRQ0Handler
	public	pIRQ1Handler
	public	pIRQ2Handler
	public	pIRQ3Handler
	public	pIRQ4Handler
	public	pIRQ5Handler
	public	pIRQ6Handler
	public	pIRQ7Handler
	public	pIRQ8Handler
	public	pIRQ9Handler
	public	pIRQ10Handler
	public	pIRQ11Handler
	public	pIRQ12Handler
	public	pIRQ13Handler
	public	pIRQ14Handler
	public	pIRQ15Handler
	public	pTrapHandler
	public	pINT25hHandler
	public	pINT26hHandler
	public	pINT2ahHandler
	public	pINT2fhHandler
	public	pINT33hHandler
	public	pINT5chHandler
;=============================================================================
;==	L O C A L   C O N S T A N T S
;=============================================================================
	include allocmem.inc
	include vdmseg.inc
	include vdmsel.inc
	include desc.inc
	include dma.inc
	include vm386.inc
	include	emm386.inc
	include	emmfunct.inc
	include	emmdata.inc
	include	winemm.inc

ifdef PICtrap
PIC_ICW1	equ	00010001b	; ICW1
PIC_ICW2	equ	00000000b	; ICW2 (or with base vector)
MPIC_ICW3	equ	00000100b	; Master ICW3 (slave on IR 2)
SPIC_ICW3	equ	00000010b	; Slave ICW3 (respond to cascade 2)
PIC_ICW4	equ	00000001b	; ICW4

PIC_OCW3	equ	00001010b	; OCW3 (read IRR)

ICW1_DEF	equ	00010000b	; ICW1 definition
OCW2_DEF	equ	00011000b	; OCW2 definition
OCW2_EOI	equ	00100000b	; OCW2/EOI bit
OCW2_SL		equ	01000000b	; OCW2/SL bit
OCW2_R		equ	10000000b	; OCW2/R bit
OCW3_DEF	equ	00001000b	; OCW3 definition
OCW3_RR		equ	00000010b	; RR bit field
OCW3_RIS	equ	00000001b	; RIS bit field
endif

;=============================================================================
;==	E X T E R N A L   R E F E R E N C E S
;=============================================================================
_TEXT	segment
	extrn	DMACheckTC:near
	extrn	PortTrapFar:far
	extrn	pXMMentry:near
	extrn	pWinEMMGlobImpDisp:near
ifdef PICtrap
	extrn	VCPIProgPIC:near
endif
_TEXT	ends

R_CODE	segment
	extrn	DebBreakStr:byte
R_CODE	ends

R1_CODE	segment
	extrn	InstanceData:byte
	extrn	Win386VxDRefDat:byte
	extrn	rQueryXMSpages:near
	extrn	rAllocateXMSblock:near
	extrn	rFreeXMSblock:near
R1_CODE	ends

;=============================================================================
;==	L O C A	L   D A T A
;=============================================================================
_DATA	segment

ifdef PICtrap
even
PICFlags	label	word
	dw	0
	dw	0
fPICMoved	equ 00000001b	; PIC vectors moved by CEMM
fICW1		equ 00000010b	; Indicates ICW1 detected
fICW2		equ 00000100b	; Indicates ICW2 detected
fICW3		equ 00001000b	; Indicates ICW3 detected
fPICMovedbit	equ 	0
fICW1bit	equ 	1
fICW2bit	equ 	2
fICW3bit	equ 	3

ICW1	label	byte
	dw	PIC_ICW1
	dw	PIC_ICW1
ICWs	label	byte
ICW2	label	byte
	dw	DOS_MASTER_VECTOR
	dw	DOS_SLAVE_VECTOR
ICW3	label	byte
	dw	MPIC_ICW3
	dw	SPIC_ICW3
ICW4	label	byte
	dw	PIC_ICW4
	dw	PIC_ICW4
ICWmask	label	byte
	dw	0
	dw	0
endif

pLastVMTF	dw	-1
LastVMTF	label	word
	dw	256 dup (0)

_DATA	ends

_TEXT	segment

rModeCallTable	label	word
	dw	offset R1_CODE:rQueryXMSpages
	.errnz	QUERY_XMS_PAGES - FIRST_RMODE_RTN
	dw	offset R1_CODE:rAllocateXMSblock
	.errnz	ALLOC_XMS_BLOCK - QUERY_XMS_PAGES - 1
	dw	offset R1_CODE:rFreeXMSblock
	.errnz	FREE_XMS_BLOCK - ALLOC_XMS_BLOCK - 1
	.errnz	FREE_XMS_BLOCK - LAST_RMODE_RTN

_TEXT	ends


R_CODE	segment

even

PICVec		label	word
MasterPICVec	dw  DOS_MASTER_VECTOR	; Master PIC vector
SlavePICVec	dw  DOS_SLAVE_VECTOR	; Slave PIC vector

ifdef PICtrap
VirPICVec	label	word
VirMasterPICVec	dw  DOS_MASTER_VECTOR	; Virtual master PIC vector
VirSlavePICVec	dw  DOS_SLAVE_VECTOR	; Virtual mode slave PIC vector

MasterIS	dw	0		; In service levels on master PIC
ZERO		dw	0
LastOCW3	db	PIC_OCW3	; Last OCW3 to master PIC

OldSlaveIRQHandler	label	dword
	dd	8 dup (0)

OldInt21hHandler dd	0

PharLapCopy	db   'Copyright (C) '	; Phar Lap copy right message in PSP
PharLapCopyLen	equ	$-PharLapCopy
PharLapName	db   'Phar Lap Software, Inc.'	; Phar Lap message in PSP
PharLapNameLen	equ	$-PharLapName
PharLapOffs	equ	100h		; offset into PSP for Phar Lap Copy Right message

PICPortList	label	word
PICcommPorts label word
	dw	020h			; PIC1_CMD
	dw	0A0h			; PIC2_CMD
PICdataPorts label word
	dw	021h			; PIC1_INIT
	dw	0A1h			; PIC2_INIT
TOTAL_PIC_PORTS	equ	($-PICPortList)/2
endif

extrn	rI15KeyBoard:near

R_CODE	ends

LAST	segment

ifdef PICtrap
rMasterIRQHandlers	label	word
	dw	offset R_CODE:rIRQ0Handler
	dw	offset R_CODE:rIRQ1Handler
	dw	offset R_CODE:rIRQ2Handler
	dw	offset R_CODE:rIRQ3Handler
	dw	offset R_CODE:rIRQ4Handler
	dw	offset R_CODE:rIRQ5Handler
	dw	offset R_CODE:rIRQ6Handler
	dw	offset R_CODE:rIRQ7Handler

rSlaveIRQHandlers	label	word
	dw	offset R_CODE:rIRQ8Handler
	dw	offset R_CODE:rIRQ9Handler
	dw	offset R_CODE:rIRQ10Handler
	dw	offset R_CODE:rIRQ11Handler
	dw	offset R_CODE:rIRQ12Handler
	dw	offset R_CODE:rIRQ13Handler
	dw	offset R_CODE:rIRQ14Handler
	dw	offset R_CODE:rIRQ15Handler
endif

pMasterIRQHandlers	label	word
	dw	offset _TEXT:pIRQ0Handler
	dw	offset _TEXT:pIRQ1Handler
	dw	offset _TEXT:pIRQ2Handler
	dw	offset _TEXT:pIRQ3Handler
	dw	offset _TEXT:pIRQ4Handler
	dw	offset _TEXT:pIRQ5Handler
	dw	offset _TEXT:pIRQ6Handler
	dw	offset _TEXT:pIRQ7Handler

pSlaveIRQHandlers	label	word
	dw	offset _TEXT:pIRQ8Handler
	dw	offset _TEXT:pIRQ9Handler
	dw	offset _TEXT:pIRQ10Handler
	dw	offset _TEXT:pIRQ11Handler
	dw	offset _TEXT:pIRQ12Handler
	dw	offset _TEXT:pIRQ13Handler
	dw	offset _TEXT:pIRQ14Handler
	dw	offset _TEXT:pIRQ15Handler

pIRQ5xHandlers	label	word
	dw	offset _TEXT:pIRQ50Handler
	dw	offset _TEXT:pIRQ51Handler
	dw	offset _TEXT:pIRQ52Handler
	dw	offset _TEXT:pIRQ53Handler
	dw	offset _TEXT:pIRQ54Handler
	dw	offset _TEXT:pIRQ55Handler
	dw	offset _TEXT:pIRQ56Handler
	dw	offset _TEXT:pIRQ57Handler

LAST	ends
;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
_TEXT	segment
	assume	cs:_TEXT,ds:_DATA,es:_DATA,gs:R_CODE,ss:STACK

ifdef PICtrap
;==============================================================================
;==
;== Initialization Command Word Format (ICW1-ICW4) (X-default)
;==
;==
;== ICW1: (Write) 8259A Programmable Interrupt Controller (20h & A0h)
;==
;== 76543210
;== xxxxxxxx> IC4    0 = No ICW4 needed
;==              1 = ICW4 needed     			X
;== 
;== > SNGL   0 = Cascade mode    			X
;==               1 = Single
;== 
;== > ADI    0 = Call address interval of 8 		X
;==                1 =  "     "        "     "  4
;== 
;== > LTIM   0 = Edge triggered mode  		X
;==                 1 = Level triggered mode
;== 
;== > 1      Indicates ICW1
;== 
;== > 0	A5-A7: Vector address for MCS80/85 mode only
;==
;==
;== ICW2: (Write) 8259A Programmable Interrupt Controller (21h & A1h)
;==
;== 76543210
;== xxxxxxxx
;== > 0	A8-A10: Vector address for MCS80/85 mode only
;== 
;== > T3-T7  Vector address for 8086/8088 mode only
;==			or A11-A15: Vector address for MCS80/85 mode only
;==
;==
;== ICW3: (Write) 8259A Programmable Interrupt Controller (21h & A1h)
;==
;== 76543210
;== xxxxxxxx
;== > SLAVE  ID number of this slave (0-7) 		(02h)
;== 
;== > MASTER 0 = IR input does not have a slave 	(04h)
;==			1 = IR input has a slave
;==
;==
;== ICW4: (Write) 8259A Programmable Interrupt Controller (21h & A1h)
;==
;== 76543210
;== xxxxxxxx> uPM    0 = MCS80/85 mode
;==              1 = 8086/8088 mode			X
;== 
;== > AEOI   0 = Normal EOI				X
;==               1 = Auto EOI
;== 
;== > M/S    0 = Buffered mode: Slave   		X
;==                1 = Buffered mode: Master
;== 
;== > BUF    0 = Not buffered mode      		X
;==                 1 = Buffered mode
;== 
;== > SFNM   0 = Special fully nested mode     	X
;==                  1 = Not special fully nested mode
;== 
;== > 0
;==
;==============================================================================

;==============================================================================
;==
;== Operation Command Word Format (OCW1-OCW3)
;==
;==
;== OCW1: (Write) 8259A Programmable Interrupt Controller (21h & A1h)
;==
;== 76543210
;== xxxxxxxx
;== > IM	0 = IR mask reset
;==			1 = IR mask set
;==
;==
;== OCW2: (Write) 8259A Programmable Interrupt Controller (20h & A0h)
;==
;== 76543210
;== xxxxxxxx
;== > L0-L2  IR level to be acted upon (IR0-IR7) (if bit 6 is set)
;== > 0      OCW2 definition
;== > EOI    End Of Interrupt
;== > SL	Set interrupt Level
;== > R	Rotate Mode
;==
;== R SL EOI
;==
;== 0  0  0	Rotate in auto EOI mode (clear)      Auto Rotation (reserved)
;== 0  0  1	Non-specific EOI command             EOI
;== 0  1  0	No operation			     noop
;== 0  1  1	Specific EOI command		     EOI
;== 1  0  0	Rotate in auto EOI mode (set)        Auto Rotation (reserved)
;== 1  0  1	Rotate on non-specific EOI command   Auto Rotation
;== 1  1  0	Set priority command                 Specific Rotation
;== 1  1  1	Rotate on specific EOI command	     Specific Rotation
;==
;== OCW3: (Write) 8259A Programmable Interrupt Controller (20h & A0h)
;==
;== 76543210
;== xxxxxxxx> RIS    0 = Read IR register on next read (RR must be set)
;==              1 = Read IS register on next read (RR must be set)
;== 
;== > RR     0 = Do not read IR/IS register: RIS is a no-op
;==               1 = Read IR/IS register: RIS determines whether IR/IS
;== 
;== > P	0 = No poll command 		X
;== 		1 = Poll command
;== 
;== > 1      OCW3 definition
;== > 0       "       "
;== 
;== > SMM    0 = Reset special mask          X
;==                   1 = Set special mask
;== 
;== > ESMM   0 = SMM is a no-op              X
;==                    1 = SMM determines whether a clear/set of special mask
;== 
;== > 0
;==
;==============================================================================

;==============================================================================
;==
;== PICCommand: Trap PIC command ports 20h & A0h and detect attempt to
;==		reprogram vector via ICWs.
;==
;== Entry: (Protected Mode)
;==	DS = _DATA
;==	GS = R_CODE
;==
;== Exit:  (Protected Mode)
;==
;==============================================================================
PICCommand1:
	push	si
;
;  Check to see if this is an OCW2 doing an EOI for the Master PIC
;
	or	dx,dx			;Q: Is it an OUT command?
	jz	short PICCMasterCont	; N: don't trap

;
;  If H/W interrupts are not entering via base vectors, don't virtualize PIC's
;  IS register.
;
	cmp	gs:[MasterPICVec],DOS_MASTER_VECTOR    ;Q: Virtualize IS register?
	jne	short PICCMasterCont	; N: don't trap

	push	ax

	movzx	si,al
	and	al,OCW2_DEF		;Q: Is it an OCW2?
	jnz	short PICCcheckOCW3	; N: check if OCW3

	test	si,OCW2_EOI		;Q: Is it an EOI?
	jz	short PICCnotEOI	; N: continue

	mov	ax,si			; restore AL
	out	20h,al			; do EOI

	mov	ax,1011b		; read ISR
	out	20h,al
	in	al,20h			; read ISR from master PIC
	mov	gs:[MasterIS],ax	; save ISR state
	mov	al,gs:[LastOCW3]
	out	20h,al			; restore last OCW3

	pop	ax
	pop	si
	clc
	ret

PICCcheckOCW3:
	test	si,OCW3_DEF		;Q: Is it an OCW3?
	jz	short PICCnotEOI	; N: continue
	and	al,not OCW3_DEF		;Q: Is it an OCW3?
	jnz	short PICCnotEOI	; N: continue
	test	si,OCW3_RR		;Q: Is it ISR/IRR command?
	jz	short PICCnotEOI	; N: continue

	pop	ax
	mov	gs:[LastOCW3],al
	jmp	short PICCMasterCont

ifdef 900417
	test	si,OCW2_R		;Q: Is it a rotate priority EOI?
	jnz	short PICCnotEOI	; Y: currently, can not handle! ***QLEO***

	test	si,OCW2_SL		;Q: Is it a specific level EOI?
	jnz	short PICCspecificEOI	; Y: mark EOI

	bsf	ax,gs:[MasterIS]  	;Q: Highest priority level needing EOI?
	jz	short PICCnotEOI	; N: no level needs EOI, exit
	jmp	short PICCEOI		; Y: AX contains highest interrupt level

PICCspecificEOI:
	mov	ax,si
	and	ax,7			; specific level to EOI
PICCEOI:
	btr	gs:[MasterIS],ax
endif


PICCnotEOI:
	pop	ax
PICCMasterCont:
	xor	si,si			; index into controller 1
	jmp	short PICCommand


PICCommand2:
	push	si
	mov	si,2			; index into controller 2

PICCommand:
	and	[PICFlags][si],not (fICW1+fICW2+fICW3)

	or	dx,dx			;Q: Is it an OUT command?
	jz	short PICCnoEmul	; N: don't trap

	test	al,ICW1_DEF		;Q: Is it an ICW1 command?
	jz	short PICCnoEmul	; N: don'trap
	or	[PICFlags][si],fICW1    ; Y: set flag to watch for ICW2
	mov	[ICW1][si],al
	clc
PICCexit:
	pop	si
	ret

PICCnoEmul:
	stc
	jmp	short PICCexit

;==============================================================================
;==
;== PICData: Trap PIC data ports 21h & A1h and detect attempt to
;==	     reprogram vector via ICW2.
;==
;== Entry: (Protected Mode)
;==	DS = _DATA
;==	GS = R_CODE
;==
;== Exit:  (Protected Mode)
;==
;==============================================================================
PICData1:
	push	si
	xor	si,si			; index into controller 1
	jmp	short PICData

PICData2:
	push	si
	mov	si,2			; index into controller 2

PICData:
	btr	[PICFlags][si],fICW3bit	;Q: Was prior command an ICW3?
	jc	short PICDICW4		; Y: virtualize
	btr	[PICFlags][si],fICW2bit	;Q: Was prior command an ICW2?
	jc	short PICDICW3		; Y: virtualize
	btr	[PICFlags][si],fICW1bit	;Q: Was prior command an ICW1?
	jnc	short PICDnoEmul	; N: no emulation, proceed!

PICDICW2:
	and	[PICFlags][si],not (fICW1+fICW2+fICW3)
	or	dx,dx			;Q: Is it an OUT command?
	jz	short PICDnoEmul	; N: don't trap

	push	ax			; virtualize new PIC vector locations
	and	ax,0F8h			; get new vector location
	mov	gs:[VirPICVec][si],ax	; save for real mode IRQ handlers
	pop	ax

	or	[PICFlags][si],fICW2
	test	[PICFlags][si],fPICMoved;Q: Has CEMM moved the PIC vector?
	jnz	short PICDexit		; Y: don't program
	mov	[ICW2][si],al
	jmp	short PICDexit

PICDICW3:
	and	[PICFlags][si],not (fICW1+fICW2+fICW3)
	or	dx,dx			;Q: Is it an OUT command?
	jz	short PICDnoEmul	; N: don't trap
	or	[PICFlags][si],fICW3	; Y: virtualize
	test	[PICFlags][si],fPICMoved;Q: Has CEMM moved the PIC vector?
	jnz	short PICDexit		; Y: don't program
	mov	[ICW3][si],al
	jmp	short PICDexit

PICDICW4:
	and	[PICFlags][si],not (fICW1+fICW2+fICW3)
	or	dx,dx			;Q: Is it an OUT command?
	jz	short PICDnoEmul	; N: don't trap
	test	[PICFlags][si],fPICMoved;Q: Has CEMM moved the PIC vector?
	jnz	short PICDexit		; Y: don't program
	mov	[ICW4][si],al		; N: virtualize

	pushad
	mov	bx,gs:[VirMasterPICVec]
	mov	cx,gs:[VirSlavePICVec]

	call	VCPIProgPIC
	popad

PICDexit:
	clc
	pop	si
	ret

PICDnoEmul:
	stc
	pop	si
	ret

;==============================================================================
;==
;== EnterVirtPIC: Program IRQ0-IRQ15 vectors to the values in
;==		  R_CODE:[MasterPICVec] & R_CODE:[SlavePICVec] locations.
;==
;== Entry: (Protected Mode)
;==	CLI  interrupts must be off
;==	DS = _DATA
;==	GS = R_CODE
;==
;== Exit:  (Protected Mode)
;==
;==
;==============================================================================
EnterVirtPIC	proc	near
	push	ax
;
;  Assume master PIC is being programmed to base vector locations
;
	mov	gs:[MasterIS],0

	test	[PICFlags],fPICMoved	;Q: Need to program PIC?
	jnz	short EVPcont		; Y: program
;
;  Initialize PICs to base vector locations
;
	mov	gs:[MasterPICVec],DOS_MASTER_VECTOR
	mov	gs:[VirMasterPICVec],DOS_MASTER_VECTOR
	mov	gs:[SlavePICVec],DOS_SLAVE_VECTOR
	mov	gs:[VirSlavePICVec],DOS_SLAVE_VECTOR
	jmp	short EVPexit

EVPcont:
	mov	al,PIC_ICW1
	out	020h,al
	out	0A0h,al

	mov	ax,gs:[MasterPICVec]
	out	021h,al
	mov	ax,gs:[SlavePICVec]
	out	0A1h,al

	mov	al,MPIC_ICW3
	out	021h,al
	mov	al,SPIC_ICW3
	out	0A1h,al

	mov	al,PIC_ICW4
	out	021h,al
	out	0A1h,al

	mov	al,PIC_OCW3
	out	020h,al
	out	0A0h,al
EVPexit:
	pop	ax
	ret
EnterVirtPIC	endp

;==============================================================================
;==
;== ExitVirtPIC: Program IRQ0-IRQ15 vectors to the values in
;==		 R_CODE:[VirMasterPICVec] & R_CODE:[VirSlavePICVec] locations.
;==
;== Entry: (Protected Mode)
;==	CLI  interrupts must be off
;==	GS = R_CODE
;==
;== Exit:  (Protected Mode)
;==
;==
;==============================================================================
ExitVirtPIC	proc	near
	push	ax

	test	[PICFlags],fPICMoved	;Q: Need to program PIC?
	jz	short XVPexit		; Y: leave PICs alone

	mov	al,PIC_ICW1
	out	020h,al
	out	0A0h,al

	mov	ax,gs:[VirMasterPICVec]
	out	021h,al
	mov	ax,gs:[VirSlavePICVec]
	out	0A1h,al

	mov	al,MPIC_ICW3
	out	021h,al
	mov	al,SPIC_ICW3
	out	0A1h,al

	mov	al,PIC_ICW4
	out	021h,al
	out	0A1h,al

	mov	al,PIC_OCW3
	out	020h,al
	out	0A0h,al
XVPexit:
	pop	ax
	ret
ExitVirtPIC	endp

;==============================================================================
;==
;== ProgramPIC: Program PIC to last virtual ICWs (or default values).
;==
;== Entry: (Protected Mode)
;==	CLI  interrupts must be off
;==	DS = _DATA
;==	GS = R_CODE
;==
;== Exit:  (Protected Mode)
;==
;==
;==============================================================================
ProgramPIC proc	near
	push	esi
	push	edi
	push	ax
	push	dx
	push	cx

	test	[PICFlags][0],fPICMoved	;Q: Did CEMM move master PIC?
	jnz	short PPexit		; Y: no virtualization of ICWs
;
;  Get current mask register and then program ICW1 for each PIC
;
	xor	esi,esi
	mov	cx,2
PPloop:
;
;  Get and save mask register
;
	mov	dx,PICdataPorts[esi*2]	; get current mask register
	in	al,dx
	mov	[ICWmask][esi*2],al
;
;  Program ICW1
;
	mov	dx,[PICcommPorts][esi*2] ; program ICW1 to command port
	mov	al,[ICW1][esi*2]
	out	dx,al
;
;  Program ICW2-4 and mask for each PIC
;
	push	cx
	mov	cx,4			; program ICW2-4 and mask register
	xor	edi,edi
PPdata:
	mov	dx,PICdataPorts[esi*2]	; get data port
	mov	al,[ICWs][edi][esi*2]	; get virtual data
	out	dx,al			; program PIC
	add	di,4			; next ICW/mask
	loop	PPdata
	pop	cx
;
;  Program OCW3
;
	mov	al,PIC_OCW3
	mov	dx,PICcommPorts[esi*2]	; program OCW3 to command port
	out	dx,al

	inc	si
	loop	PPloop

PPexit:
	pop	cx
	pop	dx
	pop	ax
	pop	edi
	pop	esi
	ret
ProgramPIC	endp
endif

	assume ds:nothing,es:nothing,fs:nothing,gs:nothing
;==============================================================================
;==
;==  pIRQxHandler: H/W protected mode interrupt handlers.  These routines will
;==		   reflect HW interrupts to the real mode interrupt handlers.
;==
;==  Entry:  (Protected Mode via 386 Interrupt gate)
;==	SS:SP = Depending on the processor mode when the interrupt occurred:
;==		1) V8086 mode: the virtual mode 8088 stack frame
;==		2) Protected mode: 32-bit EIP, CS, & EFLAGS.
;==
;==  Exit:   EBP pushed on stack
;==	BP = stack frame pointer
;==
;==============================================================================
ALIGN 16
pIRQ0Handler:
	push	ebp
	push	0
	jmp	short pIRQHandlerMaster

ifdef LC910610
pIRQ1Handler:
	push	ebp
	push	1
	jmp	short pIRQHandlerMaster
endif

pIRQ2Handler:
	push	ebp
	push	2
	jmp	short pIRQHandlerMaster

pIRQ3Handler:
	push	ebp
	push	3
	jmp	short pIRQHandlerMaster

pIRQ4Handler:
	push	ebp
	push	4
	jmp	short pIRQHandlerMaster

pIRQ5Handler:
	push	ebp
	push	5
	jmp	short pIRQHandlerMaster

pIRQ6Handler:
	push	ebp
	push	6
	jmp	short pIRQHandlerMaster

pIRQ7Handler:
	push	ebp
	push	7
	jmp	short pIRQHandlerMaster

pIRQ8Handler:
	push	ebp
	push	0
	jmp	short pIRQHandlerSlave

pIRQ9Handler:
	push	ebp
	push	1
	jmp	short pIRQHandlerSlave

pIRQ10Handler:
	push	ebp
	push	2
	jmp	short pIRQHandlerSlave

pIRQ11Handler:
	push	ebp
	push	3
	jmp	short pIRQHandlerSlave

pIRQ12Handler:
	push	ebp
	push	4
	jmp	short pIRQHandlerSlave

pIRQ13Handler:
	push	ebp
	push	5
	jmp	short pIRQHandlerSlave

pIRQ14Handler:
	push	ebp
	push	6
	jmp	short pIRQHandlerSlave

pIRQ15Handler:
	push	ebp
	push	7
	jmp	short pIRQHandlerSlave

pIRQHandlerSlave:
	mov	bp,sp
	push	ebx
	mov	ebx,2
	jmp	short pIRQHandlerN

ALIGN	16
pIRQHandlerMaster:
	movzx	ebp,sp
	push	ebx
	xor	ebx,ebx

pIRQHandlerN:
	push	esi
	push	ds

	mov	si,DATA32_GSEL
	mov	ds,si

	mov	si,seg R_CODE
	movzx	esi,si
	shl	esi,4				; DS:[ESI] point to R_CODE
	assume	ds:R_CODE
ifdef PICtrap
	mov	bx,[esi][VirPICVec][ebx]
else
	mov	bx,[esi][PICVec][ebx]
endif
	add	[bp],bx
	add	bp,2

pIRQHandler:
;
;  Check if interrupt occurred in virtual8086 or protected mode.
;
	test	[bp][VTFO].VMTF_EFLAGShi,FLAGS_VM ;Q: Virtual Mode?
	jnz	vReflectInterrupt		  ; Y: vReflectInterrupt
						  ; N: pReflectInterrupt
;===============================================================================
;==
;== pReflectInterrupt:  This procedure reflects interrupts which occurred
;==		        while protected mode code was executing.
;==
;== Entry: (Protected Mode)
;==	BP    = Points to Protected Mode Interrupt Stack Frame (no error)
;==	DS    = DATA32_GSEL (4GB, zero based selector)
;==	ESI   = 32-bit pointer to base of R_CODE segment
;==	[pLastVMTF]= pointer into nesting stack
;==	[LastVMTF] = nesting stack: pointers to last Virtual Mode Trap Frame
;==	SS:SP =
;==               HIword LOword
;==              
;==                  EFLAGS     +0Ch
;==              
;==               0000   CS    +08h
;==              
;==                   EIP       +04h
;==              
;==                   EBP       +00h
;==               < SS:BP
;==               Int. Vector   -02h (word)
;==              
;==                   EBX       -06h (dword)
;==              
;==                   ESI       -0Ah (dword)
;==              
;==                   DS        -0Ch (word)
;==               < SS:SP
;==
;== Processing for HLT instruction:
;==
;==	If the VM has executed an sti hlt, then we know that the cs, eip
;== above is pointing to the instruction after the hlt that we executed in
;== EmHalt (vminst.asm). We also know that the VMTF immediatedly above the
;== EFLAGS is the one caused by the user's sti hlt plus EBP (see emhalt).
;== We wasnt to reflect this HW int down and set up the real mode stack so
;== that when the HW ISR does it's IRET control goes back to the instruction
;== after the user's hlt instruction. So we set up the stack for
;== vreflectinterrupt as follows:
;==
;==                
;==                 0000   GS  
;==                
;==                 0000   FS    +20h
;==                
;==                 0000   DS    +1Ch
;==                
;==                 0000   ES    +18h
;==                
;==                 0000   SS    +14h
;==                
;==                     ESP       +10h
;==                
;==                    EFLAGS     +0Ch
;==                
;==                 0000   CS    +08h  user segent
;==                
;==                     EIP       +04h  instruction after hlt
;==                
;==                     EBP       +00h     Start of VM_TRAP_FRAME (VMTF)
;==                 < SS:BP
;==                 Int. Vector   -02h (word)
;==                
;==                     EBX       -06h (dword)
;==                
;==                     ESI       -0Ah (dword)
;==                
;==                 DS (dummy)    -0Ch (word)
;==                 < SS:SP
;==
;==
;== Exit: (Protected Mode)
;==	BP    = Points to new Virtual Mode Interrupt Stack Frame (no error)
;==	DS    = DATA32_GSEL (4GB, zero based selector)
;==	ESI   = 32-bit pointer to base of R_CODE segment
;==	[pLastVMTF]= pointer into nesting stack incremented
;==	[LastVMTF] = nesting stack: pointers to last Virtual Mode Trap Frame
;==	SS:SP =
;==                 HIword LOword
;==                
;==                    EFLAGS   
;==                
;==                 0000   CS  
;==                
;==                     EIP     
;==                
;==                  ES    DS  
;==                
;==                  GS    FS  
;==                
;==                 0000   GS  
;==                
;==                 0000   FS    +20h
;==                
;==                 0000   DS    +1Ch
;==                
;==                 0000   ES    +18h
;==                
;==                 0000   SS    +14h
;==                
;==                     ESP       +10h
;==                
;==                    EFLAGS     +0Ch
;==                
;==                 0000   CS    +08h  R_CODE
;==                
;==                     EIP       +04h  HWInterEnd
;==                
;==                     EBP       +00h     Start of VM_TRAP_FRAME (VMTF)
;==                 < SS:BP
;==                 Int. Vector   -02h (word)
;==                
;==                     EBX       -06h (dword)
;==                
;==                     ESI       -0Ah (dword)
;==                
;==                 DS (dummy)    -0Ch (word)
;==                 < SS:SP
;==
;== Description:
;==	This routine will use the last VMTF on the stack to create a dummy VMTF
;==	which will be used to IRETD to the real mode interrupt handler.  The
;==	real mode stack will include an IRET frame to HWInterEnd, which will
;==	trap to pTrapHandler.  In pTrapHandler, the stack will be cleared,
;==	segment registers will be loaded, and finally an IRETD will return to
;==	the protected mode code which was originally interrupted.
;==
;===============================================================================
;==
;==    PMTF processing (PMTF - Protected Mode Trap Frame)
;==
;== 1) Push segment registers.
;== 2) Subtract size of VMTF from ESP. (VMTF - Virtual Mode Trap Frame)
;== 3) Create dummy VMTF for IRETD. (returns to V86 interrupt service routine)
;== 4) Force real mode stack return to dummy HWInterEnd. (inc real mode SP first!)
;== 5) Push ESP0 into nest stack. (inc nest SP first!)
;== 6) Place ESP plus size of VMTF into ESP0 in TSS.
;== 7) IRETD
;==
;==    HWInterEnd processing
;==
;== 1) Add size of VMTF to ESP (throw VMTF away).
;== 2) Pop nest stack. (dec nest SP AFTER getting value!)
;== 3) Place nest stack value into ESP0 of TSS.
;==
;==    SS:SP (ring 0)     Nest Stack             TSS
;==
;==               
;==       VMTF              a                      
;==  a                       
;==     * local *           b                      
;==                          
;==       PMTF              c                      
;==               
;==      Seg Regs                        ESP0 = x  
;==               
;==       VMTF                    
;==  b                 
;==     * local *                 
;==                    
;==       PMTF                    
;==         
;==      Seg Regs 
;==    
;==       VMTF    
;==  c 
;==     * local * 
;==    
;==       PMTF    
;==    
;==      Seg Regs 
;==  x 
;==               
;==               
;==    
;==
;===============================================================================
pReflectInterrupt:

	btr	ds:[esi][GenFlags],fEMMhltBit	;Q: Did we issue an sti hlt
	jc	PRI_hlt				; N: normal processing

;
;  Create space in SS0:SP for a VMTF: reflect interrupt to real mode handler
;
	sub	sp,size VM_TRAP_FRAME+8		; allocate space in SP
	sub	bp,size VM_TRAP_FRAME+8
	push	eax
	push	edx

;
;  Copy EBP and interrupt number down to current SP/BP
;
	mov	ebx,[bp][size VM_TRAP_FRAME][4]	; interrupt vect/EBX
	mov	eax,[bp][size VM_TRAP_FRAME][8]	; get EBP
	mov	[bp][-4],ebx
	mov	[bp],eax
	mov	ebx,[bp][size VM_TRAP_FRAME][-4]; ESI/DS (BX=original DS)
	mov	eax,[bp][size VM_TRAP_FRAME][0]	; EBX/ESI
	ror	ebx,16
	mov	[bp][-8],eax
	mov	[bp][-10],bx
;
;  Save segment registers on stack
;
	mov	ax,fs
	mov	bx,es
	shl	eax,16
	mov	ax,gs
	mov	[bp][VTFO][size VM_TRAP_FRAME][4],ebx ; DS/ES from stack
	mov	[bp][VTFO][size VM_TRAP_FRAME][0],eax ; FS/GS
;
;  Get access to _DATA
;
	assume	ds:R_CODE		; DS:[ESI] must point to R_CODE
	mov	eax,[esi][p_DATA]	; DS:[EAX] points to _DATA
	assume	ds:_DATA

;
;  Get pointer to last VMTF on the stack from TSS ESP0
;
	mov	ebx,[eax][TSS].TSS386_ESP0
	sub	bx,[VTFO][size VM_TRAP_FRAME]

;
;  Copy last VMTF into current SS0:SP
;
	mov	edx,dword ptr ss:[bx][VTFO].VMTF_GS
	mov	dword ptr [bp][VTFO].VMTF_GS,edx

	mov	edx,dword ptr ss:[bx][VTFO].VMTF_FS
	mov	dword ptr [bp][VTFO].VMTF_FS,edx

	mov	edx,dword ptr ss:[bx][VTFO].VMTF_DS
	mov	dword ptr [bp][VTFO].VMTF_DS,edx

	mov	edx,dword ptr ss:[bx][VTFO].VMTF_ES
	mov	dword ptr [bp][VTFO].VMTF_ES,edx

	mov	edx,dword ptr ss:[bx][VTFO].VMTF_SS
	mov	dword ptr [bp][VTFO].VMTF_SS,edx

	mov	edx,dword ptr ss:[bx][VTFO].VMTF_ESP
	mov	dword ptr [bp][VTFO].VMTF_ESP,edx

	mov	edx,dword ptr ss:[bx][VTFO].VMTF_EFLAGS
	mov	dword ptr [bp][VTFO].VMTF_EFLAGS,edx
;
;  Make return address to R_CODE:HWInterEnd: traps back to protected mode
;
	mov	dx,offset R_CODE:HWInterEnd	; offset must be < 64K
	movzx	edx,dx
	mov	dword ptr [bp][VTFO].VMTF_EIP,edx

	mov	dx,seg R_CODE			; NOTE: above instruction reset
	mov	dword ptr [bp][VTFO].VMTF_CS,edx; upper 16 bits

;
;  Update ESP0 on TSS so an interrupt in VM doesn't destroy information on stack
;
	movsx	edx,[eax][pLastVMTF]
	inc	edx
	mov	[eax][pLastVMTF],dx
	mov	[eax][LastVMTF][edx*2],bx

	mov	[eax][TSS].TSS386_ESP0,ebp
	add	word ptr [eax][TSS].TSS386_ESP0,[VTFO][size VM_TRAP_FRAME]

;
;  Fall through to vReflectInterrupt
;
	pop	edx
	pop	eax

;===============================================================================
;==
;== vReflectInterrupt: This procedure builds the protected and real mode
;==		       stacks so that an IRETD emulates a real mode interrupt.
;==		       The IRETD will cause the execution of the real mode
;==		       interrupt service.  The real mode stack is modified
;==		       so an IRET at the end of the real mode interrupt service
;==		       routine will cause a return to the code specified by
;==		       the CS:EIP in the VMTF.
;==
;==		       The IF and TF are zeroed when entering the real
;==		       mode interrupt service routine, but preserved when
;==		       returned to the code which was interrupted.
;==
;== Entry: (Protected Mode)
;==	BP    = Points to Virtual/Protected Mode Interrupt Stack Frame (no error)
;==	DS    = DATA32_GSEL (4GB, zero based selector)
;==	ESI   = 32-bit pointer to base of R_CODE segment
;==	SS:SP =
;==                 HIword LOword
;==                
;==                 0000   GS  
;==                
;==                 0000   FS    +20h
;==                
;==                 0000   DS    +1Ch
;==                
;==                 0000   ES    +18h
;==                
;==                 0000   SS    +14h
;==                
;==                     ESP       +10h
;==                
;==                    EFLAGS     +0Ch
;==                
;==                 0000   CS    +08h
;==                
;==                     EIP       +04h
;==                
;==                     EBP       +00h     Start of VM_TRAP_FRAME (VMTF)
;==                 < SS:BP
;==                 Int. Vector   -02h (word)
;==                
;==                     EBX       -06h (dword)
;==                
;==                     ESI       -0Ah (dword)
;==                
;==                 DS (dummy)    -0Ch (word)
;==                 < SS:SP
;==
;==
;== Exit: (Virtual Mode)
;==	IRETD to real mode interrupt handler.
;==
;===============================================================================
vReflectInterrupt:
	add	sp,2			; throw dummy DS away

	assume	ds:R_CODE		; DS:[ESI] must point to R_CODE
	mov	ebx,[esi][p_DATA]
	assume	ds:_DATA

	cmp	[ebx][DMAActive],0	;Q: Any DMA activity going on?
	jnz	RICheckDMA		; Y: check for DMA TC

RIreflect:
	assume	ds:R_CODE
	test	[esi][GenFlags], fTurnOff
					; Q: Do we ned to set up an 
					; additional IRET frame so that 
					; control is first obtained in 
					; rI15KeyBoard (see int15.asm).
	assume	ds:_DATA
	jnz	vRIsetupI15ret		; Y: set up the additonal frame

;  Create space in real mode (user) stack for the IRET frame
;
	movzx	ebx,[bp][VTFO].VMTF_ESP	; get DS:BX pointing to user stack
	sub	bx,6			; make room for IRET frame
	mov	[bp][VTFO].VMTF_ESP,bx
	push	ax
	movzx	esi,[bp][VTFO].VMTF_SS
	shl	esi,4

RIsetIretFrame:
;
;  Build real mode (user) stack: IP and CS for IRET frame
;
	mov	ax,[bp][VTFO].VMTF_EIP	; IP
	mov	[esi][ebx],ax

	inc	bx
	inc	bx
	mov	ax,[bp][VTFO].VMTF_CS	; CS
	mov	[esi][ebx],ax
;
;  Clear IF and TF to correctly emulate the interrupt
;
	inc	bx
	inc	bx
	mov	ax,[bp][VTFO].VMTF_EFLAGS
	mov	[esi][ebx],ax
	and	ax,not (FLAGS_IF+FLAGS_TF)	; reset IF and TF
	mov	[bp][VTFO].VMTF_EFLAGS,ax

	pop	ax
;
;  Replace CS:EIP of SS0:ESP so IRETD goes to interrupt handler pointed by IVT
;
	movzx	ebx,word ptr [bp][-2]	; interrupt vector
	cmp	bx, FIRST_RMODE_RTN
	jb	RIuseIVT
	sub	bx, FIRST_RMODE_RTN
	mov	bx, cs:[rModeCallTable][ebx*2]
	mov	[bp][VTFO].VMTF_EIP,bx	; move the IP
	mov	bx, seg R_CODE
	shl	ebx, 4			; high word already zeroed above
	assume	ds:R_CODE
	mov	bx, [ebx][segR1_CODE]
	assume	ds:_DATA
	mov	[bp][VTFO].VMTF_CS, bx	; set the CS
	jmp	short RIsetCSIP
RIuseIVT:
	mov	ebx,[ebx*4]
	mov	[bp][VTFO].VMTF_EIP,bx	; move the IP
	shr	ebx,16
	mov	[bp][VTFO].VMTF_CS,bx	; move the CS
RIsetCSIP:
;
;   IRETD back to real mode interrupt handler
;
	pop	esi			; restore local regs
	pop	ebx
	add	sp,2			; throw interrupt number away
	pop	ebp
	iretd

RICheckDMA:
	mov	bx,VDMD_GSEL		; access _DATA
	mov	ds,bx
	call	DMACheckTC		; check DMA operations have complete
	mov	bx,DATA32_GSEL		; restore: DS:[ESI] points to _DATA
	mov	ds,bx
	jmp	RIreflect

vRIsetupI15ret:

	;
	; Here we set up the CS, IP and flags on the (user) stack frame to
	; R_CODE:rI15KeyBoard in int15.asm. Note that sufficient space is
	; reserved on the stack to add the IRET stack frame that tranfers
	; control back to the user.
	;
     ;;;assume	ds:R_CODE
     ;;;and	[esi][GenFlags], NOT fTurnOff
	assume	ds:_DATA

;
;  Create space in real mode (user) stack for the IRET frame
;
	movzx	ebx,[bp][VTFO].VMTF_ESP	; get DS:BX pointing to user stack
	sub	bx,12			; make room for 2 IRET frames
	mov	[bp][VTFO].VMTF_ESP,bx
	push	ax
	movzx	esi,[bp][VTFO].VMTF_SS
	shl	esi,4
;
;  Build real mode (user) stack: IP and CS for IRET frame
;
	mov	ax, OFFSET R_CODE:rI15KeyBoard	; IP
	mov	[esi][ebx],ax

	inc	bx
	inc	bx
	mov	ax, seg R_CODE		; CS
	mov	[esi][ebx],ax
;
;  Clear IF and TF to correctly emulate the interrupt
;
	inc	bx
	inc	bx
	mov	ax,[bp][VTFO].VMTF_EFLAGS
	mov	[esi][ebx],ax
	inc	bx
	inc	bx
	jmp	RIsetIretFrame		; Go set up the IRET frame for 
					; return to user.


ALIGN	16
;===============================================================================
;==
;== ReflectInterrupt:  This procedure prepares the stack for the
;==		       vReflectInterrupt routine which reflects an interrupt
;==		       to the appropriate real mode interrupt service routine.
;==		       Thus, emulating an interrupt occurring in real mode.
;==
;== Entry: (Protected Mode)
;==	BP    = Points to Virtual/Protected Mode Interrupt Stack Frame (no error)
;==	SS:SP =
;==                 HIword LOword
;==                
;==                 0000   GS  
;==                
;==                 0000   FS    +20h
;==                
;==                 0000   DS    +1Ch
;==                
;==                 0000   ES    +18h
;==                
;==                 0000   SS    +14h
;==                
;==                     ESP       +10h
;==                
;==                    EFLAGS     +0Ch
;==                
;==                 0000   CS    +08h
;==                
;==                     EIP       +04h
;==                
;==                     EBP       +00h
;==                 < SS:BP
;==                 Int. Vector 
;==                 < SS:SP
;==
;==
;== Exit: (Protected Mode)
;==	BP    = Points to Virtual/Protected Mode Interrupt Stack Frame (no error)
;==	DS    = DATA32_GSEL (4GB, zero based selector)
;==	ESI   = 32-bit pointer to base of R_CODE segment
;==	SS:SP =
;==                 HIword LOword
;==                
;==                 0000   GS  
;==                
;==                 0000   FS    +20h
;==                
;==                 0000   DS    +1Ch
;==                
;==                 0000   ES    +18h
;==                
;==                 0000   SS    +14h
;==                
;==                     ESP       +10h
;==                
;==                    EFLAGS     +0Ch
;==                
;==                 0000   CS    +08h
;==                
;==                     EIP       +04h
;==                
;==                     EBP       +00h     Start of VM_TRAP_FRAME (VMTF)
;==                 < SS:BP
;==                 Int. Vector   -02h
;==                
;==                     EBX       -06h
;==                
;==                     ESI       -0Ah
;==                
;==                 DS (dummy)    -0Ch (word)
;==                 < SS:SP
;==
;== Description:
;== 	Setup stack for reflection via vReflectInterrupt.
;==
;===============================================================================
ReflectInterrupt:
	push	ebx
	push	esi
	sub	sp,2			; dummy ES value

	mov	bx,DATA32_GSEL
	mov	ds,bx

	mov	si,seg R_CODE		; DS:[ESI] points to R_CODE
	movzx	esi,si
	shl	esi,4
	jmp	vReflectInterrupt

PRI_hlt:
	push	eax
	mov	eax, [bp][-4]		; get int vect and high ebx
	mov	[bp][0ch], eax
	mov	eax, [bp][-8]		; get low ebx and high esi
	mov	[bp][8], eax
	mov	eax, [bp][-0ch]		; get low esi and ds
	mov	[bp][4], eax
	pop	eax

	add	bp, 4			; make sp point to ds
	mov	sp, bp
	add	bp, 0ch			; make bp point to ebp
    	jmp	vReflectInterrupt

	assume ds:nothing,es:nothing,fs:nothing,gs:nothing
;==============================================================================
;==
;==  CallRealModeRtn:	This routine 'calls' a real/virtual mode routine from
;==			protected mode code.
;==
;==  Entry:  (Protected Mode)
;==	AX = real mode routine id
;==
;==  Exit:   (Protected Mode)
;==	Registers as set by real mode routine
;==
;==============================================================================
	public	CallRealModeRtn

CallRealModeRtn proc	near

	pushfd				; fake a pMode IRET frame that will
	cli				;   return to this routine
	push	0
	push	cs
	push	0
	push	offset _TEXT:CRMR_back	; offset must be < 64k

	push	ebp			; setup stack the way pIRQHandler
	movzx	ebp, sp 		;   wants it

	push	ax			; routine id

	push	ebx			; setup the regs that pIRQHandler wants
	push	esi
	mov	bx, DATA32_GSEL
	push	ds
	mov	si, seg R_CODE
	mov	ds, bx
	movzx	esi, si
	shl	esi, 4
	jmp	pIRQHandler

	public	CRMR_back
CRMR_back:

	ret

CallRealModeRtn endp

	assume ds:nothing,es:nothing,fs:nothing,gs:nothing
ALIGN	16
;==============================================================================
;==
;==  pTrapHandler: Routine which either reflects S/W interrupt or processes
;==		   a protected mode trap via:
;==
;==		   a) returning to the protected mode code interrupted by a
;==		      HW interrupt.
;==		   b) trapping into protected mode for processing an XMS function
;==
;==  Entry:  (Virtual Mode)
;==
;==
;==  Exit:   (Protected Mode)
;==
;==============================================================================
pTrapHandler:
	push	ebp
	mov	bp,sp
	push	ProtTrap

	push	RCODEA_GSEL
	pop	gs
	assume	gs:R_CODE

	btr	gs:[TrapFlags],fXMMtrapBit	;Q: XMS service request?
	jc	pTHXMM				; Y: service it

	btr	gs:[TrapFlags],fWinTrapBit	;Q: EMM Global Import service request?
	jc	pTHEMMGI			; Y: service it

	btr	gs:[TrapFlags],fSetInstPtrBit	;Q: Set Instance data ptr
	jc	pTHSetInst			; Y: service it

ifdef DEBUG
	btr	gs:[TrapFlags],fpModeDebInitBit ;Q: Protected mode debugger init
	jc	pTHDebInit
endif
	btr	gs:[TrapFlags],fIntEndBit	;Q: End of H/W interrupt
	jnc	ReflectInterrupt		; N: reflect to real mode handler
	jmp	pHWInterEnd			; Y: iret to protected mode service

pTHEMMGI:
	call	pWinEMMGlobImpDisp
	jmp	short pTHexit

pTHSetInst:
	push	ds

	mov	di, DATA32_GSEL
	mov	ds, di

	mov	edi, gs:[pGDT]
	mov	dl, ah
	shr	dl, 4
	shl	eax, 4
	mov	word ptr ds:[edi][R1CODE_GSEL][2], ax
	mov	byte ptr ds:[edi][R1CODE_GSEL][4], dl
	mov	word ptr ds:[edi][R1CODEA_GSEL][2], ax
	mov	byte ptr ds:[edi][R1CODEA_GSEL][4], dl

	add	eax, offset R1_CODE:[InstanceData]
	mov	edi, gs:[p_DATA];
	add	edi,offset _DATA:[Win386VxDRefDat].RDSdata
;;	mov	ds:[Win386VxDRefDat].RDSdata,eax
	mov	ds:[edi],eax
	pop	ds
	jmp	short ptHexit

ifdef DEBUG
pTHDebInit:
	; This conditional breakpoint causes the debugger to break if
	; /B is given on the command line.  Plus it has the side effect
	; of allowing the debugger to initialize the protected mode IDT.

	push	ds
	push	esi
	mov	si, RCODEA_GSEL
	mov	ds, si

	mov	esi,offset R_CODE:[DebBreakStr]
	mov	ax, 0F001h
	int	41h

	pop	esi
	pop	ds
	jmp	short pTHexit
endif

pTHXMM:
	call	pXMMentry

pTHexit:
	add	sp,2
	pop	ebp
	iretd

;===========================================================================
;
;	The foll. are Protect mode handlers for ints 25h, 26h, 2ah, 2fh
;	5ch and 33h. These handlers will just reflect the interrupts
;	thru the real mode IDTs.
;
;===========================================================================

pINT25hHandler	proc	far

	push	ebp
	mov	bp, sp
	push	25h
	jmp	ReflectInterrupt

pint25hHandler	endp

pINT26hHandler	proc	far

	push	ebp
	mov	bp, sp
	push	26h
	jmp	ReflectInterrupt

pint26hHandler	endp

pINT2ahHandler	proc	far

	push	ebp
	mov	bp, sp
	push	2ah
	jmp	ReflectInterrupt

pint2ahHandler	endp

pINT2fhHandler	proc	far

	push	ebp
	mov	bp, sp
	push	2fh
	jmp	ReflectInterrupt

pint2fhHandler	endp


pINT33hHandler	proc	far

	push	ebp
	mov	bp, sp
	push	33h
	jmp	ReflectInterrupt

pint33hHandler	endp

pINT5chHandler	proc	far

	push	ebp
	mov	bp, sp
	push	5ch
	jmp	ReflectInterrupt

pint5chHandler	endp

ALIGN	16
;===============================================================================
;==
;==    PMTF processing (PMTF - Protected Mode Trap Frame)
;==
;== 1) Push segment registers.
;== 2) Subtract size of VMTF from ESP. (VMTF - Virtual Mode Trap Frame)
;== 3) Create dummy VMTF for IRETD. (returns to V86 interrupt service routine)
;== 4) Force real mode stack return to dummy HWInterEnd. (inc real mode SP first!)
;== 5) Push ESP0 into nest stack. (inc nest SP first!)
;== 6) Place ESP plus size of VMTF into ESP0 in TSS.
;== 7) IRETD
;==
;==    HWInterEnd processing
;==
;== 1) Add size of VMTF to ESP (throw VMTF away).
;== 2) Pop nest stack. (dec nest SP AFTER getting value!)
;== 3) Place nest stack value into ESP0 of TSS.
;==
;==    SS:SP (ring 0)     Nest Stack             TSS
;==
;==               
;==       VMTF              a                      
;==  a                       
;==     * local *           b                      
;==                          
;==       PMTF              c                      
;==               
;==      Seg Regs                        ESP0 = x  
;==               
;==       VMTF                    
;==  b                 
;==     * local *                 
;==                    
;==       PMTF                    
;==         
;==      Seg Regs 
;==    
;==       VMTF    
;==  c 
;==     * local * 
;==    
;==       PMTF    
;==    
;==      Seg Regs 
;==  x 
;==               
;==               
;==    
;==
;===============================================================================
pHWInterEnd:
	push	eax
	push	ebx

	mov	ax,DATA32_GSEL
	mov	ds,ax

	mov	ax,seg R_CODE
	movzx	eax,ax
	shl	eax,4			; DS:[ESI] point to R_CODE
	assume	ds:R_CODE

	assume	ds:R_CODE
	mov	eax,[eax][p_DATA]	; DS:[EAX] points to _DATA
	assume	ds:_DATA

	movsx	ebx,[eax][pLastVMTF]
	movzx	ebp,[eax][LastVMTF][ebx*2]
	dec	bx
	mov	[eax][pLastVMTF],bx

	add	bp,[VTFO][size VM_TRAP_FRAME]
	mov	[eax][TSS].TSS386_ESP0,ebp

	pop	ebx
	pop	eax

;
;  Need to restore stack
;
	add	sp,2			; throw interrupt number away
	pop	ebp			; restore EBP
	add	sp,[size VM_TRAP_FRAME]	; throw VMTF away
;
;  Restore segment registers & return to protected mode code interrupted
;
	pop	gs
	pop	fs
	pop	es
	pop	ds
	iretd

;==============================================================================
;==
;==  pIRQ5xHandler: H/W protected mode interrupt handlers.  These interrupt
;==		    handlers are used when an application programs the master
;==		    PIC while CEMM is ON/AUTO. (i.e. DesqView)
;==
;==  Entry:  (Protected Mode via 386 Interrupt gate)
;==	SS:SP = Depending on the processor mode when the interrupt occurred:
;==		1) V8086 mode: the virtual mode 8088 stack frame
;==		2) Protected mode: 32-bit EIP, CS, & EFLAGS.
;==
;==  Exit:   EBP pushed on stack
;==	BP = stack frame pointer
;==
;==============================================================================
ALIGN 16
pIRQ50Handler:
	push	ebp
	push	50h
	jmp	short pIRQ5xHandlerN

pIRQ51Handler:
	push	ebp
	push	51h
	jmp	short pIRQ5xHandlerN

pIRQ52Handler:
	push	ebp
	push	52h
	jmp	short pIRQ5xHandlerN

pIRQ53Handler:
	push	ebp
	push	53h
	jmp	short pIRQ5xHandlerN

pIRQ54Handler:
	push	ebp
	push	54h
	jmp	short pIRQ5xHandlerN

pIRQ55Handler:
	push	ebp
	push	55h
	jmp	short pIRQ5xHandlerN

pIRQ56Handler:
	push	ebp
	push	56h
	jmp	short pIRQ5xHandlerN

pIRQ57Handler:
	push	ebp
	push	57h

pIRQ5xHandlerN:
	mov	bp,sp
	push	ebx
	push	esi
	push	ds

	mov	si,DATA32_GSEL
	mov	ds,si

	mov	si,seg R_CODE
	movzx	esi,si
	shl	esi,4				; DS:[ESI] point to R_CODE
	assume	ds:R_CODE

	add	bp,2
	jmp	pIRQHandler

ifndef LC910610
;==============================================================================
;==
;==  pIRQ1Handler: H/W protected mode interrupt handler for the keyboard
;==		   controller (8042).  This will allow CEMM to virtualize the
;==		   8042 data register (port 60h).  Three modes of operation will
;==		   exist:
;==		   1) Reflect the IRQ1 to the appropriate ISR.  Every time a
;==		      scan code is read from the 8042 data register, CEMM traps
;==		      the I/O read, reads the physical 8042 data register and
;==		      passes the data (scan code) to the VDM code.  This is the
;==		      traditional method used by CEMM. (default)
;==		   2) Reflect the IRQ1 to the appropriate ISR.  CEMM will not
;==		      trap accesses to the 8042.  This method may cause the
;==		      system to crash if somebody diddles with the A20 line via
;==		      port 60h and 64h.
;==		   3) Use IRQ1 as a flag to read the scan code into a virtual
;==		      8042 data register.  This forces the 8042 data register
;==		      to be read only once per IRQ1.  This fixes problems caused
;==		      by multiple TSRs reading scan codes and thus causing
;==		      early scan code propagation.  This technique will only
;==		      work if the keyboard ISR is interrupt driven.  If an ISR
;==		      is polling for scan codes, this technique will cause a
;==		      system hang.
;==
;==  Entry:  (Protected Mode via 386 Interrupt gate)
;==	SS:SP = Depending on the processor mode when the interrupt occurred:
;==		1) V8086 mode: the virtual mode 8088 stack frame
;==		2) Protected mode: 32-bit EIP, CS, & EFLAGS.
;==
;==  Exit:   EBP pushed on stack
;==	BP = stack frame pointer
;==
;==============================================================================
ALIGN 16
pIRQ1Handler:
	push	ebp			; save base pointer
	push	1			; IRQ1

	movzx	ebp,sp			; set base pointer
	push	ebx			; save local registers
	push	esi
	push	ds
	mov	si,DATA32_GSEL
	mov	ds,si

	mov	si,seg R_CODE
	movzx	esi,si
	shl	esi,4			; DS:[ESI] point to R_CODE
	assume	ds:R_CODE

	mov	ebx,[esi][p_DATA]	; DS:[EBX] points to _DATA
	assume	ds:_DATA
	mov	[ebx][IRQ1Event],TRUE	; set flag indicating IRQ1 ocurred
	assume	ds:R_CODE

ifdef PICtrap
	mov	bx,[esi][VirPICVec][0]
else
	mov	bx,[esi][PICVec][0]	; get base address for master PIC
endif
	add	[bp],bx			; adjust interrupt number on stack
	add	bp,2			; base pointer pointing to VMTF
	jmp	pIRQHandler		; reflect interrupt
endif

_TEXT	ends
;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
R_CODE	segment
	assume cs:R_CODE,ds:nothing,es:nothing,fs:nothing,gs:nothing
;==============================================================================
;==
;==  HWInterEnd: Routine which traps to protected mode code executing during
;==		 last H/W interrupt.
;==
;==  Entry:  (Virtual Mode)
;==
;==
;==  Exit:   (Protected Mode)
;==
;==============================================================================
HWInterEnd:
	cli				; make sure ProtTrap occurs w/out interrupt
	or	cs:[TrapFlags],fIntEnd	; end of H/W interrupt
	int	ProtTrap		; will never return
	cli
	hlt

ifdef PICtrap
;==============================================================================
;==
;==  rIRQxHandler: H/W real mode interrupt handlers.  These routines will
;==		   reflect HW interrupts to the H/W interrupt service handlers.
;==
;==  Entry:  (Real Mode)
;==
;==
;==  Exit:   (Real Mode)
;==		H/W Interrupt service handler has been executed.
;==
;==============================================================================
rIRQ0Handler:
	push	0
	jmp	short rIRQHandlerMaster

rIRQ1Handler:
	push	1
	jmp	short rIRQHandlerMaster

rIRQ2Handler:
	push	2
	jmp	short rIRQHandlerMaster

rIRQ3Handler:
	push	3
	mov	bl,3
	jmp	short rIRQHandlerMaster

rIRQ4Handler:
	push	4
	jmp	short rIRQHandlerMaster

rIRQ5Handler:
	push	5
	jmp	short rIRQHandlerMaster

rIRQ6Handler:
	push	6
	jmp	short rIRQHandlerMaster

rIRQ7Handler:
	push	7
	jmp	short rIRQHandlerMaster

rIRQ8Handler:
	push	0
	jmp	short rIRQHandlerSlave

rIRQ9Handler:
	push	1
	jmp	short rIRQHandlerSlave

rIRQ10Handler:
	push	2
	jmp	short rIRQHandlerSlave

rIRQ11Handler:
	push	3
	jmp	short rIRQHandlerSlave

rIRQ12Handler:
	push	4
	jmp	short rIRQHandlerSlave

rIRQ13Handler:
	push	5
	jmp	short rIRQHandlerSlave

rIRQ14Handler:
	push	6
	jmp	short rIRQHandlerSlave

rIRQ15Handler:
	push	7
	jmp	short rIRQHandlerSlave

rIRQHandlerMaster:
	push	bx
	mov	bx,sp
	mov	bx,ss:[bx][2]
	add	bx,DOS_MASTER_VECTOR

rIRQHandler:
	push	ds

	mov	ds,cs:[ZERO]
	xor	bh,bh
	shl	bx,2

	pushf
	call	dword ptr [bx]

	pop	ds
	pop	bx
	add	sp,2
	iret

rIRQHandlerSlave:
	push	bx

	mov	bx,sp
	mov	bx,ss:[bx][2]

	add	bx,DOS_SLAVE_VECTOR
	cmp	cs:[SlavePicVec],DOS_SLAVE_VECTOR
	jne	short rIRQHandler

	sub	bx,DOS_SLAVE_VECTOR
	xor	bh,bh
	shl	bx,2

	pushf
	call	dword ptr cs:[OldSlaveIRQHandler][bx]
	pop	bx
	add	sp,2
	iret

;==============================================================================
;==
;==  Must hook INT 21h for Phar-Lap's DOS Extender. (Look like DesqView)
;==
;==  A bug in DOS Extender does not allow reprogramming of the PICs by CEMM.
;==  The problem has been fixed for QuarterDeck's DesqView.  Thus by hooking
;==  INT 21h and responding a DesqView signature to DOS Extender apps,
;==  this should fix the problem.
;==
;==  NOTE: INT 21h is not hooked if PIC is not programmed by CEMM.
;==
;==============================================================================
rINT21hHandler:
	cmp	ah,2Bh
	jne	short rI21Hchain
	cmp	cx,'DE'
	jne	short rI21Hchain
	cmp	dx,'SQ'
	jne	short rI21Hchain

	test	cs:[Current_State],fState_Active ;Q: in Virtual mode ?
	jz	short rI21Hchain		 ; N: don't need to process

;
;QLEO: Need to add code to detect a PharLap DOS Extender App (Get PSP and
;      look for Copyright information.  If it is a PharLap App, return
;      BX=0215h (version 2.21).
;
	push	ax	; save registers
	push	bx
	push	cx
	push	si
	push	di
	push	ds
	push	es

	push	cs	; access R_CODE
	pop	ds

	mov	ah,62h	; get PSP address in BX
	int	21h
	mov	es,bx

	lea	si,R_CODE:PharLapCopy
	mov	di,PharLapOffs
	mov	cx,PharLapCopyLen
	cld
;
;  Is Pharlap Copyright notice in PSP?
;
	repe cmpsb		;Q: Is Copyright at 100h into PSP?
	jne short rI21Hexit 	; N: no, not a Phar Lap app, chain to DOS
				; Y: skip dates, and look for Phar Lap.
	mov	al,[PharLapName]; search for "P"
	mov	cx,20h		; skip up to 32 bytes worth of dates
	repne scasb		; find "P" of Phar Lap
	dec	di		; incase it was found, return to "P"

	lea	si,R_CODE:PharLapName ; compare to "Phar Lap Software, Inc."
	mov	cx,PharLapCopyLen
	repe cmpsb		;Q: Is it a Phar Lap Dos Extender application?

rI21Hexit:
	pop	es	; restore registers
	pop	ds
	pop	di
	pop	si
	pop	cx
	pop	bx
	pop	ax

	jne	short rI21Hchain 	;N: no, not a Phar Lap app, chain to DOS
	mov	bx,0215h		;Y: return version 2.21
	iret

rI21Hchain:
	jmp	dword ptr cs:[OldInt21hHandler]
endif

R_CODE	ends
;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
LAST	segment
	assume	cs:LAST,ds:_DATA,es:_DATA,gs:R_CODE
;==============================================================================
;==
;==  PICInit: This routine initializes necessary data structures for
;==	      handling H/W interrupts and trapping PIC programming in
;==	      virtual 8088 mode.  Places correct IDT interrupt gates
;==	      for the H/W interrupt handlers.
;==
;==  Entry: (Real Mode)
;==	DS = _DATA
;==	GS = R_CODE
;==
;==  Exit:  (Real Mode)
;==
;==============================================================================
PICInit	proc	near
	push	fs

ifdef PICtrap
	test	gs:[GenFlags],fNoINT	;Q: Need to trap PIC?
	jnz	short PIvectors		; N: just update IVT and IDT
;
; The addresses of the PIC ports are set in the IO bit map so that accesses
; to them while in virtual 8088 mode will be trapped.
;
	xor	bx,bx			; 64K IO address space

	test	gs:[GenFlags],fEISA+fMCA;Q: EISA or MCA machine?
	jnz	short PIPorts		; Y: continue

ifdef	ROMIDMCA
	cmp	[ROMID],ROMIDPS2	;Q: MCA machine?
	je	short PIPorts		; Y: continue
endif
;
;  ISA system: Alias every 1K of IO space
;
	mov	bx,8000h		; 1K IO address space

PIPorts:
;
;  Trap PIC ports
;
	mov	cx,TOTAL_PIC_PORTS 	; trap EISA DMA ports
	xor	esi,esi
PISetPorts:
	mov	ax,gs:[PICPortList][esi*2]
	call	_TEXT:PortTrapFar
	inc	si
	loop	PISetPorts

;
;  Place real/protected mode handlers in IVT/IDT: Master/Slave PIC
;
PIvectors:
endif
	movzx	ebx,gs:[MasterPICVec]	; base vector for master PIC
	movzx	edx,gs:[SlavePICVec]	; base vector for slave PIC

ifdef PICtrap
	cmp	bx,DOS_MASTER_VECTOR	;Q: Will CEMM move master PIC?
	jz	short PIslave		; N: how about slave?
	or	[PICFlags][0],fPICMoved	; Y: CEMM has moved master PIC vectors
PIslave:
	cmp	dx,DOS_SLAVE_VECTOR	;Q: Will CEMM move master PIC?
	jz	short PIhandle		; N: continue
	or	[PICFlags][2],fPICMoved	; Y: CEMM has moved slave PIC vectors
PIhandle:
endif
	xor	esi,esi

	mov	cx,IDT
	mov	fs,cx			; FS = IDT (protected mode)
	assume	fs:IDT

	mov	ax,VDMC_GSEL		; master PIC (IDT)
	shl	eax,16

	shl	bx,3			; convert vector to offset in IDT
	shl	dx,3
	mov	cx,8			; 8 interrupts per PIC
PIIRQHandlers:
;
;  Place protected mode interrupt gates in IDT
;
	mov	ax,cs:[pIRQ5xHandlers][esi*2]		; IRQs at 50h
	mov	fs:[50h*8][esi*8],eax
	mov	byte ptr fs:[50h*8][esi*8][5],D_386INT0

ifdef PICtrap
	test	[PICFlags],fPICMoved	;Q: Master PIC handlers needed?
	jz	short PIcont		; N: don't need them (exception handlers)

	mov	ax,cs:[pMasterIRQHandlers][esi*2]
	mov	fs:[ebx][esi*8],eax
	mov	byte ptr fs:[ebx][esi*8][5],D_386INT0
PIcont:
endif
	mov	ax,cs:[pSlaveIRQHandlers][esi*2]	; slave PIC (IDT)
	mov	fs:[edx][esi*8],eax
	mov	byte ptr fs:[edx][esi*8][5],D_386INT0

	inc	si
	loop	PIIRQHandlers

;
;  Place multi-purpose protected mode trap selector
;
	lea	ax,[pTrapHandler]			; into protected mode
	mov	fs:[ProtTrap*8],eax			; save VDMC_GSEL:pTrapHandler
	mov	byte ptr fs:[ProtTrap*8][5],D_386INT3	; accessible via S/W

	pop	fs
	ret
PICInit	endp

;==============================================================================
;==
;==  PICVecInit: This routine places correct IVT vectors for the H/W
;==		 interrupt handlers.
;==
;==  Entry: (Real Mode)
;==	GS = R_CODE
;==
;==  Exit:  (Real Mode)
;==
;==============================================================================
PICVecInit proc	near
	push	es

ifdef PICtrap
;
;  Place real mode handlers in IVT: Master/Slave PIC
;
	movzx	ebx,gs:[MasterPICVec]	; base vector for master PIC
	movzx	edx,gs:[SlavePICVec]	; base vector for slave PIC
	xor	esi,esi

	mov	es,si			; ES = IVT (real mode)
	mov	cx,IDT
	assume	es:ABS0

	shl	bx,2			; convert vector to offset in IVT
	shl	dx,2
	mov	cx,8			; 8 interrupts per PIC

PVIIRQHandlers:
;
;  Place real mode vectors in IVT
;
	cmp	gs:[MasterPICVec],DOS_MASTER_VECTOR ;Q: Master PIC handlers needed?
	je	short PVIslave			    ; N: don't need them

	mov	ax,R_CODE				; master PIC (IVT)
	shl	eax,16
	mov	ax,cs:[rMasterIRQHandlers][esi*2]
	mov	es:[ebx][esi*4],eax

PVIslave:
	cmp	gs:[SlavePICVec],DOS_SLAVE_VECTOR ;Q: Slave PIC handlers needed?
	je	short PVIcont			    ; N: don't need them

	mov	ax,R_CODE				; slave PIC (IVT)
	shl	eax,16
	mov	ax,cs:[rSlaveIRQHandlers][esi*2]
	xchg	es:[edx][esi*4],eax
	mov	gs:[OldSlaveIRQHandler][esi*4],eax	; save original vector
PVIcont:
	inc	si
	loop	PVIIRQHandlers

	cmp	gs:[MasterPICVec],DOS_MASTER_VECTOR ;Q: Master PIC handlers needed?
	jne	short PVIhook			    ; Y: hook INT 21h
	cmp	gs:[SlavePICVec],DOS_SLAVE_VECTOR ;Q: Slave PIC different?
	je	short PVIexit			  ; N: don't hook
PVIhook:
;==============================================================================
;==
;==  Must hook INT 21h for Phar-Lap's DOS Extender. (Look like DesqView)
;==
;==  A bug in DOS Extender does not allow reprogramming of the PICs by CEMM.
;==  The problem has been fixed for QuarterDeck's DesqView.  Thus by hooking
;==  INT 21h and responding a DesqView signature to DOS Extender apps,
;==  this should fix the problem.
;==
;==============================================================================
	mov	eax,es:[int21]			; get original vector
	mov	gs:[OldInt21hHandler],eax	; save it
	mov	ax,R_CODE			; CEMM's Int21h handler in IVT
	shl	eax,16
	lea	ax,R_CODE:[rINT21hHandler]
	mov	es:[int21],eax
PVIexit:
endif
	pop	es
	ret
PICVecInit	endp

LAST	ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\mseisa.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386 - MICROSOFT Expanded Memory Manager 386
;
;   Module:   mseisa.inc
;
;  $chk_ms_xmm260:  This routine checks for the Microsoft HIMEM.SYS which
;		     was released with Windows 3.0.  This HIMEM, XMS 2.0 and
;		     internal release 2.60, uses the COMPAQ Built In Memory (BIM)
;		     without allocating it.  In order to prevent COMPAQ's
;		     utilities from allocating BIM, this routine is used to
;		     activate HIMEM.
;
;  (The routine preserves all registers)
;******************************************************************************

$ROMSEG            equ  0F000h
$EISAOFF           equ  0FFD9h
$ROMEISA           label dword
		   dw   $EISAOFF
                   dw   $ROMSEG
$XMMcontrol        dd   0

$chk_ms_xmm260     proc near
    push      es                            ;;
    push      bx                            ;;
    push      ax                            ;;
    les	      bx,[$ROMEISA]		    ;; address for "EISA" string
    cmp	      es:[bx],'IE'		    ;;Q: "EI" part of EISA?
    jne	      $no_XMM			    ;; N: not an EISA machine
    cmp	      es:[bx+2],'AS'		    ;;Q: "SA" part of EISA?
    jne	      $no_XMM			    ;; N: not an EISA machine
    mov       ax,4300h                      ;; function for XMS detect
    int       2fh                           ;; check for XMS driver
    cmp       al,80h                        ;; Q: Is XMS installed?
    jne       $no_XMM                       ;;  N: XMS not in use, not enough
    mov       ax,4310h                      ;; Get XMS routine address
    int       2fh                           ;;
    mov       word ptr cs:[$XMMcontrol],bx  ;; Save XMS routine address
    mov       word ptr cs:[$XMMcontrol+2],es;; (offset), (segment)
    mov       ah,0                          ;; Get XMS version number
    call      cs:[$XMMcontrol]              ;; Call XMM
    cmp       ax,200h                       ;; check if version = 2.00
    jne       $no_XMM                       ;; if yes continue
    cmp       bx,260h                       ;; check if internal rev > 205
    jne       $no_XMM                       ;; if yes continue
    mov       ah,8                          ;; How much extended memory is
    call      cs:[$XMMcontrol]              ;; ..... available in Kbytes?
$no_XMM:                                     ;;
    pop       ax                            ;;
    pop       bx                            ;; restore bx
    pop       es                            ;; restore es
    ret                                     ;;
$chk_ms_xmm260      endp                    ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\print.asm ===
.386p
page	58,132
;******************************************************************************
	title	PRINT.ASM - Protected Mode Print Routines
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386D.EXE - MICROSOFT Expanded Memory Manager 386 DEBUG Driver
;
;   Module:   PRINT.ASM - Protected Mode Print Routines
;
;   Version:  0.08
;
;   Date:     January 31, 1986
;
;   Author:
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   01/31/86  Original
;   05/12/86  A-RRH	Cleanup and segment reorganization
;   06/28/86  0.02	Name changed from CEMM386 to CEMM (SBP).
;   07/05/86  0.04	Moved to DCODE segment (SBP).
;   07/06/86  0.04	moved data to DDATA segment (SBP).
;   09/09/86  0.08	Added code to decide MONO vs. COLOR screen (SBP).
;
;******************************************************************************
;
;   Functional Description:
;
;******************************************************************************
.lfcond 				; list false conditionals

	public	PrintString
	public	kputc
	public	RowCol
	public	IsReal

	include VDMseg.inc
	include VDMsel.inc
	include desc.inc

DDATA	 segment
RowCol	dw	0
DDATA	 ends

CR	equ	0dh				; carriage return
LF	equ	0ah				; line feed
TAB	equ	9				; tab
BS	equ	8				; backspace

MONO_PARA	equ	0b000h
COLOUR_PARA	equ	0b800h


;***	kputc - write character/attribute to screen
;
;	This is a simple character output routine. It does not
;	interleave writes to video memory with the 6845. It
;	does not update the cursor position. It does not understand
;	anything except a CGA in 80x25 text mode.
;
;	ENTRY	PROTECTED MODE
;		AX - character-attribute to write
;		DS - kernel data selector
;
;	EXIT	none - character written
;
;	USES	AX, flags
;
DCODE	 segment

	assume	cs:DCODE, ds:DDATA, es:nothing, ss:nothing

kputc	proc	far

	push	bx				; save callers regs
	push	cx
	push	dx
	push	si
	push	di
	push	es
	push	ds

	call	IsReal				; need dual mode access
	jnz	SHORT kp10
	mov	dx, DEBD_GSEL			; selector for protected mode
	jmp	SHORT kp11
kp10:
	mov	dx, DDATA			 ; para for real mode
kp11:
	push	dx				; save this segment for later

	mov	ds, dx				; DS -> data segment
	mov	dx, ds:[RowCol] 		; DX = current row/col

	cmp	al, CR				; is character a CR?
	jne	SHORT kp1

	mov	dl, 0				; yes, go to column 0
	jmp	SHORT kp3			; jump to common code
kp1:

	cmp	al, LF				; is character a LF?
	jne	SHORT kp2

	inc	dh				; yes, go to next row
	jmp	SHORT kp3			; jump to common code
kp2:

	cmp	al, TAB 			; is it a tab
	jne	SHORT kp12
	and	dl, 0f8h			; mask off low 3 bits (8 ch)
	add	dl, 8				; move to next tab position
	jmp	SHORT kp3			; jmp to common code
kp12:

	cmp	al, BS				; is it backspace
	jne	SHORT kp13
	dec	dl				; back up one column
	jmp	SHORT kp3			; goto common code
kp13:
;	Must be ordinary character. Write it to screen, update position

	push	ax			; save char/attr

	mov	al, dh			; AL = row
	mov	ah, 80			; multiplier, 80 char per row
	mul	ah			; AX = cell at start of row
	mov	bh, 0
	mov	bl, dl			; BX = column
	add	bx, ax			; BX = cell
	shl	bx, 1			; BX = byte offset of cell

	call	GetVidSel		;(0.08) get video mem screen sel/seg
	mov	es, ax			; ES -> screen

	pop	es:[bx] 		; write character
	inc	dl			; update column
kp3:
;	Common code, first check for line wrap:

	cmp	dl, 80			; beyond rhs of screen?
	jl	SHORT kp4
	mov	dl, 0			; go to col 0
	inc	dh			; and move to next line
kp4:
;	Now check for scroll needed:

	cmp	dh, 25			; are we off end of screen?
	jl	SHORT kp5

;	Now scroll screen

	call	GetVidSel		;(0.08) get video mem screen sel/seg
	mov	ds, ax			; DS -> screen
	mov	es, ax			; ES -> screen

	mov	di, 0			; ES:DI = copy destination
	mov	si, 160 		; DS:SI = copy source
	mov	cx, 2000-80		; copy word count
	cld
	rep	movsw			; scroll

;	Blank bottom line

	mov	al, ' '
	mov	ah, 7			; AX = blank character

	mov	cx, 80			; number of cells to blank
	mov	di, 4000-160		; ES:DI = start point
	rep	stosw

;	Update position

	mov	dh, 24			; new row
kp5:
	pop	ds			; set DS to data again
	mov	ds:[RowCol], dx 	; update row/col

	call	SetCursor

	pop	ds			; restore regs
	pop	es
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx

	ret

kputc	endp
DCODE	 ends


;***	SetCursor - updates cursor position
;
;	This routine reprograms the 6845 cursor position, and
;	stores the new cursor position in the ROM bios data area.
;
;	ENTRY	DUAL MODE
;		DH, DL = row, col
;
;	EXIT	cursor updated
;
;	USES	ax, bx, cx, flags
;

CRT_COLS	equ	04ah
CURSOR_POSN	equ	050h
CRT_START	equ	04eh
ADDR_6845	equ	063h


DCODE	 segment

	assume	cs:DCODE, ds:DDATA, es:nothing, ss:nothing

SetCursor	proc	near

	push	ds
	mov	bx, 40h
	mov	ds, bx

;	Save new position in BIOS data area

	mov	ds:[CURSOR_POSN], dx

;	Calculate offset on screen

	mov	al, dh				; row
	mul	byte ptr ds:[CRT_COLS]		; row * cols
	mov	bl, dl				; bl = column
	mov	bh, 0				; bx = column
	add	ax, bx				; ax = offset in screen
	sal	ax, 1				; double for attribute bytes
	mov	cx, ds:[CRT_START]		; cx = start point of screen
	add	cx, ax				; cx = offset of cursor
	sar	cx, 1				; convert to char count only

;	Now program 6845

	mov	al, 14				; 6845 register
	mov	dx, ds:[ADDR_6845]		; base port #
	out	dx, al
	inc	dx
	jmp	short $+2

	mov	al, ch
	out	dx, al
	dec	dx
	jmp	short $+2

	mov	al, 15
	out	dx, al
	inc	dx
	jmp	short $+2

	mov	al, cl
	out	dx, al

	pop	ds

	ret

SetCursor	endp
DCODE		 ends


;***	PrintString - prints a message on console
;
;	This routine calls the "kernel" to print a string
;	one character at a time.
;
;	ENTRY	286 PROTECTED MODE
;		DS - DATA3_SEL
;		ES - DATA3_SEL
;		SI - offset in DS of null terminated string to print
;
;	EXIT	String printed
;
;	USES	Flags
;

DCODE	 segment

	assume	cs:DCODE, ds:DDATA, es:nothing, ss:nothing

PrintString	proc	near

	cld					; set up for string ops
	push	si				; save callers regs
	push	ax

pr1:						; loop printing until null
	lodsb					; al = char to print
	and	al, al				; terminator ?
	je	SHORT pr2
	mov	ah, 7				; attribute

	db	9ah				; far call
	dw	offset DCODE:kputc		 ; offset
	dw	DEBC_GSEL			; selector

	jmp	pr1				; back for more
pr2:
	pop	ax				; restore callers regs
	pop	si

	ret

PrintString	endp

;***	GetVidSel - Get video selector/segment
;
;	This routine sets AX to the selector/segment for the current
;	primary monitor - MONO or COLOR
;
;	ENTRY	DUAL MODE
;
;	EXIT	AX = selector / segment for primary monitor display memory
;
;	USES	flags
;
GetVidSel	proc	near

	call	IsReal			;Q: Real mode ?
	jnz	SHORT GVS_Real		; Y: determine MONO vs COLOR
	mov	ax, COLOUR_GSEL 	; N: Protected mode -> assume COLOR
	call	IsMono			;   Q: primary is MONO ?
	jnz	SHORT GVS_Exit		;     N: COLOR and Protected mode
	mov	ax, MONO_GSEL		;     Y: MONO and Protected mode
	jmp	SHORT GVS_Exit
GVS_Real:
	mov	ax, COLOUR_PARA 	; screen para for real mode COLOR
	call	IsMono			;   Q: primary is MONO ?
	jnz	SHORT GVS_Exit		;     N: COLOR and Real mode
	mov	ax, MONO_PARA		;     Y: MONO and Real mode
	jmp	SHORT GVS_Exit
GVS_Exit:
	ret

GetVidSel	endp

;***	IsReal - determine mode of cpu
;
;	This routine is useful when writing dual mode code.
;	It returns with 'Z' = 1 if the cpu is in protected mode,
;	otherwise 'Z' = 0.
;
;	ENTRY	DUAL MODE
;
;	EXIT	'Z' = 1 (protected mode), 0 (real mode)
;
;	USES	flags
;

IsReal	proc	near

	push	ax
	smsw	ax
	xor	al, 0ffh
	and	al, 1
	pop	ax
	ret				; returns with flags set

IsReal	endp

;***	IsMono - determine mode of cpu
;
;	Determines if the primary monitor is Monochrome.
;	It returns with 'Z' = 1 if the monitor is monochrome,
;	otherwise 'Z' = 0.
;
;	ENTRY	DUAL MODE
;			(selector 40h must point to 40:0 physical).
;
;	EXIT	'Z' = 1 (primary is monochrome), 0 (else)
;
;	USES	flags
;

IsMono	proc	near

	push	ds
	push	ax
	mov	ax,40h
	mov	ds,ax
	ASSUME	DS:romdata
	mov	ax,[EqStatus]
	and	ax,30h			; keep only primary display bits
	cmp	ax,30h			;Q: monochrome ?
					;   ZR => yes   NZ => no
	pop	ax
	pop	ds
	ASSUME	DS:DDATA
	ret				; returns with flags set

IsMono	endp

DCODE	 ends
	end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\ps2table.asm ===
.386p

;****************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;
;   This file is not normal source because it contains no code, all it has 
;   is a binary table which tells EMM386 about which regions of memory 
;   betweeen A000:0000 and EFFF:000F need to beexcluded from use by EMM386 
;   for things like EMM mapping regions.
;
;   Adaptors on PS/2 machines are often programmable as to which regions
;   of address space ROM and/or RAM on the adaptor may occupy. This table
;   allows EMM386 to read the adaptor configuration and exclude the proper
;   regions. EMM386 is capable of correctly excluding some adaptors on
;   PS/2 machines by employing a memory search, but this causes problems
;   with many adaptors:
;
;	o Some adaptors don't actually start "occupying" the address space
;		they use until they are enabled by a piece of software. This
;		defeats the EMM386 scan because the region looks empty if
;		the adaptor is disabled when WIN386 is started.
;
;	o Some adaptors have a RAM area which is actually a memory mapped
;		control area. The EMM386 scan reads and writes as part of
;		its operation, this can alter the adaptor state and disturb
;		the operation of the adaptor (the IBM 3270 card is an example
;		of an adaptor like this, writing to certain adaptor memory
;		locations causes the 3270 adaptor to try to execute an adaptor
;		command).
;
;	o Some adaptors adress ranges are only partly ocupied at any given time
;		based on the current state of the adaptor.
;
;
;   This table tells EMM386 how to interpret the adaptor POS bytes to determine
;   what regions of address space the adaptor is occupying.
;
;   The memory regions which EMM386 cares about for this are typically between
;   page A0 and page FF. Note that the data structure allows the specification
;   of ANY page number between 0 and FFh though.
;
;   *******************************************************
;   *							  *
;   *  Above ability to spec any page in 0-FF range is	  *
;   *  difference between table revs 0000h and 0001h	  *
;   *							  *
;   *******************************************************
;
;   The spec of an adapter range is 4K granular, an adaptor occupies only
;   part of a given 4k page will excluded the entire 4k page.
;
;   The Table is formed like this:
;
;	pPOSCardTable	near pointer to supported options table
;	    TotalOptions    dw	    ?	    ; Number of entries
;	    TabelRev	    dw	    0	    ; REV of table definition
;	    OptionTables    db	    ? DUP(?); Start of OptionStruc structures
;
;   TotalOptions indicates the size of the table. It is the count of how many
;   OptionStruc structures are in the file starting at OptionTables.
;
;   The current TableRev is 0001.
;
;   For each adaptor supported there is an OptionStruc which defines how to
;   exclude the region occupied by the adaptor. The values in these structures
;   are produced by interpreting the information in the @????.ADF file for
;   the adaptor:
;
;	OptionStruc struc
;		OptID	    dw	    ?	    ; 16 bit adaptor ID
;		POS2Mask    db	    ?	    ; How to interpret POS byte 2
;		POS2Shft    db	    ?
;		POS3Mask    db	    ?	    ; How to interpret POS byte 3
;		POS3Shft    db	    ?
;		POS4Mask    db	    ?	    ; How to interpret POS byte 4
;		POS4Shft    db	    ?
;		POS5Mask    db	    ?	    ; How to interpret POS byte 5
;		POS5Shft    db	    ?
;		LookUpCnt   dw	    ?	    ; Number of entries following
;		LookUpTab   db	    ? DUP(?); start of MemAddr Structures
;	OptionStruc ends
;
;	MemAddr struc
;		StartPg     db	    ?	    ; 0 based Physical page #
;					    ;	of first 4k page occupied
;					    ;	by adaptor.
;		PGLen	    db	    ?	    ; Number of 4K pages occupied
;					    ;	(May be 0).
;	MemAddr ends
;
;   This table describes how to convert the adaptor specific POS bytes
;   into the list of 4k pages to mark as used by this adaptor:
;
;     NOTE: In the following code the normal ">>" C operator IS NOT A SHR, IT
;	    IS A ROR.
;
;     if(ThisOptionID == OptionStrPtr->OptID) {
;	LookUpPTR = &OptionStrPtr->LookUpTab; /* point at LookUpTab for adaptor */
;	PgPTR = pPgArray;
;	index  = (POS2Byte & OptionStrPtr->POS2Mask) >> OptionStrPtr->POS2Shft;
;	index |= (POS3Byte & OptionStrPtr->POS3Mask) >> OptionStrPtr->POS3Shft;
;	index |= (POS4Byte & OptionStrPtr->POS4Mask) >> OptionStrPtr->POS4Shft;
;	index |= (POS5Byte & OptionStrPtr->POS5Mask) >> OptionStrPtr->POS5Shft;
;	if(index < LookUpCnt) {
;	   LookUpPTR += index;
;	   PgPTR += LookUpPTR->StartPg;
;	   for(i=0;i < LookUpPTR->PGLen;i++)
;		   *PgPtr++=1;
;	}
;     }
;
;   What is basically going on here is that the POSnMask and POSnShft values
;   specify a combonation of the POS byte bits which produce an index into
;   the LookUpTab MemAddr structure which specifies a region occupied by the
;   adaptor. NOTE THAT THE >> OPERATOR IS ROR NOT SHR!!!!!!! This allows for
;   more flexibility in bit movement.
;   The index variable IS A BYTE, therefore LookUpCnt could be 0FFh at most,
;   but typical values are <= 16. Try to be efficient in forming the index.
;   Don't waste space with lots of invalid entries.
;
;   POS bytes to be ignored are indicated by POSnMask = POSnShft = 0.
;
;   THE POS BYTES NUMBERS IN THIS FILE ARE DIFFERENT THAT THE POS BYTE NUMBERS
;   SPECIFIED IN THE .ADF FILE. THE DELTA IS 2. This is because the numbers in
;   this file are PHYSICAL POS byte numbers. The numbers in the ADF file are
;   logical. PHYSICAL POS bytes 0 and 1 are the adaptor ID POS bytes.
;
;	.ADF file POS	WIN386.PS2 POS
;	  byte #	   byte #
;     ==================================
;	    0		     2
;	    1		     3
;	    2		     4
;	    3		     5
;
;   Invalid entries in LookUpTab MemAddr structures should set
;     StartAddr = PGLen = 0.
;
;   NOTE to support adaptors with multiple discontiguous memory use
;   blocks, make more than one entry for the card ID
;
;   Note: Ported from win386 3.0 sources
;
;
;=============================================================================
;==
;==	Change Log:
;==
;==	DATE	 TAG 		Description
;==	-------- --------	--------------------------------------------
;==	01/21/91 M003		Added an entry for the IBM Artic Adapter
;==				(@EFF0.ADF). This has been ssynched up from
;==				the win386 project.
;=============================================================================


include	vdmseg.inc

LAST	SEGMENT
	assume cs:last

public	PS2DATA
PS2DATA	Label	BYTE

	dw	19	; Total options
	dw	0001h	; Table Rev
;
; AdapterName  "The IBM 3270 Connection Version A"
;
	dw	0E7FFH	; ID of 3270 card V A
	db	0	; Ignore all POS bytes
	db	0
	db	0
	db	0
	db	0
	db	0
	db	0
	db	0
	dw	1	; One entry
	db	0CEh
	db	2
;
; AdapterName "The IBM 3270 Connection Version B"
;
	dw	0E1FFH	; ID of 3270 card V B
	db	0	; Ignore POS[2]
	db	0
	db	00011110B
	db	1
	db	0	; Ignore POS[4]
	db	0
	db	0	; Ignore POS[4]
	db	0
	dw	16	; 16  entrys
	db	0	; 0000 invalid
	db	0
	db	0	; 0001 invalid
	db	0
	db	0	; 0010 invalid
	db	0
	db	0	; 0011 invalid
	db	0
	db	0	; 0100 invalid
	db	0
	db	0CAh	; 0101 0CA000h- 0CBFFFh
	db	2
	db	0CCh	; 0110 0CC000h- 0CDFFFh
	db	2
	db	0CEh	; 0111 0CE000h- 0CFFFFh
	db	2
	db	0D0h	; 1000 0D0000h- 0D1FFFh
	db	2
	db	0D2h	; 1001 0D2000h- 0D3FFFh
	db	2
	db	0D4h	; 1010 0D4000h- 0D5FFFh
	db	2
	db	0D6h	; 1011 0D6000h- 0D7FFFh
	db	2
	db	0D8h	; 1100 0D8000h- 0D9FFFh
	db	2
	db	0DAh	; 1101 0DA000h- 0DBFFFh
	db	2
	db	0DCh	; 1110 0DC000h- 0DDFFFh
	db	2
	db	0DEh	; 1111 0DE000h- 0DFFFFh
	db	2
;
; AdapterName  "Ungermann-Bass NICps/2 Ethernet LAN Adapter"
;
;  NOTE: THAT THIS ADAPTOR HAS 2 ENTRIES. One for RAM region, One for ROM
;	 region.
;
	dw	0EFF5H	; ID of UB net card RAM
	db	0	; Ignore POS[2]
	db	0
	db	10000001B
	db	6
	db	0	; Ignore POS[4]
	db	0
	db	00010010B
	db	1
	dw	13	; 13 entrys (last three of normal 16 are invalid)
	db	0C0h	; 0000	mem 0c0000h-0c7fffh
	db	8
	db	0C8h	; 0001	mem 0c8000h-0cffffh
	db	8
	db	0	; 0010 invalid
	db	0
	db	0	; 0011 invalid
	db	0
	db	0D0h	; 0100	mem 0d0000h-0d7fffh
	db	8
	db	0D8h	; 0101	mem 0d8000h-0dffffh
	db	8
	db	0	; 0110 invalid
	db	0
	db	0	; 0111 invalid
	db	0
	db	0C0h	; 1000	mem 0c0000h-0cffffh
	db	16
	db	0	; 1001 invalid
	db	0
	db	0	; 1010 invalid
	db	0
	db	0	; 1011 invalid
	db	0
	db	0D0h	; 1100	mem 0d0000h-0dffffh
	db	16
		; NOTE 1110 is "valid" but specifies a range that
		;    is outside V86 mode addressability.
		; 1110	mem 0e10000h-0e1ffffh

	dw	0EFF5H	; ID of UB net card ROM
	db	0	; Ignore POS[2]
	db	0
	db	0	; Ignore POS[3]
	db	0
	db	10000001B
	db	5
	db	00001100B
	db	2
	dw	12	; 12 entrys (last 4 of normal 16 are invalid)
	db	0C0h	; 0000 mem 0c0000h-0c3fffh
	db	4
	db	0C4h	; 0001 mem 0c4000h-0c7fffh
	db	4
	db	0C8h	; 0010 mem 0c8000h-0cbfffh
	db	4
	db	0CCh	; 0011 mem 0cc000h-0cffffh
	db	4
	db	0	; 0100 NOTE 0100 is "valid" but specifies a range that
	db	0	;	       is outside V86 mode addressability.
			;	       mem 0E00000h-0E03fffh
	db	0	; 0101 invalid
	db	0
	db	0	; 0110 invalid
	db	0
	db	0	; 0111 invalid
	db	0
	db	0D0h	; 1000 mem 0d0000h-0d3fffh
	db	4
	db	0D4h	; 1001 mem 0d4000h-0d7fffh
	db	4
	db	0D8h	; 1010 mem 0d8000h-0dbfffh
	db	4
	db	0DCh	; 1011 mem 0dc000h-0dffffh
	db	4
;
; AdapterName "Ungermann-Bass Net/One PSNIU LAN Adapter"
;
;  NOTE: THAT THIS ADAPTOR HAS 2 ENTRIES.
;
	dw	07012H	; ID of UB net card shared RAM
	db	01000000b
	db	3
	db	00000111b
	db	0
	db	0	; Ignore POS[4]
	db	0
	db	0	; Ignore POS[5]
	db	0
	dw	16	; 16 entrys
	db	0	; 0000 invalid
	db	0
	db	0	; 0001 invalid
	db	0
	db	0C8h	; 0010 Mem 0C8000h-0CFFFFh
	db	8
	db	0	; 0011 invalid
	db	0
	db	0	; 0100 invalid
	db	0
	db	0	; 0101 invalid
	db	0
	db	0D8h	; 0110 Mem 0D8000h-0DFFFFh
	db	8
	db	0	; 0111 invalid
	db	0
	db	0	; 1000 invalid
	db	0
	db	0	; 1001 invalid
	db	0
	db	0C8h	; 1010 Mem 0C8000h-0CBFFFh
	db	4
	db	0CCh	; 1011 Mem 0CC000h-0CFFFFh
	db	4
	db	0	; 1100 invalid
	db	0
	db	0	; 1101 invalid
	db	0
	db	0D8h	; 1110 Mem 0D8000h-0DBFFFh
	db	4
	db	0DCh	; 1111 Mem 0DC000h-0DFFFFh
	db	4

	dw	07012H	; ID of UB net card Remote IPL and 3270 emulation
	db	00001100b
	db	7
	db	01110000b
	db	4
	db	0	; Ignore POS[4]
	db	0
	db	0	; Ignore POS[5]
	db	0
	dw	32	; 32 entrys
	db	0	; 00000 These 8 are 3270 disabled remote IPL disabled
	db	0	;	  In this case no additional space is used
	db	0	; 00001
	db	0
	db	0	; 00010
	db	0
	db	0	; 00011
	db	0
	db	0	; 00100
	db	0
	db	0	; 00101
	db	0
	db	0	; 00110
	db	0
	db	0	; 00111
	db	0
	db	0CEh	; 01000 These 8 are 3270 enabled remote IPL disabled
	db	2	;	in this case 3270 window at CE000-CFFFF
	db	0CEh	; 01001
	db	2	;
	db	0CEh	; 01010
	db	2	;
	db	0CEh	; 01011
	db	2
	db	0CEh	; 01100
	db	2
	db	0CEh	; 01101
	db	2
	db	0CEh	; 01110
	db	2
	db	0CEh	; 01111
	db	2
	db	0	; 10000 Invalid These 8 are 3270 disabled remote IPL
	db	0	;		enabled in this case RIPL window
	db	0	; 10001 invalid address is set
	db	0
	db	0C8h	; 10010 Mem 0C8000h-0C9FFFh
	db	2
	db	0CCh	; 10011 Mem 0CC000h-0CDFFFh
	db	2
	db	0	; 10100 invalid
	db	0
	db	0	; 10101 invalid
	db	0
	db	0D8h	; 10110 Mem 0D8000h-0D9FFFh
	db	2
	db	0DCh	; 10111 Mem 0DC000h-0DDFFFh
	db	2
	db	0CCh	; 11000 These 8 are 3270 enabled remote IPL enabled
	db	4	;	In this case RIPL window fixed at CC000-CDFFF
	db	0CCh	; 11001 3270 window fixed at CE000-CFFFF
	db	4
	db	0CCh	; 11010
	db	4
	db	0CCh	; 11011
	db	4
	db	0CCh	; 11100
	db	4
	db	0CCh	; 11101
	db	4
	db	0CCh	; 11110
	db	4
	db	0CCh	; 11111
	db	4
;
; AdapterName "IBM Token-Ring Network Adapter/A"
;
;  NOTE: THAT THIS ADAPTOR HAS 2 ENTRIES. One for RAM region, One for ROM
;	 region.
;
	dw	0E000H	; ID of IBM Token Ring card RAM
	db	00011100B
	db	2
	db	0	; Ignore POS[3]-[5]
	db	0
	db	0
	db	0
	db	0
	db	0
	dw	8	; 8 entrys
	db	0C0h	; 000 MEM 0C0000h - 0C3FFFh
	db	4
	db	0C4h	; 001 MEM 0C4000h - 0C7FFFh
	db	4
	db	0C8h	; 010 MEM 0C8000h - 0CBFFFh
	db	4
	db	0CCh	; 011 MEM 0CC000h - 0CFFFFh
	db	4
	db	0D0h	; 100 MEM 0D0000h - 0D3FFFh
	db	4
	db	0D4h	; 101 MEM 0D4000h - 0D7FFFh
	db	4
	db	0D8h	; 110 MEM 0D8000h - 0DBFFFh
	db	4
	db	0DCh	; 111 MEM 0DC000h - 0DFFFFh
	db	4


	dw	0E000H	; ID of IBM Token Ring card ROM
	db	0	; Ignore POS[2]
	db	0
	db	0	; Ignore POS[3]
	db	0
	db	00011110B
	db	1
	db	0	; Ignore POS[5]
	db	0
	dw	16	; 16 entrys
	db	0C0h	; 0000 MEM 0C0000h - 0C1FFFh
	db	2
	db	0C2h	; 0001 MEM 0C2000h - 0C3FFFh
	db	2
	db	0C4h	; 0010 MEM 0C4000h - 0C5FFFh
	db	2
	db	0C6h	; 0011 MEM 0C6000h - 0C7FFFh
	db	2
	db	0C8h	; 0100 MEM 0C8000h - 0C9FFFh
	db	2
	db	0CAh	; 0101 MEM 0CA000h - 0CBFFFh
	db	2
	db	0CCh	; 0110 MEM 0CC000h - 0CDFFFh
	db	2
	db	0CEh	; 0111 MEM 0CE000h - 0CFFFFh
	db	2
	db	0D0h	; 1000 MEM 0D0000h - 0D1FFFh
	db	2
	db	0D2h	; 1001 MEM 0D2000h - 0D3FFFh
	db	2
	db	0D4h	; 1010 MEM 0D4000h - 0D5FFFh
	db	2
	db	0D6h	; 1011 MEM 0D6000h - 0D7FFFh
	db	2
	db	0D8h	; 1100 MEM 0D8000h - 0D9FFFh
	db	2
	db	0DAh	; 1101 MEM 0DA000h - 0DBFFFh
	db	2
	db	0DCh	; 1110 MEM 0DC000h - 0DDFFFh
	db	2
	db	0DEh	; 1111 MEM 0DE000h - 0DFFFFh
	db	2
;
; AdapterName  "IBM Display Adapter 8514/A"
;
;  NOTE: that this adaptor IGNORES all the POS bytes. The 8514 adaptor memory
;	use locations are FIXED and cannot be changed.
;
;  C6800-C7FFF and CA000-CA7FF
;
;  Two entries, one for each block
;
	dw	0EF7FH	; ID of IBM 8514/A adaptor C6800-C7FFF
	db	0	; Ignore POS[2]
	db	0
	db	0	; Ignore POS[3]
	db	0
	db	0	; Ignore POS[4]
	db	0
	db	0	; Ignore POS[5]
	db	0
	dw	1	; 1 entry
	db	0C6h
	db	2

	dw	0EF7FH	; ID of IBM 8514/A adaptor CA000-CA7FF
	db	0	; Ignore POS[2]
	db	0
	db	0	; Ignore POS[3]
	db	0
	db	0	; Ignore POS[4]
	db	0
	db	0	; Ignore POS[5]
	db	0
	dw	1	; 1 entry
	db	0CAh
	db	1
;
; AdapterName  "PC Network Adapter "
;
	dw	0EFEFh	; ID of PC Network adaptor
	db	00001110b
	db	1
	db	0	; Ignore POS[3]
	db	0
	db	0	; Ignore POS[4]
	db	0
	db	0	; Ignore POS[5]
	db	0
	dw	8	; 8 entrys
	db	0	; 000 invalid
	db	0
	db	0D0h	; 001 mem 0D0000h - 0D7FFFh
	db	8
	db	0C8h	; 010 mem 0C8000h - 0CFFFFh
	db	8
	db	0D8h	; 011 mem 0D8000h - 0DFFFFh
	db	8
	db	0	; 100 invalid
	db	0
	db	0D6h	; 101 mem 0D6000h - 0D7FFFh
	db	2
	db	0CEh	; 110 mem 0CE000h - 0CFFFFh
	db	2
	db	0DEh	; 111 mem 0DE000h - 0DFFFFh
	db	2
;
; AdapterName  "3117 Scanner Adapter/A"
;
	dw	0F04FH	; ID of 3117
	db	11110000b
	db	4
	db	0	; Ignore POS[3]
	db	0
	db	0	; Ignore POS[4]
	db	0
	db	0	; Ignore POS[5]
	db	0
	dw	12	; 12 entrys (last 4 of normal 16 are invalid)
	db	0DCh	; 0000 mem 0DC000h - 0DDFFFh
	db	2
	db	0DEh	; 0001 mem 0DE000h - 0DFFFFh
	db	2
	db	0D8h	; 0010 mem 0D8000h - 0D9FFFh
	db	2
	db	0DAh	; 0011 mem 0DA000h - 0DBFFFh
	db	2
	db	0D4h	; 0100 mem 0D4000h - 0D5FFFh
	db	2
	db	0D6h	; 0101 mem 0D6000h - 0D7FFFh
	db	2
	db	0D0h	; 0110 mem 0D0000h - 0D1FFFh
	db	2
	db	0D2h	; 0111 mem 0D2000h - 0D3FFFh
	db	2
	db	0CCh	; 1000 mem 0CC000h - 0CEFFFh
	db	3
	db	0CEh	; 1001 mem 0CE000h - 0CFFFFh
	db	2
	db	0C8h	; 1010 mem 0C8000h - 0C9FFFh
	db	2
	db	0CAh	; 1011 mem 0CA000h - 0CBFFFh
	db	2
;
; AdapterName  "High Speed Adapter/A"
;
	dw	0E04EH	; ID of 3117
	db	11110000b
	db	4
	db	0	; Ignore POS[3]
	db	0
	db	0	; Ignore POS[4]
	db	0
	db	0	; Ignore POS[5]
	db	0
	dw	12	; 12 entrys (last 4 of normal 16 are invalid)
	db	0DEh	; 0000 mem 0DE000h - 0DFFFFh
	db	2
	db	0DCh	; 0001 mem 0DC000h - 0DDFFFh
	db	2
	db	0DAh	; 0010 mem 0DA000h - 0DBFFFh
	db	2
	db	0D8h	; 0011 mem 0D8000h - 0D9FFFh
	db	2
	db	0D6h	; 0100 mem 0D6000h - 0D7FFFh
	db	2
	db	0D4h	; 0101 mem 0D4000h - 0D5FFFh
	db	2
	db	0D2h	; 0110 mem 0D2000h - 0D3FFFh
	db	2
	db	0D0h	; 0111 mem 0D0000h - 0D1FFFh
	db	2
	db	0CEh	; 1000 mem 0CE000h - 0CFFFFh
	db	2
	db	0CCh	; 1001 mem 0CC000h - 0CDFFFh
	db	2
	db	0CAh	; 1010 mem 0CA000h - 0CBFFFh
	db	2
	db	0C8h	; 1011 mem 0C8000h - 0C9FFFh
	db	2
;
; AdapterName  "3119 Adapter/A"
;
	dw	0E04EH	; ID of 3117
	db	11110000b
	db	4
	db	0	; Ignore POS[3]
	db	0
	db	0	; Ignore POS[4]
	db	0
	db	0	; Ignore POS[5]
	db	0
	dw	12	; 12 entrys (last 4 of normal 16 are invalid)
	db	0DEh	; 0000 mem 0DE000h - 0DFFFFh
	db	2
	db	0DCh	; 0001 mem 0DC000h - 0DDFFFh
	db	2
	db	0DAh	; 0010 mem 0DA000h - 0DBFFFh
	db	2
	db	0D8h	; 0011 mem 0D8000h - 0D9FFFh
	db	2
	db	0D6h	; 0100 mem 0D6000h - 0D7FFFh
	db	2
	db	0D4h	; 0101 mem 0D4000h - 0D5FFFh
	db	2
	db	0D2h	; 0110 mem 0D2000h - 0D3FFFh
	db	2
	db	0D0h	; 0111 mem 0D0000h - 0D1FFFh
	db	2
	db	0CEh	; 1000 mem 0CE000h - 0CFFFFh
	db	2
	db	0CCh	; 1001 mem 0CC000h - 0CDFFFh
	db	2
	db	0CAh	; 1010 mem 0CA000h - 0CBFFFh
	db	2
	db	0C8h	; 1011 mem 0C8000h - 0C9FFFh
	db	2
;
; AdapterName "3Com EtherLink/MC Ethernet Adapter"
;
	dw	06042h	; ID
	db	00011000b
	db	3
	db	0	; Ignore POS[3]
	db	0
	db	0	; Ignore POS[4]
	db	0
	db	0	; Ignore POS[5]
	db	0
	dw	4	; 4 entrys
	db	0C0h	; 00 pos[0]=XXX00XXXb  mem 0c0000h-0C5FFFh
	db	6
	db	0C8h	; 01 pos[0]=XXX01XXXb  mem 0c8000h-0CDFFFh
	db	6
	db	0D0h	; 10 pos[0]=XXX10XXXb  mem 0d0000h-0D5FFFh
	db	6
	db	0D8h	; 11 pos[0]=XXX11XXXb  mem 0d8000h-0DDFFFh
	db	6
;
; AdapterName "ATTACHMATE - Advanced 3270 Adapter/2"
;
	dw	0677Fh	; ID
	db	0	; Ignore POS[2]
	db	0
	db	0	; Ignore POS[3]
	db	0
	db	00011111B
	db	1
	db	0	; Ignore POS[5]
	db	0
	dw	16	; 16 entrys NOTE: The low bit is the "mem disabled"
			;    bit, by rotating by one, this bit is placed in
			;    the high bit. Thus any disabled settings are
			;    "out of range" and we correctly ignore them.
	db	0C0h	; 0000 mem 0C0000h-0C1FFFh
	db	2
	db	0C2h	; 0001 mem 0C2000h-0C3FFFh
	db	2
	db	0C4h	; 0010 mem 0C4000h-0C5FFFh
	db	2
	db	0C6h	; 0011 mem 0C6000h-0C7FFFh
	db	2
	db	0C8h	; 0100 mem 0C8000h-0C9FFFh
	db	2
	db	0CAh	; 0101 mem 0CA000h-0CBFFFh
	db	2
	db	0CCh	; 0110 mem 0CC000h-0CDFFFh
	db	2
	db	0CEh	; 0111 mem 0CE000h-0CFFFFh
	db	2
	db	0D0h	; 1000 mem 0D0000h-0D1FFFh
	db	2
	db	0D2h	; 1001 mem 0D2000h-0D3FFFh
	db	2
	db	0D4h	; 1010 mem 0D4000h-0D5FFFh
	db	2
	db	0D6h	; 1011 mem 0D6000h-0D7FFFh
	db	2
	db	0D8h	; 1100 mem 0D8000h-0D9FFFh
	db	2
	db	0DAh	; 1101 mem 0DA000h-0DBFFFh
	db	2
	db	0DCh	; 1110 mem 0DC000h-0DDFFFh
	db	2
	db	0DEh	; 1111 mem 0DE000h-0DFFFFh
	db	2
;
; IBM Token-Ring Network 16/4 Adapter/A
;
;  NOTE: THAT THIS ADAPTOR HAS 2 ENTRIES. One for RAM region, One for ROM
;	 region.
;
	dw	0E001h	; ID ROM
	db	0	; Ignore POS[2]
	db	0
	db	0	; Ignore POS[3]
	db	0
	db	00011110B
	db	1
	db	0	; Ignore POS[5]
	db	0
	dw	16	; 16 entrys
	db	0C0h	; 0000 MEM 0C0000h - 0C1FFFh
	db	2
	db	0C2h	; 0001 MEM 0C2000h - 0C3FFFh
	db	2
	db	0C4h	; 0010 MEM 0C4000h - 0C5FFFh
	db	2
	db	0C6h	; 0011 MEM 0C6000h - 0C7FFFh
	db	2
	db	0C8h	; 0100 MEM 0C8000h - 0C9FFFh
	db	2
	db	0CAh	; 0101 MEM 0CA000h - 0CBFFFh
	db	2
	db	0CCh	; 0110 MEM 0CC000h - 0CDFFFh
	db	2
	db	0CEh	; 0111 MEM 0CE000h - 0CFFFFh
	db	2
	db	0D0h	; 1000 MEM 0D0000h - 0D1FFFh
	db	2
	db	0D2h	; 1001 MEM 0D2000h - 0D3FFFh
	db	2
	db	0D4h	; 1010 MEM 0D4000h - 0D5FFFh
	db	2
	db	0D6h	; 1011 MEM 0D6000h - 0D7FFFh
	db	2
	db	0D8h	; 1100 MEM 0D8000h - 0D9FFFh
	db	2
	db	0DAh	; 1101 MEM 0DA000h - 0DBFFFh
	db	2
	db	0DCh	; 1110 MEM 0DC000h - 0DDFFFh
	db	2
	db	0DEh	; 1111 MEM 0DE000h - 0DFFFFh
	db	2

	dw	0E001h	; ID RAM
	db	00011110b
	db	1
	db	00001100b
	db	6
	db	0	; Ignore POS[4]
	db	0
	db	0	; Ignore POS[5]
	db	0
	dw	57	; 57 entrys (last 7 of normal 64 are invalid)
   ;8k RAM
	db	0C0h	; 000000 MEM 0C0000h - 0C1FFFh
	db	2
	db	0C2h	; 000001 MEM 0C2000h - 0C3FFFh
	db	2
	db	0C4h	; 000010 MEM 0C4000h - 0C5FFFh
	db	2
	db	0C6h	; 000011 MEM 0C6000h - 0C7FFFh
	db	2
	db	0C8h	; 000100 MEM 0C8000h - 0C9FFFh
	db	2
	db	0CAh	; 000101 MEM 0CA000h - 0CBFFFh
	db	2
	db	0CCh	; 000110 MEM 0CC000h - 0CDFFFh
	db	2
	db	0CEh	; 000111 MEM 0CE000h - 0CFFFFh
	db	2
	db	0D0h	; 001000 MEM 0D0000h - 0D1FFFh
	db	2
	db	0D2h	; 001001 MEM 0D2000h - 0D3FFFh
	db	2
	db	0D4h	; 001010 MEM 0D4000h - 0D5FFFh
	db	2
	db	0D6h	; 001011 MEM 0D6000h - 0D7FFFh
	db	2
	db	0D8h	; 001100 MEM 0D8000h - 0D9FFFh
	db	2
	db	0DAh	; 001101 MEM 0DA000h - 0DBFFFh
	db	2
	db	0DCh	; 001110 MEM 0DC000h - 0DDFFFh
	db	2
	db	0DEh	; 001111 MEM 0DE000h - 0DFFFFh
	db	2
   ;16k RAM
	db	0C0h	; 010000 MEM 0C0000h - 0C3FFFh
	db	4
	db	0	; 010001 Invalid
	db	0
	db	0C4h	; 010010 MEM 0C4000h - 0C7FFFh
	db	4
	db	0	; 010011 Invalid
	db	0
	db	0C8h	; 010100 MEM 0C8000h - 0CBFFFh
	db	4
	db	0	; 010101 Invalid
	db	0
	db	0CCh	; 010110 MEM 0CC000h - 0CFFFFh
	db	4
	db	0	; 010111 Invalid
	db	0
	db	0D0h	; 011000 MEM 0D0000h - 0D3FFFh
	db	4
	db	0	; 011001 Invalid
	db	0
	db	0D4h	; 011010 MEM 0D4000h - 0D7FFFh
	db	4
	db	0	; 011011 Invalid
	db	0
	db	0D8h	; 011100 MEM 0D8000h - 0DBFFFh
	db	4
	db	0	; 011101 Invalid
	db	0
	db	0DCh	; 011110 MEM 0DC000h - 0DFFFFh
	db	4
	db	0	; 011111 Invalid
	db	0
   ;32k RAM
	db	0C0h	; 100000 MEM 0C0000h - 0C7FFFh
	db	8
	db	0	; 100001 Invalid
	db	0
	db	0	; 100010 Invalid
	db	0
	db	0	; 100011 Invalid
	db	0
	db	0C8h	; 100100 MEM 0C8000h - 0CFFFFh
	db	8
	db	0	; 100101 Invalid
	db	0
	db	0	; 100110 Invalid
	db	0
	db	0	; 100111 Invalid
	db	0
	db	0D0h	; 101000 MEM 0D0000h - 0D7FFFh
	db	8
	db	0	; 101001 Invalid
	db	0
	db	0	; 101010 Invalid
	db	0
	db	0	; 101011 Invalid
	db	0
	db	0D8h	; 101100 MEM 0D8000h - 0DFFFFh
	db	8
	db	0	; 101101 Invalid
	db	0
	db	0	; 101110 Invalid
	db	0
	db	0	; 101111 Invalid
	db	0
   ;64k RAM
	db	0C0h	; 110000 MEM 0C0000h - 0CFFFFh
	db	16
	db	0	; 110001 Invalid
	db	0
	db	0	; 110010 Invalid
	db	0
	db	0	; 110011 Invalid
	db	0
	db	0	; 110100 Invalid
	db	0
	db	0	; 110101 Invalid
	db	0
	db	0	; 110110 Invalid
	db	0
	db	0	; 110111 Invalid
	db	0
	db	0D0h	; 111000 MEM 0D0000h - 0DFFFFh
	db	16
;
; M003 - Start
; AdapterName "IBM Realtime Interface Co-processor Multiport/2 or X.25 /2"
;
	dw	0EFF0H	; ID of 3270 card V A
	db	0	; Ignore POS[2]
	db	0
	db	00001111B  ; Start addr
	db	0
	db	00000001B  ; > 1Meg memory select
	db	2
	db	00000011B  ; Size, 00 8K, 01 16K, 10 32K, 11 64k
	db	4
	dw	57	; All high bit set entries are > 1Meg memory configs
			;  last 7 entries of normal 64 are invalid
     ;8K
	db	0C0h	; 0000000 MEM 0C0000h - 0C1FFFh
	db	2
	db	0C2h	; 0000001 MEM 0C2000h - 0C3FFFh
	db	2
	db	0C4h	; 0000010 MEM 0C4000h - 0C5FFFh
	db	2
	db	0C6h	; 0000011 MEM 0C6000h - 0C7FFFh
	db	2
	db	0C8h	; 0000100 MEM 0C8000h - 0C9FFFh
	db	2
	db	0CAh	; 0000101 MEM 0CA000h - 0CBFFFh
	db	2
	db	0CCh	; 0000110 MEM 0CC000h - 0CDFFFh
	db	2
	db	0CEh	; 0000111 MEM 0CE000h - 0CFFFFh
	db	2
	db	0D0h	; 0001000 MEM 0D0000h - 0D1FFFh
	db	2
	db	0D2h	; 0001001 MEM 0D2000h - 0D3FFFh
	db	2
	db	0D4h	; 0001010 MEM 0D4000h - 0D5FFFh
	db	2
	db	0D6h	; 0001011 MEM 0D6000h - 0D7FFFh
	db	2
	db	0D8h	; 0001100 MEM 0D8000h - 0D9FFFh
	db	2
	db	0DAh	; 0001101 MEM 0DA000h - 0DBFFFh
	db	2
	db	0DCh	; 0001110 MEM 0DC000h - 0DDFFFh
	db	2
	db	0DEh	; 0001111 MEM 0DE000h - 0DFFFFh
	db	2
     ;16K
	db	0C0h	; 0010000 MEM 0C0000h - 0C3FFFh
	db	4
	db	0	; 0010001 Invalid
	db	0
	db	0C4h	; 0010010 MEM 0C4000h - 0C7FFFh
	db	4
	db	0	; 0010011 Invalid
	db	0
	db	0C8h	; 0010100 MEM 0C8000h - 0CBFFFh
	db	4
	db	0	; 0010101 Invalid
	db	0
	db	0CCh	; 0010110 MEM 0CC000h - 0CFFFFh
	db	4
	db	0	; 0010111 Invalid
	db	0
	db	0D0h	; 0011000 MEM 0D0000h - 0D3FFFh
	db	4
	db	0	; 0011001 Invalid
	db	0
	db	0D4h	; 0011010 MEM 0D4000h - 0D7FFFh
	db	4
	db	0	; 0011011 Invalid
	db	0
	db	0D8h	; 0011100 MEM 0D8000h - 0DBFFFh
	db	4
	db	0	; 0011101 Invalid
	db	0
	db	0DCh	; 0011110 MEM 0DC000h - 0DFFFFh
	db	4
	db	0	; 0011111 Invalid
	db	0
    ;32K
	db	0C0h	; 0100000 MEM 0C0000h - 0C7FFFh
	db	8
	db	0	; 0100001 Invalid
	db	0
	db	0	; 0100010 Invalid
	db	0
	db	0	; 0100011 Invalid
	db	0
	db	0C8h	; 0100100 MEM 0C8000h - 0CFFFFh
	db	8
	db	0	; 0100101 Invalid
	db	0
	db	0	; 0100110 Invalid
	db	0
	db	0	; 0100111 Invalid
	db	0
	db	0D0h	; 0101000 MEM 0D0000h - 0D7FFFh
	db	8
	db	0	; 0101001 Invalid
	db	0
	db	0	; 0101010 Invalid
	db	0
	db	0	; 0101011 Invalid
	db	0
	db	0D8h	; 0101100 MEM 0D8000h - 0DFFFFh
	db	8
	db	0	; 0101101 Invalid
	db	0
	db	0	; 0101110 Invalid
	db	0
	db	0	; 0101111 Invalid
	db	0
    ;64K
	db	0C0h	; 0110000 MEM 0C0000h - 0CFFFFh
	db	16
	db	0	; 0110001 Invalid
	db	0
	db	0	; 0110010 Invalid
	db	0
	db	0	; 0110011 Invalid
	db	0
	db	0	; 0110100 Invalid
	db	0
	db	0	; 0110101 Invalid
	db	0
	db	0	; 0110110 Invalid
	db	0
	db	0	; 0110111 Invalid
	db	0
	db	0D0h	; 0111000 MEM 0D0000h - 0DFFFFh
	db	16

;
; M003 - End
;


LAST ENDS
     END 

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\ps2equ.inc ===
;********************************************************************
;								    *
;   (C) Copyright MICROSOFT Corp., 1988-1991			    *
;								    *
;   MODULE:	PS2EQU.INC					    *
;								    *
;   WRITTEN BY: SUNIL PAI					    *
;								    *
;   DATE:	9/21/1987					    *
;								    *
;   PURPOSE:	TO DEFINE HARDWARE EQUATES FOR THE PS/2 MEMORY	    *
;								    *
;********************************************************************

; Micro Channel Architecture:
;
; The IBM micro channel architecture provides a number of connectors
; in which one can put expansion boards.  The programmable option
; select (POS) eliminates switches from the system board and adapters
; by replacing their function with programmable registers.  The adapters
; and system board all share I/O addresses 100h - 107h.  The system
; board POS byte (94h) and the adapter POS port (96h) control the
; device unique setup signals for all devices.
;
; POS I/O Address Space:
;
;   Address	Function
;    (hex)
;
;   0094	System Board Enable / Setup
;   0095	Reserved
;   0096	Adapter Enable / Setup
;   0097	Reserved
;   0100	POS Reg. 0 - Adapter ID byte (LSB)
;   0101	POS Reg. 1 - Adapter ID byte (MSB)
;   0102	POS Reg. 2 - Option Select Data Byte 1 ( bit 0 is card enable )
;   0103	POS Reg. 3 - Option Select Data Byte 2
;   0104	POS Reg. 4 - Option Select Data Byte 3
;   0105	POS Reg. 5 - Option Select Data Byte 4
;   0106	POS Reg. 6 - Subaddress Extension (LSB)
;   0107	POS Reg. 7 - Subaddress Extension (MSB)
;
;
; SYSTEM BOARD POS BYTE (94h):
;
;     ---------------------------------
;     | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
;     ---------------------------------
;	|   |	|   |	|   |	|   |
;	|   |	|   -----------------------Reserved
;	|   |	|
;	|   |	---------------------------VGA +Enbl/-Setup
;	|   |
;	|   -------------------------------Reserved
;	|
;	--------------------------- -------System Board Functions +Enbl/-Setup
;
    ;
    ; System POS Port
    ;
    SYSTEM_POS	EQU	094h
    ;
	;
	; equates for this byte
	;
	VGA_ENB    equ     20h
	VGA_SET    equ	   NOT VGA_ENB
	;
	SYS_ENB    equ     80h
	SYS_SET    equ	   NOT SYS_ENB
;
;
;   ADAPTER POS BYTE (96h):
;
;		  ---------------------------------
;   Channel Sel.  | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
;   for setup	  ---------------------------------
;
;	None	    0	0   0	0   0	X   X	X
;	 1	    0	0   0	0   1	0   0	0
;	 2	    0	0   0	0   1	0   0	1
;	 3	    0	0   0	0   1	0   1	0
;	 4	    0	0   0	0   1	0   1	1
;	 5	    0	0   0	0   1	1   0	0
;	 6	    0	0   0	0   1	1   0	1
;	 7	    0	0   0	0   1	1   1	0
;	 8	    0	0   0	0   1	1   1	1
;   channel reset   1	0   0	0   X	X   X	X
;
;   Each channel has a unique setup line (-CD SETUP) associated with it.
;   Prior to a setup cycle, an I/O operation to port hex 0096h sets up
;   the bit pattern to select the the channel position to which the
;   subsequent setup operation will occur.
;
;   NOTE: The status of port hex 0096 can be read by software. However bits
;	  4, 5 and 6 will be read as 1
    ;
    ; Adapter POS Port
    ;
    ADAPTER_POS EQU	096h
    ;
	;
	; equates for this byte
	;
	ADAPTER_DSB	    equ	    0
	ADAPTER_ENB	    equ     08h
	ADAPTER_POS_MASK    equ     NOT ADAPTER_ENB
	CHANNEL_MASK	    equ     07h
;
;
;   FOR SYSTEM BOARD SETUP:
;
;	1) Port hex 0094 bit 7 must be 0 for setup of system board functions
;	   other than VGA.
;
;	2) Port hex 0094 bit 5 must be 1 to avoid driving a setup to the VGA
;
;	3) Port hex 0096 bit 3 must be 0 to avoid driving a setup to an adapter
;
;   FOR ADAPTER SETUP:
;
;	1) Port hex 0094 bit 7 must be 1 to avoid a setup to system board
;	   functions.
;
;	2) Port hex 0094 bit 5 must be 1 to avoid a setup to the VGA.
;
;	3) Port hex 0096 bit 3 must be 1 for adapter setup with I/O addresses
;	   100h - 107h.
;
;
;   NOTE:
;
;   In our case the only system board setup we shall need to do is disable
;   the system 1M of system board memory. This is done by a command to bit
;   0 of port 103h. To disable memory this should be set to 0 and to enable
;   memory it should be set to 1.
;
	SYS_MEM_CONT	equ	103h
	SYS_MEM_BIT	equ	01B
	SYS_MEM_DSB	equ	NOT 01B
;
; The PMeM:
;
;   Has 2MB of additional dyanamic random access memory. Four banks
;   of special sockets hold 256K X 9 memory SIPs.
;
;   The PMeM features Enhanced Dynamic Memory Relocation which provides
;   the user with the ability to map any 16K physical segment of PMeM
;   memory into any 16K segment of the 16M system memory space.
;						 -------------
;		 (Translation RAM)    -----------|	     |---- Select one
;		  ---------------    |		 | DEMUX     | ... of 4 banks
;  A23 -----------|A9	      D7|-----	   BS0-2 |	     |----
;	    10	  |	TRAM	|	 --------|------------
;  A14 -----------|A0  (1X8K) D0|-----	 |
;		  ---------------    |	 --------} The upper five address bits
;				     |	   A14-18} select one of the 32 16K
;				     ------------} pages. The lower 14 bits
;  A13-------------------------------------------} select offset within this
;					   A0-13 } segment
;  A0 -------------------------------------------}
;
;   The PMeM is on an adapter board accessible through the programmmable select
;   option registers (100h - 107h).  The board can be setup only when the
;   CD/SETUP line to the connector, on which this board is installed, is
;   active.  This can be activated by selecting adapter setup and indicating
;   which connector we want to examine / change.  The ports to do these are
;   ports 94h and 96h.
;
;
;
; Port addresses for PMeM memory
;
    ;
    ; 1. Card ID ADDR
    ;
    ID_ADDR	EQU	100H
    ID_ADDR_LO  EQU	ID_ADDR
    ID_ADDR_HI	EQU	ID_ADDR+1
	    ;
	    ; ID FOR PMeM CARD
	    ;
	    MEM_ID_LO	EQU 0FEH
	    MEM_ID_HI	EQU 0FEH
	    ;
    ;
    ; The ID is guaranteed to be unique.
    ;
    ;
    ;
    ; 2. CONFIG PORT
    ;
    ;	---------------------------------
    ;	| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | 102H
    ;	---------------------------------
    ;	  |   |   |   |   |   |   |   |----------Sleep Bit 0 - sleeping
    ;	  |   |   |   |   |   |   |			   1 - awake	(R/W)
    ;	  |   |   |   |   |   |   |
    ;	  |   |   |   |   |   |   ---------------Bank 0 Presc. Det2 (R)
    ;	  |   |   |   |   |   |
    ;	  |   |   |   |   |   -------------------Bank 1 Presc. Det1 (R)
    ;	  |   |   |   |   -----------------------Bank 1 Presc. Det2 (R)
    ;	  |   |   |   |
    ;	  |   |   |   ---------------------------Bank 2 Presc. Det1 (R)
    ;	  |   |   -------------------------------Bank 2 Presc. Det2 (R)
    ;	  |   |
    ;	  |   -----------------------------------Bank 3 Presc. Det1 (R)
    ;	  ---------------------------------------Bank 3 Presc. Det2 (R)
    ;
    ;	The procedure to check the prescence of a bank is to check for the
    ;	logical or of both the bits set aside for the particular bank. If
    ;	this value is one then we conclude that the bank is present.  Also
    ;	during configuration or reconfiguration we should either exclude
    ;	interrupts or put the board to sleep.  After this process is over
    ;	we can awaken the board.
    ;
    CONF_ADDR	EQU	ID_ADDR + 2
    ;
	    ;
	    ; STATUS BIT EQUATES
	    ;
	    AWAKE   EQU     1H
	    SLEEP   EQU     NOT AWAKE
	    ;
	    BANK0_PR	EQU 00000010B
	    BANK1_PR	EQU 00001100B
	    BANK2_PR	EQU 00110000B
	    BANK3_PR	EQU 11000000B
    ;
    ;
    ; 3. DATA PORT
    ;
    TRAM_DATA	EQU	ID_ADDR + 3
    ;
    ;
    ;	The TRAM Decoder output is used as the following:
    ;
    ;	---------------------------------
    ;	| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    ;	---------------------------------
    ;	  |   |   |   | 	      |
    ;	  |   -----   -----------------
    ;	  |	|	     |
    ;	  |	|	     --------------------------- Page Select (1 of 32)
    ;	  |	|
    ;	  |	---------------------------------------- Bank Select (1 0f 4)
    ;	  |
    ;	  ---------------------------------------------- Enble Bit,0 - PMeM not
    ;							 accessed,1 - PMeM accessed
    ;
    ;
    ;	Using this will be described in the discussion for the next two ports
    ;
	;
	; Equates for enable bit
	;
	TRAM_ENB    EQU 80H
	TRAM_DSB    EQU NOT TRAM_ENB
	;
    ;
    ;
    ; 4. TRAM ADDR PORTS
    ;
    ;	The TRAM is RAM with 10 address pin input.  To initialise the TRAM
    ;	we have to first specify the address of the TRAM location we are
    ;	going to initialise or change.	This is done by outputting the low
    ;	byte of the address to port 106H and then the high byte to address
    ;	107H.  The data at this address can then be output to the TRAM_DATA
    ;	port at 103H according to the values decided by the mapping desired
    ;	and the bit assignment of the TRAM decoder as given in the diagram
    ;	above.
    ;
    TRAM_ADDR	    EQU ID_ADDR + 6
    TRAM_ADDR_LO    EQU TRAM_ADDR
    TRAM_ADDR_HI    EQU TRAM_ADDR + 1
    ;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\segend.asm ===
PAGE	, 132
.386p
;******************************************************************************
;
; (C) Copyright MICROSFT Computer Corp. 1989-1991
; (C) Copyright COMPAQ Computer Corp. 1989-1991
;
; Title:	EMM386.EXE - MICROSOFT Expanded Memory Manager 386
;
; Module:	SEGEND.ASM - For defining the end location of the segments
;
; Version:	0.01
;
; Date:		January 18, 1989
;
; Author:	Daniel J. Mazina
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;	      Original
;******************************************************************************

;******************************************************************************
; PUBLICS
;******************************************************************************
public	register_set

;******************************************************************************
; INCLUDES
;******************************************************************************
include	vdmseg.inc
include emmfunct.inc

; The following label definitions are used for locating the ends of the various
; CEMM segments.  This is needed so that CEMM can move individual segments up
; into extended memory or the ROM space easily.  This module must be linked in
; last to insure that these labels occur at the end.

	; This is the code that must remain in the lower 640k of memory.
public	end_of_R_CODE
R_CODE	segment
	end_of_R_CODE	label	byte
R_CODE	ends

	; This is the code that must remain in the lower 640k of memory.
public	end_of_R_STACK
R_STACK segment
	end_of_R_STACK	label	byte
R_STACK	ends

public	end_of_R1_CODE
R1_CODE	segment
	end_of_R1_CODE	label	byte
R1_CODE	ends


	; This used for the common protected mode data area.
public	end_of_DATA
_DATA		segment
	ASSUME	cs:_DATA,ds:_DATA

register_set	label	word
	RegisterSet_struc	<>

	end_of_DATA	label	byte
_DATA		ends

	; This used for the ring zero stack frame.
public	end_of_STACK
STACK	segment
	end_of_STACK	label	byte
STACK	ends

	; This used for the common protected mode code area.
public	end_of_TEXT
_TEXT	segment
	end_of_TEXT	label	byte
_TEXT	ends

	; This is used for the initialization code that gets overlaid.
public	end_of_LAST
LAST	segment
	end_of_LAST	label	byte
LAST	ends

	; This is the code that must remain in the lower 640k of memory.
public	end_of_L_STACK
L_STACK segment
	end_of_L_STACK	label	byte
L_STACK	ends

END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\ps2ex.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;
;   Title:    PS2EX.INC Emm386 memory manager
;
;   Module:   PS2EX.INC - Equates and structs for PS/2 adaptor Exclusion
;
;   Version:  0.00
;
;   Date:     7/27/88
;
;   Author: ARR
;
;   Note: Ported from win386 3.0 sources.
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   07/27/88  0.00
;
;******************************************************************************

;
; Maximum number of cards in a PS/2
;
MAX_CARDS	equ	8

;
; Maximum size of the WIN386 PS/2 adaptor exclude file (win386.ps2)
;
MAXPS2EXFILESZ	equ	8192

;
; Structure of the PS2DATA in ps2table.asm
;
POSCardTable   struc
	TotalOptions	dw	?	; Number of entries
	TabelRev	dw	?	; REV of table definition
	OptionTables	db	?	; Start of OptionStruc structures
POSCardTable   ends

;
; Current value of TabelRev
;
CUR_PS2_TABLE_REV equ	0001h

;
;	    This table describes how to convert the adaptor specific POS
;	    bytes into the list of pages in the SegArray to mark as used
;	    for this adaptor:
;
;	     LookUpPTR = LookUpTab;
;	     SegPTR = pSegArray;
;	     index  = (POS2Byte & POS2Mask) >> POS2Shft;
;	     index |= (POS3Byte & POS3Mask) >> POS3Shft;
;	     index |= (POS4Byte & POS4Mask) >> POS4Shft;
;	     index |= (POS5Byte & POS5Mask) >> POS5Shft;
;	     if(index < LookUpCnt) {
;		LookUpPTR += index;
;		SegPtr += LookUpPTR->StartAddr;
;		for(i=0;i<LookUpPTR->PGLen;i++)
;			*SegPtr++=1;
;	     }
;
;	     POS bytes to be ignored are indicated by POSnMask = POSnShft = 0.
;	     Invalid index values should set StartAddr = PGLen = 0.
;
;	     NOTE to support adaptors with multiple discontiguous memory use
;	     blocks, make more than one entry for the card ID
OptionStruc struc
	OptID	    dw	    ?	    ; 16 bit adaptor ID
	POS2Mask    db	    ?
	POS2Shft    db	    ?
	POS3Mask    db	    ?
	POS3Shft    db	    ?
	POS4Mask    db	    ?
	POS4Shft    db	    ?
	POS5Mask    db	    ?
	POS5Shft    db	    ?
	LookUpCnt   dw	    ?	    ; Number of entries following
	LookUpTab   db	    ?	    ; start of MemAddr Structures
OptionStruc ends

MemAddr struc
	StartPg     db	    ?	    ; 0 based 4K page number of first
				    ;	4k page occupied by adaptor.
	PGLen	    db	    ?	    ; Number of 4K pages occupied
				    ;	(May be 0).
MemAddr ends

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\tabdef.asm ===
.386p
page	58,132
;******************************************************************************
	title	TABDEF.ASM - 386 Protected Mode CPU Tables
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
;   Module:   TABDEF.ASM - 386 Protected Mode CPU Tables
;
;   Version:  2.00
;
;   Date:     January 31, 1986
;
;   Author:
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   01/31/86  A. Short	Tables for Standalone protected mode system
;	      A-WCC	Modified for Virtual DOS
;   05/12/86  B-RRH	Cleanup and segment reorganization
;   06/28/86  0.02	Name changed from CEMM386 to CEMM (SBP).
;   07/05/86  0.04	Moved KBD and PRINT to DCODE segment (SBP).
;   05/08/87  2.00	Added selectors for RCODE_GSEL and RSS_GSEL (SBP).
;   10/12/88  3.32 (*D) Add VCPI code (DJM).
;   08/23/89  4.10	Add DEB386 support & PAGED_GSEL (LC)
;
;******************************************************************************
;
;   Functional Description:
;
;******************************************************************************
.lfcond 				; list false conditionals

NAME	tabdef
;

.xlist
	include VDMseg.inc
	include VDMsel.inc
	include desc.inc
	include page.inc
.list


ifdef	BugMode
DCODE	SEGMENT
	extrn	kputc:far
	extrn	kgetc:far
DCODE	ENDS
endif

_TEXT SEGMENT
	extrn	ExceptHandler0:far
	extrn	ExceptHandler1:far
	extrn	ExceptHandler2:far
	extrn	ExceptHandler3:far
	extrn	ExceptHandler4:far
	extrn	ExceptHandler5:far
	extrn	ExceptHandler6:far
	extrn	ExceptHandler7:far
	extrn	ExceptHandler8:far
	extrn	ExceptHandler9:far
	extrn	ExceptHandler10:far
	extrn	ExceptHandler11:far
	extrn	ExceptHandler12:far
	extrn	ExceptHandler13:far
	extrn	ExceptHandler14:far
	extrn	ExceptHandler15:far
	extrn	ExceptHandler16:far
	extrn	ExceptHandler17:far

	extrn	EMM_pEntry:far
	extrn	pINT13hHandler:far
	extrn	pINT15hHandler:far
	extrn	pTrapHandler:far
	extrn	pINT4BhHandler:far

	extrn	pINT25hHandler:far
	extrn	pINT26hHandler:far
	extrn	pINT2ahHandler:far
	extrn	pINT2fhHandler:far
	extrn	pINT33hHandler:far
	extrn	pINT5chHandler:far

_TEXT ENDS


;***	GDT - Global Descriptor Table
;
;	This is the system GDT. Some parts are statically initialised,
;	others must be set up at run time, either because masm can't
;	calculate the data or it changes while the system is running.
;
;	WARNING
;
;	Don't change this without consulting "sel.inc", and the
;	routines which initialise the gdt.
;

GDT SEGMENT

gdtstart	label byte	; label for everyone to refer to the GDT

GDT_ENTRY	0, 0, 1, 0			; null selector
GDT_ENTRY	0, 0, 0, D_DATA0		; GDT alias
GDT_ENTRY	0, 0, 0, D_DATA0		; IDT alias
GDT_ENTRY	0, 0, 0, D_LDT0 		; LDT
GDT_ENTRY	0, 0, 0, D_DATA0		; LDT alias
GDT_ENTRY	0, 0, 0, D_386TSS0		; TSS
GDT_ENTRY	0, 0, 0, D_DATA0		; TSS alias
GDT_ENTRY	0, 0, <400h>, D_DATA3		; Real Mode IDT
GDT_ENTRY	400h, 0, 0, D_DATA0		; ROM Data
GDT_ENTRY	0, 0, 0, D_CODE0		; VDM Code
GDT_ENTRY	0, 0, 0, D_DATA0		; VDM Data
GDT_ENTRY	0, 0, 0, D_DATA0		; VDM Stack
GDT_ENTRY	0, 0bh, 1000h, D_DATA0		; Mono Display
GDT_ENTRY	8000h, 0bh, 4000h, D_DATA0	; Colour Disp
GDT_ENTRY	0, 0ah, 0, D_DATA0		; EGA Low
GDT_ENTRY	0, 0ch, 0, D_DATA0		; EGA High
	db	0FFh,0FFh,0,0,0,D_DATA0,0CFh,0	; DATA32 - large linear addr
GDT_ENTRY	0, 0, 0, 0			; debugger work
GDT_ENTRY	0, 0, 0, 0			; debugger work
GDT_ENTRY	0, 0, 0, 0			; debugger work
GDT_ENTRY	0, 0, 0, 0			; debugger work
ifndef	BugMode
GDT_ENTRY	0, 0, 0, 0			; general work
GDT_ENTRY	0, 0, 0, 0			; general work
else
IDT_ENTRY	DEBC_GSEL, <offset DCODE:kputc>, D_GATE3 ; call gate
IDT_ENTRY	DEBC_GSEL, <offset DCODE:kgetc>, D_GATE3 ; call gate
endif
GDT_ENTRY	0, 0, 0, D_CODE0		; R_CODE code segment selector
GDT_ENTRY	0, 0, 0, D_DATA0		; R_CODE data alias
GDT_ENTRY	0, 0, 0, D_DATA0		; real mode SS alias
GDT_ENTRY	0, 0, 0, D_DATA0		; VM1_GSEL - vm trap scratch
GDT_ENTRY	0, 0, 0, D_DATA0		; VM2_GSEL - vm trap scratch
GDT_ENTRY	0, 0, 0, D_DATA0		; MBSRC_GSEL - move blk scratch
GDT_ENTRY	0, 0, 0, D_DATA0		; MBTAR_GSEL - move blk scratch
GDT_ENTRY	0, 0, 0, D_DATA0		; PAGET_GSEL - page table area
GDT_ENTRY	0, 0, 0, D_DATA0		; VDM Code - Data Alias
GDT_ENTRY	0, 0, 0, D_DATA0		; EMM1 - EMM scratch selector
GDT_ENTRY	0, 0, 0, D_DATA0		; EMM2 - EMM scratch selector
GDT_ENTRY	0, 0, 0, D_DATA0		; extra entry
GDT_ENTRY	0, 0, 0, D_DATA0		; PAGED_GSEL page directory ;LEO
GDT_ENTRY	0, 0, 0, D_DATA0		; RMS_GSEL small protected mode base stack
GDT_ENTRY	0, 0, 0, D_CODE0		; R1CODE_GSEL - code selector
GDT_ENTRY	0, 0, 0, D_DATA0		; R1CODEA_GSEL - data selector
ifndef BugMode
GDT_ENTRY	0, 0, 0, 0			; debugger work 1
GDT_ENTRY	0, 0, 0, 0			; debugger work	2
GDT_ENTRY	0, 0, 0, 0			; debugger work	3
GDT_ENTRY	0, 0, 0, 0			; debugger work	4
GDT_ENTRY	0, 0, 0, 0			; debugger work	5
GDT_ENTRY	0, 0, 0, 0			; debugger work	(Addresses all memory)
endif
	public	GDTLEN
GDTLEN		equ	$ - gdtstart

GDT ENDS

ifdef TSSQLEO

;***	TSS for protected Mode
;
;	This is the VDM TSS. We only use one, for loading
;	SS:SP on privilige transitions. We don't use all
;	the 286 task switching stuff.
;
;

TSS	segment
;
	TssArea 	TSS386STRUC	<>
;
;   I/O Bit Map for Virtual Mode I/O trapping
;
	public	IOBitMap
IOBitMap	label	byte
	db	2000h dup (0)		; initialize all ports to NO trapping
	db	0FFh			; last byte is all 1's

	public	TSSLEN
TSSLEN		equ	$ - tss

TSS	ends
endif

;***	IDT for protected mode
;
;   This is the protected mode interrupt descriptor table.
;
;   The first 78h entries are defined.	Only processor exceptions and
;   hardware interrupts are fielded through the PM IDT.  Since the
;   gate DPLs are < 3, all software INTs are funneled through INT 13
;   (GP exception) and emulated.   Note that Null IDT entries and limit
;   exceptions produce the same results (GP error code) as DPL faults,
;   so we can use a truncated IDT.  This assumes no one is reprogramming
;   the 8259s base vector for some reason - don't know of any DOS apps
;   that do this.
;
IDT SEGMENT

idtstart	label byte

IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler0>,D_386INT0 ; 00 Divide Error
ifndef	BugMode
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler1>,D_386INT0 ; 01 Debug
else
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler1>,D_386INT3 ; 01 Debug
endif
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler2>,D_386INT0 ; 02 NMI/287 Error
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler3>,D_386INT0 ; 03 Breakpoint
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler4>,D_386INT0 ; 04 INTO
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler5>,D_386INT0 ; 05 BOUND/Print Screen
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler6>,D_386INT0 ; 06 Invalid Opcode
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler7>,D_386INT0 ; 07 287 Not Available

IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler8>,D_386INT0 ; 08 Double Exception
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler9>,D_386INT0 ; 09 (not on 386)
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler10>,D_386INT0 ; 0A Invalid TSS
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler11>,D_386INT0 ; 0B Segment Not Present
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler12>,D_386INT0 ; 0C Stack Fault
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler13>,D_386INT0 ; 0D General Protection
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler14>,D_386INT0 ; 0E Page Fault
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler15>,D_386INT0 ; 0F Intel Reserved

IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler16>,D_386INT0 ; 10 Coprocessor error
;LEO IDT_ENTRY	0, 0, 0 		; 10 [287 Error]/Video INT (This exception
					;    cannot occur on AT/Explorer architecture)
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:ExceptHandler17>,D_386INT0 ; 11 Equipment Check
;LEO IDT_ENTRY	0, 0, 0 		; 11 Equipment Check
IDT_ENTRY	0, 0, 0 		; 12 Memory Size
IDT_ENTRY VDMC_GSEL,<offset _TEXT:pINT13hHandler>,D_386INT3 ; 13 Disk INT  ;LEO
IDT_ENTRY	0, 0, 0 		; 14 RS232
IDT_ENTRY VDMC_GSEL,<offset _TEXT:pINT15hHandler>,D_386INT3 ; 15 MoveBlock,Post&Wait,MP
IDT_ENTRY	0, 0, 0 		; 16 Keyboard
IDT_ENTRY	0, 0, 0 		; 17 Printer

IDT_ENTRY	0, 0, 0 		; 18 Resident BASIC
IDT_ENTRY	0, 0, 0 		; 19 Bootstrap
IDT_ENTRY	0, 0, 0 		; 1A Time of Day
IDT_ENTRY	0, 0, 0 		; 1B Break
IDT_ENTRY	0, 0, 0 		; 1C Timer Tick
IDT_ENTRY	0, 0, 0 		; 1D Ptr to Video Param
IDT_ENTRY	0, 0, 0 		; 1E Ptr to Disk Params
IDT_ENTRY	0, 0, 0 		; 1F Ptr to Graphics

IDT_ENTRY	0, 0, 0 		; 20 DOS
IDT_ENTRY	0, 0, 0 		; 21 DOS
IDT_ENTRY	0, 0, 0 		; 22 DOS
IDT_ENTRY	0, 0, 0 		; 23 DOS
IDT_ENTRY	0, 0, 0 		; 24 DOS

;;IDT_ENTRY	0, 0, 0 		; 25 DOS
IDT_ENTRY VDMC_GSEL,<offset _TEXT:pINT25hHandler>,D_386INT3 ; ABS disk read

;;IDT_ENTRY	0, 0, 0 		; 26 DOS
IDT_ENTRY VDMC_GSEL,<offset _TEXT:pINT26hHandler>,D_386INT3 ; ABS disk write

IDT_ENTRY	0, 0, 0 		; 27 DOS

IDT_ENTRY	0, 0, 0 		; 28 DOS
IDT_ENTRY	0, 0, 0 		; 29 DOS

;;IDT_ENTRY	0, 0, 0 		; 2A DOS
IDT_ENTRY VDMC_GSEL,<offset _TEXT:pINT2ahHandler>,D_386INT3 ; LM

IDT_ENTRY	0, 0, 0 		; 2B DOS
IDT_ENTRY	0, 0, 0 		; 2C DOS
IDT_ENTRY	0, 0, 0 		; 2D DOS
IDT_ENTRY	0, 0, 0 		; 2E DOS

;;IDT_ENTRY	0, 0, 0 		; 2F ELIM
IDT_ENTRY VDMC_GSEL,<offset _TEXT:pINT2fhHandler>,D_386INT3 ; LM

IDT_ENTRY	0, 0, 0 		; 30 DOS
IDT_ENTRY	0, 0, 0 		; 31 DOS
IDT_ENTRY	0, 0, 0 		; 32 DOS

;;IDT_ENTRY	0, 0, 0 		; 33 DOS
IDT_ENTRY VDMC_GSEL,<offset _TEXT:pINT33hHandler>,D_386INT3 ; mouse

IDT_ENTRY	0, 0, 0 		; 34 DOS
IDT_ENTRY	0, 0, 0 		; 35 DOS
IDT_ENTRY	0, 0, 0 		; 36 DOS
IDT_ENTRY	0, 0, 0 		; 37 DOS

IDT_ENTRY	0, 0, 0 		; 38 DOS
IDT_ENTRY	0, 0, 0 		; 39 DOS
IDT_ENTRY	0, 0, 0 		; 3A DOS
IDT_ENTRY	0, 0, 0 		; 3B DOS
IDT_ENTRY	0, 0, 0 		; 3C DOS
IDT_ENTRY	0, 0, 0 		; 3D DOS
IDT_ENTRY	0, 0, 0 		; 3E DOS
IDT_ENTRY	0, 0, 0 		; 3F DOS

IDT_ENTRY	0, 0, 0 		; 40 Reserved
IDT_ENTRY	0, 0, 0 		; 41 Reserved
IDT_ENTRY	0, 0, 0 		; 42 Reserved
IDT_ENTRY	0, 0, 0 		; 43 Reserved
IDT_ENTRY	0, 0, 0 		; 44 Reserved
IDT_ENTRY	0, 0, 0 		; 45 Reserved
IDT_ENTRY	0, 0, 0 		; 46 Reserved
IDT_ENTRY	0, 0, 0 		; 47 Reserved

IDT_ENTRY	0, 0, 0 		; 48 Reserved
IDT_ENTRY	0, 0, 0 		; 49 Reserved
IDT_ENTRY	0, 0, 0 		; 4A Reserved
IDT_ENTRY VDMC_GSEL,<offset _TEXT:pINT4BhHandler>,D_386INT3 ; 4B: DMAserv  ;LEO
IDT_ENTRY	0, 0, 0 		; 4C Reserved
IDT_ENTRY	0, 0, 0 		; 4D Reserved
IDT_ENTRY	0, 0, 0 		; 4E Reserved
IDT_ENTRY	0, 0, 0 		; 4F Reserved

IDT_ENTRY	0, 0, 0 		; 50 Reserved
IDT_ENTRY	0, 0, 0 		; 51 Reserved
IDT_ENTRY	0, 0, 0 		; 52 Reserved
IDT_ENTRY	0, 0, 0 		; 53 Reserved
IDT_ENTRY	0, 0, 0 		; 54 Reserved
IDT_ENTRY	0, 0, 0 		; 55 Reserved
IDT_ENTRY	0, 0, 0 		; 56 Reserved
IDT_ENTRY	0, 0, 0 		; 57 Reserved
IDT_ENTRY	0, 0, 0 		; 58 Reserved
IDT_ENTRY	0, 0, 0 		; 59 Reserved
IDT_ENTRY	0, 0, 0 		; 5A Reserved
IDT_ENTRY	0, 0, 0 		; 5B Reserved

;;IDT_ENTRY	0, 0, 0 		; 5C Reserved
IDT_ENTRY VDMC_GSEL,<offset _TEXT:pINT5chHandler>,D_386INT3 ; LM

IDT_ENTRY	0, 0, 0 		; 5D Reserved
IDT_ENTRY	0, 0, 0 		; 5E Reserved
IDT_ENTRY	0, 0, 0 		; 5F Reserved

IDT_ENTRY	0, 0, 0 		; 60 User Programs
IDT_ENTRY	0, 0, 0 		; 61 User Programs
IDT_ENTRY	0, 0, 0 		; 62 User Programs
IDT_ENTRY	0, 0, 0 		; 63 User Programs
IDT_ENTRY	0, 0, 0 		; 64 User Programs
IDT_ENTRY	0, 0, 0 		; 65 User Programs
IDT_ENTRY	0, 0, 0 		; 66 User Programs
IDT_ENTRY	VDMC_GSEL,<offset _TEXT:EMM_pEntry>,D_386INT3 ; 67 ELIM

IDT_ENTRY	0, 0, 0 		; 68 Not Used
IDT_ENTRY	0, 0, 0 		; 69 Not Used
IDT_ENTRY	0, 0, 0 		; 6A Not Used
IDT_ENTRY	0, 0, 0 		; 6B Not Used
IDT_ENTRY	0, 0, 0 		; 6C Not Used
IDT_ENTRY	0, 0, 0 		; 6D Not Used
IDT_ENTRY	0, 0, 0 		; 6E Not Used
IDT_ENTRY	0, 0, 0 		; 6F Not Used

;
;  The following table entries extend the IDT to cover the full 256 possible
;  IDT entries.  This is provided for the VCPI interface since it allows the
;  remapping of the 8259 chips to any vector.
;

IDT_ENTRY	0, 0, 0 		; 70h
IDT_ENTRY	0, 0, 0 		; 71h
IDT_ENTRY	0, 0, 0 		; 72h
IDT_ENTRY	0, 0, 0 		; 73h
IDT_ENTRY	0, 0, 0 		; 74h
IDT_ENTRY	0, 0, 0 		; 75h
IDT_ENTRY	0, 0, 0 		; 76h
IDT_ENTRY	0, 0, 0 		; 77h
IDT_ENTRY	0, 0, 0 		; 78h
IDT_ENTRY	0, 0, 0 		; 79h
IDT_ENTRY	0, 0, 0 		; 7Ah
IDT_ENTRY	0, 0, 0 		; 7Bh
IDT_ENTRY	0, 0, 0 		; 7Ch
IDT_ENTRY	0, 0, 0 		; 7Dh
IDT_ENTRY	0, 0, 0 		; 7Eh
IDT_ENTRY	0, 0, 0 		; 7Fh

IDT_ENTRY	0, 0, 0 		; 80h
IDT_ENTRY	0, 0, 0 		; 81h
IDT_ENTRY	0, 0, 0 		; 82h
IDT_ENTRY	0, 0, 0 		; 83h
IDT_ENTRY	0, 0, 0 		; 84h
IDT_ENTRY	0, 0, 0 		; 85h
IDT_ENTRY	0, 0, 0 		; 86h
IDT_ENTRY	0, 0, 0 		; 87h
IDT_ENTRY	0, 0, 0 		; 88h
IDT_ENTRY	0, 0, 0 		; 89h
IDT_ENTRY	0, 0, 0 		; 8Ah
IDT_ENTRY	0, 0, 0 		; 8Bh
IDT_ENTRY	0, 0, 0 		; 8Ch
IDT_ENTRY	0, 0, 0 		; 8Dh
IDT_ENTRY	0, 0, 0 		; 8Eh
IDT_ENTRY	0, 0, 0 		; 8Fh

IDT_ENTRY	0, 0, 0 		; 90h
IDT_ENTRY	0, 0, 0 		; 91h
IDT_ENTRY	0, 0, 0 		; 92h
IDT_ENTRY	0, 0, 0 		; 93h
IDT_ENTRY	0, 0, 0 		; 94h
IDT_ENTRY	0, 0, 0 		; 95h
IDT_ENTRY	0, 0, 0 		; 96h
IDT_ENTRY	0, 0, 0 		; 97h
IDT_ENTRY	0, 0, 0 		; 98h
IDT_ENTRY	0, 0, 0 		; 99h
IDT_ENTRY	0, 0, 0 		; 9Ah
IDT_ENTRY	0, 0, 0 		; 9Bh
IDT_ENTRY	0, 0, 0 		; 9Ch
IDT_ENTRY	0, 0, 0 		; 9Dh
IDT_ENTRY	0, 0, 0 		; 9Eh
IDT_ENTRY	0, 0, 0 		; 9Fh
IDT_ENTRY	0, 0, 0 		; A0h
IDT_ENTRY	0, 0, 0 		; A1h
IDT_ENTRY	0, 0, 0 		; A2h
IDT_ENTRY	0, 0, 0 		; A3h
IDT_ENTRY	0, 0, 0 		; A4h
IDT_ENTRY	0, 0, 0 		; A5h
IDT_ENTRY	0, 0, 0 		; A6h
IDT_ENTRY	0, 0, 0 		; A7h
IDT_ENTRY	0, 0, 0 		; A8h
IDT_ENTRY	0, 0, 0 		; A9h
IDT_ENTRY	0, 0, 0 		; AAh
IDT_ENTRY	0, 0, 0 		; ABh
IDT_ENTRY	0, 0, 0 		; ACh
IDT_ENTRY	0, 0, 0 		; ADh
IDT_ENTRY	0, 0, 0 		; AEh
IDT_ENTRY	0, 0, 0 		; AFh
IDT_ENTRY	0, 0, 0 		; B0h
IDT_ENTRY	0, 0, 0 		; B1h
IDT_ENTRY	0, 0, 0 		; B2h
IDT_ENTRY	0, 0, 0 		; B3h
IDT_ENTRY	0, 0, 0 		; B4h
IDT_ENTRY	0, 0, 0 		; B5h
IDT_ENTRY	0, 0, 0 		; B6h
IDT_ENTRY	0, 0, 0 		; B7h
IDT_ENTRY	0, 0, 0 		; B8h
IDT_ENTRY	0, 0, 0 		; B9h
IDT_ENTRY	0, 0, 0 		; BAh
IDT_ENTRY	0, 0, 0 		; BBh
IDT_ENTRY	0, 0, 0 		; BCh
IDT_ENTRY	0, 0, 0 		; BDh
IDT_ENTRY	0, 0, 0 		; BEh
IDT_ENTRY	0, 0, 0 		; BFh
IDT_ENTRY	0, 0, 0 		; C0h
IDT_ENTRY	0, 0, 0 		; C1h
IDT_ENTRY	0, 0, 0 		; C2h
IDT_ENTRY	0, 0, 0 		; C3h
IDT_ENTRY	0, 0, 0 		; C4h
IDT_ENTRY	0, 0, 0 		; C5h
IDT_ENTRY	0, 0, 0 		; C6h
IDT_ENTRY	0, 0, 0 		; C7h
IDT_ENTRY	0, 0, 0 		; C8h
IDT_ENTRY	0, 0, 0 		; C9h
IDT_ENTRY	0, 0, 0 		; CAh
IDT_ENTRY	0, 0, 0 		; CBh
IDT_ENTRY	0, 0, 0 		; CCh
IDT_ENTRY	0, 0, 0 		; CDh
IDT_ENTRY	0, 0, 0 		; CEh
IDT_ENTRY	0, 0, 0 		; CFh
IDT_ENTRY	0, 0, 0 		; D0h
IDT_ENTRY	0, 0, 0 		; D1h
IDT_ENTRY	0, 0, 0 		; D2h
IDT_ENTRY	0, 0, 0 		; D3h
IDT_ENTRY	0, 0, 0 		; D4h
IDT_ENTRY	0, 0, 0 		; D5h
IDT_ENTRY	0, 0, 0 		; D6h
IDT_ENTRY	0, 0, 0 		; D7h
IDT_ENTRY	0, 0, 0 		; D8h
IDT_ENTRY	0, 0, 0 		; D9h
IDT_ENTRY	0, 0, 0 		; DAh
IDT_ENTRY	0, 0, 0 		; DBh
IDT_ENTRY	0, 0, 0 		; DCh
IDT_ENTRY	0, 0, 0 		; DDh
IDT_ENTRY	0, 0, 0 		; DEh
IDT_ENTRY	0, 0, 0 		; DFh
IDT_ENTRY	0, 0, 0 		; E0h
IDT_ENTRY	0, 0, 0 		; E1h
IDT_ENTRY	0, 0, 0 		; E2h
IDT_ENTRY	0, 0, 0 		; E3h
IDT_ENTRY	0, 0, 0 		; E4h
IDT_ENTRY	0, 0, 0 		; E5h
IDT_ENTRY	0, 0, 0 		; E6h
IDT_ENTRY	0, 0, 0 		; E7h
IDT_ENTRY	0, 0, 0 		; E8h
IDT_ENTRY	0, 0, 0 		; E9h
IDT_ENTRY	0, 0, 0 		; EAh
IDT_ENTRY	0, 0, 0 		; EBh
IDT_ENTRY	0, 0, 0 		; ECh
IDT_ENTRY	0, 0, 0 		; EDh
IDT_ENTRY	0, 0, 0 		; EEh
IDT_ENTRY	0, 0, 0 		; EFh
IDT_ENTRY	0, 0, 0 		; F0h
IDT_ENTRY	0, 0, 0 		; F1h
IDT_ENTRY	0, 0, 0 		; F2h
IDT_ENTRY	0, 0, 0 		; F3h
IDT_ENTRY	0, 0, 0 		; F4h
IDT_ENTRY	0, 0, 0 		; F5h
IDT_ENTRY	0, 0, 0 		; F6h
IDT_ENTRY	0, 0, 0 		; F7h
IDT_ENTRY	0, 0, 0 		; F8h
IDT_ENTRY	0, 0, 0 		; F9h
IDT_ENTRY	0, 0, 0 		; FAh
IDT_ENTRY	0, 0, 0 		; FBh
IDT_ENTRY	0, 0, 0 		; FCh
IDT_ENTRY	0, 0, 0 		; FDh
IDT_ENTRY	0, 0, 0 		; FEh
IDT_ENTRY	0, 0, 0 		; FFh

	public	IDTLEN
idtlen		equ	this byte - idtstart

IDT ends

END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\retreal.asm ===
.386p
page	58,132
;******************************************************************************
	title	RetReal - Return-To-Real routine(s) for the 386
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
;   Module:   RetReal - Return-To-Real routine(s) for the 386
;
;   Version:  2.00
;
;   Date:     February 20, 1986
;
;   Author:   Caldwell Crosswy
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   02/20/86  Original
;   05/12/86  A-RRH	Cleanup and segment reorganization
;   06/01/86		Removed Real386a (loadall version) and left only
;			RetReal via PE bit (SBP).
;   06/21/86  0.02	Saved Eax (SBP).
;   06/28/86  0.02	Name changed from CEMM386 to CEMM (SBP).
;   07/02/86  0.03	Reset TSS busy bit (SBP).
;   07/05/86  0.04	Added Real_Seg label for _TEXT fixup (SBP).
;   07/06/86  0.04	changed assume to _DATA (SBP).
;   05/13/87  2.00	moved the mode switching code to the routine GoRealMode
;			in MODESW.ASM. Also moved RR_GoReal and JumpReal
;			to here from RR_TRAP.ASM. (SBP)
;
;******************************************************************************
;
;   Functional Description:
;
;	This module contains routines for returning to real mode from
;	protected mode.
;		RR_GoReal - This entry is used by the port 84/85 return to
;				real mode trap.  It exits thru JumpReal and
;				continues execution of the system in real
;				mode.
;		JumpReal - This entry is called to continue the system in
;				real mode.
;		RetReal - Goes from Protected Mode to real mode using the
;				ring 0 stack.
;
;******************************************************************************
.lfcond 				; list false conditionals
	page
;******************************************************************************
;			P U B L I C   D E C L A R A T I O N S
;******************************************************************************
;
	public	RR_GoReal
;LEO	public	JumpReal
	public	RetReal

	page
;******************************************************************************
;			I N C L U D E	F I L E S
;******************************************************************************

include vdmseg.inc
include vdmsel.inc
include	oemdep.inc
include	vm386.inc
include	emm386.inc
include	emmfunct.inc
include emmdata.inc
;
;******************************************************************************
;			E X T E R N A L   R E F E R E N C E S
;******************************************************************************
;

_TEXT	segment
Extrn	ExitVirtual:far
_TEXT	ends

R_CODE	segment
Extrn	Current_State:word
Extrn	GoRealMode:near
R_CODE	ends

;******************************************************************************
;			L O C A L   C O N S T A N T S
;******************************************************************************
;

RR_MASK equ	NOT	(FLAGS_IF+FLAGS_TF)	; mask off IF and TF bits

	page
R_CODE	SEGMENT
	ASSUME	CS:R_CODE, DS:R_CODE, ES:R_CODE, GS:R_CODE
;
;******************************************************************************
;			L O C A L   D A T A   A R E A
;******************************************************************************
;
RR_Jump 	label	dword		; ret addr for instr after out 84
RR_JOff 	dw	0
RR_JSeg 	dw	0

RR_DS		dw	0		; DS for return
RR_SS		dw	0		; SS for return
RR_SP		dw	0		; SP for return

RR_AX		dw	0		; save AX here

RR_Flags	dw	0		; low word of flags for return

	page
;******************************************************************************
;			C O D E
;******************************************************************************

;******************************************************************************
;	RR_GoReal - return client to real after 84/85 trap
;
;    This is the return to real code.  First we return to real mode.
;    Then we set up the stack, restore the registers and return to
;    the instruction following the out to 85h.
;
;		*** JMP TO HERE
;
; ENTRY:	PROTECTED MODE
;		SS:[BP] -> points to saved EBP on GP fault stack frame
;		SS:[SP] -> bottom of pushad
;
;			=> to unwind:
;				popad
;				pop	ebp	; entry BP pts to here
;				add	sp,4	; throw away error code
;				iret
;
; EXIT:		REAL MODE
;		R_CODE:[Current_State] = active bit reset => CEMM inactive
;		continues execution of process specified in GP fault stack
;		frame.
;******************************************************************************
;
RR_GoReal:
	;
	; now leaving Virtual MODE and Deactivating CEMM
	;
	Pcall	VDMC_GSEL, _TEXT:ExitVirtual
	; return to real mode
	call	RetReal
	iret			;LEO
ifdef 900226			;LEO
	; fall into jumpreal code

;******************************************************************************
;
; NAME:	JumpReal - jump into faulting code and continuing executing in Real
;	mode.   When a virtual mode process causes a GP fault, then wishes
;	to continue executing in Real mode afterwards, VDM returns to real
;	mode then calls this routine to "unwind" the stack and continue
;	the process in real mode.
;
;		THIS IS A FAR JUMP ***
;
; ENTRY:	REAL MODE
;		SS:[BP] -> points to saved EBP on GP fault stack frame
;		SS:[SP] -> bottom of pushad
;
;			=> to unwind:
;				popad
;				pop	ebp	; entry BP pts to here
;				add	sp,4	; throw away error code
;				iret
;
; EXIT:		REAL MODE
;		R_CODE:[Current_State] = active bit reset => CEMM inactive
;		continues execution of process specified in GP fault stack
;		frame.
;
;******************************************************************************
JumpReal	label	far
	push	cs
	pop	ds		; set DS= CS = R_CODE

	push	ax
	mov	al,DISABLE_NMI
	out	NMI_CMD,al		; disable NMIs
	pop	ax

	; set state to inactive

	and	[Current_State], NOT fState_Active

					; set up return address
	mov	bx,[bp.VTFOE+VMTF_EIP]	; get return IP
	mov	[RR_JOff],bx		; save it
	mov	bx,[bp.VTFOE+VMTF_CS]	; get return CS
	mov	[RR_JSeg],bx		; save it
;
	mov	bx,[bp.VTFOE+VMTF_EFLAGS]	; get flags
	mov	[RR_Flags],bx			; and save
	and	[bp.VTFOE+VMTF_EFLAGS],RR_MASK	; mask off certain bits
;
	mov	bx,[bp.VTFOE+VMTF_DS]	; get DS
	mov	[RR_DS],bx		; save it

	mov	bx,[bp.VTFOE+VMTF_SS]	; get SS
	mov	[RR_SS],bx		; save it
	mov	bx,[bp.VTFOE+VMTF_ESP]	; get SP
	mov	[RR_SP],bx		; save it
;
; restore regs from stack
;
	popad
	pop	ebp				; now SP -> error code

	add	sp,4+VMTF_ES		; skip error code and GP fault stack
					;   up to ES

	pop	es			; reset ES for return
	add	sp,6			; skip high word of ES segment
					; and DS dword

	pop	fs				; reset FS for return
	add	sp,2			; skip high word of segment

	pop	gs				; reset GS for return
;
;  now set flags, DS, stack, and jump to return.
;
	test	[RR_Flags],FLAGS_IF	;Q: IF bit set in return flags ?
	jz	SHORT RR_CLIexit	;  N: then just return
	push	[RR_Flags]		;  Y: enable interrupts on return
	popf				; set flags
	push	[RR_DS]
	pop	ds			; set DS for exit

	mov	ss,CS:[RR_SS]		; restore SS
	mov	sp,CS:[RR_SP]		; restore SP

	mov	CS:[RR_AX],ax
	mov	al,ENABLE_NMI
	out	NMI_CMD,al		; enable NMIs
	mov	ax,CS:[RR_AX]

	sti				; enable ints
	jmp	CS:[RR_Jump]		;  and return

RR_CLIexit:
	push	[RR_Flags]		; leave interrupts disabled on return
	popf				; set flags
	push	[RR_DS]
	pop	ds			; set DS for exit

	mov	ss,CS:[RR_SS]		; restore SS
	mov	sp,CS:[RR_SP]		; restore SP

	mov	CS:[RR_AX],ax
	mov	al,ENABLE_NMI
	out	NMI_CMD,al		; enable NMIs
	mov	ax,CS:[RR_AX]

	jmp	CS:[RR_Jump]		; far jump for return
;

;******************************************************************************
;***	RetReal - cause a 386 mode switch to real mode
;
;	ENTRY	Ring 0 protected mode
;		CLI - interrupts disabled
;		SS = Ring 0 stack
;
;	EXIT	Real Mode
;		CS = _TEXT
;		DS = R_CODE
;		ES = FS = GS = R_CODE
;		SS = Ring 0 Stack segment
;		A20 disabled
;		high system memory LOCKED
;
;	USES	flags
;
;	DESCRIPTION
;	    This routine switches to real mode and an internal stack.
;	It is usually followed by a call to the routine JumpReal which
;	continues the machine in real mode.
;		NOTE: this routine requires that the Ring0 stack be
;			accessible in Real mode.
;
RetReal	proc near

	call	GoRealMode
	ret				; *** RETURN ***
RetReal	endp

endif	;LEO

;=============================================================================
;==
;==  RetReal:  This routine will switch the processor back into real mode.
;==  	       It translates from the protected mode stack to the user stack
;==	       but only maintains the CS:IP and flags to return to the user
;==	       code.
;==
;==  Entry: (Protected Mode)
;==	    SS:SP = points to IP and a PUSHAD
;==	    SS:BP = points to Virtual Mode Stack Frame
;==	       GS = R_CODE
;==
;==  Exit:  (Real Mode)
;==	    SS:SP = ready for an IRET to return to the user code in real mode.
;==	    General Registers = same as user registers when trapped.
;==	    Segment Registers = same as user registers when trapped.
;==
;=============================================================================
RetReal	proc near
;
;  Deactivate CEMM
;
	and	gs:[Current_State],not fState_Active

;
;  Setup RSS_GSEL in GDT to have same base as user stack
;
	mov	ax,GDTD_GSEL		; ES access to GDT
	mov	es,ax

	movzx	ebx,[bp][VTFOE].VMTF_SS	; get base address of user stack
	shl	ebx,4
	mov	es:[RSS_GSEL][2],bx	; bits 0-15 of base address
	shr	ebx,16
	mov	es:[RSS_GSEL][4],bl	; bits 16-23
	mov	es:[RSS_GSEL][7],bh	; bits 24-31
;
;  Setup user stack with proper return address and CS:IP & flags inorder
;  to return to the user code.
;
	mov	bx,[bp][VTFOE].VMTF_ESP	; get offset for user stack

	mov	ax,RSS_GSEL		; access user stack via DS
	mov	es,ax

	mov	ax,[bp][VTFOE].VMTF_EFLAGS ; get user flags
	sub	bx,2			    ; and place it on the user stack
	mov	es:[bx],ax

	mov	ax,[bp][VTFOE].VMTF_CS	; get code segment
	sub	bx,2			; and place it on the user stack
	mov	es:[bx],ax

	mov	ax,[bp][VTFOE].VMTF_EIP; get instruction pointer
	sub	bx,2			; and place it on the user stack
	mov	es:[bx],ax

	movzx	esp,sp			; access only 64K
	mov	ax,[esp]		; get return address
	sub	bx,2			; and place it on the user stack
	mov	es:[bx],ax
;
;  Save all segment registers for real mode
;
	mov	ax,[bp][VTFOE].VMTF_DS	; get user DS
	mov	gs:[UserDS],ax

	mov	ax,[bp][VTFOE].VMTF_ES	; get user ES
	mov	gs:[UserES],ax

	mov	ax,[bp][VTFOE].VMTF_FS	; get user FS
	mov	gs:[UserFS],ax

	mov	ax,[bp][VTFOE].VMTF_GS	; get user GS
	mov	gs:[UserGS],ax
;
;  Save user stack values
;
	mov	gs:[UserSS],RSS_GSEL
	mov	gs:[UserSP],bx
;
;  Restore general registers
;
	add	sp,2			; throw away return address
	popad				; restore general registers
	pop	ebp			; restore EBP
;
;  Switch to user stack
;
	mov	ss,gs:[UserSS]
	mov	sp,gs:[UserSP]
;
;  Return to real mode
;
	call	GoRealMode
;
;  Restore segment resiters
;
	mov	ds,gs:[UserDS]
	mov	es,gs:[UserES]
	mov	fs,gs:[UserFS]
	mov	gs,gs:[UserGS]

	ret
RetReal	endp

R_CODE	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\rrtrap.asm ===
.386p
page	58,132
;******************************************************************************
	title	RRTRAP.ASM - Return To Real Trap
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
;   Module:   RRTRAP.ASM - Return to Real Trap
;
;   Version:  2.00
;
;   Date:     June 1, 1986
;
;   Author:   Steve Preston
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   06/01/86  Original
;   06/28/86  0.02	Name changed from CEMM386 to CEMM (SBP).
;   07/03/86  0.03	Changed to P84/85 Handlers (SBP).
;   07/06/86  0.04	Moved JumpReal to R_CODE and far label (SBP).
;   07/06/86  0.04	Changed assume to _DATA (SBP).
;   05/18/87  2.00	Movde JumpReal and RR_GoReal to RETREAL.ASM (SBP).
;   06/07/87  2.00	Expaned port 84h/85h trapping to include a general
;			CEMM call interface.
;
;******************************************************************************
;
;   Functional Description:
;	This module traps ports 84h and 85h and watches for specific output
;   sequences.  COMPAQ ROMS output values to port 84h and 85h during
;   power up and other diagnostics.   Port 85h receives a major code indicating
;   the ROM type and possibly the diagnostic mode.  Port 84h receives the minor
;   code indicating the section of diagnostic code executing.  CEMM uses these
;   ports as a function call interface for accessing protected mode functions
;   from virtual mode.  To access the CEMM protected mode functions via this
;   interface, the user program must output a minor code (function class) to
;   port 84h, then output the CEMM major code to port 85h.
;	The following major codes (port 85h) are currently in use.
;		00 -> system ROM
;		01 -> system ROM
;		02 -> CEMM
;		05 -> Merlin ROM
;
;	CEMM uses the following major/minor codes
;	85h = 00		=> ROM code
;		84h = 0F	=> CEMM returns to real mode
;
;	85h = 02		=> CEMM functions
;		84h = 00	=> Weitek functions
;		84h = 01	=> Diagnostic functions
;
;******************************************************************************
.lfcond 				; list false conditionals
	page
;******************************************************************************
;			P U B L I C   D E C L A R A T I O N S
;******************************************************************************
;
	public	P84_Handler
	public	P85_Handler
	public	PMF_RetReal

ifdef	QHKN
	public	Debug_GetPTE
endif
;
;******************************************************************************
;			E X T E R N A L   R E F E R E N C E S
;******************************************************************************
	include VDMseg.inc
	include VDMsel.inc
	include desc.inc
	include VM386.INC
	include	EMM386.INC
	include page.inc
	include	emmfunct.inc
	include	emmdata.inc
;
_TEXT	SEGMENT
	extrn	UpdateHMA:near
	extrn	RestoreIVT:near
	extrn	FlushDMAState:near
_TEXT	ENDS

R_CODE	SEGMENT
	extrn	RR_GoReal:far
ifdef	QHKN
	extrn	Debug_PhysIO:far
endif

R_CODE	ENDS

	page
;******************************************************************************
;			L O C A L   C O N S T A N T S
;******************************************************************************
;
;  On entry of Protected Mode functions, BP points to the saved BP just
;  below the VMTF stack frame after a GP fault.  The following stack
;  frame is used to access items on the entry stack to the P85 handler
;  PMFS_OFF is subtracted from BP to allow use of the PMF_Stack struc.
;
PMF_Stack	struc
PMFS_DX		dw	?		; user DX
PMFS_BX		dw	?		; saved BX
PMFS_ESI 	dw	?		; user ESIlo
		dw	?		; user ESIhi
PMFS_EBX 	dw	?		; user EBXlo
		dw	?		; user EBXhi
PMFS_EBP 	dw	?		; user EBPlo
		dw	?		; user EBPhi
PMFS_ERR	dw	?		; VM Error Code (low)
		dw	?		; VM Error Code (high)
PMFS_EIP	dw	?		; VM EIP (low)
		dw	?		; VM EIP (high)
PMFS_CS		dw	?		; VM CS
		dw	?		;   (padding)
PMFS_EFLAGS	dw	?		; VM EFLAGS (low)
PMFS_EFLAGShi	dw	?		; VM EFLAGS (high)
PMFS_ESP	dw	?		; VM ESP (low)
		dw	?		; VM ESP (high)
PMFS_SS		dw	?		; VM SS
		dw	?		;   (padding)
PMFS_ES		dw	?		; VM ES
		dw	?		;   (padding)
PMFS_DS		dw	?		; VM DS
     		dw	?		;   (padding)
PMFS_FS		dw	?		; VM FS
		dw	?		;   (padding)
PMFS_GS		dw	?		; VM GS
		dw	?		;   (padding)
PMF_Stack	ends

PMFS_OFF	equ	(PMFS_EBP - PMFS_DX)

;
;******************************************************************************
;			S E G M E N T	D E F I N I T I O N
;******************************************************************************

;------------------------------------------------------------------------------
;	_TEXT code
;------------------------------------------------------------------------------
_TEXT	segment
	assume	cs:_TEXT, ds:_DATA, es:_DATA, ss:_DATA

;******************************************************************************
; CEMM protected mode functions dispatch table
;******************************************************************************
CEMM_PMF_Table	label	word
	dw	offset	_TEXT:UpdateHMA		; 84h = 00		;LEO
ifdef	QHKN
	dw	offset	_TEXT:PMF_Diag		; 84h = 01
endif
CEMM_PMF_MAX	equ	($-CEMM_PMF_Table)/2 - 1	; max function code

	page
;******************************************************************************
;   P84_Handler - I/O Trap handler for port 84h
;
;   ENTRY: Protected Mode Ring 0
;		AL = byte to output to port.
;		BX = 2 * port addr
;		DX == 0 => input
;		   <> 0 => output
;		DS = _DATA
;		SS:SP pts to: IP, saved DS, saved DX, IP ,
;			      saved DX,saved BX,saved ESI,saved EBX,saved EBP,
;			then GP fault stack frame with error code.
;		SS:BP = points to stack frame on entry to GP fault handler
;
;   EXIT: Protected Mode Ring 0
;		CLC => I/O emulated.
;		STC => I/O NOT emulated.
;
;   USED:  Flags
;   STACK:
;******************************************************************************
P84_Handler	proc	near
;
	or	dx,dx		;Q: Output ?
;QLEO	jz	SHORT P84_Bye	;  N: then leave
	jz	short P84exit	;  N: then leave
	mov	[RR84save],al	;  Y: save value written to 84
	mov	[RR_Last],84h	; save this RR port #
P84_Bye:
	out	84h,al		; emulate it now - save time later
	clc			; don't bother to emulate it
	ret
P84exit:
	stc
	ret
;
P84_Handler	endp
	page
;******************************************************************************
;   P85_Handler - I/O Trap handler for port 85h
;
;   ENTRY: Protected Mode Ring 0
;		AL = byte to output to port.
;		BX = 2 * port addr
;		DX == 0 => input
;		   <> 0 => output
;		DS = _DATA
;		SS:SP pts to: IP, saved DS, saved DX, IP ,
;			      saved DX,saved BX,saved ESI,saved EBX,saved EBP,
;			then GP fault stack frame with error code.
;		SS:BP = points to stack frame on entry to GP fault handler
;
;   EXIT: If output to 85h => return to Real
;		RRTrap emulates the output to 85h
;		RRTrap returns to real, fixes the segments and stack, and
;		       returns to the instruction past the output in real mode.
;	  If output to 85h  => Weitek functions
;		call Weitek functions handler
;	  else,
;		Protected Mode Ring 0
;		CLC => I/O emulated.
;		STC => I/O NOT emulated.
;
;   USED:  Flags
;   STACK:
;******************************************************************************
P85_Handler	proc	near
;
	or	dx,dx		;Q: Output ?
;QLEO	jz	SHORT P85_Bye	;  N: then leave
	jz	short P85exit	;  N: then leave
	mov	[RR85save],al	;  Y: save value for 85h
	out	85h,al		;     emulate output
	cmp	[RR_Last],84h	;Q: was port 84h last RR port output ?
	jne	SHORT P85_Exit	;  N: save port # and leave
				;  Y: check for valid major function #
	; check for ROM return to real
	;
	cmp	al,RR85_Value		;Q: ROM Return to Real major code ?
	jne	SHORT P85_ChkCEMM	;  N: check for CEMM code
	cmp	[RR84Save],RR84_Value	;  Y: Q: was 84h value RR value ?
	jne	SHORT P85_Exit		;       N: save port # and leave
	jmp	SHORT PMF_RetReal	;       Y: return to real

	;
	; check for CEMM functions
	;
P85_ChkCEMM:
	cmp	al,CEMM_85_Value	;Q: CEMM code ?
	jne	SHORT P85_Exit		;  N: leave
	cmp	[RR84Save],CEMM_PMF_MAX	;  Y: Q: valid CEMM minor code ?
	ja	SHORT P85_Exit		;       N: leave
	xor	bx,bx			;       Y: dispatch function
	mov	bl,[RR84Save]		; BX = minor code
	shl	bx,1			; BX = word offset in table
ifndef	QHKN
	or	bx, bx
	jnz	SHORT P85_PMF_err
endif
	call	CS:CEMM_PMF_Table[bx]	; Q:CEMM PMF handler return OK
	jc	SHORT P85_PMF_err	;   N: set user's CF
					;   Y: reset user's CF
	and	WORD PTR [bp.PMFS_EFLAGS - PMFS_OFF],NOT FLAGS_CF
	jmp	SHORT P85_exit
P85_PMF_err:
	or	WORD PTR [bp.PMFS_EFLAGS - PMFS_OFF],FLAGS_CF	; user STC
;
; all done - save this port as last 84/85h port written
;
P85_Exit:
	mov	[RR_Last],85h	; save this RR port addr
P85_Bye:
	clc			; already emulated
	ret
P85exit:
	stc
	ret
;
P85_Handler	endp

;******************************************************************************
;  PMF_RetReal - port 84/85 return to real functions
;	return processor to real mode and continues the process executing.
;   ENTRY: Protected Mode Ring 0
;		DS = _DATA
;		SS:SP pts to: IP, saved DS, saved DX, IP ,
;			      saved DX,saved BX,saved ESI,saved EBX,saved EBP,
;			then GP fault stack frame with error code.
;		SS:BP = points to stack frame on entry to GP fault handler
;
;   EXIT: Real Mode
;
;******************************************************************************
PMF_RetReal:

	call	FlushDMAState		; write out the virtual dma regs

	mov	dx,DATA32_GSEL		; need access to entire address space
	mov	fs,dx
;
;  If CPU shutdown is detected - restore IVT
;
	test	gs:[GenFlags],fShutDown	;Q: Is the CPU shutting down?
	jz	short PRRcont		; N: continue
	call	RestoreIVT		; Y: restore IVT
PRRcont:
	;
	;   reset registers from the stack
	;
	add	sp,8			; skip IP,DS,DX, and IP
	pop	dx
	pop	bx			; last pushed by OUT emulator
	;
	;   now back to stack presented by VmFault's jmp to instr handler
	;	go to GP fault+pushad stack and then to return to real code
	;
	pop	esi
	pop	ebx
	pushad
	PJmp	RCODE_GSEL,R_CODE:RR_GoReal  ;	  return to real

;LEO ;******************************************************************************
;LEO ;  PMF_Weitek - CEMM Protected Mode Functions for Weitek Coprocessor
;LEO ;   ENTRY: Protected Mode Ring 0
;LEO ;		AL = byte to output to port.
;LEO ;		DS = _DATA
;LEO ;		SS:SP pts to: IP, saved DS, saved DX, IP ,
;LEO ;			      user DX,saved BX,user ESI,user EBX,user EBP,
;LEO ;			then GP fault stack frame with error code.
;LEO ;		SS:BP = points to stack frame on entry to GP fault handler
;LEO ;
;LEO ;		USER BX = 0 => turn Weitek page table mapping on
;LEO ;		        = 1 => turn Weitek page table mapping off
;LEO ;   EXIT:
;LEO ;		Protected Mode Ring 0
;LEO ;
;LEO ;   USED:  Flags
;LEO ;   STACK:
;LEO ;
;LEO ;******************************************************************************
;LEO PMF_Weitek	proc	near
;LEO 	push	bx
;LEO 	push	es
;LEO	mov	bx,word ptr [bp.PMFS_EBX - PMFS_OFF] ; get BX from stk
;LEO	push	PAGET_GSEL
;LEO	pop	es				; ES -> page tables
;LEO	PCall	RCODE_GSEL,R_CODE:WeitekPageMap	; go map it
;LEO	pop	es
;LEO	pop	bx
;LEO	ret
;LEO PMF_Weitek	endp

ifdef	QHKN
;******************************************************************************
;  PMF_Diag - CEMM Protected Mode Functions for Diagnostics/Testing
;   ENTRY: Protected Mode Ring 0
;		DS = _DATA
;		SS:SP pts to: IP, saved DS, saved DX, IP ,
;			      user DX,saved BX,user ESI,user EBX,user EBP,
;			then GP fault stack frame with error code.
;		SS:BP = points to stack frame on entry to GP fault handler
;
;		BX = function #
;		   = 0 => Get Page Table Entry  - see ELIMFUNC.ASM
;		   = 1 => Do physical IO  - see ELIMFUNC.ASM
;   EXIT:
;		Protected Mode Ring 0
;		STC => error - invalid function
;
;   USED:  Flags
;   STACK:
;
;******************************************************************************
PMF_Diag	proc	near
	mov	bx,word ptr [bp.PMFS_EBX - PMFS_OFF] ; get BX from stk
	cmp	bl,0			;Q: GetPTE call ?
	jne	SHORT PMFD_chk1		;  N: check for function 1
					;  Y: get args from stack
	mov	dx,word ptr [bp.PMFS_DX - PMFS_OFF] ; get DX from stk
	call	Debug_GetPTE		; get PTE
	jmp	SHORT PMFD_exit

PMFD_chk1:
	cmp	bl,1				;Q: PhysIO call ?
	jne	SHORT PMFD_err			;  N: report error
						;  Y: get args from stack
	mov	si,word ptr [bp.PMFS_ESI - PMFS_OFF] ; get SI from stk
	mov	dx,word ptr [bp.PMFS_DX - PMFS_OFF] ; get DX from stk
	PCall	RCODE_GSEL,R_CODE:Debug_PhysIO	;     do it
PMFD_exit:
	ret

PMFD_err:
	stc
	ret
PMF_Diag	endp

	page
;******************************************************************************
;	Debug_GetPTE  - Returns the Page Table Entry for a Linear Address
;
;	NOTE: THIS IS A FAR ROUTINE
;
;	ENTRY:	PROTECTED mode
;		ECX = linear address
;		DX = 0  => don't map linear address first (for >1meg addrs)
;		DX = 1  => map linear address first
;
;	EXIT:	Same processor mode as entry
;		STC => error
;		CLC => no errors and
;			ECX = page table entry
;
;	USED: none
;
;******************************************************************************
Debug_GetPTE	proc	near
	push	eax
	push	esi
	push	ds

	mov	ax,PAGET_GSEL
	mov	ds,ax			; DS ->page tables

	or	dx,dx			;Q: map linear addr ?
	jz	SHORT DGPTE_mapped	;  N: don't bother
					;  Y: map it
DGPTE_mapped:

	mov	esi,ecx		; ESI = linear addr
	PDOFF	si		; ESI = page dir off for this addr
	shr	si,2		; ESI = page table # (zero based)
	cmp	si,TOTAL_PAGE_TABLES	;Q: valid CEMM page table  ?
	jae	SHORT DGPTE_err		;  N: report error
	shl	si,12			;  Y: SI = offset to begin of it's table

	PTOFF	cx		; ECX = page table off for this addr
	add	si,cx		; SI -> page table entry

	mov	ecx,[si]		; ECX <- DS:[SI] = page table entry
	clc	; OK ...

DGPTE_exit:
	pop	ds
	pop	esi
	pop	eax
	ret
DGPTE_err:
	stc
	jmp	DGPTE_exit

Debug_GetPTE	endp

endif

_TEXT	ends				; end of segment

	end				; end of module

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\segfix.asm ===
.386p
;******************************************************************************
	title	SEGFIX
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1989-1991
;   (C) Copyright COMPAQ Computer Corp. 1989-1991
;
;   Title:    EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
;   Module:   SEGFIX - Sets the descriptor caches
;
;   Version:  0.001
;
;   Date:     Feb 16,1990
;
;   Author:   Harish K. Naidu
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   02/16/89  Original
;
;******************************************************************************
;
;   Functional Description:
;
;
;******************************************************************************

;******************************************************************************
;	P U B L I C S
;******************************************************************************

	public	segfixup

;******************************************************************************
;	D E F I N E S
;******************************************************************************
	include vdmseg.inc
	include	desc.inc

SGDTD_GSEL	equ	08h 		; gdt data alias
SIDTD_GSEL	equ	10h 		; idt data alias
SVDMC_GSEL	equ	18h 		; VDM Code selector
SVDMD_GSEL	equ	20h 		; VDM Data Selector

;******************************************************************************
;	E X T E R N A L   R E F E R E N C E S
;******************************************************************************

LAST	segment

	extrn	SetSegDesc:near
	extrn	SegTo24:near

LAST	ends


SGDT	segment

GDT_ENTRY	0, 0, 1, 0			; null selector
GDT_ENTRY	0, 0, 0, D_DATA0		; GDT alias
GDT_ENTRY	0, 0, 0, D_DATA0		; IDT alias
GDT_ENTRY	0, 0, 0, D_CODE0		; VDM Code
GDT_ENTRY	0, 0, 0, D_DATA0		; VDM Data

SGDTLEN	EQU	$-SGDT

SGDT	ends

SIDT	segment

IDT_ENTRY	0, 0, 0 	 

SIDTLEN	EQU	$-SIDT

SIDT	ends


LAST	segment 

	assume	cs:LAST

SGDT_Ptr 	dd 2 dup (0)	; GDT ptr for LGDT
SIDT_Ptr 	dd 2 dup (0)	; IDT ptr for LIDT

Sreal_idt	dw	0400h	; real mode DOS IDT limit
		dd	0	; and base ptr
		dw	0	; just in case qword used

ss_save		dw	?	; temporary location to save stack
sp_save		dw	?


;--------------------------------------------------------------------------
;
; Procedure SegFixup
;
; This routine will switch to protect mode and set up the selectors with 
; real mode attributes and return to real mode. This is called at init
; time. This is necessary to fix up the BUGGY ROMS of certain machines
; like APRICOT Qi which does not do this for fs and gs. Therefore on this
; machine one cannot access fs from REAL MODE!! unless something similar
; to this routine is done
;
; USES: ALL
;--------------------------------------------------------------------------

segfixup	proc	near

	mov	ax,SGDT
	mov	es,ax			; ES:0 -> gdt

	mov	ax,SGDT
	call	SegTo24
	mov	cx,SGDTLEN
	mov	ah,D_DATA0
	mov	bx,SGDTD_GSEL
	call	SetSegDesc		; Set up SGDT alias descriptor

	mov	ax,SIDT
	call	SegTo24
	mov	cx,SIDTLEN
	mov	ah,D_DATA0
	mov	bx,SIDTD_GSEL
	call	SetSegDesc		; Set up SIDT alias descriptor

	mov	ax,seg LAST
	call	SegTo24
	mov	cx,0			; 0 = 64K size
	mov	ah,D_CODE0
	mov	bx,SVDMC_GSEL
	call	SetSegDesc		; Set up LAST Code descriptor


	mov	ax,seg LAST
	call	SegTo24
	mov	cx,0			; 0 = 64K size
	mov	ah,D_DATA0
	mov	bx,SVDMD_GSEL
	call	SetSegDesc		; Set up LAST Data descriptor




; The GDT and IDT pointers are setup up so that when CEMM gets turned on,
; the LGDT and LIDT instructions will have their correct pointers.
;
	mov	ax,SGDT		; DS:SI point to the GDT's entry location.
	mov	ds,ax
	mov	si,SGDTD_GSEL


	mov	ax,seg LAST	; ES:DI point to data strucutre used by the LGDT.
	mov	es,ax
	assume	es:LAST
	mov	di,offset LAST:SGDT_Ptr

	movsd	; The 8 byte descriptor is copied over as is.
	movsd

;
; Since only the first 6 bytes of the GDT pointer is needed for the base and
; linear address, the upper 8 bits of the linear address must be copied down
; to its proper location.
;
	mov	al,byte ptr es:[SGDT_Ptr][7]
	mov	byte ptr es:[SGDT_Ptr][5],al

;
; The exact same operations are done for the IDT pointer.
;
	mov	si,SIDTD_GSEL
	mov	di,offset LAST:SIDT_Ptr
	movsd
	movsd
	mov	al,byte ptr es:[SIDT_Ptr][7]
	mov	byte ptr es:[SIDT_Ptr][5],al

	pushf
	mov	cs:[ss_save],ss
	mov	cs:[sp_save],sp

	cli

;
;   load gdt and ldt base registers  (DB 66h needed for 32 bit address)
;
	db	66h
	lgdt	fword ptr CS:[SGDT_ptr]
	db	66h
	lidt	fword ptr CS:[SIDT_ptr]
;
;   go protected and enable paging - turn on bits in CR0
;

	mov	eax,cr0

	or	eax, MSW_PROTECT ; or EAX,imm32
		; PROT MODE

	mov	cr0,eax

;	far jump to flush prefetch, and reload CS

	db	0eah			; far jmp opcode
	dw	offset LAST:spm1	; offset
	dw	SVDMC_GSEL		; selector
spm1:


;  We are now in protected mode.

;
;
;  Intel shows DS,ES,FS,GS,and SS set up to make sure 'Real Mode' type
;  access rights, and limit are installed.  In this program, that happens
;  to already be the case, but for general purposeness, VDMD_GSEL fits
;  the bill.
;
	mov	ax,SVDMD_GSEL		; selector with real mode attributes
	mov	ds,ax
	mov	es,ax
	mov	ss,ax
	mov	fs,ax
	mov	gs,ax

;
; Switch back to real
;

;
;    reset the PE bit ...
;
	mov	eax,cr0			;  get CR0
	and	eax,07FFFFFFEh		; force real mode and shut down paging
	mov	cr0,eax			; set CR0

					; flush prefetched instructions with:
	db	0EAh			; Far Jump opcode
	dw	offset LAST:srl386_b	; destination offset
	dw	LAST			; destination segment
srl386_b:

	lidt	fword ptr cs:[Sreal_idt]

	mov	ss, cs:[ss_save]	; restore stack
	mov	sp, cs:[sp_save]
	
	mov	eax,cr3			; get CR3
	mov	cr3,eax			; set CR3 => clear TLB

	popf
	ret

segfixup	endp


LAST	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\util.asm ===
.386p
;******************************************************************************
	title	UTIL - general CEMM utilities
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
;   Module:   UTIL - utilities
;
;   Version:  2.0
;
;   Date:     June 11, 1986
;
;   Author:	Steve Preston
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   06/11/86  Original	from i286.asm
;   06/18/86  0.01	in GoVirtual - added code to init VDM state
;			variables (SBP).
;   06/25/86  0.02	in GoVirtual - more DiagByte state variable.
;   06/28/86  0.02	Name change from CEMM386 to CEMM (SBP).
;   06/29/86  0.02	Changed check code for ROM write protect state (SBP).
;   07/01/86  0.03	Added call to InitDMA in GoVirtual (SBP).
;   07/05/86  0.04	Moved code to InitLOCK (SBP).
;   07/05/86  0.04	Added FarGoVirtual and moved IsReal to PRINT.ASM (SBP).
;   07/06/86  0.04	Changed assume to _DATA and moved stack
;			out of _DATA(SBP) .
;   05/08/87  2.00	Moved GoVirtual to R_CODE (SBP).
;   04/27/88  3.30	Change old Int11h save to be init'ed to zero (RDV).
;   05/27/88  3.30	Change CHKA20 to not access 8042 (RDV).
;   07/26/88  3.31	Better CHKA20 (RDV).
;   09/09/88  3.31	Fix better CHKA20 (RDV).
;   08/09/89  4.10	EnterVirtual: add CEMM/Windows initialization (LC).
;
;   02/13/91  M008	Do not make int 16s on a Compaq Deskpro
;			386/16 or a Compaq portable 386.
;
;
;******************************************************************************
;
;   Functional Description:
;
;
;******************************************************************************
.lfcond 				; list false conditionals

	public	EnterVirtual
	public	ExitVirtual
	public	UpdateHMA
;;	public	Int11_Hook
;;	public	Int10_Hook
	public	GoVirtual
	public	FarGoVirtual
	public	ChkA20
	public	SelToSeg
	public	Log2Phy
	public	Log2Lin
	public	Lin2Phy
;;	public	chk_machine_state

ifdef MSFLAG
	public	UpdateHMAfar
	public	GetA20cnt
	public	SetA20cnt
endif

;******************************************************************************
;	D E F I N E S
;******************************************************************************
	include VDMseg.inc
	include VDMsel.inc
	include desc.inc
	include oemdep.inc
	include emm386.inc
	include emmfunct.inc
	include emmdata.inc
	include page.inc
	include winemm.inc
	include	xmm.inc

;******************************************************************************
;	E X T E R N A L   R E F E R E N C E S
;******************************************************************************

_TEXT	SEGMENT
	extrn	InitDMA:near		; (dmatrap.asm)
	extrn	Kybd_Watch:near 	; (a20trap.asm)
	extrn	InitReset:near
ifdef PICtrap
	extrn	EnterVirtPIC:near	; (pictrap.asm)
	extrn	ExitVirtPIC:near	; (pictrap.asm)
endif
_TEXT	ENDS

R_CODE	SEGMENT
	extrn	GoProtMode:near 	; (modesw.asm)
	extrn	GoVirtualMode:near	; (modesw.asm)
	extrn	Cache_Off:near		; (cemm386.asm)
ifdef MSFLAG
	extrn	XMMcontrol:dword
	extrn	EnableCount:word	; (xms.asm)
	extrn	DisableA20:near		; (modesw.asm)
	extrn	EnableA20:near		; (modesw.asm)
endif
R_CODE	ENDS

R1_CODE	segment
	extrn	PrevInt10:dword
	extrn	PrevInt11:dword
R1_CODE	ends

	page
;******************************************************************************
;		S E G M E N T	D E F I N I T I O N S
;******************************************************************************

;******************************************************************************
;		_TEXT segment
;******************************************************************************

_TEXT SEGMENT
	assume cs:_TEXT, ds:_DATA, es:_DATA

;******************************************************************************
;**	EnterVirtual - Initialization for entering virtual mode operation
;
;	    **** THIS IS A FAR ROUTINE ****
;
;	ENTRY	PROTECTED MODE
;
;	EXIT	PROTECTED MODE
;
;	USES	flags
;
;******************************************************************************
EnterVirtual	proc	far
	push	ax
	push	ds
	push	gs
	push	fs

	mov	ax,VDMD_GSEL
	mov	ds,ax			; DS -> _DATA
	mov	ax,RCODEA_GSEL
	mov	gs,ax
	mov	ax,DATA32_GSEL
	mov	fs,ax
;
;   init VDM state variables
;
ifdef TSSQLEO
	push	es
	mov	ax,TSSD_GSEL
	mov	es,ax		; ES -> TSS
endif
	call	Kybd_Watch	; init a20 line watch

;TSSQLEO pop	es


;
; reset Return to real variables
;
	mov	[RR_Last],0
	mov	[RR85save],0FFh
	mov	[RR84save],0FFh

;
; initialize DMA virtualization logic
;
	call	InitDMA 		; init DMA watcher

ifdef PICtrap
;
; initialize PIC vector mapping
;
	call	EnterVirtPIC 		; virtualize PIC
endif

;
; initialize EGA mapping logic
;
	call	EnterEGA

;
; initialize HMA page table entries according to state of A20/Weitek
;
	call	UpdateHMA
;
; initialize the reset vector at F000:FFF0 to point to ResetRoutine
;
	call	InitReset

	pop	fs
	pop	gs
	pop	ds
	pop	ax
	ret
EnterVirtual	endp

;******************************************************************************
;**	EnterEGA - EGA related initialization for entering Virtual Mode
;
;	ENTRY	PROTECTED MODE
;		R_CODE:[Current_State]
;		R_CODE:[PrevInt10] = vector for Int 10 chains
;
;	EXIT	PROTECTED MODE
;		R_CODE:[EGA_Seg] = saved EGA_Segment (E000h)
;		R_CODE:[PrevInt10+2] = segment -> C000h
;		Int 1fh and Int43h vectors -> C000h segment
;		(if they -> E000h before)
;
;	USES	flags
;
;******************************************************************************
EnterEGA	proc	near

	push	ax
	push	ds
	push	fs
	mov	ax,RCODEA_GSEL
	mov	ds,ax
	ASSUME	DS:R_CODE

	mov	ax,R1CODEA_GSEL
	mov	fs,ax
	ASSUME	FS:R1_CODE

	test	[Current_State],fState_CEGAmove ;Q: do EGA move ?
	jz	SHORT EEGA_exit			;  N: leave
	mov	word ptr fs:[PrevInt10+2],0C000h;  Y: seg to 0C000h
	push	es
	mov	ax,RM_IDT_GSEL
	mov	es,ax			; ES -> 0
	ASSUME	ES:ABS0
	cmp	es:[int5+2],0E000h	;Q: Int 5 (print screen) -> EGA ROM ?
	jne	short EEGA_chk1F	;  N: chk 1Fh vector
	mov	es:[int5+2],0C000h	;  Y: point it to C000h
EEGA_chk1F:
	cmp	ES:[int1F+2],0E000h	;Q: int 1f -> EGA ROM ?
	jne	SHORT EEGA_chk43	;  N: chk 43h vector
	mov	ES:[int1F+2],0C000h	;  Y: point it to C000h
EEGA_chk43:
	cmp	ES:[int43+2],0E000h	;Q: int 43  -> EGA ROM ?
	jne	SHORT EEGA_chk6d	;  N: chk 6dh vector
	mov	ES:[int43+2],0C000h	;  Y point it to C000h
EEGA_chk6d:
	cmp	ES:[int6d+2],0E000h	;Q: int 6d  -> EGA ROM ?
	jne	SHORT EEGA_vecdone	;  N: vextors patched
	mov	ES:[int6d+2],0C000h	;  Y point it to C000h
EEGA_vecdone:
	pop	es
	ASSUME	ES:_DATA
EEGA_exit:
	pop	fs
	assume	fs:nothing
	pop	ds
	ASSUME	DS:_DATA
	pop	ax
	ret
EnterEGA	endp

ifdef 900801
;******************************************************************************
;**	EnterWeitek - Weitek related initialization for entering Virtual Mode
;
;	Checks the current state of the Weitek mapping flag and updates
;	the page tables entries for the 1meg wraparound area to the proper
;	physical pages.
;
;	ENTRY	PROTECTED MODE
;		DS -> _DATA
;
;	EXIT	PROTECTED MODE
;
;	USES	flags
;
;******************************************************************************
EnterWeitek	proc	near
	push	bx
	push	es

	push	RCODEA_GSEL
	pop	es		;ES -> R_CODE
	ASSUME	ES:R_CODE

	xor	bx,bx				; BX = 0 => Weitek mapping
	test	ES:[Weitek_State],fWeitek_Map	;Q: is Weitek enabled ?
	jnz	SHORT EW_setPT			;  Y: set up Weitek mapping
	inc	bx				;  N: BX =1 => 1meg wrap
W_setPT:
	push	PAGET_GSEL
	pop	es				; ES -> page tables
	PCall	RCODE_GSEL,R_CODE:WeitekPageMap ; go map it
	pop	es
	pop	bx
	ret
	ASSUME	ES:_DATA

EnterWeitek	endp

endif

;==============================================================================
;==
;==  Log2Phy: Translates the logical address ES:EAX to a physical address.
;==
;==  Entry: (Protected Mode)
;==	ES:EAX	= logical address
;==
;==  Exit:
;==	EAX	= 32-bit physical address
;==
;==============================================================================
Log2Phy proc	near

	call	Log2Lin
	call	Lin2Phy

	ret
Log2Phy endp

;==============================================================================
;==
;==  Log2Lin: Translates the logical address ES:EAX to a linear address.
;==
;==  Entry: (Protected Mode)
;==	ES:EAX	= logical address
;==
;==  Exit:
;==	EAX	= 32-bit linear address
;==
;==============================================================================
Log2Lin proc	near
	push	ebx
	push	si
	push	fs

	mov	si,GDTD_GSEL		; access GDT via FS
	mov	fs,si
;
;  Get index into GDT
;
	mov	si,es
	and	si,SELECTOR_MASK
;
;  Get base address of selector
;
	mov	ebx,fs:[si][2]		; get low 24 bits
	rol	ebx,8
	mov	bl,fs:[si][7]		; upper 8 bits
	ror	ebx,8
;
;  Add base to offset to get linear address
;
	add	eax, ebx 		; linear address in eax

	pop	fs
	pop	si
	pop	ebx
	ret
Log2Lin	endp

;==============================================================================
;==
;==  Lin2Phy: Translates the linear address EAX to a physical address.
;==
;==  Entry: (Protected Mode)
;==	EAX	= 32-bit linear address
;==
;==  Exit:
;==	EAX	= 32-bit physical address
;==
;==============================================================================
Lin2Phy proc	near
	push	ebx
	push	fs

	mov	bx,PAGET_GSEL		; access page tables via FS
	mov	fs,bx

	push	eax			; save linear address
	shr	eax,12			; convert linear address tp PTE index
;
;  Get base physical address
;
	mov	ebx,fs:[eax*4]		; get base physical address
	and	ebx,PTE_ADDRESS_BIT_MASK; clear PTE control bits

	pop	eax			; restore linear address
	and	eax,00000FFFh 		; keep offset into physical page
;
;  Calculate physical address
;
	add	eax,ebx			; eax has physical address

	pop	fs
	pop	ebx
	ret
Lin2Phy	endp

;===============================================================================
;==
;==  UpdateHMA : Update page tables with current state of HMA
;==
;==  Entry:	(Protected Mode)
;==	RCODEA_GSEL:[Current_State](fState_A20Ena) = Current A20 state.
;==	RCODEA_GSEL:[Weitek_State](fWeitek_Map) = Current Weitek map state.
;==
;==
;==  Exit:	(Protected Mode)
;==	same (page tables reflect A20/Weitek state)
;==
;===============================================================================
ifdef MSFLAG
UpdateHMAfar	proc	far
	call	UpdateHMA
	ret
UpdateHMAfar	endp
endif

UpdateHMA proc	near
	push	eax
	push	ecx
	push	edi
	push	es
	push	ds
	cld

	mov	ax,RCODEA_GSEL		; RCODE alias
	mov	ds,ax			;
	mov	ax,PAGET_GSEL  		; PAGET segment
	mov	es,ax
	assume	ds:R_CODE

	mov	eax,0C0000000h		; assume WEITEK map on
	test	[Weitek_State],fWeitek_Map ;Q: WEITEK on?
	jnz	short UHMAcont		   ; Y: WEITEK map

	xor	eax,eax			; assume A20 disabled
	test	[Current_State],fState_A20Ena ;Q: Enable A20?
	jz	short UHMAcont		      ; N: wrap with page tables
	mov	eax,[HMAptr]		      ; Y: no wrap (functional HMA)
;QLEO	mov	eax,100000h		      ; Y: no wrap (start at 1Meg)
UHMAcont:
	mov	edi,100h		; ES:DI*4 -> PTE for 1Meg linear
	mov	cx,10h			; 64k worth of entries
UHMAloop:
	and	dword ptr es:[edi*4],0FFFh ; do not disturb the user bits
	or	es:[edi*4],eax
	inc	di
	add	eax,1000h		; EAX = next physical page (with attrs)
	dec	cx			; dec/jnz faster than loop!!!
	jnz	short UHMAloop		; loop until done with PTEs?

	mov	eax,cr3			; clear the TLB !!!
	mov	cr3,eax

	pop	ds
	pop	es
	pop	edi
	pop	ecx
	pop	eax
	assume ds:_DATA, es:_DATA
	ret

UpdateHMA	endp

;******************************************************************************
;**	ExitVirtual - clean up when leaving virtual mode operation
;
;	    **** THIS IS A FAR ROUTINE ****
;
;	ENTRY	PROTECTED MODE
;		DS -> _DATA
;
;	EXIT	PROTECTED MODE
;
;	USES	flags
;
;******************************************************************************
ExitVirtual	proc	far

;
;  DMA/bus master services are not needed in real mode
;
	push ds

	push DATA32_GSEL
	pop ds
	assume ds:ABS0

	and [DBSflag],not fDBSactive   ; deactivate DMA/bus master interface
	pop ds

ifdef PICtrap
	call	ExitVirtPIC	; remap PIC vectors to real mode value
endif

	call	ExitEGA
	ret
ExitVirtual	endp

;******************************************************************************
;**	ExitEGA - EGA related initialization for entering Virtual Mode
;
;	ENTRY	PROTECTED MODE
;		R_CODE:[PrevInt10+2] -> C000h
;		R_CODE:[EGA_Seg] = saved EGA segment (E000h)
;		Int 1f and Int 43h vectors' segment don't point to E000h
;
;	EXIT	PROTECTED MODE
;		R_CODE:[PrevInt10+2] -> R_CODE:[EGA_Seg]
;		Int 1f and Int43h vector's segments -> E000h if they
;		pointed to C000h.
;
;	USES	flags
;
;******************************************************************************
ExitEGA proc	near

	push	ax
	push	ds
	push	fs

	mov	ax,RCODEA_GSEL
	mov	ds,ax
	ASSUME	DS:R_CODE

	mov	ax,R1CODEA_GSEL
	mov	fs,ax
	ASSUME	FS:R1_CODE


	test	[Current_State],fState_CEGAmove	;Q: EGA moved ?
	jz	SHORT XEGA_exit			; N: leave

	test	[Current_State],fState_WinCntrl	;Q: Window Interface?
	jnz	short XEGA_exit			; Y: don't use E000!

	mov	word ptr fs:[PrevInt10+2],0E000h;  Y: seg back to 0E000h
	push	es
	mov	ax,RM_IDT_GSEL
	mov	es,ax		; ES -> 0
	ASSUME	ES:ABS0
	cmp	es:[int5+2],0C000h	;Q: Int 5 (print screen) -> EGA ROM ?
	jne	short XEGA_chk1F	;  N: chk 1Fh vector
	mov	es:[int5+2],0E000h	;  Y: point it to E000h
XEGA_chk1F:
	cmp	ES:[int1F+2],0C000h	;Q: int 1f moved ?
	jne	SHORT XEGA_chk43	;  N: chk 43h vector
	mov	ES:[int1F+2],0E000h	;  Y: point it to E000h
XEGA_chk43:
	cmp	ES:[int43+2],0C000h	;Q: int 43 moved ?
	jne	SHORT XEGA_chk6d	;  N: chk 6dh vector
	mov	ES:[int43+2],0E000h	;  Y point it to E000h
XEGA_chk6d:
	cmp	ES:[int6d+2],0C000h	;Q: int 6d moved ?
	jne	SHORT XEGA_vecdone	;  N: vectors patched
	mov	ES:[int6d+2],0E000h	;  Y point it to E000h
XEGA_vecdone:
	pop	es
	ASSUME	ES:_DATA
XEGA_exit:
	pop	fs
	assume	fs:nothing
	pop	ds
	ASSUME	DS:_DATA
	pop	ax
	ret
	ret
ExitEGA endp

_TEXT	ends

	page
R_CODE	SEGMENT
	assume cs:R_CODE, ds:R_CODE, es:R_CODE

;******************************************************************************
;		R_CODE CODE
;******************************************************************************

;******************************************************************************
;	FarGoVirtual - far link for GoVirtual
;
;	NOTE: this is a FAR routine.
;
;    ENTRY:	Real Mode
;
;    EXIT:	Virtual Mode
;		VDM state variables initialized
;
;    USED:	none
;
;******************************************************************************
FarGoVirtual	proc	far
	call	GoVirtual
	ret
FarGoVirtual	endp

;******************************************************************************
;	GoVirtual - go to virtual mode
;
;    ENTRY:	Real Mode
;
;    EXIT:	Virtual Mode
;		VDM state variables initialized
;
;    USED:	none
;
;******************************************************************************
GoVirtual	proc	near
	pusha
	push	ds
	push	es
	push	fs
	push	gs
	pushf

;
;  chk on current state of A20
;
	call	ChkA20

;
; Go to protected mode
;
	cli				;;; no ints now
	call	GoProtMode
	jc	short GVerror

;
; initialize VDM variables
;
	PCall	VDMC_GSEL,_TEXT:EnterVirtual
;
; Go to Virtual Mode
;
	call	GoVirtualMode
;
; now in virtual mode, return
;
	popf
	clc

GVexit:
	pop	gs
	pop	fs
	pop	es
	pop	ds
	popa
	ret

GVerror:
	popf
	stc
	jmp	short GVexit

GoVirtual	endp

;******************************************************************************
;***	ChkA20 - check current state of Enable A20
;
;	This routine checks the current state of the A20 line by reading
;	the Output Port of the 8042 and testing the state of the A20 enable
;	bit.  NOTE: This routine uses the COMPAQ specific 8042 Special Read
;	command.
;	ENTRY	Real Mode
;	EXIT	R_CODE:[Current_State]	- fState_A20Ena = 0 if A20 disabled
;							= 1 if A20 enabled
;	USES	none
;******************************************************************************
ChkA20	proc	near

	push	ax
	push	bx
	push	ds
	push	es
	push	di
	push	si

	call	Cache_Off		 ; if cache, turn it off (status in bx)

;
;  Check if HMA is wrapped into the IVT area
;
	or	cs:[Current_State],fState_A20Ena ; assume A20 is enabled
ifdef MSFLAG
	push	bx			; save regs destroyed by XMM call

	mov	ah, XMM_QUERY_A20
	push	seg R_CODE
	pop	ds
	call	[XMMcontrol]

	pop	bx			; restore regs
	or	ax, ax			; Q: is A20 enabled
	jnz	short CA20_exit		; Y: A20 is enabled
					; N: A20 is disabled
	and	cs:[Current_State],not fState_A20Ena
else
	xor	ax,ax			; DS=0h and ES=FFFFh
	mov	ds,ax
	not	ax
	mov	es,ax
	xor	si,si			; compare 0:0 and FFFF:10

	pushf
	cli

	mov	ax,es:[si+10h]		; get HMA location
	cmp	ax,ds:[si]		;Q: Same as IVT location?
	jne	short CA20cont		; N: A20 is enabled

	inc	ax
	mov	es:[si+10h],ax		; change the HMA location
	dec	ax

	cmp	ax,ds:[si]		;Q: Did the IVT location change?
	mov	es:[si+10h],ax		; - restore HMA location
	je	short CA20cont			    ; N: A20 is enabled
	and	cs:[Current_State],not fState_A20Ena; Y: A20 is disabled

CA20cont:
	popf
endif

CA20_exit:

	mov	ax,0F000h		 ;look at ROM mem struct
	mov	es,ax			 ;ROM seg

	cmp	word ptr es:[0FFE9h],'C3';Q: ROM ID Compaq 386?
	jne	short nocache 		 ; N: can't have cache then

	test	cs:[GenFlags], fCPQ16	 ; M008: Q: is this a compaq deskpro 
					 ; M008: 386/16
	jnz	short nocache		 ; M008: Y: no cache

	cmp	bx,0E201h		 ; Q: was cache enabled upon entry?
	jne	SHORT nocache 		 ;   N:
	mov	ax,0F401h		 ;   Y: restore by enabling
	int	16h			 ;

nocache:
	pop	si
	pop	di
	pop	es
	pop	ds
	pop	bx
	pop	ax
	ret
ChkA20	endp

ifdef MSFLAG

;---------------------------------------------------------------------------
;
; Procedure Name : GetA20cnt
;
; Determines the enable count in himem by disabling a20 util it is disabled
;
; ENTRY : NONE
; EXIT  : EnableCount has the actual himem enable count
;	  If we are unable to turn a20 OFF then EnableCount=0
;
; USES  : NONE
;
;------------------------------------------------------------------------

GetA20cnt	proc NEAR

	test	cs:[Current_State], fState_WinCntrl
					; Q: is windows making a virtual
					;    enable call
	jnz	GA_done			; Y: enable count is same as what it
					;    was when windows turned us OFF

	push	cx
	push	bx
	push	ax

    ;
    ; loop locally disabling A20, until it is actually disabled  (to count
    ;	enables)
    ;
	xor	cx, cx
	xor	bx,bx
GA_dis:
	call	DisableA20
	jc	A20_disabled	    ; function failed
	inc	cx
	xor	bx,bx		    ; Assume bomb out (zero "ons" count)
	cmp	cx,1000h	    ; Reached RIDICULOUS value?
	ja	short A20_disabled  ; YES, give the hell up.....
	mov	ah, XMM_QUERY_A20
	call	cs:[XMMcontrol]
	or	ax, ax		    ; Q: is A20 really disabled
	jnz	short GA_dis	    ; N: disable again
				    ; Y: A20 is disabled we have enable count

; redo the enables
	push	cx		    ; Save ons count
GA_en:
	call	EnableA20
	loop	GA_en
	pop	bx
A20_disabled:
	mov	cs:[EnableCount], bx ; store current enable count

	pop	ax
	pop	bx
	pop	cx

GA_done:
	ret

GetA20cnt	endp

;---------------------------------------------------------------------------
;
; Procedure Name	: SetA20cnt
;
; Set's up HIMEM's enablec count to EMM386's enable count. This is called
; when EMM386 is turning OFF
;
; ENTRY: NONE
; EXIT : Himem's enable count = Emm386's
;	 If we are unable to turn A20 Off then Himem's enable count != Emm's
;
; USED : NONE
;
;
;---------------------------------------------------------------------------

SetA20cnt	proc	near

	test	cs:[Current_State], fState_WinCntrl
					; Q: is windows making a virtual
					;    disable call
	jnz	SA_fin			; Y: windows has already obtained
					;    enable count from us

	push	ax
	push	cx
	push	bx

	xor	cx,cx

SA_dis:
	call	DisableA20
	inc	cx
	cmp	cx, 01000h	    ; guard against possibility of A20 line
				    ; not getting disabled at all
	ja	SA_done
	mov	ah, XMM_QUERY_A20
	call	cs:[XMMcontrol]
	or	ax, ax		    ; Q: is A20 really disabled
	jnz	short SA_dis	    ; N: disable again
				    ; Y: A20 is disabled (HIMEM's enablecount
				    ;    is 0

	cmp	cs:[EnableCount], 0 ; Q: is our enable count 0
	je	SA_done		    ; Y: done. we're coherent with Himem
				    ; N: make Himem's enable count = ours

	mov	cx, cs:[EnableCount]
SA_en:
	call	EnableA20
	loop	SA_en

SA_done:
	pop	bx
	pop	cx
	pop	ax

SA_fin:
	ret

SetA20cnt	endp

endif

;******************************************************************************
;**	SelToSeg - convert selector to a segment number
;
;	The protected mode selector value is converted to a
;	real mode segment number.
;
;	ENTRY	PROTECTED MODE
;		BX = selector
;
;	EXIT	AX = segment number
;
;	USES	BX, Flags, other regs preserved
;
;******************************************************************************
SelToSeg proc near
	push	ds
	mov	ax,GDTD_GSEL		; selector is in the GDT
	mov	ds,ax
	and	bl,0F8h

	mov	ax,word ptr ds:[bx + 2] ; low 16 bits of base address
	mov	bh,ds:[bx + 4]		; high 8 bits of base address
	shr	ax,4
	shl	bh,4
	mov	bl,0
	add	ax,bx			; AX = segment number for selector
	pop	ds
	ret
SelToSeg endp


R_CODE	ENDS

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\vdisk.inc ===
ifndef INC_LIST
.xlist
endif
;=============================================================================
;==
;== (C) Copyright MICROSOFT Corp. 1989-1991
;== (C) Copyright COMPAQ Computer Corp. 1989-1991
;==
;==	Title:	EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;==
;==	Module: VDISK.INC - VDISK equates and structures for detecting them
;==
;==	Version: 1.00
;==
;==	Date:	October 5, 1989
;==
;==	Author: Leo Cohen
;==
;=============================================================================
;==
;==	Change Log:
;==
;==	DATE	 REVISION	Description
;==	-------- --------	--------------------------------------------
;==     08/22/89 0.00	        Original
;==
;=============================================================================

;=============================================================================
;==			VDISK Header Structure
;== 	(used only for searching for previously installed VDISK's)
;=============================================================================
VDISKheader  	struc
		dd	-1		; Pointer to next device
		dw 0000000000000000b	; Attribute word
;		   ^^^ ^----------------- 11: O/C/RM not supported
;		   |||------------------- 13: IBM format
;	 	   ||-------------------- 14: IOCTL not supported
;	 	   |--------------------- 15: Block device
		dw	0		; Entry point of strategy routine
		dw	0		; Entry point of 'interrupt' routine
		db	8 dup (0)	; Name field - 0 units
  V_VDISK 	db	'VDISK'		; VDISK Header label
  V_VER   	db	'  V2.0'        ; VDISK version
  V_TYPE	db	28h,0,0,0,0,0,0,0,0,0,0,0,60h,086h,09h
  V_ADDRLO 	dw	0000h		; Bits 15:00
  V_ADDRHI 	db	10h		; Bits 23:16
VDISKheader  	ends

;=============================================================================
;==			Structure for BOOT record
;== 	(not used, left over from old CEMM by Steve Preston)
;=============================================================================
BOOTS	struc
		db	3 dup(?)	; Jump instr or 0,0,0 if non-bootable
  OEMS		db	8 dup(?)	; Oem name
  BYTBS		dw	?		; Bytes per sector
  SECAU		db	?		; Sectors per allocation unit
  RSSEC		dw	?		; Reserved sectors
  FTNUM		db	?		; Number of fats
  DENUM		dw	?		; Number of directory entries
  TLSEC		dw	?		; Total sectors
  MEDES		db	?		; Media descriptor
  NUMFT		dw	?		; Number of fat sectors
  SECTK		dw	?		; Sectors per track
  NUMHD		dw	?		; Number of heads
  NUMHS		dw	?		; Number of hidden sectors
  BPBEXT	dw	?		; Extended memory allocated
BOOTS	ends				; End of structure

.list ; end of VDISK.inc

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\vdminit.asm ===
.386p
page	58,132
;******************************************************************************
	title	VDM_Init - VDM initialization module
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
;   Module:   VDM_Init - VDM initialization routine
;
;   Version:  2.00
;
;   Date:     June 3,1986
;
;   Author:	Steve Preston
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   06/03/86  Original	from VDM MAIN.ASM module
;   06/16/86  0.01	Added code to dword align LL buffer(SBP).
;   06/21/86  0.02	moved cld in init_pages (SBP) and save Eax.
;   06/28/86  0.02	Name change from CEMM386 to CEMM (SBP).
;   07/06/86  0.04	changed assume to _DATA and moved stack out of
;			_DATA (SBP).
;   07/10/86  0.05	Init of RCODEA_GSEL (SBP).
;   07/10/86  0.05	Added PageT_Seg (SBP).
;   05/08/87  2.00	Added init of RCODE_GSEL and RSS_GSEL (SBP).
;   10/12/88  3.32 (*D) Add VCPI code (DJM).
;   10/12/88  3.32 (*D) Fix math error by linker (RDV).
;   08/23/89  4.10      Initialize PAGED_GSEL to point to page directory (LC)
;   08/23/89  4.10	Initialize PTE's so linear = physical addresses (LC)
;
;******************************************************************************
;
;   Functional Description:
;
;	This module is the general initialization module for the Virtual DOS
;   Monitor part of CEMM.  This module initializes the protected mode
;   GDT, IDT, TSS (and I/O BitMap), and the Page Tables.  This module also
;   initializes all variables used by the VDM code.  This module returns
;   to the calling routine in Virtual Mode.
;
;******************************************************************************
.lfcond 				; list false conditionals
;******************************************************************************
;	P U B L I C S
;******************************************************************************
	public	VDM_Init
	public	InitPages
	public	handle0_PTEs
	public	tempBuffer
;QEMS	public	tempAllocMap
;QEMS	public	tempAllocMapLen
;******************************************************************************
;	D E F I N E S
;******************************************************************************
	INCLUDE ALLOCMEM.INC
	INCLUDE EMM386.INC
	include VDMseg.inc
	include VDMsel.inc
	include desc.inc
	include page.inc
	include emmfunct.inc
	include emmdata.inc
;******************************************************************************
;	E X T E R N A L   R E F E R E N C E S
;******************************************************************************

_TEXT SEGMENT

extrn	InitBitMap:far	; (vminit.asm)
EXTRN	TotalFreeMem: NEAR
EXTRN	MemGet: NEAR

_TEXT	ENDS

GDT	SEGMENT
extrn	GDTLEN:abs
GDT	ENDS

IDT	SEGMENT
extrn	IDTLEN:abs
IDT	ENDS

LAST	SEGMENT
extrn	PICInit:near
extrn	SetSegDesc:near
extrn	SegTo24:near
extrn	TotalFreeMem:near
extrn	DoMoveBlock:near
extrn	EstWorkSpace:near
extrn	SaveResetVector:near
extrn	NumOfUMBwindows:byte
extrn	Page4K:byte
extrn	UMBtable:byte
extrn	ext_mem:dword
extrn	HMAonSet:byte
extrn	max_pool_size:word
tempBuffer	DD	1024 DUP (0)
handle0_PTEs	DW	0
ifndef LC910611	; extra room for systems with 256K base memory and require backfill
Handle0_UMBs	dd	128 dup (0)
else
Handle0_UMBs	dd	64 dup (0)
endif

;QEMS tempAllocMap	dw	(((100000h shr 12) shr 3) shr 1) dup (0)
;QEMS tempAllocMapLen	equ	$-tempAllocMap

LAST	ENDS

R1_CODE	segment
	extrn	Int10_Hook: near
	extrn	Int11_Hook: near
	extrn	PrevInt10:dword
	extrn	PrevInt11:dword
R1_CODE	ends


;******************************************************************************
;	S E G M E N T	D E F I N I T I O N S
;******************************************************************************

;
;   code
;
LAST SEGMENT

	assume cs:LAST,ds:_DATA,es:_DATA,gs:R_CODE

;******************************************************************************
;	VDM_Init - VDM initialization routine
;
;
;    ENTRY:	Real Mode
;		DS = _DATA
;		GDT = GDT segment
;TSSQLEO	TSS = TSS segment
;
;    EXIT:	Real Mode
;		VDM Tables initialized
;		TSS initialized
;
;    USED:	none
;
;******************************************************************************
VDM_Init	proc	near
;
	pushf
	pushad
	cli

	call	SaveResetVector	; trap execution at the reset vector (F000:FFF0)
	call	VirHMA		; allocate memory for possible virtual HMA
	call	InitGdt 	; initialize GDT descriptors
;
;  initialize Page Table, I/O Bit Map and LIM h/w emulator
;
	call	InitPages		; initialize paging tables
	call	InitBitMap		; initialize I/O Bit Map
	call	InitWEITEK		; initialize Weitek hook (Int 11h)
	call	PICInit			; trap PIC I/O ports
;
;  initialize TSS,GDTR,IDTR
;
;	set ring 0 SS:SP in the TSS so we can take outer ring traps

	movzx	eax,gs:[StackTop]
	mov	[TSS].TSS386_ESP0,eax
	mov	[TSS].TSS386_SS0,VDMS_GSEL
;
; now set CR3 in the TSS
;
	mov	eax,cr3
	and	eax,0FFFh		; clear address bits
	or	eax,[page_directory]	; EAX = page dir 32 bit addr
	mov	dword ptr [TSS].TSS386_CR3,eax ; mov EAX into CR3 spot in TSS

ifdef TSSQLEO
	mov	ax, seg TSS
	mov	es,ax			; ES -> TSS
	xor	di,di			; ES:DI -> TSS

	movzx	eax,gs:[StackTop]
	mov	es:[di].TSS386_ESP0,eax
	mov	es:[di].TSS386_SS0,VDMS_GSEL

;LEO	mov	word ptr ES:[di.TSS386_ESP0lo],offset STACK:Stack0_top
;LEO	mov	word ptr ES:[di.TSS386_ESP0hi], 0

; now set CR3 in the TSS

	mov	eax,cr3
	and	eax,0FFFh		; clear address bits
	or	eax,[page_directory]	; EAX = page dir 32 bit addr
	mov	dword ptr ES:[di.TSS386_CR3],eax ; mov EAX into CR3 spot in TSS

endif ;TSSQLEO

;	clear the TSS busy flag

	mov	ax,seg GDT
	mov	es, ax			; DS:0 = ptr to gdt

	and	byte ptr es:[TSS_GSEL + 5], 11111101B
;
;  allocate scratch handle space
;
	movzx	eax,[NumberHandlePages]
	or	ax,ax			;Q: Did we allocate a handle space?
	jz	short VIexit		; N: exit
	shl	ax,10			; number of bytes needed
	mov	ebx,PARA_BOUNDARY	; paragraph boundede
	call	MemGet			; enough memory for a PTE per 16K page
	mov	[ScratchHandleSpace],ebx
	jnc	short VIexit
	or	[msg_flag],MEM_ERR_MSG
VIexit:
;
; and return
;
	popad
	popf
	ret
VDM_Init	endp

;**	InitGdt - initialise GDT
;
;	Some of the GDT is statically initialized. This routine
;	initializes the rest, except the LDT pointer which
;	changes dynamically, and the VDM stack which changes too.
;
;	ENTRY	GDT:0 = GDT to use.
;	EXIT	None
;	USES	All except BP
;
;	WARNING This code only works on a 286.
;		Designed to be called from real mode ONLY.

	public InitGdt
InitGdt proc near

	mov	ax,GDT
	mov	es,ax			; ES:0 -> gdt

	mov	ax,GDT
	call	SegTo24
	mov	cx,GDTLEN
	mov	ah,D_DATA0
	mov	bx,GDTD_GSEL
	call	SetSegDesc		; Set up GDT alias descriptor

	mov	ax,IDT
	call	SegTo24
	mov	cx,IDTLEN
	mov	ah,D_DATA0
	mov	bx,IDTD_GSEL
	call	SetSegDesc		; Set up IDT alias descriptor

ifdef TSSQLEO
	mov	ax,TSS
	call	SegTo24
	mov	cx,TSSLEN
	mov	ah,D_386TSS0
	mov	bx,TSS_GSEL
	call	SetSegDesc		; Set up TSS descriptor

	mov	ah,D_DATA0
	mov	bx,TSSD_GSEL
	call	SetSegDesc		; Set up TSS alias descriptor
endif

	mov	ax,seg _TEXT
	call	SegTo24
	mov	cx,0			; 0 = 64K size
	mov	ah,D_CODE0
	mov	bx,VDMC_GSEL
	call	SetSegDesc		; Set up VDM Code descriptor

	mov	ax,_TEXT
	call	SegTo24
	mov	cx,0			; 0 = 64K size
	mov	ah,D_DATA0
	mov	bx,VDMCA_GSEL
	call	SetSegDesc		; Set up VDM Code segment alias descr

	mov	ax,seg _DATA
	call	SegTo24
	mov	cx,0			; 0 = 64K size
	mov	ah,D_DATA0
	mov	bx,VDMD_GSEL
	call	SetSegDesc		; Set up VDM Data descriptor

	mov	ax, seg STACK		; set up Ring 0 stack
	call	SegTo24
	mov	cx, offset STACK:Stack0_top
	mov	ah, D_DATA0
	mov	bx, VDMS_GSEL
	call	SetSegDesc

	mov	ax, seg R_STACK		; set up base protected mode stack
	call	SegTo24
	mov	cx, offset R_STACK:RealStackTop
	mov	ah, D_DATA0
	mov	bx, RMS_GSEL
	call	SetSegDesc

	mov	ax,seg R_CODE
	call	SegTo24
	mov	cx,0			; 0 = 64K size
	mov	ah,D_CODE0
	mov	bx,RCODE_GSEL
	call	SetSegDesc		; Set up R_CODE Code descriptor

	mov	ax,R_CODE
	call	SegTo24
	mov	cx,0			; 0 = 64K size
	mov	ah,D_DATA0
	mov	bx,RCODEA_GSEL
	call	SetSegDesc		; Set up R_CODE segment alias descriptor

	mov	ax,R1_CODE
	call	SegTo24
	mov	cx,0			; 0 = 64K size
	mov	ah,D_CODE0
	mov	bx,R1CODE_GSEL
	call	SetSegDesc		; Set up R_CODE segment alias descriptor

	mov	ax,R1_CODE
	call	SegTo24
	mov	cx,0			; 0 = 64K size
	mov	ah,D_DATA0
	mov	bx,R1CODEA_GSEL
	call	SetSegDesc		; Set up R_CODE segment alias descriptor


	mov	ax,seg _DATA
	call	SegTo24
	mov	cx,0			; 0 = 64K size
	mov	ah,D_DATA0
	mov	bx,RSS_GSEL
	call	SetSegDesc		; Set up real mode SS alias

	xor	dx,dx							   ;LEO
	mov	al,0C0h			; only low 24 bits of address here!;LEO
	mov	cx,0			; 64k long                         ;LEO
	mov	ah,D_DATA0		; data segment                     ;LEO
	mov	bx,DIAG_GSEL                                               ;LEO
	call	SetSegDesc		; Set up IDT alias descriptor      ;LEO
	mov	byte ptr es:[bx][7],80h	; set high 8 bits of address       ;LEO
									   ;LEO
ifdef BugMode
	mov	ax, dcode		; debugger code segment
	call	SegTo24
	mov	cx,0
	mov	ah,D_CODE0
	mov	bx,DEBC_GSEL
	call	SetSegDesc

	mov	ax, ddata		; debugger data segment
	call	SegTo24
	mov	cx,0
	mov	ah,D_DATA0
	mov	bx,DEBD_GSEL
	call	SetSegDesc
endif

	ret
InitGdt endp

;******************************************************************************
; InitPages
;
; ENTRY
;	DS = _DATA
; EXIT
;	page_directory - 32 bit address for the page directory
;	page_tables - 32 bit address for the page tables
;
; DESCRIPTION
;	This routine initializes a page directory and the page tables.
;	Both of these are aligned on a physical 4k page boundary.
;
;	The page dir and table set up by this routine maps the linear
;	addresses for Virtual mode programs into physical addresses using
;	the following scheme.
;	Linear Addr		Physical Addr
;	00000000h - 000FFFFFh	00000000h - 000FFFFFh
;	00100000h - 0010FFFFh	00000000h - 0000FFFFh  (64k wraparound)
;	00110000h - 0100FFFFh	00100000h - 00FFFFFFh  (top 15Meg of phys)
;
;QLEO: This routine has been patched to death!  Needs to be rewritten!
;
;******************************************************************************
InitPages	proc near
	PUSHAD
	PUSH	DS
	PUSH	ES
	MOV	AX, _DATA
	MOV	DS, AX
	ASSUME	DS: _DATA

	MOV	AX, LAST
	MOV	ES, AX
	ASSUME	ES: LAST		; ES is now LAST

ifndef LC910610
IPStart:
endif
	cmp	gs:[NoEMSset],FALSE	;Q: EMS available?
	jne	short no_base_memory	; N: no base memory

	CMP	[xma2ems], TRUE
	JE	SHORT no_base_memory

	MOV	AX, [end_of_base_memory_PTE]
	SUB	AX, [strtng_bs_wndw_PTE]; STARTING_BASE_WINDOW_PTE
	MOV	ES:[handle0_PTEs], AX	; # of 4K pages allocated to handle 0

no_base_memory:
	; *** Get the size of the unallocated memory
	; EAX = TotalFreeMem();
	CALL	TotalFreeMem
	SHR	EAX, 10			; Size in K bytes

	cmp	es:[ext_mem],FREE	;Q: Is L=ddd set?
	je	short IPcont		; N: no adjustment necessary
	mov	ebx,es:[ext_mem]	; Y: subtract memory that must be left

	sub	eax,ebx                 ;Q: Enough memory left over?
	jbe	allocErr		; N: no memory!

IPcont:
	CMP	EAX, MAX_SIZE		; Is size too big?
	JA	SHORT usePoolSize	; Y: use max_pool_size

	; *** Get the minimum of the two
	; if (EAX > max_pool_size) EAX = max_pool_size;
	CMP	AX,cs:[max_pool_size]	; Q: Is totalFree <= max_pool_size
	JBE	SHORT useTotalFree	; Y: use totalFree
usePoolSize:
	MOVZX	EAX, WORD PTR [max_pool_size] ; N: use max_pool_size

	; *** Get the number of PHs needed
useTotalFree:
	SHR	AX, 2
	ADD	AX, ES:[handle0_PTEs]
	SHR	AX, 2			; Rounded down to multiple of 16K

	ADD	AX, 0FFh		; Number of
	SHR	AX, 8			; PHs needed
	MOV	CX, AX			; Save PHs
	SHL	AX, 10			; Number of entries for PHs	;@PIW
ifdef QEMS
	MOV	[PH_entries], AX	; Save the number of entries	;@PIW
	MOV	[PH_boundary], AX	; Beyond the PHs boundary	;@PIW
	ADD	[PH_boundary], FIRST_HANDLE_PTE ; The limit of PHs	;@PIW
endif
	SHR	AX, 10			; Restore PHs			;@PIW

	; The logical handle PTE space is initialized.
;QEMS	mov	[starting_handle_PTE],FIRST_HANDLE_PTE
;
; Number of handle PTEs are calculated by the number of PHs
;
	mov	[NumberHandlePages],ax	; used to map handle space in PD

	; *** Get the number of PTs needed
	MOV	EBX, TopOfPhysicalMemory; Total system memory
	ADD	EBX, 4*1024*1024-1
	SHR	EBX, 22			; PTs needed

	MOV	DI, BX			; Save PTs

; The number of pages tables actually needed is now determined based on how
; much handle space is required.  AX is the number of unneeded page tables.

; Need to save in [number_page_tables], just the PTs and not the PHs space.

;QEMS	mov	gs:[number_page_tables], BX

; *** Allocate memory for page directory and page tables
; PD_addr = MemGet(PAGE_BOUNDARY, PD_size+PT_size);
	ADD	AX, 3			; PD, PTF0, and PTF1
	ADD	AX, BX			; Total tables (MAX=3+PHs+PTs)
	MOV	DX, AX			; For PAGED_GSEL
	SHL	EAX, 12			; Each table needs 4K bytes
	MOV	EBX, PAGE_BOUNDARY

	CALL	MemGet
	JC	allocErr

	; *** Save page directory address
	MOV	[page_directory], EBX

ifndef LC910610
;
;  Make sure page tables are not in HMA so that A20 state is not a concern
;
	cmp	ebx,110000h		;Q: In HMA?
	jb	IPStart			; Y: try again
endif
	PUSH	EBX

	; *** Set PAGED_GSEL
	MOV	AX, GDT
	MOV	ES, AX
	ASSUME	ES: GDT			; ES is now GDT

	MOV	SI, PAGED_GSEL
	DEC	DX			; Limit = size - 1
	MOV	ES:[SI], DX		; Limit
	MOV	ES:[SI+2], BX		; Base low
	SHR	EBX, 16
	MOV	BYTE PTR ES:[SI+4], BL	; Base medium
	MOV	BYTE PTR ES:[SI+5], D_DATA0 ; P-DPL-S-type
	MOV	BYTE PTR ES:[SI+6], 80h	; Granularity bit set
	MOV	BYTE PTR ES:[SI+7], BH	; Base high

	; *** Get page directory address
	POP	EBX

	; *** Set PAGET_GSEL
	MOV	EAX, 3			; PD, PTF0 and PTF1
	ADD	AX, CX			; Number of PH tables
	SHL	AX, 12			; Each table needs 4K bytes
	ADD	EBX, EAX		; Page table address
	; *** Save page table address
	MOV	[page_tables], EBX
	MOV	SI, PAGET_GSEL
	MOV	DX, DI			; Number of PTs to be initialized
	DEC	DI			; Limit = size - 1
	MOV	ES:[SI], DI		; Limit
	MOV	ES:[SI+2], BX		; Base low
	SHR	EBX, 16
	MOV	BYTE PTR ES:[SI+4], BL	; Base medium
	MOV	BYTE PTR ES:[SI+5], D_DATA0 ; P-DPL-S-type
	MOV	BYTE PTR ES:[SI+6], 80h	; Granularity bit set
	MOV	BYTE PTR ES:[SI+7], BH	; Base high

	MOV	AX, LAST
	MOV	ES, AX
	ASSUME	ES: LAST		; ES is now LAST

	; *** Initialize PD
	; Page directory contains the physical address of page tables
	; DX: the number PTs present
	MOV	DI, OFFSET tempBuffer
	MOV	EAX, [page_tables]
	OR	AX, P_AVAIL
	MOV	CX, DX			; Number of PTs
	CLD
initPD:
	STOSD
	ADD	EAX, PAGE_SIZE
	LOOP	initPD

	; *** Move to extended memory
	; CY = !MoveBlock(ESI, EDI, CX);
	XOR	ESI, ESI
	MOV	SI, LAST
	SHL	ESI, 4
	ADD	ESI, OFFSET tempBuffer
	MOV	EDI, [page_directory]
	MOV	CX, PAGE_SIZE
	CALL	DoMoveBlock
	JC	moveErr

	; *** Initialize PHs
	; Handle 0 has 24 16KB physical pages (256K-640K)
	MOV	DI, OFFSET tempBuffer
	MOVZX	EAX, [strtng_bs_wndw_PTE]
	SHL	EAX, 12
	OR	EAX, P_AVAIL
	cmp	gs:[NoEMSset],TRUE	;Q: Is it in [NoEMS] mode?
	je	initPTx			; Y: no PHs init PTs
	CMP	[xma2ems], TRUE		; Q: Is it in XMA2EMS mode?	;@PIW
	JE	SHORT not_allocated	; Y: Handle allocated bit clear	;@PIW
;QEMS	OR	EAX, HANDLE_ALLOCATED_BIT_SET				;@PIW
not_allocated:								;@PIW
	MOV	CX, ES:[handle0_PTEs]
;QLEO	JCXZ	SHORT no_handle0_PTE					;@PIW
	or	cx,cx
	jz	no_handle0_PTE
initPH0s:
;
; QLEO: Need to get address of back-filled RAM for Handle Space.
;
	cmp	[NumOfUMBwindows],0
	je	PHstep0E

	pushad
	movzx	ecx,cs:[NumOfUMBwindows]
	shr	eax,12
PHstep0A:
	cmp	cs:[UMBtable][ecx-1],al
	je	short PHstep0B
	loop	PHstep0A
	jmp	PHstep0D
PHstep0B:
	push	eax
	call	EstWorkSpace		; work space needed for code/data
	add	ebx,EMS_PAGE_SIZE
	add	ebx,10000h		; leave 64K for EMS

	call	TotalFreeMem		; get free memory available
	cmp	eax,ebx			;Q: Enough memory for UMB?
	pop	eax
	jb	PHstep0C		; N: no more UMB memory available
	shl	eax,12
	mov	esi,eax			; starting linear address for UMB
	mov	eax,EMS_PAGE_SIZE
	mov	ebx,EMS_BOUNDARY
;QEMS	mov	eax,PAGE_SIZE
;QEMS	mov	ebx,PAGE_BOUNDARY

	call	MemGet
	jc	PHstep0C		; if error, No UMB memory
	mov	cs:[Handle0_UMBs][ecx*4-4],ebx
	mov	cs:[Handle0_UMBs][ecx*4],ebx
	mov	cs:[Handle0_UMBs][ecx*4+4],ebx
	mov	cs:[Handle0_UMBs][ecx*4+8],ebx
	add	cs:[Handle0_UMBs][ecx*4+0],1000h
	add	cs:[Handle0_UMBs][ecx*4+4],2000h
	add	cs:[Handle0_UMBs][ecx*4+8],3000h
	push	edi			; save pointer to current PTE
	mov	edi,ebx			; starting physical address for UMB
	mov	ecx,EMS_PAGE_SIZE	; copy original contents to physical RAM
;QEMS	mov	ecx,PAGE_SIZE		; copy original contents to physical RAM
	call	DoMoveBlock
	pop	edi			; restore current PTE entry
	mov	eax,ebx
	shr	esi,12			; linear page
;QEMS	or	ax,HANDLE_ALLOCATED_BIT_SET+P_AVAIL
	or	ax,P_AVAIL+fEMSPageAllocated
	stosd
	and	ax,not fEMSPageAllocated
	add	eax,1000h
	stosd
	add	eax,1000h
	stosd
	add	eax,1000h
	stosd
	popad
	add	di,16
	add	eax,EMS_PAGE_SIZE
	dec	cx
	jnz	initPH0s
	jmp	short no_handle0_PTE
PHstep0C:
	mov	cs:[UMBtable][ecx-1],0	; not a valid UMB
	or	gs:[msg_flag],UMBmem_Msg; error message
PHstep0D:
	popad
;QEMS	jmp	short PHstep0E
PHstep0E:
	test	ah,30h			;Q: 16K boundary?
	jnz	short PHcont		; N: don't mark EMS allocated
	or	ax,fEMSPageAllocated
PHcont:
	STOSD
	and	ax,not fEMSPageAllocated
PHstep0F:
	ADD	EAX, PAGE_SIZE
;QLEO	LOOP	initPH0s
	dec	cx
	jnz	initPH0s
no_handle0_PTE:								;@PIW
	XOR	EAX, EAX
	MOV	CX, 1024		; Number of entries per table
	SUB	CX, ES:[handle0_PTEs]
initPHs0a:
	STOSD
	LOOP	initPHs0a

	; *** Move to extended memory
	; CY = !MoveBlock(ESI, EDI, CX);
	XOR	ESI, ESI
	MOV	SI, LAST
	SHL	ESI, 4
	ADD	ESI, OFFSET tempBuffer
	MOV	EDI, [page_directory]
	ADD	EDI, FIRST_HANDLE_PTE SHL 2
	MOV	CX, PAGE_SIZE
	CALL	DoMoveBlock
	JC	moveErr

;
;  Initialize PH1-7 with zero's (clear buffer)
;
	XOR	EAX, EAX
	MOV	DI, OFFSET tempBuffer
	MOV	CX, 1024		; Number of entries per table
initPHs1:
	STOSD
	LOOP	initPHs1

	; *** Move to extended memory
	; CY = !MoveBlock(ESI, EDI, CX);
	XOR	ESI, ESI
	MOV	SI, LAST
	SHL	ESI, 4
	ADD	ESI, OFFSET tempBuffer
	MOV	EDI, [page_directory]
	ADD	EDI, FIRST_HANDLE_PTE SHL 2
	MOV	CX, [NumberHandlePages]
	DEC	CX
	JCXZ	SHORT initPTx
initPHs1a:
	PUSH	CX
	MOV	ECX,PAGE_SIZE
	ADD	EDI,PAGE_SIZE		; next PH
	CALL	DoMoveBlock
	JC	moveErr
	POP	CX
	LOOP	initPHs1a

initPTx:
	; *** Initialize PTs
	; Page tables contain the physical address of pages
	; DX: the number PTs present
	MOV	EAX, P_AVAIL		; Pages are available
	MOV	EBX, [page_tables]	; Page table directory
initPTs:
	MOV	CX, 1024		; Number of entries per table
	MOV	DI, OFFSET tempBuffer	; Temporary buffer

	cmp	gs:[NoEMSset],TRUE	;Q: Is it in [NoEMS] mode?
	je	step1			; Y: skip this part

	CMP	[xma2ems], TRUE		; Q: Is it in XMA2EMS mode?	;@PIW
	JE	step1			; Y: Skip this part		;@PIW
; +++
	MOVZX	ESI, [strtng_bs_wndw_PTE]; Base window starts at 10..40
	SHL	ESI, 12			; It's in 4K chunk
	OR	SI, P_AVAIL		; Set it to available
initPT:
	CMP	EAX, ESI		; Q: Have we reach the end?	;@PIW
	JNE	step1			; N: Not yet			;@PIW

	MOV	SI, ES:[handle0_PTEs]	; Number of base window PTEs	;@PIW
	or	si,si
	jz	step1

;QEMS	OR	AX, PAGE_ALLOCATED_BIT_MASK ; Basw windows are allocated;@PIW
	SUB	CX, SI
step0:
	push	eax
	push	ecx

	cmp	[NumOfUMBwindows],0
	je	short step0C

	movzx	ecx,cs:[NumOfUMBwindows]
	shr	eax,12
step0A:
	cmp	cs:[UMBtable][ecx-1],al
	je	short step0B
	loop	step0A
	jmp	short step0C
step0B:
	mov	eax,cs:[Handle0_UMBs][ecx*4-4]
	or	ax,P_AVAIL
;QEMS	or	ax,P_AVAIL+PAGE_ALLOCATED_BIT_MASK ; RAM
	stosd
	shr	eax,12
;QEMS	bts	[tempAllocMap],ax	; Mark page allocated

	pop	ecx
	pop	eax
	jmp	short step0E
step0C:
	pop	ecx
	mov	eax,[esp]
	shr	eax,12
;QEMS	bts	[tempAllocMap],ax	; Mark page allocated
	pop	eax

	STOSD
step0E:
	ADD	EAX, PAGE_SIZE
	DEC	SI
	JNZ	short step0
;QEMS	AND	AX, NOT PAGE_ALLOCATED_BIT_MASK

step1:
	CMP	EAX, 0C0000h OR P_AVAIL	; Q: Is this C0000?		;@PIW
	JNE	SHORT step3		; N: Skip this part		;@PIW

	; SI = Check_CEGA();		; SI is number of pages to remap;@PIW
	CALL	Check_CEGA		; Q: Is the ROM there?		;@PIW
	JNC	SHORT step3		; N: Keep going			;@PIW
	SUB	CX, SI
	ADD	EAX, 20000h		; Change from C0000h to E0000h
step2:
	STOSD
	ADD	EAX, PAGE_SIZE
	DEC	SI
	JNZ	SHORT step2
	SUB	EAX, 20000h		; Change from E0000h to C0000h
step3:
	cmp	eax,100000h or P_AVAIL
	jae	step4

	cmp	[NumOfUMBwindows],0
	je	step4

	pushad
	movzx	ecx,cs:[NumOfUMBwindows]
	shr	eax,12
step3A:
	cmp	cs:[UMBtable][ecx-1],al
	je	short step3B
	loop	step3A
;QLEO	jmp	short step3F
	jmp	step3F
step3B:
	push	eax
	call	EstWorkSpace		; work space needed for code/data
	add	ebx,PAGE_SIZE
	cmp	gs:[NoEMSset],TRUE	;Q: NoEMS set?
	je	short step3C		; Y: memory not a factor
	add	ebx,10000h		; N: leave 64K for EMS
step3C:
	call	TotalFreeMem		; get free memory available
	cmp	eax,ebx			;Q: Enough memory for UMB?
	pop	eax
	jb	short step3E		; N: no more UMB memory available
	shl	eax,12
	mov	esi,eax			; starting linear address for UMB
	mov	eax,PAGE_SIZE
	mov	ebx,PAGE_BOUNDARY

	call	MemGet
	jc	short step3E		; if error, No UMB memory
	push	edi			; save pointer to current PTE
	mov	edi,ebx			; starting physical address for UMB
	mov	ecx,PAGE_SIZE		; copy original contents to physical RAM
	call	DoMoveBlock
	pop	edi			; restore current PTE entry
	mov	eax,ebx
	shr	esi,12			; linear page
	or	ax,P_AVAIL		; assume RAM
	test	cs:[Page4K][si],ROM	;Q: ROM: need write protection?
	jz	short Step3D		; N: continue
	and	ax,not P_WRITE		; Y: write protect the page
Step3D:
	stosd
	popad
	add	di,4
	jmp	short nextPTE
step3E:
	mov	cs:[UMBtable][ecx-1],0	; not a valid UMB
	or	gs:[msg_flag],UMBmem_Msg; error message
step3F:
	popad
	;jmp	 short step4
step4:
	cmp	eax,100000h
	jb	short step4A
	cmp	eax,110000h
	jae	short storePTE
	sub	eax,100000h		; create possible virtual HMA
	add	eax,gs:[HMAptr]
	stosd
	add	eax,100000h
	sub	eax,gs:[HMAptr]
	jmp	short nextPTE
step4A:

; EAX has a PTE for a non UMB page somewhere in the 1st Meg.  Check if
; this page as been selected as a WINdows page, and set the fWINpage
; bit if so.

	push	esi
	mov	esi, eax
	shr	esi, 12
	test	cs:[Page4K][si], WIN	; Q: WIN page?
	jz	short notWINpage
	or	ax, fWINpage		; Y: set fWINpage bit
	inc	[cntWinPages]		; and count how many there are
	stosd
	and	ax, NOT fWINpage
	pop	esi
	jmp	short nextPTE
notWINpage:
	pop	esi

storePTE:
	STOSD

nextPTE:
	ADD	EAX, PAGE_SIZE
	dec	cx
	jnz	initPT
	; *** Move to extended memory
	; CY = !MoveBlock(ESI, EDI, CX);
	XOR	ESI, ESI
	MOV	SI, LAST
	SHL	ESI, 4
	ADD	ESI, OFFSET tempBuffer
	MOV	EDI, EBX
	ADD	EBX, PAGE_SIZE
	MOV	CX, PAGE_SIZE
	CALL	DoMoveBlock
	JC	SHORT moveErr
	DEC	DX
	JNZ	initPTs
	JMP	SHORT return
moveErr:
	; To be continued...
allocErr:
	OR	GS:[msg_flag], MEM_ERR_MSG
return:
	POP	ES
	POP	DS
	POPAD
	RET
InitPages endp

;------------------------------------------------------------------------------
;	Check for E000h segment used for page frame
;	and for CEGA in system.
; EXIT: CY - if remap is necessary
;	SI - the number of pages to remap, valid only if CY is set.
;------------------------------------------------------------------------------
Check_CEGA	PROC
;	cmp	[PF_Base],0D000h			;Q: page frame > D000h ?
;	ja	short IT_E000 				;  Y: E000h used
;	jmp	IT_chkpt				;  N: E000h not used
;IT_E000:
	; Test would clear the carry flag, so no CLC is needed
	test	gs:[Current_State],fState_CEGAinst	;Q: CEGA installed ?
	jz	short IT_chkpt				;  N: nothing special
	PUSH	EAX
	push	fs
	mov	ax,seg R1_CODE
	mov	fs, ax
	assume	fs:R1_CODE

	or	gs:[Current_State],fState_CEGAmove	;  Y: we must move it
	;
	; Patch INT 10
	xor	ax,ax
	mov	ds,ax
	ASSUME	DS:ABS0
	mov	eax,dword ptr [int10] 		; EAX = old int10 vector
	mov	gs:[Int10_Save],eax	; save old vector

	; set int10 -> CEMM hook code

	mov	fs:[PrevInt10],eax	; set chain vector
	mov	ax, fs
	shl	eax,16
	mov	ax,offset R1_CODE:Int10_Hook
	mov	dword ptr [int10],eax 		; set int10 vector

	;
	; change page table entries for C0000-CxFFFh -> E0000h - ExFFFh
	;
	mov	ax,seg _DATA
	mov	ds,ax
	assume	ds:_DATA
	mov	SI,gs:[CROM_Length]	; length of opt rom in paras
	shr	SI,8			; length of opt rom in pages
	pop	fs
	assume	fs:nothing
	POP	EAX
	STC
IT_chkpt:
	RET
Check_CEGA	ENDP

;------------------------------------------------------------------------------
;	Check for Weitek installed
;------------------------------------------------------------------------------
InitWEITEK proc	near
	push	ds

	test	gs:[Weitek_State],fWeitek_Inst	;Q: Weitek installed ?
	jz	short IWexit			; N: don't patch int 11
						; Y: patch int 11h
	xor	ax,ax
	mov	ds,ax				; DS -> 0
	ASSUME	DS:ABS0

	push	fs
	mov	ax,seg R1_CODE
	mov	fs, ax
	assume	fs:R1_CODE

	shl	eax,16
	mov	ax,offset R1_CODE:Int11_Hook
	xchg	eax,dword ptr [int11] 		; EAX = old int11 vector
	mov	dword ptr fs:[PrevInt11],eax	; set chain vector

	pop	fs
	assume	fs:nothing

IWexit:
	pop	ds
	ret
InitWEITEK	endp

;==============================================================================
;==
;==  VirHMA: If virtual HMA has been specified, allocate 64K for it.
;==
;==  Entry: (Real Mode)
;==
;==  Exit:
;==	R_CODE:[msg_flag],MEM_ERR_MSG - set if no memory available
;==
;==============================================================================
VirHMA	proc	near
	push	eax
	push	ebx
	cmp	cs:[HMAonSet],TRUE	;Q: Virtual HMA desired?
	jne	short VHexit
;
;  Check if enough extended memory for virtual HMA
;
	call	EstWorkSpace		; work space needed for code/data
	add	ebx,8*1024*4		; space for PTs(4),PFs(2),PD(1),PH(1)
	add	ebx,10000h		; assume NoEMS set: 64K for for HMA
	cmp	gs:[NoEMSset],TRUE	;Q: NoEMS set?
	je	short VHcont		; Y: memory not a factor
	add	ebx,10000h		; N: leave 64K for EMS
VHcont:
	call	TotalFreeMem		; get free memory available
	cmp	eax,ebx			;Q: Enough memory for virtual HMA?
	jb	short VHnoMemory	; N: error
;
;  Get exteneded memory for virtual HMA
;
	mov	eax,10000h		; get 64K
	mov	ebx,PAGE_BOUNDARY	; on a page boundary

	call	MemGet        		;Q: Enough memory available?
	jc	short VHnoMemory	; N: return error code (don't load)
;
; Save physical pointer
;
	mov	gs:[HMAptr],ebx		; physical address
	mov	gs:[UMBHMA],TRUE	; don't allow CEMM to turn off

VHexit:
	pop	ebx
	pop	eax
	ret

VHnoMemory:
	or	gs:[msg_flag],UMBmem_MSG
	stc
	jmp	short VHexit
VirHMA	endp

LAST	ends

END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\vdmseg.inc ===
ifndef INC_LIST
.xlist
endif
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386 - MICROSOFT Expanded Memory Manager 386
;
;   Module:   VDMSEG.INC - Segment Ordering and attributes for VDM
;
;   Version:  0.04
;
;   Date:     May 12, 1986
;
;   Author:
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;	      Original
;   05/12/86  A-RRH	Cleanup and segment reorganization
;   06/03/86  C-SBP	changed order and added STACK and STACK0,STACK0_SIZE
;   06/06/86  C-SBP	changed CODE to _TEXT and DATA to _DATA
;   06/28/86  0.02	Name change from CEMM386 to CEMM (SBP).
;   07/05/86  0.04	Re-organized to allow code seg move (SBP).
;   10/12/88  3.32 (*D) VCPI added (DJM).
;
;******************************************************************************
;******************************************************************************
; SEGMENTS
;******************************************************************************

	; CODE area containing EMM/VDISK headers and writeable real mode code
R_CODE	segment para use16 public 'R_CODE'
R_CODE	ends

	;* Debugger Code and Data segments (if linked in)
dcode	segment public use16 word 'DCODE'
dcode	ends

ddata	segment public use16 word 'DDATA'
ddata	ends

	; Base memory stack
R_STACK	segment word use16 public 'R_STACK'
R_STACK	ends

R1_CODE	segment para use16 public 'R1_CODE'
R1_CODE	ends

	; Ring 0 stack in VDM
STACK	segment para use16 public 'STACK'
STACK	ends

	; Global Descriptor Table
GDT	segment para use16 common
GDT	ends

	; Local Descriptor Table
LDT	segment para use16 common
LDT	ends

	; Interrupt Descriptor Table
IDT	segment para use16 common
IDT	ends

ifdef TSSQLEO
	; Task State Segment
TSS	segment para use16 common
TSS	ends
endif

SGDT	segment para use16 common
SGDT	ends

SIDT	segment para use16 common
SIDT	ends

	; Contains initialized variables and variables used at startup.
_DATA	segment para use16 public 'DATA'
_DATA	ends

	; The code comprising the system.  Must be READ-ONLY in real mode.
_TEXT	segment para use16 public 'CODE'
_TEXT	ends

	; Initialization code and variables.  Used for data later.
	; Must be last segment.
LAST	segment para use16 public 'LAST'
LAST	ends

L_STACK	segment word use16 stack 'L_STACK'
L_STACK	ends

ABS0	segment USE16 at 0000h
	org 4*5h
int5	dw	?
	dw	?
	org 4*10h
int10	dw	?
	dw	?
	org 4*11h
int11	dw	?
	dw	?
	org 4*13h																															;LEO
int13	dd	?
	org 4*15h
int15	dd	?
	org 19h*4
int19	dd	?
	org 1Fh*4
int1F	dw	?
	dw	?
	org 21h*4
int21	dd	?
	org 2Fh*4
int2f	dd	?
	org 43h*4
int43	dw	?
	dw	?
	org 4*4Bh
int4B	dd	?
	org 4*6dh
int6d	dw	?
	dw	?
	org 67h*4
int67	dw	?
	dw	?
	org	47Bh
DBSflag	db	?
fDBSactive	equ	00100000b
fDBSchain	equ	00001000b
ABS0	ends

	;***	ROM BIOS data area, set up addresses
romdata segment use16 at 40h
	org	0Eh
pExtBIOS	dw	?
	org	10h
EqStatus	dw	?
	org	13h
Int12hMem	dw	?
	org	17h
KeyState	db	?
BreakState	db	?
AltKey		db	?
KbHead		dw	?
KbTail		dw	?
KbBuffer	dw	16 dup (?)
KbBufferEnd	label	word
	org	49h
VidMode 	db	?
	org	65h
VidReg		db	?
	org	71h
fBreak		db	?
fReset		dw	?
	org	80h
KbStart 	dw	?
KbEnd		dw	?
	org	97h
ATKbFlags	db	?
romdata ends

.list	; end of VDMSEG.INC

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\vcpi.asm ===
.386p
page	58,132
;******************************************************************************
	title	VCPI - VCPI function handler
;******************************************************************************
;
; (C) Copyright MICROSOFT Corp. 1988-1991
; (C) Copyright COMPAQ Computer Corp. 1988-1991
;
; Title:	EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;		EMMLIB.LIB - Expanded Memory Manager Functions Library
;
; Module:	VCPI Function Handler
;
; Version:	1.00
;
; Date:		August 11, 1988
;
; Authors:	Dan Mazina
;		Dick Vail
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   8/11/88	1	initial code
;   3/26/88   4.01	Improve performance
;******************************************************************************
;
;   Functional Description:
;	This module implements all of the functions for the VCPI interface.
;
;******************************************************************************

;******************************************************************************
; PUBLICS
;******************************************************************************
public	VCPIDispatcher
public	VCPISwitchToProtected
public	VCPIPresenceDetection
public	VCPIModeInterface
public	VCPIMaxPhysicalAddress
public	VCPICountFreePages
public	VCPIAllocatePage
public	VCPIFreePage
public	VCPIPagePhysicalAddress
public	VCPIReadCR0
public	VCPIReadDebugRegisters
public	VCPILoadDebugRegisters
public	VCPIRead8259Mappings
public	VCPISet8259Mappings
public	VCPISwitchToProtected

public	VCPIProtectedDispatcher
public	VCPIInvalidFunction
public	VCPICountFreePagesProt
public	VCPIAllocatePageProt
public	VCPIFreePageProt
public	VCPISwitchToV86
public	VCPIDispReturn
public	VCPIProtDispReturn
public	VCPIReturnFromProt

ifdef PICtrap
public	VCPIProgPIC
endif

;******************************************************************************
; INCLUDES
;******************************************************************************
include vdmseg.inc
include vdmsel.inc
include vm386.inc
include oemdep.inc
include emm386.inc
include emmfunct.inc
include emmdata.inc
include page.inc
ifdef BETA
include dbg.inc
endif
include desc.inc
include debmac.inc
page
;******************************************************************************
; DEFINES
;******************************************************************************

page
;******************************************************************************
; EXTERNALS
;******************************************************************************

_TEXT	segment
ifdef PICtrap
	extrn	ProgramPIC:near
endif
	extrn	pIRQ0Handler:far
	extrn	pIRQ1Handler:far
	extrn	pIRQ2Handler:far
	extrn	pIRQ3Handler:far
	extrn	pIRQ4Handler:far
	extrn	pIRQ5Handler:far
	extrn	pIRQ6Handler:far
	extrn	pIRQ7Handler:far
	extrn	pIRQ8Handler:far
	extrn	pIRQ9Handler:far
	extrn	pIRQ10Handler:far
	extrn	pIRQ11Handler:far
	extrn	pIRQ12Handler:far
	extrn	pIRQ13Handler:far
	extrn	pIRQ14Handler:far
	extrn	pIRQ15Handler:far

	extrn	AddFreeEMS:near
	extrn	GetFreeEMS:near
	extrn	GrowEMSPool:near
	extrn	ShrinkEMSpool:near
	extrn	AddFreeEMS_far:far
	extrn	GetFreeEMS_far:far
	extrn	GrowEMSPool_far:far
	extrn	ShrinkEMSpool_far:far
ifdef QEMS
	extrn	SetPT0Cntxt:near
	extrn	RestorePT0Cntxt:near
endif
ifdef DEBUG
	extrn	pTestDbgIns:far
	extrn	pDebugPrintf:far
endif
_TEXT	ends

R_CODE	segment
	extrn	MasterPICVec:word
	extrn	SlavePICVec:word

ifdef PICtrap
	extrn	VirMasterPICVec:word
	extrn	VirSlavePICVec:word
	extrn	MasterIS:word
	extrn	LastOCW3:byte
endif

	public	VCPIClientData
VCPIClientData	label	dword
client_cr2	dd	?	; save area for VCPI client context
client_cr3	dd	?
client_jmpfar	label	dword			    ; keep these 3 in order
		dw	offset R1_CODE:VCC_load_seg ; keep these 3 in order
client_cs	dw	?			    ; keep these 3 in order
client_ss	dw	?
client_esp	dd	?
client_gdtr	df	?
client_idtr	df	?
client_ldtr	dw	?
client_tr	dw	?
ret_addr	dw	?

R_CODE	ends

R1_CODE segment
	extrn	RealStack2_top:byte
R1_CODE ends

page
;******************************************************************************
; SEGMENTS
;******************************************************************************

_TEXT	SEGMENT
assume	cs:_TEXT,ds:_DATA,es:nothing,gs:R_CODE,ss:STACK,fs:nothing
;***********************************************************************
; This is the jump table used by VCPIDispatcher.
;***********************************************************************
dispatch_vector label	word
	dw	OFFSET	VCPIPresenceDetection	; function 0h
	dw	OFFSET	VCPIModeInterface	; function 1h
	dw	OFFSET	VCPIMaxPhysicalAddress	; function 2h
	dw	OFFSET	VCPICountFreePages	; function 3h
	dw	OFFSET	VCPIAllocatePage	; function 4h
	dw	OFFSET	VCPIFreePage 		; function 5h
	dw	OFFSET	VCPIPagePhysicalAddress	; function 6h
	dw	OFFSET	VCPIReadCR0		; function 7h
	dw	OFFSET	VCPIReadDebugRegisters	; function 8h
	dw	OFFSET	VCPILoadDebugRegisters	; function 9h
	dw	OFFSET	VCPIRead8259Mappings 	; function 0Ah
	dw	OFFSET	VCPISet8259Mappings	; function 0Bh
;	dw	OFFSET	VCPISwitchToProtected	; function 0Ch

;***********************************************************************
; VCPIDispatcher - entry point for int 67 VCPI calls
;
; ENTRY
;	AL = function number
;	All other registers depend on the function.
; EXIT
;	Return registers depend on the function.
; DESCRIPTION
;	This procedure is called by EMM_pEntry when a VCPI function code
;	is detected.  This code checks for a valid function number and
;	calls the appropriate function to execute it.  The stack frame
;	is set up here.
;***********************************************************************
VCPIDispatcher	proc	far

		; The input registers are saved on the stack with BP pointing
		; to the stack frame.  All returned register values should be
		; placed in the stack frame.  NOTE: the BP value pushed is
		; CEMM's value, not the original program's BP.
		; Validate the function code for a number between 0 and 0Ch
		; If the function is invalid, then return an invalid error code.
	cmp	al,0Ch
	ja	short VD_Invalid_Function
	jb	short VD_Normal_Function
	PJmp	R1CODE_GSEL,R1_CODE:VCPISwitchToProtected

VD_Invalid_Function:
	mov	ah,INVALID_SUBFUNCTION
	ret

VD_Normal_Function:
	pushad
	movzx	ebp,sp

		; Call through the jump table where AL is the index into the
		; jump table. This code destroys the SI register and any
		; function needing it must reload it later.
	movzx	eax,al
	call	cs:dispatch_vector[eax*2]

VCPIDispReturn:
		; The return registers are set up from the stack frame.
		; NOTE: The calling programs BP will be restored in EMM_pEntry.
	popad
	retf
VCPIDispatcher	endp

page
;***********************************************************************
; VCPIPresenceDetection - Indicates that VCPI is supported
;
; ENTRY
;	GS = RCODEA_GSEL
; EXIT
;	AH = 0 (no error encountered)
;	BX = version number
; DESCRIPTION
;	This procedure loads the current version number and returns a
;	success code so that VCPI programs can detect VCPI support in CEMM.
;	The initialization is also done here for debug sake but should be
;	moved elsewhere before actual release.
;***********************************************************************
VCPIPresenceDetection	proc	near

		; The version number is loaded.
	mov	eax,gs:[VCPI_version]
	mov	word ptr [ebp.reg_EBX],ax
	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
	ret
VCPIPresenceDetection	endp

page
;***********************************************************************
; VCPIModeInterface - Sets up the VCPI interface
;
; ENTRY
;	[EBP] ES:DI - ptr to 4k page table buffer
;	[EBP] DS:SI - ptr to three descriptor table entries in the GDT
; EXIT
;	AH = 0 (no error encountered)
;	DI - points to first PTE in the buffer that is not used
;	EBX - offset of the protected mode code entry point
; DESCRIPTION
;	This procedure sets up the protected mode interface that VCPI
;	uses.  This includes coping the first MB's PTE plus the CEMM
;	page table PTE's to the VCPI program's PT's.  Then three descriptors
;	are set up in the VCPI program's GDT: this code segment, this data
;	segment, and a descriptor to CEMM's PT's.
;
;	The location of CEMM's page tables are placed in the VCPI programs
;	page tables starting at linear address 1MB so that this VCPI code
;	can access them.  A descriptor is set up in the VCPI program's GDT
;	that will generate a base address for that 1MB linear address.
;	If the location of the PTE entries is changed then the descriptor's
;	base address must also be changed.
;***********************************************************************
VCPIModeInterface	proc	near

		; The 4k page table pointer is loaded into ES:EDI.
	movzx	edi,[ebp.reg_ES]
	shl	edi,4
	movzx	eax,word ptr [ebp.reg_EDI]
	add	edi,eax

	mov	bx,[NumberHandlePages]	; get this while we have access to _DATA
;
;  The first MB of linear memory has its PTE's copied over to the buffer.
;  There are 100h PTE's to be copied and each PTE uses 4 bytes.  ES:EDI are
;  the VCPI's PTE's while DS:SI are CEMM's PTE's. The PTE's User Bits must
;  be cleared.
;
	mov	ax,PAGET_GSEL
	mov	ds,ax
assume ds:nothing
	xor	esi,esi
	mov	ecx,100h
	cld

MI_copy_1MB_PTEs:
	lods	dword ptr ds:[esi]
	and	eax,0FFFFF1FFh		; clear user bits in PTE's
	STOS_DWORD_PTR_ES_EDI
	loop	MI_copy_1MB_PTEs

;
;  The base addresses for CEMM's PT's are now written to the VCPI program's
;  next PTE's.  The page tables plus the page directory is all lumped together.
;
	mov	eax,[PageD_Addr]
	mov	cx,bx			; number of pages for handle space
	add	cx,3			; add directory and page fault tables
	or	ax,P_AVAIL		; make it available
MIHandleSpace:
	STOS_DWORD_PTR_ES_EDI
	add	eax,1000h
	loop	MIHandleSpace
;
;  DI is set to the next PTE not being used.  To do this the segment value
;  must be subtracted off from the EDI address.
;
	movzx	eax,[ebp.reg_ES]
	shl	eax,4
	sub	edi,eax
	mov	word ptr [ebp.reg_EDI],di
;
;  A new work descriptor is set up in ES:EDI for the VCPI program's GDT.
;
	movzx	edi,[ebp.reg_DS]
	shl	edi,4
	movzx	eax,word ptr [ebp.reg_ESI]
	add	edi,eax
;
;  The three provided descriptors are used for designating the VCPI code
;  segment, VCPI data segment and CEMM page tables.  DS is still the GDT
;  alias, ES:EDI is the program's GDT.
;
	push	GDTD_GSEL
	pop	ds
;
; CEMM's descriptor info for the code segment is copied over.
;
	mov	esi,R1CODE_GSEL
	MOVS_DWORD_USING_DS_ESI
	MOVS_DWORD_USING_DS_ESI
;
; CEMM's descriptor info for the data segment is copied over.
;
	mov	esi,RCODEA_GSEL
	MOVS_DWORD_USING_DS_ESI
	MOVS_DWORD_USING_DS_ESI
;
; CEMM's descriptor info for the page table segment is copied.
;
	mov	esi,PAGED_GSEL
	MOVS_DWORD_USING_DS_ESI
	MOVS_DWORD_USING_DS_ESI
;
;  The actual base address is hard coded to coincide with the location in the
;  PT's that was loaded earlier at 1MB.
;
	mov	byte ptr es:[edi-4],10h
	mov	word ptr es:[edi-6],0000h
;
; The protected mode entry point is returned.
;
	mov	eax,OFFSET R1_CODE:VCPIProtectedDispatcher
	mov	[ebp.reg_EBX],eax
;
; All done
;
	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
	ret
VCPIModeInterface	endp
assume ds:_DATA

page
;***********************************************************************
; VCPIMaxPhysicalAddress - return the maximum allocatable physical address
;
; ENTRY
;	GS = RCODEA_GSEL
; EXIT
;	AH - 0
;	EDX - The maximum physical address for VCPI memory pages.
; DESCRIPTION
;	This procedure returns the maximum physical address for allocatable
;	memory pages.  This is based on the assumption that all VCPI memory
;	is being allocated out of extended memory, not HIMEM.
;***********************************************************************
VCPIMaxPhysicalAddress	proc	near
;QEMS assume	ds:_DATA
;
; Should return top of physical memory. Should be intialized at INIT time.
;
	mov	eax,[TopOfPhysicalMemory] ; top of physical memory    ;LEO
	and	eax,not 0FFFh		  ; last PTE entry index      ;LEO

MPA_return_code:
	mov	[ebp.reg_EDX],eax
	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
	ret
;QEMS assume	ds:R_CODE
VCPIMaxPhysicalAddress	endp

page
;***********************************************************************
; VCPICountFreePages - return the number of free 4k pages
;
; ENTRY
;	DS = R_CODE selector
;	ES = PAGET_GSEL selector
; EXIT
;	EDX = number of free pages
;	AH = 0
; DESCRIPTION
;	This procedure returns the number of current free 4k pages.  This
;	number is initialized and changed by AllocatePage and
;	FreePage.
;***********************************************************************
VCPICountFreePages	proc	near
ifdef QEMS
	mov	ax,gs
	mov	ds,ax
	movzx	eax,[free_4k_pages]
endif
	call	GetFreeEMS		; ax = # free 16k EMS pages

	movzx	eax, ax
	shl	eax, 2			; 16k to 4k pages

	movzx	ebx, [TopOfHandleSpace]
	sub	bx, [BotOfVCPIspace]
	sub	bx, [UsedVCPIPages]	; bx = # free 4k pages in VCPI space

	add	eax, ebx

	;;;pDebugF "VCPICountFreePages: returning %ld free 4k pages\n", <eax>

	mov	[ebp.reg_EDX],eax
	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
	ret
VCPICountFreePages	endp

page
;==============================================================================
;==
;== VCPIAllocatePage: allocates a 4K page
;==
;== Entry
;==	DS = _DATA selector
;==	ES = DATA32_GSEL selector
;==	GS = R_CODE
;==
;== Exit
;==	EDX = physical address of page
;==	AH = 0 or FFFF
;==
;==============================================================================
	public	VCPIAllocatePage

VCPIAllocatePage proc	near

	AssertSegReg	gs, RCODEA_GSEL

;  Check if any VCPI pages are free

	mov	ax,PAGED_GSEL
	mov	es,ax
	assume	es:NOTHING

	mov	ax, [TopOfHandleSpace]
	sub	ax, [BotOfVCPIspace]
	sub	ax, [UsedVCPIPages]
	jbe	VAP_grow_vcpi_space

;  Should be a free page in VCPI space, find it

	movzx	esi, [TopOfHandleSpace]
	movzx	edi, [BotOfVCPIspace]
VAPloop1:
	bts	word ptr es:[esi*4-4], fVCPIPageAllocatedBit
	jnc	short VAPpageFound
	dec	si
	cmp	si,di			;Q: End of VCPI space?
	jne	short VAPloop1

;  No free pages in VCPI space, try to grow it

VAP_grow_vcpi_space:

	movzx	esi, [TopOfFreeEMSspace]
	cmp	si, [TopOfUsedEMSspace] ;Q: any easy to grab EMS pages free?
	jbe	short VAP_try_compact	;N: try compacting EMS handle space

	mov	cx, 4
	movzx	edi, [BotOfVCPIspace]
	sub	[TopOfFreeEMSspace], cx ; lower EMS space by 4 4k pages
	sub	[BotOfVCPIspace], cx	; increase VCPI space by the same

	cmp	si, di		    ;Q: [TopOfFreeEMSspace] = [BotOfVCPIspace]?
	je	VAP_mark_page	    ;Y: no need to move PTEs around

;  There is a gap between the bottom of VCPI space and the top of free EMS
;  space so the free EMS PTEs have to be moved up to VCPI land

	mov	bx, di			; save old [BotOfVCPIspace]

	cld
	movzx	ecx, cx 		; make sure only 16 bits used
	lea	esi, [esi*4-4*4]
	lea	edi, [edi*4-4*4]
	REP_MOVS_DWORD_USING_ES_ESI

	mov	cx, 4			; clear the old PTEs at old
	xor	eax, eax		;   [TopOfFreeEMSspace]
	lea	edi, [esi-4*4]
	REP_STOS_DWORD_PTR_ES_EDI

	movzx	esi, bx 		; following code expects SI = old bottom

VAP_mark_page:
	or	word ptr es:[esi*4-4], fVCPIPageAllocated

VAPpageFound:
	inc	[UsedVCPIPages]
	mov	edx,es:[esi*4-4]
	and	dx,not 0FFFh
	mov	byte ptr [bp][reg_EAX+1], SUCCESS
	mov	[bp][reg_EDX], edx
VAPexit:
	ret

;  No free EMS pages between [TopOfFreeEMSspace] and [TopOfUsedEMSspace],
;  can some be freed by compacting handle space?

VAP_try_compact:

	mov	ax, [TopOfFreeEMSspace]
	sub	ax, FIRST_HANDLE_PTE
	shr	ax, 2
	sub	ax, [UsedEMSpages]
	jbe	VAP_grow_pool

;  There is some free EMS, compact handle space

	pDebugF "VCPIAllocPage_near: compacting handle space, untested\n"
	pDebugBreak

	mov	ax,DATA32_GSEL
	mov	es,ax
	mov	ax,-1
	call	AddFreeEMS
	mov	ax,PAGED_GSEL
	mov	es,ax
	jmp	VAP_grow_vcpi_space

;  No free EMS to steal anywhere, try to grow the EMS pool from XMS

VAP_grow_pool:

	mov	ax,DATA32_GSEL
	mov	es,ax
	mov	bx, 1
	call	GrowEMSpool
	mov	ax,PAGED_GSEL
	mov	es,ax
	jnc	VAP_grow_vcpi_space

;  No memory available at all, tell caller

	mov	byte ptr [bp][reg_EAX+1], NOT_ENOUGH_FREE_MEM
	jmp	short VAPexit

VCPIAllocatePage   endp


ifdef QEMS
page
;***********************************************************************
; VCPIAllocatePage - return the address of a 4k page to be allocated
;
; ENTRY
;	DS = RCODEA_GSEL selector
;QEMS	ES = PAGET_GSEL selector
; EXIT
;	EDX = physical address of page
;	AH = 0 or FFFF
; DESCRIPTION
;	This procedure searches through the CEMM's page tables looking for
;	an unallocated 4k page.  It does this by checking the system reserved
;	bit which it sets when it allocates a page.  This code assumes that
;	all of VCPI's allocatable memory is contiguous in extended memory.
;
;***********************************************************************
VCPIAllocatePage	proc	near

		; Check to see if there are any free pages available.
	mov	ax,RCODEA_GSEL
	mov	fs,ax
ifdef QEMS
	mov	ax,PAGET_GSEL
	mov	es,ax
endif
	mov	ax, VDMD_GSEL
	mov	ds, ax
	cmp	fs:[free_4k_pages],0
	je	AP_no_pages
		; The beginning of the extended memory PTE's is loaded into
		; DS:SI and CX is initialized to the number of pages.
AP_do_setup:
ifdef QEMS
	;
	; AR
	; Ensure that that the PT 0 associated with Alternate Register set
	; 0 is mapped in at PAGET_GSEL base address.
	;
	call	SetPT0Cntxt
endif
	mov	bx,word ptr [AllocMapPtr]
	xor	si,si
	mov	cx,fs:[number_ext_mem_PTEs]
	jcxz	short AP_try_high_memory
	movzx	esi,fs:[starting_ext_mem_PTE]

AP_check_extended:
	bts	[bx],si
	jnc	short AP_found_page
	inc	ax
	inc	esi
	loop	AP_check_extended

		; The beginning of the high memory PTE's is loaded into
		; ES:SI and CX is initialized to the number of pages.
AP_try_high_memory:
	mov	cx,fs:[number_high_mem_PTEs]
	jcxz	short AP_try_conventional_memory
	movzx	esi,fs:[starting_high_mem_PTE]

AP_check_high:
	bts	[bx],si
	jnc	short AP_found_page
	inc	esi
	loop	AP_check_high

		; The conventional memory pool is tried.
AP_try_conventional_memory:
	mov	cx,fs:[number_conv_mem_PTEs]
	jcxz	short AP_no_pages
	movzx	esi,fs:[starting_conv_mem_PTE]
AP_check_conventional:
	bts	[bx],si
	jnc	short AP_found_page
	inc	esi
	loop	AP_check_conventional

AP_found_page:
	dec	fs:[free_4k_pages]
	mov	bx,word ptr [VCPIAllocMapPtr]
	bts	[bx],si
	shl	esi,P_SHIFT
	mov	[ebp.reg_EDX],esi
	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
ifdef QEMS
	;
	; AR
	; Ensure that the current PT0 as indicated by the 0th page directory
	; entry is mapped in at PAGET_GSEL's base address.
	;
	call	RestorePT0Cntxt
endif
	ret

AP_no_pages:
	mov	byte ptr [ebp.reg_EAX + 1],NOT_ENOUGH_FREE_MEM
	ret

VCPIAllocatePage	endp
endif

page
;==============================================================================
;==
;== VCPIFreePage: Frees a previously allocated 4K page
;==
;== Entry
;==	EDX = physcial address of page to free up
;==
;== Exit
;==	AH = 0 or FFFF
;==
;==============================================================================
VCPIFreePage	proc	near

;
;  Search for page in VCPI space
;
	movzx	esi,[TopOfHandleSpace]
	movzx	edi,[BotOfVCPIspace]

	cmp	si,di			;Q: Any VCPI space defined yet?
	je	short VFPerr		; N: can't deallocate

	mov	ax,PAGED_GSEL
	mov	es,ax

	and	dx,not 0FFFh
	or	dx,P_AVAIL+fVCPIPageAllocated
VFPloop:
	mov	eax, es:[esi*4-4]
	and	ax, NOT fXMSPageAllocated	; ignore XMS bit
	cmp	edx, eax
	je	short VFPpageFound
	dec	si
	cmp	si,di			;Q: End of VCPI space?
	jne	short VFPloop		; N: continue
	jmp	short VFPerr		; Y: error, could not find page

VFPpageFound:
	dec	si
	and	word ptr es:[esi*4],not fVCPIPageAllocated

	mov	ax,gs		; DS = R_CODEA
	mov	ds,ax
	assume  ds:R_CODE
;
;  Check if this freed up a 16K page: If so, place it in the free EMS space
;
	PCall	R1CODE_GSEL,R1_CODE:VCPItoEMSspaceFar	; eax = page PTE if yes,
							;	0 if no
	dec	gs:[UsedVCPIPages]
	mov	byte ptr [bp][reg_EAX+1],SUCCESS

	bt	eax, fXMSPageAllocatedBit	;Q: was an XMS allocated page
	jnc	short VFPexit			;   moved to free EMS space?

	mov	ax, VDMD_GSEL
	mov	ds, ax
	mov	ax, DATA32_GSEL
	mov	es, ax
	call	ShrinkEMSpool			;Y: try to give back XMS memory

VFPexit:
	ret
	assume  ds:_DATA,es:nothing
;
;  If this is reached then no match was found. Set the error code and return.
;
VFPerr:
	mov	byte ptr [bp][reg_EAX+1],LOG_PAGE_RANGE
	jmp	short VFPexit

VCPIFreePage	endp


ifdef QEMS
;***********************************************************************
; VCPIFreePage - frees up a previously allocated 4K page
;
; ENTRY
;	EDX = physcial address of page to free up
;	DS = RCODEA_GSEL selector
;	ES = PAGET_GSEL selector
; EXIT
;	AH = 0 or FFFF
; DESCRIPTION
;	This procedure frees up a previously allocated page.  It does this by
;	checking the system reserved bit and the physical address for a match.
;	This code assumes that all of VCPI's allocatable memory is contiguous
;	in extended memory.
;***********************************************************************
VCPIFreePage	proc	near

	mov	ax,RCODEA_GSEL
	mov	fs,ax
ifdef QEMS
	mov	ax,PAGET_GSEL
	mov	es,ax
endif
	mov	ax, VDMD_GSEL
	mov	ds, ax
ifdef QEMS
	;
	; AR
	; Ensure that that the PT 0 associated with Alternate Register set
	; 0 is mapped in at PAGET_GSEL base address.
	;
	call	SetPT0Cntxt
endif
	mov	bx,word ptr [VCPIAllocMapPtr]
	shr	edx,P_SHIFT

	btr	[bx],dx
	jnc	short FP_fail

		; If the page is found then reset its in use bits.
	mov	bx,word ptr [AllocMapPtr]
	btr	[bx],dx
	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
	inc	fs:[free_4k_pages]
FP_done:
ifdef QEMS
	;
	; AR
	; Ensure that the current PT0 as indicated by the 0th page directory
	; entry is mapped in at PAGET_GSEL's base address.
	;
	call	RestorePT0Cntxt
endif
	ret
		; If this is reached then no match was found.
		; Set the error code and return.
FP_fail:
	mov	byte ptr [ebp.reg_EAX + 1],LOG_PAGE_RANGE
	jmp	short FP_done

VCPIFreePage	endp
endif
page
;***********************************************************************
; VCPIPagePhysicalAddress - return a pages physical address
;
; ENTRY
;	CX = page linear address shifted right by 12
; EXIT
;	AH = 0
;	EDX = physical address
; DESCRIPTION
;	This procedure returns the physcial address of a linear page.
;	This is done by using the page index as a lookup into CEMM's page
;	tables and reading the base address.
;***********************************************************************
VCPIPagePhysicalAddress	proc	near

		; The page index is checked to see if it is within the
		; first MB.  If not then set the error return.
	cmp	cx,100h
	jae	short PPA_invalid_index
	mov	ax,PAGET_GSEL
	mov	es,ax
	movzx	esi,cx
	mov	edx,es:[esi*4]
	and	edx,PTE_ADDRESS_BIT_MASK
	mov	[ebp.reg_EDX],edx
	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
	ret

PPA_invalid_index:
	mov	byte ptr [ebp.reg_EAX + 1],PHYS_PAGE_RANGE
	ret

VCPIPagePhysicalAddress	endp

page
;***********************************************************************
; VCPIReadCR0
;
; ENTRY
;	none
; EXIT
;	AH = 0
;	EBX = CR0
; DESCRIPTION
;	This procedure reads the current value of CR0 and returns it.
;***********************************************************************
VCPIReadCR0 proc	near

		; Store the CR0 value, set the status code and return.
	mov	eax,cr0
	mov	[ebp.reg_EBX],eax
	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
	ret
VCPIReadCR0 endp

page
;***********************************************************************
; VCPIReadDebugRegisters
;
; ENTRY
;	ES:DI - ptr to array of 8 dwords for debug registers
; EXIT
;	AH = 0
; DESCRIPTION
;	This procedure reads the current value of the debug registers and
;	writes them into the provided data buffer.
;***********************************************************************
VCPIReadDebugRegisters	proc	near

		; A work selector is set up for ES:EDI.
	mov	ax,DATA32_GSEL
	mov	es,ax
	movzx	edi,[ebp.reg_ES]
	shl	edi,4
	movzx	eax,word ptr [ebp.reg_EDI]
	add	edi,eax

		; The debug registers are read and stored.
	cld
	mov	eax,dr0
	mov	es:[edi],eax
	add	edi,4
	mov	eax,dr1
	mov	es:[edi],eax
	add	edi,4
	mov	eax,dr2
	mov	es:[edi],eax
	add	edi,4
	mov	eax,dr3
	mov	es:[edi],eax
	add	edi,4
	xor	eax,eax
	mov	es:[edi],eax
	add	edi,4
	mov	es:[edi],eax
	add	edi,4
	mov	eax,dr6
	mov	es:[edi],eax
	add	edi,4
	mov	eax,dr7
	mov	es:[edi],eax
	add	edi,4

	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
	ret
VCPIReadDebugRegisters	endp

page
;***********************************************************************
; VCPILoadDebugRegisters
;
; ENTRY
;	ES:DI - pointer to an array of 8 dwords with the values
; EXIT
;	AH = 0
; DESCRIPTION
;	This procedure loads the debug registers with the values provided.
;***********************************************************************
VCPILoadDebugRegisters	proc	near

		; A work selector is set up for ES:ESI.
	mov	ax,DATA32_GSEL
	mov	es,ax
	movzx	esi,[ebp.reg_ES]
	shl	esi,4
	movzx	eax,word ptr [ebp.reg_EDI]
	add	esi,eax

		; The values are read in and loaded.
	cld
	lods	dword ptr es:[esi]
	mov	dr0,eax
	lods	dword ptr es:[esi]
	mov	dr1,eax
	lods	dword ptr es:[esi]
	mov	dr2,eax
	lods	dword ptr es:[esi]
	mov	dr3,eax
	lods	dword ptr es:[esi]
	lods	dword ptr es:[esi]
	lods	dword ptr es:[esi]
	mov	dr6,eax
	lods	dword ptr es:[esi]
	mov	dr7,eax

	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
	ret
VCPILoadDebugRegisters	endp

page
;***********************************************************************
; VCPIRead8259Mappings
;
; ENTRY
;	GS = RCODEA_GSEL
; EXIT
;	AH = 0
;	BX = vector mappings for master 8259
;	CX = vector mappings for slave 8259
; DESCRIPTION
;	This procedure returns the current values of the 8259 vector mappings.
;	There is no way to actually read the values so the original default
;	values are the DOS values.  However, if the 8259 mappings are changed
;	thru Set8259Mappings, then the new values will be returned.
;QLEO:  The values returned will be values that were programmed by CEMM.
;***********************************************************************
VCPIRead8259Mappings	proc	near
;QEMS assume	ds:_DATA

		; The stored values are loaded and returned.
	mov	ax,gs:[MasterPICVec]
	mov	word ptr [ebp.reg_EBX],ax
	mov	ax,gs:[SlavePICVec]
	mov	word ptr [ebp.reg_ECX],ax
	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
	ret
VCPIRead8259Mappings	endp

page
;***********************************************************************
; VCPISet8259Mappings
;
; ENTRY
;	BX = vector mappings for master 8259
;	CX = vector mappings for slave 8259
;	GS = RCODEA_GSEL
; EXIT
;	AH = 0
; DESCRIPTION
;	This procedure is for notification purposes only.  The code doesn't
;	do anything except save the values for later use during a read of
;	the 8259 mapping.  The VCPI program may have already set the new
;	values up before this call.
;QLEO:  Need to return an error if this VCPI call is attempted.  CEMM has
;	already reprogrammed the PICs to new values, and thus this call is
;	no longer valid.
;***********************************************************************
VCPISet8259Mappings proc	near

ifdef PICtrap
	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
	ret

VCPIProgPIC:
;
;  Program PIC if the ICWs are being virtualized
;
	call	ProgramPIC
endif

		; The data alias for the IDT is load.
	mov	ax,IDTD_GSEL
	mov	es,ax

		; The slave's value is saved in dx.
	mov	dx,cx

		; If the current 8259 vector is DOS's value, then the IDT
		; entries are left alone as CEMM has processor interrupts
		; connected into here.
	cmp	gs:[MasterPICVec],DOS_MASTER_VECTOR
	je	short SM_check_master_vector

	cmp	gs:[MasterPICVec],50h		; leave handlers at 50h
	je	short SM_check_master_vector

		; If the current 8259 is different than DOS, clear out the
		; old entries so they will generate GP's if accessed.
	movzx	esi,gs:[MasterPICVec]
	mov	cx,8
SM_clear_master_IDTs:
	mov	dword ptr es:[esi*8],0
	mov	dword ptr es:[esi*8 + 4],0
	inc	esi
	loop	SM_clear_master_IDTs

		; If the new 8259 vector is DOS's value, then the IDT
		; entries are left alone as they are already set up.
SM_check_master_vector:
 	mov	gs:[MasterPICVec],bx
;
;  Assume master PIC is being programmed to base vector locations
;
ifdef PICtrap
	mov	gs:[VirMasterPICVec],bx
endif

	cmp	bx,DOS_MASTER_VECTOR
	je	SM_check_slave_IDTs

	cmp	bx,50h			; use handlers at 50h
	je	SM_check_slave_IDTs

		; If the new 8259 vector is different than DOS's, the IDT
		; entries are mapped into the special trap routines that
		; handle hardware interrupts.
	mov	cx,8
	movzx	esi,bx
SM_load_master_IDTs:
	mov	word ptr es:[esi*8 + 2],VDMC_GSEL
	mov	byte ptr es:[esi*8 + 5],D_386INT0
	inc	esi
	loop	SM_load_master_IDTs

	movzx	esi,bx
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ0Handler
	inc	si
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ1Handler
	inc	si
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ2Handler
	inc	si
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ3Handler
	inc	si
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ4Handler
	inc	si
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ5Handler
	inc	si
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ6Handler
	inc	si
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ7Handler

		; If the current 8259 vector is DOS's value, then the IDT
		; entries are left alone as CEMM has these entries set up.
SM_check_slave_IDTs:
	cmp	gs:[SlavePICVec],DOS_SLAVE_VECTOR
	je	short SM_check_slave_vector

	cmp	gs:[SlavePICVec],50h		; leave 50h handlers
	je	short SM_check_slave_vector

		; If the current 8259 is different than DOS, clear out the
		; old entries so they will generate GP's if accessed.
	movzx	esi,gs:[SlavePICVec]
	mov	cx,8
SM_clear_slave_IDTs:
	mov	dword ptr es:[esi*8],0
	mov	dword ptr es:[esi*8 + 4],0
	inc	esi
	loop	SM_clear_slave_IDTs

		; If the new 8259 vector is DOS's value, then the IDT
		; entries are left alone as they are already set up.
SM_check_slave_vector:
 	mov	gs:[SlavePICVec],dx
ifdef PICtrap
	mov	gs:[VirSlavePICVec],dx
endif

	cmp	dx,DOS_SLAVE_VECTOR
	je	SM_exit

	cmp	dx,50h		; use 50h handlers
	je	SM_exit

		; If the new 8259 vector is different than DOS's, the IDT
		; entries are mapped into the special trap routines that
		; handle hardware interrupts.
	mov	cx,8
	movzx	esi,dx
SM_load_slave_IDTs:
	mov	word ptr es:[esi*8 + 2],VDMC_GSEL
	mov	byte ptr es:[esi*8 + 5],D_386INT0
	inc	esi
	loop	SM_load_slave_IDTs

	movzx	esi,dx
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ8Handler
	inc	si
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ9Handler
	inc	si
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ10Handler
	inc	si
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ11Handler
	inc	si
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ12Handler
	inc	si
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ13Handler
	inc	si
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ14Handler
	inc	si
	mov	word ptr es:[esi*8],offset _TEXT:pIRQ15Handler

SM_exit:
ifndef PICtrap
	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
endif
	ret
VCPISet8259Mappings endp


_TEXT	ends

	page
R1_CODE	segment
	assume	cs:R1_CODE,ds:R_CODE,es:nothing,ss:STACK,fs:NOTHING,gs:NOTHING

;***********************************************************************
; This is the jump table used by VCPIProtectedDispatcher.
;***********************************************************************
protected_vector	label	word
	dw	OFFSET	VCPIInvalidFunction 	; function 0h
	dw	OFFSET	VCPIInvalidFunction 	; function 1h
	dw	OFFSET	VCPIInvalidFunction 	; function 2h
	dw	OFFSET	VCPICountFreePagesProt	; function 3h
	dw	OFFSET	VCPIAllocatePageProt	; function 4h
	dw	OFFSET	VCPIFreePageProt	; function 5h
	dw	OFFSET	VCPIInvalidFunction 	; function 6h
	dw	OFFSET	VCPIInvalidFunction 	; function 7h
	dw	OFFSET	VCPIInvalidFunction 	; function 8h
	dw	OFFSET	VCPIInvalidFunction 	; function 9h
	dw	OFFSET	VCPIInvalidFunction 	; function 0Ah
	dw	OFFSET	VCPIInvalidFunction 	; function 0Bh
page
;***********************************************************************
; VCPIProtectedDispatcher - entry point for protected mode VCPI calls
;
; ENTRY
;	AL = function number
;	All other registers depend on the function.
; EXIT
;	All registers depend on the function.
; DESCRIPTION
;	This procedure is called by the VCPI program directly while in
;	protected mode, no INT 67h is done.  The stack frame
;	is set up here.
;***********************************************************************
VCPIProtectedDispatcher	proc	far

		; Check for the function 'Switch to Protected Mode'.  This
		; call never returns to here so a stack frame is not set up.
	cmp	al,0Ch
	ja	short PVD_Invalid_Function
	jb	short PVD_Normal_Function
	jmp	VCPISwitchToV86

PVD_Invalid_Function:
	mov	ah,INVALID_SUBFUNCTION
	db	66h
	ret
		; The input registers are saved on the stack with BP pointing
		; to the stack frame.  All returned register values should be
		; placed in the stack frame.  NOTE: The BP value pushed here
		; is the original BP since the procedure is called directly.
		; The segment registers are saved to be safe.
PVD_Normal_Function:
	push	ds
	push	es
	pushad
	mov	ebp,esp

		; Since these procedures can be called by either GDT, the
		; ES and DS registers are setup here to hold PAGET_GSEL
		; selector and R_CODE selector respectively.

		; It is known that the
		; data selector follows the code selector so the size of a
		; descriptor entry is added to the code selector.  The same
		; is true of the page table selector.
	ror	eax,8			;save al in upper part

	mov	ax,cs			;cs is our code selector
	add	ax,8			;next GDT desc. is data
	mov	ds,ax			;R_CODE data
;QEMS	assume	ds:R_CODE
	add	ax,8			;next GDT desc. is ABS0/DATA32_GSEL
	mov	es,ax			;_DATA
;QEMS	ASSUME	ES:_DATA

		; The function is called through the jump table.
	shr	eax,24			;recover al for jump
	call	cs:protected_vector[eax*2]

VCPIProtDispReturn:

		; Restore the return registers.
	popad
	pop	es
	pop	ds

		; A far USE32 bit return is done to the VCPI code.
	db	66h
	retf

VCPIProtectedDispatcher	endp

;***********************************************************************
; VCPIInvalidFunction
;
; ENTRY
;	none
; EXIT
;	EAX = FAILURE
; DESCRIPTION
;	This procedure is for internal use only.  It sets up the return
;	value to indicate that an invalid function number was specified.
;	This is done in a separate routine for handling invalid functions
;	in the jump table.
;***********************************************************************
VCPIInvalidFunction proc	near
	mov	byte ptr [ebp.reg_EAX + 1],INVALID_SUBFUNCTION
	ret
VCPIInvalidFunction endp

page
;***********************************************************************
; VCPICountFreePagesProt - return the number of free 4k pages
;
; ENTRY
;	DS = R_CODE selector
;	ES = PAGET_GSEL selector
; EXIT
;	EDX = number of free pages
;	AH = 0
; DESCRIPTION
;	This procedure returns the number of current free 4k pages.  This
;	number is initialized and changed by AllocatePage and
;	FreePage.
;***********************************************************************
	public	VCPICountFreePagesProt
	assume	ds:R_CODE,es:nothing,fs:NOTHING,gs:NOTHING

VCPICountFreePagesProt	proc	near
;QEMS	movzx	eax,[free_4k_pages]

	pushf
	call	VCPIServerContext	; disables interrupts
	assume	ds:_DATA,es:NOTHING,gs:R_CODE

	;;;pDebugF "VCPICountFreePagesProt, untested code\n"
	;;;pDebugBreak

	Pcall	VDMC_GSEL,_TEXT:GetFreeEMS_far	; ax = # free 16k EMS pages

	movzx	eax, ax
	shl	eax, 2			; 16k to 4k pages

	movzx	ecx, [TopOfHandleSpace]
	sub	cx, [BotOfVCPIspace]
	sub	cx, [UsedVCPIPages]	; cx = # free 4k pages in VCPI space

	add	ecx, eax

	;;;pDebugF "VCPICountFreePagesProt: returning %ld free 4k pages\n", <ecx>

	call	VCPIClientContext
	assume	ds:R_CODE,es:nothing,gs:NOTHING
	popf

	mov	[ebp.reg_EDX],ecx
	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
	ret

VCPICountFreePagesProt	endp

page
;==============================================================================
;==
;== VCPIAllocatePageProt: allocates a 4K page
;==
;== Entry
;==	DS = R_CODE
;==	ES = PAGED_GSEL selector
;==
;== Exit
;==	EDX = physical address of page
;==	AH = 0 or FFFF
;==
;==============================================================================
VCPIAllocatePageProt	proc	near

;
;  Check to see if any pages are available
;
	mov	ax,[TopOfHandleSpace]
	sub	ax,[BotOfVCPIspace]
	sub	ax,[UsedVCPIPages]		; free pages in VCPI space

	mov	bx, [TopOfFreeEMSspace]
	sub	bx, [TopOfUsedEMSspace] 	; free pages in EMS space
	add	ax, bx				;   that we can get at

	or	ax,ax			;Q: Any VCPI pages left?
	jz	VAPP_grow_VCPI_space

;
;  Allocate a VCPI page
;
	movzx	esi,[TopOfHandleSpace]
	movzx	edi,[BotOfVCPIspace]
	cmp	si,di			;Q: Any VCPI space defined yet?
	je	short VAPPcont
VAPPloop1:
	bts	word ptr es:[esi*4-4],fVCPIPageAllocatedBit
	jnc	short VAPPpageFound
	dec	si
	cmp	si,di			;Q: End of VCPI space?
	jne	short VAPPloop1
VAPPcont:
	movzx	esi, [TopOfFreeEMSspace]
	cmp	si, [TopOfUsedEMSspace]     ;Q: any easy to get EMS pages free?
	jbe	short VAPP_grow_VCPI_space  ;N:

	mov	cx, 4
	movzx	edi, [BotOfVCPIspace]
	sub	[TopOfFreeEMSspace], cx ; lower EMS space by 4 4k pages
	sub	[BotOfVCPIspace], cx	; increase VCPI space by the same

	cmp	si, di		    ;Q: [TopOfFreeEMSspace] = [BotOfVCPIspace]?
	je	VAPP_mark_page	    ;Y: no need to move PTEs around

;  There is a gap between the bottom of VCPI space and the top of free EMS
;  space so the free EMS PTEs have to be moved up to VCPI land

	mov	bx, di			; save old [BotOfVCPIspace]

	cld
	movzx	ecx, cx 		; make sure only 16 bits used
	lea	esi, [esi*4-4*4]
	lea	edi, [edi*4-4*4]
	REP_MOVS_DWORD_USING_ES_ESI

	mov	cx, 4			; clear the old PTEs at old
	xor	eax, eax		;   [TopOfFreeEMSspace]
	lea	edi, [esi-4*4]
	REP_STOS_DWORD_PTR_ES_EDI

	movzx	esi, bx 		; following code expects SI = old bottom

VAPP_mark_page:
	or	word ptr es:[esi*4-4],fVCPIPageAllocated

VAPPpageFound:
	inc	[UsedVCPIPages]
	mov	eax,es:[esi*4-4]
	and	ax,not 0FFFh
	mov	[ebp][reg_EDX],eax
	mov	byte ptr [ebp][reg_EAX+1],SUCCESS

VAPPexit:
	ret

VAPPnoPages:
	mov	byte ptr [ebp][reg_EAX+1],NOT_ENOUGH_FREE_MEM
	jmp	short VAPPexit

VAPP_grow_vcpi_space:

	mov	ax, [TopOfFreeEMSspace] ; If there are free EMS pages, compact
	sub	ax, FIRST_HANDLE_PTE	;   handle space so they can be used.
	shr	ax, 2
	sub	ax, [UsedEMSpages]
	jbe	VAPP_grow_pool

	pushf
	call	VCPIServerContext	; disables interrupts
	assume	ds:_DATA,es:NOTHING,gs:R_CODE

	pDebugF "VCPIAllocPageProt: compacting handle space, untested\n"
	pDebugBreak

	mov	ax, -1
	Pcall	VDMC_GSEL,_TEXT:AddFreeEMS_far	; Compact EMS handle space

	call	VCPIClientContext
	assume	ds:R_CODE,es:nothing,gs:NOTHING
	popf
	jmp	VCPIAllocatePageProt	; The allocation will work now

VAPP_grow_pool:

	pushf
	call	VCPIServerContext	; disables interrupts
	assume	ds:_DATA,es:NOTHING,gs:R_CODE

	mov	bx, 1
	Pcall	VDMC_GSEL,_TEXT:GrowEMSpool_far ; Add mem to the EMS pool
	rcl	cl, 1				; save CY in cl

	call	VCPIClientContext
	assume	ds:R_CODE,es:nothing,gs:NOTHING
	popf

	test	cl, 1			; Q: did GrowEMSpool_far set carry?
	jz	VCPIAllocatePageProt	; N: try to alloc again
	jmp	short VAPPnoPages	; Y: can't allocate a page


VCPIAllocatePageProt	endp

ifdef QEMS
;***********************************************************************
; VCPIAllocatePageProt - return the address of a 4k page to be allocated
;
; ENTRY
;	DS = RCODEA_GSEL selector
;	ES = PAGET_GSEL selector
; EXIT
;	EDX = physical address of page
;	AH = 0 or FFFF
; DESCRIPTION
;	This procedure searches through the CEMM's page tables looking for
;	an unallocated 4k page.  It does this by checking the system reserved
;	bit which it sets when it allocates a page.  This code assumes that
;	all of VCPI's allocatable memory is contiguous in extended memory.
;
;***********************************************************************
VCPIAllocatePageProt	proc	near
	cmp	[free_4k_pages],0
	je	short PAP_no_pages
		; The beginning of the extended memory PTE's is loaded into
		; DS:SI and CX is initialized to the number of pages.
PAP_do_setup:
	mov	bx,word ptr es:[AllocMapPtr]
	xor	esi,esi
	mov	cx,[number_ext_mem_PTEs]
	jcxz	short PAP_try_high_memory
	movzx	esi,[starting_ext_mem_PTE]

PAP_check_extended:
	bts	es:[bx],si
	jnc	short PAP_found_page
	inc	esi
	loop	PAP_check_extended

		; The beginning of the high memory PTE's is loaded into
		; ES:SI and CX is initialized to the number of pages.
PAP_try_high_memory:
	mov	cx,[number_high_mem_PTEs]
	jcxz	short PAP_try_conventional_memory
	movzx	esi,[starting_high_mem_PTE]

PAP_check_high:
	bts	es:[bx],si
	jnc	short PAP_found_page
	inc	esi
	loop	PAP_check_high

		; The conventional memory pool is tried.
PAP_try_conventional_memory:
	mov	cx,[number_conv_mem_PTEs]
	jcxz	short PAP_no_pages
	movzx	esi,[starting_conv_mem_PTE]
PAP_check_conventional:
	bts	es:[bx],si
	jnc	short PAP_found_page
	inc	esi
	loop	PAP_check_conventional

PAP_found_page:
	mov	bx,word ptr es:[VCPIAllocMapPtr]
	dec	[free_4k_pages]
	bts	es:[bx],si
	shl	esi,P_SHIFT
	mov	[ebp.reg_EDX],esi
	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
	ret

PAP_no_pages:
	mov	byte ptr [ebp.reg_EAX + 1],NOT_ENOUGH_FREE_MEM
	ret

VCPIAllocatePageProt	endp
endif

page
;==============================================================================
;==
;== VCPIFreePageProt: Frees a previously allocated 4K page
;==
;== Entry
;==	EDX = physcial address of page to free up
;==
;== Exit
;==	AH = 0 or FFFF
;==
;==============================================================================
VCPIFreePageProt proc	near
;
;  Search for page in VCPI space
;
	movzx	esi,[TopOfHandleSpace]
	movzx	edi,[BotOfVCPIspace]

	cmp	si,di			;Q: Any VCPI space defined yet?
	je	short VFPPerr		; N: can't deallocate

	and	dx,not 0FFFh
	or	dx,P_AVAIL+fVCPIPageAllocated
VFPPloop:
	mov	eax, es:[esi*4-4]
	and	ax, NOT fXMSPageAllocated	; ignore XMS bit
	cmp	edx, eax
	je	short VFPPpageFound
	dec	si
	cmp	si,di			;Q: End of VCPI space?
	jne	short VFPPloop		; N: continue
	jmp	short VFPPerr		; Y: error, could not find page

VFPPpageFound:
	dec	si
	and	word ptr es:[esi*4],not fVCPIPageAllocated

;
;  Check if this freed up a 16K page: If so, place it in the free EMS space
;
	call	VCPItoEMSspace		; eax = page PTE if yes, 0 no

	dec	[UsedVCPIPages]
	mov	byte ptr [ebp][reg_EAX+1],SUCCESS

	bt	eax, fXMSPageAllocatedBit	;Q: was an XMS allocated page
	jnc	short VFPPexit			;   moved to free EMS space?

	pushf
	call	VCPIServerContext	; disables interrupts
	assume	ds:_DATA,es:NOTHING,gs:R_CODE

	;;;pDebugF "VCPIFreePageProt: shrinking EMS pool, untested\n"
	;;;pDebugBreak

	Pcall	VDMC_GSEL,_TEXT:ShrinkEMSpool_far   ; try to give back XMS mem

	call	VCPIClientContext
	assume	ds:R_CODE,es:nothing,gs:NOTHING
	popf

VFPPexit:
	ret
;
;  If this is reached then no match was found. Set the error code and return.
;
VFPPerr:
	mov	byte ptr [ebp][reg_EAX+1],LOG_PAGE_RANGE
	jmp	short VFPPexit
VCPIFreePageProt	endp

ifdef QEMS
;***********************************************************************
; VCPIFreePageProt - frees up a previously allocated 4K page
;
; ENTRY
;	EDX = physcial address of page to free up
;	DS = RCODEA_GSEL selector
;	ES = PAGET_GSEL selector
; EXIT
;	AH = 0 or FFFF
; DESCRIPTION
;	This procedure frees up a previously allocated page.  It does this by
;	checking the system reserved bit and the physical address for a match.
;	This code assumes that all of VCPI's allocatable memory is contiguous
;	in extended memory.
;***********************************************************************
VCPIFreePageProt	proc	near
	shr	edx,P_SHIFT

	mov	bx,word ptr es:[VCPIAllocMapPtr]
	btr	es:[bx],dx
	jnc	short PFP_fail

		; If the page is found then reset its in use bits.
	mov	bx,word ptr es:[AllocMapPtr]
	btr	es:[bx],dx
	mov	byte ptr [ebp.reg_EAX + 1],SUCCESS
	inc	[free_4k_pages]
	ret
		; If this is reached then no match was found.
		; Set the error code and return.
PFP_fail:
	mov	byte ptr [ebp.reg_EAX + 1],LOG_PAGE_RANGE
	ret

VCPIFreePageProt	endp
endif
;***********************************************************************
; VCPISwitchToV86
;
; ENTRY
;	Interrupts disabled
;	SS:ESP - stack frame with valid selectors
;	DS - selector used for protected mode interface
; EXIT
;	interrupts disabled
; DESCRIPTION
;	This procedure restores CEMM's system registers and transfers
;	control back to the VCPI program's V86 code.  This code turns off
;	interrupts for the duration of the call.  The stack is cleaned up
;	since this does not return back out to the protected mode code
;	that called it.
;
;	The nested task bit is not explicitly set since this code is
;	reached by a far call, not an interrupt or task gate.
;***********************************************************************
VCPISwitchToV86	proc	near


		; The interrupts and NMI is disabled.
	mov	al,DISABLE_NMI
	out	NMI_CMD,al

		; The stack is cleaned up by incrementing past the
		; 8 byte return address to the protected OS.
	add	esp,8

		; The EFLAGS value on the stack is set up so that V86
		; mode will be done.
	mov	dword ptr ss:[esp + 8],00023000h ; VM=1 + IOPL=3

		; The current data segment is loaded by incrementing the
		; code selecter by the size of one descriptor entry in the
		; GDT.	The data descriptor always follows the code desc.
	mov	ax,cs
	add	ax,8
	mov	ds,ax
	assume	ds:R_CODE

ifdef PICtrap
;QLEO  Initialize the Master PIC In Service Register
	mov	ax,1011b		; read ISR
	out	20h,al
	in	al,20h			; read ISR from master PIC
	mov	[MasterIS],ax		; save ISR state
	mov	al,[LastOCW3]
	out	20h,al			; restore last OCW3
;QLEO
endif
;
;  Insure that CR2 is 0: This allows determination of Page Faults
;
	mov	eax,cr2			; preserve CR2 across VCPI interface
	mov	[saved_cr2],eax		; this is for PharLap's DOS extenders
	xor	eax,eax
	mov	cr2,eax

		; The saved page table directory address must be loaded
		; to return to CEMM's linear space.
	mov	eax,cr3
	and	eax,0FFFh			; clear address
	or	eax,dword ptr [saved_cr3]       ; address
	mov	cr3,eax

		; The previously saved system registers are restored.  Even
		; though the new GDT and IDT are not addressable through the
		; VCPI program's page tables yet, its okay because all of the
		; selectors have their hidden parts still intact.
	db	66h
	lgdt	fword ptr [saved_gdtr]	; -> 16 bit limit : 32 bit base
	db	66h
	lidt	fword ptr [saved_idtr]	; -> 16 bit limit : 32 bit base

		; Now the LDT and TSS can be loaded.
	lldt	word ptr [saved_ldtr]
	ltr	word ptr [saved_tr]

		; NMI's are reenabled.
	mov	al,ENABLE_NMI
	out	NMI_CMD,al

VCPIReturnFromProt:

		; The control is passed back using the stack frame provided.
	iretd
VCPISwitchToV86	endp

;***********************************************************************
; VCPISwitchToProtected
;
; ENTRY
;	ESI = linear address of data struct to be used.
; EXIT
;	Interrupts disabled
; DESCRIPTION
;	This procedure changes the system registers and switches control
;	to the VCPI program.  Interrupts are left disabled and the current
;	CEMM stack is cleaned up as this routine does not return.  This
;	code saves the current system registers GDT, LDT, IDT, TSS and CR3
;	for restoration later on.  The busy bit in the TSS descriptor is
;	also reset.
;***********************************************************************

Switch_to_protected_struc	struc
	Switch_CR3		dd	?
	Switch_GDTR_ptr		dd      ?	; -> fword
	Switch_IDTR_ptr		dd      ?	; -> fword
	Switch_LDT_sel		dw      ?
	Switch_TR_sel		dw      ?
	Switch_EIP		dd      ?
	Switch_CS		dw      ?
Switch_to_protected_struc	ends

VCPISwitchToProtected	proc	near

		; The interrupts and NMI is disabled.
	mov	al,DISABLE_NMI
	out	NMI_CMD,al

		;restore users BP from stack frame
	mov	ebp,[bp]

		; The stack is cleared up since this doesn't return by
		; resetting the stack pointer.	This code assumes that a
		; transfer to the ring 0 stack was done when executing the
		; INT 67h.
;LEO	mov	sp,OFFSET STACK:stack0_top

	push	RMS_GSEL
	pop	ss
	mov	sp,OFFSET R_STACK:RealStackTop

		; The current GDT,IDT,LDT, CR3 and TSS are saved.
		; We cannot use CS for this since it is a write operation.
	mov	ax,RCODEA_GSEL
	mov	ds,ax
	assume	ds:R_CODE
	db	66h
	sgdt	fword ptr [saved_gdtr]
	db	66h
	sidt	fword ptr [saved_idtr]
	sldt	word ptr [saved_ldtr]
	str	word ptr [saved_tr]
	mov	eax,cr3
	and	ax,NOT 0FFFh			; clear control bits
	mov	dword ptr [saved_cr3],eax

;
;  Restore CR2 for the VCPI client
;
	mov	eax,[saved_cr2]			; this is for PharLap's DOS extenders
	mov	cr2,eax

		; The current TSS's busy bit is reset
	mov	ax,GDTD_GSEL
	mov	ds,ax
	assume	ds:GDT
	and	byte ptr ds:[TSS_GSEL + 5],TSS_RESET_BUSY

		; A special 4GB zero based descriptor is set up for ds:ESI.
	mov	ax,DATA32_GSEL
	mov	ds,ax
	assume	ds:nothing

		; CR3 is loaded from the table.  This will cause new memory
		; fetches to go through the new page tables but since the
		; VCPI code is located in 640k memory which is duplicated in
		; both versions of page tables, this is no problem.
	push	ebx
	mov	eax,cr3
	and	eax,0FFFh		; clear address
	mov	ebx,[esi.Switch_CR3]
	and	bx,NOT 0FFFh		; clear control bits
	or	eax,ebx
	mov	cr3,eax

		; Turn off the busy bit for the TSS entry in the GDT. This
		; is done by loading the base address of the GDT.
		; Then the TR selector and the GDT address are used with
		; the zero based DS selector to reset the busy bit.
	mov	eax,[esi.Switch_GDTR_ptr]
	mov	eax,dword ptr [eax + 2]
	movzx	ebx,word ptr [esi.Switch_TR_sel]
	and	bl,0F8h				;remove TI and RPL bits
	and	byte ptr [eax + ebx + 5],TSS_RESET_BUSY
	pop	ebx

		; The GDT and IDT pointers are loaded from the table.
		; NOTE: even though the GDT has changed, the current selectors
		; are still valid because of the hidden parts that were loaded
		; with the base address and limit.
	mov	eax,[esi.Switch_GDTR_ptr]
	db	66h
	lgdt	fword ptr [eax]		; -> 16 bit limit : 32 bit base

	mov	eax,[esi.Switch_IDTR_ptr]
	db	66h
	lidt	fword ptr [eax]		; -> 16 bit limit : 32 bit base

		; The LDT and TR are loaded from the table.
	lldt	word ptr [esi.Switch_LDT_sel]
	ltr	word ptr [esi.Switch_TR_sel]

		; The return address is pushed on the stack.  This returns
		; into the VCPI program's code.
	push	0
	push	word ptr [esi.Switch_CS]
	push	dword ptr [esi.Switch_EIP]

		; NMI's are reenabled.
	mov	al,ENABLE_NMI
	out	NMI_CMD,al

		; A far USE32 bit return is done.
	db	66h
	retf
VCPISwitchToProtected	endp
page
;***********************************************************************
; VCPIServerContext:	This routine saves the VCPI client's system
;	context, and switches to EMM386's context.
;
; ENTRY
;	System tables and segment regs setup with client's context
;
; EXIT
;	System tables setup for EMM386 context
;	CS  = R1_CODE
;	DS  = _DATA
;	ES  = ABS0
;	FS  = NULL
;	GS  = R_CODE
; Used:
;	EAX
;
;***********************************************************************
	public	VCPIServerContext

VCPIServerContext proc	near

	cli
	mov	al,DISABLE_NMI
	out	NMI_CMD,al

	mov	ax, cs			; make sure DS -> R_CODE
	add	ax, 8
	mov	ds,ax
	assume	ds:R_CODE

	pop	ax			; save near return address
	mov	[ret_addr], ax

;  Save the client's context so it can be restored later

	mov	[client_cs], cs 	; save CS selector client is using

	push	ebp			; save more client state on it's stack
	push	fs
	push	gs

	mov	[client_ss], ss 	; save client stack
	mov	[client_esp], esp

		; The current GDT,IDT,LDT, CR2, CR3 and TSS are saved.
	db	66h
	sgdt	[client_gdtr]
	db	66h
	sidt	[client_idtr]
	sldt	word ptr [client_ldtr]
	str	word ptr [client_tr]
	mov	eax, cr2
	mov	[client_cr2], eax
	mov	eax,cr3
	and	ax,NOT 0FFFh			; clear control bits
	mov	dword ptr [client_cr3],eax

;  Now setup the server's (EMM386) context

	xor	eax, eax
	mov	cr2, eax

		; The saved page table directory address must be loaded
		; to return to EMM386's linear space.
	mov	eax,cr3
	and	eax,0FFFh			; clear address
	or	eax,dword ptr [saved_cr3]       ; address
	mov	cr3,eax

		; The previously saved system registers are restored.  Even
		; though the new GDT and IDT are not addressable through the
		; VCPI program's page tables yet, its okay because all of the
		; selectors have their hidden parts still intact.
	db	66h
	lgdt	fword ptr [saved_gdtr]	; -> 16 bit limit : 32 bit base
	db	66h
	lidt	fword ptr [saved_idtr]	; -> 16 bit limit : 32 bit base

		; Now the LDT and TSS can be loaded.
	lldt	word ptr [saved_ldtr]
	ltr	word ptr [saved_tr]

		; Now setup segment registers using our GDT
	Pjmp	R1CODE_GSEL,R1_CODE:VSC_load_seg
VSC_load_seg:
	mov	ax, VDMD_GSEL
	mov	ds, ax			; ds = _DATA
	mov	ax, DATA32_GSEL
	mov	es, ax			; es = 4 Gb
	xor	ax, ax
	mov	fs, ax			; fs = NULL
	mov	ax, RCODEA_GSEL
	mov	gs, ax			; gs = R_CODE
	assume	DS:_DATA,es:ABS0,fs:NOTHING,gs:R_CODE

		; setup stack frame from EMM386 TSS
	mov	ss, [TSS].TSS386_SS0
	mov	esp, [TSS].TSS386_ESP0
	sub	esp, [VTFO][size VM_TRAP_FRAME]
	mov	ebp, esp

		; dummy up some values in the VM TRAP FRAME
	xor	eax, eax
	mov	dword ptr [bp][VTFO].VMTF_GS, eax
	mov	dword ptr [bp][VTFO].VMTF_FS, eax
	mov	dword ptr [bp][VTFO].VMTF_DS, eax
	mov	dword ptr [bp][VTFO].VMTF_ES, eax
	mov	ax, [segR1_CODE]
	mov	dword ptr [bp][VTFO].VMTF_SS, eax	; a stack to use if
	mov	ax, offset R1_CODE:RealStack2_top	;   V86 mode used
	mov	dword ptr [bp][VTFO].VMTF_ESP, eax
	mov	dword ptr [bp][VTFO].VMTF_EFLAGS, (FLAGS_VM SHL 16) OR FLAGS_IOPL

		; NMI's are reenabled.
	mov	al,ENABLE_NMI
	out	NMI_CMD,al

	jmp	[ret_addr]		; 'return' to caller in EMM386 context

VCPIServerContext endp

;***********************************************************************
; VCPIClientContext:	This routine restores the VCPI client's saved
;	system context.
;
; ENTRY
;
; EXIT
;	System tables and segment registers setup for client context
; Used:
;	EAX, EBX
;
;***********************************************************************
	public	VCPIClientContext
	assume	DS:_DATA,es:NOTHING,fs:NOTHING,gs:R_CODE

VCPIClientContext proc	 near

	cli
	mov	al,DISABLE_NMI
	out	NMI_CMD,al

	pop	ax			; save near return address
	mov	[ret_addr], ax

		; Restore CR2 for the VCPI client
	mov	eax,[client_cr2]	; this is for PharLap's DOS extenders
	mov	cr2,eax

		; The current TSS's busy bit is reset
	mov	ax,GDTD_GSEL
	mov	ds,ax
	assume	ds:GDT
	and	byte ptr ds:[TSS_GSEL + 5],TSS_RESET_BUSY

	mov	ax, DATA32_GSEL
	mov	ds, ax
	assume	ds:NOTHING

		; CR3 is loaded from the table.  This will cause new memory
		; fetches to go through the new page tables but since the
		; VCPI code is located in 640k memory which is duplicated in
		; both versions of page tables, this is no problem.
	mov	eax,cr3
	and	eax,0FFFh		; clear address
	or	eax, [client_CR3]
	mov	cr3,eax

		; The GDT and IDT pointers are loaded.
		; NOTE: even though the GDT has changed, the current selectors
		; are still valid because of the hidden parts that were loaded
		; with the base address and limit.
	db	66h
	lgdt	[client_gdtr]		; -> 16 bit limit : 32 bit base

	db	66h
	lidt	[client_idtr]		; -> 16 bit limit : 32 bit base

		; Turn off the busy bit for the TSS entry in the GDT. This
		; is done by loading the base address of the GDT.
		; Then the TR selector and the GDT address are used with
		; the zero based DS selector to reset the busy bit.
	mov	eax, dword ptr [client_gdtr + 2]
	movzx	ebx, [client_tr]
	and	bl,0F8h				;remove TI and RPL bits
	and	byte ptr [eax + ebx + 5],TSS_RESET_BUSY

		; The LDT and TR are loaded.
	lldt	[client_ldtr]
	ltr	[client_tr]

		; Restore client stack and segment registers

	jmp	dword ptr [client_jmpfar]   ; loads CS, goes to VCC_load_seg
VCC_load_seg:

	mov	ss, [client_ss]
	mov	esp, [client_esp]

	mov	ax, cs
	add	ax, 8
	mov	ds, ax
	add	ax, 8
	mov	es, ax
	pop	gs
	pop	fs
	pop	ebp
	assume	ds:R_CODE,es:NOTHING,fs:NOTHING,gs:NOTHING

		; NMI's are reenabled.
	mov	al,ENABLE_NMI
	out	NMI_CMD,al

	jmp	[ret_addr]		; 'return' to caller in client context

VCPIClientContext endp

page
assume cs:R1_CODE,ds:R_CODE,es:nothing,fs:nothing,gs:nothing
;==============================================================================
;==
;== VCPItoEMSspace: Moves a 16K EMS page to the free EMS handle space
;==
;== Entry
;==	ESI = index into a 4K VCPI page
;==	DS  = R_CODE
;==	ES  = PAGED_GSEL
;==
;== Exit
;==	EAX = base address of EMS page if page moved, 0 otherwise
;==
;==============================================================================
VCPItoEMSspaceFar proc	far
	call	VCPItoEMSspace
	ret
VCPItoEMSspaceFar	endp

VCPItoEMSspace proc	near
;
;  Check if this freed up a 16K page: If so, place it in the free EMS space
;
	xor	ebx, ebx
	and	si,not 3		; 16K boundary

	test	word ptr es:[esi*4],fVCPIPageAllocated
	jnz	VTEexit
	test	word ptr es:[esi*4+4],fVCPIPageAllocated
	jnz	VTEexit
	test	word ptr es:[esi*4+8],fVCPIPageAllocated
	jnz	VTEexit
	test	word ptr es:[esi*4+12],fVCPIPageAllocated
	jnz	VTEexit

	mov	ebx, es:[esi*4] 	; base address for EMS page
;
;  Is this 16K page already in top
;
	cmp	si, [TopOfFreeEMSspace] ;Q: Move anything?
	je	short VTEdone		; N: exit
	jb	short VTEerror

;
;  Move VCPI space up 4 entries
;
	movzx	ecx,si			; start of source
	sub	cx,[BotOfVCPIspace]	; number of entries to move
	jbe	short VTEclearFree
	add	si,3			; start index of destination
	shl	si,2			; offset
	mov	edi,esi			; destination
	sub	esi,4*4			; source

	std				; reverse move
	REP_MOVS_DWORD_USING_ES_ESI

VTEclearFree:
	cld				; clear direction flag
	mov	cx, 4
	xor	eax, eax
	movzx	edi, [BotOfVCPIspace]	; zero 4 invalid entries
	shl	di, 2			; offset
	REP_STOS_DWORD_PTR_ES_EDI

	mov	eax, ebx
	movzx	edi, [TopOfFreeEMSspace]; store page entries in EMS space
	shl	di, 2			; offset
	STOS_DWORD_PTR_ES_EDI		; eax has base address for EMS page
	add	eax,1000h
	STOS_DWORD_PTR_ES_EDI
	add	eax,1000h
	STOS_DWORD_PTR_ES_EDI
	add	eax,1000h
	STOS_DWORD_PTR_ES_EDI
VTEdone:
;
;  Add a 16K EMS page to the free EMS space, remove it from VCPI space
;
	add	[TopOfFreeEMSspace],4
	add	[BotOfVCPIspace], 4
VTEexit:
	mov	eax, ebx		; base address or 0
	ret
VTEerror:
ifdef BETA
int 1;beta
endif
	jmp	short VTEexit
VCPItoEMSspace	endp
R1_CODE	ends
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\umbseg.asm ===
.386p
page 58,132
;******************************************************************************
	title	EMM - Expanded Memory Manager interface for EMM386
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;
;    Title:	EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
;    Module:	EMM - Expanded Memory Manager interface
;
;    Version:	2.05
;
;    Date:	June 28, 1991
;
;    Author:	Harish Naidu
;
;******************************************************************************
;
;	Change Log:
;
;	DATE	 REVISION	Description
;	-------- --------	--------------------------------------------
;	06/28/91 original
;
;******************************************************************************
;   Functional Description:
;
;	This module contains most of R1_CODE segment. The other files that 
;   contain R1_CODE are vcpi.asm and errhndlr.asm. This segment will be 
;   moved into UMBs if noems or ram is specifed in the emm386.exe device
;   line. The user can use nohi to prevent this segment from going into 
;   UMBs.
;
;******************************************************************************
	page
;******************************************************************************
;			P U B L I C   D E C L A R A T I O N S
;******************************************************************************
;
	public	UMBFARTABLE
	public	UMBADDRLEN
	public	EMM_rFarEntry
	public	StrategyEntry
	public	InterruptEntry
	public	rInt13HEntry
	public	ReqPtr
	public	OldInt13
	public	PrevInt4B
	public	rINT4BhHandler

	public	I13SectTrans		
	public	I13DriveTrap		
	public	SectorsInDMABuffer	
	public	LongSectorsInDMABuffer	

	public	CopyInstData
	public	ValidPathFar
	public	PrevXmm
	public	rXMMentry
	public	XMMAllocHMAFar
	public	XMMDeallHMAFar
	public	checkXMMFar

	public	PrevInt10
	public	PrevInt11
	public	Int10_Hook
	public	Int11_Hook

	public	chkMcStateFar
	public	EHFarReturn


	page
;******************************************************************************
;			L O C A L   C O N S T A N T S
;******************************************************************************
;
	include vdmseg.inc
	include vdmsel.inc
	include vm386.inc
	include emm386.inc
	include emmfunct.inc
	include emmdata.inc

	include driver.equ
	include driver.inc

	include i13.inc
	include	winemm.inc
	include	xmm.inc
	include	desc.inc

;******************************************************************************
;			E X T E R N A L    R E F E R E N C E S
;******************************************************************************
;

_TEXT	segment
	extrn	EMSDispatcher:far
	extrn	EnterVirtual:far
	extrn	VCPIDispatcher:far
_TEXT	ends

LAST	segment
	extrn	Init_CEMM386:far	; initializes VDM,EMM, and driver
	extrn	Inv_DOS_msg:byte
	extrn	InitMessage:byte
LAST	ends

R1_CODE	segment
	extrn	CEMMpath:byte
	extrn	EHReturnFar:byte
	extrn	end_of_R1_CODE:byte
R1_CODE	ends



R_CODE	segment

	;
	; This table contains dword ptrs thru which R_CODE accesses R1_CODE.
	; The actual segment value of R1_CODE is patched into this table 
	; if R1_CODE is moved in MovUmbSeg in init.asm
	;

	EVEN
UMBFARTABLE	LABEL	WORD
	
EMM_rFarEntry	DW	OFFSET R1_CODE:EMM_rEntryFar	, seg R1_CODE
EMM_rFarReturn	DW	OFFSET R1_CODE:EMM_rReturnFar	, seg R1_CODE
EMM_vFarReturn	DW	OFFSET R1_CODE:EMM_vReturnFar	, seg R1_CODE
StrategyEntry	DW	OFFSET R1_CODE:STRATEGY_Far	, seg R1_CODE
InterruptEntry	DW	OFFSET R1_CODE:Interrupt_Far	, seg R1_CODE
rInt13HEntry	DW	OFFSET R1_CODE:rFarINT13hHandler, seg R1_CODE
CopyInstData	DW	OFFSET R1_CODE:Copy_Inst_Data	, seg R1_CODE
ValidPathFar	DW	OFFSET R1_CODE:ValidatePath	, seg R1_CODE
XMMAllocHMAFar	DW	OFFSET R1_CODE:XMMAllocateHMA	, seg R1_CODE
XMMDeallHMAFar 	DW	OFFSET R1_CODE:XMMDeallocateHMA	, seg R1_CODE
checkXMMFar	DW	OFFSET R1_CODE:check_XMM	, seg R1_CODE
chkMcStateFar	DW	OFFSET R1_CODE:chk_machine_state, seg R1_CODE
EHFarReturn	DW	OFFSET R1_CODE:EHReturnFar	, seg R1_CODE

UMBADDRLEN	EQU	($ - UMBFARTABLE) / 4


	extrn	GoVirtualMode:near
	extrn	GoRealMode:near
	extrn	GoProtMode:near
	extrn	ChkA20:near
	extrn	Devname:byte

	extrn	ELIM_Entry:far		; general entry for CEMM functions
	extrn	SIG_LENGTH:abs
	extrn	Linkbuf_length:abs
	extrn	EMMGIDataVer:word
	extrn	XMMcontrol:dword
	extrn	DriverVersion:word

R_CODE	ends

R_CODE	segment
	assume	cs:R_CODE
;-------------------------------------------------------------------------
;
; Far interfaces to routines in R_CODE segment. Note that these far 
; interfaces are used only by the routine EMM_rEntryFar and hence their 
; returns are hard coded.
;
;------------------------------------------------------------------------


FarGoVirtualMode	proc	far
	call	GoVirtualMode
	jmp	dword ptr cs:[EMM_vFarReturn]
FarGoVirtualMode	endp

FarGoRealMode		proc	far
	call	GoRealMode
	jmp	dword ptr cs:[EMM_rFarReturn]

FarGoRealMode		endp

FarGoProtMode	proc	far
	call	GoProtMode
	PJmp	R1CODE_GSEL,R1_CODE:EMS_Entry
FarGoProtMode	endp

FarChkA20		proc	far
	call	ChkA20	
	ret
FarChkA20	endp
	
R_CODE	ends


R1_CODE	segment
	assume	cs:R1_CODE


;#########################################################################
;
; EMM_rEntryFar - real/virtual mode entry point for EMM function calls
;
; ENTRY:
;	real/virtual mode 
;	GS = R_CODE
;
; EXIT:
;	real/virtual mode
;
; DESCRIPTION:
;	If CEMM is off then an appropriate error code is returned in AH.
;	If CEMM is in auto mode and off then the EMS call is done from here
;	and CEMM is returned in either auto off state or ON state.  If CEMM
;	is on this this call simply reflects it back to the protected entry
;	point.
;
;##########################################################################

EMM_rEntryFar	proc	far

	; The interrupts are cleared in case the user didn't use the
	; int opcode but just pushed the flags and called.
	cli

	;
	; If CEMM is active (ON) then the call to here is done so that
	; any routines that patched out int 67h will be done first.
	; Now the EMMp_Entry routine is called with the flag set.
	;
	test	gs:[Current_State],fState_Active
	jz	short EMM_rChkOFF
	or	gs:[TrapFlags],fI67trap
	int	67h
	ret

	;
	; If CEMM is off then an appropriate error code needs to be set.
	;
EMM_rChkOFF:
	cmp	gs:[Current_Mode],MODE_OFF
	jne	short EMM_protected_mode
	mov	ah,EMM_SW_MALFUNCTION
	ret

	;
	; At this point EMM386 is inactive. Which means UMBs could not have 
	; been present. Hence this segment could not have been in UMBs. 
	; Therefore the following code is free to switch modes.
	;
EMM_protected_mode:

	;
	;  The user stack is changed to the CEMM Real Stack
	;
	mov	gs:[UserSS],ss
	mov	gs:[UserSP],sp
	push	seg R_STACK
	pop	ss
	lea	sp,R_STACK:RealStackTop

	;
	;  The user's segment registers are pushed on the stack.
	;
	push	gs
	push	fs
	push	es
	push	ds

	call	far ptr chk_machine_state
					; Q: is the machine in real mode
	jc	Emm_rError1		; N: return error

	mov	gs:[UserDS],ds
	mov	gs:[UserES],es

	;
	; The A20 line is activated and the system taken in protected
	; mode.
	;
	call	FarChkA20

	jmp	FarGoProtMode
EMS_Entry:
	jc	EMM_rError

	;
	; The DS and GS selectors are set up.
	;
	push	VDMD_GSEL
	pop	ds
	assume	ds:_DATA
	push	RCODEA_GSEL
	pop	gs
	assume	gs:R_CODE
	
	;
	;  Save CEMM real stack and change to protected mode stack
	;
	mov	gs:[RealSS],ss
	mov	gs:[RealSP],sp
	push	VDMS_GSEL
	pop	ss
	mov	sp,gs:[StackTop]

	push	gs:[UserES]
	push	gs:[UserDS]

	;
	; The function number is saved and the call done.
	;
	mov	[function_number],ah

	;
	; Check to see if its a VCPI function or EMS function. Call 
	; proper dispatcher.
	;
	cmp	ah,VCPI_FUNCTION_OPCODE
	je	short ErE_VCPI_function

	PCall	VDMC_GSEL,_TEXT:EMSDispatcher
	jmp	short ErEcont

ErE_VCPI_function:
	PCall	VDMC_GSEL,_TEXT:VCPIDispatcher
ErEcont:
	
	;
	;  Restore CEMM real stack
	;
	mov	ss,gs:[RealSS]
	mov	sp,gs:[RealSP]

	;
	; Failures (namely invalid functions) should not turn on.
	;
	cmp	ah,0
	jne	short EMM_rRetReal

	;
	; The function is checked for the status call.  If anything
	; but status is done then take CEMM in ON mode.
	;
	cmp	[function_number],EMS_STATUS_FUNCTION
	JE	SHORT EMM_rRetReal	; Y: Return to real mode	;@PIW

EMM_turn_CEMM_on:
	PCall	VDMC_GSEL, _TEXT:EnterVirtual
	PJmp	RCODE_GSEL, R_CODE:FarGoVirtualMode
EMM_vReturnFar:

	mov	gs:[Current_Mode],MODE_ON
	or	gs:[Current_State],fState_Active
	jmp	short EMM_rExit

EMM_rRetReal:
	;
	; At this point we're in protected mode hence we have to do a far
	; jmp
	;
	PJmp	RCODE_GSEL,R_CODE:FarGoRealMode
EMM_rReturnFar:

EMM_rExit:
	pop	ds
	pop	es
	pop	fs
	pop	gs

	;
	;  Restore user stack
	;
	mov	ss,gs:[UserSS]
	mov	sp,gs:[UserSP]
	ret

EMM_rError:
	mov	gs:[Current_Mode],MODE_OFF 	     ; set mode to OFF
	mov	gs:[Devname],'$'		     ; set to prevent presense detect
	and	gs:[Current_State],NOT fState_Active ; reset active flag &
EMM_rError1:
	mov     ah,EMM_SW_MALFUNCTION		     ; S/W cannot control A20
	jmp	short EMM_rExit

EMM_rEntryFar	endp


;===========================================================================
;
;	Routines associated with STRATEGY and INTERRUPT
;
;===========================================================================

;	Define the command dispatch table for the driver functions
;
Cmd_Table	LABEL		NEAR
	DW	Init_Call		;0 - Initialization
	DW	Null_Exit		;1 - Media Check
	DW	Null_Exit		;2 - Get BPB
	DW  	EMM_IOCTL_READ		;3 - IOCTL input
	DW	Null_Exit		;4 - Input (Destructive)
	DW	Null_Exit		;5 - No wait input
	DW	Null_Exit		;6 - Input status
	DW	Null_Exit		;7 - Input buffer flush
	DW	Null_Exit		;8 - Output (Write)
	DW	Null_Exit		;9 - Output with verify
	DW	Null_Exit		;A - Output status
	DW	Null_Exit		;B - Output buffer flush
	DW	Null_Exit		;C - IOCTL output

TBL_LENGTH	EQU		(THIS BYTE-CMD_TABLE)/2 


ReqPtr		label	dword	; dword ptr to Request Header
ReqOff		dw	0	; saved offset of Request Header
ReqSeg		dw	0	; saved segment of Request Header

fFirstTime	db	0	; first time initialization flag

;=============================================================================

STRATEGY_Far	proc	far

	mov	cs:[ReqOff],bx ;Save header offset
	mov	cs:[ReqSeg],es ;Save header segment
	ret

STRATEGY_Far endp


;******************************************************************************
;	Interrupt - device driver interrupt routine for CEMM
;
;	ENTRY: R1_CODE:ReqPtr = pointer to request header.
;
;	EXIT: Request completed.
;
;	USED: none
;
;******************************************************************************
Interrupt_Far	proc		far

	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	ds
	push	es
	cld					;All strings forward
	lds	bx,CS:[ReqPtr]			;DS:BX pts to Request Header
	mov	al,[bx].COMMAND_CODE		;Get the command code
	cmp	al,TBL_LENGTH			;Check for validity
	jae	short Invalid 			;Jump if command invalid
	cbw					;Command to a full word
	shl	ax,1				;Compute dispatch index
	mov	si,OFFSET Cmd_Table		;Point to dispatch table
	add	si,ax				;Index based on command
	call	CS:[si] 			;Call correct routine
;
;   ENTRY:	AX = Status field for Request Header
;
FINISH:
	lds	bx,CS:[ReqPtr]	;Get request header ptr.
	or	ah,DON			;Set done bit in status
	mov	DS:[bx.STATUS_WORD],ax	;Save status in header
	pop	es			;Restore the ES register
	pop	ds
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret
Invalid:
	mov	al,UNK_COMMAND		; unknown command
	mov	ah,ERR			; error
	stc
	jmp	SHORT Finish
Interrupt_Far	endp

;******************************************************************************
;	Null_Exit: do nothing
;
;	ENTRY: DS:BX pts to request header
;
;	EXIT:	No error returned.
;		CLC
;
;******************************************************************************
Null_Exit	proc	near
;
	xor	ax,ax
	clc
	ret
;
Null_Exit	endp

;******************************************************************************
;	Init_Call - call initialization routine
;
;	ENTRY: DS:BX pts to request header
;
;	EXIT: AX = status field for request header
;
;******************************************************************************
Init_Call	proc	near
;
	cmp	cs:[fFirstTime], 0	; Will be called twice if 2 device
	jne	init_done		;   headers used, only init once

	inc	cs:[fFirstTime] 	; Don't init again

	call	Init_CEMM386

init_done:
	ret
;
Init_Call	endp

;
; Dispatch Table for IOCTL read ax=4402
;
EMMRDTBL	DB	05
  		DW 	Rtn_Signet
  		dw 	EMMGlobImpIOCTL
		dw	GetVersion
		dw	GetEMSMinMax
		dw	GetUMBsegInfo

;###########################################################################
;
; Procedure name  : EMM_IOCTL_READ
;
; Entry:  The destination buffer pointed to by the request header points to
;         an 8 byte buffer whos first byte is a function code (either 0 or 1)
;
; exit:  the appropriate function is executed if wrong code then error.
;
;############################################################################

EMM_IOCTL_READ 	proc 	near

	push	ax
	push	si

 	les 	di,ds:[bx+14]		; es:di -> dest. buffer
 	mov 	al,es:[di]   	       	; al = command code
 	cmp 	al,cs:[EMMRDTBL]
 	jae 	IOCTLerr
	cbw
	mov	si,ax
	shl	si,1
	call 	cs:word ptr [EMMRDTBL][1][si]
	xor	ax,ax

IOCTLexit:
	pop	si
	pop	ax
 	ret

IOCTLerr:
 	mov al,UNK_COMMAND		; unknown command       *C
 	mov ah,ERR 		        ; error         	*C
 	mov word ptr DS:[bx+18],0	; no bytes transferred  *C
	jmp	short IOCTLexit
EMM_IOCTL_READ endp

;*****************************************************************************C
;	Rtn_Signet - return signature and entry address 		     *C
;									     *C
;	ENTRY: DS:BX pts to request header				     *C
;									     *C
;	EXIT: AX = status field for request header			     *C
;									     *C
;*****************************************************************************C
Rtn_Signet	proc	near	       ; special read request from CEMM.EXE  *C
	cmp	word ptr DS:[bx+18],Linkbuf_length ; make sure our length    *C
	jne	short Rerr		       ;			     *C

	mov	word ptr ES:[di],SIG_LENGTH ; send back signature length     *C
	mov	word ptr ES:[di+2],OFFSET ELIM_Entry ; entry offset	     *C
	mov	word ptr ES:[di+4],SEG ELIM_Entry ; entry segment	     *C

	xor	ax,ax		       ; good status			     *C
	ret			       ;				     *C
				       ;				     *C
Rerr:	mov	al,UNK_COMMAND	       ; unknown command		     *C
	mov	ah,ERR		       ; error				     *C
	mov	word ptr DS:[bx+18],0  ; no bytes transferred		     *C
	ret			       ;				     *C
Rtn_Signet	endp		       ;				     *C

;==============================================================================
;==
;==  GetVersion: Returns version of CEMM/EMM386 driver.
;==
;==  Entry: Buffer is pointed to by request header.
;==	DS:BX	= Request Header
;==	ES:DI	= Destination Buffer
;==
;==  Exit:  Fills buffer with version number of CEMM/EMM386 driver.
;==
;==============================================================================
GetVersion proc	near
	push	ax
	push	gs

	mov	ax, seg R_CODE
	mov	gs, ax

	cmp	word ptr ds:[bx][18],2	;Q: Must be a 2 byte buffer?
	jne	short GVerror		; N: error
;
;  Set version number of driver.
;
	mov	ax,gs:[DriverVersion]	; get driver version number
	mov	es:[di],ax		; return address

;  Also an entry point from GetEMSMinMax

GVexit:
	pop	gs
	pop	ax
	ret
;
;  Error return, also an entry point from GetEMSMinMax
;
GVerror:
 	mov 	al,UNK_COMMAND          ; unknown command
 	mov 	ah,ERR           	; error
 	mov	word ptr ds:[bx][18],0	; no bytes transferred
	jmp	short GVexit
GetVersion	endp

;==============================================================================
;==
;==  GetEMSMinMax:  Returns max/min EMS/VCPI size info
;==
;==  Entry: Buffer is pointed to by request header.
;==	DS:BX	= Request Header
;==	ES:DI	= Destination Buffer
;==
;==  Exit:  Fills buffer with max & min EMS/VCPI pool size
;==
;==============================================================================
GetEMSMinMax	proc near
	push	ax
	push	gs

	push	seg R_CODE
	pop	gs

	cmp	word ptr ds:[bx][18],4	;Q: Must be a 4 byte buffer?
	jne	short GVerror		; N: error

	mov	ax, gs:[MaxEMSpool]
	mov	es:[di], ax
	mov	ax, gs:[MinEMSpool]
	mov	es:[di+2], ax

	jmp	short GVexit

GetEMSMinMax	endp


;==============================================================================
;==
;==  GetUMBsegInfo:  Returns location and size of UMB segment
;==
;==  Entry: Buffer is pointed to by request header.
;==	DS:BX	= Request Header
;==	ES:DI	= Destination Buffer
;==
;==  Exit:  Fills buffer with UMB segment paragraph address & length, and
;==	    count of WIN= pages
;==
;==============================================================================
GetUMBsegInfo	proc near

	push	ax
	push	gs

	push	seg R_CODE
	pop	gs

	cmp	word ptr ds:[bx][18],6	;Q: Must be a 6 byte buffer?
	jne	short GVerror		; N: error

	mov	ax, gs:[segR1_CODE]
	mov	es:[di], ax
	mov	ax, offset R1_CODE:end_of_R1_CODE
	add	ax, 0fh
	shr	ax, 4			;round size up to nearest paragraph
	mov	es:[di+2], ax
	mov	ax, gs:[cntWinPages]	;count of WIN= pages
	mov	es:[di+4], ax

	jmp	short GVexit

GetUMBsegInfo	endp


;==============================================================================
;==
;==  EMMGlobImpIOCTL: Windows opens that "EMMXXX0" device and does a read IOCTL.
;==		      This routine fills up a buffer with version information
;==		      and the physical address of the EMM Global Import Data
;==		      Structure.
;==
;==  Entry: Buffer is pointed to by request header.
;==	DS:BX	= Request Header
;==	ES:DI	= Destination Buffer
;==
;==  Exit:  Fills buffer with version number and physical address of EMM
;==	    Global Import Data Structure.
;==
;==============================================================================
EMMGlobImpIOCTL	proc	near

	push	ebx
	push	gs

	push	seg R_CODE
	pop	gs

	cmp	word ptr ds:[bx][18],6	;Q: Must be a 6 byte buffer?
	jne	short EGIIerror		; N: error

	mov	ebx,gs:[PageD_Addr]	; get physical address of PD
;
;  Set physical address for EMM Global Import Data Structure
;
	add	ebx,PAGE_SIZE		; PF0 address: used for data structure
	mov	es:[di],ebx		; return address
;
;  Set version of EMM Global Import Interface to execute
;
	mov	bx,gs:[EMMGIDataVer]
	xchg	bh,bl
	mov	es:[di][4],bx

EMMGIIOCTLexit:
	pop	gs
	pop	ebx
	ret
;
;  Error return
;
EGIIerror:
 	mov 	al,UNK_COMMAND          ; unknown command
 	mov 	ah,ERR           	; error
 	mov	word ptr ds:[bx][18],0	; no bytes transferred
	jmp	short EMMGIIOCTLexit
EMMGlobImpIOCTL	endp



;==========================================================================
;
;	DATA and CODE for INT13Handler
;
;==========================================================================


I13SectTrans		db	0	; Number of sectors transferred
I13DriveTrap		dd	-1	; Initially, trap all drives

SectorsInDMABuffer	db	0	; Sectors in DMA buffer
	db	TotalDrives-1	dup (0)

LongSectorsInDMABuffer	db	0	; Long Sectors in DMA buffer
	db	TotalDrives-1	dup (0)

OldInt13		dd	?


;==============================================================================
;==
;==  rFarINT13hHandler: 
;==
;==	This is an interrupt 13h handler which monitors activity to
;==     the drives for DMA purposes.  If it detects a user buffer
;==     (ES:BX) in an EMS window and its corresponding  physical
;==     memory is discontiguous, the operation will be modified.
;==
;==	1) The operation will be broken down to multiple read/
;==	   write requests, each being less than the DMA buffer.
;==
;==	2) If a format request is encountered, a flag will be
;==	   set so the DMA programming by the ROM will be modified
;==	   not to use a 64K buffer.
;==
;==  Entry: (Real Mode)
;==	INT 13h interface
;==
;==  Exit:
;==
;==============================================================================

rFarINT13hHandler:

	test	cl,3Fh			;Q: Sector 0?
	jz	short rfI13oldHandler	; Y: let the ROM handle it!

	cmp	ah,READ			;Q: Read request?
	je	short rI13Buffered	; Y: process

	cmp	ah,WRITE		;Q: Write request?
	je	short rI13Buffered	; Y: process

	cmp	ah,LONG+READ		;Q: Long read request?
	je	short rI13Buffered	; Y: process

	cmp	ah,LONG+WRITE		;Q: Long write request?
	je	short rI13Buffered	; Y: process
	jmp	short rfI13oldHandler

rI13oldHandlerX:
	pop	edx

rfI13oldHandler:
	jmp	cs:[OldInt13]


rI13Buffered:
	push	edx
	
	and	edx,0FFh		; drive number
	btr	dx,7			;Q: Is it a hard drive?
	jc	short rI13index		; Y: continue
	add	dx,FixedDrives		; N: floppy data
rI13index:
	cmp	dx,TotalDrives		;Q: Trap this drive?
	jae	short rI13oldHandlerX	; N: let ROM handle it

	bt	cs:[I13DriveTrap],edx	;Q: Trap this drive?
	jnc	short rI13oldHandlerX	; N: let ROM handle it

					;M012: use ah to test for LONG
	test	ah,LONG			;Q: Long sectors?
	jnz	rI13LongIO		; Y: use long sectors

	cmp	al,cs:[SectorsInDMABuffer][edx] 
					;Q: Will it fit in DMA buffer?
	jbe	short rI13oldHandlerX	; Y: let ROM go ahead
	jmp	short rI13ProcessIO	; N: process IO

rI13LongIO:
	cmp	al,cs:[LongSectorsInDMABuffer][edx] 
					;Q: Fit in DMA buffer?
	jbe	short rI13oldHandlerX	; Y: let ROM go ahead

rI13ProcessIO:
	pop	edx
	push	ebx
	push	ecx
	push	edx
	push	esi
	push	es

	push	fs			; 
	push	seg R_CODE		; 
	pop	fs			; 


;
;  Need to trap into protected mode to check for a contiguous buffer for floppy.
;  If buffer is not contiguous, the I/O will be broken down to no larger than
;  the DMA buffer size.
;
rI13SetUpIO:
	or	fs:[TrapFlags],fI13trap	; QHKN:trap this next int 13h
	int	13h			; and set up for next I/O

	push	fs			; save fs as the NCR386SX's SCSI ROM
					; destroys it
	pushf
	cli
	call	cs:[OldInt13]		; Q: Error on the I/O
	pop	fs			; restore fs
	jc	short rI13Return	; Y: return the error

	test	fs:[TrapFlags],fI13trap	;Q: Is the I/O request complete?
	jnz	rI13SetUpIO		; N: set up for the next I/O
	mov	al,cs:[I13SectTrans]	; Y: return total sectors transferred

rI13Return:
	pushf				; need to preserve carry flag
	and	fs:[TrapFlags],not fI13trap ; don't trap next int 13h **128KDMA
	popf
	pop	fs			;
	pop	es
	pop	esi
	pop	edx
	pop	ecx
	pop	ebx
	retf	02				; and return to caller


;===========================================================================
;
;	INT 4B Handler and data
;
;============================================================================

PrevInt4B		dd	0	; The old int4B vector

;==============================================================================
;==
;==  rINT4BhHandler: This is an entry point to the DMA/bus master services.
;==
;==  Entry: (Real Mode)
;==
;==  Exit:
;==
;==============================================================================

rINT4BhHandler:

	push	bp
	mov	bp,sp
	pushf
	push	fs

	push	seg R_CODE
	pop	fs			
	assume	fs:R_CODE

	cmp	ah,81h			;Q: DMA/bus master service request
	jne	short rI4BoldHandler	; N: chain it down

;
;  Need to trap into protected mode handler.
;
	push	ds

	push	seg ABS0
	pop	ds
	assume	ds:ABS0

	test	[DBSflag],fDBSactive	;Q: Active?
	pop	ds			; - restore DS
	jz	short rI4BoldHandler	; N: chain it down

	or	fs:[TrapFlags],fI4Btrap	; trap into DMA/bus master services

	pop	fs
	popf

	int	4Bh

	push	ax			; save ax
	pushf
	pop	ax			; return flags

	xchg	ax,[bp].INT_FLAGS	; entry flag in AX, return flags on stack

	and	ax,FLAGS_IF		; restore entry IF
	or	[bp].INT_FLAGS,ax

	pop	ax
	pop	bp
	iret

rI4BoldHandler:

	test	fs:[GenFlags], fMCA	; Q: MCA
	jz	short rI4BISA		; N: check is old vector 0 

	push	ds

	push	40h
	pop	ds

	test	byte ptr ds:[7bh], 8	; Q is bit 3 of byte at 40:7b set
	pop	ds

	jnz	short rI4BChain		; Y: chaining required

					
	cmp	word ptr cs:[PrevInt4B+2], 0e000h
					; Q: is previous seg e000
	je	short rI14Biret		; Y: don't chain, return 

	cmp	word ptr cs:[PrevInt4B+2], 0f000h
					; Q: is previous seg f000
	je	short rI14Biret		; Y: don't chain, return 

rI4BISA:
	cmp	cs:[PrevInt4B],0	;Q: Is old vector ZERO?
	jz	short rI14Biret		; Y: don't chain, return

rI4BChain:
	pop	fs
	popf
	pop	bp
	jmp	cs:[PrevInt4B]

rI14Biret:
	pop	fs
	popf
	pop	bp
	iret

;==========================================================================
;
;	Windows Interface Code and data
;
;==========================================================================

	assume	ds:nothing,es:nothing,fs:nothing,gs:nothing

;===========================================================================
;
;   Copy_Inst_Data
;
;   DESCRIPTION:
;   This procedure will copy instance data fields from the Windows/386 3.00
;   initialization data structure that specify instance data in Upper Memory
;   Blocks into a table inside of a LIMulator.	When Copy_Inst_Data returns
;   it will have filled in the LIMulator's table and removed the entries from
;   the Win386 initialization data structure.
;
;   ENTRY:
;	CX = Maximum number of entries to copy (6 bytes each)
;	ES:DI -> Area to copy instance info into
;		 Table should be of size CX*6+4 (add 4 for term dword 0)
;	ESI = Value passed by Windows 3.00 to LIMulator shut down procedure
;
;   EXIT:
;	If carry flag is clear then
;	    Success!
;	    CX = Number of entries NOT used in table
;	    ES:DI -> Byte past null termination dword in table
;	else
;	    ERROR:  Not enough space in table for all instance items
;
;   USES:
;	DS, EAX, EBX, ECX, EDX, ESI, EDI, EBP, Flags
;
;   Version:	1.00
;
;   Date:	24-Jul-1990
;
;   Author:	RAL
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   24-Jul-1990 RAL Original
;   25-Jul-1990 RAL Updated documentation
;   26-Jul-1990 RAL Fixed 2 bugs
;
;
;==============================================================================

Copy_Inst_Data PROC far

	cld

	mov	bx, si
	and	bx, 1111b
	shr	esi, 4
	mov	ds, si

	cmp	BYTE PTR [bx+4Bh], 1
	jne	CID_Success

	mov	esi, DWORD PTR [bx+26h]
	mov	ebx, esi
	shr	ebx, 4
	mov	ds, bx
	and	si, 1111b

;
;   At this point DS:SI -> Win386_Startup_Info_Struc
;
	push	ds
	push	si

	lds	si, [si.WSSInstData]
	mov	ax, ds				; Just to be paranoid...
	or	ax, si
	jz	CID_Success

;
;   Now move all instance fields from the current table into our private
;   table.  This code will shift all instance fields that are not in the
;   Upper Memory region down.  If there are no instance regions remaining
;   after the loop then it will zero out the SIS_Instance_Data_Ptr in the
;   init data area's fake Int 2Fh data structure.
;
	push	si

	mov	bx, si

CID_Move_Data_Loop:
	lodsd
	test	eax, eax			; Q: At the end?
	jz	CID_At_End_Of_List

	mov	ebp, eax
	shr	ebp, 16
	shl	ebp, 4
	movzx	edx, ax
	add	ebp, edx

	cmp	ebp, 0A0000h			; Q: Is this in a UMB?
	jae	CID_Found_One			;    Y: Copy data into us
						;    N: Shift into correct pos
;
;   This entry does NOT specify instance data in a UMB.  Leave it in the
;   init data table.
;
	mov	DWORD PTR [bx], eax
	lodsw
	mov	WORD PTR [bx+4], ax
	add	bx, 6
	jmp	CID_Move_Data_Loop

;
;   This entry specifies instance data in a UMB.  Copy it into our
;   internal table if enough room remains.
;
CID_Found_One:
	dec	cx				; Q: Enough room left?
	jl	CID_Out_Of_Copy_Space		;    N: ERROR!

	stosd
	movsw
	jmp	CID_Move_Data_Loop

;
;   We're at the end of the list of instance regions.  We may have copied
;   all of the instance regions into our internal table.  If so, then zero
;   the SIS_Instance_Data_Ptr in the fake Int 2Fh startup info data structure
;   to indicate that there is no instance data.  Otherwise, null terminate
;   the table and leave the SIS_Instance_Data_Ptr alone.
;
CID_At_End_Of_List:
	pop	si				; SI->Start of original table
	cmp	bx, si				; Q: Has copy pointer moved?
	je	CID_None_Left_In_List		;    N: The table is empty
						;    Y: Still some in table
	mov	DWORD PTR [bx], eax		; Terminate original table
	add	sp, 4				; Junk DS and SI on stack
	jmp	CID_Success			; Return success!

;
;   All of the instance fields were in UMB's -- Zap the entire table
;
CID_None_Left_In_List:
	pop	si
	pop	ds				; DS:SI -> Startup info struc
	mov	[si.WSSInstData], eax 		; Zero instance table ptr

;
;   In all cases where we return with success, we must null terminate the
;   table.
;
CID_Success:
	xor	eax, eax
	stosd					; Terminate internal list

	clc					; Indicate that it worked
	ret

;
;   ERROR:  Out of space in internal table.  Clear stack and return
;	    with carry flag set to indicate an error.
;
CID_Out_Of_Copy_Space:
	add	sp, 6

	stc					; Indicate an error
	ret

Copy_Inst_Data ENDP

;============================================================================
;
;	M010:
;
;	Procedure Name	: ValidatePath
;
;	Inputs		: None
;
;	Outputs		: CY if unable to access file
;			; NC otherwise
;
;============================================================================

ValidatePath	proc	far

	push	ds
	push	si
	push	bx
	push	dx
	push	cx
	push	ax

	push	cs
	pop	ds

	lea	si,R1_CODE:[CEMMpath]
				; ds:si -> ASCIZ file spec

	mov	bx, 2000h	; read only+compatibilty+supress I24.
	mov	dx, 1		; if file exits open it.
	xor	cx, cx

	mov	ax, 6c00h	; do extended open
	int	21h
       	jc	Vpdone		; error done.

	mov	bx, ax		; bx has handle
	mov	ah, 3eh		; close file
	int	21h
	clc			; it better succeed
Vpdone:
	pop	ax
	pop	cx
	pop	dx
	pop	bx
	pop	si
	pop	ds
	ret

ValidatePath	endp

	
;============================================================================
;
;	real mode XMS entry Code and Data
;
;============================================================================

;=============================================================================
;==	L O C A	L   D A T A
;=============================================================================
PrevXMM		dd	0	; previous XMM handler's entry point

XMMtrapTable	label word
		dw	offset GetVer		; 0
		dw	offset HMA	   	; 1
		dw	offset HMA   		; 2
ifdef MSFLAG
		dw	offset XeTrap	   	; 3
		dw	offset XeTrap		; 4
		dw	offset XeTrap		; 5
		dw	offset XeTrap	   	; 6
		dw	offset XeTrap   	; 7 M005
else
		dw	offset XePrev   	; 3
		dw	offset XePrev   	; 4
		dw	offset XePrev   	; 5
		dw	offset XePrev   	; 6
		dw	offset XePrev   	; 7 M005
endif
		dw	offset XePrev   	; 8
		dw	offset XePrev   	; 9
		dw	offset XePrev   	; 10
		dw	offset XePrev   	; 11
		dw	offset XePrev   	; 12
		dw	offset XePrev   	; 13
		dw	offset XePrev   	; 14
		dw	offset XePrev   	; 15
		dw	offset UMB	   	; 16
		dw	offset UMB   		; 17
MaxXMMtrap	equ	($-XMMtrapTable)/2
;==============================================================================
;==
;==  rXMMentry: CEMM XMM real mode entry point.
;==
;==  Enter:
;==
;==  Exit:
;==
;==============================================================================
rXMMentry proc	far

	jmp	short XeCont	; allow hooking of XMS
	nop
	nop
	nop
XeCont:
	pushf
	push	ecx
	push	es
	push	seg R_CODE
	pop	es
	assume	es:R_CODE

	test	es:[Current_State],fState_Active
	jz	short XePrev

	cmp	ah,MaxXMMtrap
	jae	short XePrev

	movzx	ecx,ah
	jmp	cs:[XMMtrapTable][ecx*2]

XePrev:
	pop	es
	pop	ecx
	popf
	jmp	dword ptr cs:[PrevXMM]	; previous XMS handler

GetVer:
	cmp	es:[HMAptr],100000h	;Q: Virtual HMA?
	je	short XePrev		; N: don't trap
	pop	es
	pop	ecx
	popf
	call	dword ptr cs:[PrevXMM]	; call previous XMS handler
	mov	dx,1			; indicate the HMA exists
	jmp	short XeExit

HMA:
	cmp	es:[HMAptr],100000h	;Q: Virtual HMA?
	je	short XePrev		; N: don't trap
	jmp	short XeTrap

UMB:
	cmp	es:[UMBptr],0		;Q: UMB manager?
	je	short XePrev		; N: don't trap

XeTrap:
	cli				; no interrupts allowed before TRAP
	or	es:[TrapFlags],fXMMtrap	; trap this function
	pop	es
	int	ProtTrap

	pop	ecx
	popf
XeExit:
	ret
rXMMentry	endp


;*****************************************************************************;
;***	XMMAllocateHMA - allocate HMA 					      ;
;									      ;
;	This routine is used to allocate HMA area		 	      ;
;									      ;
;	ENTRY	none		;ds = _DATA				      ;
;	EXIT	CY: set if not available				      ;
;	USES	ax, flags modified					      ;
;									      ;
;*****************************************************************************;
XMMAllocateHMA	proc	far


	push	ax
	push	dx
	push	fs
	mov	dx, seg R_CODE
	mov	fs, dx
	assume	fs:R_CODE

	mov	dx,0FFFFh		; requesting entire HMA
	mov	ah,XMM_REQUEST_HMA
	call	fs:[XMMcontrol]

	or	ax,ax			;Q: Error?
	jz	short XAHerr		; Y: set carry
	or	fs:[GenFlags],fHMA
	clc

XAHexit:
	pop	fs
	pop	dx
	pop	ax
	ret

XAHerr:
	stc
	jmp	short XAHexit

XMMAllocateHMA	endp

;*****************************************************************************;
;***	XMMDeallocateHMA - Deallocate HMA 				      ;
;									      ;
;	This routine is used to deallocate HMA area		 	      ;
;									      ;
;	ENTRY	none		;ds = _DATA				      ;
;	EXIT	CY: set if unable to deallocate HMA			      ;
;	USES	ax, flags modified					      ;
;									      ;
;*****************************************************************************;
XMMDeallocateHMA	proc	far

	push	ax
	push	fs
	mov	ax, seg R_CODE
	mov	fs, ax
	assume	fs:R_CODE

	mov	ah,XMM_RELEASE_HMA
	call	fs:[XMMcontrol]
	or	ax,ax
	jz	short XDHerr
	and	fs:[GenFlags],not fHMA
	clc
XDHexit:
	pop	fs
	pop	ax
	ret

XDHerr:
	stc
	jmp	short XDHexit

XMMDeallocateHMA	endp

;******************************************************************************
;	check_XMM: routine to check presence of XMM driver
;
;	ENTRY:	DS = _DATA
;	EXIT:	[msg_flag] set with error number if error occur
;	USED:	none
;
;******************************************************************************
check_XMM proc	far
;
; determine whether or not an XMM driver is installed
;
	push	ax
	push	fs
	mov	ax,seg R_CODE
	mov	fs,ax
	assume	fs:R_CODE

	and	fs:[GenFlags],not fXMM	; assume XMM not invoked
	mov	ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
	int	2Fh
	cmp	al,80h			; Q: installed
	jne	short cXMM_no_driver	;   N: set error, quit
;
; get the XMM control functions entry point, save it, we
; need to call it later.
;
	push	bx
	push	dx
	push	es
	mov	ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
	int	2Fh
	mov	word ptr fs:[XMMcontrol], bx
	mov	word ptr fs:[XMMcontrol+2],es

;  M009 : EMM386 always uses XMS driver for A20 control
;		But we leave CEMM as it is with the 'ifndef'

ifndef	MSFLAG				; M009
;
;  Has XMM already stolen all extended memory?

	mov	ax,8800h
	int	15h
	or	ax,ax			;Q: XMM invoked?
	jnz	short cXMMexit		; N: don't use it
endif					; M009
	or	fs:[GenFlags],fXMM		; Y: use it for A20 control

cXMMexit:
	clc
	pop	es
	pop	dx
	pop	bx
	pop	fs
	pop	ax
	ret				; done
;
; set carry if XMM driver not present
;
cXMM_no_driver:
	stc
	pop	fs
	pop	ax
	ret

check_XMM	endp

;=========================================================================
;
;	Int 10 and int 11 handlers
;
;=========================================================================

PrevInt10		dd	0	; The old int10 vector
PrevInt11		dd	0	; The old int11 vector

;******************************************************************************
;	Int10_Hook - Int 10 hook when EGA present and using E000h page frame
;
;	This hook is necessary when the E000h segment is used for the page
;	frame and an EGA is in the system.  In this case CEMM "moves" the
;	EGA ROM back to C000h by modifying the page table entry for C000h
;	linear to point to E000h physical.   Additionally, CEMM changes the
;	int 10h, int 1fh, and int 43h vectors.	Changing the int 10h vector
;	could be a problem if a program had already chained into the int 10h
;	vector and had saved the E000 segment for the EGA vector.  If CEMM
;	subsequently "moved" the EGA ROM away from E000h, the int10h chain
;	would not work.  To fix this, CEMM attempts to placed itself at the
;	end of the int10h chain by patching int10h at device driver load
;	time.  This allows CEMM to change the EGA segment in it's in10h
;	hook when necessary and everything should work fine then.
;
;    ENTRY:	Real Mode/Virtual Mode
;
;    EXIT:	same as entry
;		chains on to current "true" int 10h vector.
;
;    USED:	none
;
;******************************************************************************
Int10_Hook	proc	near
	jmp	CS:[PrevInt10]	; chain to previous Int 10h
Int10_Hook	endp

;******************************************************************************
;	Int11_Hook - Int 11 hook when Weitek processor present
;
;	This hook is used when the Weitek processor is present.  It returns
;	bit 23 of EAX = 1 when the Weitek mapping is enabled.
;
;    ENTRY:	Real Mode/Virtual Mode
;
;    EXIT:	bit 32 of EAX = 0 => Weitek mapping is disabled
;		bit 32 of EAX = 1 => Weitek mapping is enabled
;
;    USED:	none
;
;******************************************************************************
Int11_Hook	proc	near
	pushf
	call	CS:[PrevInt11]	; call previous int 11 handler
		; default to Weitek not mapped
	and	eax,((NOT fI11h_Weitek_Map) SHL 16) + 0FFFFh

	push	fs
	push	seg R_CODE
	pop	fs
	assume	fs:R_CODE

	test	fs:[Current_State],fState_Active;Q: CEMM active ?
	jz	SHORT I11_iret			; N: then Weitek not mapped
	test	fs:[Weitek_State],fWeitek_Map	; Y:Q: Weitek mapped ?
	jz	SHORT I11_iret			;    N: say so  ...
	or	eax,(fI11h_Weitek_Map SHL 16)	;    Y: set bit 23
I11_iret:
	pop	fs
	iret
Int11_Hook	endp

;----------------------------------------------------------------------------
;
; Procedure name	: chk_machine_state
;
; ENTRY			:
;
; EXIT			: NC if real mode
;			  CY otherwise
;
;----------------------------------------------------------------------------
chk_machine_state	proc	far
	push	ax

	smsw	ax
        test    ax,MSW_PROTECT  ; Q: is bit 0 set
	pop	ax

	jz	cms_real	; N: machine in real mode
	stc
	ret

cms_real:
	clc
	ret
chk_machine_state	endp

R1_CODE	ends

	end

 	


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\vdmsel.inc ===
ifndef INC_LIST
.xlist
endif
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386 - MICROSOFT Expanded Memory Manager 386
;
;   Module:   VDMSEL.INC - Selector Definitions for CEMM
;
;   Version:  2.00
;
;   Date:     May 12, 1986
;
;   Author:
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;	      Original
;   05/12/86  A-RRH	Cleanup and segment reorganization
;   06/07/86  C-SBP	merged with module from Rick
;   06/28/86  0.02	Name change from CEMM386 to CEMM (SBP).
;   07/10/86  0.05	Changed CODE_GSEL to RCODEA_GSEL (SBP).
;   05/08/86  2.00	Added RCODE_GSEL  and  RSS_GSEL (SBP).
;   10/12/88  3.32 (*D) VCPI added (DJM).
;   08/23/89  4.10  Added selctors for DEB386 and PAGED_GSEL (LC)
;
;******************************************************************************
;
;	DESCRIPTION
;
;	These are the fixed selector numbers for the GDT and LDT
;
;	All are declared with RPL = 0 so they can easily be used
;	as table indices.
;
;	Do not change anything without consulting files which include
;	this one. Add new selectors to the end and update the
;	gdt declaration and initialisation code elsewhere.
;

;	Define LDT and GDT table bits

TAB_LDT 	equ	4h
TAB_GDT 	equ	0h


;	Define GDT selectors

GDTD_GSEL	equ	08h OR TAB_GDT	; gdt data alias
IDTD_GSEL	equ	10h OR TAB_GDT	; idt data alias
LDT_GSEL	equ	18h OR TAB_GDT	; ldt
LDTD_GSEL	equ	20h OR TAB_GDT	; ldt data alias
TSS_GSEL	equ	28h OR TAB_GDT	; tss
TSSD_GSEL	equ	30h OR TAB_GDT	; tss data alias
RM_IDT_GSEL	equ	38h OR TAB_GDT	; real mode idt (locn 0)
ROMDATA_GSEL	equ	40h OR TAB_GDT	; maps 40:0 - DON'T CHANGE!!
VDMC_GSEL	equ	48h OR TAB_GDT	; VDM Code selector
VDMD_GSEL	equ	50h OR TAB_GDT	; VDM Data Selector
VDMS_GSEL	equ	58h OR TAB_GDT	; VDM stack selector
MONO_GSEL	equ	60h OR TAB_GDT	; monochrome display memory
COLOUR_GSEL	equ	68h OR TAB_GDT	; colour display memory
EGA1_GSEL	equ	70h OR TAB_GDT	; first EGA sel
EGA2_GSEL	equ	78h OR TAB_GDT	; second EGA sel
DATA32_GSEL	equ	80h OR TAB_GDT	; large linear addr data sel
DEBC_GSEL	equ	88h or TAB_GDT	; debugger work descr
DEBD_GSEL	equ	90h or TAB_GDT	; debugger work descr
DEBW1_GSEL	equ	98h or TAB_GDT	; debugger work descr
DEBW2_GSEL	equ	0A0h or TAB_GDT ; debugger work descr
K_PUTC286	equ	0A8h OR TAB_GDT ; 286 call gate to kputc
K_GETC286	equ	0B0h OR TAB_GDT ; 286 call gate to kgetc
RCODE_GSEL	equ	0B8h OR TAB_GDT ; R_CODE code segment selector
RCODEA_GSEL	equ	0C0h OR TAB_GDT ; data alias for R_CODE segment
RSS_GSEL	equ	0C8h OR TAB_GDT ; real mode SS alias
VM1_GSEL	equ	0D0h OR TAB_GDT ; scratch for vm handler
VM2_GSEL	equ	0D8h OR TAB_GDT ; scratch for vm handler
MBSRC_GSEL	equ	0E0h OR TAB_GDT ; source sel for move blk
MBTAR_GSEL	equ	0E8h OR TAB_GDT ; target sel for move blk
PAGET_GSEL	equ	0F0h OR TAB_GDT ; page table area sel
VDMCA_GSEL	equ	0F8h OR TAB_GDT ; VDM code segment alias
EMM1_GSEL	equ	100h OR TAB_GDT ; EMM scratch selector
EMM2_GSEL	equ	108h OR TAB_GDT ; EMM scratch selector
DIAG_GSEL	equ	110h OR TAB_GDT ; diagnostic port selector
PAGED_GSEL	equ	118h OR TAB_GDT ; page directory area sel
RMS_GSEL	equ	120h or TAB_GDT	; small protected mode base stack
R1CODE_GSEL	equ	128h or TAB_GDT	; R_CODE1 code selector
R1CODEA_GSEL	equ	130h or TAB_GDT	; R_CODE1 code selector
DEB1_GSEL	equ	138h or TAB_GDT	; deb386 word descr
DEB2_GSEL	equ	140h or TAB_GDT	; deb386 word descr
DEB3_GSEL	equ	148h or TAB_GDT	; deb386 word descr
DEB4_GSEL	equ	150h or TAB_GDT	; deb386 word descr
DEB5_GSEL	equ	158h or TAB_GDT	; deb386 word descr
DEBX_GSEL	equ	160h or TAB_GDT	; deb386 descr for 4G address space

.list	; end of VDMSEL.INC

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\vm386.inc ===
ifndef INC_LIST
.xlist
endif
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386 - MICROSOFT Expanded Memory Manager 386
;
;   Module:   VM386.INC
;
;   Version:  0.03
;
;   Date:     May 12, 1986
;
;   Author:
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;	      Original
;   05/12/86  A-RRH	Cleanup and segment reorganization
;   06/08/86  B-RRH	Added Disable A20 equates
;   06/14/86  C-RRH	Added MOV_CDTR_FRAME, PROT_INS_FRAME, and changed
;			VTFO from 2 to 4 to reflect push of EBP from BP
;   06/15/86  D-RRH	Added GPFAULT_FRAME
;   06/28/86  0.02	Name change from CEMM386 to CEMM (SBP).
;   07/01/86  0.03	Added structures for accessing memory (RRH).
;
;******************************************************************************
;
;   Structures for accessing memory
;
WordS	struc
  LowByte 	db	?
  HighByte	db	?
WordS	ends

DwordS	struc
  LowWord 	dw	?
  HighWord	dw	?
DwordS	ends

;
;   Accessing flags, CS, and IP during a real mode interrupt (pushing BP)
;
INT_FRAME	struc
  INT_BP	dw	?
  INT_IP	dw	?
  INT_CS	dw	?
  INT_FLAGS	dw	?
INT_FRAME	ends

;
;   Structure for accessing stack frame pushed during trap exit from VM
;
VM_TRAP_FRAME	struc
  VMTF_EIP	dw	?	; EIP (low)
		dw	?	; EIP (high)
  VMTF_CS 	dw	?	; CS
		dw	?	;   (padding)
  VMTF_EFLAGS	dw	?	; EFLAGS (low)
  VMTF_EFLAGShi	dw	?	; EFLAGS (high)
  VMTF_ESP	dw	?	; ESP (low)
		dw	?	; ESP (high)
  VMTF_SS 	dw	?	; SS
		dw	?	;   (padding)
  VMTF_ES 	dw	?	; ES
		dw	?	;   (padding)
  VMTF_DS 	dw	?	; DS
		dw	?	;   (padding)
  VMTF_FS 	dw	?	; FS
		dw	?	;   (padding)
  VMTF_GS 	dw	?	; GS
		dw	?	;   (padding)
VM_TRAP_FRAME	ends
;
				; Used in EmMovCDTR (vminst.asm)
MOV_CDTR_FRAME	 struc
  MCF_WBP	dw	?	; Work BP
  MCF_WES       dw	?	; Work ES
  MCF_EAX       dw	?	; EAXlo
		dw	?	; EAXhi
  MCF_ESI       dw	?	; ESIlo
		dw	?	; ESIhi
  MCF_EBX       dw	?	; EBXlo
		dw	?	; EBXhi
  MCF_EBP       dw	?	; EBPlo
		dw	?	; EBPhi
  MCF_VMERR	dw	?	; VM Error Code (low)
		dw	?	; VM Error Code (high)
  MCF_VMEIP	dw	?	; VM EIP (low)
		dw	?	; VM EIP (high)
  MCF_VMCS      dw	?	; VM CS
		dw	?	;   (padding)
  MCF_VMEFLAGS	dw	?	; VM EFLAGS (low)
  MCF_VMEFLAGShi dw	?	; VM EFLAGS (high)
  MCF_VMESP	dw	?	; VM ESP (low)
		dw	?	; VM ESP (high)
  MCF_VMSS      dw	?	; VM SS
		dw	?	;   (padding)
  MCF_VMES      dw	?	; VM ES
		dw	?	;   (padding)
  MCF_VMDS      dw	?	; VM DS
 		dw	?	;   (padding)
  MCF_VMFS      dw	?	; VM FS
		dw	?	;   (padding)
  MCF_VMGS      dw	?	; VM GS
		dw	?	;   (padding)
MOV_CDTR_FRAME	 ends
;
					; Used in EmProtIns (vminst.asm)
PROT_INS_FRAME	 struc
  PIF_WBP	dw	?	; Work BP
  PIF_WES 	dw	?	; Work ES
  PIF_AX	dw	?	; EAXlo
  PIF_DX	dw	?	; EDXlo
  PIF_ESI 	dw	?	; ESIlo
		dw	?	; ESIhi
  PIF_EBX 	dw	?	; EBXlo
		dw	?	; EBXhi
  PIF_EBP 	dw	?	; EBPlo
		dw	?	; EBPhi
  PIF_VMERR	dw	?	; VM Error Code (low)
		dw	?	; VM Error Code (high)
  PIF_VMEIP	dw	?	; VM EIP (low)
		dw	?	; VM EIP (high)
  PIF_VMCS	dw	?	; VM CS
		dw	?	;   (padding)
  PIF_VMEFLAGS	dw	?	; VM EFLAGS (low)
  PIF_VMEFLAGShi dw	?	; VM EFLAGS (high)
  PIF_VMESP	dw	?	; VM ESP (low)
		dw	?	; VM ESP (high)
  PIF_VMSS	dw	?	; VM SS
		dw	?	;   (padding)
  PIF_VMES	dw	?	; VM ES
		dw	?	;   (padding)
  PIF_VMDS	dw	?	; VM DS
		dw	?	;   (padding)
  PIF_VMFS	dw	?	; VM FS
		dw	?	;   (padding)
  PIF_VMGS	dw	?	; VM GS
		dw	?	;   (padding)
PROT_INS_FRAME	 ends
;
GPFAULT_FRAME	struc
  GPF_ESI	dw	?	; ESIlo
		dw	?	; ESIhi
  GPF_EBX 	dw	?	; EBXlo
		dw	?	; EBXhi
  GPF_EBP 	dw	?	; EBPlo
		dw	?	; EBPhi
GPFAULT_FRAME	ends

GPOFF		equ	(-(size GPFAULT_FRAME))	; offset to GPFAULT frame
																		; from VMINST entry BP
;
;   The following constants define the offset of the Virtual Mode trap stack
;   frame (from current SP assuming BP has been pushed) for the two cases:
;   1) exceptions that don't push error codes and 2) those that do.
;
VTFO		equ	4					; offset of VM trap stack frame
VTFOE		equ	VTFO + 4	; as above, but including error code
;
;   These constants are used to sanity-check the value of SP when one of
;   the exception handlers has been entered:
;
STACK	segment
	extrn	Stack0:byte
	extrn	Stack0_top:byte
STACK	ends

  ; Trap/no error
VMT_STACK	equ	offset STACK:Stack0_top - size VM_TRAP_FRAME - VTFO
  ; Trap w/error
VMTERR_STACK	equ	offset STACK:Stack0_top - size VM_TRAP_FRAME - VTFOE
;
;   These constants are used to watch for a Disable A20 attempt by the VM client
;
YesLLdone	equ	1
KbdDataEnb	equ	2

A20CmdBit	equ	02h		; high is enabled
A20DsbCmd	equ	0DDh
A20EnbCmd	equ	0DFh

KbdCmdPort	equ	64h		; 8042 cmd port
KbdDataPort	equ	60h		; 8042 data port
KbdWrtData	equ	0D1h		; Enable write to data port

;******************************************************************************
;			    E R R O R	 C O D E S
;******************************************************************************
;
PrivErr     equ	0000h	    ; Privileged Operation Error class
ErrLGDT     equ	0000h	    ; Client tried to execute a LGDT
ErrLIDT     equ	0001h	    ; Client tried to execute a LIDT
ErrLMSW     equ	0002h	    ; Client tried to execute a LMSW
Err2LL	    equ	0003h	    ; Client tried to execute a 286 Loadall
Err3LL	    equ	0004h	    ; Client tried to execute a 386 Loadall
ErrMovCR    equ	0005h	    ; Client tried to execute a CRn mov
ErrMovDR    equ	0006h	    ; Client tried to execute a DRn mov
ErrMovTR    equ	0007h	    ; Client tried to execute a TRn mov

ExcpErr     equ	0001h	    ; Exception Error class
ErrDIV	    equ	0000h	    ; Divide Error
ErrINT1     equ	0001h	    ; Debug Exception
ErrNMI	    equ	0002h	    ; NMI
ErrINT3     equ	0003h	    ; Int 3
ErrINTO     equ	0004h	    ; Int O error
ErrBounds   equ	0005h	    ; Array Bounds Check
ErrOpCode   equ	0006h	    ; Invalid Opcode
ErrCoPNA    equ	0007h	    ; Coprocessor Device not available
ErrDouble   equ	0008h	    ; Double Fault
ErrCoPseg   equ	0009h	    ; Coprocessor Segment Overrun
ErrTSS	    equ	000Ah	    ; Invalid TSS
ErrSegNP    equ	000Bh	    ; Segment not Present
ErrStack    equ	000Ch	    ; Stack Fault
ErrGP	    equ	000Dh	    ; General Protection Fault
ErrPage     equ	000Eh	    ; Page Fault
ErrCoPerr   equ	0010h	    ; Coprocessor Error
ErrWrite    equ	0020h	    ; Attempt to write to protected area
ErrDMA	    equ	0021h	    ; Attempt to DMA into page frame (not for user)
ErrINTProt  equ	0022h	    ; General Protected interrupt error

DMASizeErr  equ	0002h	    ; Fatal DMA errors
DMAModeErr  equ	0003h	    ; Transfer larger than DMA buffer
UnRecPrivErr equ 0004h	    ; Unrecoverable Privileged Operation Error

.list	; end of VM386.INC

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\winemm.inc ===
ifndef INC_LIST
.xlist
endif
;******************************************************************************
;
; (C) Copyright MICROSOFT Corp. 1989-1991
; (C) Copyright COMPAQ Computer Corp. 1989-1991
;
; Title:	EMM386.EXE  - MICROSOFT Expanded Memory Manager 386 Driver
;
; Module:	WINEMM.INC - defines for EMM code.
;
; Version:	0.001
;
; Date:		July 26, 1989
;
; Author:	HKN, Leo Cohen
;
;******************************************************************************
;
; Change log:
;
; DATE		REV	DESCRIPTION
; --------	------	-----------------------------------------------------
; 07/26/86	0.0
;******************************************************************************

;=============================================================================
;==	D A T A   S T R U C T U R E S
;=============================================================================
Win386StartupStruc	struc
  WSSversion	db	3,0	; version number
  WSSnextPtr	dd	?	; pointer to next entry in the chain
  WSSVxDFilePtr	dd	0	; name/path of VxD to load
  WSSVxDRefData	dd	?	; pointer to VxD defined structure
  WSSInstData	dd	0	; pointer to instace data structure
Win386StartupStruc	ends

VxDRefDataStruct	struc
  RDSDDchain	dd	?	; logical address of start of device driver chain
  RDSdata	dd	?	; pointer to data structure filled in by Ralphs code.
  RDSUMBstart	dd	?	; linear 4K page number with first UMB
  RDSUMBarray	dd (100h-0A0h) dup (0)	; physical PTE index from previous field to 1 megabyte
VxDRefDataStruct	ends

InstanceDataStruct	struc
  IDSptr	dd	0	; logical address of instance data area
  IDSsize	dw	0	; size of instance data area
InstanceDataStruct	ends

;==============================================================================
;==  F L A G S
;==============================================================================
;==============================================================================
;==  EMMGI_Flags
;==============================================================================
ANY_HANDLE_CTXT	equ 00001b	; Conext saved in some handle
NONZR_REG_SET	equ 00010b	; reg set other than 0 allocated
NO_XMS_HANDLE	equ 00100b	; No XMS handle information
HMA_INFO	equ 01000b	; Virtual HMA is free at Win init time
NO_XMS_UMB	equ 10000b	; No XMS UMB information
;==============================================================================
;==  EMMGI_Vers
;==============================================================================
MAJOR_INTERFACE_VER	equ	1
MINOR_INTERFACE_VER_0	equ	0
MINOR_INTERFACE_VER_11	equ	11
WIN_VERSION_LO		equ	300h
WIN_VERSION_HI		equ	30Ah
EMMGI_VERSION_LO	equ (MAJOR_INTERFACE_VER shl 8)+MINOR_INTERFACE_VER_0
EMMGI_VERSION_100	equ (MAJOR_INTERFACE_VER shl 8)+MINOR_INTERFACE_VER_0
EMMGI_VERSION_111	equ (MAJOR_INTERFACE_VER shl 8)+MINOR_INTERFACE_VER_11
EMMGI_VERSION_HI	equ (MAJOR_INTERFACE_VER shl 8)+MINOR_INTERFACE_VER_11
;==============================================================================
;==  EMMCntx_Flags
;==============================================================================
EMM_PAGE		equ 00000001b	; this is a mappable EMM page (either 3.2 or 4.0)
FRAME_32		equ 00000010b	; this page is part of a 3.2 frame
CNTXT_UMB0	 	equ 00000100b	; 1st 4K is mapped as a UMB
CNTXT_UMB1 		equ 00001000b	; 2nd 4K is mapped as a UMB
CNTXT_UMB2	 	equ 00010000b	; 3rd 4K is mapped as a UMB
CNTXT_UMB3	 	equ 00100000b	; 4th 4K is mapped as a UMB
CNTXT_UMB0bit	 	equ 2
;==============================================================================
;==  EMMCntx_EFlgs
;==============================================================================
CNTXT_USEABLE	 	equ 00000001b	; 4K page usable
CNTXT_NOTUSED 		equ 00000010b	; 4K page not usable
;==============================================================================
;==  EMMHndl_Flags
;==============================================================================
HANDLE_HAS_NAME	EQU	0001b	; this handle has a name
HANDLE_HAS_CTXT	EQU	0010b   ; this handle has a saved context
HF_UNUSED	equ 	0100b	; this is not a valid handle entry
;==============================================================================
;==  XMSflags
;==============================================================================
HANDLE_UNUSED	equ	0001b	; this handle is currently not allocated.
;==============================================================================
;==  S T R U C T U R E S
;==============================================================================
;==============================================================================
;==  EMMContext structure
;==============================================================================
EMMContext 	struc
  EMMCntx_Flags	db	?	; one of the above equates
  EMMCntx_HMap	db	?	; if EMM page contains handle number else if UMB
  				; contains index into EMM_UMB_Map struc
  EMMCntx_Lpag	dw	?	; logical page number within handle
  EMMCntx_PPag	db	?	; physical page # (index into EMS_window_location array )
  EMMCntx_EFlgs db	?	; Non EMM/UMB flags
EMMContext	ends
EMMCntx_UMBindex  equ  EMMCntx_HMap ; If UMB, this is index into array
;==============================================================================
;==  EMM_UMB_Map structure
;==============================================================================
EMM_UMB_Map	struc
  EUM_Page0	dd	?	; physical 4K page number
  EUM_Page1	dd	?	; physical 4K page number
  EUM_Page2	dd	?	; physical 4K page number
  EUM_Page3	dd	?	; physical 4K page number
EMM_UMB_Map	ends
;==============================================================================
;==  EMM_Handle structure
;==============================================================================
EMM_Handle	struc
  HandleNum   	db	?	; Handle Number
  HandleFlags	db	?	; Flags: This handle has a name
  				;        This handle has a saved context
  HandleName 	db 8 dup (?)	; Handle Name
  NumLogPages   dw	?	; Number of 16K EMS logical pages
  PhysPtrToPTEs dd	?	; Physical pointer to PTE entries ..
EMM_Handle	ends		; describing Handle space (PTE struc)
;==============================================================================
;==  MEM_FREE_Map structure
;==============================================================================
MEM_FREE_Map	struc
  MEMstart	dd	?	; starting page number of region
  MEMcount	dd	?	; count of contiguous free pages
MEM_FREE_Map	ends
;==============================================================================
;==  XMS_Handle structure
;==============================================================================
XMS_Handle	struc
  XMShandle	dw	?	; handle number
  XMSflags	dw	?	; flags for this handle
  XMSsize	dd	?	; size of handle in KBs
  XMSaddr	dd	?	; lock address (physical)
XMS_Handle	ends
;==============================================================================
;==  UMB_FREE_Map structure
;==============================================================================
UMB_FREE_Map	struc
  UMBseg	dw	?	; starting page number of region
  UMBsize	dw	?	; count of contiguous free pages
UMB_FREE_Map	ends

EMMGICntxtNum	equ	64	; 64 16K contexts in first megabyte
;==============================================================================
;==  EMM Global Import Data Structure
;==============================================================================
EMM_Global_Import_Data	struc

  EMMGI_Flags		dw	0	; flags
  EMMGI_Len		dw	0	; length of structure
  EMMGI_Vers		db	0,0	; version of data structure
  EMMGI_OSKey		dd	0	; OS key (0=none)

  EMMGI_Cntxt		db (EMMGICntxtNum*size EMMContext) dup (0)

  EMMGI_CntxtSz		db 	0	; Int 67h AX=4E03h return value

  EMMGI_UMBcnt		db	0	; UMB array size in entries

  EMMGI_HndlCnt		db	0	; handle array size in entries
;
; End of Version 1.00 EMM Global Import Data Structure
;
  EMMGI_Int67		dd	0	; back door to Int 67h hook address

  EMMGI_HMA		dd	0	; pointer to 16 PTEs providing HMA

  EMMGI_FreeMEMcnt	db	0	; free memory page array size in entries

  EMMGI_XMScnt		db	0	; EMB handle array count

  EMMGI_FreeUMBcnt	db	0	; free UMB array size in entries

  EMMGI_Vendor		db	40 dup (0)

EMM_Global_Import_Data	ends
;==============================================================================
;==  EMM Global Import Data Structure: Start of variable length fields
;==============================================================================
EMMGI_UMBs 	equ EMMGI_UMBcnt+1    	; start of UMB array
EMMGI_Hndls	equ EMMGI_HndlCnt+1	; start of handle array
EMMGI_FreeMEM	equ EMMGI_FreeMEMcnt+1	; start of free EMS page array
EMMGI_XMS	equ EMMGI_XMScnt+1	; start of EMB handle array
EMMGI_FreeUMB	equ EMMGI_FreeUMBcnt+1	; start of free UMB array

EMMGIDS100size	equ EMMGI_Hndls  	; size of version 1.00 data structure
EMMGIDS110size	equ size EMM_Global_Import_DATA ; size of version 1.10 data structure
;QEMS EMMGIDS110size	equ EMMGI_FreeUMB	; size of version 1.10 data structure
.list	; end WinEMM.inc

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\winemm.asm ===
.386p
page	58,132
;******************************************************************************
	title	WINEMM
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1989-1991
;   (C) Copyright COMPAQ Computer Corp. 1989-1991
;
;   Title:    EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
;   Module:   WINEMM - Routines to fill in data structure to pass to win386
;
;   Version:  0.001
;
;   Date:     July 26,1989
;
;   Author:   Harish K. Naidu
;	      Leo Cohen
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   07/26/89  Original
;   08/11/89  4.10	Add WinInit & updated Windows/CEMM interface. 	(LC)
;   07/31/90  4.20      Win 3.1 and UMB support. 			(LC)
;
;   02/14/91  M010	Added support to validate LoadHi Vxd path at win 
;			startup int 2f.
;
;   02/27/91  M013	First Check if standard mode has issued the int 2f 
;			startup in rint2fhHandler. If so just chain.
;
;   03/07/91  M015	Clear out the high word of edx when initializing 
;			dx with the arena length in VxdUsedUMBList.
;
;******************************************************************************
;
;   Functional Description:
;
;
;******************************************************************************
;=============================================================================
;==	P U B L I C   D E C L A R A T I O N S
;=============================================================================
	public	pWinEMMGlobImpDisp
	public	rINT2FhHandler
	public	GetPathName
	public	StorePath		; M010
	public	VxDInit

	public	EMMGIDataVer
	public	CEMMpath
	public	InstanceData
	public	Win386VxDRefDat

;=============================================================================
;==	L O C A L   C O N S T A N T S / E Q U A T E S
;=============================================================================
	include VDMseg.inc
	include winemm.inc
	include	emmfunct.inc
	include	emmdata.inc
	include	vdmsel.inc
	include	emm386.inc
	include vm386.inc
	include XMM.inc
	include driver.equ
ifdef BETA
	include winemm.pub
	include	dbg.inc
endif
;=============================================================================
;==	E X T E R N A L  D E C L A R A T I O N S
;=============================================================================
_DATA	SEGMENT
	extrn	EMS_window_location:word
	extrn	register_set:word
	extrn	number_EMS_windows:word
	extrn	context_save_area_size:word
	extrn	HMAfree:byte
	extrn	_PFUser:word
_DATA	ENDS

R_CODE	segment
	extrn	GoVirtual:near
	extrn	ChkA20:near
	extrn	GoProtMode:near
	extrn	GoVirtualMode:near
	extrn	GoRealMode:near
	extrn	EMM_rEntry:near
	extrn	Devname:byte
	extrn	WINEMM_Mess:byte
	extrn	ReInitDeb:near
	extrn	CopyInstData:dword
	extrn	ValidPathFar:dword
	extrn	EMM_rFarEntry:word

R_CODE	ends

R1_CODE	segment
	extrn	WinBackfillMess:byte
	extrn	WinInvPathMess:byte	; M010
R1_CODE	ends


_TEXT	SEGMENT
	extrn	MapHandlePage:near
	extrn	EnterVirtual:far
	extrn	Log2Phy:near
	extrn	Lin2Phy:near
_TEXT	ENDS

LAST	SEGMENT
	extrn	tempBuffer:dword
LAST	ENDS
	extrn	MajVer:abs
	extrn	MinVer1:abs
	extrn	MinVer2:abs
;=============================================================================
;==	L O C A	L   D A T A
;=============================================================================
R_CODE	segment

WinVer	label	word		; Version of Windows V86MMGR
WinVerMin	db	0	; Minor version
WinVerMaj	db	0	; Major version

EMMGIDataVer label word
EMMGIDataVerMin	db	0	; Minor version
EMMGIDataVerMaj	db	1	; Major version

ifndef MSFLAG
EMMGIVendor	db	"COMPAQ              "
EMMGIProduct	db	"CEMM ",MajVer+'0',".",MinVer1+'0',MinVer2+'0',"           "
else
EMMGIVendor	db	"MICROSOFT           "
EMMGIProduct	db	"EMM386 ",MajVer+'0',".",MinVer1+'0',MinVer2+'0',"         "
endif

pRDSdata	dw	0

R_CODE	ends

R1_CODE	segment


ConfigBuffer	equ	128	; up to 128 character path will be kept
Win386Struc	Win386StartupStruc <>

MaxUMBInstObj	equ	10	; up to 10 instance objects in UMB area supported
InstanceData	label	byte
rept MaxUMBInstObj
  	InstanceDataStruct<>	; possible XBDA/UMB instance data
endm
	dd	0	; termination of structure array

CEMMpath	db	ConfigBuffer dup (0)

R1_CODE	ends

_DATA	segment

Win386VxDRefDat	VxDRefDataStruct<>

_DATA	ends

;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
_TEXT	segment
	assume	cs:_TEXT,ds:nothing,es:nothing,fs:nothing,gs:nothing
;==============================================================================
;==  pWinEMMGItable jump table
;==============================================================================
pWinEMMGItable	label	word
	dw	offset UpdateStructure
	dw	offset UpdateInternals
	dw	offset WinBroadcast
pWEGImax	equ	$-pWinEMMGItable
;==============================================================================
;==
;==  pWinEMMGlobImpDisp: This is a dispatcher for the routine which update
;==			 the EMM Global Import data structure during a Windows'
;==			 Virtual Disable Call and gets info from the structure
;==			 during a Windows Enable Call.
;==
;==  Entry: (Protected Mode)
;==	AX	= 0 	Windows Disable Call
;==		= 1 	Windows Enable Call
;==		= 2     Windows Broadcast
;==	GS	= R_CODE segment
;==
;==  Exit:
;==	[ebp][VTFO].VMTF_EFLAGS	carry flag set if error, else zero
;==
;==============================================================================
pWinEMMGlobImpDisp proc	near
	push	eax

	shl	eax,24
	mov	ax,VDMD_GSEL	; DS/GS are setup for CEMM's 2 data areas.
	mov	ds,ax
	mov	ax,DATA32_GSEL	; access 4GB address space
	mov	fs,ax
	assume	ds:_DATA,es:nothing,fs:ABS0,gs:R_CODE

	shr	eax,24
	call	cs:[pWinEMMGItable][eax*2]	; call function

	pop	eax
	ret
pWinEMMGlobImpDisp	endp

;==============================================================================
;==
;==  UpdateStructure: This routine updates the EMM Global Import data structure
;==		      during a Windows' Virtual Disable Call.
;==
;==  Entry: (Protected Mode)
;==	AX	= 0   Windows Disable Call
;==	DS	= _DATA
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==	[ebp][VTFO].VMTF_EFLAGS	carry flag set if error, else zero
;==
;==============================================================================
UpdateStructure proc	near
	push	ebx
	push	esi
;
;  Get FS:[EBX] pointing to EMM Global Import Data Structure
;
	call	GetEMMGlobImpDatArea

	mov	fs:[ebx].EMMGI_Len,EMMGIDS100size  ; assume 1.00 version size

	call	Fill_Flags
	call	Fill_EMMCtxt
	call	Fill_HandleInfo

;
;  If version 1.11 or later continue, else end of structure
;
	cmp	word ptr fs:[ebx][EMMGI_Vers],EMMGI_VERSION_111	;Q: Atleast 1.10?
	jb	short USexit					; N: exit
	mov	fs:[ebx].EMMGI_Len,EMMGIDS110size		; Y: size as 1.10 version

	call	FillFreeMem
	call	FillXMS
	call	FillFreeUMBs

	call	FillProductName

;
;  ESI contains the size of the variable portion of the Data Structure
;
USexit:
	add	fs:[ebx].EMMGI_Len,si	; add variable portion of data structure
	pop	esi
	pop	ebx
	ret
UpdateStructure	endp

;==============================================================================
;==
;==  UpdateInternals: This routine updates CEMM's internals using the  EMM
;==		      Global Import data structure during a Windows' Virtual
;==		      Enable Call.
;==
;==  Entry: (Protected Mode)
;==	AX	= 1   Windows Enable Call
;==	DS	= _DATA
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==	[ebp][VTFO].VMTF_EFLAGS	carry flag set if error, else zero
;==
;==============================================================================
UpdateInternalsFar proc	far
	push	fs

	mov	ax,DATA32_GSEL
	mov	fs,ax

	call	UpdateInternals

	pop	fs
	ret
UpdateInternalsFar 	endp

UpdateInternals proc	near
	push	ebx
;
;  Get FS:[EBX] pointing to EMM Global Import Data Structure
;
	call	GetEMMGlobImpDatArea
;
;  Update current EMS mapping
;
	call	Update_Mapping_State

	pop	ebx
	ret
UpdateInternals	endp

;==============================================================================
;==
;==  WinBroadcast: Windows INT 2Fh AX=1605 broadcast.  Need to sync up the
;==		   version numbers and fill the VxD information for Win 3.0
;==		   and UMB information.
;==
;==  Entry: (Protected Mode)
;==	AX	= 2   Windows Broadcast Call
;==	DS	= _DATA
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==	[ebp][VTFO].VMTF_EFLAGS	carry flag set if error, else zero
;==
;==============================================================================
WinBroadcast	proc	near
	push	eax
;
;  Check if Windows Init is still OK
;
	mov	ax,[bp][VTFO].VMTF_DS

	or	cx,cx			;Q: Anybody fail Windows Init?
	jnz	short WBerror		; Y: fail Win Init

	or	ax,si			;Q: Is a Virtual Disable Call set?
	jnz	short WBerror		; Y: impossible/error - fail init

	mov	gs:[WinVer],di		; save Windows version
	mov	gs:[EMMGIDataVer],EMMGI_VERSION_HI ; most recent version supported
	cmp	di,WIN_VERSION_HI	;Q: Version supported?
	jae	short WBSetEntry	; Y: continue
;
;  As new Windows versions get added and supported, need to place the most
;  recent EMM Global Import Data Structure supported in [EMMGIDataVer]
;
	cmp	di,WIN_VERSION_LO	;Q: Version supported?
	jb	short WBerror		; N: cannot do interface
	mov	gs:[EMMGIDataVer],EMMGI_VERSION_LO ; assume CEMM can handle latest version
	or	gs:[GenFlags],fWin30	; Win 3.0 broadcast occurred
;
;  Add VxD information to Windows Version 3.00 (called only for this version!)
;
	call	VxDSupport
;
;  Set Virtual Disable Call entry point
;
WBSetEntry:
	mov	si,seg R_CODE
	mov	[bp][VTFO].VMTF_DS,si
	mov	si,offset rWinV86Proc
WBexit:
	pop	eax
	ret

WBerror:
	mov	cx,-1			; fail Windows Init
	jmp	short WBexit
WinBroadcast	endp

;==============================================================================
;==
;==  GetEMMGlobImpDatArea: Gets pointer to start of EMM Global Import Data
;==			   structure.  Also, clears the page directory entries
;==			   which correspond to the Page Fault Tables.  The Page
;==			   Fault Tables will not be used while Windows is in
;==			   control.
;==
;==  Entry: (Protected Mode)
;==	DS	= _DATA
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:  (Page Fault Handler Reset)
;==
;==	FS:[EBX]= pointer to start of EMM Global Import Data Structure
;==
;==============================================================================
GetEMMGlobImpDatArea	proc	near
	push	eax
	push	ecx
;
;  Get FS:[EBX] pointing to the Page Directory and clear Page Fault Table entries
;
	mov	ebx,[page_directory]
	mov	ecx,2			; two page fault tables
GEGIDAloop:
	movzx	eax,[_PFUser][ecx*2-2]
	or	ax,ax			;Q: Is Page Fault Table being used?
	jz	short GEGIDAnext	; N: skip it
	mov	dword ptr fs:[ebx][eax],0;Y: reset it
GEGIDAnext:
	loop	GEGIDAloop
;
;  Get FS:[EBX] pointing to EMM Global Import Data Structure
;
	add	ebx,PAGE_SIZE		; address for PF0
	pop	ecx
	pop	eax
	ret
GetEMMGlobImpDatArea	endp

;############################################################################
;
;	Procedure name		: Fill_Flags
;
;	ENTRY			: Protected mode
;				  DS->_DATA
;				  FS->DATA32_GSEL
;				  GS->R_CODE
;
;	EXIT			: Fills the EMMOSKey flag and fills the
;				  EMMFlags with the regiser set info.
;
;	REGS MOD		: NONE
;
;############################################################################
Fill_Flags	proc	near
	push	eax
	push	cx
;
;  Initialize data structure
;
	mov	fs:[ebx].EMMGI_Flags,0
;
;  EMM Global Import Interface version number
;
	mov	ax,gs:[EMMGIDataVer]
	mov	word ptr fs:[ebx].EMMGI_Vers,ax
;
;  OS Key
;
	mov	eax,[OS_Key]
	mov	fs:[ebx].EMMGI_OSKey,eax

	mov	si,size RegisterSet_Struc	; access the register set 1
	movzx	cx, BYTE PTR [total_register_sets]
	dec	cx				; not register set 0

chk_active_reg_set:
	cmp	register_set[si].active,TRUE	  ;Q: Is register set active?
	jne	short next_reg_set		  ; N: OK, continue
	or	fs:[ebx].EMMGI_Flags,NONZR_REG_SET; Y: set flag accordingly
	jmp	short fill_flags_done

next_reg_set:
	add	si,size RegisterSet_Struc
	loop	chk_active_reg_set
;
;  If version 1.10 or later set HMA flag accordingly
;
	cmp	word ptr fs:[ebx][EMMGI_Vers],EMMGI_VERSION_111	;Q: Atleast 1.10?
	jb	short fill_flags_done				; N: exit

	or	fs:[ebx].EMMGI_Flags,NO_XMS_HANDLE ; EMBs not managed by CEMM

	cmp	gs:[UMBptr],0			;Q: Is CEMM managing UMBs?
	jne	FFcont				; Y: continue
	or	fs:[ebx].EMMGI_Flags,NO_XMS_UMB	; N: UMBs not managed by CEMM
FFcont:
	cmp	gs:[HMAptr],100000h		;Q: Virtual HMA?
	je	short fill_flags_done		; N: exit

	cmp	[HMAfree],TRUE			;Q: Is virtual HMA free?
	jne	short fill_flags_done		; N: exit
	or	fs:[ebx].EMMGI_Flags,HMA_INFO	; Y: allow windows to use it

fill_flags_done:
	pop	cx
	pop	eax
	ret
Fill_Flags	endp

;########################################################################
;
;	Procedure name	: Fill_EmmCtxt
;
;	ENTRY	:	Protected mode
;			DS -> _DATA
;			FS->DATA32_GSEL
;			GS->R_CODE
;
;	EXIT	:	EMMCtxt array initialized with current values.
;
;	Regs Mod:	NONE
;
;	written	:	7/26/89 HKN
;
;##########################################################################
Fill_EmmCtxt	proc	near
	push	ebp
	push	eax
	push	ecx
	push	edx
	push	edi
	push	es

	mov	dx,PAGET_GSEL
	mov	es,dx
;
;  Fill in the context save map size for CEMM and initialize UMB count
;
	mov	ax,[context_save_area_size]
	mov	fs:[ebx].EMMGI_CntxtSz,al
	mov	fs:[ebx].EMMGI_UMBcnt,0
;
;  Loop through first megabyte looking for EMS/UMBs
;
	xor	esi,esi
	xor	edi,edi
	xor	edx,edx
next_16K_page:
;
;  Initialize context
;
	mov	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_Flags,0
  	mov	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_HMap,-1
	mov	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_Lpag,-1
	mov	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_PPag,-1
 	mov	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_EFlgs,0
;
;  Get physical EMS window number for current 16K context
;
	call	Get_Phys_PNum

	cmp	eax, -1		;Q: Valid physical page number?
	je	short get_UMBs	; N: check for UMBs
	call	GetEMSInfo	; Y: get EMS information

ifdef QEMS
;
;  Index into the EMS_window array to obtain handle and the logical page to
;  which this physical page belongs. Note that the logical page number in the
;  EMS_window array refers 4K pages and hence has to be divided by 4 to get
;  the 16K logical page #
;
;  eax is the physical page number. For each physical page number there are 
;  3 bytes in the EMS_window array. The current EMS_window array is pointed
;  to by the EMS_window_ptr. Therefore [EMS_window_ptr]+eax*3 will access 
;  the appropriate entry
;
	mov	ebp, eax
	shl	ebp, 1
	add	ebp, eax	     	; ebp = eax * 3
	add	ebp, [EMS_window_ptr]	; ebp = offset in EMS_window
	
;AR	mov	cl,EMS_window[eax+eax*2].handle ; handle is only 8 bits
	mov	cl,ds:[ebp].handle 	; handle is only 8 bits

	mov	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_HMap,cl

;AR	mov	cx,EMS_window[eax+eax*2].logical_4k_page
	mov	cx,ds:[ebp].logical_4k_page

	shr	cx,2
	mov	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_Lpag,cx

;
; fill in physical page number
;
	mov	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_PPag,al
;
; indicate that it is an EMM page
;
	mov	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_Flags,EMM_PAGE
	cmp	dx,8000h		;Q: Possible LIM 3.2 page frame?
	jbe	short get_next          ; N: too low (no page frame)
	cmp	ax,4
	jae	short get_next
	or	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_Flags,FRAME_32
endif

	jmp	short get_next

get_UMBs:
	cmp	word ptr fs:[ebx][EMMGI_Vers],EMMGI_VERSION_111	;Q: Atleast 1.10?
	jb	short get_next					; N: exit

	cmp	gs:[UMBptr],0				;Q: UMBs on the system?
	jb	short get_next				; N: exit
;
;  Need to get UMB information
;
	call	GetUMBInfo

get_next:
	add	edi,size EMMContext
	add	dx, 0400h
	jnc	next_16K_page

	pop	es
	pop	edi
	pop	edx
	pop	ecx
	pop	eax
	pop	ebp
	ret
Fill_EMMCtxt	endp

;############################################################################
;
;	Procedure name	:	Fill_HandleInfo
;
;	ENTRY		:	Protected mode
;				DS -> _DATA
;				FS->DATA32_GSEL
;				GS->R_CODE
;				ESI= total size of variable sized entries in structure
;
;	EXIT		: 	EMM_HandleInfo array initialized
;
;	REGs MOD	:	NONE
;
;	written		: 	7/27/89 HKN
;
;############################################################################
Fill_HandleInfo		proc	near
	push	eax
	push	edx
	push	edi
	push	ebp
	push	cx
	push	es

	push	esi				; access to HndlCnt field

	mov	ax,PAGED_GSEL
	mov	es,ax

	mov	fs:[ebx][esi].EMMGI_HndlCnt,0	;(initialize)

	cmp	word ptr fs:[ebx][EMMGI_Vers],EMMGI_VERSION_111	
						; Q: Atleast 1.10?
	jb	FH_hndl0			; N: we cannot pass a null
						;    map as win 3.0 can't 
						;    handle it.

;;	cmp	gs:[NoEMSset],TRUE		; Q: Is NoEMS mode active?
;;	je	FH_exit		     		; Y: no handle info

	cmp	gs:[VCPIset], -1		; Q: has noems been specifed
	jne	FH_exit				; Y: no handle info

FH_hndl0:
;
;  Fill out the handle array
;
	mov	edi,[hndl_tbl_ptr]
	mov	ebp,[hndl_nam_ptr]
	mov	cx,[total_handles]
	xor	edx,edx			; clear handle index
get_handle_info:
	cmp	ds:[edi][edx*4].base_PTE_index,FREE;Q: Is handle allocated
	je	next_handle		           ; N: process next handle

	pop	eax				   ; Y: restore original offset
	inc	fs:[ebx][eax].EMMGI_HndlCnt	   ; increment handle array
	push	eax

	mov	fs:[ebx][EMMGI_Hndls][esi].HandleNum,dl ; handle number
;
;  Initialize Handle structure
;
	mov	fs:[ebx][EMMGI_Hndls][esi].HandleFlags,0
	mov	dword ptr fs:[ebx][EMMGI_Hndls][esi].HandleName,0
	mov	dword ptr fs:[ebx][EMMGI_Hndls][esi].HandleName[4],0
;
;  Get the # of logical pages alloc'd to this handle. Note that the number_PTEs
;  field gives the # of 4K logical pages, so divide by 4.
;
	mov	ax,ds:[edi][edx*4].number_PTEs
	shr	ax,2
	mov	fs:[ebx][EMMGI_Hndls][esi].NumLogPages,ax
;
;  Get Physical address of PTEs. The base_PTE_index field in the handle table
;  points to the required handle space. The selector for this is PAGED_GSEL.
;
	movzx	eax,ds:[edi][edx*4].base_PTE_index
	shl	eax,2				; make an offset
	call	Log2Phy				; physical address for ES:EAX
	mov	fs:[ebx][EMMGI_Hndls][esi].PhysPtrToPTEs,eax
;
;  Check if handle has a name
;					; check if handle is named
	mov	eax,ds:[ebp][edx*8]
	or	eax,eax			;Q: Name?
	jnz	short named_hndl	; Y: get name
	mov	eax,ds:[ebp][edx*8][4]  ; N: check second dword
	or	eax,eax			;Q: Name?
	jz	short chk_context	; N: check if it has a context
;
;  Get/Save name of handle
;
named_hndl:
	mov	eax,ds:[ebp][edx*8]
	mov	dword ptr fs:[ebx][EMMGI_Hndls][esi].HandleName,eax
	mov	eax,ds:[ebp][edx*8][4]
	mov	dword ptr fs:[ebx][EMMGI_Hndls][esi].HandleName[4],eax
	or	fs:[ebx][EMMGI_Hndls][esi].HandleFlags,HANDLE_HAS_NAME
;
;  Check if handle has a context
;
chk_context:
	cmp	byte ptr save_flag[edx],0 		 ;Q: Saved context?
	jne	short proc_next_handle        		 ; N: next handle
	or	fs:[ebx][EMMGI_Hndls][esi].HandleFlags,HANDLE_HAS_CTXT; Y: indicate in handle flag
	or	fs:[ebx].EMMGI_Flags,ANY_HANDLE_CTXT     ;    & also in the EMMFlags
;
;  Next handle structure
;
proc_next_handle:
	add	esi,size EMM_Handle		; point to next EMM_Handle struc
;
;  Get next handle
;
next_handle:
	inc	dx
	dec	cx
	jnz	get_handle_info

FH_exit:
	add	sp,4				; restore stack
	pop	es
	pop	cx
	pop	ebp
	pop	edi
	pop	edx
	pop	eax
	ret
Fill_HandleInfo	endp

;==============================================================================
;==
;==  FillFreeMem: Fill free EMS memory structures, virtual HMA info, and Int 67h
;==		  entry point information into the EMM Global Import Data Structure.
;==
;==  Entry: (Protected Mode)
;==	FS:[EBX]= start of EMM Global Import Data Structure
;==	ESI	= size of variable fields in EMM Global Import Data Structure
;==	DS	= _DATA
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==
;==============================================================================
FillFreeMem	proc	near
	push	eax
	push	ecx
	push	edx
	push	edi
	push	es
ifdef QEMS
	mov	ax,PAGET_GSEL
	mov	es,ax
endif
;
;  Fill Int 67h entry point field
;
	mov	ax,seg R_CODE
	shl	eax,16
	mov	ax,offset R_CODE:EMM_rEntry
	mov	fs:[ebx][esi].EMMGI_Int67,eax
;
;  Fill physical HMA pointer
;
	mov	fs:[ebx][esi].EMMGI_HMA,0
	mov	eax,[HMAptr]			; get HMA physical memory
	cmp	eax,100000h			;Q: Phy=Lin (Virtual HMA)?
	je	short FFMFreeMem		; N: no virtual HMA
						; Y: get PTEs for virtual HMA
	mov	eax,ds:[page_tables]
	add	eax,(100000h shr 12)*4		; linear address of first HMA PTE
	call	Lin2Phy				; Y: pointer to virtual HMA PTEs
	mov	fs:[ebx][esi].EMMGI_HMA,eax
;
;  Fill free memory region structures
;
FFMFreeMem:
	mov	fs:[ebx][esi].EMMGI_FreeMEMcnt,0; initialize count to zero
	mov	edx,esi
	xor	edi,edi
	mov	di,FIRST_HANDLE_PTE
FFMloop:
	call	GetFreeEMSRange
	cmp	eax,-1			;Q: Free EMS range found?
	je	short FFMexit		; N: done, exit

	inc	fs:[ebx][edx].EMMGI_FreeMEMcnt
	mov	fs:[ebx][EMMGI_FreeMEM][esi].MEMstart,eax
	mov	fs:[ebx][EMMGI_FreeMEM][esi].MEMcount,ecx

	add	si,size MEM_FREE_Map
	add	eax,ecx			; search for next free range
	jmp	short FFMloop

FFMexit:
	pop	es
	pop	edi
	pop	edx
	pop	ecx
	pop	eax
	ret
FillFreeMem	endp

;==============================================================================
;==
;==  FillXMS: Fill XMS information into the EMM Global Import Data Structure.
;==
;==  Entry: (Protected Mode)
;==	FS:[EBX]= start of EMM Global Import Data Structure
;==	ESI	= size of variable fields in EMM Global Import Data Structure
;==	DS	= _DATA
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==
;==============================================================================
FillXMS	proc	near
;
;  No XMS EMB management is done in CEMM
;
	mov	fs:[ebx][esi].EMMGI_XMScnt,0

	ret
FillXMS	endp

;==============================================================================
;==
;==  FillFreeUMBs: Fill free UMB memory structures in the EMM Global Import
;==		   Data Structure.
;==
;==  Entry: (Protected Mode)
;==	FS:[EBX]= start of EMM Global Import Data Structure
;==	ESI	= size of variable fields in EMM Global Import Data Structure
;==	DS	= _DATA
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==
;==============================================================================
FillFreeUMBs	proc	near
	push	eax
	push	ecx
	push	edi
	push	dx

;
;  Fill free UMB memory region structures
;
	mov	ecx,esi
	mov	fs:[ebx][ecx].EMMGI_FreeUMBcnt,0; initialize count to zero

	movzx	edi,gs:[UMBptr]
	or	di,di				;Q: UMBs provided?
	jz	short FFUexit			; N: exit
	shl	edi,4				; Y: offset to first ARENA
FFUloop:
	cmp	fs:[edi].Sig,'M'		;Q: Is it an ARENA?
	je	short FFUlcont			; Y: OK
	cmp	fs:[edi].Sig,'Z'		;Q: Is it an ARENA?
	jne	short FFUexit			; N: exit, corruption
;
;  Valid ARENA: Get starting paragraph and length
;
FFUlcont:
	mov	eax,edi				; get current paragraph
	shr	eax,4
	inc	ax				; AX is starting paragraph
	mov	dx,fs:[edi].Len			; get length

	cmp	fs:[edi].Own,0			;Q: Is it a FREE UMB?
	jne	short FFUnext			; N: get next ARENA
;
;  Free UMB encountered: place info in structure
;
	inc	fs:[ebx][ecx].EMMGI_FreeUMBcnt
	mov	fs:[ebx][EMMGI_FreeUMB][esi].UMBseg,ax
	mov	fs:[ebx][EMMGI_FreeUMB][esi].UMBsize,dx

	add	si,size UMB_FREE_Map

FFUnext:
	cmp	fs:[edi].Sig,'Z'		;Q: Is it end of ARENA chain?
	je	short FFUexit			; Y: exit
	add	ax,dx				; N: next ARENA
	shl	eax,4
	mov	edi,eax
	jmp	short FFUloop

FFUexit:
	pop	dx
	pop	edi
	pop	ecx
	pop	eax
	ret
FillFreeUMBs	endp

;==============================================================================
;==
;==  FillProductName: Fill in the name of the vendor and the product 
;==
;==  Entry: (Protected Mode)
;==	FS:[EBX]= start of EMM Global Import Data Structure
;==	ESI	= size of variable fields in EMM Global Import Data Structure
;==	DS	= _DATA
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==
;==============================================================================
FillProductName	proc	near

	push	esi
	push	edi
	push	ecx
	push	ds
	push	es

	mov	ecx, esi

	lea	edi, fs:[ebx][ecx].EMMGI_Vendor
	push	fs
	pop	es		; es:di -> destination

	
	lea	esi, gs:[EMMGIVendor]
	push	gs
	pop	ds		; ds:si -> source string

	mov	cx, 20		; move 40 bytes

	REP32MOVSW

	pop	es
	pop	ds
	pop	ecx
	pop	edi
	pop	esi

	ret

FillProductName	endp


;############################################################################
;
;	Procedure name		: Update_mapping_state
;
;	ENTRY			: Protected mode
;				: DS -> _DATA
;			  	  FS->DATA32_GSEL
;			  	  GS->R_CODE
;
;	EXIT			: mapping state is updated with the info
;				  passed by win386 in EMMCtxt array
;
;	REGs MOD		: NONE
;
;
;	written			: 7/27/89 HKN
;
;############################################################################
Update_mapping_state	proc	near
	push	ebx
	push	esi
	push	edi
	push	ax
	push	cx
	push	dx
	push	es

	mov	di,DATA32_GSEL	; need ES = DATA32_GSEL for MapHandlePage function
	mov	es,di
;
;  Loop through the 64 Context structures and map the EMS ones
;
	mov	edi,ebx		; need EBX for MapHandlePage routine
	xor	esi,esi
	mov	cx,64
UMSloop:
;
; Check if this is a 16K EMS window
;
	test	fs:[edi][EMMGI_Cntxt][esi].EMMCntx_Flags,EMM_PAGE
	jz	short UMSnext	; no - try next context structure

;;	cmp	gs:[NoEMSset],TRUE	;Q: NoEMS mode active?
;;	je	short UMSnext		; Y: must be an error, skip it

	cmp	gs:[VCPIset], -1	; Q: has noems been specifed
	jne	short UMSnext		; Y: must be an error, skip it

;
;  Get current state from this EMS context structure
;
	movzx	ax,fs:[edi][EMMGI_Cntxt][esi].EMMCntx_PPag
	mov	bx,fs:[edi][EMMGI_Cntxt][esi].EMMCntx_LPag
	movzx	dx,fs:[edi][EMMGI_Cntxt][esi].EMMCntx_HMap
;
;  We are using the MapHandlePage function to set the mapping.
;  SS:[EBP].reg_EAX must have access to the AX register.
;

;	push	ax
;	push	ebp
;	mov	bp,sp
;	sub	bp,reg_EAX-4
;	push	edi
;	push	esi

	pushad
	mov	bp, sp

	call	MapHandlePage

;	pop	esi
;	pop	edi
;	add	bp,reg_EAX-4
;	pop	ebp
;	pop	ax

	popad

;
;  Check for an error during the mapping
;
	or	ah,ah				;Q: Succesful mapping?
	jnz	short UMSerror			; N: set error flag (carry)

UMSnext:

	add	esi,size EMMContext		; next EMMCntx entry
	loop	UMSloop
	clc

UMSexit:
	pop	es
	pop	dx
	pop	cx
	pop	ax
	pop	edi
	pop	esi
	pop	ebx
	ret

UMSerror:
	cmp	ah,INVALID_HANDLE	;Q: Handle which didn't unmap?
	je	short UMSnext		; Y: continue

	stc				; set carry (error)
	jmp	short UMSexit

Update_mapping_state	endp

;==============================================================================
;==
;==  Get_Phys_PNum
;==
;==  Entry: (Protected mode)
;== 	DS = _DATA
;==	DX = segment value (0 thru A000) (16K bounded
;==	DS = _DATA
;==	FS = DATA32_GSEL
;==	GS = R_CODE
;==	EBX= global import data
;==
;==  Exit: (Protected Mode)
;==	EAX = modified
;==
;==		: if ( segment in DX is a mappable EMM Page )
;==			     &&
;==			     (
;==			       (import version >= 1.11 && noems not specified)
;==			       ||
;==			       import version < 1.11
;==			     )
;==
;==				EAX = Physical page number
;==			  else
;==				EAX = -1
;==
;==============================================================================
Get_Phys_Pnum	proc	near
	push	edx

	mov	eax,-1		; assume this is not an EMS window
;
;  Because of a bug in Win 3.0, we cannot pass a null if in NoEMS mode
;

	cmp	word ptr fs:[ebx][EMMGI_Vers],EMMGI_VERSION_111 ;Q: Win 3.0?
	jb	short GPPcont		; Y: can't pass null ems map as

	cmp	gs:[VCPIset],-1		;Q: Has noems been specifed
	jne	short GPPexit		; Y: assumption is correct
GPPcont:
	mov	dl,dh
	movzx	edx,dl
	movsx	eax,[EMSsegLoc][edx]

GPPexit:
	pop	edx
	ret
Get_Phys_Pnum	endp

ifdef QEMS
;###########################################################################
;
;	Procedure name	: Get_Phys_PNum
;
;	ENTRY		: Protected mode
;			: DS -> _DATA
;			: DX = segment value (0 thru A000) (16K bounded
;			: DS -> _DATA
;			: FS->DATA32_GSEL
;			: GS->R_CODE
;			: EBX -> global import data
;
;	EXIT		: if ( segment in DX is a mappable EMM Page )
;			     &&
;			     ( 
;			       (import version >= 1.11 && noems not specified)
;			       || 
;			       import version < 1.11 
;			     )
;
;				EAX = Physical page number
;			  else
;				EAX = -1
;
;	REGs MOD	: EAX
;
;	written		: 7/26/89 HKN
;
;###########################################################################
Get_Phys_Pnum	proc	near
	push	dx
	push	cx

	cmp	word ptr fs:[ebx][EMMGI_Vers],EMMGI_VERSION_111	
					; Q: Atleast 1.10?
	jb	GPPcont			; N: can't pass null ems map as 
					;    win3.0 cannot handle it.

;;	cmp	gs:[NoEMSset],TRUE	; Q: Is NoEMS mode active?
;;	je	short GPPnotFound	; Y: don't check for EMS

	cmp	gs:[VCPIset], -1		; Q: has noems been specifed
	jne	short GPPnotFound	; Y: don't check for EMS

GPPcont:
	shr	dx,8			; convert segment in dx to PTE offset
	mov	cx,[number_EMS_windows]
	xor	eax,eax

next_window:
	cmp	dx,EMS_window_location[eax*2]
	je	short got_phys_page
	inc	eax
	loop	next_window

GPPnotFound:
	mov	eax, -1

got_phys_page:
	pop	cx
	pop	dx
	ret
Get_Phys_Pnum	endp
endif
even
;==============================================================================
;==
;==  GetEMSInfo: Get handle and the logical page to which this physical page
;==	         belongs.
;==
;==  Entry: (Protected Mode)
;==	EAX	= index for EMS windows
;==	EDX	= segment address for 16K block size
;==	FS:[EBX]= start of EMM Global Import Data Structure
;==	ESI	= offset into current UMB structure
;==	EDI	= offset into current CONTEXT structure
;==	DS	= _DATA
;==	ES	= PAGET_GSEL
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==
;==============================================================================
GetEMSinfo proc	near
	push	edx
	push	esi
	push	es

	push	ebx
;
;  Fill in physical page number
;
	mov	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_PPag,al

;
;  Indicate that it is an EMM page
;
	mov	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_Flags,EMM_PAGE

	cmp	dx,8000h		;Q: Possible LIM 3.2 page frame?
	jbe	short GEiCont		; N: too low (no page frame)

	cmp	al,4			;Q: Is it page frame?
	jae	short GEiCont		; N: must be windows 0.3

	or	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_Flags,FRAME_32
GEiCont:
;
;  Setup for searching through Handles
;
	movzx	esi,dx
	shr	si,8
	mov	eax,es:[esi*4]	; get page currently mapped at this window
	shr	eax,12		; clear control bits

	mov	si,PAGED_GSEL	; access handle space
	mov	es,si

	mov	cx,[total_handles]	; number of handles to loop through
GEiLoop:
;
;  Search each handle for ownership of this page
;
	dec	cx			; handle index
	movzx	esi,cx			; handle index
	shl	si,2
	add	esi,[hndl_tbl_ptr]	; (EDI) = pointer to handle structure
	.errnz	(SIZE HandleTable_struc-4)

	movzx	edx,ds:[si].number_PTEs	    ; get number of PTEs
	movzx	esi,ds:[si].base_PTE_index  ; get base_PTE_index

	cmp	si,FREE 		    ;Q: Handle in use?
	je	short GEiNextHandle	    ; N: next handle

	shr	dx,2			; number of EMS pages to this handle
	shl	esi,2			; starting offset for handle space

	or	dx,dx			;Q: Does this handle have pages?
	jz	short GEiNextHandle	; N: it can't be the one we're looking for
GEiFindPage:
	dec	dx
	shl	dx,2			; adjust to 4K page number
	mov	ebx,es:[esi][edx*4]	; get logical page
	shr	dx,2			; re-adjust to 16K page number
	shr	ebx,12			; make a PTE index

	cmp	eax,ebx			;Q: Is there a match?
	je	short GEiExit		; Y: exit

	or	dx,dx			;Q: More logical pages for this handle
	jnz	short GEiFindPage	; Y: continue

GEiNextHandle:
	or	cx,cx			;Q: Anymore handles?
	jnz	short GEiLoop		; Y: continue

;
;  This window is currently not mapped
;
	mov	cl,FREE		; this window is free
	mov	dx,NULL_PAGE	; no logical page
;
;  At this point, CL is the handle index and DX is the logical page number
;
GEiExit:
	pop	ebx
	mov	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_HMap,cl
	mov	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_Lpag,dx

	pop	es
	pop	esi
	pop	edx
	ret
GetEMSinfo	endp

even
;==============================================================================
;==
;==  GetUMBInfo: Detects a UMB in a 16K area.  If detected, the EMM Global
;==		 Import Data Structure will be updated in the CONTEXT structure
;==		 and the UMB structure.
;==
;==  Entry: (Protected Mode)
;==	EDX	= segment address for 16K block size
;==	FS:[EBX]= start of EMM Global Import Data Structure
;==	ESI	= offset into current UMB structure
;==	EDI	= offset into current CONTEXT structure
;==	DS	= _DATA
;==	ES	= PAGET_GSEL
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==
;==============================================================================
GetUMBinfo proc	near
	push	eax
	push	ecx
	push	dx

;
;  ESI is offset into current UMB array structure entry: Initialize it
;
	mov	fs:[ebx][EMMGI_UMBs][esi].EUM_Page0,0
	mov	fs:[ebx][EMMGI_UMBs][esi].EUM_Page1,0
	mov	fs:[ebx][EMMGI_UMBs][esi].EUM_Page2,0
	mov	fs:[ebx][EMMGI_UMBs][esi].EUM_Page3,0

	xor	ecx,ecx			; start with first 4K page
	shr	dx,8			; linear index into page table
GUiLoop:
;
;  Assume this page is "unuseable"
;
	shl	cx,1
	mov	ax,CNTXT_NOTUSED
	shl	ax,cl
	or	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_EFlgs,al
	shr	cx,1
;
;  Check linear=physical
;
	cmp	dx,0FFh			;Q: Last ROM page?
	je	short GUiNext		; Y: Windows can't write protect it!

	mov	eax,es:[edx*4]		; get PTE entry
	bt	eax, fWINPageBit	;Q: WINdows page?
	jnc	short GUiNotWinPage	; N:

	call	GUiUseable		; Y: mark page "useable" for Windows
	jmp	short GUiNext

GUiNotWinPage:
	shr	eax,12			; turn into physical index

	cmp	eax,edx			;Q: Linear=Physical?
	je	short GUiNext		; Y: not a UMB and thus assume unuseable
;
;  UMB found: unmark "unuseable" assumption
;
	call	GUiUseable
;
;  Indicate a UMB
;
	push	ax
	mov	ax,1
	shl	ax,cl
	shl	ax,CNTXT_UMB0bit
	or	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_Flags,al
	pop	ax
;
;  Save physical index in UMB structure
;
	mov	fs:[ebx][EMMGI_UMBs][esi].EUM_Page0,eax
;
;  Next 4K page
;
GUiNext:
	add	si,type EUM_Page0
	inc	dx
	inc	cx
	cmp	cx,4
	jb	short GUiLoop
	sub	si,size EMM_UMB_Map
;
;  Update UMB array pointer
;
	test	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_Flags,-1 ;Q: Any UMBs?
	jz	short GUiExit			   ; N: next context
	mov	al,fs:[ebx].EMMGI_UMBcnt	   ; Y: save UMB array index

	mov	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_UMBindex,al
	inc	fs:[ebx].EMMGI_UMBcnt		; increment UMB array count
	add	si,size EMM_UMB_Map		; add to variable portion

GUiExit:
	pop	dx
	pop	ecx
	pop	eax
	ret
GetUMBinfo	endp


;  mark page as "useable"

GUiUseable proc near

;  Unmark "unusable" assumption

	shl	cx,1
	push	ax
	mov	ax,CNTXT_NOTUSED
	shl	ax,cl
	not	ax
	and	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_EFlgs,al ; "unknown" status
;
;  Mark as "useable"
;
	mov	ax,CNTXT_USEABLE
	shl	ax,cl
	or	fs:[ebx][EMMGI_Cntxt][edi].EMMCntx_EFlgs,al
	shr	cx,1
	pop	ax
	ret

GUiUseable endp

;==============================================================================
;==
;==  GetFreeEMSRange: Finds next free EMS range.
;==
;==  Entry: (Protected Mode)
;==	EDI	= starting index in handle space to search
;==	DS	= _DATA
;==	ES	= PAGET_GSEL
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==	EAX	= starting page number of free range (-1 if range not found)
;==	ECX	= free region size in number of pages
;==
;==============================================================================
GetFreeEMSRange	proc	near
	push	ebx
	push	edx
	push	si

	mov	edx,[page_directory]
GFERloop1:
	cmp	di,[TopOfFreeEMSspace]
	jae	short GFERdone

	mov	eax,fs:[edx][edi*4]
	add	di,4

	test	ax,fEMSPageAllocated
	jnz	short GFERloop1

	mov	ecx,4
	mov	ebx,eax
GFERloop2:
	add	ebx,4000h

	cmp	di,[TopOfFreeEMSspace]
	jae	short GFERcont

	cmp	ebx,fs:[edx][edi*4]
	jne	short GFERcont

	add	cx,4
	add	di,4
	jmp	short GFERloop2

GFERcont:
	shr	eax,12

;
;  EAX = free pool start (or -1) and ECX = count of free pool
;
GFERexit:
	pop	si
	pop	edx
	pop	ebx
	ret
GFERdone:
	mov	eax,-1
	jmp	short GFERexit
GetFreeEMSRange	endp

ifdef QEMS
;==============================================================================
;==
;==  GetFreeEMSRange: Finds next free EMS range.
;==
;==  Entry: (Protected Mode)
;==	EAX	= starting page number for search
;==	DS	= _DATA
;==	ES	= PAGET_GSEL
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==	EAX	= starting page number of free range (-1 if range not found)
;==	ECX	= free region size in number of pages
;==
;==============================================================================
GetFreeEMSRange	proc	near
	push	ebx
	push	edx
	push	si
;
;  Initialize local variables
;
GFERinit:
	mov	si,word ptr [AllocMapPtr]

	xor	ebx,ebx
	xor	ecx,ecx
	xor     edx,edx
	dec	edx
;
;  Figure out the EMS pool above and below where we are
;
	cmp	gs:[starting_conv_mem_PTE],0
	jz	short GFERhigh

	cmp	ax,gs:[starting_conv_mem_PTE]
	jb	short GFERcon2
	movzx	ebx,gs:[starting_conv_mem_PTE]
	mov	cx,gs:[number_conv_mem_PTEs]
	jmp	short GFERhigh
GFERcon2:
	movzx	edx,gs:[starting_conv_mem_PTE]
	ror	ecx,16
	mov	cx,gs:[number_conv_mem_PTEs]
	ror	ecx,16

GFERhigh:
	cmp	gs:[starting_high_mem_PTE],0
	jz	short GFERext

	cmp	ax,gs:[starting_high_mem_PTE]
	jb	short GFERhigh2
	cmp	bx,gs:[starting_high_mem_PTE]
	ja	short GFERext
	movzx	ebx,gs:[starting_high_mem_PTE]
	mov	cx,gs:[number_high_mem_PTEs]
	jmp	short GFERext
GFERhigh2:
	cmp	dx,gs:[starting_high_mem_PTE]
	jb	short GFERext
	movzx	edx,gs:[starting_high_mem_PTE]
	ror	ecx,16
	mov	cx,gs:[number_high_mem_PTEs]
	ror	ecx,16

GFERext:
	cmp	gs:[starting_ext_mem_PTE],0
	je	short GFERcont

	cmp	ax,gs:[starting_ext_mem_PTE]
	jb	short GFERext2
	cmp	bx,gs:[starting_ext_mem_PTE]
	jae	short GFERcont
	movzx	ebx,gs:[starting_ext_mem_PTE]
	mov	cx,gs:[number_ext_mem_PTEs]
	jmp	short GFERcont
GFERext2:
	cmp	dx,gs:[starting_ext_mem_PTE]
	jb	short GFERcont
	movzx	edx,gs:[starting_ext_mem_PTE]
	ror	ecx,16
	mov	cx,gs:[number_ext_mem_PTEs]
	ror	ecx,16
;
;  We now have the lower pool in EBX,ECX(low) and high pool at EDX,ECX(high)
;
GFERcont:
	add	cx,bx
	cmp	ax,cx		;Q: Are we in lower pool?
	jae	short GFERhiPool; N: try higher pool
	movzx	edx,cx		; Y: last PTE+1 of this pool
	jmp	short GFERusedloop

GFERhiPool:
	shr	ecx,16
	mov	eax,edx		; start of next pool
	add	dx,cx		; end of this pool
	cmp	eax,-1		;Q: Have we reached the end of EMS memory?
	je	short GFERexit	; Y: exit

GFERusedloop:
	bt	ds:[si],ax			;Q: Allocated?
	jnc	short GFERfree			; N: this range is free
	inc	ax				; Y: try next bit
	cmp	ax,dx				;Q: Have we reached the end of pool?
	jb	short GFERusedloop		; N: continue searching
	jmp	GFERinit			; Y: go to next pool

GFERfree:
	mov	bx,ax				; free pool start
	xor	ecx,ecx				; initialize count to zero
	inc	bx				; we have already tested first page
	inc	cx				; we know we have atleast one page
GFERfreeloop:
	bt	ds:[si],ax			;Q: Allocated?
	jc	short GFERexit			; Y: end of the free pool
	inc	cx
	inc	bx
	cmp	bx,dx				;Q: Reached end of EMS pool?
	jb	short GFERfreeloop		; N: see if next PTE is free
;
;  EAX = free pool start (or -1) and ECX = count of free pool
;
GFERexit:
	pop	si
	pop	edx
	pop	ebx
	ret
GetFreeEMSRange	endp
endif
ifdef QEMS
;==============================================================================
;==
;==  GetFreeEMSRange: Finds next free EMS range.
;==
;==  Entry: (Protected Mode)
;==	EAX	= starting page number for search
;==	DS	= _DATA
;==	ES	= PAGET_GSEL
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==	EAX	= starting page number of free range (-1 if range not found)
;==	ECX	= free region size in number of pages
;==
;==============================================================================
	push	ebx
	push	edx
	push	si

	mov	si,word ptr [AllocMapPtr]
	xor	ecx,ecx

GFERloop:
	movzx	ebx,gs:[starting_conv_mem_PTE]
	movzx	edx,gs:[number_conv_mem_PTEs]

	call	CheckRange
	jnc	short GFERcont

	movzx	ebx,gs:[starting_ext_mem_PTE]
	movzx	edx,gs:[number_ext_mem_PTEs]

	call	CheckRange
	jnc	short GFERcont

	movzx	ebx,gs:[starting_high_mem_PTE]
	movzx	edx,gs:[number_high_mem_PTEs]

	call	CheckRange
	jnc	short GFERcont
	mov	eax,-1
	jmp	short GFERexit

GFERcont:
	mov	ebx,eax				; start of range
	bt	ds:[si],ax			;Q: Allocated?
	jnc	short GFERfree			; N: this range is free

;QEMS	test	es:[eax*4],PAGE_ALLOCATED_BIT_MASK;Q: Allocated?
;QEMS	jz	short GFERfree			  ; N: this range is free
	inc	eax				  ; Y: try next PTE

	cmp	eax,edx				;Q: Reached end of EMS pool?
	jb	short GFERcont			; N: try next PTE
	jmp	short GFERloop			; Y: try next EMS pool

GFERfree:
	inc	ecx				; free range size
	inc	ebx				; try next PTE

	cmp	ebx,edx				;Q: Reached end of EMS pool?
	jae	short GFERexit			; Y: exit

	bt	ds:[si],bx			;Q: Allocated?
	jnc	short GFERfree			; N: increase range size

;QEMS	test	es:[ebx*4],PAGE_ALLOCATED_BIT_MASK;Q: Allocated?
;QEMS	jz	short GFERfree			  ; N: increase range size
GFERexit:					  ; Y: return free region
	pop	si
	pop	edx
	pop	ebx
	ret
GetFreeEMSRange	endp
;==============================================================================
;==
;==  CheckRange: Find an EMS range.
;==
;==  Entry: (Protected Mode)
;==	EAX	= entry to search higher than
;==	EBX	= start of a EMS pool range
;==	EDX	= number of PTE entries in pool range
;==	DS	= _DATA
;==	ES	= PAGET_GSEL
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==	EAX	= starting page number to start search
;==	EDX	= last PTE entry for this pool + 1
;==	NC	= within EMS range
;==	CY	= outside EMS range
;==
;==============================================================================
CheckRange proc	near

	add	edx,ebx		; boundary for EMS pool

	or	edx,edx		;Q: Valid EMS pool range?
	jz	short CRerror	; N: exit

	cmp	eax,ebx		;Q: Below EMS pool?
	jbe	short CRbelow	; Y: start at base of EMS pool

	cmp	eax,edx		;Q: Above EMS pool?
	jb	short CRok	; N: OK, within range
CRerror:
	stc			; check next EMS pool range
	jmp	CRexit

CRbelow:
	mov	eax,ebx		; start at the beginning of EMS pool
CRok:
	clc			; Check this EMS pool
CRexit:
	ret
CheckRange 	endp
endif

;==============================================================================
;==
;==  VxDSupport: Add a Win386 Startup Info Structure for a VxD which handles
;==		 UMBs.
;==
;==  Entry: (Real Mode)
;==	DS	= _DATA
;==	ES	= PAGET_GSEL
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==	DI	= Version number: major in upper byte, minor in lower
;==
;==  VMTF_ES:BX	= points to next data structure in linked chain
;==
;==
;==  Exit:
;==  VMTF_ES:BX	= pointer to our data structure
;==
;==============================================================================
VxDSupport proc	near


	push	eax
;
;  Check Page Table 0 for aliasing of first megabyte
;
	call	VxDlistUMB
;
;  If no aliasing in first megabyte, VxD not needed.
;
	cmp	ds:[Win386VxDRefDat].RDSUMBstart,0
	je	short VxDSexit
;
;  Fill in used UMB information in VxD structure
;
	call	VxDUsedUMBList
;
;  Delete EMS windows from the UMB list
;
	call	VxDEMSPages
;
;  Delete C6 and C7 if Cega installed and length > 24 K
;
	call	VxdCROMPages
;
;  We now initialize the WSSnextPtr and WSSVxDFilePtr fields in Win386Struc.
;  The former is initilazed to ES:BX in segment:offset form. The latter 
;  is initialized to CEMMpath that is defined in the R1_CODE segment as 
;  a linear address. Note that the segment of R1_CODE segment is obtained
;  from any one of the entries in the UMBFARTABLE defined in umbseg.asm.
;
;
	push	edi
	movzx	edi, word ptr gs:[EMM_rFarEntry+2]
	shl	edi, 4
	add	edi, OFFSET R1_CODE:Win386Struc

	;
	; edi = 32 bit pointer to Win386Struc defined in R1_CODE
	;

	mov	ax,[bp][VTFO].VMTF_ES
	shl	eax,16
	mov	ax,bx
	mov	fs:[edi].WSSnextPtr,eax

	mov	ax, gs:[EMM_rFarEntry+2]
	shl	eax,16
	lea	ax,R1_CODE:CEMMpath
	mov	fs:[edi].WSSVxDFilePtr,eax
	shr	eax, 16

;
;  Make ES:BX point to Win386 Startup Structure for UMB VxD
;
	mov	[bp][VTFO].VMTF_ES,ax
	mov	bx,OFFSET R1_CODE:Win386Struc
	pop	edi

VxDSexit:
	pop	eax
	ret
VxDSupport	endp

;==============================================================================
;==
;==  VxDlistUMB: Initialize Windows 386 UMB VxD refrence data struture with
;==		 physical addresses of UMBs.
;==
;==  Entry: (Real Mode)
;==	DS	= _DATA
;==	ES	= PAGET_GSEL
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==
;==============================================================================
VxDlistUMB proc	near
	push	eax
	push	ebx
	push	esi
	push	edi
	push	cx
;
;  Make ESI point to PT0 and EDI point to [Win386VxDRefDat].RDSUMBarray
;
	mov	esi,ds:[page_tables]

;;	mov	di,seg R_CODE
;;	movzx	edi,di
;;	shl	edi,4
	mov	edi, gs:[p_DATA];
	add	edi,offset ds:[Win386VxDRefDat].RDSUMBarray

	mov	ebx,0A0h
	mov	cx,100h-0A0h		; loop thru PTEs from A000 to 1MB
VlUFindFirst:
	mov	eax,fs:[esi][ebx*4]
	shr	eax,12
	cmp	eax,ebx			;Q: Have we reached the first lin<>phy?
	jne	short VlUFirst		; Y: first UMB page
	inc	bx			; get next PTE
	loop	VlUFindFirst
	jmp	short VlUexit

;
;  First UMB has been detected
;
VlUFirst:
	mov	ds:[Win386VxDRefDat].RDSUMBstart,ebx
VlUFound:
	cmp	eax,ebx			; Q: lin = phy
	jne	VlUFcont		; N:
	xor	eax,eax			; Y: stuff 0 in UMBarray
VlUFcont:
	mov	fs:[edi],eax
	add	edi,4
	inc	bx
	mov	eax,fs:[esi][ebx*4]
	shr	eax,12
	loop	VlUFound

VlUexit:
	mov	gs:[pRDSdata],di	; address of next entry in Win386VxDRefData

	pop	cx
	pop	edi
	pop	esi
	pop	ebx
	pop	eax
	ret
VxDlistUMB	endp

;==============================================================================
;==
;==  VxDUsedUMBList: Fills VxD data structure with used UMB area.
;==
;==  Entry: (Protected Mode)
;==	DS	= _DATA
;==	ES	= PAGET_GSEL
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==
;==============================================================================
VxDUsedUMBList	proc	near
	push	eax
	push	edx
	push	edi
;
;  VxD Used List only if UMBptr
;
	cmp	gs:[UMBptr],0		;Q: UMB ARENAs on the system?
	je	VUULexit		; N: exit
;
;  Get free UMB memory region areas
;
	movzx	edi,gs:[UMBptr]
	or	di,di				;Q: UMBs provided?
	jz	VUULexit			; N: exit
	shl	edi,4				; Y: offset to first ARENA
VUULloop:
	cmp	fs:[edi].Sig,'M'		;Q: Is it an ARENA?
	je	short VUULlcont			; Y: OK
	cmp	fs:[edi].Sig,'Z'		;Q: Is it an ARENA?
	jne	short VUULexit			; N: exit, corruption
;
;  Valid ARENA: Get starting paragraph and length
;
VUULlcont:
	mov	eax,edi				; get current paragraph
	shr	eax,4
	movzx	edx,fs:[edi].Len		; M015: get length and 
						; M015: Zxtend it.
	add	dx,2

	cmp	fs:[edi].Own,0			;Q: Is it a FREE UMB?
	jne	short VUULnext			; N: get next ARENA

	push	eax
	push	edx

	shl	eax,4
	shl	edx,4

	add	edx,eax
	add	eax,1000h-1

	shr	eax,12
	shr	edx,12

	sub	eax,ds:[Win386VxDRefDat].RDSUMBstart
	sub	edx,ds:[Win386VxDRefDat].RDSUMBstart
	cmp	eax,edx
	jae	short VUULnoFreePage
VUULclear:
	mov	ds:[Win386VxDRefDat][eax*4].RDSUMBarray,0
	inc	eax
	cmp	eax,edx
	jb	short VUULclear
VUULnoFreePage:
	pop	edx
	pop	eax

VUULnext:
	cmp	fs:[edi].Sig,'Z'		;Q: Is it end of ARENA chain?
	je	short VUULexit			; Y: exit
	add	ax,dx				; N: next ARENA
	dec	ax
	shl	eax,4
	mov	edi,eax
	jmp	VUULloop

VUULexit:
	pop	edi
	pop	edx
	pop	eax
	ret
VxDUsedUMBList	endp

;==============================================================================
;==
;==  VxDEMSPages: Clear EMS pages from the VxD UMB list
;==
;==  Entry: (Protected Mode)
;==	DS	= _DATA
;==	ES	= PAGET_GSEL
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==
;==============================================================================
VxDEMSPages	proc	near
	push	eax
	push	esi
	push	cx

;
;  Check if any EMS pages exist
;
	cmp	gs:[NoEMSset],TRUE	;Q: EMS available?
	je	short VEPexit		; N: exit

	cmp	gs:[NoPFset],TRUE	;Q: FRAME=NONE specified?
	je	short VEPexit		; Y: exit

;
;  Check to see if EMS pages are part of the UMB list
;
	xor	esi,esi
	mov	cx,[number_EMS_windows]	; number of EMS windows

VEPEMSLoop:
	movzx	eax,[EMS_window_location][esi*2]	; get EMS linear page
	sub	eax,ds:[Win386VxDRefDat].RDSUMBstart	; offset into UMB list
	jb	short VEPnext				; not pat of UMB list

;
;  Delete the EMS page from the UMB list
;
	push	cx
	mov	cx,4
VEPClearLoop:
	mov	ds:[Win386VxDRefDat][eax*4].RDSUMBarray,0
	inc	eax
	loop	VEPClearLoop
	pop	cx
VEPnext:
	inc	si
	loop	VEPEMSLoop

VEPexit:
	pop	cx
	pop	esi
	pop	eax
	ret
VxDEMSPages	endp

;==============================================================================
;==
;==  VxDCROMPages: Clear the Video ROM alias pages if a non-CPQ ROM is detected.
;==		   This is to prevent Win 3.0 from crashing. Also clear page
;==		   page at FF/reset vector.
;==
;==  Entry: (Protected Mode)
;==	DS	= _DATA
;==	ES	= PAGET_GSEL
;==	FS	= DATA32_GSEL
;==	GS	= R_CODE
;==
;==  Exit:
;==
;==============================================================================
VxDCROMPages	proc	near
	push	eax
	push	cx
;
;  Do not alias PTE 0FFh because Win 3.0 will not write protect it.

	mov	eax, 0ffh
	sub	eax,ds:[Win386VxDRefDat].RDSUMBstart	
					; offset into UMB list
	mov	ds:[Win386VxDRefDat][eax*4].RDSUMBarray,0 
					; no aliasing
;
;  Do not alias VIDEO ROM if it's greater than 24K - due to a Win 3.0 problem.
;
	test	gs:[Current_State], fstate_CEGAinst ;Q Shadowed Video ROM installed?
	jz	VCRdone				    ; N: don't worry

	cmp	gs:[CROM_Length],600h	;Q: Larger than 24K
	jbe	short VCRdone		; N: no problem with Win 3.0!

	mov	cx,gs:[CROM_Length]	; get actual size
	shr	cx,8			; size in pages
	mov	eax,0C0h		; starting page

	sub	eax,ds:[Win386VxDRefDat].RDSUMBstart	; offset into UMB list
VCRloop:
	mov	ds:[Win386VxDRefDat][eax*4].RDSUMBarray,0 ; no aliasing
	inc	eax					  ; next page
	loop	VCRloop


ifdef 901004					; CROM_length has length in paras
	cmp	gs:[CROM_Length], 0600h	; Q: is Rom length > 24 K
	jbe	VCRdone			; N:

					; Y: zero out c6 and c7
	mov	eax, 0c6h
	sub	eax,ds:[Win386VxDRefDat].RDSUMBstart	; offset into UMB list
	mov	ds:[Win386VxDRefDat][eax*4].RDSUMBarray,0
	inc	eax
	mov	ds:[Win386VxDRefDat][eax*4].RDSUMBarray,0
endif

VCRdone:
	pop	cx
	pop	eax
	ret
VxDCROMPages	endp

_TEXT	ends

;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
R1_CODE segment
	assume	cs:R1_CODE,ds:nothing,es:nothing
;==============================================================================
;==
;==  rINT2FhHandler: This is an interrupt 2Fh handler which monitors for the
;==	      	     Windows 386 and DOS Extender Initialization.
;==
;==  Entry: (Real Mode)
;==	AX	= 1605h Windows Initialization
;==	ES:BX	= 0:0
;==	DS:SI	= 0:0
;==	DI	= Version number: major in upper byte, minor in lower
;==	CX	= 0
;==	DX	= Flags
;==	  Bit 0 = 0 Windows 386 inititalization
;==	  	  1 Windows 286 DOS extender inititalization
;==
;==  Exit:
;==
;==	AX	= 1605h Windows Initialization
;==	ES:BX	= pointer to linked instance data structure chain
;==	DS:SI	= far call entry point for Virtual Disable Call
;==	DI	= Version number: major in upper byte, minor in lower
;==	CX	= 0 if OK for Windows to initialize
;==	        <>0 if Windows should NOT initialize
;==	DX	= Flags
;==	  Bit 0 = 0 Windows 386 inititalization
;==	  	  1 Windows 286 DOS extender inititalization
;==
;==============================================================================
rINT2FhHandler:

	pushf

	cmp	ah,16h			;Q: Windows Init or Exit?
	jne	short rI2Fquick 	; N: chain

	push	ds
	push	seg R_CODE
	pop	ds
	assume	ds:R_CODE

	cmp	al,05h			;Q: Windows Init?
	je	short rI2FWinInit	; Y: process
	cmp	al,06h			;Q: Windows Exit?
	jne	short rI2FoldHandler	; N: exit
	and	[GenFlags],not fWin30	; Y: Win 3.0 broadcast over

	mov	[EMMGIDataVer],EMMGI_VERSION_LO
					; set import veriosn back to base 1.00 

	cmp	[Current_Mode],MODE_OFF ;Q: Is CEMM off?
	je	short rI2FoldHandler	; Y: chain
	mov	[DevName],'E'		; N: make sure EMS on

;;        cmp     cs:[NoEMSset],TRUE	;Q: Is CEMM in NoEMS mode?
;;        jne	short rI2FoldHandler	; N: chain

	mov	[DevName+3], 'X'	; ensure that 4th char in device
					; name is X rather than Q.

	cmp	[VCPIset], -1		; Q: has noems been specifed.
        je	short rI2FoldHandler	; N: chain

	cmp	[VCPIset], FALSE	; Q: did user specify only NOEMS
	jne	short rI2FSpecialSig	; N: noems+poolsize was specfied

	mov	[DevName],'$'		; Y: make sure EMS is off
	jmp	short rI2foldHandler

rI2FSpecialSig:
	mov	[Devname+3], 'Q'	; set up sig to EMMQXXX.

rI2FoldHandler:
	pop	ds
rI2Fquick:
	popf
	jmp	cs:[PrevInt2F]

;============================================================================
;=  Instance data, install a driver, and Virtual Disable Call entry point
;============================================================================
rI2FWinInit:
        test    dx,1				; M013: Q: Win Standard Mode?
        jnz	short rI2FStdInit		; M013: Y: do std. mode init

	cmp	[Current_Mode],MODE_OFF 	;Q: Is CEMM off?
        je      short rI2FoldHandler		; Y: chain

	call	[ValidPathFar]			; M010: Q: is the path valid
	jc	short rI2FInvPath		; M010: N: fail win start up

	test	[GenFlags], fBackfill		; Q: is backfill on
	jnz	short rI2Fbackfill		; Y: fail win start up

	test	[Current_State],fState_Active	;Q: Is CEMM active?
	jnz	short rI2Fhook			; Y: hook broadcast

	mov	[DevName],'$'			; N: turn EMS off
        jmp	short rI2FoldHandler		; chain

;============================================================================
;	Standard mode init: Change device name to EMMQXXX 
;============================================================================

rI2fStdInit:
	cmp	di, WIN_VERSION_LO	; Q: is version > 3.0
	jbe	rI2foldHandler		; N: just chain
	mov	[Devname], 'E'		; Y: change device name
	mov	[Devname+3], 'Q'
	jmp	short rI2foldHandler	

;==============================================================================
;==  Fail Windows start up due to base memory back fill
;==============================================================================

rI2Fbackfill:
	push	dx
	lea	dx, R1_CODE:WinBackfillMess
	jmp	short rI2fPrintFail		; print msg and ret failure

;==============================================================================
;==  Fail Windows start up due to invalid path
;==============================================================================

rI2FInvPath: 					; M010 - Start
	push	dx
	lea	dx, R1_CODE:WinInvPathMess	; print error message

rI2fPrintFail:
	push	ax
	mov	ax, cs
	mov	ds, ax			; ds = segment of R1_CODE
	assume	ds:nothing
	mov	ah, 09h
	int	21h			; print error msg
	pop	ax
	pop	dx
	mov	cx, 1				; indicate failure cx != 0
	jmp	short rI2FoldHandler		; M010 - End

;==============================================================================
;==  Call previous INT 2Fh to get instance data or installable device
;==============================================================================
	assume	ds:R_CODE

rI2Fhook:
	mov	[DevName],'E'		; make sure EMS is on
	mov	[DevName+3], 'X'
;
;  Call previous INT 2Fh to get instance data or installable device
;
	pop	ds
	assume	ds:NOTHING
	popf				; restore original flags
	pushf				; set up for emulated int 2Fh
	call	cs:[PrevInt2F]

	push	ax
	push	ds
	mov	ax, seg R_CODE
	mov	ds, ax
	assume	ds:R_CODE
	mov	ax,2			; code for Win broadcast
;==============================================================================
;==  Update Windows Version and VxD (if Win 3.0)
;==============================================================================
	cli
	or	[TrapFlags],fWinTrap	; dispatch to Ein Global Import
	pop	ds
	assume	ds:NOTHING
	int	ProtTrap		; enter protected mode
	pop	ax
	iret

R1_CODE ends

;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
R_CODE	segment
	assume	cs:R_CODE,ds:nothing,es:nothing
;==============================================================================
;==  rWinV86Proc jump table
;==============================================================================
rWVPtable	label	word
	dw	offset rWinVirDisable
	dw	offset rWinVirEnable
rWVPmax	equ	$-rWVPtable
;==============================================================================
;==
;==  rWinV86Proc: This routine is called by Windows to disable/enable V86
;==		  mode.  During V86 disable, the EMM Global Import data
;==		  structure is updated to reflect CEMM's current EMS and
;==		  linear to physical mapping state.  During V86 enable,
;==		  CEMM will update its internal data structures and page
;==		  tables with information from the EMM Global data structure.
;==		  This allows critical information to be passed to Windows
;==		  during V86 disable, and to CEMM from Windows during V86
;==		  enable.
;==
;==  Entry: (Real/V86 Mode)
;==	AX	= 0	Disable Virtual 8086 mode (enter Real Mode)
;==		= 1	Re-enable Virtual 8086 mode (from Real Mode)
;==
;==  Exit:  (V86/Real Mode)
;==
;==============================================================================
rWinV86Proc	proc	far
	push	bx

	mov	bx,ax
	shl	bx,1

	cmp	bx,rWVPmax		;Q: Valid function?
	jae	short rWinV86exit	; N: error

	clc				; assume success
	call	cs:[rWVPtable][bx]	; call function

rWinV86exit:
	pop	bx
	ret
rWinV86Proc	endp

;==============================================================================
;==
;==  rWinVirDisable: This routine is called by Windows to disable V86 mode
;==		     During V86 disable, the EMM Global Import data structure
;==		     is updated to reflect CEMM's current EMS and linear to
;==     	     physical mapping state. This allows critical information
;==		     to be passed to Windows during V86 disable.
;==
;==  Entry: (V86 Mode)
;==	AX	= 0	Disable Virtual 8086 mode (enter Real Mode)
;==
;==  Exit:  (Real Mode)
;==
;==============================================================================
rWinVirDisable	proc	near
;
;  Windows Virtual Disable Call
;
	and	cs:[GenFlags],not fWin30	; Win 3.0 broadcast complete

	test	cs:[Current_State],fState_Active;Q: Virtual Mode?
	jz	rWVDerror			; N: error

;==============================================================================
;==  Update EMM Global Import data structure from internals
;==============================================================================
	cli
	or	cs:[TrapFlags],fWinTrap ; dispatch to Ein Global Import
	int	ProtTrap		; enter protected mode
;
;  Leave A20 enabled for Windows and indicate Windows is in control
;
	or	cs:[Current_State],fState_A20Ena+fState_WinCntrl

	pushad

;;	push	cs
;;	pop	es

	mov	di, cs:[EMM_rFarEntry+2]	
	mov	es, di			; es = segment of R1_CODE
	assume	es:R1_CODE					
	lea	di,es:[InstanceData]	; es:di -> data struc into which prev.
					; instance info. is to be copied
	mov	cx,MaxUMBInstObj	; maximum instance objects in UMBs
	call	cs:[CopyInstData]
;QLEO
;;	lea	ax,cs:[Win386Struc]
;QLEO
	popad

;
;  V86 disable
;
	call	CEMMoff			; turn CEMM off
	mov	cs:[Devname],'$'	; inactivate CEMM
;
;  Return to Windows
;
rWVDexit:
	clc
	ret
rWVDerror:
	stc
	ret
rWinVirDisable	endp

;==============================================================================
;==
;==  rWinVirEnable: This routine is called by Windows to enable V86 mode.
;==		    During V86 enable, CEMM will update its internal data
;==		    structures and page tables with information from the
;==		    EMM Global data structure.
;==		    This allows critical information to be received from
;==		    Windows during V86 enable.
;==
;==  Entry: (Real Mode)
;==	AX	= 1	Re-enable Virtual 8086 mode (from Real Mode)
;==
;==  Exit:  (V86 Mode)
;==
;==============================================================================
rWinVirEnable	proc	near

	test	cs:[Current_State],fState_Active;Q: Virtual Mode?
	jnz	rWVEerror	 		; Y: already on!

ifdef	MSFLAG
	bt	cs:[Current_State],fState_WinCntrlBit;Q: Waiting for Windows to exit?
else
	btr	cs:[Current_State],fState_WinCntrlBit;Q: Waiting for Windows to exit?
endif

	jnc	rWVEerror	 		     ; N: why this call?

;
;  The user stack is changed to the CEMM Real Stack
;
	mov	cs:[UserSS],ss
	mov	cs:[UserSP],sp
	push	seg R_STACK
	pop	ss
	lea	sp,R_STACK:RealStackTop

	call	ReInitDeb
;
;  The user's segment registers are pushed on the stack.
;
	push	gs
	push	fs
	push	es
	push	ds

	cli				;;; no ints now
	call	GoProtMode
	jc	short WINEMM_rExit

;
; The DS and GS selectors are set up.
;
	push	VDMD_GSEL
	pop	ds
	assume	ds:_DATA
	push	RCODEA_GSEL
	pop	gs
	assume	gs:R_CODE


;
;  Save CEMM real stack and change to protected mode stack
;
	mov	gs:[RealSS],ss
	mov	gs:[RealSP],sp
	push	VDMS_GSEL
	pop	ss
	mov	sp,gs:[StackTop]
;
; The function number is saved and the call done.
;
	PCall	VDMC_GSEL,_TEXT:UpdateInternalsFar
;
;  Restore CEMM real stack
;
	mov	ss,gs:[RealSS]
	mov	sp,gs:[RealSP]

	jc	short gotoreal			; error, don't turn on

	PCall	VDMC_GSEL,_TEXT:EnterVirtual
	call	GoVirtualMode

	jc	short WINEMM_rExit

	or	cs:[Current_State],fState_Active
	mov	cs:[Devname],'E'		     ; activate CEMM
	jmp	short WINEMM_rExit

gotoreal:

	call	GoRealMode
	mov	cs:[Devname],'$'		  ; inactivate CEMM
	and	cs:[Current_State],not fState_Active

	mov	dx,offset WINEMM_Mess		; Y: print out message
	mov	ah,9
	int	21h				; print message

WINEMM_rExit:

ifdef	MSFLAG
	and	cs:[Current_State], NOT fState_WinCntrl
endif

	pop	ds
	pop	es
	pop	fs
	pop	gs
;
;  Restore user stack
;
	mov	ss,cs:[UserSS]
	mov	sp,cs:[UserSP]

WINEMM_done:
	ret

WINEMM_error:
	stc
	ret

ifdef QLEO	; look into problems with switching to V86 mode???? QLEO
;
;  The user stack is changed to the CEMM Real Stack
;
	mov	cs:[UserSS],ss
	mov	cs:[UserSP],sp
	push	seg R_STACK
	pop	ss
	lea	sp,R_STACK:RealStackTop

	call	GoVirtual		;Q: Enter V86 mode
	jc	rWVPerrorX	 	; N: error
;
;  Restore user stack
;
	mov	ss,cs:[UserSS]
	mov	sp,cs:[UserSP]
;
;  Update internal with EMM Global Import data structure
;
	cli
	or	cs:[TrapFlags],fWinTrap ; dispatch to EMM Global Import
	int	ProtTrap		; enter protected mode
	jnc	short rWVPexit		; if no error, return to Windows

;
;  Error restoring EMM Global Import state: set carry
;
	mov	dx,offset WINEMM_Mess	; print out message
	mov	ah,9
	int	21h
	stc				; indicate error

;
;  Restore user stack
;
rWVPerrorX:
	mov	ss,cs:[UserSS]
	mov	sp,cs:[UserSP]
endif

;
;  Set carry due to error
;
rWVEerror:
	stc				; indicate error
	ret
rWinVirEnable	endp

;==============================================================================
;==
;==  CEMMoff: Procedure to turn CEMM off via diagnostic ports.
;==
;==  Entry: (V86 Mode)
;==
;==  Exit:  (Real Mode)
;==
;==============================================================================
CEMMoff	proc	near
	push	ax
	pushf
	cli
;
;  CEMM traps the following IOs and turns off
;
	mov	al,0Fh
	out	84h,al
	mov	al,00h
	out	85h,al
	jmp	$+2

	popf
	pop	ax
	ret
CEMMoff	endp


R_CODE	ends

;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
LAST	segment
	assume	cs:LAST,ds:nothing,es:nothing
;==============================================================================
;==
;==  VxDInit: Initialize Windows 386 VxD.
;==
;==  Entry: (Real Mode)
;==	GS	= R_CODE
;==	DS 	= _DATA
;==	R1_CODE has not been moved.
;==
;==  Exit:
;==
;==============================================================================
VxDInit proc	near

	push	eax
	push	ebx
	push	es
	
	push	fs
	
	mov	ax, seg R1_CODE		; R1_CODE seg not moved yet.
	mov	fs, ax
	assume	fs:R1_CODE
;
;  Place virtual device file name pointer
;
;;	mov	ax,fs
;;	shl	eax,16
;;	lea	ax,fs:[CEMMpath]
;;	mov	fs:[Win386Struc].WSSVxDFilePtr,eax
;
;  Place VxD reference data structure pointer
;
;;	xor	ax,ax
;;	shr	eax,12
;;	add	eax,offset gs:[Win386VxDRefDat]
;;	mov	gs:[Win386Struc].WSSVxDRefData,eax

	mov	eax, gs:[p_DATA]
	add	eax,offset [Win386VxDRefDat]
	mov	fs:[Win386Struc].WSSVxDRefData,eax

;
;  Now fill information for VxD in VxDRefDataStruct: start of device driver chain
;
	xor	eax,eax
	mov	ebx,eax
	mov	ah,52h		; get address of start of device driver chain
	int	21h
	mov	ax,es		; address of ES:[BX][22h]
	shl	eax,4
	add	eax,ebx
	add	eax,22h
	mov	ds:[Win386VxDRefDat].RDSDDchain,eax
;
;  Place instance data structure pointer
;
	xor	eax, eax
	mov	ax, fs
	shl	eax, 4
	add	eax, offset fs:[InstanceData]
	mov	ds:[Win386VxDRefDat].RDSdata,eax

	pop	fs
	pop	es
	pop	ebx
	pop	eax
	ret
VxDInit	endp

;==============================================================================
;==
;==  GetPathName: This procedure will get the path and name of the CEMM device
;==	      	  driver from the CONFIG.SYS buffer.
;==
;==  Entry: (Real Mode)
;==	ES:DI	= pointer to CONFIG.SYS line
;==	GS	= R_CODE
;==	R1_CODE has not been moved.
;==
;==  Exit:
;==
;==============================================================================
GetPathName	proc	near

	push	ax
	push	cx
	push	si
	push	di
	push	ds
	push	es
;
;  Move ES:DI to DS:SI and place R1_CODE:[CEMMpath] in ES:DI
;
	mov	ax,es
	mov	si,gs:[EMM_rFarEntry+2]
				; si = R1_CODE segment
	mov	ds,ax
	mov	es,si
	mov	si,di
	lea	di,R1_CODE:[CEMMpath]

	cld
	mov	cx,ConfigBuffer	; max length cannot be greater than 128 chars

	push	di		; save pointer to destination buffer

GPNnext:
	lodsb			; get a char from buffer
	cmp	al, 0dh		; Q: is it CR
	je	GPNfullname	; Y: try to get full name
	cmp	al, 0ah		; Q: is is LF
	je	GPNfullname	; Y: try to get full name
	cmp	al, ' '		; Q: is it a blank
	je	GPNfullname	; Y: try to get a full name
	cmp	al, 0		; M010: Q: is it a NULL
	je	GPNfullname	; M010: Y: try to get a full name
	stosb			; save char in destination buffer
	loop	GPNnext		; get next char

	;
	; We shall now make an attempt to get the full actual path of the
	; device by calling Int 21 function ah=60h.
	;
GPNfullname:
	mov	byte ptr es:[di], 0
				; M010: NULL terminate
	pop	di		; restore destination buffer pointer

	push	ax		; save last char obtained
	mov	byte ptr ds:[si-1], 0
				; terminate name with NULL
	sub	cx, ConfigBuffer+1		
	neg	cx		; cx = length of string
	sub	si, cx		; rewind si to start of string
	mov	ah, 060h	; call $nametrans (undocumented call)
	int	21h		; returns full path in es:di
				; Note: if this call returns it's not bad as
				; we already copied the device name into the
				; destination.
	pop	ax		; restore last char found in source string
	add	si, cx		; si pointing to end of name
	mov	byte ptr ds:[si-1], al
				; put last char back

GPNexit:
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	cx
	pop	ax
	ret
GetPathName	endp

;---------------------------------------------------------------------------
;
;	M010:
;
;	Procedure Name	: StorePath
;
;	Inputs		: DS:SI -> points to path spec
;	Output		: stores path in CEMMPath
;
;	Uses		: None
;
;---------------------------------------------------------------------------

StorePath	proc	near
	
	push	es
	push	di

	push	ds
	pop	es
	mov	di, si		; set es:di to path
	call	GetPathName

	pop	di
	pop	es
	ret

StorePath	endp
	
	
LAST	ends

	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\vminit.asm ===
.386p
page	58,132
;******************************************************************************
	title	VMINIT.ASM - Initialization routines for VM-DOS
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
;   Module:   VMINIT - Initialization routines for CEMM/ VDM
;
;   Version:  0.04
;
;   Date:     January 30, 1986
;
;   Author:   Caldwell Crosswy
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   01/30/86  Original
;   04/07/86  A-SBP	Added InitBitMap
;   05/12/86  B-RRH	Cleanup and segment reorganization
;   06/18/86  0.01	Re-arranged comments, etc.
;   06/28/86  0.02	Name change from CEMM386 to CEMM (SBP).
;   07/03/86  0.03	Added call to Kybd_Watch (SBP).
;   07/06/86  0.04	changed assume to _DATA (SBP).
;
;******************************************************************************
;
;   Functional Description:
;
;   This module contains various initialization routines for Virtual DOS
;
;******************************************************************************
.lfcond 				; list false conditionals
	page
;******************************************************************************
;			P U B L I C   D E C L A R A T I O N S
;******************************************************************************
;
;LEO	public	vminit			; module label
	public	InitBitMap		; init I/O Bit Map
	public	PortTrap		; set bit(s) in I/O Bit Map
	public	PortTrapFar
	public	PortClear		; clear bit(s) in I/O Bit Map
;LEO	public	BitOFF			; bit offset calculation
	page
;******************************************************************************
;			L O C A L   C O N S T A N T S
;******************************************************************************
;
	include VDMseg.inc
	include VDMsel.inc
	include desc.inc
	include dma.inc
	include	emmfunct.inc
	include	emmdata.inc

	page
;******************************************************************************
;			E X T E R N A L   R E F E R E N C E S
;******************************************************************************
;
ifdef TSSQLEO
TSS	segment
	extrn	IOBitMap:byte		; Bit Map in Tss
TSS	ends
endif

_TEXT	segment
	extrn	Kybd_Watch:near		; (a20trap.asm)
_TEXT	ends

;
;******************************************************************************
;			S E G M E N T	D E F I N I T I O N
;******************************************************************************
;
;------------------------------------------------------------------------------
_TEXT	segment
	assume	cs:_TEXT, ds:_DATA, es:_DATA, ss:_DATA
vminit	label	byte
	page
;******************************************************************************
;   InitBitMap - Initialize 386 Tss I/O bit map for Virtual mode I/O trapping.
;
;   ENTRY: Real Mode
;		DS = _DATA
;		I/O bit map all zeroes (no trapping) except last byte.
;   EXIT:  Real Mode
;		I/O bit map in Tss initialized.
;   USED:  Flags
;   STACK:
;------------------------------------------------------------------------------
InitBitMap	proc	far
;
	push	ax
	push	bx
	push	si
;TSSQLEO push	es
	push	gs
;
ifdef TSSQLEO
	mov	ax,seg TSS
	mov	es,ax			; set ES to I/O Bit Map seg
endif
	mov	ax,seg R_CODE
	mov	gs,ax
ifdef TSSQLEO
	ASSUME	ES:TSS,gs:R_CODE
	xor	bx,bx			; ES:[BX] = pts to TSS
;
; initialize BitMapBase in Tss
;
	mov	ax,offset TSS:IOBitMap
	mov	ES:[bx.BitMapBase],ax		; set Bit Map base in Tss
;
;  set ports for return to real trap
;
	mov	ax,84h
	call	BitOFF
	or	ES:IOBitMap[bx],al
	mov	ax,85h
	call	BitOFF
	or	ES:IOBitMap[bx],al
endif

;
;  initialize BitMapBase in Tss
;
	mov	[TSS][BitMapBase],IOBitMap	; set Bit Map base in Tss
;
;  set ports for return to real trap
;
	mov	ax,84h
	call	BitOFF
	add	bx,IOBitMap
	or	[TSS][bx],al
	mov	ax,85h
	call	BitOFF
	add	bx,IOBitMap
	or	[TSS][bx],al
;
;  Turn on Keyboard watching for A20 disable
;
	call	Kybd_Watch

IB_exit:
	pop	gs
;TSSQLEO pop	es
	ASSUME	ES:_DATA,gs:nothing
	pop	si
	pop	bx
	pop	ax
	ret				; *** RETURN ***
InitBitMap	endp

;******************************************************************************
;   PortTrap - sets bit(s) in I/O bit map to enable trapping at an I/O address
;
;	This function sets the appropriate bits in the I/O bit map to enable
;   trapping of the desired I/O address.  Since some I/O ports on the AT system
;   board are selected via only 10 bits of address lines, these ports appear
;   at every 1K in the I/O address space.  When trapping these "system board"
;   ports, the trap bits in the I/O bit map must be set for every 1k instance
;   of the port.
;
;   ENTRY: AX = byte I/O address to set in Bit Map
;	   BH = high bit set => set traps bits for this address @ every 1K
;TSSQLEO   ES = TSS
;
;   EXIT: none.
;
;   USED:  Flags
;   STACK:
;------------------------------------------------------------------------------
PortTrapFar	proc	far
	call	PortTrap
	retf
PortTrapFar	endp

PortTrap	proc	near
;
;TSSQLEO ASSUME	ES:TSS
	push	ax
	push	bx
	push	cx
;
	mov	cx,1			;   once by default
	test	bh,80h			;Q: map it every 1K ?
	jz	SHORT PT_loop		;  N: do it once
	mov	cx,64			;  Y: do it 64 times (once per 1k)
PT_loop:
	push	ax			;  map it. save this address
	call	BitOFF			; get offset and bit
	add	bx,IOBitMap
	or	[TSS][bx],al
;TSSQLEO or	ES:IOBitMap[bx],al	; trap this address
	pop	ax			; restore this address
	add	ax,400h			; add 1k for next address
	loop	PT_loop			; and continue ...
;
	pop	cx
	pop	bx
	pop	ax
	ret
	ASSUME	ES:_DATA
;
PortTrap	endp


;******************************************************************************
;   PortClear - clears bit(s) in I/O bit map to disable trapping at an I/O
;   address
;
;	This function clears the appropriate bits in the I/O bit map to disable
;   trapping of the desired I/O address.  Since some I/O ports on the AT system
;   board are selected via only 10 bits of address lines, these ports appear
;   at every 1K in the I/O address space.  When clearing these "system board"
;   ports, the trap bits in the I/O bit map must be cleared at every 1k instance
;   of the port.
;
;   ENTRY: AX = byte I/O address to clear in Bit Map
;	   BH = high bit set => clear traps bits for this address @ every 1K
;TSSQLEO   ES = data segment for I/O bit map
;
;   EXIT: none.
;
;   USED:  Flags
;   STACK:
;   NOTE:   This implementation does not account for a port being multiply set
;   for many purposes.	(ie. If a port is set 3 times, it still only takes one
;   PortClear call to clear it.)  If this is a problem, a counter for each
;   enabled port will have to be added.
;
;------------------------------------------------------------------------------
PortClear	proc	near
;
;TSSQLEO ASSUME	ES:TSS
	push	ax
	push	bx
	push	cx
;
	mov	cx,1			;   once by default
	test	bh,80h			;Q: map it every 1K ?
	jz	SHORT PC_loop 		;  N: do it once
	mov	cx,64			;  Y: do it 64 times (once per 1k)
PC_loop:
	push	ax			;  map it. save this address
	call	BitOFF			; get offset and bit
	not	al
	add	bx,IOBitMap
	and	[TSS][bx],al
;TSSQLEO and	ES:IOBitMap[bx],al	; clear this address
	pop	ax			; restore this address
	add	ax,400h 		; add 1k for next address
	loop	PC_loop 		; and continue ...
;
	pop	cx
	pop	bx
	pop	ax
	ret
	ASSUME	ES:_DATA
;
PortClear	endp


;******************************************************************************
;   BitOFF - sets up byte and bit for I/O address in I/O Bit Map
;
;   ENTRY: AX = byte I/O address to set in Bit Map
;
;   EXIT:  BX = byte offset
;	   AL = bit to OR in to set proper bit
;
;   USED:  Flags
;   STACK:
;------------------------------------------------------------------------------
BitOFF	proc	near
;
	push	cx

	mov	cx,ax
	and	cx,07h				; CL = bit pos for this port
	shr	ax,3				; AX = byte offset for this bit
	mov	bx,ax				; BX = byte offset for port
	mov	ax,1
	shl	ax,cl				; AL = bit mask for this port

	pop	cx
	ret
;
BitOFF	endp

;
_TEXT	ends				; end of segment
;
	end				; end of module

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\vminst.asm ===
.386p
page	58,132
;******************************************************************************
	title	VMINST.ASM - Virtual Mode GP fault instruction emulation
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;   (C) Copyright COMPAQ Computer Corp. 1986-1991
;
;   Title:    EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
;   Module:   VMINST.ASM - Virtual Mode GP fault instruction emulation
;
;   Version:  2.00
;
;   Date:     February 11, 1986
;
;   Author:	Caldwell Crosswy
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   02/12/86  Original
;   04/07/86  A-WCC	Added call to LIM emulation routines for all I/O.
;			Bit Map set up to trap only LIM related ports. SBP.
;   05/12/86  B-RRH	Cleanup and segment reorganization
;   05/18/86  C-RRH	Added VM privileged instruction emulation
;   06/08/86  D-SBP	Added calls to RRTrap.
;   06/14/86  E-RRH	Changed stack saves from BP, BX, SI to EBP, EBX, ESI
;   06/15/86  F-RRH	Changed inc [bp.VTFOE+VMTF_EIP] to inc SI in Prefix
;			Handlers
;   06/15/86  G-RRH	Added MOVSB and MOVSW for Rash Rule emulation
;   06/16/86  H-RRH	Added Error Handler interfaces, BugMode conditional
;			assembly constructs, and Error Handler return logic
;   06/19/86  0.01	Changed call JumpReal to jmp JumpReal (SBP)
;   06/19/86  0.01	Clear TF bit on all INT reflects, but not on emulations.
;   06/19/86  0.01	CLTS now does a clts for the VM client.
;   06/27/86  0.02	INT3 emulation now ALLWAYS reflects(SBP).
;   06/28/86  0.02	Name change from CEMM386 to CEMM (SBP).
;   07/01/86  0.03	Call to IO_Trap instead of LIM_Trap (SBP).
;   07/03/86  0.03	Let IO_Trap handle A20 and Return to real logic (SBP).
;   07/05/86  0.04	JumpReal in R_CODE (SBP).
;   07/06/86  0.04	changed assume to _DATA (SBP).
;   07/10/86  0.05	added MB_Flag check for move block emulator (SBP).
;   01/12/87  0.09	fixed EmHALT to check for user CLI (SBP).
;   05/18/87  2.00	Changed ErrHndlr calls to go to R_CODE (SBP).
;
;******************************************************************************
;
;   Functional Description:
;
;   This module contains the routines that handle GP faults fielded from
;   Virtual Mode.  The offending instruction is either emulated or we exit
;   to the debugger.
;
;   NOTE: The current implementation is sufficient for breadboard - see
;	'to do' notes in various header for holes.  Specifically, the only
;	override that is handled is REP, and only for INS/OUTS.  Segment
;	overrides are not yet supported.
;
;******************************************************************************
.lfcond 				; list false conditionals

page
;******************************************************************************
;			P U B L I C   D E C L A R A T I O N S
;******************************************************************************
;
	public	VmInst			; module label
	public	VmFault
	public	EmProtIns		; just for debug map
	public	EmMovCDTR		; just for debug map
	public	EmMOVSW 		; just for debug map
	public	BadVMTrap
;
;******************************************************************************
;			E X T E R N A L   R E F E R E N C E S
;******************************************************************************
;
ifdef BugMode
DCODE	segment

	extrn _Trap03:far		; INT 3 handler
	extrn _Trap04:far		; INTO handler
	extrn _Trap13:far		; general protection fault

DCODE	ends
endif

R1_CODE	segment
	extrn	ErrHndlr:far		; Handle user's error response
R1_CODE	ends

_TEXT	 segment
	extrn	IO_Trap:near		; I/O Trap Dispatcher
;LEO	extrn	PortClear:near		; IOBM trap clear function (VMINIT)
	extrn	ReflectInterrupt:near	; Interrupt reflection routine (PICTRAP)
_TEXT	 ends

_DATA	segment
	extrn	pLastVMTF:word
	extrn	LastVMTF:word
_DATA	ends

	page
;******************************************************************************
;			I N C L U D E	F I L E S
;******************************************************************************

include VDMseg.inc
include desc.inc
include VDMsel.inc
include vm386.inc
include oemdep.inc
include emm386.inc
include emmfunct.inc
include emmdata.inc

;******************************************************************************
;			L O C A L   C O N S T A N T S
;******************************************************************************
;

LOCK_PREFIX	equ	0F0h

;
; bit flags for instruction prefixes
;
REP_FLAG	equ	0001h
REPNE_FLAG	equ	0002h
REPS_FLAG	equ	(REP_FLAG or REPNE_FLAG)
CS_FLAG 	equ	0004h
DS_FLAG 	equ	0008h
ES_FLAG 	equ	0010h
SS_FLAG 	equ	0020h
FS_FLAG 	equ	0040h
GS_FLAG 	equ	0080h
LOCK_FLAG	equ	0100h
OPER_SZ_FLAG	equ	0200h
ADDR_SZ_FLAG	equ	0400h
P0F_FLAG	equ	0800h

page
;******************************************************************************
;			L O C A L   D A T A  A R E A
;******************************************************************************
_DATA	 segment

PrefixFlag	dw	0		; flags for Fault Instr Prefixes
RefNum		dw	0		; Reflect number for RefToRom

_DATA	 ends

page
;******************************************************************************
;			     C O D E	A R E A
;******************************************************************************
_TEXT	 segment
	assume	cs:_TEXT, ds:_DATA, es:_DATA, ss:_DATA

VMinst	label	word
;   Index table for opcode emulation dispatch - This is too general-purpose
;   if all we want to handle is INT instructions, but it'll get fleshed out
;   later, when we start emulating IOPL-sensitive stuff
;
OpTable label	word
	dw	offset _TEXT:BadVmTrap	 ;  0 - LLDT, LTR, SLDT, STR, VERR, VERW
	dw	offset _TEXT:EmProtIns	 ;  1 - LGDT, LIDT, LMSW
	dw	offset _TEXT:BadVmTrap	 ;  2 - LAR
	dw	offset _TEXT:BadVmTrap	 ;  3 - LSL
	dw	offset _TEXT:BadVmTrap	 ;  4
	dw	offset _TEXT:EmLoadal2	 ;  5 - 286Loadall
	dw	offset _TEXT:EmCLTS	 ;  6 - CLTS
	dw	offset _TEXT:EmLoadal3	 ;  7 - 386Loadall
	dw	offset _TEXT:BadVmTrap	 ;  8
	dw	offset _TEXT:BadVmTrap	 ;  9
	dw	offset _TEXT:BadVmTrap	 ;  a
	dw	offset _TEXT:BadVmTrap	 ;  b
	dw	offset _TEXT:BadVmTrap	 ;  c
	dw	offset _TEXT:BadVmTrap	 ;  d
	dw	offset _TEXT:BadVmTrap	 ;  e
	dw	offset _TEXT:Prefix_0F	 ;  f
	dw	offset _TEXT:BadVmTrap	 ; 10
	dw	offset _TEXT:BadVmTrap	 ; 11
	dw	offset _TEXT:BadVmTrap	 ; 12
	dw	offset _TEXT:BadVmTrap	 ; 13
	dw	offset _TEXT:BadVmTrap	 ; 14
	dw	offset _TEXT:BadVmTrap	 ; 15
	dw	offset _TEXT:BadVmTrap	 ; 16
	dw	offset _TEXT:BadVmTrap	 ; 17
	dw	offset _TEXT:BadVmTrap	 ; 18
	dw	offset _TEXT:BadVmTrap	 ; 19
	dw	offset _TEXT:BadVmTrap	 ; 1a
	dw	offset _TEXT:BadVmTrap	 ; 1b
	dw	offset _TEXT:BadVmTrap	 ; 1c
	dw	offset _TEXT:BadVmTrap	 ; 1d
	dw	offset _TEXT:BadVmTrap	 ; 1e
	dw	offset _TEXT:BadVmTrap	 ; 1f
	dw	offset _TEXT:EmMovCDTR	 ; 20 - Mov Rn, CRn
	dw	offset _TEXT:EmMovCDTR	 ; 21 - Mov Rn, DRn
	dw	offset _TEXT:EmMovCDTR	 ; 22 - Mov CRn, Rn
	dw	offset _TEXT:EmMovCDTR	 ; 23 - Mov DRn, Rn
	dw	offset _TEXT:EmMovCDTR	 ; 24 - Mov Rn, TRn
	dw	offset _TEXT:BadVmTrap	 ; 25
	dw	offset _TEXT:ESOverride  ; 26 - ES Override & Mov TRn, Rn
	dw	offset _TEXT:BadVmTrap	 ; 27
	dw	offset _TEXT:BadVmTrap	 ; 28
	dw	offset _TEXT:BadVmTrap	 ; 29
	dw	offset _TEXT:BadVmTrap	 ; 2a
	dw	offset _TEXT:BadVmTrap	 ; 2b
	dw	offset _TEXT:BadVmTrap	 ; 2c
	dw	offset _TEXT:BadVmTrap	 ; 2d
	dw	offset _TEXT:CSOverride  ; 2e - CS Override
	dw	offset _TEXT:BadVmTrap	 ; 2f
	dw	offset _TEXT:BadVmTrap	 ; 30
	dw	offset _TEXT:BadVmTrap	 ; 31
	dw	offset _TEXT:BadVmTrap	 ; 32
	dw	offset _TEXT:BadVmTrap	 ; 33
	dw	offset _TEXT:BadVmTrap	 ; 34
	dw	offset _TEXT:BadVmTrap	 ; 35
	dw	offset _TEXT:SSOverride  ; 36 - SS Override
	dw	offset _TEXT:BadVmTrap	 ; 37
	dw	offset _TEXT:BadVmTrap	 ; 38
	dw	offset _TEXT:BadVmTrap	 ; 39
	dw	offset _TEXT:BadVmTrap	 ; 3a
	dw	offset _TEXT:BadVmTrap	 ; 3b
	dw	offset _TEXT:BadVmTrap	 ; 3c
	dw	offset _TEXT:BadVmTrap	 ; 3d
	dw	offset _TEXT:DSOverride  ; 3e - DS Override
	dw	offset _TEXT:BadVmTrap	 ; 3f
	dw	offset _TEXT:BadVmTrap	 ; 40
	dw	offset _TEXT:BadVmTrap	 ; 41
	dw	offset _TEXT:BadVmTrap	 ; 42
	dw	offset _TEXT:BadVmTrap	 ; 43
	dw	offset _TEXT:BadVmTrap	 ; 44
	dw	offset _TEXT:BadVmTrap	 ; 45
	dw	offset _TEXT:BadVmTrap	 ; 46
	dw	offset _TEXT:BadVmTrap	 ; 47
	dw	offset _TEXT:BadVmTrap	 ; 48
	dw	offset _TEXT:BadVmTrap	 ; 49
	dw	offset _TEXT:BadVmTrap	 ; 4a
	dw	offset _TEXT:BadVmTrap	 ; 4b
	dw	offset _TEXT:BadVmTrap	 ; 4c
	dw	offset _TEXT:BadVmTrap	 ; 4d
	dw	offset _TEXT:BadVmTrap	 ; 4e
	dw	offset _TEXT:BadVmTrap	 ; 4f
	dw	offset _TEXT:BadVmTrap	 ; 50
	dw	offset _TEXT:BadVmTrap	 ; 51
	dw	offset _TEXT:BadVmTrap	 ; 52
	dw	offset _TEXT:BadVmTrap	 ; 53
	dw	offset _TEXT:BadVmTrap	 ; 54
	dw	offset _TEXT:BadVmTrap	 ; 55
	dw	offset _TEXT:BadVmTrap	 ; 56
	dw	offset _TEXT:BadVmTrap	 ; 57
	dw	offset _TEXT:BadVmTrap	 ; 58
	dw	offset _TEXT:BadVmTrap	 ; 59
	dw	offset _TEXT:BadVmTrap	 ; 5a
	dw	offset _TEXT:BadVmTrap	 ; 5b
	dw	offset _TEXT:BadVmTrap	 ; 5c
	dw	offset _TEXT:BadVmTrap	 ; 5d
	dw	offset _TEXT:BadVmTrap	 ; 5e
	dw	offset _TEXT:BadVmTrap	 ; 5f
	dw	offset _TEXT:BadVmTrap	 ; 60
	dw	offset _TEXT:BadVmTrap	 ; 61
	dw	offset _TEXT:BadVmTrap	 ; 62
	dw	offset _TEXT:ReturnEMM	 ; 63 - ARPL (return to Protected mode gateway)
	dw	offset _TEXT:FSOverride  ; 64 - FS override
	dw	offset _TEXT:GSOverride  ; 65 - GS override
	dw	offset _TEXT:BadVmTrap	 ; 66 - Operand size override
	dw	offset _TEXT:BadVmTrap	 ; 67 - Address size override
	dw	offset _TEXT:BadVmTrap	 ; 68
	dw	offset _TEXT:BadVmTrap	 ; 69
	dw	offset _TEXT:BadVmTrap	 ; 6a
	dw	offset _TEXT:BadVmTrap	 ; 6b
	dw	offset _TEXT:EmINSB	 ; 6c - INSB
	dw	offset _TEXT:EmINSW	 ; 6d - INSW
	dw	offset _TEXT:EmOUTSB	 ; 6e - OUTSB
	dw	offset _TEXT:EmOUTSW	 ; 6f - OUTSW
	dw	offset _TEXT:BadVmTrap	 ; 70
	dw	offset _TEXT:BadVmTrap	 ; 71
	dw	offset _TEXT:BadVmTrap	 ; 72
	dw	offset _TEXT:BadVmTrap	 ; 73
	dw	offset _TEXT:BadVmTrap	 ; 74
	dw	offset _TEXT:BadVmTrap	 ; 75
	dw	offset _TEXT:BadVmTrap	 ; 76
	dw	offset _TEXT:BadVmTrap	 ; 77
	dw	offset _TEXT:BadVmTrap	 ; 78
	dw	offset _TEXT:BadVmTrap	 ; 79
	dw	offset _TEXT:BadVmTrap	 ; 7a
	dw	offset _TEXT:BadVmTrap	 ; 7b
	dw	offset _TEXT:BadVmTrap	 ; 7c
	dw	offset _TEXT:BadVmTrap	 ; 7d
	dw	offset _TEXT:BadVmTrap	 ; 7e
	dw	offset _TEXT:BadVmTrap	 ; 7f
	dw	offset _TEXT:BadVmTrap	 ; 80
	dw	offset _TEXT:BadVmTrap	 ; 81
	dw	offset _TEXT:BadVmTrap	 ; 82
	dw	offset _TEXT:BadVmTrap	 ; 83
	dw	offset _TEXT:BadVmTrap	 ; 84
	dw	offset _TEXT:BadVmTrap	 ; 85
	dw	offset _TEXT:BadVmTrap	 ; 86
	dw	offset _TEXT:BadVmTrap	 ; 87
	dw	offset _TEXT:BadVmTrap	 ; 88
	dw	offset _TEXT:BadVmTrap	 ; 89
	dw	offset _TEXT:BadVmTrap	 ; 8a
	dw	offset _TEXT:BadVmTrap	 ; 8b
	dw	offset _TEXT:BadVmTrap	 ; 8c
	dw	offset _TEXT:BadVmTrap	 ; 8d
	dw	offset _TEXT:BadVmTrap	 ; 8e
	dw	offset _TEXT:BadVmTrap	 ; 8f
	dw	offset _TEXT:BadVmTrap	 ; 90
	dw	offset _TEXT:BadVmTrap	 ; 91
	dw	offset _TEXT:BadVmTrap	 ; 92
	dw	offset _TEXT:BadVmTrap	 ; 93
	dw	offset _TEXT:BadVmTrap	 ; 94
	dw	offset _TEXT:BadVmTrap	 ; 95
	dw	offset _TEXT:BadVmTrap	 ; 96
	dw	offset _TEXT:BadVmTrap	 ; 97
	dw	offset _TEXT:BadVmTrap	 ; 98
	dw	offset _TEXT:BadVmTrap	 ; 99
	dw	offset _TEXT:BadVmTrap	 ; 9a
	dw	offset _TEXT:BadVmTrap	 ; 9b
	dw	offset _TEXT:BadVmTrap	 ; 9c - PUSHF (not for IOPL=3)
	dw	offset _TEXT:BadVmTrap	 ; 9d - POPF (not for IOPL=3)
	dw	offset _TEXT:BadVmTrap	 ; 9e
	dw	offset _TEXT:BadVmTrap	 ; 9f
	dw	offset _TEXT:BadVmTrap	 ; a0
	dw	offset _TEXT:BadVmTrap	 ; a1
	dw	offset _TEXT:BadVmTrap	 ; a2
	dw	offset _TEXT:BadVmTrap	 ; a3
	dw	offset _TEXT:BadVmTrap	 ; a4 - MOVSB
	dw	offset _TEXT:EmMOVSW	 ; a5 - MOVSW
	dw	offset _TEXT:BadVmTrap	 ; a6
	dw	offset _TEXT:BadVmTrap	 ; a7
	dw	offset _TEXT:BadVmTrap	 ; a8
	dw	offset _TEXT:BadVmTrap	 ; a9
	dw	offset _TEXT:BadVmTrap	 ; aa
	dw	offset _TEXT:BadVmTrap	 ; ab
	dw	offset _TEXT:BadVmTrap	 ; ac
	dw	offset _TEXT:BadVmTrap	 ; ad
	dw	offset _TEXT:BadVmTrap	 ; ae
	dw	offset _TEXT:BadVmTrap	 ; af
	dw	offset _TEXT:BadVmTrap	 ; b0
	dw	offset _TEXT:BadVmTrap	 ; b1
	dw	offset _TEXT:BadVmTrap	 ; b2
	dw	offset _TEXT:BadVmTrap	 ; b3
	dw	offset _TEXT:BadVmTrap	 ; b4
	dw	offset _TEXT:BadVmTrap	 ; b5
	dw	offset _TEXT:BadVmTrap	 ; b6
	dw	offset _TEXT:BadVmTrap	 ; b7
	dw	offset _TEXT:BadVmTrap	 ; b8
	dw	offset _TEXT:BadVmTrap	 ; b9
	dw	offset _TEXT:BadVmTrap	 ; ba
	dw	offset _TEXT:BadVmTrap	 ; bb
	dw	offset _TEXT:BadVmTrap	 ; bc
	dw	offset _TEXT:BadVmTrap	 ; bd
	dw	offset _TEXT:BadVmTrap	 ; be
	dw	offset _TEXT:BadVmTrap	 ; bf
	dw	offset _TEXT:BadVmTrap	 ; c0
	dw	offset _TEXT:BadVmTrap	 ; c1
	dw	offset _TEXT:BadVmTrap	 ; c2
	dw	offset _TEXT:BadVmTrap	 ; c3
	dw	offset _TEXT:BadVmTrap	 ; c4
	dw	offset _TEXT:BadVmTrap	 ; c5
	dw	offset _TEXT:BadVmTrap	 ; c6
	dw	offset _TEXT:BadVmTrap	 ; c7
	dw	offset _TEXT:BadVmTrap	 ; c8
	dw	offset _TEXT:BadVmTrap	 ; c9
	dw	offset _TEXT:BadVmTrap	 ; ca
	dw	offset _TEXT:BadVmTrap	 ; cb
	dw	offset _TEXT:EmINT3	 ; cc - INT 3
	dw	offset _TEXT:EmINTnn	 ; cd - INT nn
	dw	offset _TEXT:EmINTO	 ; ce - INTO
	dw	offset _TEXT:BadVmTrap	 ; cf - IRET/EmIRET (not for IOPL=3)
	dw	offset _TEXT:BadVmTrap	 ; d0
	dw	offset _TEXT:BadVmTrap	 ; d1
	dw	offset _TEXT:BadVmTrap	 ; d2
	dw	offset _TEXT:BadVmTrap	 ; d3
	dw	offset _TEXT:BadVmTrap	 ; d4
	dw	offset _TEXT:BadVmTrap	 ; d5
	dw	offset _TEXT:BadVmTrap	 ; d6
	dw	offset _TEXT:BadVmTrap	 ; d7
	dw	offset _TEXT:BadVmTrap	 ; d8
	dw	offset _TEXT:BadVmTrap	 ; d9
	dw	offset _TEXT:BadVmTrap	 ; da
	dw	offset _TEXT:BadVmTrap	 ; db
	dw	offset _TEXT:BadVmTrap	 ; dc
	dw	offset _TEXT:BadVmTrap	 ; dd
	dw	offset _TEXT:BadVmTrap	 ; de
	dw	offset _TEXT:BadVmTrap	 ; df
	dw	offset _TEXT:BadVmTrap	 ; e0
	dw	offset _TEXT:BadVmTrap	 ; e1
	dw	offset _TEXT:BadVmTrap	 ; e2
	dw	offset _TEXT:BadVmTrap	 ; e3
	dw	offset _TEXT:EmINBimm	 ; e4 - INB imm
	dw	offset _TEXT:EmINWimm	 ; e5 - INW imm
	dw	offset _TEXT:EmOUTBimm	 ; e6 - OUTB imm
	dw	offset _TEXT:EmOUTWimm	 ; e7 - OUTW imm
	dw	offset _TEXT:BadVmTrap	 ; e8
	dw	offset _TEXT:BadVmTrap	 ; e9
	dw	offset _TEXT:BadVmTrap	 ; ea
	dw	offset _TEXT:BadVmTrap	 ; eb
	dw	offset _TEXT:EmINB	 ; ec - INB
	dw	offset _TEXT:EmINW	 ; ed - INW
	dw	offset _TEXT:EmOUTB	 ; ee - OUTB
	dw	offset _TEXT:EmOUTW	 ; ef - OUTW
	dw	offset _TEXT:EmLOCK	 ; f0 - LOCK
	dw	offset _TEXT:BadVmTrap	 ; f1
	dw	offset _TEXT:EmREPNE	 ; f2 - REPNE
	dw	offset _TEXT:EmREP	 ; f3 - REP/REPE
	dw	offset _TEXT:EmHALT	 ; f4 - HLT
	dw	offset _TEXT:BadVmTrap	 ; f5
	dw	offset _TEXT:BadVmTrap	 ; f6
	dw	offset _TEXT:BadVmTrap	 ; f7
	dw	offset _TEXT:BadVmTrap	 ; f8
	dw	offset _TEXT:BadVmTrap	 ; f9
	dw	offset _TEXT:BadVmTrap	 ; fa - CLI EmCLI (not for IOPL=3)
	dw	offset _TEXT:BadVmTrap	 ; fb - STI EmSTI (not for IOPL=3)
	dw	offset _TEXT:BadVmTrap	 ; fc
	dw	offset _TEXT:BadVmTrap	 ; fd
	dw	offset _TEXT:BadVmTrap	 ; fe
	dw	offset _TEXT:BadVmTrap	 ; ff - Change P0F_Invalid, if used

	page
;******************************************************************************
;   VmFault - entry point for Virtual Mode GP faults (from routine vm_trap0d
;	in module VMTRAP.ASM).	The appropriate instructions are emulated and
;	control is returned to the Virtual Mode client.  Currently, we assume
;	the client is running WITH IOPL, INT gate DPL = 0, and a truncated
;	IDT, so INT instruction fault to here and are emulated.  All other
;	GP faults enter the debugger.
;
;   The following instructions are invalid in Real or Virtual Mode:
;
;	ARPL, LAR, LSL, VERR, VERW, STR, LTR, SLDT, LLDT
;
;   The following instructions are privileged and are thus invalid in
;   Virtual Mode since VM progs run at CPL 3:
;
;	LIDT, LDGT, LMSW, CLTS, HLT, Debug Register ops, Control
;	Register ops, and Test Register ops
;
;   If client does not have IOPL, the following instructions must be handled
;   (in addition to the INT instructions).  This scenario changes for B0:
;
;	IN, INS, OUT, OUTS, STI, CLI, LOCK, PUSHF, POPF, and IRET
;
;   For B0, the following instructions must be handled when they trap
;   according to the bit map in the TSS.
;
;	IN, INS, OUT, and OUTS
;
;   For Invalid Opcode (vm_trap06) emulation:
;   The following instructions are invalid in Real or Virtual Mode:
;
;	LTR, LLDT, LAR, LSL, ARPL, STR, SLDT, VERR, VERW
;
;   In fielding the exception from Virtual Mode, the 386 interrupt gate
;   switched to the Ring 0 stack and pushed 32-bit values as follows:
;
;	 hiword loword	offset (in addition to error code and BP push)
;	+------+------+ <-------- Top of 'kernel' stack
;	| 0000 |  GS  |  +32 (decimal)
;	|------+------|
;	| 0000 |  FS  |  +28
;	|------|------|
;	| 0000 |  DS  |  +24
;	|------|------|
;	| 0000 |  ES  |  +20
;	|------|------|
;	| 0000 |  SS  |  +16
;	|------|------|
;	|     ESP     |  +12
;	|------|------|
;	|    EFLAGS   |  +08
;	|------|------|
;	| 0000 |  CS  |  +04
;	|------|------|
;	|     EIP     |  +00
;	+------|------+
;	| error code  |
;	|------|------| <-------- Ring 0 SS:SP
;	|    (ebp)    |
;	+------+------+ <-------- Ring 0 SS:EBP
;
;
;   ENTRY:  386 Protected Mode - ring 0
;	    EBP is on the stack
;	    SS:BP -> VM trap frame on stack w/error code (faulting selector)
;	    GP exceptions are faults: pushed CS:EIP points to faulting opcode
;   EXIT:   via IRET to VM client, instruction emulated as necessary
;   USED:   (none) (note that DS & ES are free to use - saved during trap)
;   STACK:  n/a
;------------------------------------------------------------------------------
VmFault proc	near
	push	ebx			; local registers
	push	esi
	mov	bx,GDTD_GSEL		; get GDT data alias
	mov	ds,bx			; DS -> GDT
;
;   Build a selector (VM1_GSEL) to client's stack.  VM1_GSEL is already set
;   up with limit (0FFFFh) and access (D_DATA0), so just fill in the base.
;
	mov	bx,[bp.VTFOE+VMTF_SS]	; BX = VM SS (segment form)
	shl	bx,4			; BX = low 16 bits of base
	mov	ds:[VM1_GSEL+2],bx	; place in descriptor
	mov	bx,[bp.VTFOE+VMTF_SS]	; BX = VM SS (again)
	shr	bx,4			; BH = high 8 bits of base
	mov	ds:[VM1_GSEL+4],bh	; place in descriptor
;
;   Build a selector (VM2_GSEL) to client's code segment, as above.
;
	mov	bx,[bp.VTFOE+VMTF_CS]	; BX = VM CS (in segment form)
	shl	bx,4			; BX = low 16 bits of base
	mov	ds:[VM2_GSEL+2],bx	; place in descriptor
	mov	bx,[bp.VTFOE+VMTF_CS]	; BX = VM CS (again)
	shr	bx,4			; BH = high 8 bits of base
	mov	ds:[VM2_GSEL+4],bh	; place in descriptor
;
;   Reset prefix flags
;
	mov	bx,VDMD_GSEL
	mov	es,bx
	mov	ES:[PrefixFlag],0	; start with no prefixes
;
;   Jump to appropriate instruction handler
;
	mov	bx,VM2_GSEL
	mov	ds,bx			; DS = selector for VM code segment
	mov	si,[bp.VTFOE+VMTF_EIP]	; DS:SI = VM CS:IP
VmInsHandle:
	mov	bl,ds:[si]		; BL = opcode
	mov	bh,0			; BX = opcode
	shl	bx,1			; BX = BX*2 (word table)
					; DS:SI = VM CS:IP
					; ES pts to local data segment
					; VM1_GSEL pts to VM SS
					; VM2_GSEL pts to VM CS
	jmp	cs:OpTable[bx]		; enter instruction emulation routine

VmFault endp

page
;******************************************************************************
;   BadVmTrap - unsupported Virtual Mode GP exception - enter the debugger
;
;   ENTRY:  EBP,EBX,ESI are on the stack
;   EXIT:   to the debugger
;   USED:
;   STACK:  n/a
;------------------------------------------------------------------------------
BadVmTrap	proc	near

	jmp	Reflect6		; Reflect to VM illegal opcode handler

ifdef QLEO
ifndef	BugMode
	jmp	Reflect6		; Reflect to VM illegal opcode handler
else
	pop	esi 			;  clean up the stack,
	pop	ebx
	pop	ebp
	db	0EAh			; far jump opcode
	dw	offset DCODE:_trap13	; offset
	dw	DEBC_GSEL		; selector
endif
endif

BadVmTrap	endp

;******************************************************************************
;   ReturnEMM - user is trying to go back into the protected mode via ARPL
;
;   ENTRY:  EBP,EBX,ESI are on the stack
;   EXIT:   to the debugger
;   USED:
;   STACK:  n/a
;
;	Code ported from EMM386 for PS2 support.
;
;------------------------------------------------------------------------------
ReturnEMM	proc	far
;
; We assume that only EMM can go back to protected mode and therefore
; hardwired this code to go to R_CODE.
; It could use some data checking (by making sure that DS is actually
; pointing to R_CODE) or be more general (by building a new GDT selector
; which is a code selector and contains the faulting code's segment
; and push this instead of RCODE_GSEL)
;
	add	si, 2			; "IP" now points to instruction
					;   after "ARPL reg,reg"
	push	RCODE_GSEL		; push faulting code's CS
	push	si			; push faulting code's IP
	retf				; back to faulting code in protected mode!
ReturnEMM	endp

page
;******************************************************************************
;   EmINTnn - emulate software interrupt
;
;   The emulation of the software INT instructions requires us to massage
;   the trap stack frame (see VmFault header) and build a 'real mode'
;   stack frame for the virtual mode client so that we can transfer
;   control to virtual mode at the address specified in the appropriate
;   real mode IDT vector.  The client's IRET out of the interrupt routine
;   will proceed normally (assuming we're letting him run with IOPL = 3).
;   Since we're fielding the trap from Virtual Mode, we assume the high
;   word of ESP and EIP is 0000.
;
;	+-------+ <-------- Client's current SS:SP
;	| Flags |  +4
;	|-------|
;	|  CS	|  +2
;	|-------|
;	|  IP	|  +0
;	+-------+ <-------- Client's SS:SP when we let him have control
;
;   ENTRY:  386 Protected Mode
;	    EBP,EBX,ESI pushed on stack
;	    VM1_GSEL = VM client's stack segment
;	    VM2_GSEL = VM client's code segment
;	    DS:SI -> faulting opcode = CD nn  (DS = VM2_GSEL)
;   EXIT:   via IRET to VM client
;	    appropriate real mode IRET set up @ client's SS:SP
;   USED:   (none)
;   STACK:
;
;   to do:  Streamline this code - it's on the critical path
;	    Decide about how to handle Trace Bit in general
;------------------------------------------------------------------------------
EmINTnn proc	near

	inc	si			; DS:SI -> nn (int #)

;   Adjust client's SP to make room for building his IRET frame
;
	sub	word ptr [bp.VTFOE+VMTF_ESP],6	; adjust client's SP
	mov	bx,VM1_GSEL
	mov	ds,bx			; DS = VM stack segment
	mov	si,[bp.VTFOE+VMTF_ESP]	; DS:SI -> client's IRET stack frame
;
;   Move low 16 bits of Flags, CS, and EIP from IRET frame to client stack frame
;
	mov	bx,[bp.VTFOE+VMTF_EFLAGS] ; low word of EFLAGS
;
; *** Clear IF bit on flags for reflect, but leave it unchanged for the
;	flags on the IRET stack we build on the client's stack
; *** Also clear the Trace Flag -> because all software INTs clear the trace
;      flag.
;
	and	[bp.VTFOE+VMTF_EFLAGS],not (FLAGS_IF OR FLAGS_TF)

	mov	ds:[si.4],bx		; to client's flags
	mov	bx,[bp.VTFOE+VMTF_CS]	;
	mov	ds:[si.2],bx		; to client's CS
	mov	bx,[bp.VTFOE+VMTF_EIP]	; low word of EIP
	add	bx,2			; set IP past the instruction we emulate
	mov	ds:[si.0],bx		; to client's IP
;
;   Replace low 16 bits of IRET frame CS:EIP with vector from real mode IDT
;
	mov	si,VM2_GSEL
	mov	ds,si			; DS -> Client's code segment
	mov	bl,ds:[bx-1]		; get INTerrupt number
	xor	bh,bh			; BX has INT number
	shl	bx,2			; BX = BX * 4 (vector table index)
	mov	si,RM_IDT_GSEL		; get real mode IDT alias
	mov	ds,si			; DS -> Real Mode IDT
	mov	esi,ds:[bx]		;QLEO
;QLEO	mov	si,ds:[bx]		;
	mov	[bp.VTFOE+VMTF_EIP],si	; move the IP
	shr	esi,16			;QLEO
;QLEO	mov	si,ds:[bx+2]		;
	mov	[bp.VTFOE+VMTF_CS],si	; move the CS
;
;   32-bit IRET back to client
;
EmExit:
EmSkipLockExit: 			; as the label implies...
	pop	esi 			; restore local regs
	pop	ebx
	pop	ebp
	add	sp,4			; throw away error code
	iretd			; *** RETURN *** to client
EmINTnn endp

page
;******************************************************************************
;   EmINT3 - emulate the 'breakpoint' interrupt instruction
;
;   ENTRY:  386 Protected Mode
;	    EBP,EBX,ESI pushed on stack
;	    VM1_GSEL = VM client's stack segment
;	    VM2_GSEL = VM client's code segment
;	    DS:SI -> faulting opcode = CD nn  (DS = VM2_GSEL)
;   EXIT:   via IRET to VM client
;	    appropriate real mode IRET set up @ client's SS:SP
;   USED:   (none)
;   STACK:
;
;   to do:  implement the handler
;------------------------------------------------------------------------------
EmINT3	proc	near
	mov	ES:[RefNum], 03h	    ; Vector to VM int 3 handler
RefIntN:
	inc	si			    ; fault, not a trap
	mov	[bp.VTFOE+VMTF_EIP], si     ; point beyond int3
	jmp	RefToRom		    ; and let the VM OS handle it
EmINT3	endp

;******************************************************************************
;   EmINTO - emulate overflow interrupt
;
;   ENTRY:  386 Protected Mode
;	    EBP,EBX,ESI pushed on stack
;	    VM1_GSEL = VM client's stack segment
;	    VM2_GSEL = VM client's code segment
;	    DS:SI -> faulting opcode = CD nn  (DS = VM2_GSEL)
;   EXIT:   via IRET to VM client
;	    appropriate real mode IRET set up @ client's SS:SP
;   USED:   (none)
;   STACK:
;------------------------------------------------------------------------------
EmINTO	proc	near
ifndef	BugMode
	mov	ES:[RefNum], 04h	    ; Vector to VM int 3 handler
	jmp	RefIntN
else
	inc	si			; fault, not a trap
	mov	[bp.VTFOE+VMTF_EIP],si	; set IP past the instruction we emulate
	pop	esi 			;  clean up the stack,
	pop	ebx
	pop	ebp
	add	sp,4			; throw away error code
	db	0EAh			; far jump opcode
	dw	offset DCODE:_trap04	; offset
	dw	DEBC_GSEL		; selector
endif
EmINTO	endp

page
;******************************************************************************
;   EmINB - emulate the IN byte instruction
;
;   ENTRY:  386 Protected Mode
;	    EBP,EBX,ESI pushed on stack
;	    VM1_GSEL = VM client's stack segment
;	    VM2_GSEL = VM client's code segment
;	    DS:SI -> faulting opcode =	nn  (DS = VM2_GSEL)
;   EXIT:   via IRET to VM client
;   USED:
;   STACK:  n/a
;------------------------------------------------------------------------------
EmINB	proc	near
	inc	si
	mov	[bp.VTFOE+VMTF_EIP],si	; set IP past the instruction we emulate
	push	bx
	xor	bx,bx			; IN instruction
	call	IO_Trap 		; Q: Emulated ?
	jnc	SHORT EINB_Exit		;   Y: exit
	in	al,dx			;   N:do the INput
EINB_Exit:
	pop	bx
	jmp	EmExit			; *** RETURN *** to VM client
EmINB	endp

page
;******************************************************************************
;   EmINW - emulate IN word
;
;	This routine emulates the IN word instruction
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	IRET back to VM program
;------------------------------------------------------------------------------
EmINW	proc	near
	inc	si
	mov	[bp.VTFOE+VMTF_EIP],si	; set IP past the instruction we emulate
	push	bx
	xor	bx,bx			; IN instruction
	call	IO_Trap 		; Q: Emulated ?
	cbw				; AX= returned value
	jnc	SHORT EINW_Exit		;   Y: exit
	in	ax,dx			;   N:do the word INput
EINW_Exit:				;
	pop	bx			;
	jmp	EmExit			; *** RETURN *** to VM client
EmINW	endp

page
;******************************************************************************
;   EmINBimm - emulate IN word immediate
;
;	This routine emulates the IN word immediate instruction
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	IRET back to VM program
;------------------------------------------------------------------------------
EmINBimm	proc	near
	push	bx
	push	dx
	mov	dl,ds:[si+1]		; get port number
	xor	dh,dh			; DX has INT number
	add	si, 2
	mov	[bp.VTFOE+VMTF_EIP],si	; set IP past the instruction we emulate
	xor	bx,bx			; IN instruction
	call	IO_Trap 		; Q: Emulated ?
	jnc	SHORT EINBi_Exit	;   Y: exit
	in	al,dx			;   N:do the INput
EINBi_exit:
	pop	dx
	pop	bx
	jmp	EmExit			; *** RETURN *** to VM client
EmINBimm	endp

page
;******************************************************************************
;***	EmINWimm - emulate IN word immediate
;
;	This routine emulates the IN word immediate instruction
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	IRET back to VM program
;------------------------------------------------------------------------------
EmINWimm	proc	near
	push	bx
	push	dx
	mov	dl,ds:[si+1]		; get port number
	xor	dh,dh			; DX has INT number
	add	si, 2
	mov	[bp.VTFOE+VMTF_EIP],si	; set IP past the instruction we emulate
	xor	bx,bx			; IN instruction
	call	IO_Trap 		; Q: Emulated ?
	cbw				; AX = returned value
	jnc	SHORT EINWi_Exit	;   Y: exit
	in	ax,dx			;   N:do the word INput
EINWi_Exit:
	pop	dx
	pop	bx
	jmp	EmExit			; *** RETURN *** to VM client
EmINWimm	endp

page
;******************************************************************************
;***	EmOUTB - emulate OUT byte
;
;	This routine emulates the OUT byte instruction
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	IRET back to VM program
;
EmOUTB	proc	near
	inc	si
	mov	[bp.VTFOE+VMTF_EIP],si	; set IP past the instruction we emulate
	push	bx
	push	dx
	mov	bx,1			; OUT instruction
	call	IO_Trap 		; Q: Emulated ?
	jnc	SHORT EOUTB_Exit	;  Y:exit
EOUTB_em:
	out	dx,al			;      N:do the byte OUTput
EOUTB_Exit:
	pop	dx
	pop	bx
	jmp	EmExit			; *** RETURN *** to VM client
EmOUTB	endp

page
;******************************************************************************
;***	EmOUTW - emulate OUT word
;
;	This routine emulates the OUT word instruction
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	IRET back to VM program
;
EmOUTW	proc	near
	inc	si
	mov	[bp.VTFOE+VMTF_EIP],si	; set IP past the instruction we emulate
	push	bx
	mov	bx,1			; OUT instruction
	call	IO_Trap 		; Q: Emulated ?
	jnc	SHORT EOUTW_Exit	;   Y: exit
					;   N:
	out	dx,ax			; do the word OUTput
EOUTW_Exit:
	pop	bx
	jmp	EmExit			; *** RETURN *** to VM client
EmOUTW	endp

page
;******************************************************************************
;***	EmOUTBimm - emulate OUT byte immediate
;
;	This routine emulates the OUT byte immediate
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	IRET back to VM program
;
EmOUTBimm	proc	near
	push	bx
	push	dx
	mov	dl,ds:[si+1]		; get port number
	xor	dh,dh			; DX has INT number
	add	si, 2
	mov	[bp.VTFOE+VMTF_EIP],si	; set IP past the instruction we emulate
	mov	bx,1			; OUT instruction
	call	IO_Trap 		; Q: Emulated ?
	jnc	SHORT EOUTBi_Exit	;   Y:exit
EOUTBi_em:
	out	dx,al			;      N:do the byte OUTput
EOUTBi_Exit:
	pop	dx
	pop	bx
	jmp	EmExit			; *** RETURN *** to VM client
EmOUTBimm	endp

page
;******************************************************************************
;***	EmOUTWimm - emulate OUT word immediate
;
;	This routine emulates the OUT word immediate instruction
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	IRET back to VM program
;
EmOUTWimm	proc	near
	push	bx
	push	dx
	mov	dl,ds:[si+1]		; get port number
	xor	dh,dh			; DX has INT number
	add	si, 2
	mov	[bp.VTFOE+VMTF_EIP],si	; set IP past the instruction we emulate
	mov	bx,1			; OUT instruction
	call	IO_Trap 		; Q: Emulated ?
	jnc	SHORT EOUTWi_Exit	;   Y: exit
	out	dx,ax			;   N:do the word OUTput
EOUTWi_Exit:
	pop	dx
	pop	bx
	jmp	EmExit			; *** RETURN *** to VM client
EmOUTWimm	endp
page
;******************************************************************************
;***	EmHALT - Emulate HALT command
;
;	This routine is entered if a faulting instruction
;	is a HALT command
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	return to VM client
;		if the user's flags => CLI, then do a CLI,HLT
;		else, skip the instruction
;
EmHALT	proc	near

ifdef QLEO
	test	[bp.VTFOE+VMTF_EFLAGS],FLAGS_IF ;Q: user flags => CLI ?
	jnz	SHORT EmH_skip			;  N: just skip hlt
	cli					;  Y: do the CLI,HLT
	hlt

EmH_skip:
	inc	si				; inc VM CS:IP past command
	mov	[bp.VTFOE+VMTF_EIP], si 	;  we emulate
	jmp	EmExit				; and leave
endif
;
; Need to return to instruction follwing HLT
;
	inc	si				; inc VM CS:IP past HLT command
	mov	[bp.VTFOE+VMTF_EIP], si
;
; Check if client had interrupts on/off
;
	test	[bp][VTFOE].VMTF_EFLAGS,FLAGS_IF;Q: HLT with CLI?
	jz	short EmHhlt			; Y: HLT with CLI

;
; Set up the stack so that preflectinterrupt can handle this case.
; Also indicate in Genglags to preflectinterrupt.
;
	push	ds
	push	RCODEA_GSEL
	pop	ds
	assume	ds:R_CODE
	or	ds:[GenFlags],fEMMhlt
	pop	ds
	assume	ds:_DATA

	pop	esi 			; restore local regs
	pop	ebx
	pop	ebp
	add	sp,4			; throw away error code
	push	ebp			; put ebp on top of error code

	sti				; HLT with STI
EmHhlt:
	hlt

;##### NOTE WE WILL NOT COME HERE IF STI HLT IS EXECUTED ######

	cli					; clear interrupts
	jmp	EmExit				; and leave
EmHALT	endp

page
;******************************************************************************
;***	EmLoadal2 - Emulate 286 Loadall command
;
;	This routine is entered if a faulting instruction
;	is a Loadall 286 command
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	return to VM client
;
EmLoadal2  proc    near

	jmp	BadVmTrap		    ;  N: Vector to VM illegal opcode
EmLoadal2  endp

;******************************************************************************
;***	EmLoadal3 - Emulate 386 Loadall command
;
;	This routine is entered if a faulting instruction
;	is a Loadall 386 command
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	return to VM client
;
EmLoadal3  proc    near

	jmp	BadVmTrap		    ;  N: Vector to VM illegal opcode
EmLoadal3  endp

;******************************************************************************
;   EmCLTS - emulate the CLTS instruction
;
;   ENTRY:  386 Protected Mode
;	    EBP,EBX,ESI pushed on stack
;	    VM1_GSEL = VM client's stack segment
;	    VM2_GSEL = VM client's code segment
;	    DS:SI -> faulting opcode =	nn  (DS = VM2_GSEL)
;   EXIT:   via IRET to VM client
;   USED:
;   STACK:  n/a
;------------------------------------------------------------------------------
EmCLTS	proc	near

	test	ES:[PrefixFlag],P0F_FLAG
	jz	SHORT Not_CLTS
	clts					; go ahead and CLTS
	inc	si				; inc VM CS:IP past command
	mov	[bp.VTFOE+VMTF_EIP], si 	;  we emulate
	jmp	EmExit				; and leave

Not_CLTS:
	jmp	BadVmTrap

EmCLTS	endp

;******************************************************************************
;   EmProtIns - emulate the protection control instructions
;   Currently this throws LIDT and LGDT to the error handler and only emulates
;   LMSW
;   NOTE:  The Stack configuration is critical!!!  If it is changed, the
;   offsets to the register images must be updated accordingly.
;   (RRH)
;
;   ENTRY:  386 Protected Mode
;	    EBP,EBX,ESI pushed on stack
;	    VM1_GSEL = VM client's stack segment
;	    VM2_GSEL = VM client's code segment
;	    DS:SI -> faulting opcode =	nn  (DS = VM2_GSEL)
;   EXIT:   via IRET to VM client
;	    bp.VTFOE+VMTF_EIP points beyond offender to next client instruction
;	    VM2_GSEL, DS, and SI may be modified at exit, this should not be a
;	    problem for the IRET
;   USED:
;   STACK:  n/a
;------------------------------------------------------------------------------
EmProtIns proc	  near

	test	ES:[PrefixFlag],P0F_FLAG
	jnz	SHORT EmPI1
	jmp	Not_ProtIns1
EmPI1:
	push	dx
	push	ax
	push	es
	mov	dx, ES:[PrefixFlag]
	mov	bx,VDMCA_GSEL		; Load CODE (writeable) alias
	mov	es, bx
	assume	es:_TEXT
	inc	si			; set si past the opcode
	mov	bl,[si] 		; BL = modR/M
	mov	bh, bl			; BH = modR/M
	and	bl, 38h
	cmp	bl, 30h
	je	SHORT EmLMSW		; Emulate LMSW
	cmp	bl, 18h
	jne	SHORT LGDTerr 		; VM guy not allowed to LGDT
	mov	bx, ErrLIDT
	jmp	ExitPIer		; VM guy not allowed to LIDT
LGDTerr:
	mov	bx, ErrLGDT
	jmp	ExitPIer
EmLMSW:
	inc	si			; set SI past the modR/M
	mov	[bp.VTFOE+VMTF_EIP],si	; VM CS:IP = DS:SI
	mov	bl, bh			; BL = modR/M
	cmp	bl, 0C0h		; is MSW being loaded from a register?
	JAE	MoveReg 		; Y: go do a register move

MoveData:
;   Because of all the possible addressing modes this is pretty nasty.	Like
;   MoveReg, it is complicated by the requirement to not clear the PE bit.
;   The general approach is to find the client's data value, put it in AX,
;   set the PE bit in AX, then load the MSW from AX.  To keep from having
;   to know about all the modR/M combinations, we yank the client's possible
;   offset from his code, and put his slightly modified modR/M byte in our
;   home-made MOV AX, MemData instruction.

;   If there is a data offset, yank it from the VM instruction and put it
;   in our instruction.

	and	bl, 0C7h		; Force AX to be the MOV destination
	mov	byte ptr es:[LMSWmod],bl
	mov	ax, 09090h
	mov	word ptr es:[LMSWoff],ax ; initialize offset to NOPS
	cmp	bl, 06h 		; special case for DS:d16
	je	SHORT load16off
	and	bl, 0C0h
	cmp	bl, 040h
	je	SHORT load8off
	cmp	bl, 080h
	jne	SHORT BldDesc 		; No data offset, so go build desc
Load16off:
	mov	ax,[si] 		; AX = 16 bit offset
	mov	word ptr es:[LMSWoff],ax
	add	si, 2
	mov	[bp.VTFOE+VMTF_EIP],si	; VM CS:IP = DS:SI
	jmp	SHORT BldDesc
Load8off:
	mov	al,[si] 		; AL = 8 bit offset
	mov	byte ptr es:[LMSWoff],al
	inc	si
	mov	[bp.VTFOE+VMTF_EIP],si	; VM CS:IP = DS:SI

BldDesc:
;   Build a descriptor to the client's data segment

	mov	bl, bh
	mov	ax, [bp.VTFOE+VMTF_DS]	; Assume DS is the data segment

;   Check for segment override
	and	dx, 00FCh		; strip all but segment overrides
	cmp	dx, CS_FLAG
	jl	SHORT GetmodBase	; no override, check base
	je	SHORT CS_data
	cmp	dx, ES_FLAG
	je	SHORT ES_data
	jl	SHORT GetSel		; ds is override
	cmp	dx, FS_FLAG
	jl	SHORT SS_data
	je	SHORT FS_data
GS_data:
	mov	ax, [bp.VTFOE+VMTF_GS]	; GS is the data segment
	jmp	SHORT GetSel
FS_data:
	mov	ax, [bp.VTFOE+VMTF_FS]	; FS is the data segment
	jmp	SHORT GetSel
SS_data:
	mov	ax, VM1_GSEL
	mov	ds, ax
	jmp	SHORT RestoreRegs
CS_data:
	mov	ax, VM2_GSEL
	mov	ds, ax
	jmp	SHORT RestoreRegs
ES_data:
	mov	ax, [bp.VTFOE+VMTF_ES]	; ES is the data segment
	jmp	SHORT GetSel

GetmodBase:
;   We have no Segment override, so we need to look at the modR/M byte to
;   see whether or not the data index/offset is based on DS (assumed) or SS
	and	bl, 0C7h		; clear instruction bits
	cmp	bl, 46h
	je	SS_Data 		; EA = SS:[BP+d8]
	and	bl, 7
	cmp	bl, 2
	je	SS_Data 		; EA = SS:[BP+SI+?]
	cmp	bl, 3
	je	SS_Data 		; EA = SS:[BP+DI+?]

GetSel:
;   Build a selector (VM2_GSEL) to client's data.  VM2_GSEL is already set
;   up with limit (0FFFFh) and access (D_DATA0), so just fill in the base.
;   The Descriptor base VM segment value is in AX
	push	es
	push	bx
	mov	bx,GDTD_GSEL		; get GDT data alias
	mov	es,bx			; DS -> GDT
	mov	bx, ax			; copy the VM data segment value
	shl	ax,4			; BX = low 16 bits of base
	mov	es:[VM2_GSEL+2],ax	; place in descriptor
	shr	bx,4			; BH = high 8 bits of base
	mov	es:[VM2_GSEL+4],bh	; place in descriptor
	mov	ax, VM2_GSEL
	mov	ds, ax
	pop	bx
	pop	es

RestoreRegs:
;   Since BX, SI, DI, and BP can all be used to form an effective address we
;   blindly restore BX, SI, and BP from the stack so that we don't
;   have to know what the instruction is using for its effective address.
;   DI does not need to be restored, because it should still be the client's

	push	bp
	mov	bp, sp

;   Now the Stack had better look like PROT_INS_FRAME. (vm386.inc)
	mov	si, [bp.PIF_ESI]
	mov	bx, [bp.PIF_EBX]
	mov	bp, [bp.PIF_EBP]

;   Move the VM data operand to AX
	db	3Eh			; ds overide (for bp & di)
	db	8Bh			; MOV opcode
LMSWmod db	00h			; modR/M
LMSWoff db	90h, 90h		; possible offset (NOPS otherwise)

	jmp	SHORT ExLMSW		; Finally... go do the LMSW

MoveReg:
;   Here we have a LMSW from one of the general registers.  This is pretty
;   ugly because many of the possible registers the client might have used
;   are currently saved on the stack.  It is also complicated by the
;   requirement to not clear the PE bit.  The general approach is to find
;   the client's register value/image, put it in AX, set the PE bit in AX,
;   then load the MSW from AX.	To keep from having to know all the modR/M
;   combinations, we again use a slightly modified client's modR/M byte in
;   our home-made MOV AX, RegData instruction.

	push	bp
	mov	bp, sp

;   Now the Stack had better look like PROT_INS_FRAME. (vm386.inc)

	and	bh, 07h 		; If Src is AX, it hasn't been changed
	jz	SHORT ExLMSW		; so just go do the the LMSW
CkSrcBX:				; otherwise, find it and move it to AX
	cmp	bh, 3
	jne	SHORT CkSrcBP
	mov	ax, [bp.PIF_EBX]	; src was BX, get from stack
	jmp	SHORT ExLMSW
CkSrcBP:
	cmp	bh, 5
	jne	SHORT CkSrcSI
	mov	ax, [bp.PIF_EBP]	; src was BP, get from stack
	jmp	SHORT ExLMSW
CkSrcSI:
	cmp	bh, 6
	jne	SHORT CkSrcDX
	mov	ax, [bp.PIF_ESI]	; src was SI, get from stack
	jmp	SHORT ExLMSW
CkSrcDX:
	cmp	bh, 2
	jne	SHORT CkSrcSP
	mov	ax, [bp.PIF_DX] 	; src was DX, get from stack
	jmp	SHORT ExLMSW
CkSrcSP:
	cmp	bh, 4
	jne	SHORT GetReg
	mov	ax, [bp.PIF_VMESP]	; src was SP, get from stack
	jmp	SHORT ExLMSW
GetReg:
	or	bh, 0C0h		; set register to register move bits
	mov	es:[Lmod], bh		; setup move from client's src register
	jmp	SHORT GetRn		; clear prefetch so that bh gets there
GetRn:
;   Execute MOV AX, Rn
	db	08Bh
Lmod	db	0C0h

;   Finally Execute the LMSW
ExLMSW:

;   At this point we could check for the PE bit and notify the user that
;   he must switch to real mode... but because an old app might do a SMSW,
;   which copies the PE bit (?!!), then set a bit in that image and do a LMSW,
;   (not caring about the PE bit), we just let it go... under the assumption
;   that if he really were trying to enter Protected mode, he would have
;   failed trying to LIDT and LGDT.

	or	ax, 0001h		;  N: we want to stay in Prot mode
	LMSW	ax			; So we must set it (use BTS above)

	pop	bp
	pop	es
	assume	es:_DATA
	pop	ax
	pop	dx
	jmp	EmExit			; *** RETURN *** to VM client

ExitPIer:
	pop	es
	assume	es:_DATA
	pop	ax
	pop	dx
	mov	[bp+4],bx	; save minor error # over error code
	pop	esi
	pop	ebx
	pushad		; -> entry condition for ErrHndlr

ifndef	BugMode
	mov	bx,[bp+4]		; restore minor error #
	mov	ax, PrivErr
	PJmp	R1CODE_GSEL, R1_CODE:ErrHndlr
else
	popad
	push	ebx
	push	esi
	jmp	BadVmTrap
endif

Not_ProtIns1:
	jmp	BadVmTrap

EmProtIns endp

;******************************************************************************
;   EmMovCDTR - emulate the - MOV Rn, C/D/TRn & MOV C/D/TRn, Rn - instructions
;     This is done by copying the MOV instruction from the VM to our
;     code and then executing it.  If CR0 is being stored, the PE
;     bit is masked clear before completing the instruction.  Execution speed
;     should not be critical for these instructions, so I have lumped them
;     all together to save memory that can be better used for more time
;     critical emulations.
;     NOTE:  The Stack configuration is critical!!!  If it is changed, the
;     offsets to the register images must be updated accordingly.
;     (RRH)
;     Also NOTE: The TR register opcodes have been removed from the legal 0F
;     prefix list, (P0F_OpTab(x)), and the EmMovCDTR address removed from their
;     opcode table ,(OpTable), vectors, so that they don't come here anymore.
;
;   ENTRY:  386 Protected Mode
;	    EBP,EBX,ESI pushed on stack
;	    VM1_GSEL = VM client's stack segment
;	    VM2_GSEL = VM client's code segment
;	    DS:SI -> faulting opcode =	nn  (DS = VM2_GSEL)
;   EXIT:   via IRET to VM client
;	    bp.VTFOE+VMTF_EIP points beyond offender to next client instruction
;   USED:
;   STACK:  n/a
;------------------------------------------------------------------------------
EmMovCDTR proc	  near

	test	ES:[PrefixFlag],P0F_FLAG
	JZ	Not_MovCDTR		; Didn't come from a 0F prefix

MovCDTR1:
	push	eax
	push	es
	mov	bx,VDMCA_GSEL		; Load CODE (writeable) alias
	mov	es, bx
	assume	es:_TEXT
	mov	bl,[si] 		; BL = opcode
	mov	es:[CDTRopc], bl
	inc	si			; set SI past the opcode
	mov	bl,[si] 		; BL = modR/M
	mov	bh, bl			; Copy modR/M
	and	bl, 0F8h		; For control, we reroute move thru AX
	mov	es:[CDTRmod], bl
	inc	si			; set SI past the modR/M
	mov	[bp.VTFOE+VMTF_EIP],si	; VM CS:IP = DS:SI

	push	bp
	mov	bp, sp

;   Now the Stack had better look like MOV_CDTR_FRAME. (vm386.inc)

	mov	bl, es:[CDTRopc]	; load opcode
	cmp	bl, 024h		; Check TRn load/store
	jb	SHORT NotTRErr		; N: continue
	mov	bx, ErrMovTR		; Y: go flag error
	jmp	CTRErr

NotTRErr:
	and	bh, 7			; strip all but src reg bits
	cmp	bh, 0
	je	SHORT ExCDTR		; reg is AX, so just do move

	cmp	bl, 020h		; Check CRn store
	je	SHORT ExCDTR1 		; Y: go do it
	cmp	bl, 021h		; Check DRn store
	je	SHORT ExCDTR1 		; Y: go do it

ChkSrcBX:
	cmp	bh, 3
	jne	SHORT ChkSrcBP
	mov	eax,dword ptr [bp.MCF_EBX]	; mov EBX from stack
	jmp	SHORT ExCDTR
ChkSrcBP:
	cmp	bh, 5
	jne	SHORT ChkSrcSI
	mov	eax,dword ptr [bp.MCF_EBP]	; mov EBP from stack
	jmp	SHORT ExCDTR
ChkSrcSI:
	cmp	bh, 6
	jne	SHORT ChkSrcSP
	mov	eax,dword ptr [bp.MCF_ESI]	; mov ESI from stack
	jmp	SHORT ExCDTR
ChkSrcSP:
	cmp	bh, 4
	jne	SHORT GetFmReg
	mov	eax,dword ptr [bp.MCF_VMESP]	; mov ESP from stack
	jmp	SHORT ExCDTR
GetFmReg:
	or	bh, 0C0h		; set register to register move bits
	mov	es:[CDTRreg], bh	; setup move from client's src register
	jmp	SHORT GetERn		; clear prefetch so that bh gets there
GetERn:
;   Execute MOV EAX, ERn
	db	66h
	db	08Bh
CDTRreg db	0C0h

ExCDTR:
	cmp	bl, 022h		; Check CRn load
	jne	SHORT FltrDRL3		; N: destination not CRn
	cmp	byte ptr es:[CDTRmod], 0C0h ; Check for CR0 load
	je	SHORT CR0FltrL		; Y: filter it
	mov	bx, ErrMovCR
	jmp	CTRErr			; N: go tell user he did a NoNo
FltrDRL3:
	cmp	byte ptr es:[CDTRmod], 0C3h ; Check for DR0-3 load
	ja	SHORT FltrGDbit		; N: continue
	jmp	SHORT ExCDTR1		;  linear map, then continue
FltrGDbit:
	cmp	byte ptr es:[CDTRmod], 0C7h ; Check for DR7 load
	jne	SHORT ExCDTR1 		; N: continue
	and	ax, 0DFFFh		; Y: don't let client set the GD bit
	jmp	SHORT ExCDTR1		; continue

;   For the reason below, we don't bug the user about setting the PE bit
;   through LMSW.  To be consistent, and because the client would die
;   in his attmept to LGDT or Mov CR3,Reg before this, we let him go here
;   also.
;   LMSW Reason:
;   At this point we could check for the PE bit and notify the user that
;   he must switch to real mode... but because an old app might do a SMSW,
;   which copies the PE bit (?!!), then set a bit in that image and do a LMSW,
;   (not caring about the PE bit), we just let it go... under the assumption
;   that if he really were trying to enter Protected mode, he would have
;   failed trying to LIDT and LGDT.

CR0FltrL:
	or	eax,80000001h		; set PE bit
					; and PG bit if they weren't
ExCDTR1:
;   Execute MOV CDTRn, EAX  (Finally!)
	db	0Fh
CDTRopc db	020h
CDTRmod db	0C0h

;   The special register move has now been executed, but we altered it to
;   use AX.  If the move was a load, we are done. If it was a store to one of
;   the registers on the stack, we need to stuff the register's stack image,
;   otherwise we need to move AX to the proper register.

	cmp	bl, 022h		; Check CRn load
	je	SHORT Exit_MovCDTR	; Y: we're done
	cmp	bl, 023h		; Check DRn load
	je	SHORT Exit_MovCDTR	; Y: we're done
FltrDRS3:
NotDRS3:
	cmp	bl, 020h		; Check CRn store
	jne	short ChkDstBX		; N: source not CRn
	cmp	byte ptr es:[CDTRmod], 0C0h ; Check for CR0 store
	je	short CR0FltrS		; Y: filter it
	cmp	byte ptr es:[CDTRmod],0	; Check for CR0 store		;QLEO
	je	short CR0FltrS		; Y: filter it			;QLEO
	jmp	short ChkDstBX		; N: check if store was on EBX	;QLEO
;QLEO	jmp	short Exit_MovCDTR	; N: we're done			;QLEO
;QLEO	mov	bx, ErrMovCR
;QLEO	jmp	SHORT CTRErr		; N: go tell user he did a NoNo

;   Because SMSW shows the PE bit, we let it go through here also
CR0FltrS:
	and	eax,7FFFFFFFh		; Y: clear
					; PG bit if it was set
ChkDstBX:
	cmp	bh, 3
	jne	SHORT ChkDstBP
	mov	dword ptr [bp.MCF_EBX],eax	; mov EBX to stack
	jmp	SHORT Exit_MovCDTR
ChkDstBP:
	cmp	bh, 5
	jne	SHORT ChkDstSI
	mov	dword ptr [bp.MCF_EBP],eax	; mov EBP to stack
	jmp	SHORT Exit_MovCDTR
ChkDstSI:
	cmp	bh, 6
	jne	SHORT ChkDstAX
	mov	dword ptr [bp.MCF_ESI],eax	; mov ESI to stack
	jmp	SHORT Exit_MovCDTR
ChkDstAX:
	cmp	bh, 0
	jne	SHORT ChkDstSP
	mov	dword ptr [bp.MCF_EAX],eax	; mov EAX to stack
	jmp	SHORT Exit_MovCDTR	;   at exit
ChkDstSP:
	cmp	bh, 4
	jne	SHORT PutInReg
	mov	dword ptr [bp.MCF_VMESP],eax	  ; mov ESP to stack
	jmp	SHORT Exit_MovCDTR	;   at exit
PutInReg:
;   Execute MOV ERn, EAX
	or	bh, 0C0h		; set register to register move bits
	mov	es:[regCDTR], bh	; setup load to client's dest register
	jmp	SHORT PutERn		; clear prefetch so that bh gets there
PutERn:
	db	66h
	db	089h
regCDTR db	0C0h


Exit_MovCDTR:
	pop	bp
	pop	es
	assume	es:_DATA
	pop	eax
	jmp	EmExit			; *** RETURN *** to VM client
CTRErr:
	pop	bp
	sub	[bp.VTFOE+VMTF_EIP],3	; VM CS:IP = faulting instruction
	pop	es
	assume	es:_DATA

	mov	[bp+4],bx	; save minor error # over error code
	pop	eax
	pop	esi
	pop	ebx
	pushad		; -> entry condition for ErrHndlr

ifndef	BugMode
	mov	bx,[bp+4]		; restore minor error #
	mov	ax, PrivErr
	PJmp	R1CODE_GSEL, R1_CODE:ErrHndlr
else
	popad
	push	ebx
	push	esi
	jmp	BadVmTrap
endif

Not_MovCDTR:
	jmp	BadVmTrap

EmMovCDTR endp

;******************************************************************************
;***	EmLOCK - Emulate LOCK prefix
;
;	This routine is entered if a faulting instruction
;	is a LOCK prefix.
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	xfer on to handler for next opcode
;
EmLOCK	proc	near

	inc	si				; set IP past the
	mov	[bp.VTFOE+VMTF_EIP], si 	; instruction we emulate
	jmp	EmExit				; and leave

EmLOCK	endp

;******************************************************************************
;***	EmREPNE - handle REPNE prefix
;
;	We come here if the trapping instruction has
;	a REPNE prefix. We just pass it on to the handler
;	for the next opcode.
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	IRET back to VM program
;
EmREPNE proc	near

	or	ES:[PrefixFlag],REPNE_FLAG	; set appropriate flag
	inc	si				; inc VM CS:IP past prefix
	jmp	VmInsHandle			; handle next part of instr

EmREPNE endp

;***	EmREP - handle REP prefix
;
;	We come here if the trapping instruction has
;	a REP or REPE prefix. We just pass it on to the handler
;	for the next opcode.
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	IRET back to VM program
;
EmREP	proc	near

	or	ES:[PrefixFlag],REP_FLAG	; set appropriate flag
	inc	si				; inc VM CS:IP past prefix
	jmp	VmInsHandle			; handle next part of instr

EmREP	endp

;******************************************************************************
;***	Prefix_0F - handle 0F overrides
;
;	This routine is entered if an instruction begins with a 0F prefix.
;	  It checks the current opcode against a table of valid 0F-opcodes,
;	  and if the opcode is valid, it indexes back into OpTable to jump
;	  to the proper opcode handler.
;	  (NOTE: This scheme works fine as long as the valid 0F-opcodes
;	    continue to have low values allowing this P0F_OpTabx to stay
;	    relatively small.  If this changes, we probably should go back
;	    to using the P0F_OpTab scheme.)
;
;	ENTRY:	386 Protected Mode
;	    EBP,EBX,ESI pushed on stack
;	    VM1_GSEL = VM client's stack segment
;	    VM2_GSEL = VM client's code segment
;	    DS:SI -> faulting prefix =	nn  (DS = VM2_GSEL)
;	EXIT	xfer directly to handler for next opcode
;
;***
P0F_Invalid equ     0FFh    ; OpTable vector offset to BadVmTrap

P0F_OpTabx  label   byte
	db  00h 	    ; 00h - LLDT, LTR, SLDT, STR, VERR, VERW
	db  02h 	    ; 01h - LIDT, LGDT, LMSW
	db  04h 	    ; 02h - LAR
	db  06h 	    ; 03h - LSL
	db  P0F_Invalid     ; 04h - BadVmTrap
	db  0Ah 	    ; 05h - 286 Loadall
	db  0Ch 	    ; 06h - CLTS
	db  0Eh 	    ; 07h - 386 Loadall
	db  P0F_Invalid     ; 08h - BadVmTrap
	db  P0F_Invalid     ; 09h - BadVmTrap
	db  P0F_Invalid     ; 0Ah - BadVmTrap
	db  P0F_Invalid     ; 0Bh - BadVmTrap
	db  P0F_Invalid     ; 0Ch - BadVmTrap
	db  P0F_Invalid     ; 0Dh - BadVmTrap
	db  P0F_Invalid     ; 0Eh - BadVmTrap
	db  P0F_Invalid     ; 0Fh - BadVmTrap
	db  P0F_Invalid     ; 10h - BadVmTrap
	db  P0F_Invalid     ; 11h - BadVmTrap
	db  P0F_Invalid     ; 12h - BadVmTrap
	db  P0F_Invalid     ; 13h - BadVmTrap
	db  P0F_Invalid     ; 14h - BadVmTrap
	db  P0F_Invalid     ; 15h - BadVmTrap
	db  P0F_Invalid     ; 16h - BadVmTrap
	db  P0F_Invalid     ; 17h - BadVmTrap
	db  P0F_Invalid     ; 18h - BadVmTrap
	db  P0F_Invalid     ; 19h - BadVmTrap
	db  P0F_Invalid     ; 1Ah - BadVmTrap
	db  P0F_Invalid     ; 1Bh - BadVmTrap
	db  P0F_Invalid     ; 1Ch - BadVmTrap
	db  P0F_Invalid     ; 1Dh - BadVmTrap
	db  P0F_Invalid     ; 1Eh - BadVmTrap
	db  P0F_Invalid     ; 1Fh - BadVmTrap
	db  40h 	    ; 20h - CR moves
	db  42h 	    ; 21h - DR moves
	db  44h 	    ; 22h - CR moves
	db  46h 	    ; 23h - DR moves
	db  48h 	    ; 24h - TR moves
	db  P0F_Invalid     ; 25h - BadVmTrap
	db  4Ch 	    ; 26h - TR moves
P0F_OpTabx_Size equ $-P0F_OpTabx

;***
Prefix_0F	proc	near
	inc	si			    ; inc DS:SI past prefix
	mov	bl,[si] 		    ; BL = opcode
	cmp	bl, P0F_OpTabx_Size
	jae	SHORT Bad_0F
	mov	bh,0			    ; BX = opcode
	mov	bl, cs:P0F_OpTabx[bx]
	cmp	bl, P0F_Invalid
	je	SHORT Bad_0F
	or	es:[PrefixFlag],P0F_FLAG    ; set appropriate flag
	jmp	cs:OpTable[bx]		    ; enter instr emulation routine

Bad_0F:
	jmp	BadVmTrap

Prefix_0F	endp

;******************************************************************************
;***	CSOverride - handle CS overrides
;
;	This routine is entered if a faulting instruction
;	has a CS override.
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	xfer on to handler for next opcode
;
CSOverride	proc	near

	or	ES:[PrefixFlag],CS_FLAG 	; set appropriate flag
	inc	si				; inc VM CS:IP past prefix
	jmp	VmInsHandle			; handle next part of instr

CSOverride	endp

;******************************************************************************
;***	DSOverride - handle DS overrides
;
;	This routine is entered if a faulting instruction
;	has a DS override.
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	xfer on to handler for next opcode
;
DSOverride	proc	near

	or	ES:[PrefixFlag],DS_FLAG 	; set appropriate flag
	inc	si				; inc VM CS:IP past prefix
	jmp	VmInsHandle			; handle next part of instr

DSOverride	endp

;******************************************************************************
;***	ESOverride - handle ES overrides
;
;	This routine is entered if a faulting instruction
;	has a ES override or a MOV TRn, Rn opcode
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	xfer on to handler for next opcode
;

ESOverride	proc	near

	test	ES:[PrefixFlag],P0F_FLAG	; only for TR emulation
	jz	SHORT ESO1			; only for TR emulation
	jmp	EmMovCDTR			; only for TR emulation
ESO1:
	or	ES:[PrefixFlag],ES_FLAG 	; set appropriate flag
	inc	si				; inc VM CS:IP past prefix
	jmp	VmInsHandle			; handle next part of instr

ESOverride	endp

;******************************************************************************
;***	SSOverride - handle SS overrides
;
;	This routine is entered if a faulting instruction
;	has a SS override.
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	xfer on to handler for next opcode
;

SSOverride	proc	near

	or	ES:[PrefixFlag],SS_FLAG 	; set appropriate flag
	inc	si				; inc VM CS:IP past prefix
	jmp	VmInsHandle			; handle next part of instr

SSOverride	endp

;******************************************************************************
;***	FSOverride - handle FS overrides
;
;	This routine is entered if a faulting instruction
;	has a FS override.
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	xfer on to handler for next opcode
;

FSOverride	proc	near

	or	ES:[PrefixFlag],FS_FLAG 	; set appropriate flag
	inc	si				; inc VM CS:IP past prefix
	jmp	VmInsHandle			; handle next part of instr

FSOverride	endp

;******************************************************************************
;***	GSOverride - handle GS overrides
;
;	This routine is entered if a faulting instruction
;	has a GS override.
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	xfer on to handler for next opcode
;

GSOverride	proc	near

	or	ES:[PrefixFlag],GS_FLAG 	; set appropriate flag
	inc	si				; inc VM CS:IP past prefix
	jmp	VmInsHandle			; handle next part of instr

GSOverride	endp

;******************************************************************************
;***	EmINSB - emulate IN byte string
;
;	This routine emulates the IN byte string instruction
;		*** this routine emulates REP instructions entirely	***
;		*** within protected mode.  This effectively masks out	***
;		*** interupts between bytes in the operation, even	***
;		*** if the VM code had interrupts on.			***
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	IRET back to VM program
;
;	USES	ES,BX,DI
;

EmINSB	proc	near
;
	inc	si			; set IP past the
	mov	[bp.VTFOE+VMTF_EIP], si ; instruction we emulate
;
;
;   Build a selector (VM1_GSEL) to client's ES segment.  VM1_GSEL is already set
;   up with limit (0FFFFh) and access (D_DATA0), so just fill in the base.
;
	mov	bx,GDTD_GSEL
	mov	ds,bx			; DS = GDT selector
	mov	bx,[bp.VTFOE+VMTF_ES]	; BX = VM ES (segment form)
	shl	bx,4			; BX = low 16 bits of base
	mov	ds:[VM1_GSEL+2],bx	; place in descriptor
	mov	bx,[bp.VTFOE+VMTF_ES]	; BX = VM ES (again)
	shr	bx,4			; BH = high 8 bits of base
	mov	ds:[VM1_GSEL+4],bh	; place in descriptor
	mov	bx,VM1_GSEL
	test	ES:[PrefixFlag],REP_FLAG	;Q: REP prefix active ?
	mov	es,bx				; ES = VM ES
	jnz	SHORT EINSB_loop		;  Y: go do rep instruction
	insb					;  N: do single instruction
	jmp	SHORT EINSB_exit			;     and leave
EINSB_loop:
	cld					; assume cld
	mov	bx,FLAGS_DF
	test	bx,word ptr [bp.VTFOE+VMTF_EFLAGS] ;Q: client's DF bit is CLD?
	jz	SHORT EINSB_rep			;  Y: go ahead
	std					;  N: set it
EINSB_rep:
	rep insb				;   rep version

EINSB_Exit:			;
	jmp	EmExit		; *** RETURN *** to VM client
;
EmINSB	endp


;******************************************************************************
;***	EmINSW - emulate IN word string
;
;	This routine emulates the IN word string instruction
;		*** this routine emulates REP instructions entirely	***
;		*** within protected mode.  This effectively masks out	***
;		*** interupts between bytes in the operation, even	***
;		*** if the VM code had interrupts on.			***
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	IRET back to VM program
;
;	USES	ES,BX,DI
;

EmINSW	proc	near
;
	inc	si			; set IP past the
	mov	[bp.VTFOE+VMTF_EIP], si ; instruction we emulate
;
;
;
;   Build a selector (VM1_GSEL) to client's ES segment.  VM1_GSEL is already set
;   up with limit (0FFFFh) and access (D_DATA0), so just fill in the base.
;
	mov	bx,GDTD_GSEL
	mov	ds,bx			; DS = GDT selector
	mov	bx,[bp.VTFOE+VMTF_ES]	; BX = VM ES (segment form)
	shl	bx,4			; BX = low 16 bits of base
	mov	ds:[VM1_GSEL+2],bx	; place in descriptor
	mov	bx,[bp.VTFOE+VMTF_ES]	; BX = VM ES (again)
	shr	bx,4			; BH = high 8 bits of base
	mov	ds:[VM1_GSEL+4],bh	; place in descriptor
	mov	bx,VM1_GSEL
	test	ES:[PrefixFlag],REP_FLAG	;Q: REP prefix active ?
	mov	es,bx				; ES = VM ES
	jnz	SHORT EINSW_loop		;  Y: go do rep instruction
	insw					;  N: do single instruction
	jmp	SHORT EINSW_exit		;     and leave
EINSW_loop:
	cld					; assume cld
	mov	bx,FLAGS_DF
	test	bx,word ptr [bp.VTFOE+VMTF_EFLAGS] ;Q: client's DF bit is CLD?
	jz	SHORT EINSW_rep			;  Y: go ahead
	std					;  N: set it
EINSW_rep:
	rep insw				;   rep version

EINSW_Exit:			;
	jmp	EmExit		; *** RETURN *** to VM client
;
EmINSW	endp


;******************************************************************************
;***	EmOUTSB - emulate OUT byte string
;
;	This routine emulates the OUT byte string instruction
;		*** this routine emulates REP instructions entirely	***
;		*** within protected mode.  This effectively masks out	***
;		*** interupts between bytes in the operation, even	***
;		*** if the VM code had interrupts on.			***
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	IRET back to VM program
;
;	USES	DS,BX,SI
;

EmOUTSB proc	near
;
	inc	si			; set IP past the
	mov	[bp.VTFOE+VMTF_EIP], si ; instruction we emulate
;
;   restore SI
;
	pop	si
	push	si
;
;   Build a selector (VM1_GSEL) to client's DS segment.  VM1_GSEL is already set
;   up with limit (0FFFFh) and access (D_DATA0), so just fill in the base.
;
	mov	bx,GDTD_GSEL
	mov	ds,bx			; DS = GDT selector
	mov	bx,[bp.VTFOE+VMTF_DS]	; BX = VM DS (segment form)
	shl	bx,4			; BX = low 16 bits of base
	mov	ds:[VM1_GSEL+2],bx	; place in descriptor
	mov	bx,[bp.VTFOE+VMTF_DS]	; BX = VM DS (again)
	shr	bx,4			; BH = high 8 bits of base
	mov	ds:[VM1_GSEL+4],bh	; place in descriptor
	mov	bx,VM1_GSEL
	mov	ds,bx			; DS = VM DS

	test	ES:[PrefixFlag],REP_FLAG ;Q: REP prefix active ?
	jnz	SHORT EOUTSB_loop		;  Y: go do rep instruction
	outsb					;  N: do single instruction
	jmp	SHORT EOUTSB_exit		;     and leave
EOUTSB_loop:
	cld					; assume cld
	mov	bx,FLAGS_DF
	test	bx,word ptr [bp.VTFOE+VMTF_EFLAGS] ;Q: client's DF bit is CLD?
	jz	SHORT EOUTSB_rep		;  Y: go ahead
	std					;  N: set it
EOUTSB_rep:
	rep outsb				;   rep version

EOUTSB_Exit:			;
	jmp	EmExit		; *** RETURN *** to VM client
;
EmOUTSB endp


;******************************************************************************
;***	EmOUTSW - emulate OUT word string
;
;	This routine emulates the OUT word string instruction
;		*** this routine emulates REP instructions entirely	***
;		*** within protected mode.  This effectively masks out	***
;		*** interupts between bytes in the operation, even	***
;		*** if the VM code had interrupts on.			***
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	IRET back to VM program
;
;	USES	DS,BX,SI
;

EmOUTSW proc	near
;
	inc	si			; set IP past the
	mov	[bp.VTFOE+VMTF_EIP], si ; instruction we emulate
;
;   restore SI
;
	pop	si
	push	si
;
;
;   Build a selector (VM1_GSEL) to client's DS segment.  VM1_GSEL is already set
;   up with limit (0FFFFh) and access (D_DATA0), so just fill in the base.
;
	mov	bx,GDTD_GSEL
	mov	ds,bx			; DS = GDT selector
	mov	bx,[bp.VTFOE+VMTF_DS]	; BX = VM DS (segment form)
	shl	bx,4			; BX = low 16 bits of base
	mov	ds:[VM1_GSEL+2],bx	; place in descriptor
	mov	bx,[bp.VTFOE+VMTF_DS]	; BX = VM DS (again)
	shr	bx,4			; BH = high 8 bits of base
	mov	ds:[VM1_GSEL+4],bh	; place in descriptor
	mov	bx,VM1_GSEL
	mov	ds,bx			; DS = VM DS

	test	ES:[PrefixFlag],REP_FLAG ;Q: REP prefix active ?
	jnz	SHORT EOUTSW_loop		;  Y: go do rep instruction
	outsw					;  N: do single instruction
	jmp	SHORT EOUTSW_exit		;     and leave
EOUTSW_loop:
	cld					; assume cld
	mov	bx,FLAGS_DF
	test	bx,word ptr [bp.VTFOE+VMTF_EFLAGS] ;Q: client's DF bit is CLD?
	jz	SHORT EOUTSW_rep		;  Y: go ahead
	std					;  N: set it
EOUTSW_rep:
	rep outsw				;   rep version

EOUTSW_Exit:			;
	jmp	EmExit		; *** RETURN *** to VM client
;
EmOUTSW endp

;******************************************************************************
;***	EmMOVSW - emulate MOV word string
;
;	This routine emulates the MOV word string instruction
;	specifically to handle the RASH Rules (Jokes) emulation.
;	For now, the only reason for doing this is to allow a bug
;	in PC Week's benchmark tests to FAIL "properly" so that the test
;	works.	(Unbelievable!)
;
;	NOTE:	After testing, if the ROM properly emulates the RASH
;	requirements, this routine should be reduced to the Reflect6
;	function.
;
;	ENTRY	386 PROTECTED MODE
;		see common description at top
;
;	EXIT	IRET back to VM program
;
;	USES	DS,BX,SI
;
EmMOVSW proc	near
	mov	bx, sp
	cmp	di, 0FFFFh		    ; Q:Does either Di
	je	SHORT EmWRASH
	cmp	ss:[bx.GPF_ESI], 0FFFFh     ;	or SI = FFFF?
	je	SHORT EmWRASH 		    ;  Y:Assume RASH GPfault
Reflect6:
	mov	es:[RefNum], 06h
RefToROM:
	pop	esi 			    ;  N: clean up the stack,
	pop	ebx
	pop	ebp
	add	sp,4			    ; throw away error code,
	push	ebp
	mov	bp,sp			    ; reset BP to stack frame
	push	es:[RefNum]		    ; push the trap number
	jmp	ReflectInterrupt	    ; and, Reflect to ROM
EmWRASH:
	test	es:[PrefixFlag], REPS_FLAG  ; Q:Is this a REP of REPNE?
	jz	SHORT EMWCXok 		    ;  N: don't change CX
	inc	cx
EMWCXok:
	mov	ax, 2			    ; assume up counter
	test	[bp.VTFOE+VMTF_EFLAGS], FLAGS_DF
	jz	SHORT EMWUpdtSI
	not	ax
EMWUpdtSI:
	mov	si, ss:[bx.GPF_ESI]
	add	ss:[bx.GPF_ESI], ax	    ; verify neg???
	cmp	si, 0FFFFh		    ; Q:Did SI cause the GP fault
	JE	SHORT EMW_Exit		    ;  Y:We're done

EMWUpdtDI:
	test	es:[PrefixFlag], REPS_FLAG  ; Q:Is this a REP of REPNE?
	jz	SHORT EMWCXok2		    ;  N: don't change CX
	inc	cx
EMWCXok2:
	add	di, ax			    ; verify neg???
EMW_Exit:
	jmp	EmExit		; *** RETURN *** to VM client
;
EmMOVSW endp

_TEXT	 ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\xmm.inc ===
ifndef INC_LIST
.xlist
endif
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1989-1991
;
;   Title:    EMM386 - MICROSOFT Expanded Memory Manager 386
;
;   Module:   XMM.INC - Definitions for extended memory manger (XMM)
;
;   Version:  0.01
;
;   Date:     Feb. 15, 1989
;
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   02/15/89  Original
;   02/19/89  pc	add other struct and equ
;
;******************************************************************************

XMM_MULTIPLEX		equ	43h	; XMM multiplex number of INT 2Fh
XMM_INSTALL_CHECK	equ	00h	; install check call
XMM_FUNCTION_ADDR	equ	10h	; get control function address call
;
; XMM functions
;
XMM_GET_VERSION		equ	00h
XMM_REQUEST_HMA		equ	01h
XMM_RELEASE_HMA		equ	02h
XMM_GLOBAL_ENABLE_A20	equ	03h
XMM_GLOBAL_DISABLE_A20	equ	04h
XMM_LOCAL_ENABLE_A20	equ	05h
XMM_LOCAL_DISABLE_A20	equ	06h
XMM_QUERY_A20		equ	07h
XMM_QUERY_FREE_EXTMEM	equ	08h
XMM_ALLOC_EMB		equ	09h
XMM_FREE_EMB		equ	0Ah
XMM_MOVE_EMB		equ	0Bh
XMM_LOCK_EMB		equ	0Ch
XMM_UNLOCK_EMB		equ	0Dh
XMM_GET_EMB_INFO	equ	0Eh
XMM_REALLOC_EMB		equ	0Fh
XMM_REQUEST_UMB		equ	10h
XMM_RELEASE_UMB		equ	11h
;
; All error codes has this bit on.
; Used for test sucess of XMM_QUERY_FREE_EXTMEM
;
;=============================================================================
;==  XMS Error Codes
;=============================================================================
XMM_ERROR_BIT		equ	80h

XMMerrA20		equ	82h
XMMnoHMA		equ	90h
XMMuseHMA		equ	91h
XMMminHMA		equ	92h
XMMfreeHMA		equ	93h
XMMsmallUMB		equ	0B0h
XMMnoUMB		equ	0B1h
XMMsegUMB		equ	0B2h

;
;  Previous HIMEM.SYS versions are not reliable
;
GOOD_HIMEM_VERSION	equ	208h

;
; struct pass to XMM_MOVE_EMB in DS:SI
;
ExtMemMoveStruct	struc
  mov_length	dd	?	; 32 bit number of bytes to transfer
  src_handle	dw	?	; handle of source block
  src_offset	dd	?	; 32 bit offset into source
  dst_handle	dw	?	; handle of destination block
  dst_offset	dd	?	; 32 bit offset into destination
ExtMemMoveStruct	ends

;=============================================================================
;==  ARENA Data Structure & Invalid Memory Owner
;=============================================================================
Arena	struc
  Sig	db	0
  Own	dw	0
  Len	dw	0
  RSVD	db	3 dup(0)
  Nam	db	8 dup(0)
Arena	ends
InvMem	equ	0Ah	; invalid memory owner (8 or 0Ah)

.list		; end of XMM.inc

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\xms.asm ===
.386p
	page 58,132
;=============================================================================
	title	X M S - XMS routines/support
;=============================================================================
;==
;== (C) Copyright MICROSOFT Corp. 1990-1991
;== (C) Copyright COMPAQ Computer Corp. 1990-1991
;==
;==	Title:	EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;==
;==	Module: XMS  - support routines for XMS
;==
;==	Version: 1.00
;==
;==	Date:	July 20,1990
;==
;==	Author: Leo Cohen
;==	(some routines extracted from XMM.ASM and A20TRAP.ASM: PC &
;==						               Harish Naidu)
;==
;=============================================================================
;==
;==	Change Log:
;==
;==	DATE	 REVISION	Description
;==	-------- --------	--------------------------------------------
;==     07/20/90 0.00	        Original (several routines from old modules)
;==
;==	01/30/91 M005		Hook QueryA20 (function 07h) also.
;==
;==	02/14/91 M009		B#5875. Forced EMM386 to use XMS for
;==				A20 control.
;==
;=============================================================================
;==
;==   Functional Description:
;==
;==   This module includes all support routines needed for XMS.
;==
;=============================================================================
;==	P U B L I C   D E C L A R A T I O N S
;=============================================================================
	public	pXMMentry
	public	XMMcheck
	public	XMMcontrol	; all XMM calls uses this dword address

	public	QueryA20	; query A20 state
	public	XmsVer
	public	HimemVer
	public	get_XMM_ver
	public	XMMQueryExtended
	public	UMBlink
	public	AvailUMB
	public	LargestUMB
	public	HMAmin
	public	HMAfree

ifdef MSFLAG
	public	EnableCount
endif
;=============================================================================
;==	E X T E R N A L  D E C L A R A T I O N S
;=============================================================================
LAST	segment
	extrn	VxDInit:near
	extrn	UMBtable:byte
	extrn	NumOfUMBwindows:byte
	extrn	Page4K:byte
	extrn	RAMSet:word

	extrn	XmmControlBase:dword	; base address of XMM control headers
	extrn	XmmControlJmpVal:byte	; offset byte of short jmp instruction

	extrn	XMMHookAddr:dword

LAST	ends

R_CODE	segment

EnableCount	dw	0	; A20 enable/disable counter
XMMcontrol	dd	0	; address of XMM entry point

	extrn	XMMAllocHMAFar:dword
	extrn	XMMDeallHMAFar:dword
	extrn	checkXMMFar:dword

R_CODE	ends

R1_CODE	segment
	extrn	PrevXmm:dword
	extrn	rXMMentry:byte
R1_CODE	ends



_TEXT	segment
	extrn	UpdateHMA:near
_TEXT	ends
;=============================================================================
;==	L O C A L   C O N S T A N T S
;=============================================================================
	include vdmseg.inc
	include vdmsel.inc
	include desc.inc
	include emm386.inc
	include vm386.inc
	include romstruc.equ
	include emmfunct.inc
	include emmdata.inc
	include	xmm.inc
	include oemdep.inc
;=============================================================================
;==	D A T A  S E G M E N T
;=============================================================================
_DATA	segment
fGlobalEnable	dw	0	; Global A20 enable/disable call
fCanChangeA20	db	1
HMAfree		db	TRUE	; HMA availability
HMAmin		dw	0	; HMA minimum size for allocation
_DATA	ends
;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
_TEXT	segment
	assume	cs:_TEXT,ds:_DATA,es:_DATA,gs:R_CODE,ss:STACK
;=============================================================================
;==	L O C A	L   D A T A
;=============================================================================
XMMproc	label word
	dw	offset GetVersion	; 0
	dw	offset RequestHMA   	; 1
	dw	offset ReleaseHMA   	; 2
	dw	offset GlobalEnableA20  ; 3
	dw	offset GlobalDisableA20 ; 4
	dw	offset LocalEnableA20   ; 5
	dw	offset LocalDisableA20  ; 6
	dw	offset IsA20On   	; 7 M005
	dw	offset QueryEMB   	; 8
	dw	offset AllocateEMB   	; 9
	dw	offset FreeEMB   	; 10
	dw	offset MoveEMB   	; 11
	dw	offset LockEMB   	; 12
	dw	offset UnlockEMB   	; 13
	dw	offset GetEMBInfo   	; 14
	dw	offset ReallocateEMB   	; 15
	dw	offset RequestUMB   	; 16
	dw	offset ReleaseUMB   	; 17
MaxXMMprocs	equ	($-XMMproc)/2
;==============================================================================
;==
;==  pXMMentry: Services XMM requests in protected mode.
;==
;==  Entry: (Protected Mode)
;==	AH  = XMM function number
;==	ECX = XMM function number
;==	GS  = R_CODE
;==
;==  Exit:
;==
;==============================================================================
pXMMentry proc	near

	push	VDMD_GSEL	; DS/GS are setup for CEMM's 2 data areas.
	pop	ds
	assume	ds:_DATA,es:nothing,fs:nothing,gs:R_CODE

	call	cs:[XMMproc][ecx*2]
	ret
pXMMentry	endp

;==============================================================================
;==
;==  XMMnullProcedures: These XMS routines are not serviced by CEMM.  They are
;==			passed to the next XMM in the chain.
;==
;==  Entry: (Protected Mode)
;==
;==  Exit:
;==
;==============================================================================
XMMnullProcedures proc	near
GetVersion:
QueryEMB:
AllocateEMB:
FreeEMB:
MoveEMB:
LockEMB:
UnlockEMB:
GetEMBInfo:
ReallocateEMB:
	ret
XMMnullProcedures	endp

;==============================================================================
;==
;==  RequestHMA: If CEMM is providing a virtual HMA and an XMM has already
;==		 been loaded, then it probably will not recognize the HMA
;==		 at run-time.  Thus, CEMM will hook the existing XMM and
;==		 provide the HMA services.  If an XMM is not present on
;==		 the system, CEMM will report 64K of memory via INT 15h
;==		 AH=88h.
;==
;==  Entry: (Protected Mode)
;==	AH = 1 request HMA function
;==	DX = Size of HMA required
;==
;==  Exit:
;==	AX = 1 if the HMA function was succesful.
;==	     0 if the HMA function failed.
;==	       BL = 91h if the HMA is already in use
;==	       BL = 92h if DX is less than the HMAMIN parameter
;==
;==============================================================================
RequestHMA proc	near

	cmp	[HMAfree],TRUE
	jne	short ReqHuse

	cmp	dx,[HMAmin]
	jb	short ReqHmin

	mov	[HMAfree],FALSE
	mov	ax,1

ReqHexit:
	ret

ReqHuse:
	mov	bl,XMMuseHMA
	xor	ax,ax
	jmp	short ReqHexit

ReqHmin:
	mov	bl,XMMminHMA
	xor	ax,ax
	jmp	short ReqHexit
RequestHMA	endp

;==============================================================================
;==
;==  ReleaseHMA
;==
;==  Entry: (Protected Mode)
;==	AH = 2 release HMA function
;==
;==  Exit:
;==	AX = 1 if the HMA function was succesful.
;==	     0 if the HMA function failed.
;==	       BL = 93h if the HMA is already free
;==
;==============================================================================
ReleaseHMA proc	near

	cmp	[HMAfree],TRUE
	je	short RelHfree

	mov	[HMAfree],TRUE
	mov	ax,1

RelHexit:
	ret

RelHfree:
	mov	bl,XMMfreeHMA
	xor	ax,ax
	jmp	short RelHexit
ReleaseHMA	endp

;==============================================================================
;==
;==  RequestUMB
;==
;==  Entry: (Protected Mode)
;==	AH = 16 request UMB function
;==	DX = size of UMB requested
;==
;==  Exit:
;==	AX = 1 if the UMB function was succesful.
;==	       BX = segment of UMB allocated
;==	       DX = actual size of UMB
;==	     0 if the UMB function failed.
;==	       BL = B0h if a smaller UMB is available
;==	       BL = B1h if no UMBs are available
;==	       DX = size of largest UMB available.
;==
;==============================================================================
RequestUMB proc	near
	push	fs

	mov	ax,DATA32_GSEL
	mov	fs,ax

	xor	bx,bx
	movzx	ecx,gs:[UMBptr]
	shl	ecx,4
RUloop:
	cmp	fs:[ecx].Sig,'M'	;Q: Valid ARENA header?
	je	short RUown		; Y: valid, see if its owned
	cmp	fs:[ecx].Sig,'Z'	;Q: Valid ARENA header?
	jne	RUnotFound		; N: arena header corruption
RUown:
	cmp	fs:[ecx].Own,0		;Q: Is this block available?
	jne	short RUnext		; N: get next ARENA header

	cmp	fs:[ecx].Len,bx		;Q: Largets block so far?
	jbe	short RUnext		; N: get next ARENA header
	mov	bx,fs:[ecx].Len		; Y: save this size
	cmp	bx,dx			;Q: Large enough block?
	jae	short RUfound		; Y: found a UMB
RUnext:
	cmp	fs:[ecx].Sig,'Z'	;Q: Last ARENA header in chain?
	je	RUnotFound		; Y: no blocks satisfy request

	mov	ax,fs:[ecx].Len		; get size of block in paragraphs
	inc	ax			; increment to memory block
	shr	ecx,4			; paragraph pointer
	add	cx,ax			; get to next ARENA header
	jc	short RUnotFound		; if carry, ARENAs are corrupt
	shl	ecx,4			; byte pointer
	jmp	short RUloop		; try the next arena
;
;  A UMB was found
;
RUfound:
	shr	ecx,4
	mov	ax,cx			; save paragraph in AX
	shl	ecx,4
	inc	ax
	push	ax			; save UMB address for return
;
;  Mark ARENA used
;
	mov	fs:[ecx].Own,ax		; paragraph as owner
	mov	fs:[ecx].Len,dx		; size
	mov	dword ptr fs:[ecx].Nam," BMU"; UMB is the name
	mov	dword ptr fs:[ecx][4].Nam,"    "
;
;  Is there enough memory to create another ARENA
;
	sub	bx,dx			;Q: Any more room in this ARENA?
	jbe	short RUcont		; N: just mark used
	dec	bx			; Y: size of new ARENA

	mov	al,'M'			; save ARENA signature
	xchg	fs:[ecx].Sig,al		; mark with "M" signature

	shr	ecx,4
	inc	cx
	add	cx,dx
	shl	ecx,4
;
;  Create new ARENA
;
	mov	fs:[ecx].Sig,al		; mark with "M/Z" signature
	mov	fs:[ecx].Own,0		; free
	mov	fs:[ecx].Len,bx		; size of free memory
	mov	dword ptr fs:[ecx].Nam,0; no name
	mov	dword ptr fs:[ecx][4].Nam,0

RUcont:
	mov	ax,1			; UMB allocated
	pop	bx			; restore paragraph address of UMB
	jmp	short RUexit
;
;  A UMB was NOT found
;
RUnotFound:
	mov	dx,bx			; save size of largest block
	mov	bx,XMMnoUMB		; assume no UMBs are available
	or	dx,dx			;Q: Any blocks available?
	jz	short RUerr		; N: error code is correct
	mov	bx,XMMsmallUMB		; Y: but they're too small
RUerr:
	xor	ax,ax			; error indication
RUexit:
	pop	fs
	ret
RequestUMB	endp

;==============================================================================
;==
;==  ReleaseUMB
;==
;==  Entry: (Protected Mode)
;==	AH = 17 request UMB function
;==	DX = segment number of UMB to release
;==
;==  Exit:
;==	AX = 1 if the UMB function was succesful.
;==	     0 if the UMB function failed.
;==	       BL = B2h if the UMB segment number was invalid
;==
;==============================================================================
ReleaseUMB proc	near
	push	fs

	mov	ax,DATA32_GSEL
	mov	fs,ax
;
;  Get address of UMB
;
	movzx	ecx,dx
	dec	cx
	shl	ecx,4
;
;  Check if UMB is valid
;
	cmp	fs:[ecx].Own,dx		;Q: Was it allocated via XMS UMB?
	jne	RelUMBerr		; N: invalid segment number

	cmp	dword ptr fs:[ecx].Nam," BMU"	;Q: Allocated via XMS UMB?
	jne	RelUMBerr			; N: invalid segment number
	cmp	dword ptr fs:[ecx][4].Nam,"    ";Q: Allocated via XMS UMB?
	jne	RelUMBerr			; N: invalid segment number
;
;  Free up the UMB
;
	mov	fs:[ecx].Own,0	      	; free
	mov	dword ptr fs:[ecx].Nam,0; no name
	mov	dword ptr fs:[ecx][4].Nam,0
;
;  Garbage collect UMB ARENAs
;
	call	UMBGarbageCollect

	mov	ax,1			; succesful release
	xor	bx,bx			; no error code

RelUMBexit:
	pop	fs
	ret

RelUMBerr:
	xor	ax,ax			; indicate an error
	mov	bx,XMMsegUMB		; invalid segment number error code
	jmp	short RelUMBexit

ReleaseUMB	endp

;==============================================================================
;==
;==  UMBGarbageCollect:  Garbage collects all ARENA headers.
;==
;==  Entry: (Protected Mode)
;==	DS	 = _DATA
;==	FS	 = DATA32_GSEL
;==	GS	 = _R_CODE
;==	[UMBptr] = first ARENA header
;==
;==  Exit:
;==	All free memory blocks above [UMBptr] which are adjacent, will be
;==	combined.
;==
;==============================================================================
UMBGarbageCollect proc	near
	push	eax
	push	ebx
	push	ecx
;
;  Get first ARENA pointer
;
	movzx	eax,gs:[UMBptr]		; get pointer to first ARENA
	shl	eax,4
;
;  Make sure it is a valid ARENA (base)
;
UGCloop:
	cmp	fs:[eax].Sig,'Z'	;Q: Last ARENA?
	je	short UGCexit		; Y: no more garbage collecting needed!
	cmp	fs:[eax].Sig,'M'	;Q: Valid base ARENA?
	jne	short UGCexit		; N: error, invalid ARENA
;
;  Check if base ARENA is FREE
;
UGCvalid:
	cmp	fs:[eax].Own,0		;Q: Is this base ARENA free?
	jne	short UGCnextBase	; N: get another base ARENA
	movzx	ebx,fs:[eax].Len	; Y: get to next ARENA
	inc	bx
	shl	ebx,4
	add	ebx,eax
;
;  Check if next ARENA is also FREE
;
	xchg	eax,ebx			; check if next ARENA is free
	cmp	fs:[eax].Own,0		;Q: Is next ARENA free?
	jne	short UGCnextBase	; N: get another base ARENA
	xchg	eax,ebx			; Y: combine base and next ARENAs
;
;  Use signature of next ARENA for base
;
	mov	cl,fs:[ebx].Sig
	mov	fs:[eax].Sig,cl
;
;  Add size of next ARENA to base
;
	mov	cx,fs:[ebx].Len		; get size of next ARENA
	inc	cx
	add	fs:[eax].Len,cx		; add size to base ARENA
;
;  Clear next ARENA: it was swallowed by base ARENA
;
	xor	ecx,ecx
	mov	fs:[ebx][0],ecx
	mov	fs:[ebx][4],ecx
	mov	fs:[ebx][8],ecx
	mov	fs:[ebx][12],ecx
	jmp	short UGCloop		; check new next ARENA if it is also free
;
;  Get a new base ARENA
;
UGCnextBase:
	movzx	ecx,fs:[eax].Len
	inc	cx
	shl	ecx,4
	add	eax,ecx
	cmp	fs:[eax].Sig,'Z'	;Q: End of chain?
	jne	short UGCloop		; N: continue

UGCexit:
	pop	ecx
	pop	ebx
	pop	eax
	ret
UMBGarbageCollect endp

;*----------------------------------------------------------------------*
;*									*
;*  GlobalEnableA20 -					FUNCTION 03h    *
;*									*
;*	Globally enable the A20 line					*
;*									*
;*  ENTRY:  PROTECTED MODE						*
;*  ARGS:   CLI								*
;*  RETS:   AX = 1 if the A20 line is enabled, 0 otherwise.  BL = Error	*
;*  REGS:   AX, BX CX, SI, DI and Flags clobbered			*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*
GlobalEnableA20 proc near


	cmp	[fGlobalEnable],1	; Is A20 already globally enabled?
	je	GEARet

GEAEnable:
	call    LocalEnableA20		; Attempt to enable A20
	or	ax,ax
	jz	GEAA20Err

	mov	[fGlobalEnable],1	; Mark A20 global enabled

GEARet:
	mov	ax,1			; return success
	xor	bl,bl
	ret

GEAA20Err:
	mov	bl,XmmerrA20		; some A20 error occurred
	xor	ax,ax
	ret
GlobalEnableA20 endp

;*----------------------------------------------------------------------*
;*									*
;*  GlobalDisableA20 -					FUNCTION 04h    *
;*									*
;*	Globally disable the A20 line					*
;*									*
;*  ENTRY:  PROTECTED MODE, CLI						*
;*  ARGS:   								*
;*  RETS:   AX=1 if the A20 line is disabled, 0 otherwise.  BL = Error	*
;*  REGS:   AX, BX, CX, SI, DI and Flags are clobbered			*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*
GlobalDisableA20 proc near

	cmp	[fGlobalEnable],0	; Is A20 already global-disabled?
	je	GDARet

	call    LocalDisableA20		; Attempt to disable it
	or	ax,ax			;   (also zaps CX, SI, DI)
	jz	GDAA20Err

	mov	[fGlobalEnable],0	; mark as global-disabled

GDARet:
	mov	ax,1			; return success
	xor	bl,bl
	ret

GDAA20Err:
	mov	bl,XMMerrA20		; some A20 error occurred
	xor	ax,ax
	ret
GlobalDisableA20 endp

;*----------------------------------------------------------------------*
;*									*
;*  LocalEnableA20 -					FUNCTION 05h    *
;*									*
;*	Locally enable the A20 line					*
;*									*
;*  ENTRY:  PROTECTED MODE, CLI						*
;*  ARGS:   								*
;*  RETS:   AX = 1 if the A20 line is enabled, 0 otherwise.  BL = Error	*
;*  REGS:   AX, BX, CX, SI, DI and Flags clobbered			*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*
LocalEnableA20 proc near

	cmp	[fCanChangeA20],1	; Can we change A20?
	jne	LEARet			; No, don't touch A20


	test	gs:[Current_State],fState_A20ena
					; Q: is A20 ON
	jnz	LEAIncIt		; Y: just increment count
					; N: turn it ON virtually
	or	gs:[Current_State],fState_A20Ena
	call	UpdateHMA

LEAIncIt:
	inc	gs:[EnableCount]
LEARet:
	mov	ax,1			; return success
	xor	bl,bl
	ret

LEAA20Err:
	mov	bl,XMMerrA20		; some A20 error occurred
	xor	ax,ax
	ret
LocalEnableA20 endp

;*----------------------------------------------------------------------*
;*									*
;*  LocalDisableA20 -					FUNCTION 06h    *
;*									*
;*	Locally disable the A20 line					*
;*									*
;*  ENTRY:  PROTECTED MODE, CLI						*
;*  ARGS:   		 						*
;*  RETS:   AX=1 if the A20 line is disabled, 0 otherwise.  BL = Error	*
;*  REGS:   AX, BX, CX, SI, DI and Flags are clobbered			*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*
LocalDisableA20 proc near

	cmp	[fCanChangeA20],0	; Can we change A20?
	je	LDARet			; No, don't touch A20

	cmp	gs:[EnableCount],0		; make sure the count's not zero
	je	LDAA20Err

;;
;;	xor	ax, ax			; assume A20 is OFF
;;					; Q: is A20 ON
;;	test	gs:[Current_State],fState_A20ena
;;	jz	LDAcont			; N: AX = 0
;;	mov	ax, 1			; Y: AX = 1
;;LDAcont:
					; M005: use routine instead of inline
	call	IsA20On			; M005: currently on or off
			

	cmp     gs:[EnableCount],1	; Only if the count = 1 should A20 be
	jnz     LDAStayOn		;   turned off, otherwise it stays on

	or	ax,ax			; If A20 is already off, don't
	jz	LDADecIt		;   bother to turn off again

	xor     ax,ax			; It's on, but should be turned off
	jmp     short LDASetIt

LDAStayOn:
	or	ax,ax			; A20 must stay on, if it is on, just
	jnz	LDADecIt		;   dec count, else force A20 on

LDASetIt:
	and	gs:[Current_State], NOT fState_A20Ena
					; Disable A20 virtually
	call	UpdateHMA

LDADecIt:
	dec	gs:[EnableCount]

LDARet:
	mov	ax,1			; return success
	xor	bl,bl
	ret

LDAA20Err:
	mov     bl,XMMerrA20		; some A20 error occurred
	xor     ax,ax
	ret
LocalDisableA20 endp

;*----------------------------------------------------------------------*
;*  M005								*
;*									*
;*  IsA20On -						FUNCTION 07h    *
;*									*
;*	Returns the state of the A20 line				*
;*									*
;*  ENTRY:  PROTECTED MODE, CLI						*
;*	    GS = R_CODE							*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if the A20 line is enabled, 0 otherwise		*
;*	    BL = 0							*
;*  REGS:   AX								*
;*									*
;*									*
;*----------------------------------------------------------------------*

IsA20On	proc	near

	xor	ax, ax			; assume A20 is OFF
					; Q: is A20 ON
	test	gs:[Current_State],fState_A20ena
	jz	IsA20Exit		; N: AX = 0
	mov	ax, 1			; Y: AX = 1

IsA20Exit:
	xor	bl, bl			; return success
	ret

IsA20On	endp

	

_TEXT	ends				; end of segment

;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
LAST	segment
	assume	cs:LAST,ds:_DATA,gs:R_CODE
;=============================================================================
;==	L O C A	L   D A T A
;=============================================================================
XMSver		dw	0
HimemVer	dw	0
;==============================================================================
;==
;==  UMBlink: Link all UMBs for XMM/DOS/RUNHI/LOADHI.
;==
;==  Enter:
;==     RAMset[] 	completely filled
;==	Page4K[] 	completely filled
;==	UMBtable[]      completely filled
;==
;==  Exit:
;==     		Arena headers on the UMB blocks
;==	[UMBptr]	pointer to first arena header.
;==
;==============================================================================
UMBlink	proc	near
	pusha
	push	es
	push	fs
;
;  Initialize Windows VxD for UMBs
;
;;	call	VxDInit

	xor	ax,ax

	xor	si,si
	movzx	cx,cs:[NumOfUMBwindows]
	or	cx,cx			;Q: Any UMBs?
	jz	UlExit			; N: exit
UlLoop:
	movzx	bx,cs:[UMBtable][si]	; get 4K page number

	or	bx,bx			;Q: Valid UMB entry?
	jz	short UlNext		; N: try next entry

	test	cs:[Page4K][bx],RAM	;Q: User specified RAM?
	jz	short UlCont		; N: check if user specified ROM

	call	FindSetRanges		; Y: mark ARENAs
	jmp	short UlNext		; try next page

UlCont:
	test	cs:[Page4K][bx],ROM	;Q: User specified ROM?
	jnz	short UlNext		; Y: don't use this page
;
;  Mark the entire 4K page as a UMB
;
	shl	bx,8			; starting paragraph
	mov	dx,bx
	add	dx,0FFh			; last paragraph

	call	CreateARENAs		; create ARENA header

UlNext:
	inc	si
	dec	cx
	jnz	UlLoop
;
;  Now fix up adjacent ARENAs: first delete ZERO length arenas
;
	mov	bx,gs:[UMBptr]
	or	bx,bx			;Q: Any UMBs found?
	jz	UlExit			; N: exit
	mov	dx,bx			; Y: first ARENA
	mov	fs,dx
	add	bx,fs:[0].Len
	inc	bx

UlAdj:
	mov	fs,bx
	mov	al,fs:[0].Sig
	add	bx,fs:[0].Len
	inc	bx

	cmp	fs:[0].Len,0
	jne	short UlAdjNext

	cmp	al,"Z"
	je	short UlAdjCont

	call	ClearARENA

	mov	fs,bx
	add	bx,fs:[0].Len
	inc	bx

UlAdjCont:
	call	ClearARENA

	mov	fs,dx
	mov	fs:[0].Sig,al
	mov	fs:[0].Len,bx
	sub	fs:[0].Len,dx
	dec	fs:[0].Len

UlAdjNext:
	mov	dx,fs
	cmp	al,"Z"		;Q: Last ARENA?
	jne	short UlAdj	; N: next ARENA

;
;  Need to see if first UMB is adjacent to last DOS ARENA
;
	mov	bx,-1			; sanity checker
	mov	ax,5200h		; add 1K to arena header
	int	21h                     ; get SYSINIT variables
	cmp	bx,-1			;Q: Did the call work?
	je	UlExit			; N: don't add 1K to arena
	mov	bx,es:[bx][-2]		; Y: UNDOCUMENTED start of arena chain
UlArenaLoop:
	mov	es,bx			; access current arena
	add	bx,es:[0].Len		; get segment to next arena
	jc	short UlExit		; if overflow, incorrect chain - EXIT!
	inc	bx
	cmp	es:[0].Sig,'Z'		;Q: Last arena header?
	jne	short UlArenaLoop	; N: check next arena
	cmp	bx,gs:[UMBptr]		;Q: Is first UMB adjacent?
	jne	short UlExit		; N: don't add to DOS chain
;
;  First UMB is adjacent, add to DOS memory
;
	mov	fs,bx			; access first UMB arena
	mov	bx,fs:[0].Len		; size of first UMB arena
	inc	bx
	cmp	fs:[0].Sig,'Z'		;Q: Last UMB?
	je	short UlDOScont	; Y: Don't add an extra arena
	inc	bx
UlDOScont:
	add	es:[0].Len,bx		; add to DOS memory
;
;  Fix INT 12h at 40:13h
;
	mov	bx,es
	add	bx,es:[0].Len
	inc	bx
	shr	bx,6			; kilobyte increment
	mov	ax,romdata		; get pointer to BIOS data area
	mov	fs,ax
	assume 	fs:romdata
	mov	fs:[Int12hMem],bx	; increment INT 12h by first UMB size

	or	gs:[GenFlags], fBackfill; we don't want to start win /3 if
					; back fill.
;
;  Find new first UMB pointer
;
	xor	bx,bx
	xchg	gs:[UMBptr],bx		; assume no UMBs
	mov	fs,bx			; get first UMB
	add	bx,fs:[0].Len
	inc	bx
	cmp	fs:[0].Sig,'Z'		;Q: Last UMB arena?
	pushf
	call	ClearARENA
	popf
	je	short UlExit		; Y: exit

UlDOSarena:
	mov	fs,bx			; get first UMB
	mov	gs:[UMBptr],bx		; assume first UMB
	add	bx,fs:[0].Len
	inc	bx
	cmp	fs:[0].Own,0		;Q: New first UMB?
	je	short UlExit		; Y: exit
	call	ClearArena		; N: clear arena
	jmp	short UlDOSarena

UlExit:
	pop	fs
	pop	es
	popa
	ret
UMBlink	endp

;==============================================================================
;==
;==  ClearARENA: Create ARENAs from set ranges in a 4K page.
;==
;==  Enter:
;==	FS =	Segment address for ARENA header
;==
;==  Exit:
;==     ARENA header has been cleared (zeroed)
;==
;==============================================================================
ClearArena proc	near
	push	eax

	xor	eax,eax
	mov	fs:[0],eax
	mov	fs:[4],eax
	mov	fs:[8],eax
	mov	fs:[12],eax

	pop	eax
	ret
ClearArena	endp

;==============================================================================
;==
;==  FindSetRanges: Create ARENAs from set ranges in a 4K page.
;==
;==  Enter:
;==	AX =	Previous ARENA describing invalid memory
;==	BX =	4K page index
;==
;==  Exit:
;==	AX =	New previous ARENA
;==     ARENA headers on this 4K page specified by user.
;==
;==============================================================================
FROM	equ	2
FindSetRanges	proc	near
	push	bx
	push	cx
	push	si

	shl	bx,8			; start of 4K page
;
;  Find lowest address in this 4K page
;
FSRloop:
	mov	dx,-1
	xor	si,si
FSRlow:
	mov	cx,cs:[RAMSet+2][si]	; get FROM range
	or	cx,cx			;Q: End of user specified range?
	jz	short FSRdone		; Y: check TO range
	add	si,2			; N: next range

	cmp	ch,bh			;Q: Same page?
	jne	short FSRlow		; N: try next paragraph

	cmp	cx,dx			;Q: Lowest paragraph?
	jae	short FSRlow		; N: get next one
	mov	dx,cx			; Y: save value
	mov	di,si			; save index
	sub	di,2
	jmp	short FSRlow

;
;  Lowest address found
;
FSRdone:
	cmp	dx,-1			;Q: Any values found?
	je	short FSRnoMore		; N: last ARENA

	cmp	dx,ax			;Q: Higher than last ARENA?
	jbe	short FSRexit		; N: problem, probably overlap!
;
;  FROM or TO value?
;
	test	di,FROM			;Q: FROM paragraph?
	jnz	short FSRto		; N: TO paragraph
	mov	bx,dx			; Y: new ARENA
	mov	cs:[RAMset+2][di],1	; mark entry used
	add	di,2
;
;  Get TO value
;
	cmp	bh,byte ptr cs:[RAMset+3][di] ;Q: Is TO in same 4K page index
	je	short FSRto		      ; Y: get TO address
	or	dx,0FFh			      ; N: use the rest of the page
	jmp	short FSRcreate

FSRto:
	mov	dx,1			; used to mark entry
	xchg	dx,cs:[RAMset+2][di]	; get address and mark used
	cmp	bx,dx			;Q: Is start and end the same?
	jne	short FSRcont		; N: continue
	or	dx,0FFh			; Y: mark the entire page
FSRcont:
	call	CreateARENAs		; create ARENA
	jmp	short FSRloop		; find any other ranges
;
;  Use entire page if no ranges found, else exit
;
FSRnoMore:
	cmp	ah,bh			;Q: Last ARENA in this page?
	je	short FSRexit		; Y: user specified range found
	mov	dx,bx			; N: use entire page as RAM
	add	dx,0FFh

FSRcreate:
	call	CreateARENAs

FSRexit:
	pop	si
	pop	cx
	pop	bx
	ret
FindSetRanges	endp

;==============================================================================
;==
;==  CreateARENAs:  Create ARENA headers
;==
;==  Enter:
;==     AX =	Previous ARENA header describing invalid memory
;==	BX =	Start of current memory area
;==	DX =	Last paragraph of current memory area
;==
;==  Exit:
;==	AX =	Last paragraph of current memory becomes new previous ARENA
;==     ARENA headers on this memory block. Also, last ARENA updated.
;==
;==============================================================================
CreateARENAs	proc	near

	or	ax,ax			;Q: Previous ARENA?
	jz	short CAfirst		; N: this is the first

	mov	fs,ax			; access last ARENA
	mov	fs:[0].Sig,"M"		; it is not the last
	mov	fs:[0].Len,bx		; calculate the new size
	sub	fs:[0].Len,ax
	dec	fs:[0].Len
	jmp	short CAcurr		; create current ARENA

CAfirst:
	mov	gs:[UMBptr],bx		; this is the first ARENA

CAcurr:
	mov	fs,bx			; access current ARENA
	mov	fs:[0].Sig,"M"		; not the last
	mov	fs:[0].Own,0		; free memory

	mov	fs:[0].Len,dx		; calculate the size
	sub	fs:[0].Len,bx
	dec	fs:[0].Len

	mov	byte ptr fs:[0].RSVD,0	; zero out rest of ARENA
	mov	word ptr fs:[0].RSVD+1,0
	mov	dword ptr fs:[0].Nam,0
	mov	dword ptr fs:[0].Nam+4,0

	mov	fs,dx			; access last ARENA

	mov	fs:[0].Sig,"Z"		; mark last ARENA
	mov	fs:[0].Own,InvMem	; owned by "SM" (invalid memory)
	mov	fs:[0].Len,0		; don't know length yet
	mov	byte ptr fs:[0].RSVD,0	; "SM"
	mov	word ptr fs:[0].RSVD+1,0
	mov	dword ptr fs:[0].Nam,"  MS"
	mov	dword ptr fs:[0].Nam+4,"    "

	mov	ax,fs			; last ARENA becomes previous ARENA

	ret
CreateARENAs	endp

;==============================================================================
;==
;==  XMMCheck: This routine checks if an XMM is on the system
;
;==	ENTRY	: GS = R_CODE
;==
;==============================================================================
XMMcheck proc	near

	call	dword ptr gs:[checkXMMFar]
					;Q: Is XMM present?
	jc	short XMMnotDetected	; N: OK only if an ISA machine.
	call	get_XMM_ver		; Y: check version

	call	XMMhook			; hook XMM

ifndef MSFLAG
	cmp	[ROMID],ROMIDISA	;Q: ISA/EISA machine?
	je	short XMMcont		; Y: don't need to invoke XMM
endif
	call	XMMQueryExtended	; allocate all memory via XMS (Microsoft)

XMMcont:
	test	gs:[Weitek_State],fWeitek_Map ;Q: Weitek enabled?
	jz	short XMMexit		      ; N: don't allocate HMA


	call	gs:[XMMAllocHMAFar]	;Q: HMA available for WEITEK?
	jnc	short XMMexit		; Y: exit
	mov	[HMAfree],FALSE		; N: take for virtual HMA

	cmp	bl,XMMnoHMA		;Q: HMA exist?
	je	short XMMexit		; N: WEITEK is possible
	mov	[HMAfree],TRUE		; Y: not available for WEITEK

	and	gs:[Weitek_State],not fWeitek_Map ; no WEITEK possible
	or	gs:[msg_flag],W_NO_HMA_MSG        ; "Unable to enable WEITEK"
	jmp	short XMMexit

XMMnotDetected:
ifndef MSFLAG
	cmp	[ROMID],ROMIDISA	;Q: ISA/EISA machine?
	je	short XMMexit		; Y: no XMM is ok!
endif
	or	gs:[msg_flag],NO_XMM_MSG; will not load with no XMM

XMMexit:
	ret
XMMcheck 	endp

;---------------------------------------------------------------------------
;
; XMMHook
;
; ENTRY		: GS -> R_CODE
;		  R1_CODE not moved yet.
;
; Hooks the XMS handler and points it to our handler rXMMentry in util.asm
;
; USES		: NONE
;
; Code ported from Smartdrv.
;
;--------------------------------------------------------------------------

XMMhook	proc	near

	push	es
	push	bx
	push	ax
	push	cx
	push	si
	push	di

	push	fs
	mov	bx, seg R1_CODE
	mov	fs, bx
	assume	fs:R1_CODE

	mov	bx,word ptr gs:[XMMcontrol]
	mov	es,word ptr gs:[XMMcontrol+2]   ; ES:BX = ptr to 1st XMM header
NextXmmHeader:
	mov	word ptr fs:[PrevXmm+2],es	; save seg of prev control adr
	mov	word ptr cs:[XmmControlBase+2],es
	mov	word ptr cs:[XmmControlBase],bx
	mov	cx,word ptr es:[bx]
	cmp	cl,0EBh				; compare short jmp opcode
	je	ShortJmp
	cmp	cl,0EAh				; compare far jmp opcode
	jne	XmmChainHosed			; bad XMM control chain
FarJmp:
	mov	si,word ptr es:[bx+1]		; SI = offset of jmp
	mov	es,word ptr es:[bx+1+2]		; ES = segment of jmp
	mov	bx,si
	jmp	NextXmmHeader			; continue down control chain
ShortJmp:
	cmp	word ptr es:[bx+2],9090h	; check NOPs
	jne	XmmChainHosed			; bad XMM control chain
	cmp	byte ptr es:[bx+4],90h
	jne	XmmChainHosed			; bad XMM control chain
	mov	di,bx				; DI = ptr to XMM header
	xor	ax,ax
	mov	al,ch				; AX = offset of short jmp
	mov	cs:[XmmControlJmpVal],al	; save offset of short jmp
	add	ax,2				; add length of jmp instr
	add	bx,ax				; BX = target of jmp
	mov	word ptr fs:[PrevXmm],bx  	; save previous control addr

;	Install ourselves in XMM control chain.

	mov	byte ptr es:[di],0EAh		; far immediate jmp opcode
	mov	word ptr es:[di+1],offset R1_CODE:rXMMentry
	mov	word ptr es:[di+3],fs

	add	di, 3
	mov	word ptr cs:[XMMHookAddr+2], es
	mov	word ptr cs:[XMMHookAddr], di

ifndef MSFLAG
ifndef LC910611
;
;  Make sure to hook the A20 API if the undocumented NoA20Trap is used!
;  This is not complete (910611)
;
	test	[GenFlags],fNoA20Trap	;Q: Was the NoA20Trap switch used?
	jz	short @f		; N: continue
					; Y: trap all XMS A20 calls
	mov	ax,offset R1_CODE:[XeTrap]
	mov	fs:[XMMTrapTable][3*2],ax
	mov	fs:[XMMTrapTable][4*2],ax
	mov	fs:[XMMTrapTable][5*2],ax
	mov	fs:[XMMTrapTable][6*2],ax
	mov	fs:[XMMTrapTable][7*2],ax
@@:
endif
endif

	jmp	short Xh_done

XmmChainHosed:
	or	gs:[msg_flag],NO_XMM_MSG	; will not load with no XMM

Xh_done:
	pop	fs
	pop	di
	pop	si
	pop	cx
	pop	ax
	pop	bx
	pop	es

	ret
XMMhook	endp

;**************************************************************************
;
;	Function	:	get_XMM_ver
;
;	Stores the XMS version # and the Himem version # in XmsVer and
;	HimemVer respectively.
;
;**************************************************************************

get_XMM_ver	proc	near

	push	ds
	push	es
	push	ax
	push	bx

	push	cs
	pop	ds
	assume	ds:LAST		; set up ds

	mov	ah, XMM_GET_VERSION
	push	seg R_CODE
	pop	es
	assume	es:R_CODE	; es -> R_CODE
	call	es:[XMMcontrol]

	mov	[XmsVer],ax
	mov	[HimemVer],bx

	cmp	bx,GOOD_HIMEM_VERSION		;Q: Good HIMEM.SYS version?
	jae	SHORT GXVexit			; Y: continue
	or	es:[msg_flag],BAD_XMM_MSG	; N: warning message

GXVexit:
	pop	bx
	pop	ax
	pop	es
	pop	ds
	assume	ds:_DATA, es:_DATA
	ret

get_XMM_ver	endp

;*****************************************************************************;
;***	XMMQueryExtended - Query amount of Extended Memory		      ;
;									      ;
;	This routine is used to query the amount of extended 		      ;
;	memory in the system using XMM calls.				      ;
;									      ;
;	ENTRY	none		;ds = _DATA				      ;
;	EXIT	AX = Size of largest free extended memory block    	      ;
;		DX = Total amount of free extended memory available           ;
;									      ;
; USES: flags								      ;
;	USES	ax, flags modified					      ;
;									      ;
;*****************************************************************************;
XMMQueryExtended proc	near

	mov	ah,XMM_QUERY_FREE_EXTMEM
	push	ds
	push	seg R_CODE
	pop	ds
	assume	ds:R_CODE
	call	[XMMcontrol]
	pop	ds
	assume	ds:_DATA
	ret

XMMQueryExtended	endp

;*****************************************************************************;
;***	QueryA20 - query A20 state					      ;
;									      ;
;	This routine is used to query the A20 state in		 	      ;
;	the system using XMM calls.					      ;
;									      ;
;	ENTRY	none		;ds = _DATA				      ;
;	EXIT	CF set if a20 is on currently				      ;
;		CF clear if a20 is off currently			      ;
;									      ;
; USES: flags								      ;
;	USES	ax, flags modified					      ;
;									      ;
;*****************************************************************************;
QueryA20 proc	near

	mov	ah, XMM_QUERY_A20
	push	ds
	push	seg R_CODE
	pop	ds
	assume	ds:R_CODE
	call	[XMMcontrol]
	pop	ds
	assume	ds:_DATA
	or	ax, ax
	jz	short QA20_ON
	stc					; ON
	ret
QA20_ON:
	clc					; OFF
	ret

QueryA20	endp

;==============================================================================
;==
;==  AvailUMB: Total available UMB space in paragraphs.
;==
;==  Enter:
;==
;==  Exit:
;==	EAX = size of FREE UMB space
;==
;==============================================================================
AvailUMB proc	near

	push	bx
	call	ScanUMBs
	mov	ax,bx
	pop	bx
	ret
AvailUMB	endp

;==============================================================================
;==
;==  LargestUMB: Largest FREE UMB space in paragraphs.
;==
;==  Enter:  es = R_CODE	
;==
;==  Exit:
;==	EAX = Largest FREE UMB space in paragraphs
;==
;==============================================================================
LargestUMB proc	near

	push	bx
	call	ScanUMBs
	pop	bx
	ret
LargestUMB	endp

;==============================================================================
;==
;==  ScanUMBs: Scan UMB space for FREE and largest FREE UMB.
;==
;==  Enter: es= R_CODE
;==
;==  Exit:
;==	AX = Largest FREE UMB space in paragraphs
;==	BX = Total available FREE space in paragraphs
;==
;==============================================================================
ScanUMBs proc	near
	assume	es:R_CODE

	push	cx
	push	fs
;
;  Initialize variables to zero and get paragraph address to first UMB
;
	xor	ax,ax
	xor	bx,bx
	mov	cx,es:[UMBptr]
SUloop:
	mov	fs,cx
	cmp	fs:[0].Sig,'M'
	je	short SUvalid
	cmp	fs:[0].Sig,'Z'
	jne	short SUexit
;
;  Valid ARENA
;
SUvalid:
	cmp	fs:[0].Own,0
	jne	short SUnext
;
;  FREE UMB: add to total available and check if it's the largest
;
	add	bx,fs:[0].Len
	cmp	ax,fs:[0].Len		;Q: Larget FREE UMB so far?
	jae	short SUnext		; N: continue
	mov	ax,fs:[0].Len		; Y: save size
;
;  Get next UMB
;
SUnext:
	add	cx,fs:[0].Len
	inc	cx
	cmp	fs:[0].Sig,'Z'
	jne	short SUloop
SUexit:
	pop	fs
	pop	cx
	ret
ScanUMBs	endp


LAST	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\winsrch.asm ===
.386p
	page 58,132
;=============================================================================
	title	W I N S R C H - searches for EMS and UMB windows
;=============================================================================
;==
;== (C) Copyright MICROSOFT Corp. 1990-1991
;== (C) Copyright COMPAQ Computer Corp. 1990-1991
;==
;==	Title:	EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;==
;==	Module: WinSrch  - searches for EMS and UMB windows
;==
;==	Version: 1.00
;==
;==	Date:	July 9,1990
;==
;==	Author: Leo Cohen
;==	(some routines extracted from ROM_SRCH.ASM: Daniel J. Mazina,
;==						    Richard D. Vail,
;==	  					    & Patrick Wu)
;==
;=============================================================================
;==
;==	Change Log:
;==
;==	DATE	 REVISION	Description
;==	-------- --------	--------------------------------------------
;==     07/09/90 0.00	        Original (* routines from ROM_SRCH.ASM)
;==
;==	01/18/91 M002		use xchg instead of move to write into 
;==				adapter space for ram determination.
;==
;==	01/30/91 M004		When trying to reclaim shadow ROM in routine
;==				CheckForCompaqROM, check to make sure that
;==				the offset of the int 10 vector lies within
;==				ROM length as specifed in the ROM header.
;==
;=============================================================================
;==
;==   Functional Description:
;==
;==   This module determines the areas which will be used by CEMM.  These
;==   areas include: page frame, other EMS windows above base memory, UMB
;==   windows, and EMS base memory windows.  It analyzes the user parameters
;==   and detects ROM and RAM areas to best determine these EMS/UMB windows.
;==
;==
;=============================================================================
;==	P U B L I C   D E C L A R A T I O N S
;=============================================================================
	public	Page4K
	public	UMBtable
	public	NumOfUMBwindows
	public	FindWindowLocations
	public	ROMcheck
	public	RAMcheck
ifdef	ROMCOMP
	public	ROMstart
endif
	public	CPQvideoROM
	public	DefaultROM
	public	DefaultInclude
	public	ProcessRange
	public	ExcludeRange
	public	RangeOverlap
	public	SetFlag
	public	GetPageFrame
	public	SetPageFrame
	public	EMSwindows
	public	UMBwindows
	public	BaseEMSwindows
	public	CheckEMSwindow
	public	CheckPageFrame
	public	CheckForROMHeader
	public	CheckForCompaqROM
	public	UpdatePageArray
	public	PFB_warning
	public	IsCompaq
;=============================================================================
;==	E X T E R N A L  D E C L A R A T I O N S
;=============================================================================
LAST	segment

ifdef	ROMCOMP
	extrn	UnProtectROM:near
	extrn	ProtectROM:near
	extrn	FixROMptrs:near
endif

	extrn	Pn:byte
	extrn	PnSet:word
	extrn	eXcSet:word
	extrn	IncSet:word
	extrn	DfltSet:word
	extrn	RAMSet:word
	extrn	ROMSet:word
	extrn	EMSSet:word
	extrn	WINset:word
	extrn	HighSet:word
	extrn	VGAROM:word
	extrn	E000ROM:word
	extrn	ROMparm:byte
	extrn	pCOMPAQ:dword
	extrn	szCOMPAQ:byte
	extrn	UMBset:byte
	extrn	PS2DATA:byte
	extrn	Highscan:byte
	extrn	NoTR:byte
	extrn	RangeSets:byte
	extrn	RangeSave:byte
	extrn	RANGESIZE:abs

	extrn	HRAMSet:word					
	extrn	BRAMSet:word					
	extrn	ToshSet:word					
	extrn	TOSHbeg:word					
	extrn	TOSHend:word
	extrn	toshiba_machine:byte

LAST	ends

_DATA	segment
	extrn	ROMID:byte
_DATA	ends
;=============================================================================
;==	L O C A L   C O N S T A N T S
;=============================================================================
	include vdmseg.inc
	include emm386.inc
	include romstruc.equ
	include emmfunct.inc
	include emmdata.inc
	include ps2ex.inc
	include ps2equ.inc
	include	eisaex.inc

;=============================================================================
;==  For ROM, RAM, and CPQ Video ROM search
;=============================================================================
FIRST_ROM_SEGMENT	= 01000H	; Segment address of first option ROM.
LAST_ROM_SEGMENT	= 0DF80H	; Segment address of last option ROM.*A
FIRST_RAM_SEGMENT	= 01000H	; Seg address of 1st possible RAM addr
;910520 LAST_RAM_SEGMENT= 0DF80H	; Seg addr of last possible RAM addr
LAST_RAM_SEGMENT	= 0EF80H	; Seg addr of last possible RAM addr 910520
REMAP_VIDEO_ROM_SEGMENT	= 0E000H	; Seg address of optional sys rom
ROM_SIGNATURE		= 0AA55h
NEXT_ROM_SEG		= 080H		; 2K seg increment to next ROM location
ROUND_BY_2K_SEG		= 0FF80h	; rounding factor for 2k seg addresses
SIZE_OF_16K_PAGE	= 0400h		; length of a EMS page in paragraphs
;=============================================================================
;==  For XMA2EMS mode
;=============================================================================
P0	EQU	1
P1	EQU	1 SHL 1
P2	EQU	1 SHL 2
P3	EQU	1 SHL 3
P254	EQU	1 SHL 4
P255	EQU	1 SHL 5
;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
LAST	segment
	assume	cs:LAST,ds:_DATA,gs:R_CODE
;=============================================================================
;==	L O C A	L   D A T A
;=============================================================================

; Data items between ZeroInitData and ZeroInitSize are set to zero (suprise)
; when FindWindowsLocations is called since it may be called more than once.

ZeroInitData		label	byte
PFB_warning		dw	0
Page4K			db	256 dup (0)
NumOfUMBwindows		db	0
UMBtable		db	128 dup (0)
ZEROINITSIZE		equ	$-ZeroInitData

LastChanceBuf		db	4*1024 dup(0)

SetTable label	word
	dw	offset LAST:DfltSet
	dw	offset LAST:HRAMSet
	dw	offset LAST:BRAMSet
	dw	offset LAST:ToshSet
	dw	offset LAST:eXcSet
	dw	offset LAST:RAMSet
	dw	offset LAST:ROMSet
	dw	offset LAST:EMSSet
	dw	offset LAST:WINset
NumberOfSets	equ	($-SetTable)/2

Pass		db	-1

EISAdata	db	(size GSI_data) dup (?)

ifdef	ROMCOMP

ROM64k		db	'DEP'
Num64kROMs	equ	$-ROM64k
ROM40k		db	'BHL'
Num40kROMs	equ	$-ROM40k
ROM32k          db	'FG'
Num32kROMs	equ	$-ROM32k

ROMstart	dw	0

endif

ROMChangeCount	equ	20

;===============================================================================
;==
;== FindWindowLocations: This routine creates an array of 256 entries.  Each
;==			 entry represents a 4K page in the first megabyte.
;==			 After searching the option ROM area, it marks any
;==			 entry which included ROM or RAM appropriately.  Then
;==			 it takes the user defined ranges from the command line
;==			 and merges this information into this array.  This
;==			 array is then analyzed to create the UMB and EMS
;==			 windows necessary for operation.
;==
;== Entry
;==	cs:PF_windows[] = table of possible page frame addresses.
;==	cs:DefltSet[]	= array of default unused areas.
;==	cs:eXcSet[]	= array of user specified areas to exclude.
;==	cs:IncSet[]	= array of user specified areas to include.
;==	cs:RAMSet[]	= array of user specified areas to include RAM.
;==	cs:EMSet[]	= array of user specified areas to include EMS.
;==	CS		= LAST segment
;==	DS 		= _DATA segment
;==	GS 		= R_CODE segment
;==
;== Exit
;==	ds:EMS_window[]			= initialized
;==	ds:EMS_window_locations[]	= initialized
;==	ds:EMSsegLoc[]			= initialized
;==	ds:[number_EMS_windows]		= initialized
;==	ds:UMBtable[]			= initialized
;==	ds:[XMA2EMS]			= initialized
;==	gs:[PF_Base]			= initialized
;==
;===============================================================================
FindWindowLocations	proc	near

	pushad
	cld

;  This routine may be called more than once, so after the first pass
;  some data must be reinitialized.

	push	cs
	pop	es

	inc	Pass				; Q: 1st time?
	jnz	short FWLagain			; N:

	mov	cx, RANGESIZE			; 1st time, save inital state
	mov	si, offset LAST:RangeSets	;   of the ranges so they can
	mov	di, offset LAST:RangeSave	;   be reused next time.
	rep movs byte ptr es:[di], es:[si]
	jmp	short FWLcont

FWLagain:
	xor	ax, ax				; 2nd time, zero initialize
	mov	cx, ZEROINITSIZE		;   some data
	mov	di, offset LAST:ZeroInitData
	rep stosb

	mov	cx, RANGESIZE			; and restore the saved ranges
	mov	si, offset LAST:RangeSave
	mov	di, offset LAST:RangeSets
	rep movs byte ptr es:[di], es:[si]

FWLcont:

;
;  Get first 16K multiple PTE entry after base memory. Used for base EMS windows.
;
	int	12h
	shr	ax,2				; 4K page
	add	ax,3				; round up
	and	ax,0FFFCh			; multiple of 4K
	mov	[end_of_base_memory_PTE],ax
;
;  Determine default memory areas not to use for EMS/UMB windows.
;
	call	DefaultROM

;  Check for Token Ring card

	call	CheckToken

;  Check Toshiba special exclude areas

	call	Toshiba_exclude

ifdef E000
;  Determine if can 'deshadow' video ROM at E000h

	test	gs:[GenFlags], fMCA	; Q: MCA
	jnz	short FWLskipE000	; Y: E000 is other ROM

	call	CheckE000

FWLskipE000:
endif
;
;  Check if Include ranges are for RAM or EMS: if no RAM switches, then EMS
;
	call	DefaultInclude
;
; If this is an MCA machine we'll do the detection of adapters using the 
; POS bytes. 
;

ifdef	ROMIDMCA
	xor	ax, ax			; Assume that POS did not work 
	cmp	[ROMID],ROMIDPS2	; Q: Is it a PS2
	jne	short FWLromscan	; N: do rom scan
endif
	test	gs:[GenFlags], fMCA	; Q: MCA
	jz	short FWLchkEISA	; N: check if EISA
					; Y: do POS detection
	call	ExcludePS2Options
	jmp	short FWLromscan

FWLchkEISA:
	test	gs:[GenFlags], fEISA	; Q: EISA
	jz	FWLromscan		; N: do rom scan
	call	ExcludeEISAOptions
;
;  Detect Option ROMs
;
FWLromscan:
	call	ROMcheck
;
;  Detect Compaq VIDEO ROM
;
	call	CPQVideoROM
;
;  Check if ROM can be mapped over by RAM
;
ifdef	ROMCOMP
	call	CPQROMcheck
endif
	call	ROMcompress

;ifndef IBMCOPYRIGHT

	; IBM version doesn't do this because their QBASIC uses ROM Basic

	call	ROMbasic
;endif
;
;  Process Default, Exclude, Include, RAM, and EMS range arrays (sets)
;
	xor	bx,bx
	mov	cx,NumberOfSets		; number of range arrays

FWLsetLoop:
	mov	si,cs:[SetTable][bx]	; get array address
	call	ProcessRange
	add	bx,2
	loop	FWLsetLoop
;
;  Detect Option RAM
;
	call	RAMcheck
;
;  Mark HighScan regions as available
;
	lea	si, cs:[HighSet]
	call	ProcessRange
;
; We now try to scan again using Ralph's algo
;
	push	edx	
	mov	edx, 0c0h		; start c0h
FWLscanagn:
	call	LastChanceScan
	inc	edx
	cmp	edx, 0f0h		; until efh
	jb	short FWLscanagn
	pop	edx
;
;  Make sure there are no overlaps in the ranges: Exclude takes precedence.
;
	call	RangeOverlap

;  On a Toshiba system, don't allow the user to put the EMS page frame over
;  reserved upper memory.

	call	ToshInvPFbase					
;
;  Now the EMS/UMB windows are selected: First get a page frame address
;
	call	GetPageFrame
;
;  Set up the page frame
;
	call	SetPageFrame
;
;  Set up EMS windows in the 640K to 1MB region
;
	call	EMSwindows
;
;  Set up UMB windows in the 640K to 1MB region
;
	call	UMBwindows
;
;  Set up base EMS windows
;
	call	BaseEMSwindows

	popad
	ret
FindWindowLocations endp

;===============================================================================
;==
;==  ROMcheck: Detect Option ROMs.
;==	       This section of code searches the auxiliary rom area
;==	       (from C0000 up to E0000) in 2K increments. A ROM checksum is
;==	       calculated to insure that the ROMs are valid.  Valid ROMs must
;==	       have the 1st byte = 55H and the next byte = 0AAH.  The next
;==	       byte indicates the size of the ROM in 512-byte blocks.  The
;==	       sum of all bytes in the ROM, modulo 256,	must be zero.
;==
;==	       If a ROM is not found at a location, the next location 2K-bytes
;==	       down is examined.  However, if it is found, the next location
;==	       after this ROM is tried.  The next ROM location is determine
;==	       according to the	size of the previous ROM.
;==
;==  Enter:
;==	Page4K[BX] = uninitialzed with detected ROM locations.
;==
;==  Exit:
;==	Page4K[BX] = initialzed with detected ROM locations.
;==
;===============================================================================
ROMcheck proc	near
	push	ax

;
; Memory above 640k is searched for any VIDEO or option ROMs located there.
;
;QLEO	mov	ax,FIRST_ROM_SEGMENT
	mov	ax,[end_of_base_memory_PTE]
	shl	ax,8

RcNextROMlocation:
	call	CheckForROMHeader

ifndef	MSFLAG
	jc	short RcROMDetected
	sub	ax,NEXT_ROM_SEG
	call	CheckPrechargeBus
endif

	jnc	short RcLast
RcROMDetected:
	call	UpdatePageArray

RcLast:
	cmp	ax,LAST_ROM_SEGMENT
	jbe	short RcNextROMlocation

	pop	ax
	ret
ROMcheck	endp

;===============================================================================
;==
;==  RAMcheck: Detect RAM mapped in the Option ROM space.
;==
;==  Enter:
;==	Page4K[BX] = uninitialzed with detected RAM locations.
;==
;==  Exit:
;==	Page4K[BX] = initialzed with detected RAM locations. (Unusable)
;==
;===============================================================================
RAMcheck proc	near

	push	ax

;
; ROM area is checked to insure no common RAM is mapped in the option space.
;
;QLEO	mov	ax,FIRST_RAM_SEGMENT
	mov	ax,[end_of_base_memory_PTE]
	shl	ax,8

RAcNextRAMlocation:
	call	CheckForMappedRAM
	jnc	short RAcLast
	call	UpdatePageArray

RAcLast:
	cmp	ax,LAST_RAM_SEGMENT
	jbe	short RAcNextRAMlocation

	pop	ax
	ret
RAMcheck	endp

;===============================================================================
;==
;==  CPQVideoROM: Detect Compaq Video ROM.
;==
;==  Enter:
;==	Page4K[BX] = uninitialized for E000h segment.
;==
;==  Exit:
;==	Page4K[BX] = E000h segment is either usable or INUSE.
;==
;===============================================================================
CPQVideoROM	proc	near
	push	ax

;
; The option ROM area that sometimes Compaq's VIDEO ROM is remapped to is
; checked.  If nothing is there then fine.
;
	mov	ax,REMAP_VIDEO_ROM_SEGMENT
	call	CheckForROMHeader
	jnc	short CVRexit
;
; If there is something there then check to see if it is Compaq's VIDEO ROM.
; If it is (CY = clear) then this area can still be used as a EMS window.
; Otherwise it can't.
;
	call	CheckForCompaqROM
	jc	short CVR_InUse

; Identified Video ROM @ E000, add it to our high scan set as being available

	movzx	di, byte ptr cs:[HighSet]
	add	byte ptr cs:[HighSet], 4
	mov	word ptr cs:[HighSet][di], 0E000h	; start of video rom
	dec	ax
	mov	word ptr cs:[HighSet][di+2], ax 	;   end of video rom
	jmp	short CVRexit

CVR_InUse:
	call	UpdatePageArray

CVRexit:
	pop	ax
	ret
CPQVideoROM	endp

ifdef	ROMCOMP

;===============================================================================
;==
;==  CPQROMcheck: Detect CPQ ROMs which have unused space in the F000 segment.
;==
;== 		  32K ROMs F000:0    - F000:7FFF = mirror image of
;==			   F000:8000 - F000:FFFF
;==
;==   		    	386G  Deskpr 386/16, 386/20, 386/25
;==   			386F  Deskpro 386s
;==   			386H  Deskpro 386/20e (Horizon only)
;==
;== 		  40K ROMs F000:0    - F000:5FFF   junk
;==			   F000:6000 - F000:FFFF = system ROM
;==
;==   			386H  Deskpro 386/20e (Gambler only)
;==   			386H  Deskpro 386/25e
;==   			386L  Deskpro 386/33
;==
;==		  64K ROMs F000:0    - F000:FFFF
;==
;==	   		386P  Portable 386
;==			386E  Systempro/Deskpro 486/25
;==			386D  Deskpro 386n
;==
;==  		  The pointers which need to be changed in order to
;==		  reclaim the lower 32K space include:
;==
;==			1BD0	dummy end of interrupt handler
;==			1C1F	IRQ 9 entry point
;==			1C28	287 error entry point
;==			20FB	diskette parameter table entry point
;==			2E12	fixed disk BIOS entry point
;==			2FA4	old fixed disk hardware entry point
;==			3343	fixed disk hardware entry point
;==			4A97	real-time clock entry point
;==
;==  Enter:
;==
;==  Exit:
;==
;===============================================================================
pCutTable	equ	801Eh		; pointer to cut-off table
CTsig		equ	1234h		; signature

tSegBase	equ	1		; segment base
tPOST		equ	2		; POST
tRunTime	equ	3		; Run-Time
tSetup		equ	4		; Setup
tVideo		equ	5		; System video (int 42h)
tProt16		equ	6		; 16 bit protected mode capable code
tProt32		equ	7		; 32 bit protected mode capable code

sCutTable 	struc
  sCTsig	dw	CTsig		; signature
  sCTnum	db	?		; number of entries
  sCTtype	db	?		; type of entry
  sCTaddr	dw	?		; address
sCutTable 	ends

sCutTableEntry 	struc
  sCTEtype	db	?		; type of entry
  sCTEaddr	dw	?		; address
sCutTableEntry	ends

CPQROMcheck proc	near
	pusha
	push	ds
	push	es
	push	fs

	call	IsCompaq		;Q: Is it a Compaq 386
	jnz	CRcExit			; N: can't use ROM space

	cmp	cs:[ROMparm],TRUE	;Q: Was ROM(Compress) parameter set?
	jne	CRcExit			; N: don't use ROM space

	cmp	cs:[UMBset],TRUE	;Q: Was RAM specified?
	je	short CRcRAM		; Y: RAM was implied

	cmp	gs:[NoEMSset],TRUE	;Q: Was NoEMS specified?
	je	short CRcRAM		; Y: RAM was implied

	cmp	gs:[NoPFset],TRUE	;Q: Was FRAME=NONE specified?
	jne	CRcExit			; N: RAM not implied

;
;  Need to detect ROMs, include RAM, and fix the vectors (end of init)
;
CRcRAM:

	mov	ax,0F000h
	mov	fs,ax
	mov	ax,cs
	mov	es,ax
	assume	es:LAST
;
;  Access cut-off table
;
	mov	bx,fs:[pCutTable]	; get pointer to cut-off table
	cmp	fs:[bx].sCTsig,CTsig	;Q: Is this a valid table?
	jne	CRcExit			; N: no ROM compression
	movzx	cx,fs:[bx].sCTnum	; Y: get number of entries
	jcxz	CRcExit			; no ROM compression if no entries
;
;  Get segment base (assume F0000h)
;
	push	bx
CRcBase:
	mov	ax,fs:[bx].sCTaddr	; get possible base
	cmp	fs:[bx].sCTtype,tSegBase;Q: Is this the segment base entry?
	je	short CRcBaseDone	; Y: get base
	add	bx,size sCutTableEntry	; N: next entry
	loop	CRcBase
	mov	ax,0F000h		; default to F000h
CRcBaseDone:
	pop	bx
;
;  Get size of POST code
;
	movzx	cx,fs:[bx].sCTnum	; get number of entries again
CRcPOST:
	cmp	fs:[bx].sCTtype,tPOST	;Q: Is this the POST entry?
	je	short CRcPOSTdone	; Y: get base
	add	bx,size sCutTableEntry	; N: next entry
	loop	CRcPOST
	jmp	short CRcExit		; no ROM compression if no entries
CRcPOSTdone:
	mov	bx,fs:[bx].sCTaddr	; get size of POST
	inc	bx
	jmp	short CRcAddRAM		; map RAM

ifdef	ROMCOMP
	mov	al,fs:[0FFE4h]		; get ROM type

;
;  Check for 64K ROMs
;
	lea	di,ROM64k
	mov	cx,Num64kROMs
	repne scas ROM64k		;Q: 64K ROM?
	je	CRcExit			; Y: no ROM compression

;
;  Check for 40K ROMs
;
	mov	bx,6000h		; start of 40K ROMs
	lea	di,ROM40k
	mov	cx,Num40kROMs
	repne scas ROM40k		;Q: 40K ROM?
	je	short CRcCompress	; Y: ROM compression

;
;  Check for 32K ROMs
;
	mov	bx,8000h		; start of 32K ROMs
	lea	di,ROM32k
	mov	cx,Num32kROMs
	repne scas ROM32k		;Q: 32K ROM?
	jne	CRcExit			; N: no ROM compression
;
;  Compress the System ROM
;
CRcCompress:

	or	gs:[GenFlags],fROMComp  ; set ROM compression flag
	mov	cs:[ROMstart],bx	; save starting of ROM after compression

;
;  Map lower image of ROM with RAM
;
	mov	ax,0F000h		; start of RAM
endif

CRcAddRAM:
	shr	bx,4
	add	bx,ax			; end of RAM
	dec	bx
	movzx	di,byte ptr cs:[RAMset]	; add to RAM list
	add	byte ptr cs:[RAMset],4
	mov	cs:[RAMset][di],ax	; from F000h ...
	mov	cs:[RAMset][di][2],bx	; ... to either F800h or F600h

CRcExit:
	pop	fs
	pop	es
	pop	ds
	popa
	ret
	assume	es:nothing
CPQROMcheck	endp

endif	; ROMCOMP


;===============================================================================
;==
;==  ROMcompress: Check to see if lower 32k of system ROM can be mapped over by
;==		  RAM.	This code was adapted from Helix.
;==
;==  Enter:
;==
;==  Exit:
;==
;===============================================================================
	public	ROMcompress

ROMcompress proc near

	cmp	cs:[Highscan], TRUE
	jne	RcQuickExit

	pusha
	push	es
	push	ds

	call	chkt2mrg			;check for type 2 merge
	assume	ds:nothing, es:nothing
	jc	short domerge			;if found skip type 1 check

	mov	ax, 0f000h			;first 3000h words (12k)
	mov	ds, ax				; at f000:0000 & f000:8000
	mov	es, ax				; must be the same
	xor	si, si
	mov	di, 8000h
	mov	cx, 3000h
	cld
	repe cmpsw
	jne	short RcExit

	xor	si,si
	mov	ds,si
	mov	cx,128
chkvecs:lodsw
	mov	dx,ax
	lodsw
	cmp	ax,0f000h
	jne	short @f
	cmp	dx,8000h
	jae	short @f
	cmp	si,32h*4			;cpm jump?
	je	short @f			;skip it
	cmp	dx,6000h
	jae	short RcExit
@@:	loop	chkvecs

domerge:xor	si,si
	mov	ds,si
	mov	cx,128
merge:	lodsw
	mov	dx,ax
	lodsw
	cmp	ax,0f000h
	jne	short @f
	cmp	dx,8000h
	jae	short @f
	add	word ptr [si-4],8000h
@@:	loop	merge

;  Make sure BIOS points to INT 13h entry point on upper 32K image by making an
;  INT 2Fh AH=13h (DOS 3.20 and later): changes the INT 13h calls from IBMBIO.
;  Note: Does not affect DOS 3.00-3.10, but valid only on DOS 3.20 and later.

	mov	ah,13h
	int	2fh
	mov	ax,ds
	cmp	ax,0f000h
	jne	short @f
	or	dx,8000h
@@:	mov	ax,es
	cmp	ax,0f000h
	jne	short @f
	or	bx,8000h
@@:	mov	ah,13h
	int	2fh

; Add 32k ROM area to RAM list

	movzx	di, byte ptr cs:[HighSet]
	add	byte ptr cs:[HighSet], 4
	mov	word ptr cs:[HighSet][di], 0f000h	; from F000h
	mov	word ptr cs:[HighSet][di+2], 0f7ffh	;   to F7FFh

RcExit:
	pop	ds
	pop	es
	popa

RcQuickExit:
	ret

ROMcompress endp


chkt2mrg proc near
	xor	si,si
	mov	ds,si
	mov	cx,128
	cld
chkt2a: lodsw
	mov	bx,ax
	lodsw
	cmp	ax,0f000h
	jne	short @f
	cmp	bx,8000h
	jae	short @f
	mov	es,ax
	cmp	si,32h*4			;cpm jump?
	je	short @f
	cmp	byte ptr es:[bx],0e9h		;check for jmp $+8000
	jne	short chkt2ng
	cmp	word ptr es:[bx+1],7ffdh	;
	jne	short chkt2ng
@@:	loop	chkt2a
	mov	ah,8
	mov	dl,0
	int	13h
	mov	ax,es
	mov	ds,ax
	mov	si,di
	or	si,8000h
	mov	cx,11
	repe cmpsb
	jne	short chkt2ng
	mov	ah,8
	mov	dl,1
	int	13h
	mov	ax,es
	mov	ds,ax
	mov	si,di
	or	si,8000h
	mov	cx,11
	repe cmpsb
	jne	short chkt2ng
	mov	ah,8
	mov	dl,80h
	int	13h
	mov	ax,es
	mov	ds,ax
	mov	si,di
	or	si,8000h
	mov	cx,11
	repe cmpsb
	jne	short chkt2ng
	stc
	ret
chkt2ng:clc
	ret
chkt2mrg endp

	assume	ds:_DATA

;ifndef IBMCOPYRIGHT

	; IBM version doesn't do this because their QBASIC uses ROM Basic

;===============================================================================
;==
;==  ROMbasic:	Check to see if machine has ROM basic that can be mapped
;==		over by RAM.  This code was adapted from Helix.
;==
;==  Enter:
;==
;==  Exit:
;==
;===============================================================================
	public	ROMbasic

basic_id db	'The IBM Personal Computer Basic'
basic_id_length equ $-basic_id

ROMbasic proc	near

	push	es

	cmp	cs:[Highscan], TRUE
	jne	RbNoBasic

	test	gs:[GenFlags], fMCA	; Q: MCA
	jnz	short RbChk4Basic	; Y: look for ROM basic

	mov	ax,3518h		; code from Helix to look for ROM basic
	int	21h			; on non-MCA machines
	mov	ax,es
	cmp	ax,0f600h
	jne	short RbNoBasic
	cmp	bx,0
	jne	short RbNoBasic
	mov	di,8000h
	mov	cx,32
	mov	al,'I'
	cld
	repne	scasb
	jne	short RbNoBasic
	cmp	word ptr es:[di],'MB'
	jne	short RbNoBasic

;  We either have an MCA machine, or a non MCA which looks like it might have
;  ROM basic (non MCA PS/2).  Do a more detailed ROM Basic search.

RbChk4Basic:

	mov	ax,0f600h		; more code from Helix
	mov	es,ax
	xor	di,di
	mov	cx,8000h-basic_id_length
	mov	al, cs:[basic_id]
basic_loop:
	repne	scasb
	jne	short RbNoBasic
	push	cx
	push	di
	mov	si,offset LAST:basic_id+1
	mov	cx,basic_id_length-1
	push	ds
	push	cs
	pop	ds
	rep	cmpsb
	pop	ds
	pop	di
	pop	cx
	jne	short basic_loop

;  Looks like we found ROM basic, add 32k to our HighScan set

	movzx	di, byte ptr cs:[HighSet]
	add	byte ptr cs:[HighSet], 4
	mov	word ptr cs:[HighSet][di], 0f600h	; from F600h
	mov	word ptr cs:[HighSet][di+2], 0fdffh	;   to FDFFh

RbNoBasic:
	pop	es

	ret

ROMbasic endp

;endif	IBMCOPYRIGHT

;===============================================================================
;==
;==  DefaultROM: Check to see if C600-C7FF should be excluded due to a bad CPQ
;==		 Video ROM.
;==
;==  Enter:
;==
;==  Exit:
;==
;===============================================================================
DefaultROM proc	near
	push	ds

	call	IsCompaq		;Q: Is it a Compaq 386
	jnz	short DRcheckMCA	; N: check if E000 should be excluded
;
;  Check if CPQ video ROMs are dated between 01/16/90 and 07/30/90
;
	push	0C000h
	pop	ds
	cmp	word ptr ds:[5FFBh],'09';Q: VGA ROMs from '90?
	jne	short DRcheckE000	; N: no problem
	cmp	byte ptr ds:[5FFAh],'/'	;Q: VGA ROMs have format mm/dd/yy?
	jne	short DRcheckE000	; N: no problem
	cmp	byte ptr ds:[5FF7h],'/'	;Q: VGA ROMs have format mm/dd/yy?
	jne	short DRcheckE000	; N: no problem
	cmp	byte ptr ds:[5FF5h],'0'	;Q: VGA ROMs have format mm/dd/yy?
	jne	short DRcheckE000	; N: no problem

	cmp	byte ptr ds:[5FF6h],'7'	;Q: VGA ROMs after July?
	ja	short DRcheckE000	; Y: no problem

	cmp	byte ptr ds:[5FF6h],'1'	;Q: VGA ROMs after January?
	ja	short DRexcC7FF		; Y: problem, exclude to C7FF

	cmp	byte ptr ds:[5FF8h],'1'	;Q: After Jan 20, 1990?
	ja	short DRexcC7FF		; Y: exclude
	jb	short DRcheckE000	; N: no problem

	cmp	byte ptr ds:[5FF9h],'6'	;Q: Before Jan 16, 1990?
	jb	short DRcheckE000	; Y: no problem

DRexcC7FF:
	mov	cs:[VGAROM],0C7FFh	; exclude to C7FFh area
	jmp	short DRcheckE000

DRcheckMCA:

	test	gs:[GenFlags], fMCA	; Q: MCA system
	jz	short DRexit		; N: finished

	mov	cs:[VGAROM],0BFFFh	; Y: include C000 ROM area

	mov	cs:[E000ROM],0E000h	;    and exclude E000 ROM area

DRcheckE000:
	;
	; DO NOT ADD ANY CODE BETWEEN DRcheckE000 & DRexit
	;

DRexit:
	pop	ds
	ret
DefaultROM	endp

;===============================================================================
;==
;==  CheckToken: Checks for Token Ring card.  Adapted from code by Helix.
;==
;==  Enter:
;==
;==  Exit:
;==
;===============================================================================
	public	CheckToken

CheckToken proc near

	push	si
	push	di
	push	es

	cmp	cs:[NoTR], TRUE 	;Don't do it if disabled
	je	CT_exit

	mov	dx,0a20h			;load primary base i/o address
	in	al,dx				;get BIOS/MMIO address
	cmp	al,0ffh 			;token ring adapter present ?
	jne	short gottr			;yes
	mov	dx,0a24h			;load alternate base i/o address
	in	al,dx				;get BIOS/MMIO address
	cmp	al,0ffh 			;token ring adapter present ?
	je	short CT_exit			;no
gottr:	and	al,0fch 			;mask off interrupt bits
	shr	al,1				;shift to correct position
	or	al,80h				;mask on high bit
	mov	ah,al				;load ah with result
	mov	al,0				;zero al
	mov	es,ax				;load es with rom address
	mov	si,1f00h			;point to adapter id area
	mov	cx,12				;load id word length
chkid:	lods	word ptr es:[si]		;get id byte
	and	al,0fh				;mask off high nybble
	xor	al,0fh				;complement value
	mov	ah,es:[si+16h]			;get complement id byte
	and	ah,0fh				;mask off high nybble
	cmp	al,ah				;does complement id byte match ?
	jne	short CT_exit			;no
	loop	chkid				;iterate loop

	push	dx				;save port address
	mov	bx, es				;mark the 8k ROM space as INUSE
	mov	dl, INUSE
	call	SetFlag
	inc	bh				;2nd 4k page of ROM
	call	SetFlag
	pop	dx

	test	gs:[GenFlags], fMCA		; Q: MCA system
	jnz	CT_mca				; Y:

	mov	ah, es:[1E00h]			; N: get shared RAM addr on ISA
	jmp	short CT_len

CT_mca: 					;get shared RAM address on MCA
	inc	dx				;add 2 to I/O address
	inc	dx
	in	al, dx				;get shifted RAM address
	and	al, 0FEh			;mask off low bit
	mov	ah, al

CT_len:
	xor	al, al				;ax = paragraph RAM address
	xor	ch, ch
	mov	cl, es:[1E01h]			;get shared RAM size
	and	cl, 0Ch 			;(bits 2&3: 00=8k,  01=16k,
	shr	cl, 1				;	    10=32k, 11=64k)
	shr	cl, 1
	inc	cl
	shl	cl, 1				;cx = RAM size in 4k pages

	mov	bx, ax				;mark the shared RAM space
	mov	dl, INUSE			;  as INUSE
CT_set_ram:
	call	SetFlag
	inc	bh
	loop	CT_set_ram

CT_exit:
	pop	es
	pop	di
	pop	si
	ret

CheckToken endp


ifdef E000

;===============================================================================
;==
;==  CheckE000: Determines if E000h area is available by default.  Adapted
;==		from code by Helix.
;==
;==  Enter:
;==
;==  Exit:
;==
;===============================================================================
	public	CheckE000

CheckE000 proc	near

;  DefaultROM will have set E000ROM to 0E000h if this is not a Compaq
;  system.  This causes E000h-EFFFh to be excluded as ROM by default,
;  but we want to be a little smarter than that.  If we can identify
;  and 'deshadow' a video bios in the E000h area, E000h is made available
;  by default.

	push	ds
	push	es
	assume	ds:nothing, es:nothing

	cmp	cs:[Highscan], TRUE
	jne	CE_exit

	mov	ax,0e000h		; from Helix...
	mov	es,ax
	cmp	word ptr es:[0],0aa55h
	jne	short CE_exit
	mov	ch,es:[2]
	mov	cl,0
	push	ds
	mov	ax,0c000h
	mov	ds,ax
	xor	si,si
	xor	di,di
	rep	cmpsw
	pop	ds
	jne	short CE_exit

	call	deshadow_command
	jc	short CE_exit

;  'Deshadowed' the video rom, add first 32k of E000 as RAM.  Why 32k?
;  That's what Helix does!

	movzx	di, byte ptr cs:[HighSet]
	add	byte ptr cs:[HighSet], 4
	mov	word ptr cs:[HighSet][di], 0E000h	; from E000h
	mov	word ptr cs:[HighSet][di+2], 0E7FFh	;   to E7FFh

CE_exit:
	pop	es
	pop	ds

	ret

CheckE000 endp

	public	deshadow_command

deshadow_command proc near
	push	ax				;save work regs
	push	bx				;...
	push	cx				;...
	push	si				;...
	push	di				;...
	push	ds				;...
	push	es				;...

; scan interrupt vectors for those pointing to E000 area
	xor	ax,ax				;assume IDT at zero
	mov	es,ax				;...
	xor	di,di				;zero offset
deshadow_command_2:
	mov	ax,word ptr es:[di]		;get offset
	shr	ax,4				;...
	add	ax,word ptr es:[di+2]		;add in segment to get abs. seg
	jc	short deshadow_command_4	;overflow= bigger then ff
	cmp	ah,0e0h 			;if not between e0
	jb	short deshadow_command_4
	cmp	ah,0e7h 			;and e7
	ja	short deshadow_command_4	; skip
; vector found pointing to E000 area
	mov	bx,di				;save offset of vector found
	lds	si,es:[di]			;point DS:SI at target area
	mov	ax,ds				;convert to C000 address
	sub	ax,2000h			;...
	mov	es,ax				;equivalent area of C000
	mov	di,si				;same offset
	mov	cx,100h 			;check for 256 bytes the same
	repe cmpsb				;compare two areas
	jne	short deshadow_command_error	;problems

; code in C000 seems to be the same as in the E000 area
	xor	ax,ax				;restore vector pointer
	mov	es,ax				;...
	mov	di,bx				;...
	sub	byte ptr es:[di+3],20h		;change E000 vector to C000

deshadow_command_4:
	add	di,4				;step to next vector
	cmp	di,320h 			;if more to check,
	jb	short deshadow_command_2	;look at the next vector

; complete IDT scanned with no problem cases

	pop	es				;restore entry regs
	pop	ds				;...
	pop	di				;...
	pop	si				;...
	pop	cx				;...
	pop	bx				;...
	pop	ax				;...
	clc					;clear carry for ok
	ret					;& return

deshadow_command_error:
	pop	es				;restore entry regs
	pop	ds				;...
	pop	di				;...
	pop	si				;...
	pop	dx				;...
	pop	cx				;...
	pop	bx				;...
	pop	ax				;...
	xor	dx,dx
	stc					;set carry for error
	ret					;& return
deshadow_command endp

	assume	ds:_DATA
endif

;===============================================================================
;==
;==  DefaultInclude: Determines if Include parameter is for RAM or EMS.
;==
;==  Enter:
;==	cs:IncSet[1] = RAM
;==
;==  Exit:
;==	cs:IncSet[1] = RAM or EMS
;==
;===============================================================================
DefaultInclude	proc	near
	push	ax
	push	bx
	push	si
	push	di

	lea	bx,cs:[RAMSet]		; assume RAM
	xor	si,si

	cmp	cs:[UMBset],TRUE	;Q: Was RAM specified?
	je	short DItran		; Y: RAM was implied

	cmp	gs:[NoEMSset],TRUE	;Q: Was NoEMS specified?
	je	short DItran		; Y: RAM was implied

	cmp	gs:[NoPFset],TRUE	;Q: Was FRAME=NONE specified?
	je	short DItran		; Y: RAM was implied
;
;  No RAM parameters were specified, thus Include is taken as EMS windows.
;
	lea	bx,cs:[EMSSet]		; default is EMS
;
;  Move Include ranges to either RAM or EMS ranges
;
DItran:
	movzx	di,byte ptr cs:[bx]	; get pointer into RAM/EMS set
	mov	ax,cs:[IncSet][2][si]	; get address from INCLUDE set
	mov	cs:[bx][di],ax		; save in RAM/EMS set
	or	ax,ax			;Q: Any more addresses?
	jz	short DIexit		; N: exit
	add	si,2			; Y: increment to next address
	add	byte ptr cs:[bx],2
	jmp	short DItran		; get next address

DIexit:
	pop	di
	pop	si
	pop	bx
	pop	ax
	ret
DefaultInclude	endp

;===============================================================================
;==
;==  ProcessRange: Process range array constructed by the parser and transfer
;==	           information to the [Page4K] array.  The parser array has
;==		   the following structure:
;==
;==		   0  [n*4+2|array flag]
;==		   2  [ entry # 1 FROM ]
;==		   4  [ entry # 1 TO   ]
;==		   6  [ entry # 2 FROM ]
;==		   8  [ entry # 2 TO   ]
;==		   :  :	    :   : :  : :
;==	       n*4-2  [ entry # n FROM ]
;==	       n*4+2  [ entry # n TO   ]
;==
;==  Enter:
;==	SI = address of parser range array to process.
;==	Page4K[0..255] = Uninitialized with flag in parser array.
;==
;==  Exit:
;==	Page4K[0..255] = Initialized with this flag.
;==
;===============================================================================
ProcessRange	proc	near
	push	ax
	push	bx
	push	dx
	push	ds

	mov	ax,seg LAST
	mov	ds,ax
	assume	ds:LAST

	mov	dl,byte ptr [si+1]	; array flag (include,exclude,RAM,EMS,etc...)
	add	si,2			; point ro first range

PRnext:
	lodsw				; Get FROM
	or	ax,ax			;Q: Any more ranges?
	jz	short PRexit		; N: finished processing
	mov	bx,ax			; Y: BX has lower limit

	call	SetFlag			; set flag for FROM value

	lodsw				; AX has upper limit

PRnextPage:
	add	bx,100h			; next 4K page
	jc	PRnext			; if overflow, goto next range
	cmp	bx,ax			;Q: Has upper limit been reached?
	ja	PRnext			; Y: Try next range (X=FROM-TO)
	call	SetFlag			; N: set flag for next 4K page
	jmp	short PRnextPage

PRexit:
	pop	ds
	pop	dx
	pop	bx
	pop	ax
	ret
	assume	ds:_DATA
ProcessRange	endp

;===============================================================================
;==
;==  ExcludeRange: Exclude range in Page4K[] array.
;==
;==  Enter:
;==	AX = starting paragraph address
;==	BX = ending paragraph address
;==
;==  Exit:
;==	Page4K[AX-BX] = EXCLUDE
;==
;===============================================================================
ExcludeRange	proc	near
	push	bx
	push	dx

	mov	dl,EXCLUDE
ERloop:
	call	SetFlag
	sub	bx,100h
	cmp	ax,bx		;Q: End of range?
	jbe	short ERloop	; N: continue excluding

	pop	dx
	pop	bx
	ret
ExcludeRange	endp

;===============================================================================
;==
;==  SetFlag: Set proper flag in Page4K[] array.
;==
;==  Enter:
;==	DL = proper flag.
;==	BX = index to Page4K[] array.
;==
;==  Exit:
;==	Page4K[BX] = DL
;==
;===============================================================================
SetFlag	proc	near
	push	bx

	shr	bx,8			; paragraph to 4K page
	and	cs:[Page4K][bx],not INUSE ; no longer INUSE
	or	cs:[Page4K][bx],dl	  ; mark with current flag

	pop	bx
	ret
SetFlag	endp

;===============================================================================
;==
;==  RangeOverlap: Checks Include/eXclude/RAM/EMS ranges for overlap.  Exclude
;==		   has precedence over WIN, RAM or EMS.  WIN has precedence
;==		   over RAM or EMS.  RAM has precedence over EMS.
;==
;==  Enter:
;==	Page4K[] array completely filled out.
;==
;==  Exit:
;==	[msg_flag] = Overlap_MSG flag set if an overlap is detected.
;==
;===============================================================================
RangeOverlap	proc	near
	push	ecx

	mov	ecx,100h			; loop through 256 entries
ROPage4K:
	test	cs:[Page4K][ecx-1],EMS+RAM+ROM+WIN  ;Q: EMS,RAM,ROM or WIN set?
	jz	short ROnextPage4K		    ; N: next 4K page

	test	cs:[Page4K][ecx-1],EXCLUDE	;Q: Is this page also excluded?
	jz	short RO4KWINpage		; N: try WIN
	and	cs:[Page4K][ecx-1],EXCLUDE	; Y: mark 4K page as excluded
	jmp	short ROmsg			; warn user with msg

RO4KWINpage:
	test	cs:[Page4K][ecx-1],EMS+RAM+ROM	;Q: EMS,RAM,or ROM set?
	jz	short ROnextPage4K		; N: next 4K page

	test	cs:[Page4K][ecx-1],WIN		;Q: Is this page also WIN?
	jz	short RO4KRAMpage		; N: try RAM
	and	cs:[Page4K][ecx-1],WIN		; Y: mark 4K page as WIN
;;;	jmp	short ROmsg			; warn user with msg
	jmp	short RONextPage4K		; no warning for WIN= overlap
						; (MEMMAKER makes WIN= overlaps)
RO4KRAMpage:
	test	cs:[Page4K][ecx-1],RAM+ROM	;Q: Is RAM or ROM set?
	jz	short ROnextPage4K		; N: EMS only, next 4K page

	btr	cs:[Page4K][ecx-1],EMSbit	;Q: Is RAM/ROM and EMS set?
	jnc	short ROnextPage4K		; N: RAM only, next 4K page
ROmsg:
	or	gs:[msg_flag],Overlap_MSG	; range overlap message

ROnextPage4K:
	loop	ROPage4K

	pop	ecx
	ret
RangeOverlap	endp

;===============================================================================
;==
;==  GetPageFrame:  Given the user has not selected a page frame base address,
;==		    this routine will find an available 64K area.
;==
;==  Enter:
;==	Page4K[] array completely filled out.
;==
;==  Exit:
;==	[PF_Base] = page frame base address
;==
;===============================================================================
GetPageFrame	proc	near

;
;  Check to see if the base address of the page frame needs to be selected
;
	cmp	gs:[NoEMSset],TRUE	;Q: Has NoEMS switch been used?
	je	short GPFexit		; Y: don't select one.

	cmp	gs:[NoPFset],TRUE	;Q: Has FRAME=NONE switch been used?
	je	short GPFexit		; Y: don't select one.

	cmp	gs:[PF_Base],FREE	;Q: Has page frame been selected?
	jne	short GPFexit		; Y: don't reselect one.

	test	cs:[PnSet],P0+P1+P2+P3	;Q: XMA2EMS mode selected?
	jnz	short GPFexit		; Y: don't select page frame
;
;  Check default page frame address of E000h for a conflict
;
	mov	ax,0E000h		; default page frame address
	call	CheckPageFrame		; check for a page frame
	or	bx,bx			;Q: Conflict?
	jz	short GPFfound		; N: found page frame
;
;  Check area from 8000h to F000h for page frame with no conflict.
;
	mov	dx,[end_of_base_memory_PTE] ; get lowest PTE candidate
	shl	dx,8			; paragraph address
	mov	ax,0F000h		; highest page frame possible

	cmp	dx,8000h		;Q: Above 512K?
	jae	short GPFfind		; Y: continue
	mov	dx,8000h		; N: lowest possible page frame address
GPFfind:
	call	CheckPageFrame		; check [AX] for a page frame
	or	bx,bx			;Q: Conflict?
	jz	short GPFfound		; N: found page frame
	sub	ax,400h			; Y: try 16K lower
	cmp	ax,dx			;Q: Valid page frame address?
	jae	short GPFfind		; Y: try this address range
	mov	ax,FREE			; N: no page frame address found

GPFfound:
	mov	gs:[PF_Base],ax		; save page frame address

GPFexit:
	ret
GetPageFrame	endp

;===============================================================================
;==
;==  SetPageFrame: Given a page frame address, it sets up the EMS_window[],
;==		   EMS_window_location[], and EMSsegLoc[].
;==
;==
;==  Enter:
;==	[PF_Base] page frame base address assigned.
;==	Page4K[]  array completely filled out.
;==
;==  Exit:
;==	EMS_window_location[]
;==	EMSsegLoc[]
;==	Page4K[] array completely filled out.
;==
;===============================================================================
SetPageFrame	proc	near

	mov	[number_EMS_windows],0	; save number of EMS windows

;
;  Check to see if the base address of the page frame needs to be set
;
	cmp	gs:[NoEMSset],TRUE	;Q: Has NoEMS switch been used?
        je      SPFexit			; Y: don't select one.

	cmp	gs:[NoPFset],TRUE	;Q: Has FRAME=NONE switch been used?
	je	SPFexit			; Y: don't select one.

	cmp	gs:[PF_Base],FREE	;Q: Has page frame been selected?
	je	SPFexit			; N: don't set one.

	test	cs:[PnSet],P0+P1+P2+P3	;Q: XMA2EMS mode selected?
	jnz	short SPFinvParm	; Y: don't select page frame

	mov	ax,gs:[PF_Base]		; get page frame address
;
;  Make sure page frame was not set in base memory
;
	mov	bx,[end_of_base_memory_PTE] ; get lowest PTE candidate
	shl	bx,8			; paragraph address
	cmp	ax,bx			;Q: Valid page frame address?
	jae	short SPFcont		; Y: continue
	mov	gs:[PF_Base],FREE	; N: can not load
	jmp	short SPFexit

SPFcont:
;
;  Exclude range from Page4K[] array and check for conflicts
;
	mov	bx,ax
        shr     bx,8                            ; paragraph to 4K page
        mov     cx,16
SPFConflictLoop:
        test    cs:[Page4K][bx],not (EMS or RAM);Q: Marked for usage other than EMS?
        jz      short SPFnoConflict             ; N: no conflict
        or      gs:[msg_flag],PF_WARN_MSG       ; Y: warn user of conflict
SPFnoConflict:
        or      cs:[Page4K][bx],EXCLUDE         ; exclude from usage
        inc     bx
        loop    SPFConflictLoop	                ; continue excluding
;
;  Initialize EMS_window_location[], EMSsegLoc[], and EMS_window[] with information
;
	mov	bx,ax
        add     bx,0C00h                ; EMS window number 3
	shr	bx,8
	mov	ecx,4   		; number of windows in page frame
SPFloop:
	mov	[EMS_window_location][ecx*2-2],bx     ; address of window
;QEMS	mov	[EMS_window][ecx*2+ecx-3].handle,FREE ; window is free
	mov	[EMSsegLoc][bx],cl		      ; window index
	dec	[EMSsegLoc][bx]			      ; window index
	sub	bx,4				      ; next window
	loop	SPFloop

	mov	[number_EMS_windows],4	; save number of EMS windows
SPFexit:
	ret

SPFinvParm:
	or	gs:[msg_flag],INV_PARM_MSG
	jmp	short SPFexit
SetPageFrame	endp

;===============================================================================
;==
;==  EMSwindows:
;==
;==
;==
;==  Enter:
;==	Page4K[] array completely filled out.
;==
;==  Exit:
;==	EMS_window_location[]
;==	Page4K[] array completely filled out.
;==
;===============================================================================
EMSwindows proc	near
;
;  Check to see if EMS windows are needed
;
	cmp	gs:[NoEMSset],TRUE	;Q: Has NoEMS switch been used?
	je	EwExit			; Y: don't create EMS windows

	cmp	gs:[NoPFset],TRUE	;Q: Has FRAME=NONE switch been used?
	je	EwExit			; Y: don't create EMS windows

	test	cs:[PnSet],P0+P1+P2+P3+P254+P255 ;Q: XMA2EMS mode selected?
	jnz	short EwXMA2EMS			  ; Y: set XMA2EMS mode

;
;  Create as many EMS windows as possible in the 640K to 1MB region.
;
	mov	ax,[end_of_base_memory_PTE] ; get lowest PTE candidate
	add	ax,3
	shr	ax,2			; round to next 16K boundary
	mov	cx,100h shr 2		; 1MB index in 16K blocks
	sub	cx,ax			; number of PTE entries to 1MB
	shl	ax,10			; paragraph address
	movzx	esi,[number_EMS_windows]; get number of EMS windows so far
EwLoop:
	mov	bx,EMS			; erase EMS flag
	call	CheckEMSWindow
	test	bx,not EMS		;Q: Conflict?
	jnz	short EwNext		; Y: try next 16K window

	test	bx,EMS			;Q: Is this page specified as EMS?
	jnz	short Ewfound		; Y: use for EMS

	cmp	cs:[UMBset],TRUE	;Q: Has RAM switch been used?
	je	EwNext			; Y: use RAM as default
					; N: use EMS as default
EwFound:
	mov	bx,ax			; N: exclude range
	add	bx,3FFh
	call	ExcludeRange
;
;  Set up EMS_window_location[] and EMS_Window[]
;
	mov	bx,ax
	shr	bx,8
	mov	[EMS_window_location][esi*2],bx
;QEMS	mov	[EMS_window][esi*2+esi].handle,FREE
	xchg	ax,si
	mov	[EMSsegLoc][bx],al		      ; window index
	xchg	ax,si
	inc	si
EwNext:
	add	ax,400h			; next window
	loop	EwLoop

	mov	[number_EMS_windows],si	; save number of EMS windows
	jmp	EwExit

;
;  Need to place CEMM in XMA2EMS mode.
;
EwXMA2EMS:
	mov	[XMA2EMS],TRUE		; configure in XMA2EMS mode

	cmp	gs:[PF_Base],FREE	;Q: Has a page frame been set?
	je	short EwXPn		; N: just look at Pn set
	mov	ax,gs:[PF_Base]		; Y: get base address
	shr	ax,8			; get PTE index
	mov	cx,4			;
	xor	bx,bx
EwXloop:
	mov	Pn[bx],al		; save starting address
	bts	[PnSet],bx		; set Pn value
	inc	bx			; next Pn value
	add	al,4			; next window base address
	loop	EwXloop
;
;  Check conflicts with P0-P3 & P254-P255
;
EwXPn:
	xor	esi,esi			; index into Pn
	xor	dx,dx			; number of EMS windows
	mov	cx,6			; check P0-3 & P254-255
EwXPnLoop:
	bt	[PnSet],si		;Q: Is this P set?
	jnc	short EwXnextPn		; N: skip it
	mov	al,Pn[si]		; Y: get address

	xor	bx,bx
	shl	ax,8			; change to paragraph
	cmp	gs:[PF_Base],FREE	;Q: Has a page frame been set?
	je	short EwXcont1		; N: check for conflicts
	cmp	si,3			;Q: PF has already been tested?
	jbe	short EwXcont		; Y: don't check
EwXcont1:				; N: check if valid EMS page
	call	CheckEMSWindow		; check for conflict
;
;QLEO: Need a message if this conflicts with a page marked as RAM
;
	test	bx,EXCLUDE		;Q: Is this window excluded?
	jnz	short EwNoWay		; Y: can't do it
	test	bx,INUSE		;Q: Is there a ROM in the window?
	jz	short EwXcont		; N: continue
	mov	cs:[PFB_warning],TRUE	; Y: warn user
EwXcont:
;
;  Set up EMS_window_location[] and EMS_Window[]
;
	mov	bx,ax
	shr	bx,8
	mov	[EMS_window_location][esi*2],bx
;QEMS	mov	[EMS_window][esi*2+esi].handle,FREE
	xchg	ax,si
	mov	[EMSsegLoc][bx],al		      ; window index
	xchg	ax,si
;
;  Exclude window range from available area
;
	mov	bx,ax
	add	bx,3FFh
	call	ExcludeRange
	inc	dx							;@PIW
EwXnextPn:
	inc	si
	loop	EwXPnLoop
	mov	[number_EMS_windows],dx	; number of EMS windows
;
; Now that all Pn's are set, can a page frame be formed?
;
EwXPF:
	mov	cx,3
	mov	esi,3
	mov	ax,[EMS_window_location][esi*2]
EwXPFset:
	dec	si
	mov	bx,[EMS_window_location][esi*2]
	sub	ax,bx
	cmp	ax,4			;Q: Are they next to each other?
	jne	short EwXnoPF		; N: page frame is not available
	mov	ax,bx			; Y: get last address
	loop	EwXPFset

	shl	ax,8
	mov	gs:[PF_Base],ax		; save page frame address
	jmp	short EwExit
EwExit:
	ret

EwXnoPF:
	or	gs:[msg_flag],NO_LIM_PF_MSG ; no page frame warning
	jmp	short EwExit

EwNoWay:
	mov	gs:[PF_Base],FREE
	jmp	short EwExit

EMSwindows	endp

;===============================================================================
;==
;==  UMBwindows:
;==
;==
;==  Enter:
;==	Page4K[] array completely filled out.
;==
;==  Exit:
;==	EMS_window_location[]
;==	Page4K[] array completely filled out.
;==
;===============================================================================
UMBwindows proc	near

	mov	bx,[end_of_base_memory_PTE] ; get lowest PTE candidate
	mov	cx,100h			    ; 1MB PTE entry
	sub	cx,bx			    ; number of PTE entries to 1MB
	xor	si,si
UMBloop:
	test	cs:[Page4K][bx],not (RAM+ROM);Q: Is this page used?
	jnz	short UMBnotFound	     ; Y: no UMB here

	test	cs:[Page4K][bx],RAM+ROM	;Q: Is this page specified as RAM or ROM?
	jnz	short UMBfound		; Y: use as a UMB

	cmp	gs:[NoEMSset],TRUE	;Q: Has NoEMS switch been used?
	je	UMBfound		; Y: UMBs implied

	cmp	gs:[NoPFset],TRUE	;Q: Has FRAME=NONE switch been used?
	je	UMBfound		; Y: UMBs implied

	cmp	cs:[UMBset],TRUE	;Q: Has RAM switch been used?
	jne	UMBnotFound		; N: no RAM by default

UMBfound:
	test	cs:[Page4K][bx],ROM	;Q: Is this page specified as ROM?
	jnz	short UMBcont		; Y: don't add to base memory

	cmp	[end_of_base_memory_PTE],bx;Q: Is this adjacent to base memory?
	jne	short UMBcont		   ; N: don't add to base memory
	inc	[end_of_base_memory_PTE]   ; Y: Add to base memory?

UMBcont:
;QLEO	or	cs:[Page4K][bx],EXCLUDE
	mov	cs:[UMBtable][si],bl
	inc	si
UMBnotFound:
	inc	bx
	loop	UMBloop
UMBend:
	mov	bx,si
	mov	cs:[NumOfUMBwindows],bl
	ret
UMBwindows	endp

;===============================================================================
;==
;==  BaseEMSwindows:
;==
;==
;==
;==  Enter:
;==	Page4K[] array completely filled out.
;==
;==  Exit:
;==	EMS_window_location[]
;==	Page4K[] array completely filled out.
;==
;===============================================================================
BaseEMSwindows	proc	near
;
;  Check to see if base EMS windows are needed
;
ifdef NoEMS
	cmp	gs:[NoEMSset],TRUE	;Q: [NoEMS] mode?
	je	short BEwExit		; Y: no base EMS windows
endif
	cmp	[XMA2EMS],TRUE		;Q: XMA2EMS mode?
	je	short BEwExit		; Y: no base EMS windows

	movzx	esi,[number_EMS_windows]; get number of EMS windows so far
	mov	cx,[end_of_base_memory_PTE] ; beyond base window
	add	cx,3
	shr	cx,2
	xor	ax,ax
BEwLoop:
	xor	bx,bx
	call	CheckEMSWindow
	test	bx,not (EMS+RAM)
	jnz	short BEwNext
	mov	bx,ax
	shr	bx,8
	mov	[EMS_window_location][esi*2],bx
;QEMS	mov	[EMS_window][esi*2+esi].handle,FREE
	xchg	ax,si
	mov	[EMSsegLoc][bx],al		      ; window index
	xchg	ax,si
	mov	bx,ax
	add	bx,3FFh
	call	ExcludeRange
	inc	si
BEwNext:
	add	ax,400h
	loop	BEwLoop
	mov	[number_EMS_windows],si

BEwExit:
	ret
BaseEMSwindows	endp

;===============================================================================
;==
;==  CheckEMSWindow: Given a starting paragraph address, this routine will
;==		     return a composite of all the flags encountered in the
;==		     16K range.
;==
;==  Enter:
;==	AX = Starting paragraph
;==	BX = flag to clear from range: EMS, RAM, EXCLUDE, INUSE
;==
;==  Exit:
;==	AX = same
;==	BX = 0 		No conflict. No carry.
;==	     EXCLUDE    Conflict with an excluded 4K page
;==	     RAM	Conflict with a RAM 4K page
;==	     INUSE	Conflict with a default excluded area
;==
;===============================================================================
CheckEMSWindow	proc	near
	push	ax
	push	cx
	push	dx

	not	bx		; complement flag
	mov	dx,bx		; flag to clear
	mov	bx,ax		; starting paragraph address
	xor	ax,ax		; clear flags
	shr	bx,8
	mov	cx,4
CEWloop:
	or	al,cs:[Page4K][bx]
	and	cs:[Page4K][bx],dl
	inc	bx
	loop	CEWloop
	mov	bx,ax
	and	bx,not EMS

	pop	dx
	pop	cx
	pop	ax
	ret
CheckEMSWindow	endp

;===============================================================================
;==
;==  CheckPageFrame: Given a starting paragraph address, this routine will
;==		     return a composite of all the flags encountered in the
;==		     64K range.
;==
;==  Enter:
;==	AX = Starting paragraph
;==
;==  Exit:
;==	AX = same
;==	BX = 0 		No conflict. No carry.
;==	     EXCLUDE    Conflict with an excluded 4K page
;==	     RAM	Conflict with a RAM 4K page
;==	     INUSE	Conflict with a default excluded area
;==
;===============================================================================
CheckPageFrame	proc	near
	push	ax
	push	cx
	push	dx

	xor	dx,dx
	mov	cx,4
CPFloop:
	xor	bx,bx
	call	CheckEMSWindow
	or	dx,bx
	add	ax,400h
	loop	CPFloop
	mov	bx,dx

	pop	dx
	pop	cx
	pop	ax
	ret
CheckPageFrame	endp

;===============================================================================
;==
;==  UpdatePageArray: Updates page array (Page4K[]) with detected ROM/RAM.
;==
;==  Enter:
;==	AX = Paragraph address of next ROM/RAM position.
;==     DX = Length of ROM/RAM in paragraphs
;==
;==  Exit:
;==	[Page4K] updated
;==
;==
;===============================================================================
UpdatePageArray	proc	near
	push	bx

	mov	bx,ax
	sub	bx,dx			; start of ROM/RAM
UPAloop:
	shr	bx,8			; index into 4K page
	or	cs:[Page4K][bx],INUSE	; mark it used
	inc	bx			; next page
	shl	bx,8			; paragraph address
	cmp	bx,ax			;Q: Still in the ROM/RAM area?
	jb	short UPAloop		; Y: mark this page as used

	pop	bx
	ret
UpdatePageArray	endp

ifndef	MSFLAG
;===============================================================================
;==
;==  CheckPrechargeBus: Detects a ROM which did not include a ROM header.
;==			The routine expects a floating bus to be precharged
;==			to either 00 or FF.  Thus, if any other pattern is read,
;==			a non-standard ROM will be reported.
;==
;==  Enter:
;==	AX = Paragraph address of next ROM/RAM position.
;==
;==  Exit:
;==	CY = A non-standard ROM was found at this location.
;==	NC = Did not find a valid ROM at this location.
;==	AX = Paragraph address of next ROM location.
;==     DX = Length of this ROM in paragraphs
;==
;==
;===============================================================================
CheckPrechargeBus proc	near
	push	ds
;
;  Assume no ROM will be found: Floating Bus
;
	mov	ds,ax
	mov	dx,NEXT_ROM_SEG
	add	ax,dx
;
;  Check for precharge of low
;
	cmp	dword ptr ds:[4],0
	jne	short CPBcheckFF
	cmp	dword ptr ds:[8],0
	jne	short CPBROMdetected
	cmp	dword ptr ds:[12],0
	jne	short CPBROMdetected
	jmp	short CPBFloatingBus
;
;  Check for precharge of high
;
CPBcheckFF:
	cmp	dword ptr ds:[4],-1
	jne	short CPBROMdetected
	cmp	dword ptr ds:[8],-1
	jne	short CPBROMdetected
	cmp	dword ptr ds:[12],-1
	je	short CPBFloatingBus
;
;  ROM detected
;
CPBROMdetected:
	stc
	jmp	short CPBexit

;
;  Floating Bus was detected (no ROM)
;
CPBFloatingBus:
	clc

CPBexit:
	pop	ds
	ret
CheckPrechargeBus	endp

endif

;******************************************************************************
; CheckForROMHeader
;
; ENTRY
;	AX = Segment address of ROM.
; EXIT
;	CY = Found a VDU ROM at this location.
;	NC = Did not find a valid ROM at this location.
;	AX = Segment address of NEXT ROM location.
;	DX = Length of this ROM in paragraphs
;
; DESCRIPTION
;	This routine looks at the ROM located at the segment address
;	specified in AX to see if 0TH and 1ST Bytes = 0AA55H.
;	If so, it calculates the checksum over the length of
;	ROM.  If the checksum is valid it updates AX to point
;	to the location of the next ROM.
;
;	For option ROMs, the layout of each valid ROM is as follows:
;
;	 OFFSET +-----------------------+
;	    0	|	   55h		|
;		+-----------------------+
;	    1	|	   AAh		|
;		+-----------------------+
;	    2	|    ROM size / 512	|
;		+-----------------------+
;	    3	|  Start of init code	|
;			    :
;	   n-1	|			|
;		+-----------------------+
;		(Sum of all bytes MOD 100h is 00h.)
;
;******************************************************************************
CheckForROMHeader proc	near

	push	ds

		; The ROM segment address is loaded into DS and the memory
		; is tested to see if the ROM signature is there.
	mov	ds,ax
	xor	bx,bx
	cmp	[bx].ROM_RECOGNITION,ROM_SIGNATURE
	jne	SHORT CFR_no_ROM_found

		; If a ROM signature is there than compute the ROM's checksum.
		; The size of the ROM is stored as the number of 512 bytes
		; blocks. It is loaded into CX as the number of bytes.
	xor	esi,esi
	xor	ecx,ecx
	mov	ch,[bx].ROM_LEN

	shl	ecx,1

	or	ecx,ecx			;Q: 128K ROM?
	jnz	SHORT CFRcont		; N: continue
	mov	ecx,20000h		; Y: 128K ROM
CFRcont:
	mov	edx,ecx

		; Each byte is loaded from the ROM area and added to the
		; checksum in BL.  At the end of the loop the value in BL
		; should be zero.  If not than this isn't a ROM.
CFR_next_byte:
	lodsb
	add	bl,al
	dec	ecx
	jnz	short CFR_next_byte

	or	bl,bl				;Q: Is this a ROM?
	jnz	short CFR_no_ROM_found		; N: ROM not found

		; If this is reached then the address reflects a ROM.  The
		; size of the ROM in DX is in bytes and is converted into
		; the number of paragraphs.
		; The original ROM address in DS is loaded into AX and
		; incremented to point to the next possible ROM segment.
	shr	edx,4
	mov	ax,ds
	add	dx,NEXT_ROM_SEG - 1	;increment to next
	and	dx,ROUND_BY_2K_SEG	;truncate to 2K boundary
	add	ax,dx
	stc
	jmp	SHORT CFR_return_code

		; If this is not a ROM then the next possible address
		; is changed into a paragraph count.
		; The original ROM address in DS is loaded into AX and
		; incremented to point to the next possible ROM segment.
CFR_no_ROM_found:
	mov	dx,NEXT_ROM_SEG
	mov	ax,ds
	add	ax,dx
	clc

CFR_return_code:

	pop	ds
	ret
CheckForROMHeader endp

;******************************************************************************
; CheckForCompaqROM
;
; ENTRY
;	none
; EXIT
;	CY - If set then the area is not Compaq's VIDEO ROM and can not be used.
;		But, it must be removed from the window map
;			- AX = next ROM segment
;			- DX = ROM length in paragraphs
; DESCRIPTION
;
;******************************************************************************
CheckForCompaqROM	proc	near

		; The entrance registers are saved.
	push	ds
	push	es

ifdef E000
		; Can't be Compaq's ROM if not a Compaq system
	call	IsCompaq
	jnz	short CFCR_not_Compaqs_ROM
endif

		; The data in the ROM area is compared to the data at
		; the default VIDEO rom area.
		; DS:SI is the default location for COMPAQ's VIDEO ROM.
	push	0C000h
	pop	ds
	xor	esi,esi

		; ES:DI is the ROM location to verfify
	push	REMAP_VIDEO_ROM_SEGMENT
	pop	es
	xor	di,di

		; The data in the two ROM areas are now checked to see if they
		; are the same. DX is the ROM length in paragraphs.
	mov	cx,dx
	shl	cx,2
	repe	cmpsd
	jne	short CFCR_not_Compaqs_ROM

		; If the ROM data matches then now the VIDEO ROM location
		; interrupt vector is checked to see if it was remapped.
	xor	esi,esi
	mov	ds,si
	ASSUME	DS:ABS0
	cmp	[int10+2],REMAP_VIDEO_ROM_SEGMENT
	jne	short CFCR_not_Compaqs_ROM

		; No one has hooked the int 10 vector. Now check to make 
		; sure the offset of the int 10 vector lies within the ROM 
		; length specifed in the header. This is an attempt to
		; prevent us from reclaiming the shadow on ROMs that do not
		; specify their length correctly.
		; 
	mov	cx, dx	   	; dx has length in paras
	shl	cx, 4		; cx has length in bytes
	cmp	cx, [int10]	; Q: is the ROM lentgh <= the offset of int10
	jbe	short CFCR_not_Compaqs_ROM
				; Y: do not recalim shadow

				
		; If this is reached then the ROM appears to be Compaq's
		; VIDEO ROM remapped so set the appropriate state.
	push	R_CODE
	pop	ds
	assume	ds:R_CODE
	or	[Current_State],fState_CEGAinst
	mov	[CROM_Length],dx
	clc
	jmp	SHORT CFCR_return_code

CFCR_not_Compaqs_ROM:
	stc

CFCR_return_code:
	pop	es
	pop	ds
	ASSUME	ds:_DATA

	ret
CheckForCompaqROM	endp

;******************************************************************************
; CheckForMappedRAM
;
; ENTRY
;	AX = Segment address for RAM search.
; EXIT
;	CY = Found RAM at this location.
;	NC = Did not find RAM at this location.
;	AX = Segment address of next RAM location.
;	DX = Length of this RAM
;
; DESCRIPTION
;	This routine looks at the address range potentially used
;	by the Page Frame to determine if any RAM is in the way.
;	It updates the map accordingly.
;******************************************************************************
CheckForMappedRAM	proc	near
	push	cx
	push	ds
	pushf
	cli				;;; clear ints during this test

;  search for RAM
;
	xor	dx,dx					; length = 0
ram_loop:
	mov	ds,ax
	add	ax,NEXT_ROM_SEG		;     prepare for next chunk

;
;  Do not search if the area has been eXcluded/Included/EMS/RAM/ROM by the user
;
	mov	bx,ds
	shr	bx,8			; index into 4K page
	cmp	cs:[Page4K][bx],0	;Q: Did user specify this page excluded/EMS/RAM?
	jnz	short no_more_ram	; Y: don't feel for RAM!

					; M002 - Start
;;;	mov	bx,ds:0A0H		; get current word
;;;	push	bx			; save it
;;;	mov	cx,ds:0A2H		; get following word
;;;	push	cx			; save it
;;;	not	bx

	mov	bx, ds:0A2H		; save word at ds:A2H
	mov	cx, ds:0A0H

	; 
	; Let us ensure that the value we're going to write out to the bus 
	; is not going to contain FCH as we're going to preset the bus to 
	; 0FCH before reading it back.
	;
	cmp	cx, 0303h		; Q: is neg cx = FCFCH
	jne	@f			; N: fine
	inc	cx			; Y: change cx to some other value
@@:

	not	cx			; neg word at ds:A0H
	push	cx			; save it for future comparison
	xchg	ds:0A0H, cx		; write this negated word to ds:A0
					; and save ds:A0h in cx

;;;	mov	word ptr ds:0A0H,bx	; try to clear word

					; M002 - End

	mov	word ptr ds:0A2H,0FFFFh ; charge up data bus
;
;  the instructions following and preceeding the xchg... below
;  are carefully chosen to not contain the value in cx as part of the 
;  instruction.
;
	cld				;;; preset the bus to 0FCh
	cld				;;; preset the bus to 0FCh
	cld				;;; preset the bus to 0FCh
	cld				;;; preset the bus to 0FCh

;;;	mov	cx,DS:0A0H		; M002
	xchg	ds:0A0H, cx		; M002: restore word at ds:A0H and get
					; M002: current value in cx

	cld				;;; preset the bus to 0FCh
	cld				;;; preset the bus to 0FCh
	cld				;;; preset the bus to 0FCh
	cld				;;; preset the bus to 0FCh
	cld				;;; preset the bus to 0FCh
	cld				;;; preset the bus to 0FCh
	cld				;;; preset the bus to 0FCh
	cld				;;; preset the bus to 0FCh
	cld				;;; preset the bus to 0FCh
	cld				;;; preset the bus to 0FCh
	cld				;;; preset the bus to 0FCh
	cld				;;; preset the bus to 0FCh

					; M002 - Start
	mov	ds:0A2H,bx		; restore to it's original value

	pop	bx			; get value that was written to 
					; ds:A0h in bx
	cmp	bx, cx			; Q: was it really written out
	jne	short no_more_ram	;  N: leave
	
;;;	cmp	bx,cx			;Q: RAM here ?
;;;	pop	bx			; restore following word
;;;	mov	ds:0A2H,bx		; to it's original value
;;;	pop	bx			; restore test word
;;;	mov	ds:0A0H,bx		; to it's original value
;;;	jne	short no_more_ram	;  N: leave
					; M002 - End

					;  Y: RAM - keep looking
	add	dx,NEXT_ROM_SEG		;     increment length count
	cmp	ax,LAST_RAM_SEGMENT	;Q: last RAM location ?
	jbe	short ram_loop		;  N: continue searching
	mov	ds,ax			;  Y: no more searching
no_more_ram:
;
	mov	ax,ds			;  get current segment
	or	dx,dx			;Q: any RAM found ?
	jnz	short ram_found		;  Y: set RAM found & chk DS seg again
					;  N:
	add	ax,NEXT_ROM_SEG		; AX -> next one to check
	popf
	clc				; set no RAM
	jmp	short ram_exit		;     and leave
;
ram_found:
	popf
	stc
ram_exit:
	pop	ds
	pop	cx
	ASSUME	ds:_DATA
	ret
CheckForMappedRAM	endp

;---------------------------------------------------------------------------
;
; ExcludePS2Options - Find PS/2 Option addresses
;
;   ExcludePS2Options(EXPS2PDevTab,EXPS2PIFile)
;
; ENTRY:
;	Know we are on a PS/2 system
;
; EXIT:
;	AX == 0
;	    ERROR (usually INVALID POSCardTable (bad TabelRev))
;
;	AX != 0
;
; USES:	EAX,ECX,EDX
;
; NOTE: Ported from win386 3.0 sources.
;
;----------------------------------------------------------------------------

ExcludePS2Options	proc	near

	enter	8,0

EXPS2TotOptions 	equ  dword ptr [ebp-4]
EXPS2Flags		equ  dword ptr [ebp-8]

EXPS2F_FndOpt		equ  00000000000000000000000000000001b
EXPS2F_FndOptBit	equ  0

	push	ds
	push	esi
	push	edi
	push	ebx

	mov	ax, cs
	mov	ds, ax
	lea	esi, PS2DATA		; ds:esi -> PS2DATA

	xor	eax,eax
	mov	EXPS2Flags,eax
	cld
	lodsw				; Get TotalOptions
.erre	TotalOptions EQ 0
	mov	EXPS2TotOptions, eax
	lodsw				; Get table revision
.erre	TabelRev EQ 2
	cmp	ax,CUR_PS2_TABLE_REV
	jne	Bad_Rev

	xor	eax, eax		; Card number
Card_Loop:
	push	eax

	or	al, ADAPTER_ENB
	cli
	out	ADAPTER_POS, al		; Enable Card

	jmp	$+2
	jmp	$+2

	mov	edx, ID_ADDR_LO 	; Get Card ID
	in	al, dx

	jmp	$+2
	jmp	$+2

	mov	ah, al
	inc	edx
	in	al, dx
	xchg	ah, al			; ID now in ax

	btr	EXPS2Flags,EXPS2F_FndOptBit
	mov	ecx, EXPS2TotOptions
	push	esi			; Save ptr to Option Tables

Option_Loop:
	cmp	ax, [esi.OptID] 	; This card?
	je	short Found_Option
Continue_Scan:
	movzx	ebx, [esi.LookupCnt]	; # Entries in table to skip
	lea	esi, [esi.LookupTab]	; Point to table
	shl	ebx, 1			; Two bytes per entry
.erre (SIZE MemAddr) EQ 2
	add	esi, ebx		; Skip the table
	loop	Option_Loop

IFDEF DEBUG
	cmp	ax,0FFFFh
	je	short No_Adap
	or	ax,ax
	jz	short No_Adap
	bt	EXPS2Flags,EXPS2F_FndOptBit
	jc	short No_Adap

;;	trace_out "No entry in WIN386.PS2 for adapter #AX found in slot # ",NO_EOL

	pop	esi
	pop	eax
	push	eax
	push	esi
	inc	eax

;;	trace_out "#AX"

No_Adap:
ENDIF


End_Option_Loop:
	pop	esi
	mov	al, ADAPTER_DSB
	out	ADAPTER_POS, al		; Disable setup
	sti
	pop	eax			; Card number
	inc	eax
	cmp	eax, MAX_CARDS		; Done all cards?
	jb	short Card_Loop 	; On to the next one
	jmp	OK_exit

Found_Option:
	bts	EXPS2Flags,EXPS2F_FndOptBit
	push	eax
	push	ecx
	push	esi
	add	esi, 2			; Toss ID word
.erre OptID    EQ 0
.erre POS2Mask EQ (OptID + 2)
	mov	edi, 4			; Number of POS bytes
	mov	edx, ID_ADDR+2		; First POS byte
	xor	ebx, ebx		; Table index
POS_Loop:
	xor	eax,eax
	cld
	lodsw				; Get mask and count
.erre POS2Shft EQ (POS2Mask + 1)
.erre POS3Shft EQ (POS3Mask + 1)
.erre POS4Shft EQ (POS4Mask + 1)
.erre POS5Shft EQ (POS5Mask + 1)
	mov	ecx, eax
	xchg	ch, cl			; cl gets shift count
	or	ah, al
	jz	short Ignore_Byte	; Stuff this one
	in	al, dx			; Get POS byte
	and	al, ch			; Mask it
	ror	al, cl			; Shift it
	or	bl, al			; Or into index
Ignore_Byte:
	inc	edx			; Next POS byte
	dec	edi
	jnz	short POS_Loop

	cld
	xor	eax,eax
	lodsw				; # entries in table
.erre LookUpCnt EQ (POS5Shft + 1)
.erre LookUpTab EQ (LookUpCnt + 2)
	cmp	ebx, eax		; Index in range?
	jae	short ContinueJ 	; No, ignore

	shl	ebx, 1			; Offset in table
.erre (SIZE MemAddr) EQ 2
	movzx	eax, word ptr [esi+ebx] ; Get entry
.erre PGLen EQ (StartPg + 1)
	xor	ecx, ecx
	mov	cl, ah			; Number of 4k pages here
	xor	ah, ah
    ;
    ; EAX is starting 4k page number
    ; ECX is a count of 4K pages to be marked as excluded starting at EAX
    ;
    ; Note that we know start page # is <= 0FFh since its value is stored
    ; in a byte
    ;
	jecxz	ContinueJ		; Nothing to do.......
	mov	edx,eax
	add	edx,ecx
	dec	edx			; Last page of range
if 0
	cmp	eax,[End_VM_Page]
	jae	short EPS2O10
	debug_out "Exclude start page out of range #eax ExcludePS2Options"
	mov	eax,[End_VM_Page]	; Move start up
EPS2O10:
endif

	cmp	edx,100h
	jb	short EPS2O20
					; Exclude count out of range. 
	mov	edx,0FFh		; Move end down
EPS2O20:

	sub	edx,eax
	jc	short ContinueJ
	inc	edx			; Corrected count
	mov	ecx,edx

	lea	edi, page4k

SetExLoop:
	or	byte ptr [edi][eax], INUSE
	inc	eax
	loop	SetExLoop

ContinueJ:
	pop	esi
	pop	ecx
	pop	eax
	jmp	Continue_Scan

Bad_Rev:
	xor	eax, eax		; Bad PS/2 table rev
	jmp	short Bye

OK_Exit:
	mov	eax, 1
Bye:
	pop	ebx
	pop	edi
	pop	esi
	pop	ds
	leave
	ret

ExcludePS2Options	endp

;**
;
; ExcludeEISAOptions - Find EISA Option addresses
;
;    ExcludeEISAOptions
;
; ENTRY:
;	Know we are on an EISA system
;
; EXIT:
;	page4k is initialized with the memory locations of the EISA expansion
;	boards
;
;	AX == 0
;	    ERROR
;
;	AX != 0
;
; USES:	EAX, ECX
;	
;
ExcludeEISAOptions	proc	near

	push	ds
	push	esi
	push	edi
	push	ebx

	mov	ax, cs
	mov	ds, ax			; DS -> LAST

	mov	cl, 1			; start slot #
EISASlotLp:
	push	cx
	mov	ax, 0D800h
	int	15h			; read slot
	pop	cx

	jc	ChkErr

	test	dl, GSI_HasMemory	; Q: does this slot have a mem entry
	jz	SkipSlot		; N: skip this slot and try next.

	;
	; This slot has one or more memory entries. We need to execute the
	; 'Read Fucntion Configuration Information' to retrieve the data 
	; block for each function. Note the number of expansion board 
	; functions was returned in DH by the previous int 15 AX = D800h.
	;

	mov	ch, dh			; ch = funtion number
NextFunc:
	xor	esi, esi
	mov	ax, 0D801h		; Read Fucntion Config. Information
	mov	si, OFFSET LAST:EISAdata
	int	15h

	jc	SkipFunc		; unexpected error. Try next func.

	test	[esi.GSI_FuncInfo],GSI_FI_IsMem
					; Q: memory info follows?
	jz	SkipFunc		; N: Try next func.

	test	[esi.GSI_FuncInfo],GSI_FI_IsCFGFreeFrm
					; Q: is slot info Free Form 
	jnz	SkipFunc		; Y: try next func

	lea	esi,[esi.GSI_Mem_Info]
	push	ecx
	mov	ecx, MAX_MEM_ENTS
EISAMemLp:
	mov	eax,dword ptr [esi.GSI_Mem_Addr256]
	and	eax,00FFFFFFh
	movzx	ebx,[esi.GSI_Mem_SizeK]
	shl	eax,8			; Byte addr of start
	shl	ebx,10			; Size in bytes
	add	ebx,eax
	dec	ebx			; Last byte of range
	shr	eax,12			; Page # of start
	shr	ebx,12			; Page # of last page of range
	cmp	eax,00000100h		; Start >= page 100?
	jae	short NextMem		; Yes, not interesting
	cmp	ebx,0A0h		; End Below lowest page?

	jb	short NextMem		; Yes, not interesting
	
	;
	; Range is at least partly in the page [End_VM_Page]-FF  region
	;

	cmp	eax,0A0h
	jae	short NoStartMov
	mov	eax,0A0h		; Move start up to A0

NoStartMov:
	cmp	ebx,000000FFh
	jbe	short NoEndMov
	mov	ebx,000000FFh		; Move end down
NoEndMov:
	sub	ebx,eax
	jc	short NextMem		; Range underflow
	inc	ebx

	;
	; Exclude EBX 4K pages starting at page EAX
	;

	push	ecx
	lea	edi, page4k
	mov	ecx,ebx

SetExLoopEISA:
	or	byte ptr [edi][eax], INUSE
	inc	eax
	loop	SetExLoopEISA
	pop	ecx

NextMem:
	test	[esi.GSI_Mem_Conf], GSI_Mem_Cnf_More
	jz	short SkipFuncP
	add	esi,SIZE GSI_Mem_Ent
	dec	ecx
	jnz	EISAMemLp
	pop	ecx			; Hit MAX_MEM_ENTS without seeing 
					; Last mem ent slot #CL 
	jmp	short SkipFunc

ChkErr:
	mov	al, ah
	cmp	al,EISA_Err_EmptySlot
	je	short SkipSlot
	cmp	al,EISA_Err_InvalSlot
	je	short EISAEX_Exit
;;	debug_out "Unexpected get SHORT slot info error #AL on slot #CL ExcludeEISAOptions"
	jmp	short EISAEX_Fail

SkipFuncP:
	pop	ecx   		; restore slot and function.

SkipFunc:
	dec	ch		; Next lower function
	jnl	NextFunc	; valid functions are 0..n

SkipSlot:
	inc	cl
	jmp	EISASlotLp

EISAEX_Exit:
	mov	eax, 1
EISAEX_Done:
	pop	ebx
	pop	edi
	pop	esi
	pop	ds
	ret

EISAEX_Fail:
	xor	eax,eax
	jmp	short EISAEX_Done

ExcludeEISAOptions	endp

;========================================================================
;
; 	Procedure	: LastChanceScan
;
;	Inputs		: edx = 4k page to scan
;	Output		: update page4k array appropriately
;
;	Notes:
;		This is called with edx ranging from c0 to ef from the
;	routine findwindowlocations.
;
;=========================================================================
	public	LastChanceScan

LastChanceScan	proc	near

	push	ds
	push	es
	push	bp
	sub	sp, 256/8
	mov	bp, sp

	call	IsHighSetPage		; Included by HighScan code?
	jc	LCS_Exit		; Yes, don't check it again

	cmp	cs:[page4K][edx], INUSE ; Already think it's a ROM?
	je	LCS_Think_Its_A_ROM	; Yes, check for special ROMS

	cmp	cs:page4k[edx],0      	; Anybody know about this page?
	jne	LCS_Exit		; Yes, skip

	pushad
	cld

	mov	di, ss
	mov	es, di			; es -> stack
	or	eax, NOT 0
	mov	cx, 256/32
	mov	di, bp
	rep	stosd			; Zero all bit values

	mov	di, cs
	mov	es, di			; es -> LAST
	lea	di, cs:LastChanceBuf	; Caller knows this is valid

;;	mov	esi, edx
;;	shl	esi, 12 		; ESI -> Lin mem of page
	shl	edx, 8
	mov	ds, dx			; ds = 4K page seg addr
	xor	si, si
	mov	cx, 1000h/4
	rep movsd			; Copy from suspect to buffer

	sub	si, 2			; Back up source 1 word
	sub	di, 4			; Back up dest 1 DWORD
	std				; BACKWARDS!
	mov	cx, 1000h/4		; Number of dwords to compare
	xor	edx, edx		; 0 different bytes detected
	mov	eax, DWORD PTR [si-2]	; Initialize the xor value

LCS_Scan_Backwards:
;
;   Prime the bus with the inverse of the previous value to try to detect
;   bus noise.
;
	xor	eax, -1 		; Try to make bus noise
	push	eax			; Put this value on the bus
	pop	eax			; Read it back for fun

	lodsw				; Get next word in table
	shl	eax, 16
	lodsw				; Get 2 words in 2 fetches
	cmp	eax, DWORD PTR es:[di]	; Q: Did it match buffer val?
	jne	LCS_Is_A_Hole		;    N: BUS NOISE!  It's a hole
					;    Y: It's consistant
	movzx	ebx, al
	btr	[bp], ebx
	adc	edx, 0
	movzx	ebx, ah
	btr	[bp], ebx
	adc	edx, 0
	ror	eax, 16
	movzx	ebx, al
	btr	[bp], ebx
	adc	edx, 0
	movzx	ebx, ah
	btr	[bp], ebx
	adc	edx, 0
	ror	eax, 16

LCS_Try_Next_Dword:
	sub	di, 4				; Subtract word from buf ptr
	loop	LCS_Scan_Backwards		; Scan the entire page

	cld					; Get things fwd again!

	cmp	edx, ROMChangeCount
	jb	SHORT LCS_Think_Its_A_Hole

;------------------------------------------------------------------------------
;
;   We think this is a ROM -- UGLY SPECIAL CASE CODE TIME!
;
;------------------------------------------------------------------------------

	popad					; Get all registers back

LCS_Think_Its_A_ROM:

	pushad					; And save them again

;
;   On Northgate machines, pages E0h-EFh are a duplication of the ROM at
;   F000h.  If the page at Exxx exactly matches the page at Fxxx then we WON'T
;   mark this as a ROM page.
;
	cmp	edx, 0E0h
	jb	SHORT LCS_Not_Special_1
	cmp	edx, 0EFh
	ja	SHORT LCS_Not_Special_1

;;	TestMem <[ebx+(10h*SIZE VM_Page_Struc).V86_Flags]>, V86_ROMPage
;;	jz	SHORT LCS_Not_Special_1

;;	cmp	cs:page4k[edx+10h], INUSE	; Is this ROM
;;	jne	SHORT LCS_Not_Special_1 	; No


	; suspect page may or may not have copied above--do it now to make sure

	mov	di, cs
	mov	es, di			; es -> LAST
	lea	di, cs:LastChanceBuf	; Caller knows this is valid

	mov	si, dx
	shl	si, 8
	mov	ds, si			; ds = 4K page seg addr
	xor	si, si
	mov	cx, 1000h/4
	rep movsd			; Copy from suspect to buffer

	lea	di, cs:LastChanceBuf		; Caller knows this is valid
	lea	si, [edx+10h]			; Page # + 10h for F000 range
;;	shl	esi, 12 			; Convert to lin address
	shl	si, 8
	mov	ds, si
	xor	si, si
	mov	cx, 1000h/4
	cld
	repe cmpsd				; See if they are the same

IFDEF DEBUG
	jne	SHORT LCS_Not_Special_1
	Trace_Out "LCS Special case # 1 on page #DL -- NOT excluded"
	jmp	SHORT LCS_Is_A_Hole
ELSE
	je	SHORT LCS_Is_A_Hole
ENDIF

LCS_Not_Special_1:

LCS_Not_A_Hole:
	popad
;;	Trace_Out "Last-chance detection found ROM at page #DL -- TELL RALPHL"
;;	SetFlag [ebx.V86_Flags], (V86_ROMPage+V86_LastChance)
	or	cs:[Page4K][edx],INUSE	; mark it used
LCS_Exit:
	add	sp, 256/8
	pop	bp
	cld
	pop	es
	pop	ds
	ret


;------------------------------------------------------------------------------
;
;   At this point, we got no bus noise and think it probably is a hole
;   because the change count was so low.  If the count is actually 0 then
;   we are POSITIVE that it is a hole or at least a *VERY* odd ROM so
;   we'll skip all special cases
;
;   DX at this point is the change count.  If it isn't 0 then we'll nuke
;   it since we don't really care -- The rest of this code handles special
;   cases.
;
;------------------------------------------------------------------------------

LCS_Think_Its_A_Hole:
	test	dx, dx
	jz	SHORT LCS_Is_A_Hole

	popad
	pushad

;
;   Special case for ROMs without signatures in the E000-EFFF range that have
;   only a TINY amount of useful stuff in the last few pages.  Starting with
;   ED00-EF00h we will exclude this page if page EC00h was excluded too.
;
;   This is a special case for the IBM LX 40 portable
;
	cmp	edx, 0EDh
	jb	SHORT LCS_Is_A_Hole
	cmp	edx, 0EFh
	ja	SHORT LCS_Is_A_Hole

;;	TestMem <VMPagesArr[0ECh*SIZE VM_Page_Struc].V86_Flags>, V86_ROMPage
	test	cs:[page4K][0ECH], INUSE
IFDEF DEBUG
	jz	SHORT LCS_Is_A_Hole
	Trace_Out "LCS special case include # 1 for page #DL"
	jmp	LCS_Not_A_Hole
ELSE
	jnz	SHORT LCS_Not_A_Hole
ENDIF

;
;   At this point we are as sure as we are ever going to be that this page is
;   really a hole.
;
LCS_Is_A_Hole:
	popad
	and	byte ptr cs:[Page4K][edx], NOT INUSE
	jmp	LCS_Exit

LastChanceScan	endp

;============================================================================
;==
;== IsHighSetPage:  Determines if page is covered by HighScan set range.
;==
;== Enter:
;==   edx = page number
;==
;== Exit:
;==   CY if page covered by HighSet range
;==
;============================================================================
	public	IsHighSetPage

IsHighSetPage proc near

	push	ds
	push	si

	push	cs
	pop	ds
	lea	si, cs:[HighSet+2]

IHSP_next:
	lodsw					; range start
	or	ax, ax				; Q: end of set?
	jz	short IHSP_nope

	shr	ax, 8				; paragraph to 4k page
	cmp	ax, dx				; Q: below the target page?
	ja	short IHSP_not_this_one 	; N: can't be in this range

	lodsw					; end of range
	shr	ax, 8
	cmp	ax, dx				; Q: => target page?
	jb	short IHSP_next 		; N: try next range

	stc					; Y: set CY flag & exit
	jmp	short IHSP_exit

IHSP_not_this_one:
	lodsw					; skip end of range
	jmp	short IHSP_next 		; and try the next one

IHSP_nope:
	clc					; page not in range, clr CY

IHSP_exit:
	pop	si
	pop	ds
	ret

IsHighSetPage endp


;----------------------------------------------------------------------------
;
; Procedure Name : IsCompaq
;
;	Output : Z  if COMPAQ
;		 NZ if not
;
;  Check to see if we're on a Compaq 386 machine
;
;----------------------------------------------------------------------------
IsCompaq 	proc near

	push	es
	push	ds
	push	di
	push	si
	push	cx

	les	di,cs:[pCOMPAQ]		; es:di points to possible COMPAQ signature
	push	cs
	pop	ds
	mov	si,offset szCOMPAQ 	; "03COMPAQ"
	mov	cx,8
	cld
	rep	cmpsb			;Q: COMPAQ 386 machine?

	pop	cx
	pop	si
	pop	di
	pop	ds
	pop	es

	ret

IsCompaq	endp

;  Added following procedures to check for EMM page & UMB conflicts
;  with Toshiba reserved areas (resume and HardRAM).
;  If conflicts found because of user-specified page frame base, set
;  invalid page frame base error.

TOSH_MID_SEG	equ	0F000H	; Toshiba machine ID byte segment
TOSH_MID_OFF	equ	0FFFAH	; Toshiba machine ID byte offset

TOSH_T5100	equ	027H	; Toshiba T5100 machine ID byte

;----------------------------------------------------------------------------
;
; Procedure Name : Toshiba_exclude
;
;	Output : DfltSet updated to reflect excluded areas for
;                Toshiba resume and HardRAM machines.
;
;  Check for resume & HardRAM machines.
;
;  Note: this routine should be incorporated into SetToshibaOptions in
;  init.asm (or that code should be moved here).  It wasn't done initially
;  since this code was cut and pasted while building release canidates for
;  MS-DOS 6 and it works in it's current form.
;
;----------------------------------------------------------------------------
Toshiba_exclude	proc near					

	cmp	toshiba_machine, 0	; On a Toshiba system?
	je	te_exit 		;   no, skip this code

;	Check for T5100 machine w/FAST ROM enabled.  If found, exclude
;	addresses E000-F000 from being used as EMS pages or UMBs.

	push	es
	push	ax
	push	dx
	mov	ax,TOSH_MID_SEG
	mov	es,ax			;   get segment containing Toshiba machine ID
	cmp	byte ptr es:[TOSH_MID_OFF],TOSH_T5100	;Q: Is this a T5100?
	jne	short Tosh_exc_xit	;N: exit

	mov	dx,8080h		;   I/O Port '8080' = Memory Map Reg
	in	al,dx			;   Read Memory Map Register Fast ROM bits
	test	al,04h			;Q: Is Fast ROM enabled for E000-F000
	jz      short Tosh_exc_xit	;Y: Exclude E000-F000, w/remapped AGS BIOS

excl_E000:

;	Now specify T5100 machine special exclude areas in
;	Toshiba misc. exclude section.	Support for T3300SL.

	mov	cs:[TOSHbeg],0E000H	;Y: E000-F000 must be excluded from EMM use
	mov	cs:[TOSHend],0EFFFH	;Y: E000-F000 must be excluded from EMM use

Tosh_exc_xit:							
	pop	dx
	pop	ax
	pop	es							
te_exit:
	ret							

Toshiba_exclude	endp						

;----------------------------------------------------------------------------
;
; Procedure Name : ToshInvPFbase
;
;	Output : PF_Base set to FREE, and invalid parameter msg
;                set if invalid page frame base error.
;                
;
;  Check for User-specifed page frame base conflict with
;  resume & HardRAM machines.
;
;----------------------------------------------------------------------------

ToshInvPFbase	proc near					

	cmp	toshiba_machine, 0	; On a Toshiba system?
	je	ToshInv_xit		;   no, skip this code

	cmp	gs:[PF_Base],FREE	;Q: Has the page frame base address been set?
	je	short ToshInv_xit	;N: No need to check for bad page frame base
	cmp	gs:[PF_Base],0D400h	;Y: Does user specified base cross E000?
	jl	short ToshInv_xit	;exit if no conflict with E000-F000 area
	mov	ax,gs:[PF_base]					
	mov	cx,4	       					
PF_Base_loop:  				;check each page for potential conflict
	xor	bx,bx						
	call	CheckEMSWindow	   				
	and	bx,INUSE	   				
	jnz	short Inv_PF_base	;if page reserved, flag as invalid parameter
	add	ax,400h			;bump to next page
	loop	PF_Base_loop	   				
	jmp	short ToshInv_xit   				

Inv_PF_base:			   				
	mov	gs:[PF_Base],FREE   				
	or	gs:[msg_flag],INV_PARM_MSG			
ToshInv_xit:							
	ret							

ToshInvPFbase	endp						

LAST	ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\wsinit.asm ===
.386p
	page 58,132
;=============================================================================
	title	W S I N I T - allocates/moves workspace to extended memory
;=============================================================================
;==
;== (C) Copyright MICROSOFT Corp. 1989-1991
;== (C) Copyright COMPAQ Computer Corp. 1989-1991
;==
;==	Title:	EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;==
;==	Module: WSInit - Allocates and moves workspace up to extended memory
;==
;==	Version: 1.00
;==
;==	Date:	September 16,1989
;==
;==	Author: Leo Cohen
;==
;=============================================================================
;==
;==	Change Log:
;==
;==	DATE	 REVISION	Description
;==	-------- --------	--------------------------------------------
;==     09/16/89 0.00	        Original
;==
;=============================================================================
;=============================================================================
;==	P U B L I C   D E C L A R A T I O N S
;=============================================================================
	public	WSInit
	public	WSMove
	public	GDT_Seg
	public	IDT_Seg
;=============================================================================
;==	E X T E R N A L  D E C L A R A T I O N S
;=============================================================================
LAST	segment
	extrn	SegTo24:near
	extrn	SetSegDesc:near
	extrn	SetPageEntry:near
	extrn	DoMoveBlock:near
	extrn	tempBuffer: BYTE
;QEMS	extrn	tempAllocMap:word
;QEMS	extrn	tempAllocMapLen:abs
	extrn	VxDInit:near

data_addr	DD	?
LAST	ends

;=============================================================================
;==	L O C A L   C O N S T A N T S
;=============================================================================
	include vdmseg.inc
	include vdmsel.inc
	include desc.inc
	include page.inc
	include oemdep.inc
	include romxbios.equ
	include emm386.inc
	include emmfunct.inc
	include	emmdata.inc
	include	allocmem.inc
	include	winemm.inc
;=============================================================================
;==	D A T A   S T R U C T U R E S
;=============================================================================
sMoveSegment	struc
 MSSource	dd	0       ; Source address
 MSDest		dd	0       ; Destination address
 MSSize		dd	0       ; Size of segment
sMoveSegment	ends
;=============================================================================
;==	L O C A	L   D A T A
;=============================================================================
R_CODE	segment
 GDT_Seg 	dw	seg GDT 	; current segment for GDT
 IDT_Seg 	dw	seg IDT 	; current segment for IDT
R_CODE	ends
;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
LAST	segment
	assume	cs:LAST,ds:_DATA,es:_DATA,gs:R_CODE
;=============================================================================
;==	L O C A	L   D A T A
;=============================================================================
;QLEO TSSLEO NumSegExt	equ	6	; number of segments reallocated to extended memory
NumSegExt	equ	5	; number of segments reallocated to extended memory
MoveSegmentList	sMoveSegment	NumSegExt dup (<>)

ARPT		dd 	255 dup(-1)

;==============================================================================
;==
;==  WSInit: Allocate work space and initialize GDT selectors with extended
;==	     memory addresses.  Does not move the segments to extended memory
;==	     due to _DATA not completely initialized until the EMS pool is
;==	     allocated.
;==
;==  Entry: (Real Mode)
;==
;==  Exit:
;==
;==============================================================================

WSInit	proc	near
	push	eax
	push	ebx
	push	edx
	push	esi

;
;  _TEXT segment
;
	mov	eax,offset end_of_TEXT
	mov	ebx,PARA_BOUNDARY
	mov	dx,VDMCA_GSEL
	shl	edx,16
	mov	dx,VDMC_GSEL
	mov	esi,offset LAST:MoveSegmentList
	call	AllocWS
	jc	WSIexit
	mov	ebx,cs:[esi].MSDest
	mov	gs:[p_TEXT],ebx

;
;  _DATA segment
;
;	mov	eax,offset end_of_DATA
;
; +++ CHNG  Add the space of the alternate register sets
	MOV	BX, [total_handles]

	mov	eax,size HandleTable_struc+size HandleName_struc+size HandleSaveMap_struc+size save_flag+size EMM_Handle

ifdef QEMS
	MOV	EAX, TYPE HandleTable_struc+TYPE HandleName_struc+TYPE EMS_window_struc * TOTAL_PF_WINDOWS+TYPE save_flag+TYPE EMM_Handle
endif
	MUL	BL			; Size of handle related data
	MOV	EDX, EAX
	MOV	BL, SIZE RegisterSet_struc
	MOV	AL, [total_register_sets]
	MUL	BL			; Size of total_register_sets

ifdef 910707
	add	edx,eax

	mov	eax,[MaxPTEindex]	; number of bits required for alloc_map
	shr	eax,2			; also for vcpi_alloc_map.
endif
	ADD	EAX, EDX
	ADD	eax,offset end_of_DATA
; +++
	mov	ebx,PARA_BOUNDARY
	mov	edx,VDMD_GSEL
	add	esi,size sMoveSegment
	call	AllocWS
	jc	WSIexit
	mov	ebx,cs:[esi].MSDest
	mov	gs:[p_DATA],ebx

	call	VxDInit

;
;  Fixup TSS selectors in GDT
;
	mov	eax,TSSLEN
	mov	ebx,cs:[esi].MSDest
	add	ebx,offset _DATA:[TSS]
	mov	gs:[pTSS],ebx
	mov	dx,TSSD_GSEL
	shl	edx,16
	mov	dx,TSS_GSEL
	call	UpdateGDT

;
;  STACK segment
;
	mov	eax,offset end_of_STACK
	mov	ebx,PARA_BOUNDARY
	mov	edx,VDMS_GSEL
	add	esi,size sMoveSegment
	call	AllocWS
	jc	WSIexit
	mov	ebx,cs:[esi].MSDest
	mov	gs:[pSTACK],ebx

ifdef TSSLEO	;QLEO
;
;  TSS segment
;
	mov	eax,TSSLEN
	mov	ebx,PARA_BOUNDARY
	mov	dx,TSSD_GSEL
	shl	edx,16
	mov	dx,TSS_GSEL
	add	esi,size sMoveSegment
	call	AllocWS
	jc	short WSIexit
	mov	ebx,cs:[esi].MSDest
	mov	gs:[pTSS],ebx
endif
;
;  IDT segment
;
	mov	eax,IDTLEN
	mov	ebx,PARA_BOUNDARY
	mov	edx,IDTD_GSEL
	add	esi,size sMoveSegment
	call	AllocWS
	jc	short WSIexit
	mov	ebx,cs:[esi].MSDest
	mov	gs:[pIDT],ebx

;
;  GDT segment
;
	mov	eax,GDTLEN
	mov	ebx,PARA_BOUNDARY
	mov	edx,GDTD_GSEL
	add	esi,size sMoveSegment
	call	AllocWS
	mov	ebx,cs:[esi].MSDest
	mov	gs:[pGDT],ebx

	cmp	gs:[NoEMSset],TRUE	; Q: Is NoEMS mode active?
	je      short WSIexit		; Y: done
	call	AllocARPTs		; N: allocate Page Tables for the
					;    Alternate Register sets.

WSIexit:
	pop	esi
	pop	edx
	pop	ebx
	pop	eax
	ret
WSInit	endp

;==============================================================================
;==
;==  WSMove: Move work space up to extended memory.
;==
;==  Entry: (Real Mode)
;==
;==  Exit:
;==
;==============================================================================
	assume	cs:LAST,ds:_DATA,es:_DATA,gs:R_CODE
WSMove	proc	near
	pushad
	push	ds
	push	es

; +++ Initialize alternate register sets	(PIW)
	MOV	ESI, OFFSET LAST:MoveSegmentList
	ADD	ESI, SIZE sMoveSegment	; Skip _TEXT
	; Update the size for _DATA to equal to the end of register set 0
	MOV	CS:[ESI].MSsize, OFFSET register_set
	ADD	CS:[ESI].MSsize, TYPE RegisterSet_struc
	MOV	EDI, CS:[ESI].MSDest	; Beginning of _DATA
	MOV	EBP, EDI		; Save the beginning of _DATA
	MOV	ESI, OFFSET register_set
	ADD	EDI, ESI		; Beginning of Register Set 0


	;
	; All register sets carry with them space for the context save area
	; i.e., the ems_window structure. The ems_window struc will now
	; be accessed via the EMS_window_ptr which will point to one of
	; the ems_window strucs in one of the register sets at any given
	; time. We shall initialize he EMS_window_ptr to point to reg set
	; 0. The actual ems_window struc will start from
	;
	; 	start of reg. set + saved_mapping + 4
	;
	; The 4 bytes is for the number_ems_window and the signature field
	; that is saved in the reg. set. See savewindowmapping in emm40.asm
	;
	; Note that EMS_window struc will have to be copied to EMS_window_ptr
	; This is done further below.
	;


;QEMS	mov	[EMS_window_ptr], offset register_set + saved_mapping+4

	ADD	EDI, TYPE RegisterSet_struc ; Beginning of Alternate Register Sets
	MOV	[SI].active, FALSE

	XOR	EAX, EAX
	MOV	AX, _DATA
	SHL	EAX, 4
	ADD	ESI, EAX
	MOV	DL, [total_register_sets]

	xor	ebx, ebx

init_next_reg_set:
	; CY = DoMoveBlock(ESI, EDI, CX)

	mov	ecx, offset register_set
	mov	eax, [ARPT+ebx*4]
	mov	[ecx].page_table_ptr, eax

	MOV	ECX, SIZE RegisterSet_struc	; Size to move
	CALL	DoMoveBlock
	ADD	EDI, ECX
	inc	ebx
	DEC	DL
	JNZ	init_next_reg_set

	MOV	SI, OFFSET register_set
	MOV	[SI].active, TRUE

	mov	eax, [page_tables]
	mov	[si].page_table_ptr, eax
ifdef QEMS
	mov	ax, [number_ems_windows]
	mov	[si].saved_mapping, ax
	mov	[si].saved_mapping+2, 'C'+'O'+'M'+'P'+'A'+'Q'
endif

; Initialize handle_table
	MOV	AX, LAST
	MOV	ES, AX
	ASSUME	ES: LAST

	MOV	EBX, EDI
	SUB	EDI, EBP		; Get the offset
	MOV	[hndl_tbl_ptr], EDI	; Save the beginning of handle_table
	MOV	DI, OFFSET tempBuffer

	MOV	AX, [end_of_base_memory_PTE]
	MOV	DX, [strtng_bs_wndw_PTE] ; STARTING_BASE_WINDOW_PTE
	SUB	AX, DX
	INC	GS:[handle_count]
	MOV	ES:[DI].base_PTE_index, FIRST_HANDLE_PTE
	MOV	ES:[DI].number_PTEs, 0
	CMP	[xma2ems], TRUE		; Q: Is it in XMA2EMS mode?	;@PIW
	JE	SHORT init_other_handles				;@PIW
	cmp	gs:[NoEMSset],TRUE		;Q: Is it in NoEMS mode?
	je	short init_other_handles	; Y: no base memory			;@PIW
;+++ PIW CUT begin
	MOV	ES:[DI].number_PTEs, AX

ifdef QEMS
	ADD	GS:[total_4k_pages], AX
	ADD	[first_free_handle_space], AX ; The first AX pages used	;@PIW

		; The conventional memory pool below 640k is now set up.
	mov	gs:[starting_conv_mem_PTE], DX ; STARTING_BASE_WINDOW_PTE
	mov	gs:[number_conv_mem_PTEs],ax

	cmp	ax,0
	je	SHORT init_other_handles

		; The window mapping for handle zero is now done.  First
		; the beginning window for handle zero is found.
	xor	esi,esi
	mov	cx,TOTAL_EMS_WINDOWS
EI_find_low_window:
	cmp	EMS_window_location[esi*2], DX ; STARTING_BASE_WINDOW_PTE
	je	short EI_map_in_handle_zero
	inc	si
	loop	EI_find_low_window

		; Now the actual handle and logical 4k page pairs are copied
		; in.  BX is the logical page which is 4 for every window.
EI_map_in_handle_zero:
	mov	cx,ax
	shr	cx,2
	XOR	DX, DX
EI_init_windows:
	mov	BYTE PTR EMS_window[esi*2+ESI].handle,0
	mov	EMS_window[esi*2+ESI].logical_4k_page, DX
	inc	si
	ADD	DX, 4
	loop	EI_init_windows
;+++ PIW CUT end
endif

init_other_handles:

	ADD	DI, TYPE HandleTable_struc
;QEMS	mov	ax,gs:[total_4k_pages]		; init number of handle PTEs;LEO
;QEMS	mov	[number_handle_PTEs],ax                                     ;LEO
	XOR	EAX, EAX
	MOV	AX, FREE			; handle_table <FREE, 0>
	MOV	CX, [total_handles]
	DEC	CX				; Skip handle 0
	cld
	REP	STOSD
	MOV	EDI, EBX
	XOR	ESI, ESI
	MOV	SI, ES
	SHL	ESI, 4
	ADD	ESI, OFFSET tempBuffer
	MOV	EAX, TYPE HandleTable_struc
	MOV	CX, [total_handles]
	MUL	CL
	MOV	CX, AX
	CALL	DoMoveBlock
	ADD	EDI, EAX
; Initialize handle_name
	MOV	EBX, EDI
	SUB	EDI, EBP			; Get the offset
	MOV	[hndl_nam_ptr], EDI		; Save the beginning of handle_name
	MOV	DI, OFFSET tempBuffer
	XOR	EAX, EAX
	MOV	CX, [total_handles]
	SHL	CX, 2				; 8 bytes for each handle
	REP	STOSD
	MOV	EDI, EBX
	XOR	ESI, ESI
	MOV	SI, ES
	SHL	ESI, 4
	ADD	ESI, OFFSET tempBuffer
	MOV	EAX, TYPE HandleName_struc
	MOV	CX, [total_handles]
	MUL	CL
	MOV	CX, AX
	CALL	DoMoveBlock
	ADD	EDI, EAX
; Initialize save_map
	MOV	EBX, EDI
	SUB	EDI, EBP			; Get the offset
	MOV	[save_map_ptr], EDI		; Save the beginning of handle_name
	MOV	DI, OFFSET tempBuffer
	MOV	EAX, FREE
	MOV	CX, [total_handles]
	shl	cx,2
	.errnz	size HandleSaveMap_struc-16
	REP	STOSD
	MOV	EDI, EBX
	XOR	ESI, ESI
	MOV	SI, ES
	SHL	ESI, 4
	ADD	ESI, OFFSET tempBuffer

	mov	EAX,size HandleSaveMap_struc
;QEMS	MOV	EAX, TYPE EMS_window_struc * TOTAL_PF_WINDOWS

	MOV	CX, [total_handles]
	MUL	CL
	MOV	CX, AX
	CALL	DoMoveBlock
	ADD	EDI, EAX

ifdef 910707
;
;  Initialize the allocation bit maps for EMS and VCPI
;
	mov	ebx,edi
	sub	ebx,ebp

	mov	eax,[MaxPTEindex]	; number of bits required for AllocMap
	shr	eax,3			; bytes for AllocMap
	mov	[AllocMapPtr],ebx	; pointer to AllocMap
	add	ebx,eax			; add size to get to
	mov	[VCPIAllocMapPtr],ebx	; pointer for the VCPIAllocMap
;
;  Intialize AllocMap by copying buffer set up by VDMINIT
;
	mov	si,seg LAST
	movzx	esi,si
	shl	esi,4
	add	esi,offset tempAllocMap	; initial information set up by VDMINIT
	mov	ecx,tempAllocMapLen
	call	DoMoveBlock
	add	edi,ecx			; next destination
	add	eax,eax			; size for both alloc maps
	sub	eax,ecx			; remaining amount to clear
	mov	edx,eax
;
;  Clear temporary buffer
;
	push	di
	push	es
	mov	di,cs
	mov	es,di
	mov	di,offset tempBuffer
	xor	eax,eax
	mov	ecx,1024
	rep stosd
	pop	es
	pop	di
;
;  Clear the rest of the allocation maps
;
	mov	si,seg LAST
	movzx	esi,si
	shl	esi,4
	add	esi,offset tempBuffer
WSAMloop:
	mov	ecx,edx			; number of bytes to be cleared
	sub	edx,1000h
	jl	short WSAMcont
	mov	ecx,1000h
WSAMcont:
	call	DoMoveBlock
	add	edi,ecx
	cmp	edx,0
	jg	short WSAMloop
endif

; Initialize whatever is needed
; +++
;
;  Six segments to move up (_TEXT, _DATA, **TSS**, IDT, and GDT) ;TSSLEO QLEO
;
	mov	esi,offset LAST:MoveSegmentList
	mov	cx,NumSegExt
WSNextSegment:
	call	MoveSegment
	add	esi,size sMoveSegment
	loop	WSNextSegment

	;
	; Copy the EMS_window struc to EMS_window_ptr
	;
ifdef QEMS
	mov	si, _DATA
	shl	esi, 4
	add	esi, offset EMS_window
	mov	edi, [EMS_window_ptr]
	add	edi, ebp
	movzx	ecx, [context_save_area_size]
	sub	ecx, 4
	call	DoMoveBlock
endif
;
;  Save page directory address for loading CR3
;
	mov	eax,[page_directory]
	mov	gs:[PageD_addr],eax

;
; The GDT and IDT pointers are setup up so that when CEMM gets turned on,
; the LGDT and LIDT instructions will have their correct pointers.
;
	mov	ax,seg GDT	; DS:SI point to the GDT's entry location.
	mov	ds,ax
	mov	si,GDTD_GSEL


	mov	ax,seg R_CODE	; ES:DI point to data strucutre used by the LGDT.
	mov	es,ax
	assume	es:R_CODE
	mov	di,offset R_CODE:GDT_Ptr

	movsd	; The 8 byte descriptor is copied over as is.
	movsd

;
; Since only the first 6 bytes of the GDT pointer is needed for the base and
; linear address, the upper 8 bits of the linear address must be copied down
; to its proper location.
;
	mov	al,byte ptr es:[GDT_Ptr][7]
	mov	byte ptr es:[GDT_Ptr][5],al

;
; The exact same operations are done for the IDT pointer.
;
	mov	si,IDTD_GSEL
	mov	di,offset R_CODE:IDT_Ptr
	movsd
	movsd
	mov	al,byte ptr es:[IDT_Ptr][7]
	mov	byte ptr es:[IDT_Ptr][5],al

	pop	es
	pop	ds
	popad
	ret
WSMove	endp

;==============================================================================
;==
;==  AllocWS: Allocate work space and initialize GDT selectors with extended
;==	      memory addresses. (NOTE: Make sure address is above HMA so that
;==	      the A20 state will not affect access to these data areas.
;==
;==  Entry: (Real Mode)
;==	EAX = Size of segment (work space)
;==	EBX = Alignment/boundary conditions
;==	EDX = DX is GDT entry, hiword is GDT alias
;==	ESI = MoveSegment structure pointer
;==
;==  Exit:
;==	R_CODE:[msg_flag],MEM_ERR_MSG - set if no memory available
;==
;==============================================================================
AllocWS	proc	near
	push	eax
	push	ebx

ifndef LC910610
AWSGetMemory:
	pop	ebx
	push	ebx
endif
;
;  Get extended memory for segment (work space)
;
	call	MemGet        		;Q: Enough memory available?
	jc	SHORT AWSnoMemory	; N: return error code (don't load)

ifndef LC910610
	cmp	ebx,110000h		;Q: Above the HMA?
	jb	short AWSGetMemory	; N: try again
endif
;
; Update destination address and size in sMoveSegment structure
;
	mov	cs:[esi].MSSize,eax	; save size of segment
	mov	cs:[esi].MSDest,ebx	; new extended memory address

	call	UpdateGDT		; update selector(s) in GDT

	mov	cs:[esi].MSSource,eax	; save old base address
	clc

AWSexit:
	pop	ebx
	pop	eax
	ret

AWSnoMemory:
	or	gs:[msg_flag],MEM_ERR_MSG
	stc
	jmp	short AWSexit

AllocWS	endp

;==============================================================================
;==
;==  UpdateGDT: Updates selector in GDT with new memory address.
;==
;==  Entry: (Real Mode)
;==	EAX = Size of object
;==	EBX = New memory address
;==	EDX = DX is GDT entry, hiword is GDT alias
;==
;==  Exit:
;==	EAX = Old base memory address
;== 	      GDT descriptor(s) updated.
;==
;==============================================================================
UpdateGDT proc	near
	push	ecx
	push	edi
	push	es

;
;  Acces to GDT via ES and get index for descriptor
;
	mov	di,seg GDT		; GDT not moved yet
	mov	es,di
	movzx	edi,dx			; index into GDT (selector)

;
;  Place limit of object in descriptor (assumes byte granularity)
;
	mov	ecx,eax
	dec	ecx
	cmp	ecx,10000h-1		;Q: Limit larger than 64K default?
	jbe	short UGcont		; N: continue
	mov	word ptr es:[edi][0],cx	; Y: limit 0.15
	shr	ecx,16
	or	byte ptr es:[edi][6],cl	; limit 16.19
UGcont:
;
;  Update source addresses in sMoveSegment structure from GDT
;
	movzx	eax,byte ptr es:[edi][4]; base 16.23
	shl	eax,16
	mov	ax,es:[edi][2]		; base 0.15

;
;  Now the descriptor in the GDT is updated.
;
	mov	es:[edi][2],bx		; new extended memory address
	ror	ebx,16
	mov	es:[edi][4],bl
	mov	es:[edi][7],bh
;
;  The alias selector is checked in the upper 16 bits of EDX.
;
	ror	edx,16
	cmp	dx,0			;Q: Alias descriptor?
	je	short UGexit		; N: all done
	movzx	edi,dx			; Y: index into GDT (alias)

;
;  Place limit of object in alias descriptor (assumes byte granularity)
;
	cmp	ecx,10000h-1		;Q: Limit larger than 64K default?
	jbe	short UGcont1		; N: continue
	mov	word ptr es:[edi][0],cx	; Y: limit 0.15
	shr	ecx,16
	or	byte ptr es:[edi][6],cl	; limit 16.19
UGcont1:
;
;  Update base address of alias
;

	mov	es:[edi][4],bl
	mov	es:[edi][7],bh
	ror	ebx,16
	mov	es:[edi][2],bx

UGexit:
	ror	edx,16
	pop	es
	pop	edi
	pop	ecx
	ret
UpdateGDT	endp

;==============================================================================
;==
;==  MoveSegment: Moves a segment to a destination address.
;==
;==  Entry: (Real Mode)
;==	ESI = MoveSegment structure pointer
;==
;==  Exit:
;==	CY set, if an error occured
;==
;==============================================================================
MoveSegment	proc	near
	push	ecx
	push	esi
	push	edi

;
;  Set up for moving segment: source,destination addresses and size
;
	mov	ecx,cs:[esi].MSsize
	mov	edi,cs:[esi].MSdest
	mov	esi,cs:[esi].MSsource

	call	DoMoveBlock		;Q: Was the move succesful?
	jc	SHORT MSerror		; N: error

	pop	edi
	pop	esi
	pop	ecx
	ret

MSerror:
	pop	edi
	pop	esi
	pop	ecx
	ret
MoveSegment	endp


;---------------------------------------------------------------------------
;
;	Procedure Name	: AllocARPTs
;
;	Allcates 1 4K page for each alternate register set and saves the
;	linear address of these pages in the table ARPTs
;
;--------------------------------------------------------------------------

AllocARPTs	proc	near

	push	cx
	xor	cx, cx
	xor	edx,edx

	mov	esi, [page_tables]	; esi - address of page table 0

	mov	cl, [total_register_sets]

ARPTnext:
	mov	eax, 4*1024		; eax - size of block = 4K
	mov	ebx, PAGE_BOUNDARY	; ebx  - need block on 4K boundary

	call	MemGet			; get block
	jc	short ARPTnomem		; not enuff mem
					; ebx - address of block
	mov	edi, ebx
	mov	[ARPT][edx*4], edi	; store address in ARPT
	inc	edx
	push	cx
	mov	cx, PAGE_SIZE
					; move cx bytes from esi to edi
	call	DoMoveBlock  		; initialize this to current PT0
	pop	cx
	jc	short ARPTnomem
	loop	ARPTnext

ARPTdone:
	pop	cx
	ret

ARPTnomem:
	or	gs:[msg_flag], MEM_ERR_MSG
	stc
	jmp	short ARPTdone

AllocARPTs 	endp
LAST	ends				; end of segment

	end				; end of module

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\lhvxd\debug.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp. 1989-1991
;
;******************************************************************************

;******************************************************************************
;
;   Assumes_Fall_Through
;
;   DESCRIPTION:
;	Used for debugging purposes only.  It will generate an error if
;	the IP <> the specified label.
;
;   PARAMETERS:
;	Label_Name = Name of label to fall-through to
;
;------------------------------------------------------------------------------

Assumes_Fall_Through MACRO L
IF2
IF (L - $) GT 3
%OUT ERROR:  Fall through to &L invalid
.ERR
ENDIF
ENDIF
		     ENDM


;******************************************************************************
;
;   Assert_VM_Handle
;
;   PARAMETERS:
;	Handle_Register = Register that contains a VM handle
;
;   ASSUMES:
;	Debug_Test_Valid_Handle does not destroy any registers or flags
;
;   EXIT:
;	NOTHING MODIFIED (not even flags)
;
;------------------------------------------------------------------------------

Assert_VM_Handle MACRO R
IFDEF DEBUG
	push	ebx
	mov	ebx, R
	VMMcall Debug_Test_Valid_Handle
	pop	ebx
ENDIF
	ENDM




;******************************************************************************
;
;   Trace_Out
;
;------------------------------------------------------------------------------

Trace_Out MACRO S, nocrlf
	LOCAL	Str_Off
IFDEF DEBUG
_LDATA SEGMENT
Str_Off db	S
IFB <nocrlf>
	db	0Ah,0Dh
ENDIF
	db	0
_LDATA ENDS

	pushfd
	pushad
	mov	esi, OFFSET32 Str_Off
	VMMcall Out_Debug_String
	popad
	popfd
ENDIF
	ENDM


;******************************************************************************
;
;   Debug_Out
;
;------------------------------------------------------------------------------

Debug_Out MACRO S
	LOCAL	Skip_Int1
IFDEF DEBUG
	pushfd
	Trace_Out   <S>
	VMMcall Test_Debug_Installed
	jz	SHORT Skip_Int1
	int	1
Skip_Int1:
	popfd
ENDIF
	ENDM


;******************************************************************************
;
;   Queue_Out
;
;------------------------------------------------------------------------------

Queue_Out MACRO S, V1, V2
	LOCAL	Str_Off
IFDEF DEBUG

_LDATA SEGMENT
Str_Off db S, 0Ah,0Dh, 0
_LDATA ENDS

	pushfd
	push	esi
IFNB <V1>
    IF	TYPE V1 GT 0
	push	dword ptr V1
    ELSE
	push	V1
    ENDIF
ELSE
	push	eax		; dummy value1
ENDIF
IFNB <V2>
    IF	TYPE V2 GT 0
	push	dword ptr V2
    ELSE
	push	V2
    ENDIF
ELSE
	push	ebx		; dummy value2
ENDIF
	mov	esi, OFFSET32 Str_Off
	VMMcall Queue_Debug_String
	pop	esi
	popfd
ENDIF
	ENDM






;******************************************************************************
;
;   Assert_Ints_Disabled
;
;------------------------------------------------------------------------------

Assert_Ints_Disabled MACRO
	LOCAL	OK

IFDEF DEBUG
	pushfd
	test	WORD PTR [esp], IF_Mask
	jz	SHORT OK
	Debug_Out "ERROR:  Ints enabled at Assert_Ints_Disabled"
	Fatal_Error
OK:
	popfd
ENDIF

	ENDM


;******************************************************************************
;
;   Assert_Ints_Enabled
;
;------------------------------------------------------------------------------

Assert_Ints_Enabled MACRO
	LOCAL	OK

IFDEF DEBUG
	pushfd
	test	WORD PTR [esp], IF_Mask
	jnz	SHORT OK
	Debug_Out "ERROR:  Ints disabled at Assert_Ints_Enabled"
	Fatal_Error
OK:
	popfd
ENDIF

	ENDM


;******************************************************************************
;
;   Assert_Cur_VM_Handle (Register)
;
;   DESCRIPTION:
;
;   ENTRY:
;
;   EXIT:
;
;   USES:
;
;==============================================================================

Assert_Cur_VM_Handle MACRO R
	LOCAL	OK
IFDEF DEBUG
	push	ebx
	mov	ebx, R
	VMMcall Debug_Test_Cur_VM
	pop	ebx
ENDIF
	ENDM




Assert_Client_Ptr MACRO Reg

IFDEF DEBUG
	push	ebp
	mov	ebp, Reg
	VMMcall Validate_Client_Ptr
	pop	ebp
ENDIF

	ENDM




;******************************************************************************


Dump_Struc_Head MACRO
IFDEF DEBUG
	Trace_Out "  Base    Address   Offs     Value  Field name"
ENDIF
	ENDM

Dump_Struc MACRO Base, X
IFDEF DEBUG
	pushfd
	pushad
	lea	esi, [Base]
	mov	ecx, X
	lea	edx, [esi+ecx]

IF SIZE X EQ 6
	mov	bx, WORD PTR [edx+4]
	mov	eax, DWORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX  #BX:#EAX  &X"
ELSE
IF SIZE X EQ 4
	mov	eax, DWORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX  #EAX  &X"
ELSE
IF SIZE X EQ 2
	mov	ax, WORD PTR [edx]
	Trace_Out "#ESI  #EDX  #CX      #AX  &X"
ELSE
	mov	al, BYTE PTR [edx]
	Trace_Out "#ESI  #EDX  #CX        #AL  &X"
ENDIF
ENDIF
ENDIF

	popad
	popfd
ENDIF
	ENDM

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\lhvxd\dosmgr.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1991
;
;   Title:	DOSMGR.Inc - Public services for DOSMGR
;
;   Version:	1.00
;
;   Date:	29-Nov-88
;
;   Author:	ARR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   29-Nov-1988 ARR Original
;
;==============================================================================

Begin_Service_Table DOSMGR

DOSMGR_Service	DOSMGR_Get_Version, LOCAL
DOSMGR_Service	_DOSMGR_Set_Exec_VM_Data, LOCAL
DOSMGR_Service	DOSMGR_Copy_VM_Drive_State, LOCAL
DOSMGR_Service	_DOSMGR_Exec_VM, LOCAL
DOSMGR_Service	DOSMGR_Get_IndosPtr, LOCAL
DOSMGR_Service	DOSMGR_Add_Device
DOSMGR_Service	DOSMGR_Remove_Device
DOSMGR_Service	DOSMGR_Instance_Device
DOSMGR_Service	DOSMGR_Get_DOS_Crit_Status, LOCAL
DOSMGR_Service	DOSMGR_Enable_Indos_Polling, LOCAL

End_Service_Table DOSMGR

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\lhvxd\instance.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1991
;
;   Title:	instance.inc -
;
;   Version:	1.00
;
;   Date:	19-Jul-1988
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   19-Jul-1988 RAL Original
;
;==============================================================================

;
; Defines the size of the instance owner array. The MAX allowed instance page
;    number = MAX_INST_PAGES - 1
;
MAX_INST_PAGES		equ	100h
MIN_LOADHI_INST_PAGE    equ	0a0h

;
;   This structure defines a single instance field in a particular instance
;   page.  The Inst_Buf_Offset+VM.CB_Inst_Buf_Offset points to the instance
;   buffer area for a given VM.  VM_Address is the linear address in the
;   VM address space of the item.  The Lead_Byte_Count specifies a count at
;   the start of the item which is byte aligned and must be moved with a
;   movsb instruction.	After this move, both the VM address and instance
;   buffer address will be dword aligned (this field may be 0).  The Field_
;   Length specifies the remaining number of BYTES to move starting at the
;   dword aligned addresses.  Note that this may not be a multiple of four,
;   the Length MOD 4 specifies an odd byte area at the end that must be moved
;   a byte at a time (this field may be 0).  The Flags are currently unused.
;
LoadHi_Instance_Map_Struc  STRUC
IMap_Inst_Buf_Offset	dd	?		; Offset to VM's instance buffer
IMap_VM_Address 	dd	?		; Linear VM address of inst data
IMap_Field_Length	dw	?		; DWord aligned field length
IMap_Lead_Byte_Count	db	?		; Initial length to dword align
IMap_Flags		db	?		; special flags
LoadHi_Instance_Map_Struc  ENDS

;
; This bit being set means that the IMap_VM_Address field is an address in
;   the PhysLinear region instead of in the VM since wrap pages are not
;   necessarily mapped in the VM when instance swaps occur on them.
;
IMap_F_Wrap_Pg		equ	00000001B	; Is INSTANCE page in wrap area
IMap_F_Wrap_PgBit	equ	0

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\lhvxd\instinit.asm ===
TITLE	Win386 LoadHi_Instance Data Manager Initialization Routines
;
;   (C) Copyright MICROSOFT Corp. 1986-1991
;
;   Module:   INSTINIT.ASM - LoadHi_Instance Data manager init
;
;   Version:  0.00
;
;   Date:     7/7/88
;
;   Author:   ARR   -  created for VMM/MMGR
;
;   Change log:	 AC   7/24/90  Adapted for LoadHi VXD.
;	
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   04/21/88  0.00
;
.lfcond 				; list false conditionals
.386p

	include VMM.inc
	include opttest.inc
	include debug.inc
	include instance.inc

VxD_DATA_SEG

Extrn	LoadHi_Inst_Page_Owner_Actual:dword	;Array of instance page owners
Extrn   FirstUMBPage:dword			;first UMB page (lowest addr)
Extrn	ActualAddInstanceItem:dword		;original _AddInstanceItem service
Extrn	CB_LoadHi_Inst_Buf_ptr:dword		;offset in CB for Instance data buffer
Extrn	CB_LoadHi_Inst_Hand:dword		;handle of above buffer

; define an equate 'LoadHi_Inst_Page_Owner' so that we can access the owner
; array as if it was defines from page numbers starting at 0 rather than 0A0H.

LoadHi_Inst_Page_Owner equ LoadHi_Inst_Page_Owner_Actual - 0A0h * 4


	public	LoadHi_Instance_Map_Table_Size_Actual
	public	LoadHi_Inst_VM_Buf_Size
	public	LoadHi_Instance_MapLaddr
	public	LoadHi_Instance_Map_Table_Ptr_Actual
	public	LoadHi_Instance_MapHand
	public	LoadHi_Instance_SnapLaddr
	public	LoadHi_Instance_SnapHand

ALIGN 4

LoadHi_Inst_VM_Buf_Size	  dd	0	; Size of VM instance data buffer in pages

LoadHi_Instance_MapLaddr  dd	0	; Linear address of instance description
					;  buffer
LoadHi_Instance_MapHand	  dd	0	; hMem of instance description buffer

LoadHi_Instance_SnapLaddr dd	0	; Linear address of instance snap shot
					;  buffer
LoadHi_Instance_SnapHand  dd	0	; hMem of instance snap shot buffer


;
; These arrays are used to manage instance data page faults. It is indexed by page
;   numbers from 0-(MAX_INST_PAGES-1).
;
;   For pages which are not instance pages both array entries will be 0.
;
;   LoadHi_Instance_Map_Table_Ptr contains pointer to the first LoadHi_Instance_Map_Struc
;	for the page.
;
;   The actusl tables will have slots only from page 0A0H onwards, but we will
;   use an equate to offset the start to page 0 so we can index into the arrays
;   directly.


LoadHi_Instance_Map_Table_Ptr_Actual	 dd (MAX_INST_PAGES-0A0h) dup (0)
LoadHi_Instance_Map_Table_Ptr equ LoadHi_Instance_Map_Table_Ptr_Actual - 0A0h * 4


;
;   LoadHi_Instance_Map_Table_Size specifies the number of LoadHi_Instance_Map_Strucs
;	for the page
;

LoadHi_Instance_Map_Table_Size_Actual 	 db (MAX_INST_PAGES-0A0H) dup (0)
LoadHi_Instance_Map_Table_Size equ LoadHi_Instance_Map_Table_Size_Actual - 0A0h

IFDEF DEBUG

public	LoadHi_InstDataListHd

ENDIF

LoadHi_Inst_VM_Buf_End 	   dd	0	; Size of VM instance data buffer in bytes
LoadHi_InstDataListHd	   dd  -1	; Head of INIT instance list
LoadHi_Instance_MapCurrOff dd	0	; Current end of Instance description buffer
LoadHi_Instance_MapLimit   dd	0	; Limit of Instance description buffer
LoadHi_InstanceAnalysisDone dd  0	; set to -1 after doing analysis


VxD_DATA_ENDS
;----------------------------------------------------------------------------;

VxD_IDATA_SEG


VxD_IDATA_ENDS
;----------------------------------------------------------------------------;
VxD_CODE_SEG

	Extrn	LoadHi_Instance_VMDestroy:near
	Extrn	LoadHi_Instance_VMSuspend:near
	Extrn	LoadHi_Map_Pages:near


;
; LoadHi_Instance_Create_VM - Create a new VMs instance data buffer
;
; ENTRY:
;	EBX -> New VM CB
;
;	NOTE THAT WE CANNOT DO AN Assert_VM_Handle on this VM handle
;	    yet
;
; EXIT:
;	Carry Clear
;	    OK
;	Carry Set
;	    Error (insufficient memory)
; USES:
;	All but EBX,ESI,EDI,EBP
;

BeginProc LoadHi_Instance_Create_VM,PUBLIC

	push	esi
	push	edi

    	call	LoadHi_Map_Pages	;map the pages in

    ; if loadhi instance data is present, exit with success.


	mov	esi,[LoadHi_InstDataListHd]
	inc	esi
	jz	SHORT ICVOK


    ;
    ; Allocate the instance buffer.  Note that the buffer will be locked when
    ; the VM is initially resumed.
    ;

	xor	eax,eax
	VMMCall _PageAllocate,<[LoadHi_Inst_VM_Buf_Size],PG_VM,ebx,eax,eax,eax,eax,0>
	or	eax,eax
	jz	short ICVFail
	mov	edi,CB_LoadHi_Inst_Buf_Ptr
	mov	[ebx][edi],edx
	mov	edi,CB_LoadHi_Inst_Hand
	mov	[ebx][edi],eax

    ;
    ; Initialize the instance buffer from the instance snap shot
    ;

	mov	edi,edx
	mov	ecx,[LoadHi_Inst_VM_Buf_Size]

;;;;	    shl     ecx,12		    ; * 4096 bytes per page
;;;;	    shr     ecx,2		    ; / 4 for size in DWORDS

    ; Combine above instructions

	shl	ecx,10
	mov	esi,[LoadHi_Instance_SnapLaddr]
	cld
	rep	movsd

     ;
     ; Now we want to reset the P_PRES bit of all the pages that are in 
     ; include any LoadHi_Instance data.
     ;
	
     	mov	ecx,MAX_INST_PAGES - 0A0H	;possible number of pages
	mov	esi,OFFSET32 LoadHi_Instance_Map_Table_Size
	mov	edx,MIN_LOADHI_INST_PAGE	;array starts at this page

VMMakeNotPresentLoop:

	cmp	byte ptr [esi][edx],0		;num inst items in page
	jz	SHORT VMNoInstItemInThisPage	;not instance page
	mov	eax,NOT P_PRES
	push	edx
	push	ecx
	VMMcall	_ModifyPageBits,<ebx,edx,1,eax,0,PG_HOOKED,0>
	pop	ecx
	pop	edx

VMNoInstItemInThisPage:

       inc	dx
       loop	VMMakeNotPresentLoop

ICVOK:

	clc
ICVDone:
	pop	edi
	pop	esi
	ret

ICVFail:
	stc
	jmp	short ICVDone

EndProc LoadHi_Instance_Create_VM
;******************************************************************************
;									     
;   LoadHi_Instance_Resume_VM						
;										
;   Lock the per VM instance data buffer

;   ENTRY:
;	EBX is VM Handle of VM being destroyed
;
;   EXIT:
;	None
;
;   USES:
;	EAX, Flags
;*****************************************************************************
BeginProc LoadHi_Instance_Resume_VM, PUBLIC

	push	esi
	push	edi

    ;
    ; Lock instance buffer
    ;

	mov	edi,CB_LoadHi_Inst_Hand
	mov	esi,[ebx][edi]
	or	esi,esi			;any instance data buffer allocated?
	jz	SHORT RV_NoInstanceData	;no.
	VMMCall _PageGetSizeAddr,<esi,0>
	or	eax,eax
IFDEF DEBUG
	jnz	short MRVM30
	debug_out "_PageGetSizeAddr failed on INST handle _LoadHi_Resume_VM"
MRVM30:
ENDIF
	jz	SHORT IVR_Fails
	VMMCall _PageLock,<esi,eax,0,0>
	or	eax,eax
	jz	SHORT IVR_Fails

RV_NoInstanceData:

	clc				;success
	jmp	SHORT IVR_Ret

IVR_Fails:

	trace_out "Couldn't lock Instance buffer _MMGR_Resume_VM"
	stc

IVR_Ret:

	pop	edi
	pop	esi	
	ret

EndProc LoadHi_Instance_Resume_VM
;----------------------------------------------------------------------------;
; LoadHi_Suspend_VM:							     ;
;									     ;
; Reassigns instance page ownership to sys vm for all pages owned by this    ;
; instance and also unlocks the pages containing the VM's copy of the        ;
; instace areas.							     ;
;									     ;
; ENTRY:								     ;
;	EBX -> VM CB							     ;
; EXIT:									     ;
;	None								     ;
; USES:									     ;
;	All but EBX,ESI,EDI,EBP						     ;
;----------------------------------------------------------------------------;
BeginProc LoadHi_Instance_Suspend_VM,PUBLIC

    ;
    ; reassign owner ship
    ;

    	push	esi
	push	edi
	call	LoadHi_Instance_VMSuspend


; at this point unlock the instance pages

	mov	edi,CB_LoadHi_Inst_Hand
	mov	esi,[ebx][edi]
	or	esi,esi			;any instance data ?
	jz	SHORT IVD_Exit		;no.
	VMMCall _PageGetSizeAddr,<esi,0>
	or	eax,eax
IFDEF DEBUG
	jnz	short MSVM30
	debug_out "_PageGetSizeAddr failed on INST handle _MMGR_Suspend_VM"
MSVM30:
ENDIF
	jz	SHORT IVD_Fail
	VMMCall _PageUnLock,<esi,eax,0,PageMarkPageOut>
	or	eax,eax
	jnz	SHORT IVD_Exit

IVD_Fail:

	trace_out "Couldn't unlock Instance buffer _MMGR_Suspend_VM"
	stc
	jmp	SHORT IVD_Ret

IVD_Exit:
	clc					; success
IVD_Ret:
	pop	edi
	pop	esi
	ret

EndProc LoadHi_Instance_Suspend_VM
;----------------------------------------------------------------------------;
;
; LoadHi_Instance_Destroy_VM - Destroy VMs instance data buffer
;
; ENTRY:
;	EBX -> VM CB
; EXIT:
;	None
; USES:
;	All but EBX,ESI,EDI,EBP
;----------------------------------------------------------------------------;
BeginProc LoadHi_Instance_Destroy_VM,PUBLIC

    ;
    ; Remove VM from instance owner list
    ;

    	push	esi
	push	edi
	call	LoadHi_Instance_VMDestroy

    ;
    ; Free the instance buffer
    ;
	xor	eax,eax
	mov	edi,CB_LoadHi_Inst_Hand
	xchg	eax,[ebx][edi]
	mov	edi,CB_LoadHi_Inst_Buf_ptr
	mov	[ebx][edi],0FFFFFFFFh    ; Addr that will page fault

	or	eax,eax			;was this allocated at all ?
	jz	SHORT @f		;no.
	VMMCall _PageFree,<eax,0>
@@:

	pop	edi
	pop	esi
	ret

EndProc LoadHi_Instance_Destroy_VM
;----------------------------------------------------------------------------;
; LoadHi_Take_Instance_SnapShot:					     ;
;									     ;
; This routine is called at Sys_VM_Init	and creates a snap shot of the 	     ;
; instance buffer.							     ;
;----------------------------------------------------------------------------;
BeginProc LoadHi_Take_Instance_SnapShot,PUBLIC


    ; if there is no loadhi instance data to be instanced than get out.

	mov	esi,[LoadHi_InstDataListHd]
	inc	esi
	jz	LHTISS_OK


    ;
    ; Allocate the LoadHi_Instance Snap Shot buffer.
    ;
	xor	esi,esi
    ;
    ; NOTE THAT THIS BUFFER SHOULD BE FIXED. If we crash, we restore the state
    ;	of instance data to the state saved in the snap shot buffer. We do not
    ;	want to get page faults while we're doing this in LoadHi_Instance_WIN386_Exit.
    ;
	VMMCall _PageAllocate,<[LoadHi_Inst_VM_Buf_Size],PG_SYS,esi,esi,esi,esi,esi,PageFixed>

	or	eax,eax
	jz	LHTISS_Fatal2
	mov	[LoadHi_Instance_SnapLaddr],edx
	mov	[LoadHi_Instance_SnapHand],eax
    ;
    ; Init the snap shot from current low memory of SYS_VM_Handle
    ;
	mov	ecx,MAX_INST_PAGES	; one beyond last page number
COPLp:
	cld
	push	ecx

	dec	ecx			; Count is 1-MAX_INST_PAGES,
					;  pages are 0-(MAX_INST_PAGES - 1)
	mov	edx, LoadHi_Instance_Map_Table_Ptr[ecx*4]
	movzx	ecx, LoadHi_Instance_Map_Table_Size[ecx]
	jecxz	COCont
COLp:
	push	ecx

	mov	edi, [LoadHi_Instance_SnapLaddr]
	add	edi, [edx.IMap_Inst_Buf_Offset]
    ;
    ; For HMA instance pages IMap_VM_Address is in the Phys Linear region so
    ;	it doesn't matter if the HMA is currently ON or OFF in the SYS VM
    ;
	mov	esi, [edx.IMap_VM_Address]
	movzx	ecx, [edx.IMap_Lead_Byte_Count]
	rep	movsb
    ; NOTE here that we know ECX == 0
	or	cx, [edx.IMap_Field_Length]
	jz	short CONext
	shr	ecx,2
	rep	movsd
    ; NOTE here that we know ECX == 0
	or	cx, [edx.IMap_Field_Length]
	and	ecx,011b		; Mask to byte part
	rep	movsb
CONext:
	pop	ecx
	add	edx, size LoadHi_Instance_Map_struc
	loop	 COLp

COCont:
	pop	ecx
	dec	ecx
	cmp	ecx,0A0H		 ;loop goes from 100h to A1H
	ja	SHORT COPLp		 ;dec ECX at top of loop makes it go
					 ;from FFh to A0H

    ;
    ; Allocate SYS_VM_Handle's instance buffer
    ;
    	VMMcall	Get_Sys_VM_Handle		; EBX has SYS_VM_Hanlde
	xor	eax,eax

	VMMCall _PageAllocate,<[LoadHi_Inst_VM_Buf_Size],PG_VM,ebx,eax,eax,eax,eax,PageLocked>

	or	eax,eax
	jz	SHORT LHTISS_Fatal3
	mov	esi,CB_LoadHi_Inst_Buf_ptr
	add	esi,ebx
	mov	[esi],edx
	mov	esi,CB_LoadHi_Inst_Hand
	add	esi,ebx
	mov	[esi],eax
    ;
    ; Copy instance snap shot into SYS_VM_Handle's instance buffer
    ;
	mov	esi,[LoadHi_Instance_SnapLaddr]
	mov	edi,edx
	mov	ecx,[LoadHi_Inst_VM_Buf_End]
	add	ecx,3
	shr	ecx,2
	cld
	rep	movsd

LHTISS_OK:

	xor	eax,eax
	dec	eax
LHTISS_Done:
	ret

LHTISS_Fatal2:
	debug_out "Allocation failure LoadHi_Inst snap _LoadHi_InstanceInitComplete"
IFDEF DEBUG
	jmp	short LHTISS_FXX
ENDIF

LHTISS_Fatal3:
	debug_out "Allocation failure VM1 LoadHi_Inst _LoadHi_InstanceInitComplete"

LHTISS_FXX:

	FATAL_ERROR



EndProc LoadHi_Take_Instance_SnapShot

IFDEF	DEBUG
;----------------------------------------------------------------------------;
; LoadHi_Debug_Query:							     ;
;									     ;
; Displays debug information about the data that is being instanced.	     ;
;----------------------------------------------------------------------------;

BeginProc	LoadHi_Debug_Query,PUBLIC

	mov	edi,[LoadHi_InstDataListHd]
	inc	edi			;is there a list
	jz	LHDQ_None		;no.
	xor	ebx,ebx
	Trace_Out "  Start     Length"
	Trace_Out " "


	mov	ecx,MAX_INST_PAGES	; last page number

LHDQ_NextPage: 

	cld
	push	ecx
	dec	ecx			; Count is 1-MAX_INST_PAGES,
					;  pages are 0-(MAX_INST_PAGES - 1)
	mov	edx, LoadHi_Instance_Map_Table_Ptr[ecx*4]
	movzx	ecx, LoadHi_Instance_Map_Table_Size[ecx]
	jecxz	LHDQ_TryNextPage

LHDQ_NextItemInPage:

	push	ecx

	mov	esi, [edx.IMap_VM_Address]
	movzx	ecx, [edx.IMap_Lead_Byte_Count]
	movzx	eax, [edx.IMap_Field_Length]
	add	eax,ecx

	cmp	ebx,1111b
	jne	SHORT @f
	VMMcall In_Debug_Chr
	jz	SHORT LHDQ_Exit
	Trace_Out " "
	Trace_Out " "
	Trace_Out "  Start     Length"
	Trace_Out " "
	xor	ebx,ebx
@@:
	Trace_Out "#ESI   #EAX"
	inc	ebx

	pop	ecx
	add	edx, size LoadHi_Instance_Map_struc
	loop	LHDQ_NextItemInPage

LHDQ_TryNextPage:

	pop	ecx
	dec	ecx
	cmp	ecx,0A0H
	ja	LHDQ_NextPage
	jmp	SHORT LHDQ_Exit

LHDQ_None:
	Trace_Out "No Instance data in UMBs"
LHDQ_Exit:
	ret

EndProc LoadHi_Debug_Query

ENDIF	;DEBUG
;----------------------------------------------------------------------------;
VxD_CODE_ENDS
;----------------------------------------------------------------------------;
VxD_ICODE_SEG


IFDEF DEBUG

public	AllocateLoadHi_InstanceMapStruc

ENDIF

;----------------------------------------------------------------------------;
;
; LoadHi_Add_Instance_Item
;
;  Add LoadHi_Instance item to instance list
;
;
;----------------------------------------------------------------------------;
BeginProc LoadHi_Add_Instance_Item,PUBLIC


	enter	0,0

AIILoadHi_InstPTR equ	dword ptr [ebp+8]	; Pointer to instance structure
AIIflags   equ	dword ptr [ebp+12]		; Flags

	push	esi
	push	edi
	push	ebx

IFDEF DEBUG
	cmp	AIIflags,0
	jz	short AII10
	debug_out "Non-Zero flags _AddLoadHi_InstanceItem"
AII10:
ENDIF

	mov	edx,AIILoadHi_InstPTR

; If the linear address is below the linear address of the first UMB page
; then chain off the next guy.

	mov	eax,[edx.InstLinAddr]
	shr	eax,12				;make it a page number
	cmp	eax,[FirstUMBPage]		;is it in UMB area
	jae	SHORT AIIDataInUMBArea		;yes.

	pop	ebx
	pop	edi
	pop	esi
	leave
	jmp	[ActualAddInstanceItem]	;chain on

AIIDataInUMBArea:

;
; Check the type field
;
	mov	eax,[edx.InstType]
	cmp	eax,INDOS_Field
	jz	short AIITypeOK
	cmp	eax,ALWAYS_Field
	jz	short AIITypeOK
	debug_out "_AddLoadHi_InstanceItem bad InstType #eax in #edx"
	mov	[edx.InstType],ALWAYS_Field	; Set unknown type to always
AIITypeOK:
IFDEF DEBUG
	xor	eax,eax
	cmp	[edx.InstLinkF],eax
	jnz	short AII12
	cmp	[edx.InstLinkB],eax
	jz	short AII13
AII12:
	debug_out "_AddLoadHi_InstanceItem Links not 0 #edx"
AII13:
ENDIF

    ;
    ; Instance items cannot live above or = page MAX_INST_PAGES
    ;
	mov	eax,[edx.InstLinAddr]
	cmp	eax,MAX_INST_PAGES SHL 12
	jae	AIIFail1

    ; If the Instance item is below the page that we will manage, we will
    ; do nothing with this.

    	cmp	eax,MIN_LOADHI_INST_PAGE SHL 12
	jb	AIIChainON

    ; check to see if the end of the Instance area goes past what we can manage

	add	eax,[edx.InstSize]
	cmp	eax,MAX_INST_PAGES SHL 12
	ja	AIIFail1

	mov	ebx,0FFFFFFFFh

    ;
    ; Sort this item onto instance list
    ;

	mov	esi,[LoadHi_InstDataListHd]
	cmp	esi,ebx
	jz	short AIINewHd			; Fist entry
	mov	eax,[edx.InstLinAddr]
	cmp	eax,[esi.InstLinAddr]
	jbe	short AIINewHd
AIIPutLp:
	mov	ecx,[esi.InstLinkF]
	cmp	ecx,ebx
	jz	short AIINewTail
	mov	esi,ecx
	cmp	eax,[esi.InstLinAddr]
	ja	short AIIPutLp
	mov	[edx.InstLinkF],esi
	mov	ecx,edx
	xchg	ecx,[esi.InstLinkB]
IFDEF DEBUG
	cmp	ecx,0FFFFFFFFh
	jnz	short AII20
	debug_out "Missed head detection _AddLoadHi_InstanceItem"
AII20:
ENDIF
	mov	[ecx.InstLinkF],edx
	mov	[edx.InstLinkB],ecx
	jmp	short AIIOK

AIINewTail:
	mov	[edx.InstLinkB],esi
	mov	[edx.InstLinkF],ebx
	mov	[esi.InstLinkF],edx
	jmp	short AIIOK

AIINewHd:
	mov	[LoadHi_InstDataListHd],edx
	mov	[edx.InstLinkB],ebx
	mov	[edx.InstLinkF],esi
	inc	esi
	jz	short AIIOK
	dec	esi
	mov	[esi.InstLinkB],edx
AIIOK:

; if the Inatance data analysys has already been done, we should redo the 
; analysis at this point.

	cmp	[LoadHi_InstanceAnalysisDone],0 ;is it still to be done ?
	jz	SHORT AIIOK1			 ;yes

; we are going to call 'LoadHi_InstanceInitComplete' again, we must initialize
; all tables that the first call to the routine had changed and also free 
; up temporary pages that it had allocated.


; initialize the LoadHi_Instance_Map_Table_Ptr_Actual & _Size_Actual tables

	mov	edi,OFFSET32 LoadHi_Instance_Map_Table_Ptr_Actual
	xor	eax,eax
	mov	ecx,MAX_INST_PAGES - 0A0H
	rep	stosd
	mov	ecx,MAX_INST_PAGES - 0A0H
	mov	edi,OFFSET32 LoadHi_Instance_Map_Table_Size_Actual
	rep	stosb

; free the instance description buffer pages.

	mov	eax, [LoadHi_Instance_MapHand]
	VMMcall	_PageFree,<eax,0>

; now to the instance buffer analysis all over again.

	call	Loadhi_InstanceInitComplete


AIIOK1:

	xor	eax,eax
	dec	eax
AIIDone:
	clc				;we have taken care of this call
AIIRet:
	pop	ebx
	pop	edi
	pop	esi
	leave
	ret

AIIChainON:
	stc				;must chain this call on
	jmp	SHORT AIIRet

AIIFail1:
	debug_out "_AddLoadHi_InstanceItem LoadHi_Instance above MAX_INST_PAGES not supported #edx"
AIIFail:
	xor	eax,eax
	jmp	short AIIDone

EndProc LoadHi_Add_Instance_Item
;----------------------------------------------------------------------------;
;
; LoadHi_InstanceInitComplete - Complete initialization of CB and instance info
;
;     Finish LoadHi_Instance data init. Data list is complete.
;     Build and Set instance info in VM1 CB including LoadHi_Instance data buffer
;     CONTROL BLOCK NOW AT FINAL SIZE
;     Set owner of all instance pages to SYS_VM_Handle
;     Build and Set LoadHi_Instance snap shot buffer
;     Initialize VM1 state to final instance form
;     GLOBAL VM AREA NOW SET UP In FINAL form and First_VM_Page is now set
;     FREE the instance structures allocated by _Allocate_Global_VM_Data_Area
;----------------------------------------------------------------------------;
BeginProc LoadHi_InstanceInitComplete,PUBLIC

	enter	12,0

IICFlags 	equ  dword ptr [ebp-4]
IICLinAddr	equ  dword ptr [ebp-8]
IICSize		equ  dword ptr [ebp-12]

IICContRec	equ	00000000000000000000000000000001b
IICContRecBit	equ	0
IICNewTab	equ	00000000000000000000000000000010b
IICNewTabBit	equ	1

	mov	IICFlags,IICNewTab		; Init frame var

;
; First make a pass over the instance list coalescing adjacent blocks
;
	mov	esi,[LoadHi_InstDataListHd]
	inc	esi
IFDEF DEBUG
	jnz	short IIC10
	trace_out "_LoadHi_InstanceInitComplete no instance list"
IIC10:
ENDIF
	jz	IICOK
	dec	esi
IICCoalLp:
	mov	edi,[esi.InstLinkF]
	inc	edi
	jz	DEBFAR IICCoalDn
	dec	edi
	mov	eax,[esi.InstType]
	cmp	eax,[edi.InstType]	; Must be same type to coalesce
	jnz	short IICNext
	mov	eax,[esi.InstLinAddr]	; eax is start of esi
	mov	ebx,eax
	add	ebx,[esi.InstSize]	; ebx is end of esi
	mov	ecx,[edi.InstLinAddr] 	; ecx is start of edi
	mov	edx,ecx
	add	edx,[edi.InstSize]	; edx is end of edi
IFDEF DEBUG
	cmp	ebx,eax
	ja	short IIC20
	debug_out "_LoadHi_InstanceInitComplete entry is 0 size #esi"
IIC20:
	cmp	edx,ecx
	ja	short IIC30
	debug_out "_LoadHi_InstanceInitComplete entry is 0 size #edi"
IIC30:
	cmp	eax,ecx
	jbe	short IIC40
	debug_out "_LoadHi_InstanceInitComplete entries not sorted #esi > #edi"
IIC40:
ENDIF
	cmp	ebx,ecx 		; Exactly adjacent, or overlap?
	je	short IICAdjacent	; Exactly adjacent
	ja	short IICOverLap	; Overlap
IICNext:
	mov	esi,edi
	jmp	IICCoalLp

IICOverLap:
IFDEF DEBUG
	push	eax
	push	ecx
	mov	eax,[esi.InstLinAddr]
	mov	ecx,[esi.InstSize]
	trace_out "Odd Case, instance overlap #esi @#EAX len #ECX"
	mov	eax,[edi.InstLinAddr]
	mov	ecx,[edi.InstSize]
	trace_out "                           #edi @#EAX len #ECX"
	pop	ecx
	pop	eax
ENDIF
	cmp	eax,ecx
	je	short IICMaxSize	; Start at same address, take Max size
	cmp	ebx,edx
	jae	short IICNextUnlink	; esi completely surrounds edi just
					;   eliminate edi
    ;
    ; new end of combined block at edx
    ;
	sub	edx,eax 		; edx is new size
	mov	[esi.InstSize],edx	; set new larger size
	jmp	short IICNextUnlink	; eliminate edi

IICMaxSize:
	mov	eax,[edi.InstSize]
	cmp	eax,[esi.InstSize]
	jbe	short IICNextUnlink	; esi completely surrounds edi just
					;   eliminate edi
	mov	[esi.InstSize],eax	; edi is bigger, replace esi size
	jmp	short IICNextUnlink	; eliminate edi

IICAdjacent:
	mov	eax,[edi.InstSize]
	add	[esi.InstSize],eax
IICNextUnlink:
	mov	eax,[edi.InstLinkF]
	cmp	eax,0FFFFFFFFh
	jz	short IICNNxt
	mov	[eax.InstLinkB],esi
IICNNxt:
	mov	[esi.InstLinkF],eax
	jmp	IICCoalLp

IICCoalDn:
    ;
    ; Allocate The first page of the LoadHi_Instance description buffer.
    ;
	xor	eax,eax
	VMMCall _PageAllocate,<1,PG_SYS,eax,eax,eax,eax,eax,<(PageFixed + PageZeroInit)>>
	or	eax,eax
	jz	IICFatal
	mov	[LoadHi_Instance_MapLimit],4096
	add	[LoadHi_Instance_MapLimit],edx
	mov	[LoadHi_Instance_MapCurrOff],edx
	mov	[LoadHi_Instance_MapLaddr],edx
	mov	[LoadHi_Instance_MapHand],eax
    ;
    ; Scan the instance list setting up instance data
    ;
	mov	esi,[LoadHi_InstDataListHd]
	mov	edi,[esi.InstLinAddr]
	shr	edi,12			; Prev page = Current page
	inc	esi			; Counter next instruction
IICBuildLp:
	dec	esi
	mov	ecx,[esi.InstLinAddr]
	mov	IICLinAddr,ecx
	mov	ecx,[esi.InstSize]
	mov	IICSize,ecx
IICBuildLp2:
	mov	ecx,IICLinAddr
	mov	ebx,ecx
	add	ebx,IICSize
	dec	ebx
	shr	ebx,12			; Page of last byte of item
	shr	ecx,12			; Page of first byte of item
	cmp	ecx,edi 		; New instance in same page as previos?
	jz	short IICContPg 	; Yes
    ;
    ; Starting new page in LoadHi_Instance_Map_Table arrays
    ;
IFDEF DEBUG
	cmp	ecx,MAX_INST_PAGES
	jb	short IICD15
	debug_out "IIC new Page #ecx out of range"
IICD15:
	cmp	LoadHi_Instance_Map_Table_Size[ecx],0
	jz	short IICD20
	debug_out "IIC Starting new Page #ecx, table struct not empty"
IICD20:
ENDIF
	or	IICFlags,IICNewTab
	mov	edi,ecx 		; Prev page = Current page
IICContPg:
	cmp	ecx,ebx 		; Crosses page bound?
	mov	ecx,IICLinAddr		; Assume it doesn't
	mov	ebx,IICSize
	je	short IICInPg		; NO
	mov	ebx,ecx
	shr	ebx,12
	inc	ebx
	shl	ebx,12
	mov	IICLinAddr,ebx		; Rest of item starts here
	sub	ebx,ecx 		; Size to page bound
	sub	IICSize,ebx
IFDEF DEBUG
	ja	short IICD30
	debug_out "IIC adjusted inst rec to 0 or neg size #esi"
IICD30:
ENDIF
	or	IICFlags,IICContRec
IICInPg:
	call	AllocateLoadHi_InstanceMapStruc
	mov	[edx.IMap_Flags],0
	mov	[edx.IMap_VM_Address],ecx
	shr	ecx,12

NotWrpLoadHi_Inst:
IFDEF DEBUG
	cmp	LoadHi_Instance_Map_Table_Size[ecx],0FFh
	jne	short IICD35
	debug_out "IIC overflowing size count page #ecx"
IICD35:
ENDIF
	inc	LoadHi_Instance_Map_Table_Size[ecx]
	btr	IICFlags,IICNewTabBit	; Set pointer?
	jnc	short IICNoPtr		; No
	mov	LoadHi_Instance_Map_Table_Ptr[ecx*4],eax
IICNoPtr:
	cmp	ebx,4			; Less than a dword?
	jb	SHORT ICCAllByte  	; Yes, do all with byte move
	testmem [edx.IMap_VM_Address],0011b	; Dword aligned in VM?
	jz	short ICCAllDWord	; Yes no lead stuff

	mov	eax,[edx.IMap_VM_Address]
	and	eax,0000011b
	sub	eax,4
	neg	eax			; Need to go this far to get to DWORD
					;  Align in VM
	mov	ecx,ebx
	sub	ecx,eax
	cmp	ecx,4			; Only worth doing if get at least
					;   one DWORD out of it.
	jb	short ICCAllByte	; Forget it, do all with byte move
	mov	[edx.IMap_Lead_Byte_Count],al ; To get to Dword align
	sub	ebx,eax 		; What's left
	mov	[edx.IMap_Field_Length],bx
	mov	ecx,[LoadHi_Inst_VM_Buf_End]
	mov	ebx,ecx
	and	ebx,0000011b
	sub	ebx,4
	neg	ebx			; Need to go this far to get to DWORD
					;  in LoadHi_Inst buf
	cmp	ebx,eax
	je	short IICSmAlign	; What luck
	ja	short IICSmAdjust	; Just need move inst buf offset
					;   up a little
	add	ecx,ebx 		; ecx now dword aligned
	add	ecx,4			; up to next dword
	sub	ecx,eax 		; and down to same align as VM address
	jmp	short IICSmAlign

IICSmAdjust:
	sub	ebx,eax 		; Move inst buf offset by this much
	add	ecx,ebx
IICSmAlign:
	mov	[edx.IMap_Inst_Buf_Offset],ecx
	movzx	eax,[edx.IMap_Field_Length]
	add	ecx,eax
	movzx	eax,[edx.IMap_Lead_Byte_Count]
	add	ecx,eax
	xor	ebx,ebx
	jmp	short ICCDnStEFl

ICCAllDWord:
	mov	ecx,[LoadHi_Inst_VM_Buf_End]
	add	ecx,3			; Go to dword align in inst buf
	and	ecx,11111111111111111111111111111100b
	mov	[edx.IMap_Inst_Buf_Offset],ecx
	mov	[edx.IMap_Field_Length],bx
	add	ecx,ebx
	xor	ebx,ebx
	mov	[edx.IMap_Lead_Byte_Count],bl
ICCDnStEFl:
	mov	[LoadHi_Inst_VM_Buf_End],ecx
	jmp	short ICCDnStFl

ICCAllByte:
	mov	[edx.IMap_Lead_Byte_Count],bl
	mov	ecx,[LoadHi_Inst_VM_Buf_End]
	mov	[edx.IMap_Inst_Buf_Offset],ecx
	add	[LoadHi_Inst_VM_Buf_End],ebx
	xor	ebx,ebx
	mov	[edx.IMap_Field_Length],bx
ICCDnStFl:
	btr	IICFlags,IICContRecBit
	jc	IICBuildLp2
	mov	esi,[esi.InstLinkF]
	inc	esi
	jnz	IICBuildLp
IICListDone:
    ;
    ; Set LoadHi_Inst_VM_Buf_Size from LoadHi_Inst_VM_Buf_End
    ;
	mov	eax,[LoadHi_Inst_VM_Buf_End]
	add	eax,0FFFh
	shr	eax,12
IFDEF DEBUG
	or	eax,eax
	jnz	short IICD10
	debug_out "Computed LoadHi_Inst_VM_Buf_Size of 0 _LoadHi_InstanceInitComplete"
IICD10:
ENDIF
	mov	[LoadHi_Inst_VM_Buf_Size],eax
    ;
    ; The instance map description buffer is now in its final linear address
    ;	location (in LoadHi_Instance_MapLaddr), we now need to set all of the
    ;	entries in the LoadHi_Instance_Map_Table_Ptr array by re-locating them.
    ;

	mov	edi,[LoadHi_Instance_MapLaddr]
	mov	esi,OFFSET32 LoadHi_Instance_Map_Table_Ptr + 0A0H*4
	mov	edx,OFFSET32 LoadHi_Instance_Map_Table_Size + 0A0H
	mov	ecx,MAX_INST_PAGES - 0A0H
	xor	eax,eax
IICRelocLp:
	cmp	byte ptr [edx],al		; Entry here?
	jz	short IICRelocSkp		; No, skip it
	add	dword ptr [esi],edi		; ReLocate
IICRelocSkp:
	add	esi,4
	inc	edx
	loop	IICRelocLp


    ; Set the instance owner of all instance pages to SYS_VM_Handle
    ;	Non-instance pages have owner 0.
    ;
    	VMMcall	Get_Sys_VM_Handle	; EBX = Sys_VM_Handle
	mov	eax, ebx		; EAX = Cur owner of Inst pages
	xor	ebx, ebx		; Non-Inst pages get 0 value
	mov	ecx, MAX_INST_PAGES	; # of pages to initialize
	mov	edi, offset32 LoadHi_Inst_Page_Owner ; EDI -> Base of table
	cld
IICStOwnLP:
	dec	ecx			; Page numbers are 0-10Fh
	cmp	LoadHi_Instance_Map_Table_Size[ecx],0 ; Instance page?
	jnz	short IICStOwnSet	; Yes, store SYS_VM_Handle
	xchg	eax,ebx 		; No, store 0
IICStOwnSet:
	mov	[edi][ecx*4], eax	; Set owner in table
	jnz	short IICOwnOK
	xchg	eax,ebx 		; Return values to correct regs
IICOwnOK:
	cmp	ecx,0A0H
	ja	SHORT IICStOwnLP

IICOK:

; mark a flag to record that we have completed the instance buffer analysis.
; If we get an AddInstanceItem call after this, we will have to redo the 
; analysis allover again.  This flag should be set even if we have no 
; instance data areas till now.

	mov	[LoadHi_InstanceAnalysisDone],-1
	xor	eax,eax
	dec	eax
	leave
	ret

IICFatal4:
	debug_out "_LoadHi_InstanceInitComplete Temp_VM_Data_Area outstanding"

	FATAL_ERROR

IICFatal3:
	debug_out "Allocation failure VM1 LoadHi_Inst _LoadHi_InstanceInitComplete"
IFDEF DEBUG
	jmp	short IICFXX
ENDIF
IICFatal2:
	debug_out "Allocation failure LoadHi_Inst snap _LoadHi_InstanceInitComplete"
IFDEF DEBUG
	jmp	short IICFXX
ENDIF
IICFatal:
	debug_out "Allocation failure LoadHi_Inst Descrip _LoadHi_InstanceInitComplete"
IICFXX:

	FATAL_ERROR

EndProc LoadHi_InstanceInitComplete
;----------------------------------------------------------------------------;

     

;
; AllocateLoadHi_InstanceMapStruc - Allocate an LoadHi_Instance_Map_Struc in the LoadHi_Instance
;		description buffer
;
; ENTRY:
;	None
;
; EXIT:
;	edx is (current) linear address of LoadHi_Instance_Map_Struc allocated
;	eax is offset into LoadHi_Instace description buffer of LoadHi_Instance_Map_Struc
;		allocated
;
; USES:
;	eax,edx,flags
;
BeginProc AllocateLoadHi_InstanceMapStruc,PUBLIC

	push	esi
	push	edi
	push	ebx
	push	ecx

AIMSTestAllo:
	mov	edx,[LoadHi_Instance_MapCurrOff]
	add	edx,SIZE LoadHi_Instance_Map_Struc
	cmp	edx,[LoadHi_Instance_MapLimit]
	jbe	short AIMSDoAllo
    ;
    ; Convert lAddrs to offsets
    ;
	mov	eax,[LoadHi_Instance_MapLaddr]
	sub	[LoadHi_Instance_MapCurrOff],eax
	sub	[LoadHi_Instance_MapLimit],eax

	VMMCall _PageGetSizeAddr,<[LoadHi_Instance_MapHand],0> ; Get size
	or	eax,eax
	jz	short AIMSFail
	inc	eax			; grow by one page
	VMMCall _PageReAllocate,<[LoadHi_Instance_MapHand],eax,PageZeroInit> ; Grow
	or	eax,eax
	jz	short AIMSFail
    ;
    ; Convert offsets back into lAddrs
    ;
	add	[LoadHi_Instance_MapLimit],4096
	add	[LoadHi_Instance_MapLimit],edx
	add	[LoadHi_Instance_MapCurrOff],edx
	mov	[LoadHi_Instance_MapLaddr],edx
	mov	[LoadHi_Instance_MapHand],eax
	jmp	short AIMSTestAllo

AIMSDoAllo:
	mov	edx,[LoadHi_Instance_MapCurrOff]
	add	[LoadHi_Instance_MapCurrOff],SIZE LoadHi_Instance_Map_Struc	; Do alloc
	mov	eax,edx
	sub	eax,[LoadHi_Instance_MapLaddr] ; Offset into LoadHi_Instance description buf
AIMSDone:
	pop	ecx
	pop	ebx
	pop	edi
	pop	esi
	ret

AIMSFail:
	debug_out "Fail grow LoadHi_Instance desc buff AllocateLoadHi_InstanceMapStruc"
	FATAL_ERROR


EndProc AllocateLoadHi_InstanceMapStruc
;----------------------------------------------------------------------------;
VxD_ICODE_ENDS

END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\lhvxd\copyinst.asm ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1990-1991
;
;   Title:	COPYINST.ASM
;
;   Version:	1.00
;
;   Date:	24-Jul-1990
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   24-Jul-1990 RAL Original
;   25-Jul-1990 RAL Updated documentation
;   26-Jul-1990 RAL Fixed 2 bugs
;
;==============================================================================
;
;   This procedure will copy instance data fields from the Windows/386 3.00
;   initialization data structure that specify instance data in Upper Memory
;   Blocks into a table inside of a LIMulator.	When Copy_Inst_Data returns
;   it will have filled in the LIMulator's table and removed the entries from
;   the Win386 initialization data structure.
;
;------------------------------------------------------------------------------

	.386p

	INCLUDE Int2FAPI.Inc


%OUT PUT SEGMENT DECLARATIONS HERE!

;******************************************************************************
;
;   Copy_Inst_Data
;
;   DESCRIPTION:
;	(See file header)
;
;   ENTRY:
;	CX = Maximum number of entries to copy (6 bytes each)
;	ES:DI -> Area to copy instance info into
;		 Table should be of size CX*6+4 (add 4 for term dword 0)
;	ESI = Value passed by Windows 3.00 to LIMulator shut down procedure
;
;   EXIT:
;	If carry flag is clear then
;	    Success!
;	    CX = Number of entries NOT used in table
;	    ES:DI -> Byte past null termination dword in table
;	else
;	    ERROR:  Not enough space in table for all instance items
;
;   USES:
;	DS, EAX, EBX, ECX, EDX, ESI, EDI, EBP, Flags
;
;==============================================================================

Copy_Inst_Data PROC NEAR

	cld

	mov	bx, si
	and	bx, 1111b
	shr	esi, 4
	mov	ds, si

	cmp	BYTE PTR [bx+4Bh], 1
	jne	CID_Success

	mov	esi, DWORD PTR [bx+26h]
	mov	ebx, esi
	shr	ebx, 4
	mov	ds, bx
	and	si, 1111b

;
;   At this point DS:SI -> Win386_Startup_Info_Struc
;
	push	ds
	push	si

	lds	si, [si.SIS_Instance_Data_Ptr]

	mov	ax, ds				; Just to be paranoid...
	or	ax, si
	jz	CID_Success

;
;   Now move all instance fields from the current table into our private
;   table.  This code will shift all instance fields that are not in the
;   Upper Memory region down.  If there are no instance regions remaining
;   after the loop then it will zero out the SIS_Instance_Data_Ptr in the
;   init data area's fake Int 2Fh data structure.
;
	push	si

	mov	bx, si

CID_Move_Data_Loop:
	lodsd
	test	eax, eax			; Q: At the end?
	jz	CID_At_End_Of_List

	mov	ebp, eax
	shr	ebp, 16
	shl	ebp, 4
	movzx	edx, ax
	add	ebp, edx

	cmp	ebp, 0A0000h			; Q: Is this in a UMB?
	jae	CID_Found_One			;    Y: Copy data into us
						;    N: Shift into correct pos
;
;   This entry does NOT specify instance data in a UMB.  Leave it in the
;   init data table.
;
	mov	DWORD PTR [bx], eax
	lodsw
	mov	WORD PTR [bx+4], ax
	add	bx, 6
	jmp	CID_Move_Data_Loop

;
;   This entry specifies instance data in a UMB.  Copy it into our
;   internal table if enough room remains.
;
CID_Found_One:
	dec	cx				; Q: Enough room left?
	jl	CID_Out_Of_Copy_Space		;    N: ERROR!

	stosd
	movsw
	jmp	CID_Move_Data_Loop

;
;   We're at the end of the list of instance regions.  We may have copied
;   all of the instance regions into our internal table.  If so, then zero
;   the SIS_Instance_Data_Ptr in the fake Int 2Fh startup info data structure
;   to indicate that there is no instance data.  Otherwise, null terminate
;   the table and leave the SIS_Instance_Data_Ptr alone.
;
CID_At_End_Of_List:
	pop	si				; SI->Start of original table
	cmp	bx, si				; Q: Has copy pointer moved?
	je	CID_None_Left_In_List		;    N: The table is empty
						;    Y: Still some in table
	mov	DWORD PTR [bx], eax		; Terminate original table
	add	sp, 4				; Junk DS and SI on stack
	jmp	CID_Success			; Return success!

;
;   All of the instance fields were in UMB's -- Zap the entire table
;
CID_None_Left_In_List:
	pop	si
	pop	ds				; DS:SI -> Startup info struc
	mov	[si.SIS_Instance_Data_Ptr], eax ; Zero instance table ptr

;
;   In all cases where we return with success, we must null terminate the
;   table.
;
CID_Success:
	xor	eax, eax
	stosd					; Terminate internal list

	clc					; Indicate that it worked
	ret

;
;   ERROR:  Out of space in internal table.  Clear stack and return
;	    with carry flag set to indicate an error.
;
CID_Out_Of_Copy_Space:
	add	sp, 6

	stc					; Indicate an error
	ret

Copy_Inst_Data ENDP


%OUT PUT SEGMENT DECLARATIONS HERE!


	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\xmsutils.asm ===
.386p
page	58,132
;******************************************************************************
	title	xmsutils.asm - XMS utility functions
;******************************************************************************
;
; (C) Copyright MICROSOFT Corp. 1992
;
; Title:	EMM386.EXE - MICROSOFT Expanded Memory Manager 386 Driver
;
; Module:	XMS memory utility functions
;
; Date: 	May 18, 1992
;
;******************************************************************************
;
;   Change log:
;
;     DATE    REVISION			DESCRIPTION
;   --------  --------	-------------------------------------------------------
;   5/18/92	1	initial code
;******************************************************************************
;
;   Functional Description:
;	This module implements utilities for the EMS/XMS pool sharing code
;	added to EMM386.
;
;******************************************************************************

page
;******************************************************************************
; INCLUDES
;******************************************************************************
include	vdmseg.inc
include vdmsel.inc
include vm386.inc
include	page.inc
include	emmfunct.inc
include	emmdata.inc
include emm386.inc
include debmac.inc

;******************************************************************************
; EXTERNALS
;******************************************************************************

_TEXT	segment
	extrn	CallRealModeRtn:near
ifdef DEBUG
	extrn	pTestDbgIns:far
	extrn	pDebugPrintf:far
endif
_TEXT	ends

R_CODE	segment
	extrn	XMMcontrol:DWORD
ifdef DEBUG
	extrn	rTestDbgIns:far
	extrn	rDebugPrintf:far
endif
R_CODE	ends

;******************************************************************************
; EQUATES / STRUCTURES
;******************************************************************************

MAX_NUM_XMS_BLKS   equ	20	; Really weird to have more XMS blocks than this
MIN_XMS_BLK_SIZE   equ	36	; Don't use XMS blocks smaller than this (in k)
MIN_XMS_ALLOC_SIZE equ	256	; Try to alloc at least 256k XMS blocks

; Control structure for each XMS block allocated

XMS_Block	struc
XMS_Next	dd	?	; next XMS_Block in linked list
XMS_Handle	dw	?	; XMS handle to block
XMS_Base_Page	dd	?	; address of 1st aligned 4k page in block
XMS_Total_Pages dw	?	; total # 4k pages in block
XMS_Free_Pages	dw	?	; # 4k pages currently free in block
XMS_Free_Head	dw	?	; index of 1st/next free 4k page in block
XMS_Free_List	dw	?	; linked list of free 4k pages in block
XMS_Block	ends


;******************************************************************************
; LOCAL DATA
;******************************************************************************

_DATA	segment

XMS_Block_List	dd	0	; head of XMS_Block struc linked list
XMS_Block_Cnt	dw	0	; # XMS blocks allocated

; Sizes of XMS blocks to allocate in 16k EMS pages

XMS_Block_Size	label	word
		dw	256 / 16		; 256 k bytes / 16 k pages
		dw	512 / 16
		dw	1024 / 16
		dw	2048 / 16
		dw	4096 / 16
		dw	8192 / 16
		dw	16384 / 16
XMS_SIZE_ENTRIES equ	($ - XMS_Block_Size) / 2


_DATA	ends

page
;=============================================================================
;==	C O D E  S E G M E N T
;=============================================================================
_TEXT	segment
assume	cs:_TEXT,ds:_DATA,ss:STACK,es:ABS0,gs:R_CODE
page
align 16

;***********************************************************************
; QueryXMSpages:    This routine determines if a specified number of
;	XMS "pages" (16k each) are available.
;
; Entry: (Protected Mode)
;	BX = Number of XMS pages desired.
; Exit:
;	CY = clear if desired # XMS pages are available,
;	CY = set if not enough XMS pages available, plus
;		AX = number of XMS pages actually available
; Used:
;	AX
;***********************************************************************
	public	QueryXMSpages

QueryXMSpages proc  near

	AssertSegReg	ds, VDMD_GSEL
	AssertSegReg	es, DATA32_GSEL
	AssertSegReg	gs, RCODEA_GSEL

	;pDebugF "QueryXMSpages: wanted %d, found ", bx

	push	bx
	push	cx
	push	dx
	push	esi

;  See if there are enough free pages in already allocated XMS blocks

	xor	ax, ax

;EnterCrit				; BEGIN CRITICAL SECTION
pushf
cli
	mov	esi, [XMS_Block_List]
QFXp_scan:
	or	esi, esi
	jz	short QFXp_not_enough

	add	ax, es:[esi].XMS_Free_Pages
	cmp	ax, bx
	jae	short QFXp_got_them

	mov	esi, es:[esi].XMS_Next
	jmp	short QFXp_scan

;  Find out how may pages the XMS driver can give us

QFXp_not_enough:

;ExitCrit				; END CRITICAL SECTION
popf
	sub	bx, ax				; need this many more pages
	mov	dx, ax				; this many we already have
	mov	ax, QUERY_XMS_PAGES
	call	CallRealModeRtn

	cmp	ax, bx				; get all we needed?
	jae	short QFXp_got_them2

	add	ax, dx				; what is avail + what we have
	stc
	jmp	short QFXp_exit

QFXp_got_them:

;ExitCrit				; END CRITICAL SECTION
popf

QFXp_got_them2:
	clc

QFXp_exit:
	;pDebugF "%d\n", ax

	pop	esi
	pop	dx
	pop	cx
	pop	bx

	ret

QueryXMSpages endp


;***********************************************************************
; AllocateXMSpages:	This routine allocates a requested number of XMS
;	"pages" (16k each) and fills in page table entries with their
;	address.
;
; Entry: (Protected Mode)
;	BX = Number of 16k XMS pages desired.
; Exit:
;	CY = clear if desired # XMS pages allocated.
;		Page table entries set.
;		[TopOfFreeEMSspace] updated.
;	CY = set if not enough XMS pages available.
; Used:
;
;***********************************************************************
	public	AllocateXMSpages

AllocateXMSpages proc	near

	AssertSegReg	ds, VDMD_GSEL
	AssertSegReg	es, DATA32_GSEL
	AssertSegReg	gs, RCODEA_GSEL

	;;;pDebugF "AllocateXMSPages: %d pages\n", bx

	pushad
	mov	bp, sp

AXp_scan_again:

;  Find out how many pages are available in existing XMS blocks

	xor	ax, ax

;EnterCrit				; BEGIN CRITICAL SECTION
pushf
cli
	mov	esi, [XMS_Block_List]
	or	esi, esi		; Q: any XMS blocks yet?
	jz	AXp_not_enough		; N:

AXp_scan:
	add	ax, es:[esi].XMS_Free_Pages
	mov	esi, es:[esi].XMS_Next
	or	esi, esi
	jnz	short AXp_scan

;  If there are enough free pages, allocate them

	mov	bx, word ptr [bp].Pushad_ebx	; # pages to assign

	cmp	ax, bx			; Q: enough pages available?
	jb	AXp_not_enough		; N:

	mov	ax, [BotOfVCPIspace]	; double check that there is enough
	sub	ax, [TopOfFreeEMSspace] ;   handle space for this allocation
	shr	ax, 2			; 4k to 16k pages
	cmp	ax, bx
	jb	AXp_no_handles

	mov	esi, [XMS_Block_List]
	mov	ecx, [page_directory]
	movzx	edi, [TopOfFreeEMSspace]
	lea	edi, [ecx][edi*4]	; es:[edi] -> TopOfFreeEMSspace

AXp_alloc_block:

	mov	cx, es:[esi].XMS_Free_Pages
	jcxz	AXp_next_block

	cmp	cx, bx				; Q: enough free pages in this
	jbe	short AXp_take_pages		;    block for remainder?
	mov	cx, bx				; Y: just take what we need
AXp_take_pages:
	sub	bx, cx
	sub	es:[esi].XMS_Free_Pages, cx

	push	bx				; remaining page count
	mov	ebx, es:[esi].XMS_Base_Page
	or	bx, P_AVAIL OR fXMSPageAllocated

	movzx	edx, es:[esi].XMS_Free_Head	; index of 1st free page

	cld

AXp_set_PTE_loop:

IFDEF DEBUG
	cmp	dword ptr es:[edi], 0
	jz	short @f
	INT	3
@@:
ENDIF
	mov	eax, edx
	shl	eax, 14 			; free page index to offset
	add	eax, ebx			; page = base + free page offset

	STOS_DWORD_PTR_ES_EDI			; store PTE
	add	eax, PAGE_SIZE
	STOS_DWORD_PTR_ES_EDI			; store PTE
	add	eax, PAGE_SIZE
	STOS_DWORD_PTR_ES_EDI			; store PTE
	add	eax, PAGE_SIZE
	STOS_DWORD_PTR_ES_EDI			; store PTE

	movzx	edx, es:[esi][edx*2].XMS_Free_List ; index of nxt free page

	loop	AXp_set_PTE_loop

	mov	es:[esi].XMS_Free_Head, dx	; update free page list

	pop	bx				; remaining page count
	or	bx, bx				; Q: all pages assigned?
	jz	short AXp_assigned_all		; Y:

AXp_next_block:

	mov	esi, es:[esi].XMS_Next

ifdef DEBUG
	or	esi, esi
	jnz	AXp_alloc_block
	; something wrong if we get here!
	pDebugBreak
else
	jmp	short AXp_alloc_block
endif

AXp_no_handles:
;ExitCrit				; END CRITICAL SECTION
popf
	jmp	short AXp_alloc_failed

AXp_assigned_all:

	sub	edi, [page_directory]
	shr	di, 2			; index back to PTE
	mov	[TopOfFreeEMSspace], di ; update top of EMS memory

;ExitCrit				; END CRITICAL SECTION
popf
	clc
	jmp	short AXp_exit


;  Try to get new XMS_Block(s) for the remaining pages

AXp_not_enough:

;ExitCrit				; END CRITICAL SECTION
popf
	mov	bx, word ptr [bp].Pushad_ebx
	sub	bx, ax			; number additional 16k pages needed

	call	AllocateXMSblock
	jnc	AXp_scan_again		; if alloc'd something, see if we can
					;   fulfill the page request now

;  Couldn't get all the pages wanted, but some XMS may have been allocated so
;  check the XMS_Block list and free any with no used pages

AXp_alloc_failed:

	call	ReleaseXMSblocks

AXp_fail:
	stc

AXp_exit:
	popad

	ret

AllocateXMSpages endp


;***********************************************************************
; FreeXMSpages: This routine scans free EMS space and releases free pages
;	that were dynamically allocated from XMS memory.
;
; Entry: (Protected Mode)
;
; Exit:
;	Page table entries cleared.
;	[TopOfFreeEMSspace] updated.
; Used:
;
;***********************************************************************
	public	FreeXMSpages

FreeXMSpages	proc	near

	AssertSegReg	ds, VDMD_GSEL
	AssertSegReg	es, DATA32_GSEL
	AssertSegReg	gs, RCODEA_GSEL

	pushad

;  Pack all free XMS page PTEs at the top of free space so their pages
;  can be released.  This has to be done so [TopOfFreeEMSspace] can be
;  moved down.

	xor	edi, edi
	mov	edx, [page_directory]

;EnterCrit				; BEGIN CRITICAL SECTION
pushf
cli
	; Scan EMS space top down to find the 1st non XMS allocated page

	movzx	esi, [TopOfFreeEMSspace]
	mov	bx, [TopOfUsedEMSspace]

FXp_scan_non_xms:
	cmp	si, bx				; Q: out of free space?
	jbe	short FXp_pack_done		; Y: finished
	bt	dword ptr es:[edx][esi*4-4*4], fXMSPageAllocatedBit
	jnc	short FXp_got_non_xms
	sub	si, 4
	jmp	short FXp_scan_non_xms

	; Scan for the first/next XMS page

FXp_got_non_xms:
	or	di, di				; Q: 1st time?
	jz	short FXp_1st_non_xms		; Y:

FXp_scan_xms:
	cmp	di, bx				; Q: out of free space?
	jbe	short FXp_pack_done		; Y: finished
	bt	dword ptr es:[edx][edi*4-4*4], fXMSPageAllocatedBit
	jc	short FXp_swap_PTE
	sub	di, 4
	jmp	short FXp_scan_xms

	; Swap XMS/non XMS entries so XMS entries at top

FXp_swap_PTE:
	mov	cx, 4				; 4 PTE entries per EMS page
FXp_swap_loop:
	mov	eax, es:[edx][edi*4-1*4]	; swap PTE entries
	xchg	eax, es:[edx][esi*4-1*4]
	mov	es:[edx][edi*4-1*4], eax
	dec	si
	dec	di
	loop	FXp_swap_loop
	jmp	short FXp_scan_non_xms

FXp_1st_non_xms:
	lea	di, [si-4]			; start looking for XMS pages
	jmp	short FXp_scan_xms		;   from below the non XMS page

FXp_pack_done:

;ExitCrit				; END CRITICAL SECTION
popf
	nop				; interrupt window
	nop
	nop

;  Now free the XMS pages at the top of free space.  We have to scan from
;  top down again because there is the possibility that things changed
;  during the interrupt window above.

;EnterCrit				; BEGIN CRITICAL SECTION
pushf
cli
	; Find the last XMS page in free space from top down

	movzx	esi, [TopOfFreeEMSspace]
	mov	bx, [TopOfUsedEMSspace]

FXp_get_last_xms:
	cmp	si, bx
	jbe	short FXp_got_xms_range
	bt	dword ptr es:[edx][esi*4-4*4], fXMSPageAllocatedBit
	jnc	short FXp_got_xms_range
	sub	si, 4
	jmp	short FXp_get_last_xms

	; Release the pages from PTE esi to [TopOfFreeEMSspace] - 1

FXp_got_xms_range:

	mov	bx, [TopOfFreeEMSspace] ; bx = old TopOfFreeEMSspace
	mov	[TopOfFreeEMSspace], si ; si = new ...

	lea	edi, [edx][esi*4]	; edi -> PTE for 1st page to free
	mov	cx, bx
	sub	cx, si			; cx = # 4k pages to free
	jbe	FXp_free_done

	shr	cx, 2			; cx = # 16k pages to free

	mov	esi, [XMS_Block_List]	; esi -> xms block info
ifdef DEBUG
	or	esi, esi
	jnz	short @f
	pDebugBreak
	jmp	FXp_free_done
@@:
endif
	mov	ebx, es:[esi].XMS_Base_Page	; ebx = base addr 4 this block

	cld

FXp_free_page:
	mov	eax, es:[edi]			; 1st PTE of page to free

ifdef DEBUG
	bt	eax, fXMSPageAllocatedBit
	jnc	short FXp_Bad_PTE
endif
	sub	eax, ebx			; Q: Is the page within the
	jb	short FXp_wrong_block		;    range of this XMS block?
	shr	eax, 14
	cmp	ax, es:[esi].XMS_Total_Pages
	jae	short FXp_wrong_block

FXp_got_block:
	mov	dx, ax				; Y: link it to the head of
	xchg	dx, es:[esi].XMS_Free_Head	;    the free page list
	mov	es:[esi][eax*2].XMS_Free_List, dx

	inc	es:[esi].XMS_Free_Pages 	; another 16k free page

	xor	eax, eax			; zero PTEs for this EMS page
	STOS_DWORD_PTR_ES_EDI
	STOS_DWORD_PTR_ES_EDI
	STOS_DWORD_PTR_ES_EDI
	STOS_DWORD_PTR_ES_EDI

	loop	FXp_free_page
	jmp	short FXp_free_done

FXp_bad_PTE:
ifdef DEBUG
	pDebugF "FreeXMSpages: Non XMS page or bad PTE %lxh @ %lxh\n", <eax, edi>
	pDebugBreak
endif
	add	edi, 4*4		; something screwy, skip this page
	loop	FXp_free_page
	jmp	short FXp_free_done

;  Page is not within the current XMS block, locate the correct block.

FXp_wrong_block:
	mov	edx, esi			; remember where we started

FXp_try_next_block:
	mov	eax, es:[edi]			; PTE of page to locate
	mov	esi, es:[esi].XMS_Next		; try next/first XMS block
	or	esi, esi
	jnz	short FXp_try_this_block
	mov	esi, [XMS_Block_List]

FXp_try_this_block:
	mov	ebx, es:[esi].XMS_Base_Page

	cmp	esi, edx			; Q: back where we started?
	jz	short FXp_bad_PTE		; Y: shouldn't happen...

	sub	eax, ebx			; Q: page within this block?
	jb	short FXp_try_next_block
	shr	eax, 14
	cmp	ax, es:[esi].XMS_Total_Pages
	jae	short FXp_try_next_block
	jmp	DebFar FXp_got_block		 ; Y:

FXp_free_done:

;ExitCrit				; END CRITICAL SECTION
popf
	call	ReleaseXMSblocks

	popad

	ret

FreeXMSpages	endp


;========================================================================


;***********************************************************************
; AllocateXMSblock:	This routine allocates a block of XMS memory
;	and adds it to the XMS_Block linked list.  Note that this
;	routine tries to allocate an XMS block that will hold the
;	desired number of pages, but may not be able to do so if there
;	is not a single large enough XMS block available.  If there
;	is not enough memory, the largest available block will be
;	allocated.  The return value (CY flag set or clear) indicates
;	if any XMS memory was allocated.
;
; Entry: (Protected Mode)
;	BX = # 16k pages needed
; Exit:
;	CY clear if an XMS block allocated
;	CY set if nothing allocated
; Used:
;	EAX, EBX, ECX, DX
;***********************************************************************
	public	AllocateXMSblock

AllocateXMSblock proc	near

	AssertSegReg	es, DATA32_GSEL
	AssertSegReg	gs, RCODEA_GSEL

	push	esi
	push	edi

;  Make sure the number of pages to allocate is at least our min allocation
;  block size and still small enough to be mapped with EMS handle space.

	cmp	bx, MIN_XMS_ALLOC_SIZE / 16 ; asking for our min block size?
	jae	short AXb_big_enough	    ; (bx in 16k pages, not k)
	movzx	ebx, [XMS_Block_Cnt]
	cmp	bx, XMS_SIZE_ENTRIES
	jb	AXb_get_size
	mov	bx, XMS_SIZE_ENTRIES - 1
AXb_get_size:
	mov	bx, [XMS_Block_Size][ebx*2]
AXb_big_enough:

	mov	ax, [BotOfVCPIspace]
	sub	ax, [TopOfFreeEMSspace] ; ax = # additional XMS pages that
	shr	ax, 2			;   can be added to EMS pool

	cmp	ax, bx
	jae	short AXb_small_enough
	mov	bx, ax
AXb_small_enough:

;  Add overhead pages to contain the XMS_Block structure and free page list.
;  We always add one 4k page (which is usually enough) to hold XMS_Block and
;  the free list, and to make sure that the free XMS 16k pages start on a
;  4k page boundry (XMS blocks are 1k aligned).  The overhead size in bytes
;  is SIZE XMS_Block + 2 * (number usable pages + 1)

	mov	cx, 4			; always add 4k for overhead/alignment

	movzx	eax, bx
	inc	ax
	lea	eax, [eax*2+SIZE XMS_Block]	; actual overhead size

	sub	ax, 1024		; alignment page gives 1k overhead--
	jb	short AXb_overhead_set	;   which is enough for most cases

	pDebugF "AllocXMSBlock: large overhead block, untested code"
	pDebugBreak

	add	ax, PAGE_SIZE - 1	; otherwise add enough 4k pages to
	shr	ax, 10			;   cover additional overhead
	add	cx, ax
AXb_overhead_set:

	shl	bx, 4			; 16k pages to k
	add	bx, cx			; add overhead / alignment size

ifdef DEBUG
	push	bx			; save requested size
endif
	mov	ax, ALLOC_XMS_BLOCK
	call	CallRealModeRtn

ifdef DEBUG
	pop	cx
	cmp	ax, cx
	jz	short AXb_got_em_all
	pDebugF "AllocXMSblock: requested %d, got %d\n", <cx, ax>
AXb_got_em_all:
endif

	; ax=block size (in k), ebx = physical address, dx=XMS handle

	or	ax, ax			; returns 0 size if failed
	jz	AXb_failed

;  We may not have gotten a block as large as we wanted, so recalculate the
;  amount of overhead needed to control the actual block.

	movzx	ecx, ax
	shr	cx, 4			  ; size in k to # 16k pages
	inc	cx			  ; overhead (bytes) = SIZE XMS_Block +
	lea	ecx, [ecx*2+SIZE XMS_Block] ;		       2 * (# pages + 1)

	mov	edi, ebx		; edi -> XMS_Block struc for this block
	lea	ebx, [ebx+ecx+PAGE_SIZE-1]
	and	bx, NOT (PAGE_SIZE - 1) ; ebx -> 1st page after overhead area

	movzx	eax, ax
	shl	eax, 10 		; size in k to bytes
	lea	ecx, [eax+edi]		; end of block
	sub	ecx, ebx		; size of free page area in bytes
	shr	ecx, 14 		; ...................... in 16k pages

;  Initialize XMS_Block fields

	mov	es:[edi].XMS_Next, 0
	mov	es:[edi].XMS_Handle, dx
	mov	es:[edi].XMS_Total_Pages, cx
	mov	es:[edi].XMS_Free_Pages, cx
	mov	es:[edi].XMS_Base_Page, ebx

;  Initialize the block's list of free pages

	xor	ax, ax
	push	edi
	add	edi, XMS_Free_Head
	.errnz	XMS_Free_List - XMS_Free_Head - 2

	cld
AXb_set_free_list:
	STOS_WORD_PTR_ES_EDI
	inc	ax
	loop	AXb_set_free_list

	mov	ax, -1				; one more to terminate list
	STOS_WORD_PTR_ES_EDI

	pop	edi

;  Add new XMS block to list of other blocks

;EnterCrit				; BEGIN CRITICAL SECTION
pushf
cli
	inc	[XMS_Block_Cnt]
	mov	esi, [XMS_Block_List]
	or	esi, esi
	jnz	short AXb_find_end

	mov	[XMS_Block_List], edi	; 1st XMS block allocated
	jmp	short AXb_done

AXb_find_end:
	mov	ebx, esi
	mov	esi, es:[esi].XMS_Next
	or	esi, esi
	jnz	short AXb_find_end

	mov	es:[ebx].XMS_Next, edi	; add to end of list

AXb_done:

;ExitCrit				; END CRITICAL SECTION
popf
	clc				; Success!
	jmp	short AXb_exit

AXb_failed:
	stc				; Failure

AXb_exit:
	pop	edi
	pop	esi
	ret

AllocateXMSblock endp


;***********************************************************************
;  ReleaseXMSblocks:	This routine scans the list of XMS_Blocks and
;	frees any that have no allocated pages.
;
;  Entry: (Protected mode)
;	None.
;  Exit:
;	None.
;  Used:
;	AX
;***********************************************************************
	public	ReleaseXMSblocks

ReleaseXMSblocks proc	near

	AssertSegReg	es, DATA32_GSEL
	AssertSegReg	gs, RCODEA_GSEL

	push	ebx
	push	edx
	push	esi

RXb_scan_list:

;EnterCrit				; BEGIN CRITICAL SECTION
pushf
cli
	mov	ebx, [p_data]
	add	ebx, offset _DATA:XMS_Block_List    ; EBX -> [XMS_Block_List]
	.errnz	XMS_Next
	mov	esi, [XMS_Block_List]

RXb_check_block:
	or	esi, esi
	jz	short RXb_none_to_free

	mov	ax, es:[esi].XMS_Free_Pages
	cmp	ax, es:[esi].XMS_Total_Pages	; Q: all pages free in block?
	jne	short RXb_check_next		; N:

	mov	edx, es:[esi].XMS_Next
	mov	es:[ebx].XMS_Next, edx
	dec	[XMS_Block_Cnt]

;ExitCrit				; END CRITICAL SECTION
popf
	mov	dx, es:[esi].XMS_Handle

	pDebugF "ReleaseXMSblocks: freeing block %lxh handle %xh\n", <esi, dx>

	mov	ax, FREE_XMS_BLOCK
	call	CallRealModeRtn

	jmp	short RXb_scan_list

RXb_check_next:
	mov	ebx, esi
	mov	esi, es:[esi].XMS_Next
	jmp	short RXb_check_block

RXb_none_to_free:

;ExitCrit				; END CRITICAL SECTION
popf
	pop	esi
	pop	edx
	pop	ebx

	ret

ReleaseXMSblocks endp

_TEXT	ends

;========================================================================

R1_CODE segment
	assume	cs:R1_CODE, ds:NOTHING, es:NOTHING, fs:NOTHING, gs:NOTHING

;***********************************************************************
; rQueryXMSpages:   This routine checks free XMS blocks to see if a
;	specific number of 16k pages are available.  This routine only
;	looks for the requested number of pages, the returned value
;	may be less than the total number free as long as the requested
;	number are found.  If the total number of requested pages are
;	not free, the returned value will be the total number of free
;	pages.	In other words, this routine looks for free pages until
;	it either finds the number wanted, or it runs out of free pages.
;
; Entry: (Virtual Mode)
;	BX = Number of 16k XMS pages desired.
; Exit:
;	AX = # XMS pages available
; Used:
;
;***********************************************************************
	public	rQueryXMSpages

rQueryXMSpages proc near

	call	SetIFflag	; invoked like an int routine, enable ints
				;   if caller had them enabled
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	ds
	mov	ax, seg R_CODE
	mov	ds, ax
	assume	ds:R_CODE

	xor	si, si			; # free 16k pages found so far
	mov	di, MAX_NUM_XMS_BLKS	; limit how far we'll look

	push	0		; null handle to end free block loop

;  Get size of largest free XMS block and determine the number of 16k
;  pages it can contain.  Each block will contain at least one page of
;  overhead for alignment and the free page list.

rQF_next:
	push	bx		; XMS calls return error code in BL
	mov	ah, 08h 	; query free extended memory
	call	[XMMcontrol]	; sets ax=largest free, dx=total free
	pop	bx

	cmp	ax, MIN_XMS_BLK_SIZE	; don't mess with tiny XMS blocks
	jb	short rQF_done

	push	ax			; save size in k
	shr	ax, 4			; k to 16k pages
	mov	cx, 4			; always sub 4k for overhead/alignment
	movzx	eax, ax
	inc	ax
	lea	eax, [eax*2+SIZE XMS_Block]	; actual overhead size

	sub	ax, 1024		; alignment page gives 1k overhead--
	jb	short rQF_overhead_set	;   which is enough for most cases

	add	ax, PAGE_SIZE - 1	; otherwise sub enough 4k pages to
	shr	ax, 10			;   cover additional overhead
	add	cx, ax
rQF_overhead_set:

	pop	ax		; block size in k
	neg	cx
	add	cx, ax		; less overhead / alignment size

	shr	cx, 4		; k to 16k pages
	add	si, cx		; accumulate free 16k pages

	cmp	si, bx		; quicker exit if found enough free
	jae	short rQF_done

	cmp	ax, dx		; if largest == total, this is the last block
	je	short rQF_done	;   available so don't need to allocate it

;  Allocate largest block to find out what the next largest block is

	mov	dx, ax		; allocate the largest free block
	push	bx		; XMS calls return error code in BL
	mov	ah, 09h 	; allocate extended memory block
	call	[XMMcontrol]
	pop	bx

	or	ax, ax		; ax = 0 if allocation failed, shouldn't
	jz	short rQF_done	;   happen, but...

	push	dx		; save handle to this XMS block

	dec	di		; look for another block if there aren't too
	jnz	short rQF_next	;   many of them

	;fall through to rQF_done

;  Free the blocks allocated above

rQF_done:

	pop	dx		; XMS handle or terminating 0
	or	dx, dx
	jz	short rQF_exit

	mov	ah, 0Ah 	; free extended memory block
	call	[XMMcontrol]
	jmp	short rQF_done

rQF_exit:
	mov	ax, si		; accumulated free pages

	pop	ds
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx

	iret			; NOTE: IRET, not ret

rQueryXMSpages endp

;***********************************************************************
; rAllocateXMSblock:	This routine allocates a block of XMS memory
;	and returns info about the block.
;
; Entry:
;	BX = max block size wanted, in k
; Exit:
;	AX = block size allocated, in k
;	EBX= physical address of block
;	DX = XMS handle to block
; Used:
;
;***********************************************************************
	public rAllocateXMSblock

rAllocateXMSblock   proc    near

	call	SetIFflag	; invoked like an int routine, enable ints
				;   if caller had them enabled
	push	ds
	mov	ax, seg R_CODE
	mov	ds, ax
	assume	ds:R_CODE

	push	bx
	mov	ah, 08h 		; query free XMS memory
	call	[XMMcontrol]
	pop	bx

	cmp	ax, bx			; Q: can we get all that's wanted?
	jae	short rAXb_get_it_all	; Y:
	cmp	ax, MIN_XMS_BLK_SIZE	; N: Q: is there at least the min?
	jae	short rAXb_get_biggest	;    Y: get that amount
	jmp	DebFar rAXb_fail

rAXb_get_it_all:
	mov	ax, bx

rAXb_get_biggest:
	push	ax			; save size to alloc

	mov	dx, ax
	mov	ah, 09h 		; allocate extended memory block
	call	[XMMcontrol]
	or	ax, ax
	jz	short rAXb_fail_alloc

	push	dx			; save block handle

	mov	ah, 0Ch 		; lock extended memory block
	call	[XMMcontrol]
	or	ax, ax
	jz	short rAXb_fail_lock	; shouldn't happen, but...

	xchg	bx, dx
	shl	ebx, 16
	mov	bx, dx			; ebx = physical address of block

	pop	dx			; dx = XMS handle
	pop	ax			; ax = block size

	rDebugF "rAllocXMSblock: %dk @ %lxh handle %xh\n", <ax, ebx, dx>

	pop	ds

	iret			; NOTE: IRET, not ret

rAXb_fail_lock:
	pop	dx			; XMS handle
	mov	ah, 0Ah 		; free extended memory block
	call	[XMMcontrol]

	rDebugF "rAllocXMSblock: lock failed!\n"

rAXb_fail_alloc:
	pop	ax			; size to alloc

	rDebugF "rAllocXMSblock: alloc of %dk failed!\n", ax

rAXb_fail:
	xor	ax, ax			; 0 allocated size means failure

	pop	ds

	iret			; NOTE: IRET, not ret

rAllocateXMSblock   endp

;***********************************************************************
; rFreeXMSblock:	This routine returns an XMS block to the XMS
;	memory manager.
;
; Entry: (Virtual mode)
;	DX = handle of XMS block to free
; Exit:
;
; Uses:
;	AX, BX
;***********************************************************************
	public rFreeXMSblock

rFreeXMSblock	proc	near

	call	SetIFflag	; invoked like an int routine, enable ints
				;   if caller had them enabled
	push	ds
	mov	ax, seg R_CODE
	mov	ds, ax
	assume	ds:R_CODE

	;;;rDebugF "rFreeXMSblock: freeing handle %xh\n", dx

	mov	ah, 0Dh 	; unlock extended memory block
	call	[XMMcontrol]
	mov	ah, 0Ah 	; free extended memory block
	call	[XMMcontrol]

ifdef DEBUG
	cmp	ax, 1
	jz	short @f
	rDebugF "rFreeXMSblock: free handle %xh failed!\n", dx
	rDebugBreak
@@:
endif
	pop	ds

	iret

rFreeXMSblock	endp


;***********************************************************************
; SetIFflag:	Helper routine to set IF flag based on flags in IRET
;	frame on stack.
;
; Entry: (Virtual mode)
;	SP-> [IP] [IP] [CS] [FL]
; Exit:
;	Interrupts may be enabled.
; Uses:
;	AX, BX
;***********************************************************************
	public SetIFflag

SetIFflag proc	near

	push	bp			;	 0    2    4	6    8
	mov	bp, sp			; bp -> [bp] [ip] [ip] [cs] [fl]

	test	byte ptr [bp+9], 2	; Q: int's enabled in stack image of
	jz	short IF_set		;    flags?

	sti				; Y:
IF_set:
	pop	bp
	ret

SetIFflag endp


R1_CODE ends

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\lhvxd\instswap.asm ===
PAGE 58,132
;******************************************************************************
TITLE INSTANCE.ASM -
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1986-1991
;
;   Title:	INSTSWAP.ASM -
;
;   Version:	2.00
;
;   Date:	18-Sep-1986
;
;   Author:	RRH, RAL, AAR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   18-SEP-1986 RRH Original
;   12-Jul-1988 RAL Changed from VMSWITCH.ASM to INSTSWAP.ASM & optimized
;   13-Jul-1988 RAL Updated to new data structures / Page must be owned
;   02-Aug-1988 AAR Added _MMGR_Toggle_HMA call for A20 wrap management
;   25-Aug-1988 RAL Fixed high memory instance faults
;   09-Mar-1989 RAL Non-dirty inst pages not copied out, New PFAULT.ASM
;   24-Jul-1990 AC  Adapted for LoadHi VXD
;
;==============================================================================
	.386p

;******************************************************************************
;		    P U B L I C   D E C L A R A T I O N S
;******************************************************************************

	PUBLIC	Swap_LoadHi_Instance_Page


;******************************************************************************
;			  I N C L U D E   F I L E S
;******************************************************************************

	INCLUDE VMM.inc
	INCLUDE Debug.Inc
	INCLUDE instance.Inc
	INCLUDE Opttest.Inc


;******************************************************************************
;		  E X T E R N A L   D E C L A R A T I O N S
;******************************************************************************

VxD_DATA_SEG

Extrn	ActualAddInstanceItem:dword		;original _AddInstanceItem service
Extrn	LoadHi_Instance_Map_Table_Ptr_Actual:dword
Extrn	LoadHi_Instance_Map_Table_Size_Actual:byte
Extrn	LoadHi_Instance_SnapLaddr:dword
Extrn	CB_LoadHi_Inst_Buf_ptr:dword		;offset in CB for Instance data buffer
Extrn	CB_LoadHi_Inst_Hand:dword		;handle of above buffer

; define contants to BIAS the MAP tables to start at page 0

LoadHi_Instance_Map_Table_Ptr equ LoadHi_Instance_Map_Table_Ptr_Actual - 0A0H * 4
LoadHi_Instance_Map_Table_Size equ LoadHi_Instance_Map_Table_Size_Actual - 0A0H


	public	LoadHi_Inst_Page_Owner_Actual

; define the actual array to start from page 0A0H onwards, but define an equate
; to back bias the start relative to page 0 so that we can index into the 
; array directly.

LoadHi_Inst_Page_Owner_Actual     dd	(MAX_INST_PAGES- 0A0H) dup (0)
LoadHi_Inst_Page_Owner equ LoadHi_Inst_Page_Owner_Actual - 0A0H * 4

;----------------------------------------------------------------------------;
VxD_DATA_ENDS
;----------------------------------------------------------------------------;
VxD_CODE_SEG

	Extrn	Get_Mapped_Page_Num:near

;******************************************************************************
;
;   Swap_LoadHi_Instance_Page
;
;   DESCRIPTION:
;
;
;   WARNING:
;	THIS PROCEDURE IS CALLED BY VMTRAP TO SWAP PAGE 0 FOR FAST INTERRUPT
;	REFLECTION!  The EAX and EDX parameters passed by the page fault
;	code will not be valid when called from VmTrap.
;
;   ENTRY:
;	EBX = Current VM handle
;	EAX = Page index of fault
;
;   EXIT:
;
;   USES:
;	EAX, EBX, ECX, EDX, ESI, EDI, Flags
;
;==============================================================================

BeginProc Swap_LoadHi_Instance_Page, High_Freq, PUBLIC

	enter	4,0

PageTableBits	EQU	DWORD PTR [EBP-4]

	mov	ecx,eax
	cmp	ecx,MAX_INST_PAGES
	jae	SIP_Fatal

comment ~
IFDEF DEBUG
	cmp	LoadHi_Inst_Page_Owner[ecx*4],0
	jne	short SIPD10
	debug_out "Swap_LoadHi_Instance_Page, 0 in LoadHi_Inst_Page_Owner for page #ecx"
SIPD10:
	testmem [ebx.CB_MMGR_Flags],CB_MMGR_Resumed
	jnz	short SIP_Not_Suspended
	testmem [ebx.CB_VM_Status], VMStat_Creating
	jnz	SHORT SIP_Not_Suspended
	Debug_Out "ERROR:  LoadHi_Instance fault on suspended VM #EBX"
SIP_Not_Suspended:
ENDIF
end comment ~

	mov	eax, ebx
	xchg	eax, LoadHi_Inst_Page_Owner[ecx*4]	; Get old owner / Set new owner

    ;
    ; eax is OLD owners Control Block
    ; ebx is NEW owners Control Block
    ; ecx is page number
    ;

    ;
    ; map the page NOT_PRESENT for the old owner and PRESENT for the 
    ; new owner. Before doing this get the page table entry information
    ; for the old owner.
    ;

    	mov	edx,ecx				;get the page number
	shl	edx,12				;convert to a linear address
	add	edx,[eax.CB_High_Linear]	;where currently mapped
	shr	edx,12				;convert back to a page number
	push	eax
	push	ebx
	push	ecx
	push	edx
	lea	esi,PageTableBits
	VMMcall	_CopyPageTable,<edx,1,esi,0>
	pop	edx
	pop	ecx
	pop	ebx
	pop	eax
	mov	esi,NOT P_PRES
	push	eax
	push	ebx
	push	ecx
	push	edx
    	VMMcall	_ModifyPageBits,<eax,ecx,1,esi,0,PG_HOOKED,0>
	pop	edx
	pop	ecx
	pop	ebx
	pop	eax

	push	eax
	push	ebx
	push	ecx
	push	edx
	mov	eax,ecx				;get the UMB page number
	call	Get_Mapped_Page_Num		;edx has mapped page number
	VMMcall	_PhysIntoV86,<edx,ebx,ecx,1,0>
	pop	edx
	pop	ecx
	pop	ebx
	pop	eax

comment ~
	mov	esi, [eax.CB_PgTable_Ptr]				; ESI -> Old owner's page table
	mov	edi, [ebx.CB_PgTable_Ptr]				; EDI -> New owner's page table
	cmp	ecx, WRAP_MAX_V86_PAGE					; Wrap area page?
	jae	SIP_Wrap1						; Yes, special stuff
	mov	dl, BYTE PTR [esi][ecx*4]				; Get page info for dirty test
	and	BYTE PTR [esi][ecx*4],NOT P_AVAIL			;Old owner can't access
	or	BYTE PTR [edi][ecx*4], P_AVAIL				; New owner can
	cmp	ecx,NOWRAP_MAX_V86_PAGE - WRAP_MAX_V86_PAGE		; Q: Page possibly mirrored above 1 meg?
	jae	SHORT SIP_Owners_Swapped				;    N: Ownership set
	testmem [eax.CB_MMGR_Flags],CB_MMGR_NoWrap			; Old guy has wrap?
	jnz	short SIPOLDNoWrp					; N:
	or	dl, BYTE PTR [esi+(WRAP_MAX_V86_PAGE*4)][ecx*4] 	; + Dirty info for high page
	and	BYTE PTR [esi+(WRAP_MAX_V86_PAGE*4)][ecx*4], NOT P_AVAIL; Old owner can't access
SIPOLDNoWrp:
	testmem [ebx.CB_MMGR_Flags],CB_MMGR_NoWrap			; New guy has wrap?
	jnz	short SIP_Owners_Swapped				; N:
	or	BYTE PTR [edi+(WRAP_MAX_V86_PAGE*4)][ecx*4], P_AVAIL	; New owner can
	and	BYTE PTR [edi+(WRAP_MAX_V86_PAGE*4)][ecx*4], NOT P_DIRTY; New owner NOT dirty
SIP_Owners_Swapped:

end comment ~

	mov	edi, cr3			; Reload CR3 to reset the TLB
	mov	cr3, edi
	mov	edi, PageTableBits		; Move dirty info to EDI

    ;
    ; eax is OLD owners Control Block
    ; ebx is NEW owners Control Block
    ; ecx is page number
    ; edi original page bits for OLD owner
    ;

	push	ecx

	mov	edx, LoadHi_Instance_Map_Table_Ptr[ecx*4]
	movzx	ecx, LoadHi_Instance_Map_Table_Size[ecx]
	or	ecx,ecx
IFDEF DEBUG
	jnz	short CIOD10
	debug_out "LoadHi_Instance fault on page with 0 IMT_LoadHi_Inst_Map_Size"
CIOD10:
ENDIF
	jz	short CIODone

;
;   If the page was not dirty then no need to save old owner's inst buffer.
;

	testreg edi, P_DIRTY
;	jz	SHORT CILoop

;
;   Copy old LoadHi_Instance Owner's data out
;
	push	ecx
	push	edx
COLoop:
	push	ecx

	mov	edi, CB_LoadHi_Inst_Buf_ptr
	mov	edi, [eax][edi]		; Point into instance buffer
	add	edi, [edx.IMap_Inst_Buf_Offset]
	mov	esi, [edx.IMap_VM_Address]
	add	esi, [ebx.CB_High_Linear]
	movzx	ecx, [edx.IMap_Lead_Byte_Count]
	rep	movsb

    ; NOTE here that we know ECX == 0

	or	cx, [edx.IMap_Field_Length]
	jz	short CONext
	shr	ecx,2
	rep	movsd

    ; NOTE here that we know ECX == 0

	or	cx, [edx.IMap_Field_Length]
	and	ecx,011b		; Mask to byte part
	rep	movsb

CONext:
	pop	ecx
	add	edx, size LoadHi_Instance_Map_struc
	loop	COLoop

	pop	edx
	pop	ecx

;
;   Copy new LoadHi_Instance Owner's data in
;
CILoop:
	push	ecx

	mov	esi, CB_LoadHi_Inst_Buf_ptr
	mov	esi, [ebx][esi]		; Point into instance buffer
	add	esi, [edx.IMap_Inst_Buf_Offset]
	mov	edi, [edx.IMap_VM_Address]
	add	edi, [ebx.CB_High_Linear]
	movzx	ecx, [edx.IMap_Lead_Byte_Count]
	rep	movsb

    ; NOTE here that we know ECX == 0

	or	cx, [edx.IMap_Field_Length]
	jz	short CINext
	shr	ecx,2
	rep	movsd

    ; NOTE here that we know ECX == 0

	or	cx, [edx.IMap_Field_Length]
	and	ecx,011b		; Mask to byte part
	rep	movsb
CINext:
	pop	ecx
	add	edx, size LoadHi_Instance_Map_struc
	loop	CILoop

CIODone:
	pop	ecx
	mov	edi, cr3
	mov	cr3, edi

	leave
	ret

SIP_Not_LoadHi_Inst_Page:
	Debug_Out "ERROR:  LoadHi_Instance fault on non-instance page"
	VMMjmp	Crash_Cur_VM

SIP_Fatal:
	debug_out "Got an instance page fault on #ecx >= MAX_INST_PAGES in a VM"
	VMMjmp	Crash_Cur_VM

EndProc Swap_LoadHi_Instance_Page

;******************************************************************************
;
;   LoadHi_Instance_VMDestroy/LoadHi_Instance_VMSuspend - Make any instance pages owned by
;					       EBX owned by SYS_VM_Handle
;
;   ENTRY:
;	EBX is VM Handle of VM being destroyed
;
;   EXIT:
;	None
;
;   USES:
;	EAX, ECX, EDX, ESI, EDI, Flags
;
;==============================================================================

BeginProc LoadHi_Instance_VMDestroy, PUBLIC
	push	1
	jmp	short VMSuspDestCommon

EndProc LoadHi_Instance_VMDestroy

BeginProc LoadHi_Instance_VMSuspend, PUBLIC

	push	0

VMSuspDestCommon:
IFDEF DEBUG
	cmp	dword ptr [esp],0	; Only invalid to DESTROY current VM
	jz	short IVD_Handle_OK
;
;   NOTE: You can not use Assert_VM_Handle ebx here since the VM handle
;	  has already been removed from the list of valid handles.
;
	;;;;;;;;Assert_VM_Handle ebx
	push	ebx
	push	eax
	mov	eax,ebx
	VMMcall	Get_Cur_VM_Handle
	cmp	eax,ebx
	pop	eax
	pop	ebx
	jne	SHORT IVD_Handle_OK
	Debug_Out "FATAL ERROR:  LoadHi_Instance_VMDestroy called with EBX = Cur_VM_Handle"
	Fatal_Error
IVD_Handle_OK:
ENDIF

	mov	ecx, MAX_INST_PAGES		; # of pages to test
IVD_Loop:
	cmp	ecx,MIN_LOADHI_INST_PAGE	; this is where we stop
	jbe	SHORT IVD_Exit			; done.
	dec	ecx				; otherwise dec page counter
;
; NOTE On non-instance pages where there is a 0 in LoadHi_Inst_Page_Owner array
;	we will ALWAYS take the JNE.
;
	cmp	LoadHi_Inst_Page_Owner[ecx*4], ebx; Q: Owned by this VM?
	jne	SHORT IVD_Loop			;    N: GOOD!  Ignore this page
	push	ebx				;    Y: Force it to be loaded
	push	ecx				;	for the system VM
	VMMcall	Get_Sys_VM_Handle		;Sys_VM_Handle in EBX
	push	eax				
	mov	eax,ecx
	call	Swap_LoadHi_Instance_Page
	pop	eax
	pop	ecx
	pop	ebx
	jmp	SHORT IVD_Loop

IVD_Exit:
	clc					; success
	pop	eax				; Discard susp/destroy flag
	ret

EndProc LoadHi_Instance_VMSuspend
;******************************************************************************
;
;   Load_LoadHi_Instance_Pages - Make sure all instance pages are present and owned
;			  by Cur_VM_Handle.
;
;   ENTRY:
;	None
;
;   EXIT:
;
;   USES:
;	EAX, EBX, ECX, EDX, ESI, EDI, Flags
;
;==============================================================================
comment ~
BeginProc Load_LoadHi_Instance_Pages, PUBLIC

	VMMcall	Get_Cur_VM_Handle 		;EBX has Cur_VM_Handle
	mov	ecx, MAX_INST_PAGES
LIP_Loop:
	dec	ecx
	jz	SHORT LIP_Exit
	cmp	LoadHi_Inst_Page_Owner[ecx*4], ebx	; Owned by Cur VM already?
	je	SHORT LIP_Loop			; Yes, skip it
	cmp	LoadHi_Inst_Page_Owner[ecx*4], 0	; LoadHi_Instance page?
	je	SHORT LIP_Loop			; No, skip it
	push	ebx
	push	ecx
	push	eax				
	mov	eax,ecx
	call	Swap_LoadHi_Instance_Page
	pop	eax
	pop	ecx
	pop	ebx
	jmp	SHORT LIP_Loop
LIP_Exit:
	ret

EndProc Load_LoadHi_Instance_Pages
end comment ~
;******************************************************************************
;
;   LoadHi_Instance_WIN386_Exit - Set up instance data for WIN386 exit. Swap in
;			   contents of instance snap shot buffer.
;
;   ENTRY:
;	None
;
;   EXIT:
;	None
;
;   USES:
;	ALL but EBP
;
;==============================================================================

comment ~
BeginProc LoadHi_Instance_WIN386_Exit, PUBLIC

	mov	ecx, MAX_INST_PAGES	; Do this many pages
CIPLp:
	cld
	push	ecx

	dec	ecx			; Count is 1-MAX_INST_PAGES,
					;  pages are 0-(MAX_INST_PAGES - 1)
	mov	edx, LoadHi_Instance_Map_Table_Ptr[ecx*4]
	movzx	ecx, LoadHi_Instance_Map_Table_Size[ecx]
	jecxz	CICont
CILp:
	push	ecx

	mov	esi, [LoadHi_Instance_SnapLaddr]
	add	esi, [edx.IMap_Inst_Buf_Offset]
    ;
    ; For HMA instance pages IMap_VM_Address is in the Phys Linear region so
    ;	it doesn't matter if the HMA is currently ON or OFF in the current
    ;	VM.
    ;
	mov	edi, [edx.IMap_VM_Address]
	movzx	ecx, [edx.IMap_Lead_Byte_Count]
	rep	movsb
    ; NOTE here that we know ECX == 0
	or	cx, [edx.IMap_Field_Length]
	jz	short COutNext
	shr	ecx,2
	rep	movsd
    ; NOTE here that we know ECX == 0
	or	cx, [edx.IMap_Field_Length]
	and	ecx,011b		; Mask to byte part
	rep	movsb
COutNext:
	pop	ecx
	add	edx, size LoadHi_Instance_Map_struc
	loop	CILp

CICont:
	pop	ecx
	loop	CIPLp
	ret

EndProc LoadHi_Instance_WIN386_Exit
end comment ~
;----------------------------------------------------------------------------;
VxD_CODE_ENDS
;----------------------------------------------------------------------------;
VxD_ICODE_SEG

VxD_ICODE_ENDS
;----------------------------------------------------------------------------;
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\lhvxd\loadhi.asm ===
PAGE 58,132
;******************************************************************************
TITLE LoadHi -- Support for Load Hi under Windows 3.0x
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1990-1991
;
;   Title:	LoadHi -- Support for Load Hi under Windows 3.0x
;
;   Version:	1.00
;
;   Date:	20-Jul-1990
;
;   Author:	AC
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;    08-27-1990	AC  Hooked "Allocate_Global_V86_Data_Area" call to fix WIN3.0 bug
;    10-01-1990 ARR added some V86MMGR bug fix work around code.
;    10-03-1990 ARR Remove _Allocate_Global_V86_Data_Area work around (due to
;		      errata 10 handling). This work around is now sole job
;		      of LA20HMA device
;    02-20-1991 AC  Will not load if duplicate or not from INT 2F chain.
;
;==============================================================================
;
;   DESCRIPTION:
;
;******************************************************************************

	.386p


;******************************************************************************
;			      I N C L U D E S
;******************************************************************************



	.XLIST
	INCLUDE VMM.Inc
	INCLUDE DOSMGR.Inc
	INCLUDE Debug.Inc
	INCLUDE Instance.Inc
	INCLUDE v86mmgr.Inc
	.LIST

	Create_VDD2_Service_Table EQU TRUE
	INCLUDE .\VDD2.Inc
	LoadHi_Service_Table EQU VDD2_Service_Table
	Num_LoadHi_Services EQU Num_VDD2_Services

;******************************************************************************
;		 V I R T U A L	 D E V I C E   D E C L A R A T I O N
;******************************************************************************


Declare_Virtual_Device LoadHi, 1, 0, LoadHi_Control, VDD2_Device_ID, VMM_Init_Order

;******************************************************************************
;				 E Q U A T E S
;******************************************************************************

MONO_DISP_LO	equ	0B0H		;start page in mono display area
MONO_DISP_HI	equ	0B7H		;end page in mono display area

;******************************************************************************
;			     S T R U C T U R E S
;******************************************************************************

LimInstanceData	STRUC
LimInstanceDataPtr	dd	?	;pointer to instance data start
LimInstanceDataSize	dw	?	;size in bytes
LimInstanceData	ENDS

;******************************************************************************
;			   F L A G   E Q U A T E S
;******************************************************************************


;******************************************************************************
;		   I N I T I A L I Z A T I O N	 D A T A
;******************************************************************************

VxD_IDATA_SEG

;;;;Real_AGVDA_Addr	    dd	    ?	    ;original Allocate_Global_V86_Data_Area

; define a copyright string

MS_CopyRight		db	'(C) Copyright MICROSOFT Corp., 1990',0
LoadHi_Device_Name	db	'LoadHi',0,0
CrashMsg		db	'LoadHi:Sys_Critical_Init Fails',0


; define strings for 'LOCAL=' and 'GLOBAL=' section names in [386Enhanced]
; section of SYSTEM.INI. 

LH_DevNameBuf		db	8 dup (?);for storing device name
LH_Local_String		db	'LOCAL',0
LH_Global_String	db	'GLOBAL',0

Prev_GPS_Pointer	dd	?	; previous GetProfileString pointer

VxD_IDATA_ENDS


;******************************************************************************
;	      R E A L	M O D E   I N I T I A L I Z A T I O N
;******************************************************************************

VxD_REAL_INIT_SEG

	Extrn	Real_Mode_Hook:near

;******************************************************************************
;
;   LoadHi_Real_Mode_Init
;
;   DESCRIPTION:
;
;	The VxD will not load if this is a duplicate load or if it is not
;	being loaded from the INT 2F chain.
;
;	This VxD should only be loaded for version 3.0 of Windows/386.
;	The real mode initialization portion of this device will abort its
;	load if the VMM version is less than version 3.10 (hex 30A)
;				
;       If our test succeedes, we need to call a Limulator specific routine
;       to do test for them and this routine would setup registers such that
;       we could do a return to VMM directly. Look at the default code in
;       UMB.ASM
;
;   ENTRY:
;	CS, DS = Real mode segment
;	AX = VMM version (AH=Major, AL=Minor)
;	BX = Flags
;
;   EXIT:
;	BX = Null pointer (no pages to exclude)
;	SI = Null pointer (no instance data)
;	EDX = Reference data to pass to protected mode portion of VxD
;
;   USES:
;	AX, BX, DX, SI, Flags
;
;==============================================================================

BeginProc LoadHi_Real_Mode_Init

; check for duplicate device load.

	test	bx, Duplicate_From_INT2F OR Duplicate_Device_ID
	jnz	SHORT LH_RMI_Fail_Load

; this is not a duplicate load, but was the device loaded from INT 2F chain ?

	test	bx,Loading_From_INT2F
	jnz	SHORT LH_RMI_Loading_Ok		;loading type is OK.

LH_RMI_Fail_Load:

; fail this device load without any error message.

	xor	bx,bx				;no pages to exclude
	xor	si,si				;no instance data
	mov	ax, Abort_Device_Load + No_Fail_Message
	jmp	SHORT LH_RMI_Exit

LH_RMI_Loading_Ok:

;
;   Make sure that we're running on Windows/386 version 3.10 or later.
;   If not, abort the load of this device with a warning message.
;

	cmp	ax, 30Ah			; Q: Is this version < 3.10?
	jae	SHORT LH_RMI_Abort_Load 	;    N: Don't load me
						;    Y: Return success flags

; call Lim specific routines and return with whatever registers they setup

	call	Real_Mode_Hook			;Lim specific real mode hook

	ret

LH_RMI_Abort_Load:

	mov	ax, Abort_Device_Load 

LH_RMI_Exit:

	ret

EndProc LoadHi_Real_Mode_Init
VxD_REAL_INIT_ENDS
;******************************************************************************
;			    L O C A L	D A T A
;******************************************************************************

VxD_DATA_SEG

			public FirstUMBPage
			public NumUMBPages
			public CB_LoadHi_Inst_Hand			
			public CB_LoadHi_Inst_Buf_ptr
			public GlobalDeviceList
			public InstanceDataList 

FirstUMBPage		dd	? 	;first UMB page number
NumUMBPages	 	dd	? 	;number of pages that we have to deal with
CB_LoadHi_Inst_Buf_ptr	dd	?	;Int buf ptr offset in CB
CB_LoadHi_Inst_Hand	dd	?	;Int buf handle offset in CB
DeviceHeaderStartPtr	dd	?	;start of device header chain
GlobalDeviceList	dd	?	;list handle for GLOBAL= List
InstanceDataList	dd	?	;list handle for inst data for devices
MonoDispAreaHasUMB	dd	0	;UMB in mono display area or not.
LoadHiDeviceActive	dd	-1	;we are active by default

	;------------------------------------------------;
	; save chain addresses for the hooked functions. ;
	;------------------------------------------------;

			public ActualAddInstanceItem	
			public ActualTGV86Mem	 	
			public ActualDOSMGRInstanceDev	

ActualAddInstanceItem	dd	?	;original _AddInstanceItem service
ActualTGV86Mem	 	dd	?	;original _TestGlobalV86Mem
ActualDOSMGRInstanceDev	dd	?	;original DOSMGR_InstanceDevice

LoadHi_OwnCall		dd	0	;INT 21H hook flag
UMBLinkState		dd	?	;original state of UMB links

V86_CB_Offset_Addr	dd	0	;Addr of Control block offset for V86MMGR
EMM_Patch_Ret_Addr	dd	0
EMM_Patch_NotPartial_Addr dd	0
V86_ImprtPtr_Addr	dd	0	;Addr of variable for V86MMGR
EMM_Patch_Ret_Addr2	dd	0
EMM_Patch_Ret_Addr2a	dd	0

	;------------------------------------------------;

VxD_DATA_ENDS



;******************************************************************************
;	       D E V I C E   C O N T R O L   P R O C E D U R E
;******************************************************************************

VxD_CODE_SEG

	Extrn	LoadHi_Instance_Create_VM:near
	Extrn	LoadHi_Instance_Destroy_VM:near
	Extrn	LoadHi_Instance_Suspend_VM:near
	Extrn   LoadHi_Instance_Resume_VM:near
	Extrn	LoadHi_InstanceInitComplete:near
IFDEF	DEBUG
	Extrn	LoadHi_Debug_Query:near
ENDIF
	Extrn	LoadHi_Take_Instance_SnapShot:near
	Extrn	Swap_LoadHi_Instance_Page:near
	Extrn	Get_Mapped_Page_Num:near
	Extrn	Control_Call_Hook:near

;******************************************************************************
;
;   LoadHi_Control
;
;   DESCRIPTION:
;
;   ENTRY:
;	EAX = Control call ID
;
;   EXIT:
;	If carry clear then
;	    Successful
;	else
;	    Control call failed
;
;   USES:
;	EAX, EBX, ECX, EDX, ESI, EDI, Flags
;
;==============================================================================

BeginProc LoadHi_Control,PUBLIC

; call 'Control_Call_Hook' so that LIMulators can hook any of the control 
; calls that they want to do additional processing on.

	pushad			
	call	Control_Call_Hook
	popad
	jc	SHORT LoadHi_Control_Ret;LIMulator failed the call

; if our part of the device is turned off because we are running on a newer
; version of windows, we should not call our hooks.

	cmp	LoadHiDeviceActive,0	;is it active ?
	jz	SHORT LoadHi_Control_Ret;no, carry is clear, return

; trap the control calls that we want to hook our selves.

	Control_Dispatch Sys_Critical_Init, LoadHi_Sys_Critical_Init
	Control_Dispatch Device_Init, LoadHi_Device_Init
	Control_Dispatch Create_VM, LoadHi_Instance_Create_VM
	Control_Dispatch Destroy_VM, LoadHi_Instance_Destroy_VM
	Control_Dispatch Init_Complete, LoadHi_InstanceInitComplete
	Control_Dispatch VM_Suspend, LoadHi_Instance_Suspend_VM
	Control_Dispatch VM_Resume, LoadHi_Instance_Resume_VM
	Control_Dispatch Sys_VM_Init, LoadHi_Sys_VM_Init
	Control_Dispatch System_Exit, <LoadHi_SystemExit>


IFDEF	DEBUG
	Control_Dispatch Debug_Query, LoadHi_Debug_Query
ENDIF	;DEBUG

	clc					; Ignore other control calls

LoadHi_Control_Ret:

	ret

EndProc LoadHi_Control

;----------------------------------------------------------------------------;
; LoadHi_Map_Pages:							     ;
;								             ;
; This routine maps in the UMB pages into the VM's address space. 	     ;
;----------------------------------------------------------------------------;

BeginProc LoadHi_Map_Pages,PUBLIC

	mov	eax,[FirstUMBPage]	;first page in the array
	mov	ecx,[NumUMBPages]	;number of pages to map in.

MapPagesLoop:

	call	Get_Mapped_Page_Num	;edx has the mapped page no.
	or	edx,edx			;is it an UMB ?
	jz	SHORT MapPagesCont	;no.
	push	ecx
	push	eax
	VMMcall _PhysIntoV86, <edx,ebx,eax,1,0>
	pop	eax
	pop	ecx

IFDEF	DEBUG
	or	eax,eax			;was the mapping successful ?
	jnz	SHORT @f 		;yes.
	debug_out "LoadHi:PhysIntoV86 fails to map phys page number #EDX into page number #EAX"
@@:
ENDIF	;DEBUG


MapPagesCont:

	inc	eax			;next V86 page
	loop	SHORT MapPagesLoop	;continue

	ret

EndProc LoadHi_Map_Pages
;----------------------------------------------------------------------------;
VxD_CODE_ENDS


;******************************************************************************
;		    I N I T I A L I Z A T I O N   C O D E
;******************************************************************************

VxD_ICODE_SEG

	Extrn	LoadHi_Add_Instance_Item:near
	Extrn	Get_UMB_Info:near
	Extrn	Get_Device_Info:near
	Extrn	Get_Ptr_To_Instance_Data_List:near

;----------------------------------------------------------------------------;
; LoadHi_Sys_Critical_Init:						     ;
;									     ;
; Entry:								     ;
;	 EDX  - 32 bit linear address of a table which has the UMB Page to   ;
;		physical page mapping information.			     ;
;									     ;
;        EBX  - VM handle						     ;
;	 EBP  - Client register frame for VM				     ;
;									     ;
; Action:								     ;
;	 . Saves the address of the mapping table for later use.   	     ;
;	 . Allocate space in Control Block for a couble of DWORDS to keep    ;
;	   track of each VM's instance data.				     ;
;	 . Hooks relevant VMM and DOSMGR services that this device must      ;
;	   monitor.							     ;
;									     ;
; Exit:									     ;
;									     ;
; Uses:									     ;
;----------------------------------------------------------------------------;
BeginProc LoadHi_Sys_Critical_Init,PUBLIC

    ;
    ; Implement the work arounds for some bugs in the 3.00 V86MMGR device.
    ;
	pushad
	xor	eax,eax

	VxDCall V86MMGR_Get_Version	      	

; if the version is above or equal 3.0A, the LoadHi device should be turned
; off.

	cmp	eax,030Ah		      	;Q: Is this version < 3.0A
	jb	SHORT LH_SCI_OK			;it is OK

; turn ourselves off.

	mov	LoadHiDeviceActive,0		;inactive

LH_SCI_OK:

	cmp	eax,0300h
	jne	LH_NoFix

    ;
    ; This first fix fixes the problem with the marking of ROM pages in the
    ;	V86MMGR memory scan code
    ;
	mov	eax, V86MMGR_Set_Mapping_Info
	mov	esi, 0FFFFFFFFh

	VMMcall Hook_Device_Service

IFDEF DEBUG
	jnc	short LHD05
	debug_out "Couldn't patch V86MMGR 1"
LHD05:
ENDIF
	jc	LHSCI_Fail
	push	esi
	mov	eax, V86MMGR_Set_Mapping_Info

	VMMcall Hook_Device_Service

	pop	esi
IFDEF DEBUG
	jnc	short LHD05a
	debug_out "Couldn't patch V86MMGR 1a"
LHD05a:
ENDIF
	jc	LHSCI_Fail
	mov	eax,0EDFh
	cmp	dword ptr [esi.eax],0107C766h
	jne	short TryDebug
	cmp	byte ptr [esi.eax+4],04h
	je	short GotPatchLoc

TryDebug:
	mov	eax,14DCh
	cmp	dword ptr [esi.eax],0107C766h
IFDEF DEBUG
	je	short LHD10
	debug_out "Did not find patch instruction 1 LH_Sys_Critical_Init"
LHD10:
ENDIF
	jne	short LH_SecondFix
	cmp	byte ptr [esi.eax+4],04h
IFDEF DEBUG
	je	short LHD20
	debug_out "Did not find patch instruction 2 LH_Sys_Critical_Init"
LHD20:
ENDIF
	jne	short LH_SecondFix
GotPatchLoc:
	lea	edx,[esi.eax+5] 		; EIP after patched instruction
	mov	ecx,offset32 LH_V86_Fix_Proc	; Patch Target
	sub	ecx,edx
	mov	byte ptr [esi.eax],0E8h 	; Near call
	mov	dword ptr [esi.eax+1],ecx
    ;
    ; This fix is for some problems in the EMM code.
    ;
LH_SecondFix:
	mov	eax, V86MMGR_Get_EMS_XMS_Limits
	mov	esi, 0FFFFFFFFh

	VMMcall Hook_Device_Service

IFDEF DEBUG
	jnc	short LHD30
	debug_out "Couldn't patch V86MMGR 2"
LHD30:
ENDIF
	jc	LHSCI_Fail
	push	esi
	mov	eax, V86MMGR_Get_EMS_XMS_Limits

	VMMcall Hook_Device_Service

	pop	esi
IFDEF DEBUG
	jnc	short LHD30a
	debug_out "Couldn't patch V86MMGR 2a"
LHD30a:
ENDIF
	jc	LHSCI_Fail
	mov	eax,27E6h
	cmp	dword ptr [esi.eax],75014338h
	jne	short TryDebug2
	cmp	byte ptr [esi.eax+4],48h
	je	short GotPatchLoc2
TryDebug2:
	mov	eax,3F24h
	cmp	dword ptr [esi.eax],75014338h
IFDEF DEBUG
	je	short LHD40
	debug_out "Did not find patch instruction 3 LH_Sys_Critical_Init"
LHD40:
ENDIF
	jne	short LH_ThirdFix
	cmp	byte ptr [esi.eax+4],48h
IFDEF DEBUG
	je	short LHD50
	debug_out "Did not find patch instruction 4 LH_Sys_Critical_Init"
LHD50:
ENDIF
	jne	short LH_ThirdFix
GotPatchLoc2:
	mov	word ptr [esi.eax+3],9090h	; NOP jne instruction
LH_ThirdFix:
    ;
    ; ESI still -> V86MMGR_Get_EMS_XMS_Limits address
    ;
	mov	eax,1B86h
	cmp	word ptr [esi.eax],358Bh
	jne	TryDebug3
	cmp	dword ptr [esi.eax+6],1D45B60Fh
	jne	TryDebug3
	mov	edx,dword ptr [esi.eax+2]
	mov	[V86_CB_Offset_Addr],edx
	mov	eax,26E9h
	cmp	dword ptr [esi.eax],7E800788h
IFDEF DEBUG
	je	short LHD55
	debug_out "Did not find patch instruction 5 LH_Sys_Critical_Init"
LHD55:
ENDIF
	jne	LH_NoFix
	cmp	word ptr [esi.eax+4],0401h
IFDEF DEBUG
	je	short LHD60
	debug_out "Did not find patch instruction 6 LH_Sys_Critical_Init"
LHD60:
ENDIF
	jne	LH_NoFix
	cmp	byte ptr [esi.eax+6],74h
IFDEF DEBUG
	je	short LHD70
	debug_out "Did not find patch instruction 7 LH_Sys_Critical_Init"
LHD70:
ENDIF
	jne	LH_NoFix
	jmp	GotPatchLoc3

TryDebug3:
	mov	eax,2974h
	cmp	word ptr [esi.eax],358Bh
IFDEF DEBUG
	je	short LHD90
	debug_out "Did not find patch instruction 8 LH_Sys_Critical_Init"
LHD90:
ENDIF
	jne	LH_FourthFix
	cmp	dword ptr [esi.eax+6],1D45B60Fh
IFDEF DEBUG
	je	short LHD100
	debug_out "Did not find patch instruction 9 LH_Sys_Critical_Init"
LHD100:
ENDIF
	jne	LH_FourthFix
	mov	edx,dword ptr [esi.eax+2]
	mov	[V86_CB_Offset_Addr],edx
	mov	eax,3DC0h
	cmp	dword ptr [esi.eax],7E800788h
IFDEF DEBUG
	je	short LHD110
	debug_out "Did not find patch instruction 10 LH_Sys_Critical_Init"
LHD110:
ENDIF
	jne	short LH_FourthFix
	cmp	word ptr [esi.eax+4],0401h
IFDEF DEBUG
	je	short LHD120
	debug_out "Did not find patch instruction 11 LH_Sys_Critical_Init"
LHD120:
ENDIF
	jne	short LH_FourthFix
	cmp	byte ptr [esi.eax+6],74h
IFDEF DEBUG
	je	short LHD130
	debug_out "Did not find patch instruction 12 LH_Sys_Critical_Init"
LHD130:
ENDIF
	jne	short LH_FourthFix
GotPatchLoc3:
	lea	edx,[esi.eax+8] 		; EIP after modified instructions
	mov	[EMM_Patch_Ret_Addr],edx
	movzx	ecx,byte ptr [esi.eax+7]	; Target of trailing JE
	add	ecx,edx
	mov	[EMM_Patch_NotPartial_Addr],ecx
	lea	edx,[esi.eax+2+5]		; EIP after instruction we insert
	mov	ecx,offset32 LH_V86_EMM_Fix_Proc; Patch Target
	sub	ecx,edx
	mov	byte ptr [esi.eax+2],0E9h	; Near unconditional jump
	mov	dword ptr [esi.eax+2+1],ecx
	mov	byte ptr [esi.eax+2+1+4],90h	; NOP left over byte
LH_FourthFix:
    ;
    ; ESI still -> V86MMGR_Get_EMS_XMS_Limits address
    ;
	mov	eax,16BEh
	cmp	word ptr [esi.eax], 3D8Bh
	jne	TryDebug4
	cmp	dword ptr [esi.eax+6], 510A7F8Dh
	jne	TryDebug4
	mov	ecx,dword ptr [esi.eax+2]
	mov	[V86_ImprtPtr_Addr],ecx
	cmp	dword ptr [esi.eax+2Eh], 6602E8C1h
	jne	TryDebug4
	cmp	dword ptr [esi.eax+2Eh+4], 59024189h
	jne	short TryDebug4
DoP4Retail:
	lea	edx,[esi.eax+5] 		; Jump back address
	mov	[EMM_Patch_Ret_Addr2],edx
	inc	[EMM_Patch_Ret_Addr2]		; Skip trailing NOP
	mov	ecx,offset32 LH_V86_EMM_Fix_Proc2 ; Patch Target
	sub	ecx,edx
	mov	byte ptr [esi.eax],0E9h 	; Near unconditional jump
	mov	dword ptr [esi.eax+1],ecx
	mov	byte ptr [esi.eax+5],90h	; NOP left over byte

	lea	edx,[esi.eax+2Eh+3+5]		; Jump back address
	mov	[EMM_Patch_Ret_Addr2a],edx
	mov	ecx,offset32 LH_V86_EMM_Fix_Proc2a ; Patch Target
	sub	ecx,edx
	mov	byte ptr [esi.eax+2Eh+3],0E9h	; Near unconditional jump
	mov	dword ptr [esi.eax+2Eh+3+1],ecx

	mov	eax,16E3h
	cmp	dword ptr [esi.eax], 4188028Ah
	jne	TryDebug4a
	cmp	byte ptr [esi.eax+4], 01h
	jne	TryDebug4a
	cmp	dword ptr [esi.eax+5], 0442B70Fh
	jne	TryDebug4a
DoP4aRetail:
	mov	byte ptr [esi.eax+1], 06h	; change EDX to ESI
	mov	byte ptr [esi.eax+7], 46h	; change EDX to ESI
	jmp	LH_NoFix

TryDebug4:
	mov	eax,23C9h
	cmp	word ptr [esi.eax], 3D8Bh
IFDEF DEBUG
	je	short LHD140
	debug_out "Did not find patch instruction 9 LH_Sys_Critical_Init"
LHD140:
ENDIF
	jne	TryDebug4a
	cmp	dword ptr [esi.eax+6], 510A7F8Dh
IFDEF DEBUG
	je	short LHD150
	debug_out "Did not find patch instruction 10 LH_Sys_Critical_Init"
LHD150:
ENDIF
	jne	TryDebug4a
	mov	ecx,dword ptr [esi.eax+2]
	mov	[V86_ImprtPtr_Addr],ecx
	cmp	dword ptr [esi.eax+95h], 6602E8C1h
IFDEF DEBUG
	je	short LHD160
	debug_out "Did not find patch instruction 11 LH_Sys_Critical_Init"
LHD160:
ENDIF
	jne	short TryDebug4a
	cmp	dword ptr [esi.eax+95h+4], 59024189h
IFDEF DEBUG
	je	short LHD170
	debug_out "Did not find patch instruction 12 LH_Sys_Critical_Init"
LHD170:
ENDIF
	jne	short TryDebug4a
DoP4Debug:
	lea	edx,[esi.eax+5] 		; Jump back address
	mov	[EMM_Patch_Ret_Addr2],edx
	inc	[EMM_Patch_Ret_Addr2]		; Skip trailing NOP
	mov	ecx,offset32 LH_V86_EMM_Fix_Proc2 ; Patch Target
	sub	ecx,edx
	mov	byte ptr [esi.eax],0E9h 	; Near unconditional jump
	mov	dword ptr [esi.eax+1],ecx
	mov	byte ptr [esi.eax+5],90h	; NOP left over byte

	lea	edx,[esi.eax+95h+3+5]		; Jump back address
	mov	[EMM_Patch_Ret_Addr2a],edx
	mov	ecx,offset32 LH_V86_EMM_Fix_Proc2a ; Patch Target
	sub	ecx,edx
	mov	byte ptr [esi.eax+95h+3],0E9h	; Near unconditional jump
	mov	dword ptr [esi.eax+95h+3+1],ecx
TryDebug4a:
	mov	eax,2414h
	cmp	dword ptr [esi.eax], 4188028Ah
IFDEF DEBUG
	je	short LHD180
	debug_out "Did not find patch instruction 13 LH_Sys_Critical_Init"
LHD180:
ENDIF
	jne	short LH_NoFix
	cmp	dword ptr [esi.eax+4], 01428A01h
IFDEF DEBUG
	je	short LHD190
	debug_out "Did not find patch instruction 14 LH_Sys_Critical_Init"
LHD190:
ENDIF
	jne	short LH_NoFix
	cmp	dword ptr [esi.eax+27h], 0442B70Fh
IFDEF DEBUG
	je	short LHD200
	debug_out "Did not find patch instruction 15 LH_Sys_Critical_Init"
LHD200:
ENDIF
	jne	short LH_NoFix
DoP4aDebug:
	mov	byte ptr [esi.eax+1], 06h	; change EDX to ESI
	mov	byte ptr [esi.eax+6], 46h	; change EDX to ESI
	mov	byte ptr [esi.eax+27h+2], 46h	; change EDX to ESI
LH_NoFix:
	popad

; if we are inactive (newer version of windows) we should proceed further
; with the call.

	cmp	LoadHiDeviceActive,0		;are we active ?
	jz	LH_SCI_Ret			;no.

; get information about the first UMB page and the number of pages that we
; could expect UMBs to be in starting with the first page. EDX has a pointer
; to a structure that has this information and the following routine can
; interpret it.




; EDX was the linear address in EMM386's environment. We need to get the 
; coressponding linear address in WIN386's space. We can't touch the block
; to figure out how big it is, for now we are going to go with the max size
; of the block, which is 4 + 4 + (100 - A0)* 4 = 392.

	

	VMMcall	_MapPhysToLinear,<edx, 400, 0>
	mov	edx,eax				;get it back into edx.
	

	call	Get_UMB_Info
	mov	FirstUMBPage,eax	;save the first UMB page number
	mov	NumUMBPages,edx		;number of pages containing UMBs

; check to see whether the start page is above the minimum that we can work with.

	cmp	eax,MIN_LOADHI_INST_PAGE
	jae	SHORT @f     		;it is OK

IFDEF	DEBUG
	debug_out "LoadHi: First UMB page is #EAX, this is unacceptable"
ENDIF	;DEBUG

	jmp	LHSCI_Fail		;fail the call
@@:

; create LIST handles for the lists that we will need for handling memory
; needed for instancing devices and for maintaining the list of GLOBAL= 
; devices.

	mov	eax,LF_Use_Heap
	mov	ecx,8			;for device names
	VMMcall	List_Create		
	mov	GlobalDeviceList,esi	;for global= device list

	mov	eax,LF_Use_Heap
	mov	ecx,SIZE InstDataStruc	;size of 'AddInstanceItem' datastruct
	VMMcall	List_Create		
	mov	InstanceDataList,esi	;for instancing devices


; allocate space worth 2 DWORDs in the Control Block and save the two offsets

	VMMcall	_Allocate_Device_CB_Area,<8,0>
	or	eax,eax			;did call fail ?

IFDEF	DEBUG
	jnz	SHORT @f 		;no.
	debug_out "LoadHi: Allocate_Device_CB_Area fails to allocate 8 bytes"
	jmp	LHSCI_Fail		;fail the call
@@:
ELSE
	jz	LHSCI_Fail		;yes, fail this call
ENDIF   ;DEBUG

	mov	CB_LoadHi_Inst_Buf_Ptr,eax
	add	eax,4			;next dword offset
	mov	CB_LoadHi_Inst_Hand,eax

; hook some of the services. Start with the _AddInstanceItem service.

	mov	eax,_AddInstanceItem	
	mov	esi,OFFSET32 LoadHi_Add_Instance_Item
	VMMcall	Hook_Device_Service

IFDEF	DEBUG
	jnc	SHORT @f		;successful
	debug_out "LoadHi: Hook_Device_Service fails to hook AddInstanceItem"
	jmp	LHSCI_Fail		;fail the call
@@:
ELSE
	jc	LHSCI_Fail		;fail the call
ENDIF	;DEBUG

	mov	[ActualAddInstanceItem],esi

; next hook the TestGlobalV86Mem service.

	mov	eax,_TestGlobalV86Mem
	mov	esi,OFFSET32 LoadHi_TestGlobalV86Mem
	VMMcall	Hook_Device_Service

IFDEF	DEBUG
	jnc	SHORT @f		;successful
	debug_out "LoadHi: Hook_Device_Service fails to hook TestGlobalV86Mem"
	jmp	LHSCI_Fail		;fail the call
@@:
ELSE
	jc	LHSCI_Fail 	;fail the call
ENDIF	;DEBUG

	mov	[ActualTGV86Mem],esi

; hook the DOSMGR_Instance_Device service

	mov	eax,DOSMGR_Instance_Device
	mov	esi,OFFSET32 LoadHi_Instance_Device
	VMMcall	Hook_Device_Service

IFDEF	DEBUG
	jnc	SHORT @f		;successful
	debug_out "LoadHi: Hook_Device_Service fails to hook DOSMGR_Instance_Device"
	jmp	LHSCI_Fail		;fail the call
@@:
ELSE
	jc	DEBFAR LHSCI_Fail  	;fail the call
ENDIF	;DEBUG

	mov	[ActualDOSMGRInstanceDev],esi

;;;;; hook the Allocate_Global_V86_Data_Area service
;;;;
;;;;	    mov     eax,_Allocate_Global_V86_Data_Area
;;;;	    mov     esi,OFFSET32 LoadHi_AGVDA_Hook
;;;;	    VMMcall Hook_Device_Service
;;;;
;;;;IFDEF   DEBUG
;;;;	    jnc     SHORT @f		    ;successful
;;;;	    debug_out "LoadHi: Hook_Device_Service fails to hook Allocate_Global_V86_Data_Area"
;;;;	    jmp     LHSCI_Fail		    ;fail the call
;;;;@@:
;;;;ELSE
;;;;	    jc	    DEBFAR LHSCI_Fail	    ;fail the call
;;;;ENDIF   ;DEBUG
;;;;
;;;;	    mov     [Real_AGVDA_Addr],esi

; assign the UMB pages & hook them.

	mov	eax,[FirstUMBPage]	;start UMB page.
	mov	ecx,[NumUMBPages]	;no of entries in the table

AssignPagesLoop:

; get the mapping page number.

	call	Get_Mapped_Page_Num	;edx returns the mapped page number
	or	edx,edx			;is it a UMB page ?
	jz	SHORT AssignPagesCont  	;no.

; if the page is in the range for a monochrome adapter, set a flag.

	call	ProcessPageInMonoDispArea

	push	ecx			;save loop count
	push	eax			;save current page number
	VMMcall _Assign_Device_V86_Pages, <eax,1,0,0>
	or	eax,eax			;did the call fail ?
	pop	eax			;get back page number
	jnz	SHORT @f 		;successful
	pop	ecx			;balance the stack

IFDEF	DEBUG
	debug_out "LoadHi: Assign_Device_V86_Pages fails on page number #EAX"
ENDIF	;DEBUG
	jmp	SHORT LHSCI_Fail   	;fail the call
@@:

; hook the page for monitoring page fault.

	push	eax			;save the current page number
	mov	esi,OFFSET32 Swap_LoadHi_Instance_Page
	VMMcall	Hook_V86_Page
	pop	eax
  	pop	ecx

IFDEF	DEBUG
	jnc	SHORT @f		;call was successful
	debug_out "LoadHi: Hook_V86_Page fails on page number #EAX"
	jmp	SHORT LHSCI_Fail     	;fail the call
@@:
ELSE
	jc	DEBFAR LHSCI_Fail	;fail the call
ENDIF 	;DEBUG
	
AssignPagesCont:

	inc	eax			;next V86 page number
	loop	AssignPagesLoop		;go through the table.

AssignPagesDone:

; map the pages in for the SYSTEM VM

    	VMMcall	Get_Sys_VM_Handle	;EBX = Sys_VM_Handle
	call	LoadHi_Map_Pages	;map pages in for SYS_VM
	
; we are done.

LH_SCI_Ret:
	
	clc
	ret

LHSCI_Fail:

    	Fatal_Error <OFFSET32 CrashMsg>

EndProc LoadHi_Sys_Critical_Init
;----------------------------------------------------------------------------;
; ProcessPageInMonoDispArea:						     ;
;									     ;
; ENTRY:								     ;
;       EAX  - V86 page number (0A0H - 10FH)			 	     ;
;	EDX  - Mapped page (0 if EAX is not a UMB page)		             ;
;                                                                            ;
; ACTION:							             ;
;       Sets MonoDispAreaHasUMB to -1 if EAX is within the mono display      ;
;       area page range and EDX is not 0.				     ;
;									     ;
; EXIT:									     ;
;	None.								     ;
;									     ;
; USES:									     ;
;	Flags.								     ;
;----------------------------------------------------------------------------;
BeginProc ProcessPageInMonoDispArea,PUBLIC

	cmp	eax,MONO_DISP_LO	;lower than mono display area ?
	jb	SHORT @f		;yes
	cmp	eax,MONO_DISP_HI	;higher than mono display area ?
	ja	SHORT @f		;yes.
	cmp	edx,0			;is there an UMB in this page ?
	jz	SHORT @f 		;no.
	mov	MonoDispAreaHasUMB,-1   ;there is an UMB in the mono display area
@@:
	ret

EndProc ProcessPageInMonoDispArea
;----------------------------------------------------------------------------;
; LoadHi_Device_Init:							     ;
;									     ;
;   DESCRIPTION:						             ;
;									     ;
;       At first this routine get the current UMB state and saves it, it then;
;       unliks the UMB and sets its own INT 21 hook which will prevent the   ;
;       UMBs from being linked back in.					     ;
;							                     ;
;       The routine then builds up a list of all 'GLOBAL=' devices that are  ;
;	specified in the [386Enhanced] section of system.ini.	     	     ;
;									     ;
;	It then scans [386Enhanced] section of SYSTEM.INI for 'LOCAL='       ;
;	devices and finds out whether they are LoadHi devices or not. If they;
;	are, then DOSMGR_Instance_Device is called. Ofcourse this call will  ;
;       be intercepted by the hook in this device and will not be chained on.;
;	This routine will do nothing for devices that are not loaded high.   ;
;									     ;
;   ENTRY:							  	     ;
;									     ;
;   EXIT:								     ;
;									     ;
;   USES:							             ;
;----------------------------------------------------------------------------;
BeginProc LoadHi_Device_Init,PUBLIC


; Get the UMB Link state, save it and turn the link state off.

	Push_Client_State
	VMMcall Begin_Nest_Exec 	;Get ready for software ints

; get the link state.

	mov	[ebp.Client_AX], 05802h ;get UMB link state
	mov	eax, 21h		;INT 21H to be done
	VMMcall Exec_Int		;do the INT
	movzx	eax,[ebp.Client_AX]	;return is in AL
	mov	UMBLinkState,eax	;save it

; reset the link state.

	mov	[ebp.Client_AX], 05803h ;set UMB link state
	mov	[ebp.Client_BX], 0	;unlink them
	mov	eax, 21h		;INT 21H to be done
	VMMcall Exec_Int		;do the INT

; end the nested exec calls.

	VMMcall End_Nest_Exec
	Pop_Client_State

; now hook INT 21H in Ring0.

	mov	eax, 21h		;want to hook INT 21H
	mov	esi, OFFSET32 Loadhi_Int21ISR
	VMMcall Hook_V86_Int_Chain	;INT 21H hooked.

; Process the "GLOBAL=" SYSTEM.INI strings

	mov	edi,offset32 LH_Global_String
	xor	esi, esi		;read [386ENH] section
	xor	edx,edx			;no default
	VMMCall Get_Profile_String	;Get first occurance
	mov	Prev_GPS_Pointer,edx	;save return value
	jc	short LHDI_GlobalDone	;Not found
	jmp	short LHDI_DoGlobal

LHDI_NextGlobal:

; get the next occurrence of 'GLOBAL='

	xor	esi, esi		;read [386ENH] section
	mov	edx,Prev_GPS_Pointer	;get last pointer
	mov	edi,offset32 LH_Global_String
	VMMCall Get_Next_Profile_String ;Get next occurance
	mov	Prev_GPS_Pointer,edx	;save return value
	jc	short LHDI_GlobalDone

LHDI_DoGlobal:

; allocate a new node for this.

	mov	esi,GlobalDeviceList	;get the handle
	VMMcall	List_Allocate		;allocate a new node
	VMMcall	List_Attach		;attach node to the list
	mov	edi,eax			;get a pointer to the new node.

	mov	esi,edx			;get a pointer to the name
	mov	ecx,8			;Max length of device names
	cld

LHDI_CopyName:

; copy the device name over to the new node. Pad it with spaces if name is
; less than 8 characters.

	lodsb

LHDI_TestEnd:

	or	al,al
	jz	short LHDI_PadSpace
	stosb
	loop	SHORT LHDI_CopyName
	jmp	short LHDI_NextGlobal

LHDI_PadSpace:

	mov	al,20h			;space pad next of the name
	rep	stosb
	jmp	short LHDI_NextGlobal

LHDI_GlobalDone:

; Process the 'LOCAL=' devices. For each such device find out if the device 
; is loaded high, if it is then instance it.


	mov	edi,offset32 LH_Local_String
	xor	esi, esi		;search [386ENH] section
	xor	edx,edx			;no default
	VMMCall Get_Profile_String	;Get first occurance
	mov	Prev_GPS_Pointer,edx	;save return value
	jc	short LHDI_LocalDone 	;Not found
	jmp	short LHDI_DoLocal

LHDI_NextLocal:

	xor	esi, esi		;read [386ENH] section
	mov	edx,Prev_GPS_Pointer	;get last pointer
	mov	edi,offset32 LH_Local_String
	VMMCall Get_Next_Profile_String ; Get next occurance
	mov	Prev_GPS_Pointer,edx	;save return value
	jc	short LHDI_LocalDone

LHDI_DoLocal:

; prepare a space padded copy of the name in a temporary buffer.

	mov	edi,offset32 LH_DevNameBuf
	mov	eax,20202020h
	mov	dword ptr [edi],eax
	mov	dword ptr [edi+4],eax
	mov	esi,edx
	mov	ecx,8			; Max length of device names

LHDI_CopyLocalName:

	cld
	lodsb
	or	al,al
	jz	short LHDI_TestDev
	stosb
	loop	LHDI_CopyLocalName

LHDI_TestDev:

	mov	esi,offset32 LH_DevNameBuf

; find out if this is in the Global Device List or not.

	call	LoadHi_IsDeviceGlobal	
	jc	SHORT LHDI_NextLocal	;yes, search for the next one.

; find out if the device is a LoadHi device.

	call	Get_Device_Info		;is this a LoadHi device ?
	jc	SHORT LHDI_NextLocal	;no, search for the next one.

; instance the device

	call	LoadHi_Instance_From_EDX_Size_EAX
	jmp	SHORT LHDI_NextLocal	;carry on search

LHDI_LocalDone:

; obtain a pointer to the list of instance data that the LIMulator has obtained
; from WIN386.

	call	Get_Ptr_To_Instance_Data_List

; EDI has a pointer to an array of nodes. Each node in the array is of 6 bytes
; The first DWORD is a seg:off of data to instance (will be in UMB area) and 
; the next WORD will be its size. The array is terminated by a DWORD of 0.
; Instance all of these areas.

LHDI_InatanceAdditionalLoop:

	cmp	[edi.LimInstanceDataPtr],0;end of array ?
	jz	SHORT LHDI_Ret		;yes
	mov	edx,[edi.LimInstanceDataPtr]

; convert the DWORD from seg:off form to a linear address.

	mov	eax,edx			;save it
	and	edx,0ffff0000h		;retain the segment
	shr	edx,12			;get it to start from bit 20.
	and	eax,0ffffh		;just the offset
	add	edx,eax			;EDX - linear address
	movzx	eax,[edi.LimInstanceDataSize]

; Instance the area

	call	LoadHi_Instance_From_EDX_Size_EAX
	add	edi,SIZE LimInstanceData ;next node
	jmp	SHORT LHDI_InatanceAdditionalLoop

LHDI_Ret:

	 clc
	 ret

EndProc LoadHi_Device_Init
;----------------------------------------------------------------------------;
; LoadHi_Instance_Device:						     ;
;									     ;
;   DESCRIPTION:							     ;
;	Instance the indicated INSTALLED DOS device driver only if it is     ;
;	loaded after higher than the start UMB page else pass it on to the   ;
;	original handler - DOSMGR_Instance_Device.			     ;
;	This service is only valid at Init_Complete device call time.	     ;
;									     ;
;   ENTRY:								     ;
;	ESI -> 8 character device name string				     ;
;	    THIS STRING MUST EXACTLY MATCH THE NAME AS IT WILL BE FOUND	     ;
;	    IN THE DEVICE HEADER IN LOW MEMORY!!!!!!!			     ;
;	    No case conversion is performed (name in dev hdr is upper case)  ;
;	    Length is 8 (name must be space padded as DOS device names are)  ;
;	    NO ':'s!! There is no ':' in the name in the device header.	     ;
;									     ;
;   EXIT:								     ;
;	Carry set if device could not be instanced			     ;
;	    o No device with this name in device list			     ;
;	    o User has overidden call with "GLOBAL=" in system.ini	     ;
;	    o The device does not have an arena associated with it.	     ;
;	Carry clear							     ;
;	    device instanced						     ;
;									     ;
;   USES:								     ;
;	FLAGS								     ;
;									     ;
;   NOTES:								     ;
;	This call applies only to INSTALLED character devices (device	     ;
;	    segment != 70h). It cannot instance devices that are in the DOS  ;
;	    RAM BIOS because there is no way to deliniate their start and    ;
;	    end addresses. It is the job of the DOS instancing to correctly  ;
;	    instance things related to character devices in the DOS RAM BIOS.;
;									     ;
;	This call instances the ENTIRE device. It cannot differentiate code  ;
;	    and data.							     ;
;									     ;
;	This service is available at Init_Complete time only.		     ;
;	    o Service cannot work until DOSMGR_Device_Init is complete.	     ;
;	    o Service is in ICODE segment so it becomes invalid after	     ;
;		Init_Complete.						     ;
;	    o Calls to _AddInstanceItem are invalid after Init_Complete.     ;
;									     ;
;	WARNING!! DO NOT USE THIS SERVICE TO INSTANCE DEVICES ADDED WITH THE ;
;	    DOSMGR_Add_Device SERVICE!!!!! This will not work properly. If   ;
;	    you need to instance one of these devices you must call	     ;
;	    _AddInstanceItem yourself on it, or use the GVDAInstance flag    ;
;	    on your _Allocate_Global_V86_Data_Area call.		     ;
;									     ;
;----------------------------------------------------------------------------;
BeginProc LoadHi_Instance_Device,PUBLIC


; find out if the device is in the global device list. If it is then we will
; not try to instance this device. We could actually end this call in this 
; routine, but for the time being will chain it on to DOSMGR.

	call	LoadHi_IsDeviceGlobal	;is it declared to be a global device?
	jc	SHORT LHID_Chain_On	;yes, chain call on.

; find out if the device is loaded high and if so, get its address and length

	call	Get_Device_Info		
	jc	SHORT LHID_Chain_On	;don't know about this, chain call on.

; instance the device

	call	LoadHi_Instance_From_EDX_Size_EAX
	clc				;device has been instanced
	ret

LHID_Chain_On:

; chain this call to DOSMGR_Instance_Device and let it deal with it in what
; ever way it want's to.

	jmp	[ActualDOSMGRInstanceDev]

EndProc LoadHi_Instance_Device
;----------------------------------------------------------------------------;
; LoadHi_Instance_From_EDX_Size_EAX:					     ;
;									     ;
;   DESCRIPTION:						             ;
;	Instances a particular device whose starting address and location    ;
;	are passed in.							     ;
;  									     ;
;   ENTRY:								     ;
;	EDX -  Start of the device.				             ;
;	EAX -  Length of the device.					     ;
;									     ;
;   EXIT:								     ;
;	NONE.								     ;
;									     ;
;   USES:								     ;
;	Flags.							             ;
;----------------------------------------------------------------------------;

BeginProc LoadHi_Instance_From_EDX_Size_EAX,PUBLIC

	pushad				;save all registers

; EDX has the start of the device and EAX has it's size.  Allocate an item for
; the add_instance_item call and fill in the information.

	mov	edi,eax			;size of device
	mov	esi,InstanceDataList	;get the handle for the list
	VMMcall	List_Allocate		;get a new list
	VMMcall	List_Attach		;attach the list on

; fill in the information for this node

	mov	[eax.InstLinkF],0	;initialize
	mov	[eax.InstLinkB],0	;initialize
	mov	[eax.InstLinAddr],edx	;save linear address of device
	mov	[eax.InstSize],edi	;size in bytes of the device
	mov	[eax.InstType],ALWAYS_Field

; call service to instance the data.

	VMMcall	_AddInstanceItem,<eax,0>
	popad				;restore all registers
	ret

EndProc LoadHi_Instance_From_EDX_Size_EAX
;----------------------------------------------------------------------------;
; LoadHi_IsDeviceGlobal:						     ;
;									     ;
;   DESCRIPTION:						             ;
;	Finds out if a passed in device name is in the Global device list    ;
;       or not.								     ;
;  									     ;
;   ENTRY:								     ;
;	ESI -  pointer to device name.	      				     ;
;									     ;
;   EXIT:								     ;
;	CARRY SET: if match obtained in global list.			     ;
;	CARRY CLEAR: otherwise.						     ;
;									     ;
;   USES:								     ;
;	EAX, Flags.						             ;
;----------------------------------------------------------------------------;
BeginProc LoadHi_IsDeviceGlobal,PUBLIC					

	push	esi
	push	edi
	push	ecx
	mov	edi,esi			;get the name pointer

; get a pointer to the first node in the Global device list.

	mov	esi,GlobalDeviceList	;get the list handle
	VMMcall	List_Get_First		;get a pointer to the first node.
	jz	SHORT LHIDG_No_Match 	;empty list, no match found

LHIDG_Match_Name:

	mov	esi,eax			;get a pointer to the node
	cld
	mov	ecx,8			;8 characters to match for
	repe	cmpsb			;do the names match ?
	jz	SHORT LHIDG_Match_Found	;match obtained

; get to the next node.

	mov	esi,GlobalDeviceList	;get the list handle
	VMMcall	List_Get_Next		;get a pointer to the first node.
	jnz	SHORT LHIDG_Match_Name	;continue to match

LHIDG_No_Match:

	clc				;not in global list
	jmp	SHORT LHIDG_Ret

LHIDG_Match_Found:

	stc				;device is in global list

LHIDG_Ret:

	pop	ecx
	pop	edi
	pop	esi			;restore thrashed registers
	ret

EndProc LoadHi_IsDeviceGlobal
;;;;;----------------------------------------------------------------------------;
;;;;;	LoadHi_AGVDA_Hook							 ;
;;;;;										 ;
;;;;;	DESCRIPTION:								 ;
;;;;;	    Hook to fix Allocate_Global_V86_Data_Area so that for page aligned	 ;
;;;;;	    reclaim allocations it will not return an address < 10000h. 	 ;
;;;;;										 ;
;;;;;	ENTRY:									 ;
;;;;;	    As for Allocate_Global_V86_Data_Area				 ;
;;;;;										 ;
;;;;;	EXIT:									 ;
;;;;;	    As for Allocate_Global_V86_Data_Area				 ;
;;;;;										 ;
;;;;;	USES:									 ;
;;;;;	    'C' calling 							 ;
;;;;;										 ;
;;;;;----------------------------------------------------------------------------;
;;;;
;;;;BeginProc LoadHi_AGVDA_Hook
;;;;
;;;;	    enter   0,0
;;;;
;;;;AGVDAnBytes   equ  dword ptr [ebp+8]	    ; Number of bytes
;;;;AGVDAflags	  equ  dword ptr [ebp+12]	    ; Flags
;;;;
;;;;	    push    esi
;;;;	    push    edi
;;;;	    push    ebx
;;;;
;;;;	    VMMCall _GetFirstV86Page
;;;;
;;;;	    cmp     eax,00000010h
;;;;	    jae     short LoadHi_AGV_ChainThrough
;;;;	    mov     esi,AGVDAflags
;;;;	    test    esi,GVDAPageAlign
;;;;	    jz	    short LoadHi_AGV_ChainThrough
;;;;	    test    esi,GVDAReclaim
;;;;	    jz	    short LoadHi_AGV_ChainThrough
;;;;	    and     esi,NOT(GVDAReclaim)	    ; Turn off reclaim
;;;;	    mov     ecx,00000010h
;;;;	    sub     ecx,eax			    ; Off by this many pages
;;;;	    shl     ecx,12			    ; Pages to bytes
;;;;
;;;;	    cCall   [Real_AGVDA_Addr],<ecx,esi>
;;;;
;;;;	    jmp     short LoadHi_ChkRet
;;;;
;;;;LoadHi_AGV_Again:
;;;;
;;;;	    cCall   [Real_AGVDA_Addr],<AGVDAnBytes,esi>
;;;;
;;;;LoadHi_ChkRet:
;;;;	    or	    eax,eax			    ; Error?
;;;;	    jz	    short LoadHi_AGV_Done	    ; Yes, finished
;;;;	    cmp     eax,00010000h
;;;;	    jb	    short LoadHi_AGV_Again
;;;;LoadHi_AGV_Done:
;;;;	    pop     ebx
;;;;	    pop     edi
;;;;	    pop     esi
;;;;	    leave
;;;;	    ret
;;;;
;;;;LoadHi_AGV_ChainThrough:
;;;;	    pop     ebx
;;;;	    pop     edi
;;;;	    pop     esi
;;;;	    leave
;;;;	    jmp     [Real_AGVDA_Addr]
;;;;
;;;;EndProc LoadHi_AGVDA_Hook

;******************************************************************************
;
;   LH_V86_Fix_Proc
;
;   DESCRIPTION:
;	Patch V86MMGR MEM_SCAN behavior
;
;   ENTRY:
;	None
;
;   EXIT:
;	None
;
;   USES:
;	None
;
;==============================================================================


BeginProc LH_V86_Fix_Proc

	test	word ptr [edi],0000001110100000b
	jnz	short SkipPg
	or	word ptr [edi],0000010000000001b
SkipPg:
	ret

EndProc LH_V86_Fix_Proc

;----------------------------------------------------------------------------;
VxD_ICODE_ENDS


VxD_CODE_SEG

;******************************************************************************
;
;   LH_V86_EMM_Fix_Proc
;
;   DESCRIPTION:
;	Hook to V86MMGR EMS driver.
;
;   ENTRY:
;	EBX is VM handle
;	THIS ROUTINE IS JUMPED TO NOT CALLED!!!!
;
;   EXIT:
;	None
;
;   USES:
;	None
;
;==============================================================================

BeginProc LH_V86_EMM_Fix_Proc

	push	ebx
	push	edi
	mov	edi,[V86_CB_Offset_Addr]
	add	ebx,dword ptr [edi]
	mov	ebx,dword ptr [ebx+50h]
	or	ebx,ebx
	jz	short NoBase
	test	byte ptr [ebx+691h],04h
NoBase:
	pop	edi
	pop	ebx
	jnz	short NormCode
	push	ebx
	mov	ebx,esi
	sub	ebx,dword ptr [esp+(1*4).Pushad_ESI]
;;;;	    shr     ebx,3	    ; index of entry
;;;;	    shl     ebx,2	    ; Times 4 4k pages per 16k page
;;;; Combine all of above yields
	shr	ebx,1
	cmp	ebx,0A0h
	pop	ebx
	jae	short NormCode
JNPart:
	jmp	[EMM_Patch_NotPartial_Addr]

NormCode:
	cmp	byte ptr [esi+01],4
	je	short JNPart
	jmp	[EMM_Patch_Ret_Addr]

EndProc LH_V86_EMM_Fix_Proc


;******************************************************************************
;
;   LH_V86_EMM_Fix_Proc2 and 2a
;
;   DESCRIPTION:
;	Hook to V86MMGR EMS driver.
;
;   ENTRY:
;	THIS ROUTINE IS JUMPED TO NOT CALLED!!!!
;
;   EXIT:
;	None
;
;   USES:
;	None
;
;==============================================================================

BeginProc LH_V86_EMM_Fix_Proc2

	push	edi
	mov	edi,[V86_ImprtPtr_Addr]
	mov	edi,dword ptr [edi]
	jmp	[EMM_Patch_Ret_Addr2]

EndProc LH_V86_EMM_Fix_Proc2

BeginProc LH_V86_EMM_Fix_Proc2a

	mov	word ptr [ecx+2],ax
	pop	ecx
	pop	edi
	jmp	[EMM_Patch_Ret_Addr2a]

EndProc LH_V86_EMM_Fix_Proc2a

;----------------------------------------------------------------------------;
; LoadHi_Sys_VM_Init:							     ;
;									     ;
; Takes the instance snap shot and releases all the list memory that was used;
; in the initialization phase.						     ;
;----------------------------------------------------------------------------;
BeginProc LoadHi_Sys_VM_Init,PUBLIC

; prepare the snap shot for the instance buffers

	call	LoadHi_Take_Instance_SnapShot

; release all initialization list memories.

	mov	esi,GlobalDeviceList	;list used to store 'GLOBAL=' devices
	VMMcall	List_Destroy
	mov	esi,InstanceDataList	;list used to allocate instance data
	VMMcall	List_Destroy

	clc				;call successful
	ret

EndProc LoadHi_Sys_VM_Init
;----------------------------------------------------------------------------;
; Loadhi_Int21ISR:							     ;
;									     ;
; Traps the SetUMBLink INT 21H call and returns failure if the call tries to ;
; link the UMBs in.							     ;
;									     ;
;   ENTRY:								     ;
;	EAX = Interrupt # (21h)						     ;
;	EBX = VM handle							     ;
;									     ;
;   EXIT:								     ;
;									     ;
;   USES:								     ;
;	All registers and flags						     ;
;----------------------------------------------------------------------------;
BeginProc LoadHi_Int21ISR, High_Freq,PUBLIC

	cmp	[ebp.Client_AX],5803h	;Set Link state call ?
	jnz	SHORT LoadHi_Int21Chain ;no.
	cmp	[ebp.Client_BX],1	;Link UMB's in ?
	jnz	SHORT LoadHi_Int21Chain ;no.
	cmp	LoadHi_OwnCall,-1	;from ourselves ?
	jz	SHORT LoadHi_Int21Chain ;yes.

; fail the set link call.

	or	[ebp.Client_Flags], CF_Mask
	mov	[ebp.Client_AX],1	;invalid function (at this time)
	clc				;Don't reflect this int
	ret

LoadHi_Int21Chain:

	stc				;chain interrupt on
	ret

EndProc LoadHi_Int21ISR 
;----------------------------------------------------------------------------;
; LoadHi_SystemExit:							     ;
;									     ;
; This is called at system exit time and the UMB link information is reset.  ;
;----------------------------------------------------------------------------;
BeginProc LoadHi_SystemExit,PUBLIC

	Push_Client_State
	VMMcall Begin_Nest_Exec 	;Get ready for software ints

; reset the link state.

	mov	LoadHi_OwnCall,-1	;we should nor trap it ourselves
	mov	[ebp.Client_AX], 05803h ;get UMB link state
	mov	ebx,UMBLinkState	;get the saved state
	and 	bx,0ffh			;only BL is significant
	mov	[ebp.Client_BX],bx	;save the state to restore
	mov	eax, 21h		;INT 21H to be done
	VMMcall Exec_Int		;do the INT
	mov	LoadHi_OwnCall,0	;just to make it clean.

; end the nested exec calls.

	VMMcall End_Nest_Exec
	Pop_Client_State

	clc				;call successful
	ret

EndProc LoadHi_SystemExit
;----------------------------------------------------------------------------;
;******************************************************************************
;			    S E R V I C E S
;******************************************************************************

BeginProc VDD2_Get_Version, Service

; if there is atleast one UMB in the mono display area then we will return
; success on this call.

	cmp	MonoDispAreaHasUMB,0	;is there any UMB in MONO area ?
	jnz	SHORT @f		;yes, return MONO disp VXD exits.
	xor	eax,eax
	xor	esi,esi	
	stc				;no secondary display VXD
	ret
@@:
	mov	esi,OFFSET32 LoadHi_Device_Name
	mov	eax, 100h
	clc
	ret

EndProc VDD2_Get_Version

;******************************************************************************
;		     S E R V I C E   H O O K S
;******************************************************************************

;----------------------------------------------------------------------------;
; LoadHi_TeastGlobalV86Mem:					 	     ;
;									     ;
; Entry:								     ;
;	unsigned	LH_TGVLinAdd	(linear address)  		     ;
;	unsigned	LH_TGVnBytes	(length of address in bytes)	     ;
;	unsigned	LH_TGVflags					     ;
;									     ;
; Action:								     ;
;	. If the Linear address is above 0A0000H, this routine returns a 1   ;
;	  in EAX to imply that the address is global, else it will chain     ;
;	  the call on to the original service handler.			     ;
;									     ;
; Exit:									     ;
;	. EAX = 1 if the linear address is above 0A0000H, else it chains the ;
;	  call along.							     ;
;									     ;
; Uses:									     ;
;----------------------------------------------------------------------------;

BeginProc LoadHi_TestGlobalV86Mem,PUBLIC

	enter	0,0

	LH_TGVLinAdd equ	dword ptr [ebp+8]
	LH_TGVnBytes equ	dword ptr [ebp+12]
	LH_TGVflags  equ	dword ptr [ebp+16]

	mov	eax,FirstUMBPage	;get the first UMB page
	shl	eax,12			;convert into a linear address
	cmp	LH_TGVLinAdd,eax	;in UMB range ?
	jae	SHORT LH_TGVGlobalAdd	;yes.
	leave
	jmp	[ActualTGV86Mem]	;chain it on

LH_TGVGlobalAdd:

	mov	eax,1			;address is globa (in UMB range)
	leave
	ret

EndProc LoadHi_TestGlobalV86Mem
;******************************************************************************
;	       D E V I C E   C O N T R O L   H A N D L E R S
;******************************************************************************


;******************************************************************************
;			L O C A L   P R O C E D U R E S
;******************************************************************************


;******************************************************************************
;		       D E B U G G I N G   C O D E
;******************************************************************************


IFDEF DEBUG

ENDIF

VxD_CODE_ENDS


END LoadHi_Real_Mode_Init

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\lhvxd\vdd2.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1991
;
;   Title:	vdd2.inc - VDD definitions for Secondary VDD
;
;   Version:	1.00
;
;   Author: MDW
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   02-Aug-1989 MDW Added service definitions
;==============================================================================


Begin_Service_Table VDD2

;***************
;VDD2 services for other devices and VMM(Get_Version must be first)
;
VDD2_Service	VDD2_Get_Version, LOCAL  ; Get version number and ID string ptr
End_Service_Table VDD2

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\lhvxd\umb.asm ===
PAGE 58,132
;******************************************************************************
TITLE LoadHi -- UMB related support routines for main VXD.
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1986-1991
;
;   Title:	UMB.ASM -
;
;   Author:	AC
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;
;==============================================================================
;
;   DESCRIPTION:
;
;******************************************************************************

	.386p


;******************************************************************************
;			      I N C L U D E S
;******************************************************************************



	.XLIST
	INCLUDE VMM.Inc
	.LIST

;******************************************************************************
;				 E Q U A T E S
;******************************************************************************

DEV_ARENA_TYPE	equ	44h		;arena type associated with devices
CHAR_DEV	equ	8000h		;character device

;******************************************************************************
;			     S T R U C T U R E S
;******************************************************************************

		;----------------------------------------------;
		; structure of a device header		       ;
		;----------------------------------------------;

SYSDEV	STRUC
SDEVNEXT	DD	?	;Pointer to next device header
SDEVATT 	DW	?	;Attributes of the device
SDEVSTRAT	DW	?	;Strategy entry point
SDEVINT 	DW	?	;Interrupt entry point
SDEVNAME	DB	8 DUP (?) ;Name of device (only first byte used for block)
SYSDEV	ENDS

		;----------------------------------------------;
		; structure of an arena header.		       ;
		;----------------------------------------------;

ArenaHeader STRUC
ArenaType	DB	?	;type of arena
ArenaOwner	DW	?	;owner of the arena
ArenaSize	DW	?	;size of arena in para
ArenaUnused	DB	3 DUP (?) ;unused
ArenaName	DB	8 DUP (?) ;name of owner
ArenaHeader ENDS

;******************************************************************************
;			   F L A G   E Q U A T E S
;******************************************************************************

;******************************************************************************
;			    L O C A L	D A T A
;******************************************************************************

VxD_DATA_SEG

LimPageMapPtr		dd	? 	;pointer to LIMs log-phys mapping
LimStartUMBPage 	dd	? 	;starting UMB page number
DeviceHeaderStartPtr	dd	?	;start of the device header list
LimInstanceDataPtr	dd	?	;pointer to instance data list

VxD_DATA_ENDS


VxD_CODE_SEG


VxD_CODE_ENDS


;******************************************************************************
;		    I N I T I A L I Z A T I O N   C O D E
;******************************************************************************

VxD_REAL_INIT_SEG

;******************************************************************************
;
;   Real_Mode_Hook
;
;   DESCRIPTION:
;
;      This routine is called from the Real_Mode_Init routine of the VXD and
;      lets the limulator part of the VXD do it's own real mode initialization
;      stuff.
;
;   ENTRY:
;
;	ALL REGISTERS SETUP AS FOR A REAL, REAL_MODE_INIT call.
;
;   EXIT:
;
;      Setup BX,SI registers appropriatesly. Thats is, if a default hook which
;      does noting should zero out BX & SI (no pages to exclude and no instance
;      data items) and AX should have the default return code .
;
;   USES:
;	AX, BX, DX, SI, Flags
;
;==============================================================================
BeginProc Real_Mode_Hook,PUBLIC

	xor	bx, bx				; No pages to exclude
	xor	si, si				; No instance data
	mov	ax, Device_Load_Ok		; OK to load device
	ret

EndProc Real_Mode_Hook
;----------------------------------------------------------------------------;
VxD_REAL_INIT_ENDS

VxD_ICODE_SEG

		PUBLIC Get_UMB_Info

;----------------------------------------------------------------------------;
; Get_UMB_Info:								     ;
; 	       								     ;
; This routine knows about the interface between the LoadHi VXD and the      ;
; Limulator that load it.  The code here assumes the following interface:    ;
;									     ;
; Entry:								     ;
;	 EDX - 32 bit linear address to the following structure:	     ;
;									     ;
;	       assume that the first UMB page is physical page number I      ;
;	       and the last UMB page is physical page number J. In between   ;
;	       there probably will be pages that are not UMB pages.	     ;
;       								     ;
;	       DWORD    -     Start of Dos device header chain (linAddr)     ;
;	       DWORD	-     I (first page).				     ;
;	       DWORD	-     page which is mapped into page I		     ;
;	       DWORD	-     page which is mapped into (I+1):0 if not UMB pg;
;	       DWORD	-     page which is mapped into (I+2):0 if not UMB pg;
;		 ---- similar DWORD for pages (I+3) through (J-1) ----       ;
;	       DWORD	-     page which is mapped into page J		     ;
;	       DWORD	-     pointer to additional instance data.	     ;
;								             ;
; Exit:									     ;
;	 EAX  - First UMB page number. (I)				     ;
;	 EDX  - # of consecutive pages that may have UMBs in them. (J-I+1)   ;
;									     ;
; Uses:  EAX,EDX and Flags.						     ;
;----------------------------------------------------------------------------;
BeginProc Get_UMB_Info

; get and save the linear address of the start of the device header chain

	mov	eax,[edx]
	mov	DeviceHeaderStartPtr,eax
	add	edx,4

; get the pointer to additional instance data table

	mov	eax,[edx]
	mov	LimInstanceDataPtr,eax
	add	edx,4

; EDX has the linear address of the array of logical and physical pages. 
; Save the start UMB page number and the array.

	mov	eax,[edx]		;get the start UMB page number
	mov	LimStartUMBPage,eax	;save it
	add	edx,4			;next is the actual map table
	mov	[LimPageMapPtr],edx	;save it for later routines

; get the number of consecutive pages that may have UMBs in them.

	mov	edx, 0ffh + 1 		;1 past the last V86 page num
	sub	edx,eax
	ret

EndProc Get_UMB_Info
;----------------------------------------------------------------------------;
; Get_Device_Info:						 	     ;
;									     ;
;   DESCRIPTION:							     ;
;	Tries to get the starting address and size of a device which is      ;
;	loaded high (interested in CONFIG.SYS devices only).		     ;
;									     ;
;   ENTRY:								     ;
;	ESI -> 8 character device name string				     ;
;	    THIS STRING MUST EXACTLY MATCH THE NAME AS IT WILL BE FOUND	     ;
;	    IN THE DEVICE HEADER IN LOW MEMORY!!!!!!!			     ;
;	    No case conversion is performed (name in dev hdr is upper case)  ;
;	    Length is 8 (name must be space padded as DOS device names are)  ;
;	    NO ':'s!! There is no ':' in the name in the device header.	     ;
;									     ;
;   EXIT:								     ;
;	Carry clear if the device is loaded high and was loaded from         ;
;	config.sys. (This implementaion assumes that devices loaded from     ;
;	config.sys will have the special DOS4/DOS5 arena associated with     ;
;	them). In this case:						     ;
;	   								     ;
;	       EDX - Start of the device part that has to be instanced.	     ;
;	       EAX - Length of the portion in bytes.			     ;
;								             ;
;	Carry set if:							     ;
;	       o Device cannot be found in the device header chain	     ;
;	       o Device not loaded high					     ;
;	       o Device is not a character device.		             ;
;	       o Device cannot be sized properly			     ;
;									     ;
;   USES:								     ;
;	FLAGS,EAX,EDX							     ;
;									     ;
;----------------------------------------------------------------------------;

BeginProc Get_Device_Info

; Search the device header list for a match for this device name 
	
	push	edi
	push	ecx
	push	ebx
	mov	edi,DeviceHeaderStartPtr;pointer to the first dev.
	mov	edx,edi			;get the first pointer
	shr	edx,4			;make up atritrary segment value
	shl	edx,16			;get the segment in hiword
	mov	ebx,edi			;get the linear address
	and	ebx,0fh			;get the balance in a para
	add	edx,ebx			;edx has seg:off of current guy
	xor	ebx,ebx			;previous segment

ChkDev:

	test	[edi.SDEVATT], CHAR_DEV	;deal with character devices only
	jz	short NextDev		;Skip non character devices
	push	esi
	push	edi			;save pointers
	lea	edi,[edi.SDEVNAME]	;start of this device's name
	mov	ecx,8
	cld
	repe	cmpsb			;check to see if it matches
	pop	edi
	pop	esi			;restore pointers
	jz	short FoundDev		;correct device

NextDev:

	mov	ebx,edx			;save segment:off of 'prev' guy
	mov	edi,[edi.SDEVNEXT]	;pointer to next device
	mov	edx,edi 		;EDX is SEG:OFF of device
	cmp	di, 0FFFFh		;End of Device list?
	je	DevExit			;Y: Done with device instance data
	mov	ecx,edi
	and	ecx,0000FFFFh		;ecx is offset of dev
	shr	edi,16
	mov	eax,edi 		;eax is Segment of device for BIOS test
	shl	edi,4
	add	edi,ecx 		;edi is lin addr of device
	jmp	short ChkDev		;continue searching

FoundDev:

; EDI has a pointer to the device, check to see if this is past the UMB line.

	mov	eax,LimStartUMBPage	;get the start of the UMB page
	shl	eax,12			;convert to linear address
	cmp	edi,eax			;is it above the UMB line ?
	jb	DevExit		       	;no, not interested

; check to see if the device has a valid arena header

	sub	edi,16			;point to the arena
	cmp	[edi.ArenaType],DEV_ARENA_TYPE
	jnz	SHORT DevMayBeCombined 	;may be a combined case
	movzx	eax,[edi.ArenaOwner]	;get the owner
	dec	eax			;back one up
	shl	eax,4			;convert to linear address
	cmp	eax,edi			;correct owner ?
	jnz	SHORT DevMayBeCombined	;may be a combined case

; this device has a valid arena header. However, if the prev device has 
; the same segment start value as this one, then this device is the 
; first in a combined list.

	push	ebx			;save last dev's seg:off
	push	edx			;save cur dev's seg:off
	shr	ebx,16			;last dev's seg
	shr	edx,16			;cur dev's seg
	cmp	ebx,edx			;are they same
	pop	edx
	pop	ebx			;restore
	jz	SHORT DevNotLastInMany	;first device of a combined list

; return with a pointer to the start of the device in EDX and a size in 
; EAX and carry clear.

	movzx	eax,[edi.ArenaSize]	;get size in paragraphs
	shl	eax,4			;convert to size in bytes
	lea	edx,[edi][16]		;start of the device
	jmp	SHORT DevSuccess	;did it right.

DevNotLastInMany:

; EDI points to a device arena which is the either the first or one of the 
; middle ones in a group of devices that have been loaded together.
; EDX has the seg:off of this device and EBX has the seg:off
; of the previous device. Their difference should give the size.

; however, this may not be a case of devices loaded together at all. We will
; not try to size the device if the offset of the previous device is less 
; than the offset of the current device. (we have established that the
; segments are the same so we can simply compare EDX and BX)

	cmp	edx,ebx			;is current in higher mem address ?
	ja	SHORT DevExit 		;yes, cannot size this device.

	add	edi,16			;point to the start of the device
	xchg	edx,edi			;EDX has the start of the device
	mov	eax,ebx			;get last's SEG:OFF
	sub	eax,edi			;difference of offs as segs are same
	jmp	SHORT DevSuccess	;did it right.

DevMayBeCombined:

; This device does not have an associated arena header. It may be either the
; middle one or the last one amongst a group of devices loaded together.
; EDX has the seg:off of the current device and EBX has the seg:off of the
; previous one. If the segments match, then this is a middle one and the
; difference of EBX and EDX is the size.

	push	ebx			;save last dev's seg:off
	push	edx			;save cur dev's seg:off
	shr	ebx,16			;last dev's seg
	shr	edx,16			;cur dev's seg
	cmp	ebx,edx			;are they same
	pop	edx
	pop	ebx			;restore
	jz	SHORT DevNotLastInMany	;middle device in a group of many

; this device could be the last one in the chain. We have to scan forward
; and see when we get to a case where a device has the same segment as well
; as a device header.

	add	edi,16			;back to the device.

DevScanFwd:

	mov	eax,[edi.SDEVNEXT]	;pointer to next device
	shr	eax,16			;get the segment
	push	edx			;save our dev's seg:off
	shr	edx,16			;get it's segment
	cmp	eax,edx			;still the same ?
	pop	edx			;restore
	jnz	SHORT DevIsItTheFirst  	;did we get the first one.
	mov	edi,[edi.SDEVNEXT]	;pointer to next device
	mov	ecx,edi
	and	ecx,0000FFFFh		;ecx is offset of dev
	shr	edi,16
	mov	eax,edi 		;eax is Segment of device for BIOS test
	shl	edi,4
	add	edi,ecx 		;edi is lin addr of device
	jmp	SHORT DevScanFwd	;scan forward

DevIsItTheFirst:

; EDI should now be pointing to the first device in the group of devices.
; check to see if the device has a valid arena header

	sub	edi,16			;point to the arena
	cmp	[edi.ArenaType],DEV_ARENA_TYPE
	jnz	SHORT DevExit		;don't know about this
	movzx	eax,[edi.ArenaOwner]	;get the owner
	dec	eax			;back one up
	shl	eax,4			;convert to linear address
	cmp	eax,edi			;correct owner ?
	jnz	SHORT DevExit		;don't know about this.
	
; EDI points to the arena. Get the size of the combined device.

	movzx	eax,[edi.ArenaSize]	;get size in paragraphs
	shl	eax,4			;convert to size in bytes
	movzx	ebx,dx			;get the offset of our device
	sub	eax,ebx			;size of our device.
	shr	edx,16			;get the segment
	shl	edx,4			;convert to linear address
	add	edx,ebx			;add in the offset

DevSuccess:

	clc				;indicate success
	jmp	SHORT DevRet		;return

DevExit:

	stc				;failure

DevRet:
	
	pop	ebx			
	pop	ecx
	pop	edi
	ret


	

EndProc Get_Device_Info
;----------------------------------------------------------------------------;
; Get_Ptr_To_Instance_Data_List:					     ;
;									     ;
;   DESCRIPTION:							     ;
;	Returns a pointer to the list of instance data address and size that ;
;       was copied out of the Windows/386 3.00 initialization data structure.;
;	                                                                     ;
;   ENTRY:								     ;
;	  None.							             ;
;	                                                                     ;
;   EXIT:								     ;
;	EDI - 32 bit pointer to an array where each entry is of 6 bytes      ;
;             (except last). The first DWORD is a seg:off address of the     ;
;	      start of a data area that is to be instanced and the last      ;
;             WORD is the size of the area in bytes.                         ;
;									     ;
;             The last entry in the array must be a DWORD of 0.		     ;
;									     ;
;   USES:								     ;
;	FLAGS,EDX							     ;
;----------------------------------------------------------------------------;
BeginProc Get_Ptr_To_Instance_Data_List

	mov	edi,LimInstanceDataPtr		;obtained at start up
	ret

EndProc Get_Ptr_To_Instance_Data_List
;----------------------------------------------------------------------------;
VxD_ICODE_ENDS

;----------------------------------------------------------------------------;

VxD_CODE_SEG

		PUBLIC	Get_Mapped_Page_Num	

;----------------------------------------------------------------------------;
; Control_Call_Hook:							     ;
;									     ;
; This procedure should handle all the control calls that the LIMULATOR wants;
; to do additional processing on. 					     ;
;								             ;
; This routine will be called before the VXD does it's own processing and the;
; VXD would do a PUSHAD/POPAD accross the call.			             ;	   
;								 	     ;
; Return CARRY SET if the call has to be failed. Not all calls can be failed.;
; While you may fail calls like Sys_Critical_Init and Create_VM, you should  ;
; not fail calls like Device_Init which would leave the VXD in an inconsistent
; state.
;									     ;
; The code provided below is just a stub and returns without hooking any of  ;
; calls.							             ;
;----------------------------------------------------------------------------;

BeginProc Control_Call_Hook,PUBLIC

; EXAMPLE of how this call should be handled:
;
;	Control_Dispatch Sys_Critical_Init, Lim_Sys_Critical_Init
;	Control_Dispatch Device_Init, Lim_Device_Init
;			   .
;			   .
;			   .
;       (where Lim_Sys_Critical_Init, Lim_Device_Init are local procedures)
;
;

	clc				;don't fail the call.
	ret

EndProc Control_Call_Hook
;----------------------------------------------------------------------------;
; Get_Mapped_Page_Num:							     ;
;									     ;
; Entry:								     ;
;	  EAX - Page number in the range of pages that have UMBs.	     ;
;									     ;
; Exit:									     ;
;	  EAX - Entry time EAX.						     ;
;	  EDX - Page that is mapped into the page num in EAX (0 if no page   ;
;		is mapped in there.					     ;
;									     ;
; Uses:   EDX								     ;
;----------------------------------------------------------------------------;
BeginProc Get_Mapped_Page_Num						

	mov	edx,eax			;get the desired page slot #
	sub	edx,LimStartUMBPage	;bias it relative to the first page
	shl	edx,2			;each entry is a dword
	add	edx,LimPageMapPtr	;point to the slot for the page in EAX
	mov	edx,[edx]		;get the mapped page number
	ret

EndProc Get_Mapped_Page_Num
;----------------------------------------------------------------------------;
VxD_CODE_ENDS


	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\lhvxd\v86mmgr.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1991
;
;   Title:	V86MMGR.Inc - Public services for V86MMGR
;
;   Version:	2.00
;
;   Date:	29-Nov-88
;
;   Author:	ARR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   29-Nov-1988 ARR Original
;   26-Apr-1989 RAL New mapper services
;
;==============================================================================

Begin_Service_Table V86MMGR

V86MMGR_Service 	V86MMGR_Get_Version,		LOCAL
V86MMGR_Service 	V86MMGR_Allocate_V86_Pages,	LOCAL
V86MMGR_Service 	V86MMGR_Set_EMS_XMS_Limits,	LOCAL
V86MMGR_Service 	V86MMGR_Get_EMS_XMS_Limits,	LOCAL
;
;   Services used for API mapping.
;
V86MMGR_Service 	V86MMGR_Set_Mapping_Info, VxD_ICODE
V86MMGR_Service 	V86MMGR_Get_Mapping_Info
V86MMGR_Service 	V86MMGR_Xlat_API
V86MMGR_Service 	V86MMGR_Load_Client_Ptr
V86MMGR_Service 	V86MMGR_Allocate_Buffer
V86MMGR_Service 	V86MMGR_Free_Buffer
V86MMGR_Service 	V86MMGR_Get_Xlat_Buff_State
V86MMGR_Service 	V86MMGR_Set_Xlat_Buff_State
V86MMGR_Service 	V86MMGR_Get_VM_Flat_Sel
V86MMGR_Service 	V86MMGR_Map_Pages
V86MMGR_Service 	V86MMGR_Free_Page_Map_Region

End_Service_Table V86MMGR

;
; BITS of ECX flags for V86MMGR_Allocate_V86_Pages
;
AV86PLocked			EQU	00000000000000000000000000000001B
AV86PLockedBit			EQU	0	; VM memory is to be
						;   ALWAYS LOCKED regardless of
						;   pager type or whether VM
						;   is suspended.
;
; BITS of ECX flags for V86MMGR_Set_EMS_XMS_Limits
;
; NOTE: If neither Limit_DisableHMA or Limit_EnableHMA is set, the HMA
;	state is not altered.
;
EMS_XMS_Limit_DisableHMA	EQU	00000000000000000000000000000001B
EMS_XMS_Limit_DisableHMABit	EQU	0
EMS_XMS_Limit_EnableHMA 	EQU	00000000000000000000000000000010B
EMS_XMS_Limit_EnableHMABit	EQU	1
EMS_XMS_Limit_XMS_Is_Locked	EQU	00000000000000000000000000000100B
EMS_XMS_Limit_XMS_Is_LockedBit	EQU	2
EMS_XMS_Limit_EMS_Is_Locked	EQU	00000000000000000000000000001000B
EMS_XMS_Limit_EMS_Is_LockedBit	EQU	3



;
;   API mapper equates and macros
;

Xlat_Exec_Int	    EQU     000h
Xlat_Fixed_Len	    EQU     001h
Xlat_Var_Len	    EQU     002h
Xlat_Calc_Len	    EQU     003h
Xlat_ASCIIZ	    EQU     004h
Xlat_Jmp_To_Proc    EQU     005h
Xlat_Return_Ptr     EQU     006h
Xlat_Return_Seg     EQU     007h


Xlat_API_Exec_Int MACRO Int_Number
	db	Xlat_Exec_Int
	db	Int_Number
	ENDM

Xlat_API_Fixed_Len MACRO Ptr_Seg, Ptr_Off, Length
	db	Xlat_Fixed_Len
	dw	Length
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Var_Len MACRO Ptr_Seg, Ptr_Off, Len_Reg
	db	Xlat_Var_Len
	db	Client_&Len_Reg
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Calc_Len MACRO Ptr_Seg, Ptr_Off, Calc_Proc_Addr
	db	Xlat_Calc_Len
	dd	OFFSET32 Calc_Proc_Addr
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_ASCIIZ  MACRO Ptr_Seg, Ptr_Off
	db	Xlat_ASCIIZ
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Jmp_To_Proc MACRO Proc_Name
	db	Xlat_Jmp_To_Proc
	dd	OFFSET32 Proc_Name
	ENDM


Xlat_API_Return_Ptr MACRO Ptr_Seg, Ptr_Off
	db	Xlat_Return_Ptr
	dw	(Client_&Ptr_Seg*100h)+Client_&Ptr_Off
	ENDM

Xlat_API_Return_Seg MACRO Ptr_Seg
	db	Xlat_Return_Seg
	db	Client_&Ptr_Seg
	ENDM

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\lhvxd\opttest.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1990-1991
;
;   Title:	OPTTEST.INC - Macros to optimize test instructions
;
;   Version:	1.00
;
;   Date:	28-Jun-1990
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   28-Jun-1990 RAL
;
;==============================================================================


TestMem MACRO MemPtr, Mask
IFE Mask AND 0FFFFFF00h
	test	BYTE PTR [MemPtr], Mask
ELSE
IFE Mask AND 0FFFF00FFh
	test	BYTE PTR [MemPtr+1], (Mask SHR 8)
ELSE
IFE Mask AND 0FF00FFFFh
	test	BYTE PTR [MemPtr+2], (Mask SHR 16)
ELSE
IFE Mask AND 000FFFFFFh
	test	BYTE PTR [MemPtr+3], (Mask SHR 24)
ELSE
IFE Mask AND 0FFFF0000h
	test	WORD PTR [MemPtr], Mask
ELSE
IFE Mask AND 0FF0000FFh
	test	WORD PTR [MemPtr+1], (Mask SHR 8)
ELSE
IFE Mask AND 00000FFFFh
	test	WORD PTR [MemPtr+2], (Mask SHR 16)
ELSE
	test	DWORD PTR [MemPtr], Mask
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM





TestReg MACRO R, Mask

_@TR MACRO Ltr
IFE Mask AND 0FFFFFF00h
	test	Ltr&&l, Mask
ELSE
IFE Mask AND 0FFFF00FFh
	test	Ltr&&h, (Mask SHR 8)
ELSE
IFE Mask AND 0FFFF0000h
	test	Ltr&&x, Mask
ELSE
	test	e&&Ltr&&x, Mask
ENDIF
ENDIF
ENDIF
	ENDM


IFIDNI <R>, <EAX>
	_@TR a, Mask
ELSE
IFIDNI <R>, <EBX>
	_@TR b, Mask
ELSE
IFIDNI <R>, <ECX>
	_@TR c, Mask
ELSE
IFIDNI <R>, <EDX>
	_@TR d, Mask
ELSE
IFIDNI <R>, <ESI>
IFE Mask AND 0FFFF0000h
	test	si, Mask
ELSE
	test	esi, Mask
ENDIF
ELSE
IFIDNI <R>, <EDI>
IFE Mask AND 0FFFF0000h
	test	di, Mask
ELSE
	test	edi, Mask
ENDIF
ELSE
%OUT ERROR:  Bad param to TestReg macro
.ERR
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\emm386\lhvxd\vmm.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1991
;
;   Title:	VMM.INC - Include file for Virtual Machine Manager
;
;   Version:	1.00
;
;   Date:	05-May-1988
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   05-May-1988 RAL Original
;
;==============================================================================


; NON Windows/386 Virtual Device sources can include this file to get some
; useful equates by declaring the symbol "Not_VxD"  If this symbol is defined,
; then everything that has to do with the specifics of the 32 bit environment
; for virtual devices is removed.  Useful equates include:  device ID's, pushad
; structure, BeginDoc/EndDoc/BeginMsg/EndMsg equates, page table equates, etc.



False	EQU	0
True	EQU	NOT False

;
;   These null macros are recognized by a utility program that produces
;   documentation files.
;
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>


BeginDoc
;******************************************************************************
;
;			EQUATES FOR REQUIRED DEVICES
;
;   Device ID formulation note:
;
;	Device ID's are a combination of OEM # and device # in the form:
;
;		xOOOOOOOOOODDDDD
;
;	The high bit of the device ID is reserved for future use.  The next
;	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
;	are the device #.  This allows each OEM to create 32 unique devices.
;	If an OEM is creating a replacement for a standard device, then it
;	should re-use the standard ID listed below.  Microsoft reserves the
;	first 16 OEM #'s (0 thru 0Fh)
;
;==============================================================================

Undefined_Device_ID		EQU	00000h
VMM_Device_ID			EQU	00001h	; Used for dynalink table
Debug_Device_ID 		EQU	00002h
VPICD_Device_ID 		EQU	00003h
VDMAD_Device_ID 		EQU	00004h
VTD_Device_ID			EQU	00005h
V86MMGR_Device_ID		EQU	00006h
PageSwap_Device_ID		EQU	00007h
Parity_Device_ID		EQU	00008h
Reboot_Device_ID		EQU	00009h
VDD_Device_ID			EQU	0000Ah
VSD_Device_ID			EQU	0000Bh
VMD_Device_ID			EQU	0000Ch
VKD_Device_ID			EQU	0000Dh
VCD_Device_ID			EQU	0000Eh
VPD_Device_ID			EQU	0000Fh
VHD_Device_ID			EQU	00010h
VMCPD_Device_ID 		EQU	00011h
EBIOS_Device_ID 		EQU	00012h
BIOSXlat_Device_ID		EQU	00013h
VNETBIOS_Device_ID		EQU	00014h
DOSMGR_Device_ID		EQU	00015h
WINLOAD_Device_ID		EQU	00016h
SHELL_Device_ID 		EQU	00017h
VMPoll_Device_ID		EQU	00018h
VPROD_Device_ID 		EQU	00019h
DOSNET_Device_ID		EQU	0001Ah
VFD_Device_ID			EQU	0001Bh
VDD2_Device_ID			EQU	0001Ch	; Secondary display adapter
WINDEBUG_Device_ID		EQU	0001Dh
TSRLoad_Device_ID		EQU	0001Eh	; TSR instance utility ID

;
;   Initialization order equates.  Devices are initialized in order from
;   LOWEST to HIGHEST.	If 2 or more devices have the same initialization
;   order value, then they are initialized in order of occurance, so a
;   specific order is not guaranteed.  Holes have been left to allow maximum
;   flexibility in ordering devices.
;

VMM_Init_Order			EQU	000000000h
Debug_Init_Order		EQU	004000000h
VPROD_Init_Order		EQU	008000000h
VPICD_Init_Order		EQU	00C000000h
VTD_Init_Order			EQU	014000000h
PageSwap_Init_Order		EQU	01C000000h
Parity_Init_Order		EQU	020000000h
Reboot_Init_Order		EQU	024000000h
EBIOS_Init_Order		EQU	026000000h
VDD_Init_Order			EQU	028000000h
VSD_Init_Order			EQU	02C000000h
VCD_Init_Order			EQU	030000000h
VMD_Init_Order			EQU	034000000h
VKD_Init_Order			EQU	038000000h
VPD_Init_Order			EQU	03C000000h
VHD_Init_Order			EQU	040000000h
VFD_Init_Order			EQU	044000000h
VMCPD_Init_Order		EQU	048000000h
BIOSXlat_Init_Order		EQU	050000000h
VNETBIOS_Init_Order		EQU	054000000h
DOSMGR_Init_Order		EQU	058000000h
DOSNET_Init_Order		EQU	05C000000h
WINLOAD_Init_Order		EQU	060000000h
VMPoll_Init_Order		EQU	064000000h

Undefined_Init_Order		EQU	080000000h

WINDEBUG_Init_Order		EQU	081000000h
VDMAD_Init_Order		EQU	090000000h
V86MMGR_Init_Order		EQU	0A0000000h
SHELL_Init_Order		EQU	0B0000000h
EndDoc

;******************************************************************************
;
;   Macro to cause a delay in between I/O accesses to the same device.
;
;------------------------------------------------------------------------------

IO_Delay    macro
jmp $+2
ENDM

Pushad_Struc	STRUC
Pushad_EDI	dd	?		; Client's EDI
Pushad_ESI	dd	?		; Client's ESI
Pushad_EBP	dd	?		; Client's EBP
Pushad_ESP	dd	?		; ESP at pushall
Pushad_EBX	dd	?		; Client's EBX
Pushad_EDX	dd	?		; Client's EDX
Pushad_ECX	dd	?		; Client's ECX
Pushad_EAX	dd	?		; Client's EAX
Pushad_Struc	ENDS



IFNDEF Not_VxD

??_CUR_CODE_SEG = 0


??_CODE  = 1
??_ICODE = 2
??_LCODE = 3
??_RCODE = 4

?_CODE	equ <(??_CUR_CODE_SEG MOD 8) - ??_CODE>
?_ICODE equ <(??_CUR_CODE_SEG MOD 8) - ??_ICODE>
?_LCODE equ <(??_CUR_CODE_SEG MOD 8) - ??_LCODE>
?_RCODE equ <(??_CUR_CODE_SEG MOD 8) - ??_RCODE>

;
;  SEGMENT definitions and order
;

;*	32 Bit locked code
_LTEXT		SEGMENT DWORD USE32 PUBLIC 'CODE'
_LTEXT		ENDS

;*	32 Bit code
_TEXT		SEGMENT DWORD USE32 PUBLIC 'PCODE'
_TEXT		ENDS

;*	32 Bit initialization code
_ITEXT		SEGMENT DWORD USE32 PUBLIC 'ICODE'
_ITEXT		ENDS

;*	Contains 32 Bit locked data
_LDATA		SEGMENT DWORD PUBLIC 'CODE'
_LDATA		ENDS

;*	Contains 32 Bit data
_DATA		SEGMENT DWORD PUBLIC 'PCODE'
_DATA		ENDS

;*	Contains 32 Bit initialization data
_IDATA		SEGMENT DWORD PUBLIC 'ICODE'
_IDATA		ENDS

;*	Real Mode initialization code/data for devices
_RCODE		SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE		ENDS


_LGROUP GROUP _LTEXT, _LDATA
_PGROUP GROUP _TEXT, _DATA
_IGROUP GROUP _ITEXT, _IDATA

	ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT


OFFSET32 EQU <OFFSET FLAT:>


BeginDoc
;==============================================================================
; The following macros are used in defining the routines
;   in a VxD which are going to be registered with VMM as callable entry
;   points. Once registered, the entry points can be called by any other
;   devices via the "VxDCall" macro, defined below. In the comments below,
;   replace "VxD" with the appropriate device name.
;
;*******
;   In the VxD.INC file, put the following lines, replacing <function_name>
;	with an appropriate name describing the function of the routine.
;
;	Begin_Service_Table VxD[,<segname>]
;	VxD_Service <function_name>[,<local segname>]
;	VxD_Service <function_name>[,<local segname>]
;		. . .
;	VxD_Service <function_name>[,<local segname>]
;	End_Service_Table   VxD[,<segname>]
;
;   Note that <segname> is an optional argument and, if specified, the
;	table is put in the segment defined by the macro "yyy_Data_Seg",
;	where yyy=segname. Otherwise the segment is defined by the
;	"VxD_Data_Seg" macro, defined below.
;   Note that <local segname> is an optional argument and, if specified,
;	the procedure's segment is defined by the macro "zzz_Code_Seg",
;	where zzz=segname. Otherwise the segment is defined by the
;	"VxD_Code_Seg" macro, defined below.
;
;*******
; One VxD module should have the following in order to define the entry points:
;Create_VxD_Service_Table = 1			; Only in module where table is
;	INCLUDE     VxD.INC			; Include the table definition
;
;*******
; All modules that want to call the services defined in the table should include
;   VxD.INC, but not define the label "Create_VxD_Service_Table". This
;   will define the service names to be used with the VxDCall macro.
;
EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment
IFB <Def_Segment>
	BST2 Device_Name, VxD
ELSE
	BST2 Device_Name, Def_Segment
ENDIF
	ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table
Def_Segment&_LOCKED_DATA_SEG
Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg
    PUBLIC $&&Procedure
    IF1
    $&&Procedure LABEL DWORD
    ENDIF
    IFDIFI <Local_Seg>, <LOCAL>
	IFNB <Local_Seg>
Local_Seg&&_SEG
	ELSE
Def_Segment&_CODE_SEG
	ENDIF
	EXTRN	@&&Procedure:NEAR
	IFNB <Local_Seg>
Local_Seg&&_ENDS
	ELSE
Def_Segment&_CODE_ENDS
	ENDIF
    ENDIF
	dd	OFFSET32 @&&Procedure
	Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
	Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
	ENDM

ELSE

Device_Name&_Service MACRO Procedure
	Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
	Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
	ENDM

ENDIF

	ENDM

;------------------------------------------------------------------------------

End_Service_Table MACRO Device_Name, Def_Segment

	PURGE	Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table
IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF
ENDIF

	ENDM


;******************************************************************************
;
;   Dword_Align -- Aligns code to dword boundry by inserting nops
;
;------------------------------------------------------------------------------

Dword_Align MACRO Seg_Name
	LOCAL segn
IFNB <Seg_Name>
	segn equ Seg_Name
ELSE
IFE ?_CODE
	segn equ <_TEXT>
ELSE
IFE ?_ICODE
	segn equ <_ITEXT>
ELSE
IFE ?_LCODE
	segn equ <_LTEXT>
ELSE
.err Dword_Align not supported
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
	    ENDM


BeginDoc
;******************************************************************************
;
;   Fatal_Error
;
;   DESCRIPTION:
;	This macro is used to crash Windows/386 when an unrecoverable error
;	is detected.  If Msg_Ptr is ommitted then no error message will be
;	displayed, otherwise Msg_Ptr is the address
;	when the
;
;   PARAMETERS:
;	Msg_Ptr (OPTIONAL) - Points to an ASCIIZ string to display.
;
;   EXIT:
;	To DOS (hopefully).  This macro never returns.
;
;==============================================================================
EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
	pushad
IFB <Msg_Ptr>
	xor	esi, esi
ELSE
	mov	esi, Msg_Ptr
IFB <Exit_Flags>
	xor	eax, eax
ELSE
	mov	eax, Exit_Flags
ENDIF
ENDIF
	VMMcall Fatal_Error_Handler
	ENDM

EF_Hang_On_Exit     EQU     1h


;******************************************************************************
;==============================================================================
;------------------------------------------------------------------------------

BeginDoc
;******************************************************************************
;   The following are control block offsets of items that can be of interest
;	to VxDs.
;*******
; VM status indicates globally interesting VM states
CB_VM_Status		EQU	DWORD PTR 00h

VMStat_Exclusive	EQU	000000000000000000001b	; VM is exclusive mode
VMStat_Exclusive_Bit	EQU	0
VMStat_Background	EQU	000000000000000000010b	; VM runs in background
VMStat_Background_Bit	EQU	1
VMStat_Creating 	EQU	000000000000000000100b	; In process of creating
VMStat_Creating_Bit	EQU	2
VMStat_Suspended	EQU	000000000000000001000b	; VM not scheduled
VMStat_Suspended_Bit	EQU	3
VMStat_Not_Executeable	EQU	000000000000000010000b	; VM partially destroyed
VMStat_Not_Executeable_Bit  EQU 4
VMStat_PM_Exec		EQU	000000000000000100000b	; Currently in PM app
VMStat_PM_Exec_Bit	EQU	5
VMStat_PM_App		EQU	000000000000001000000b	; PM app present in VM
VMStat_PM_App_Bit	EQU	6
VMStat_PM_Use32 	EQU	000000000000010000000b	; PM app is 32-bit
VMStat_PM_Use32_Bit	EQU	7
VMStat_VxD_Exec 	EQU	000000000000100000000b	; Call from VxD
VMStat_VxD_Exec_Bit	EQU	8
VMStat_High_Pri_Back	EQU	000000000001000000000b	; High pri background
VMStat_High_Pri_Back_Bit    EQU 9
VMStat_Blocked		EQU	000000000010000000000b	; Blocked on semaphore
VMStat_Blocked_Bit	EQU	0Ah
VMStat_Awakening	EQU	000000000100000000000b	; Woke up after blocked
VMStat_Awakening_Bit	EQU	0Bh
VMStat_PageableV86	EQU	000000001000000000000b	; part of V86 is pageable (PM app)
VMStat_PageableV86Bit	EQU	0Ch
VMStat_V86IntsLocked	EQU	000000010000000000000b	; Rest of V86 is locked
VMStat_V86IntsLockedBit EQU	0Dh			;  regardless of pager type
VMStat_TS_Sched 	EQU	000000100000000000000b	; Scheduled by time-slicer
VMStat_TS_Sched_Bit	EQU	0Eh
VMStat_Idle		EQU	000001000000000000000b	; VM has released time
VMStat_Idle_Bit 	EQU	0Fh			; slice

VMStat_Use32_Mask	EQU	VMStat_PM_Use32 OR VMStat_VxD_Exec


;*******
; Add this value to a V86 linear address to get address of VM's memory in
;	the VMM linear address space
CB_High_Linear		EQU	DWORD PTR 04h

;*******
CB_Client_Pointer	EQU	DWORD PTR 08h

CB_VMID 		EQU	DWORD PTR 0Ch

;
;   Equates for protected mode application control blocks
;
PMCB_Flags		EQU	DWORD PTR 00h
PMCB_Parent		EQU	DWORD PTR 04h
EndDoc

;******************************************************************************
;			    V M M   S E R V I C E S
;******************************************************************************

Begin_Service_Table VMM, VMM

VMM_Service	Get_VMM_Version, LOCAL		; MUST REMAIN SERVICE 0!

VMM_Service	Get_Cur_VM_Handle
VMM_Service	Test_Cur_VM_Handle
VMM_Service	Get_Sys_VM_Handle
VMM_Service	Test_Sys_VM_Handle
VMM_Service	Validate_VM_Handle

VMM_Service	Get_VMM_Reenter_Count, LOCAL
VMM_Service	Begin_Reentrant_Execution, LOCAL
VMM_Service	End_Reentrant_Execution, LOCAL

VMM_Service	Install_V86_Break_Point
VMM_Service	Remove_V86_Break_Point
VMM_Service	Allocate_V86_Call_Back
VMM_Service	Allocate_PM_Call_Back

VMM_Service	Call_When_VM_Returns


VMM_Service	Schedule_Global_Event
VMM_Service	Schedule_VM_Event
VMM_Service	Call_Global_Event
VMM_Service	Call_VM_Event
VMM_Service	Cancel_Global_Event
VMM_Service	Cancel_VM_Event
VMM_Service	Call_Priority_VM_Event
VMM_Service	Cancel_Priority_VM_Event

VMM_Service	Get_NMI_Handler_Addr, LOCAL
VMM_Service	Set_NMI_Handler_Addr, LOCAL
VMM_Service	Hook_NMI_Event

VMM_Service	Call_When_VM_Ints_Enabled
VMM_Service	Enable_VM_Ints
VMM_Service	Disable_VM_Ints

VMM_Service	Map_Flat
VMM_Service	Map_Lin_To_VM_Addr

;
;   Scheduler services
;
VMM_Service	Adjust_Exec_Priority
VMM_Service	Begin_Critical_Section
VMM_Service	End_Critical_Section
VMM_Service	End_Crit_And_Suspend
VMM_Service	Claim_Critical_Section
VMM_Service	Release_Critical_Section
VMM_Service	Call_When_Not_Critical
VMM_Service	Create_Semaphore
VMM_Service	Destroy_Semaphore
VMM_Service	Wait_Semaphore
VMM_Service	Signal_Semaphore
VMM_Service	Get_Crit_Section_Status
VMM_Service	Call_When_Task_Switched
VMM_Service	Suspend_VM
VMM_Service	Resume_VM
VMM_Service	No_Fail_Resume_VM
VMM_Service	Nuke_VM
VMM_Service	Crash_Cur_VM

VMM_Service	Get_Execution_Focus
VMM_Service	Set_Execution_Focus
VMM_Service	Get_Time_Slice_Priority
VMM_Service	Set_Time_Slice_Priority
VMM_Service	Get_Time_Slice_Granularity
VMM_Service	Set_Time_Slice_Granularity
VMM_Service	Get_Time_Slice_Info
VMM_Service	Adjust_Execution_Time
VMM_Service	Release_Time_Slice
VMM_Service	Wake_Up_VM
VMM_Service	Call_When_Idle

VMM_Service	Get_Next_VM_Handle

;
;   Time-out and system timer services
;
VMM_Service	Set_Global_Time_Out
VMM_Service	Set_VM_Time_Out
VMM_Service	Cancel_Time_Out
VMM_Service	Get_System_Time
VMM_Service	Get_VM_Exec_Time

VMM_Service	Hook_V86_Int_Chain
VMM_Service	Get_V86_Int_Vector
VMM_Service	Set_V86_Int_Vector
VMM_Service	Get_PM_Int_Vector
VMM_Service	Set_PM_Int_Vector

VMM_Service	Simulate_Int
VMM_Service	Simulate_Iret
VMM_Service	Simulate_Far_Call
VMM_Service	Simulate_Far_Jmp
VMM_Service	Simulate_Far_Ret
VMM_Service	Simulate_Far_Ret_N
VMM_Service	Build_Int_Stack_Frame

VMM_Service	Simulate_Push
VMM_Service	Simulate_Pop

;
; Heap Manager
;
VMM_Service	_HeapAllocate
VMM_Service	_HeapReAllocate
VMM_Service	_HeapFree
VMM_Service	_HeapGetSize

; ---------------------------------------------------
;
;	 Flags for heap allocator calls
;
; ---------------------------------------------------


HeapZeroInit	equ	00000000000000000000000000000001B
HeapZeroReInit	equ	00000000000000000000000000000010B
HeapNoCopy	equ	00000000000000000000000000000100B

; NOTE: HIGH 8 BITS (bits 24-31) are reserved


;
; Page Manager
;
VMM_Service	_PageAllocate
VMM_Service	_PageReAllocate
VMM_Service	_PageFree
VMM_Service	_PageLock
VMM_Service	_PageUnLock
VMM_Service	_PageGetSizeAddr
VMM_Service	_PageGetAllocInfo
VMM_Service	_GetFreePageCount
VMM_Service	_GetSysPageCount
VMM_Service	_GetVMPgCount
VMM_Service	_MapIntoV86
VMM_Service	_PhysIntoV86
VMM_Service	_TestGlobalV86Mem
VMM_Service	_ModifyPageBits
VMM_Service	_CopyPageTable
VMM_Service	_LinMapIntoV86
VMM_Service	_LinPageLock
VMM_Service	_LinPageUnLock
VMM_Service	_SetResetV86Pageable
VMM_Service	_GetV86PageableArray
VMM_Service	_PageCheckLinRange
VMM_Service	_PageOutDirtyPages
VMM_Service	_PageDiscardPages

; ---------------------------------------------------
;
;	 Flags for other page allocator calls
;
; ---------------------------------------------------
PageZeroInit		equ	00000000000000000000000000000001B
PageUseAlign		equ	00000000000000000000000000000010B
PageContig		equ	00000000000000000000000000000100B
PageFixed		equ	00000000000000000000000000001000B
PageDEBUGNulFault	equ	00000000000000000000000000010000B
PageZeroReInit		equ	00000000000000000000000000100000B
PageNoCopy		equ	00000000000000000000000001000000B
PageLocked		equ	00000000000000000000000010000000B
PageLockedIfDP		equ	00000000000000000000000100000000B
PageSetV86Pageable	equ	00000000000000000000001000000000B
PageClearV86Pageable	equ	00000000000000000000010000000000B
PageSetV86IntsLocked	equ	00000000000000000000100000000000B
PageClearV86IntsLocked	equ	00000000000000000001000000000000B
PageMarkPageOut 	equ	00000000000000000010000000000000B
PagePDPSetBase		equ	00000000000000000100000000000000B
PagePDPClearBase	equ	00000000000000001000000000000000B
PageDiscard		equ	00000000000000010000000000000000B
PagePDPQueryDirty	equ	00000000000000100000000000000000B

; NOTE: HIGH 8 BITS (bits 24-31) are reserved

;
; Informational services
;
VMM_Service	_GetNulPageHandle
VMM_Service	_GetFirstV86Page
VMM_Service	_MapPhysToLinear
VMM_Service	_GetAppFlatDSAlias
VMM_Service	_SelectorMapFlat
VMM_Service	_GetDemandPageInfo
;
; Data structure for _GetDemandPageInfo
;
DemandInfoStruc struc
DILin_Total_Count     dd	      ?       ; # pages in linear address space
DIPhys_Count	      dd	      ?       ; Count of phys pages
DIFree_Count	      dd	      ?       ; Count of free phys pages
DIUnlock_Count	      dd	      ?       ; Count of unlocked Phys Pages
DILinear_Base_Addr    dd	      ?       ; Base of pageable address space
DILin_Total_Free      dd	      ?       ; Total Count of free linear pages
DIReserved	      dd      10 dup (?)      ; Resvd for expansion
DemandInfoStruc ends

VMM_Service	_GetSetPageOutCount
;
; Flags bits for _GetSetPageOutCount
;
GSPOC_F_Get	equ	00000000000000000000000000000001B

;
; Device VM page manager
;
VMM_Service	Hook_V86_Page
VMM_Service	_Assign_Device_V86_Pages
VMM_Service	_DeAssign_Device_V86_Pages
VMM_Service	_Get_Device_V86_Pages_Array
VMM_Service	MMGR_SetNULPageAddr

;
; GDT/LDT management
;
VMM_Service	_Allocate_GDT_Selector
VMM_Service	_Free_GDT_Selector
VMM_Service	_Allocate_LDT_Selector
VMM_Service	_Free_LDT_Selector
VMM_Service	_BuildDescriptorDWORDs
;
; Flag equates for _BuildDescriptorDWORDs
;
BDDExplicitDPL	EQU	00000000000000000000000000000001B
;
; Flag equates for _Allocate_LDT_Selector
;
ALDTSpecSel	EQU	00000000000000000000000000000001B

VMM_Service	_GetDescriptor
VMM_Service	_SetDescriptor


VMM_Service	_MMGR_Toggle_HMA
;
; Flag equates for _MMGR_Toggle_HMA
;
MMGRHMAPhysical EQU	00000000000000000000000000000001B
MMGRHMAEnable	EQU	00000000000000000000000000000010B
MMGRHMADisable	EQU	00000000000000000000000000000100B
MMGRHMAQuery	EQU	00000000000000000000000000001000B


VMM_Service	Get_Fault_Hook_Addrs, LOCAL
VMM_Service	Hook_V86_Fault, LOCAL
VMM_Service	Hook_PM_Fault, LOCAL
VMM_Service	Hook_VMM_Fault, LOCAL

VMM_Service	Begin_Nest_V86_Exec
VMM_Service	Begin_Nest_Exec
VMM_Service	Exec_Int
VMM_Service	Resume_Exec
VMM_Service	End_Nest_Exec

VMM_Service	Allocate_PM_App_CB_Area, VMM_ICODE
VMM_Service	Get_Cur_PM_App_CB

VMM_Service	Set_V86_Exec_Mode
VMM_Service	Set_PM_Exec_Mode

VMM_Service	Begin_Use_Locked_PM_Stack
VMM_Service	End_Use_Locked_PM_Stack

VMM_Service	Save_Client_State
VMM_Service	Restore_Client_State

VMM_Service	Exec_VxD_Int

VMM_Service	Hook_Device_Service, LOCAL

VMM_Service	Hook_Device_V86_API
VMM_Service	Hook_Device_PM_API

VMM_Service	System_Control

;
;   I/O and software interrupt hooks
;
VMM_Service	Simulate_IO
VMM_Service	Install_Mult_IO_Handlers
VMM_Service	Install_IO_Handler
VMM_Service	Enable_Global_Trapping
VMM_Service	Enable_Local_Trapping
VMM_Service	Disable_Global_Trapping
VMM_Service	Disable_Local_Trapping


;
;   Linked List Abstract Data Type Services
;
VMM_Service	List_Create
VMM_Service	List_Destroy
VMM_Service	List_Allocate
VMM_Service	List_Attach
VMM_Service	List_Attach_Tail
VMM_Service	List_Insert
VMM_Service	List_Remove
VMM_Service	List_Deallocate
VMM_Service	List_Get_First
VMM_Service	List_Get_Next
VMM_Service	List_Remove_First

;
;   Flags used by List_Create
;
LF_Async		EQU	00000001b
LF_Async_Bit		EQU	0
LF_Use_Heap		EQU	00000010b
LF_Use_Heap_Bit 	EQU	1
LF_Alloc_Error		EQU	00000100b
LF_Alloc_Error_Bit	EQU	2


;==============================================================================
;	I N I T I A L I Z A T I O N   P R O C E D U R E S
;------------------------------------------------------------------------------


;
; Instance data manager
;
VMM_Service	_AddInstanceItem
;
; Data structure for _AddInstanceItem
;
InstDataStruc struc
InstLinkF	      dd	      0       ; RESERVED SET TO 0
InstLinkB	      dd	      0       ; RESERVED SET TO 0
InstLinAddr	      dd	      ?       ; Linear address of start of block
InstSize	      dd	      ?       ; Size of block in bytes
InstType	      dd	      ?       ; Type of block
InstDataStruc ends
;
; Values for InstType
;
INDOS_Field	equ	100h	; Bit indicating INDOS switch requirements
ALWAYS_Field	equ	200h	; Bit indicating ALWAYS switch requirements

;
; System structure data manager
;
VMM_Service	_Allocate_Device_CB_Area, VMM_ICODE
VMM_Service	_Allocate_Global_V86_Data_Area, VMM_ICODE
VMM_Service	_Allocate_Temp_V86_Data_Area, VMM_ICODE
VMM_Service	_Free_Temp_V86_Data_Area, VMM_ICODE

;
; Flag bits for _Allocate_Global_VM_Data_Area
;
GVDAWordAlign		EQU		00000000000000000000000000000001B
GVDADWordAlign		EQU		00000000000000000000000000000010B
GVDAParaAlign		EQU		00000000000000000000000000000100B
GVDAPageAlign		EQU		00000000000000000000000000001000B
GVDAInstance		EQU		00000000000000000000000100000000B
GVDAZeroInit		EQU		00000000000000000000001000000000B
GVDAReclaim		EQU		00000000000000000000010000000000B

;
; Initialization information calls (win.ini and environment parameters)
;
VMM_Service	Get_Profile_Decimal_Int, VMM_ICODE
VMM_Service	Convert_Decimal_String, VMM_ICODE
VMM_Service	Get_Profile_Fixed_Point, VMM_ICODE
VMM_Service	Convert_Fixed_Point_String, VMM_ICODE
VMM_Service	Get_Profile_Hex_Int, VMM_ICODE
VMM_Service	Convert_Hex_String, VMM_ICODE
VMM_Service	Get_Profile_Boolean, VMM_ICODE
VMM_Service	Convert_Boolean_String, VMM_ICODE
VMM_Service	Get_Profile_String, VMM_ICODE
VMM_Service	Get_Next_Profile_String, VMM_ICODE
VMM_Service	Get_Environment_String, VMM_ICODE
VMM_Service	Get_Exec_Path, VMM_ICODE
VMM_Service	Get_Config_Directory, VMM_ICODE
VMM_Service	OpenFile, VMM_ICODE
VMM_Service	Get_PSP_Segment, VMM_ICODE
VMM_Service	GetDOSVectors, VMM_ICODE
VMM_Service	Get_Machine_Info

GMIF_80486	EQU	00010000h
GMIF_80486_Bit	EQU	10h
GMIF_PCXT	EQU	00020000h
GMIF_PCXT_Bit	EQU	11h
GMIF_MCA	EQU	00040000h
GMIF_MCA_Bit	EQU	12h
GMIF_EISA	EQU	00080000h
GMIF_EISA_Bit	EQU	13h


;
; Following service is not restricted to initialization
;
VMM_Service	GetSet_HMA_Info
VMM_Service	Set_System_Exit_Code

VMM_Service	Fatal_Error_Handler
VMM_Service	Fatal_Memory_Error

;
;   Called by VTD only
;
VMM_Service	Update_System_Clock

;==============================================================================
;		    D E B U G G I N G	E X T E R N S
;==============================================================================

VMM_Service	Test_Debug_Installed		; Valid call in retail also

VMM_Service	Out_Debug_String		; Valid in DEBLEVEL=1
VMM_Service	Out_Debug_Chr
VMM_Service	In_Debug_Chr
VMM_Service	Debug_Convert_Hex_Binary
VMM_Service	Debug_Convert_Hex_Decimal

VMM_Service	Debug_Test_Valid_Handle
VMM_Service	Validate_Client_Ptr
VMM_Service	Test_Reenter
VMM_Service	Queue_Debug_String
VMM_Service	Log_Proc_Call
VMM_Service	Debug_Test_Cur_VM

.errnz Debug_Test_Cur_VM - 100CCh   ; VMM service table changed above this service

VMM_Service	Get_PM_Int_Type
VMM_Service	Set_PM_Int_Type

VMM_Service	Get_Last_Updated_System_Time
VMM_Service	Get_Last_Updated_VM_Exec_Time

End_Service_Table VMM, VMM



;******************************************************************************

IFDEF DEBUG
DebFar	EQU	NEAR PTR
ELSE
DebFar	EQU	SHORT
ENDIF

BeginDoc

;******************************************************************************
;
;		     EQUATES FOR SYSTEM_CONTROL CALLS
;
;==============================================================================

;
; Sys_Critical_Init is a device init call. Devices that have a critical
;   function that needs initializing before interrupts are enabled should
;   do it at Sys_Critical_Init. Devices which REQUIRE a certain range of
;   V86 pages to operate (such as the VDD video memory) should claim them
;   at Sys_Critical_Init. SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT
;   ALLOWED. Returning carry aborts device load only.
;
Sys_Critical_Init	EQU	0000h		; Devices required for virt mode
;
; Device init is where most devices do the bulk of their initialization.
;   SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
;   aborts device load only.
;
Device_Init		EQU	0001h		; All other devices init
;
; Init_Complete is the final phase of device init called just before the
;   WIN386 INIT pages are released and the Instance snapshot is taken.
;   Devices which wish to search for a region of V86 pages >= A0h to use
;   should do it at Init_Complete.
;   SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
;   aborts device load only.
;
Init_Complete		EQU	0002h		; All devices have initialized

;----------------- INITIALIZATION CODE AND DATA DISCARDED ---------------------

;
; Same as VM_Init, except for SYS VM.
;
Sys_VM_Init		EQU	0003h		; Execute the system VM (Win86)
;
; Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
;   exit this call is not made). SYS VM Simulate_Int, Exec_Int activity is
;   allowed.
;
Sys_VM_Terminate	EQU	0004h		; System VM terminted (exiting)

;------------------------------------------------------------------------------

;
; System_Exit call is made when WIN386 is exiting either normally or via
;   a crash. INTERRUPS ARE ENABLED. Instance snapshot has been restored.
;   SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
;
System_Exit		EQU	0005h		; Devices prepare to exit
;
; System_Exit call is made when WIN386 is exiting either normally or via
;   a crash. INTERRUPS ARE DISABLED. SYS VM Simulate_Int, Exec_Int ACTIVITY
;   IS NOT ALLOWED.
;
Sys_Critical_Exit	EQU	0006h		; System critical devices reset

;
; Create_VM creates a new VM. EBX = VM handle of new VM. Returning Carry will
;   fail the Create_VM.
;
Create_VM		EQU	0007h
;
; Second phase of Create_VM. EBX = VM handle of new VM. Returning Carry will
;   cause the VM to go Not_Executeable, then be destroyed. VM Simulate_Int,
;   Exec_Int activity is NOT allowed.
;
VM_Critical_Init	EQU	0008h
;
; Third phase of Create_VM. EBX = VM handle of new VM. Returning Carry will
;   cause the VM to go Not_Executeable, then be destroyed. VM Simulate_Int,
;   Exec_Int activity is allowed.
;
VM_Init 		EQU	0009h

;
; NORMAL (First phase) of Destroy_VM. EBX = VM Hanlde. This occurs on normal
;   termination of the VM. Call cannot be failed. VM Simulate_Int, Exec_Int
;   activity is allowed.
;
VM_Terminate		EQU	000Ah		; Still in VM -- About to die
;
; Second phase of Destroy_VM. EBX = VM Handle, EDX = Flags (see below). Note
;   that in the case of destroying a running VM, this is the first call made
;   (VM_Terminate call does not occur). Call cannot be failed. VM Simulate_Int,
;   Exec_Int activity is NOT allowed.
;
VM_Not_Executeable	EQU	000Bh		; Most devices die (except VDD)
;
; Final phase of Destroy_VM. EBX = VM Handle. Note that considerable time
;   can elaps between the VM_Not_Executeable call and this call. Call cannot
;   be failed. VM Simulate_Int, Exec_Int activity is NOT allowed.
;
Destroy_VM		EQU	000Ch		; VM's control block about to go

;
;   Flags for VM_Not_Executeable control call (passed in EDX)
;
VNE_Crashed		EQU	0000000000000000000000001b
VNE_Crashed_Bit 	EQU	0		; VM was crashed
VNE_Nuked		EQU	0000000000000000000000010b
VNE_Nuked_Bit		EQU	1		; VM was destroyed while active
VNE_CreateFail		EQU	0000000000000000000000100b
VNE_CreateFail_Bit	EQU	2		; Some device failed Create_VM
VNE_CrInitFail		EQU	0000000000000000000001000b
VNE_CrInitFail_Bit	EQU	3		; Some device failed VM_Critical_Init
VNE_InitFail		EQU	0000000000000000000010000b
VNE_InitFail_Bit	EQU	4		; Some device failed VM_Init

;------------------------------------------------------------------------------

;
; EBX = VM Handle. Call cannot be failed.
;
VM_Suspend		EQU	000Dh		; VM not runnable until resume
;
; EBX = VM Handle. Returning carry fails and backs out the resume.
;
VM_Resume		EQU	000Eh		; VM is leaving suspended state

;------------------------------------------------------------------------------

;
; EBX = VM Handle to set device focus to. EDX = Device ID if device specific
;   setfocus. == 0 if device critical setfocus (all devices). THIS CALL CANNOT
;   BE FAILED.
;
;   NOTE: In case where EDX == 0, ESI is a FLAG word that indicates special
;	  functions. Currently Bit 0 being set indicates that this Device
;	  critical set focus is also "VM critical". It means that we do not
;	  want some other VM to take the focus from this app now. This is
;	  primarily used when doing a device critical set focus to Windows
;	  (the SYS VM) it is interpreted by the SHELL to mean "if an old app
;	  currently has the Windows activation, set the activation to the
;	  Windows Shell, not back to the old app". ALSO in the case where
;	  Bit 0 is set, EDI = The VM handle of the VM that is "having trouble".
;	  Set this to 0 if there is no specific VM associated with the problem.
;
Set_Device_Focus	EQU	000Fh

;------------------------------------------------------------------------------

;
; EBX = VM Handle going into message mode. THIS CALL CANNOT BE FAILED.
;
Begin_Message_Mode	EQU	0010h
;
; EBX = VM Handle leaving message mode. THIS CALL CANNOT BE FAILED.
;
End_Message_Mode	EQU	0011h

;------------------------- SPECIAL CONTROL CALLS ------------------------------

;
; Request for reboot. Call cannot be failed.
;
Reboot_Processor	EQU	0012h		; Request a machine reboot
;
; Query_Destroy is an information call made by the SHELL device before an
;   attempt is made to initiate a destroy VM sequence on a running VM which
;   has not exited normally. EBX = VM Handle. Returning carry indicates that
;   a device "has a problem" with allowing this. THE DESTROY SEQUENCE CANNOT
;   BE ABORTED HOWEVER, this decision is up to the user. All this does is
;   indicate that there is a "problem" with allowing the destroy. The device
;   which returns carry should call the SHELL_Message service to post an
;   informational dialog about the reason for the problem.
;
Query_Destroy		EQU	0013h		; OK to destroy running VM?

;------------------------- DEBUGGING CONTROL CALL -----------------------------

;
; Special call for device specific DEBUG information display and activity.
;
Debug_Query		EQU	0014h

;---------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION ----------------

;
;   About to run a protected mode application.
;   EBX = Current VM handle.
;   EDX = Flags
;   EDI -> Application Control Block
;   Returning with carry set fails the call.
;
Begin_PM_App		EQU	0015h

;
;   Flags for Begin_PM_App (passed in EDX)
;
BPA_32_Bit		EQU	00000001b
BPA_32_Bit_Flag 	EQU	1

;
;   Protected mode application is terminating.
;   EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
;   EDI -> Application Control Block
;
End_PM_App		EQU	0016h

EndDoc

BeginDoc
;******************************************************************************
; BeginProc is a macro for defining entry points to routines in VMM and in the
;   VxDs. It correctly defines the procedure name for VxD services(it prepends
;   a "@" to the procedure name), DWORD aligns the procedure, takes care of
;   public declaration and does some calling verification for debug versions
;   of the software. EndProc is a macro which defines the end of the procedure.
;
; Valid parameters to the BeginProc macro are:
;	PUBLIC				; Routine used outside this module
;	HIGH_FREQ			; DWORD align procedure
;	SERVICE 			; Routine is called via VxDCall
;	ASYNC_SERVICE			; Same as "SERVICE" plus routine can
;					;	be called under interrupt.
; After the routine header in which the routine entry conditions, exit
;   conditions, side affects and functionality are specified, the BeginProc
;   macro should be used to define the routine's entry point. It has up to
;   four parameters as specified below. For example:
;
;BeginProc  <Function_Name>,PUBLIC, HIGH_FREQ, ASYNC_SERVICE
;
;	<code>
;
;EndProc    <Function_Name>
;==============================================================================
EndDoc

BeginProc MACRO Name, P1, P2, P3, P4
	LOCAL	Profile_Data, Skip_Data

IF ?_RCODE

Process_Param MACRO P
IFNB <P>
IFIDNI <P>, <HIGH_FREQ>
Dword_Align
ELSE
IFIDNI <P>, <SERVICE>
??_SERVICE = 1
ELSE
IFIDNI <P>, <ASYNC_SERVICE>
??_ASYNC_SERVICE = 1
IF ?_LCODE
%OUT ERROR:  ASYNC_SERVICE's must be in LOCKED code
;;.err
ENDIF
ELSE
IFIDNI <P>, <NO_LOG>
??_NO_LOG = 1
ELSE
IFDIFI <P>, <PUBLIC>
%OUT ERROR:  Bad para "&P" to BeginProc
.ERR
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
	ENDM


??_SERVICE = 0
??_ASYNC_SERVICE = 0
??_NO_LOG = 0

Process_Param P1
Process_Param P2
Process_Param P3
Process_Param P4


IFE ??_SERVICE + ??_ASYNC_SERVICE

PUBLIC Name
Name PROC NEAR
IFDEF DEBUG
IFE ??_NO_LOG
IFNDEF VMMSYS
	VMMcall Log_Proc_Call
ENDIF
ENDIF
ENDIF

ELSE

IFDEF DEBUG
	jmp	SHORT Skip_Data
Profile_Data LABEL DWORD
	dd	0
Skip_Data:
ENDIF

PUBLIC @&Name
@&Name PROC NEAR

IFDEF DEBUG
IFE ??_NO_LOG
;;;;IFNDEF VMMSYS
	VMMcall Log_Proc_Call
;;;;ENDIF
ENDIF
	pushfd
	inc	[Profile_Data]
IFE ??_ASYNC_SERVICE
	VMMcall Test_Reenter
ENDIF
	popfd
ENDIF
ENDIF

ELSE
IFIDNI <P1>, <PUBLIC>
PUBLIC Name
ENDIF
Name PROC NEAR
ENDIF


	ENDM



EndProc MACRO Name
IFDEF @&Name
@&Name ENDP
ELSE
IFDEF Name
Name ENDP
ELSE
.ERR
%OUT EndProc for &Name does not match BeginProc
ENDIF
ENDIF
	ENDM


;******************************************************************************
;	       S C H E D U L E R   B O O S T   V A L U E S
;==============================================================================

Reserved_Low_Boost	EQU	00000000000000000000000000000001b
Cur_Run_VM_Boost	EQU	00000000000000000000000000000100b
Low_Pri_Device_Boost	EQU	00000000000000000000000000010000b
High_Pri_Device_Boost	EQU	00000000000000000001000000000000b
Critical_Section_Boost	EQU	00000000000100000000000000000000b
Time_Critical_Boost	EQU	00000000010000000000000000000000b
Reserved_High_Boost	EQU	01000000000000000000000000000000b


;******************************************************************************
;	 F L A G S   F O R   C A L L _ P R I O R I T Y _ V M _ E V E N T
;==============================================================================

PEF_Wait_For_STI	EQU	0000001b
PEF_Wait_For_STI_Bit	EQU	0
PEF_Wait_Not_Crit	EQU	0000010b
PEF_Wait_Not_Crit_Bit	EQU	1
PEF_Dont_Unboost	EQU	0000100b
PEF_Dont_Unboost_Bit	EQU	2
PEF_Always_Sched	EQU	0001000b
PEF_Always_Sched_Bit	EQU	3


;******************************************************************************
;	 F L A G S   F O R   B E G I N _ C R I T I C A L _ S E C T I O N
;		       A N D   W A I T _ S E M A P H O R E
;==============================================================================

Block_Svc_Ints			EQU	0000001b
Block_Svc_Ints_Bit		EQU	0
Block_Svc_If_Ints_Locked	EQU	0000010b
Block_Svc_If_Ints_Locked_Bit	EQU	1
Block_Enable_Ints		EQU	0000100b
Block_Enable_Ints_Bit		EQU	2



BeginDoc
;******************************************************************************
; The following structures are pointed to by EBP when VxD routines are entered,
;   both for VxD control calls and traps(I/O traps, software INT traps, etc.).
;   The first structure as DWORD values, the second WORD values and the last
;   has BYTE values.
;
Client_Reg_Struc   struc
Client_EDI	dd	?		; Client's EDI
Client_ESI	dd	?		; Client's ESI
Client_EBP	dd	?		; Client's EBP
		dd	?		; ESP at pushall
Client_EBX	dd	?		; Client's EBX
Client_EDX	dd	?		; Client's EDX
Client_ECX	dd	?		; Client's ECX
Client_EAX	dd	?		; Client's EAX
Client_Error	dd	?		; Dword error code
Client_EIP	dd	?		; EIP
Client_CS	dw	?		; CS
		dw	?		;   (padding)
Client_EFlags	dd	?		; EFLAGS
Client_ESP	dd	?		; ESP
Client_SS	dw	?		; SS
		dw	?		;   (padding)
Client_ES	dw	?		; ES
		dw	?		;   (padding)
Client_DS	dw	?		; DS
		dw	?		;   (padding)
Client_FS	dw	?		; FS
		dw	?		;   (padding)
Client_GS	dw	?		; GS
		dw	?		;   (padding)
Client_Alt_EIP	dd	?
Client_Alt_CS	dw	?
		dw	?
Client_Alt_EFlags  dd	?
Client_Alt_ESP	dd	?
Client_Alt_SS	dw	?
		dw	?
Client_Alt_ES	dw	?
		dw	?
Client_Alt_DS	dw	?
		dw	?
Client_Alt_FS	dw	?
		dw	?
Client_Alt_GS	dw	?
		dw	?
Client_Reg_Struc   ends


Client_Word_Reg_Struc	struc
Client_DI	dw	?		; Client's DI
		dw	?		;   (padding)
Client_SI	dw	?		; Client's SI
		dw	?		;   (padding)
Client_BP	dw	?		; Client's BP
		dw	?		;   (padding)
		dd	?		; ESP at pushall
Client_BX	dw	?		; Client's BX
		dw	?		;   (padding)
Client_DX	dw	?		; Client's DX
		dw	?		;   (padding)
Client_CX	dw	?		; Client's CX
		dw	?		;   (padding)
Client_AX	dw	?		; Client's AX
		dw	?		;   (padding)
		dd	?		; Dword error code
Client_IP	dw	?		; Client's IP
		dw	?		;   (padding)
		dd	?		; CS
Client_Flags	dw	?		; Client's flags (low)
		dw	?		;   (padding)
Client_SP	dw	?		; SP
		dw	?
		dd	5 dup (?)
Client_Alt_IP	dw	?
		dw	?
		dd	?
Client_Alt_Flags    dw	?
		dw	?
Client_Alt_SP	dw	?
Client_Word_Reg_Struc	ends



Client_Byte_Reg_Struc	struc
		dd	4 dup (?)	; EDI, ESI, EBP, ESP at pushall
Client_BL	db	?		; Client's BL
Client_BH	db	?		; Client's BH
		dw	?		;   (padding)
Client_DL	db	?		; Client's DL
Client_DH	db	?		; Client's DH
		dw	?		;   (padding)
Client_CL	db	?		; Client's CL
Client_CH	db	?		; Client's CH
		dw	?		;   (padding)
Client_AL	db	?		; Client's AL
Client_AH	db	?		; Client's AH
Client_Byte_Reg_Struc	ends

;==============================================================================
EndDoc

.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX



PushCParams MACRO P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
	IRP Param, <P10, P9, P8, P7, P6, P5, P4, P3, P2, P1>
	IFNB <Param>
	push	Param
	ENDIF
	ENDM
	ENDM

ClearCParams MACRO Count, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10
IFNB <P1>
	ClearCParams %(Count+1), <P2>, <P3>, <P4>, <P5>, <P6>, <P7>, <P8>, <P9>, <P10>
ELSE
IF Count
	add	esp, Count*4
ENDIF
ENDIF
	ENDM



Dyna_Link_Int	EQU 20h

;
;
BeginDoc
;******************************************************************************
; The VMMCall and VxDCall macros provide a dynamic link to the VMM and VxD
;   service routines. For example:
;
;   VMMCall Enable_VM_Ints		; Equivalent to STI in VM code
;
;   mov     eax,[My_IRQ_Handle]
;   VxDCall VPICD_Set_Int_Request	; Set IRQ for my device's interrupt
;
; Note that Enable_VM_Ints is defined in VMM.INC and VPICD_Set_Int_Request is
;	defined in VPICD.INC
;
;==============================================================================
EndDoc


BeginDoc
;******************************************************************************
; VxDCall
;==============================================================================
EndDoc
VxDcall MACRO P, Param
	PushCParams Param
	int	Dyna_Link_Int
	dd	P
	ClearCParams 0, Param
	ENDM

VxDjmp	MACRO P, Param
IFNB <Param>
%OUT ERROR:  Parameters may not be passed to VxDjmp or VMMjmp macros
.ERR
ENDIF
	int	Dyna_Link_Int
IFDEF DEBUG
	dd	P
	ret
ELSE
	dd	P OR DL_Jmp_Mask
ENDIF
	ENDM

DL_Jmp_Mask	EQU	8000h
DL_Jmp_Bit	EQU	0Fh


VMMcall MACRO P, Param
	.ERRNZ (P SHR 16) - VMM_Device_ID
	VxDcall <P>, <Param>
	ENDM

VMMjmp MACRO P, Param
	.ERRNZ (P SHR 16) - VMM_Device_ID
	VxDjmp <P>, <Param>
	ENDM

cCall MACRO P, Param
	PushCParams Param
	call	P
	ClearCParams 0, Param
	ENDM


BeginDoc
;******************************************************************************
; Segment definition macros
;
; The segment definition macros are a convenience used in defining the
;	segments used by the device driver. They are:
;VxD_ICODE_SEG	 defines start of initialization code segment
;VxD_ICODE_ENDS  defines end of initialization code segment
;VxD_IDATA_SEG	 defines start of initialization data segment
;VxD_IDATA_ENDS  defines end of initialization data segment
;VxD_CODE_SEG	 defines start of always present code segment
;VxD_CODE_ENDS	 defines end of always present code segment
;VxD_DATA_SEG	 defines start of always present data segment
;VxD_DATA_ENDS	 defines end of always present data segment
;==============================================================================
EndDoc


;   Protected mode code
VxD_CODE_SEG	EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS	EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_LCODE
	ASSUME	cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
		ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_LTEXT	 ENDS
		ENDM



;   Protected mode initialization code
VxD_ICODE_SEG	MACRO
_ITEXT	SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_ICODE
	ASSUME	cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
		ENDM

VxD_ICODE_ENDS	MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_ITEXT	ENDS
		ENDM


;   Protected mode data
VxD_DATA_SEG	EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS	EQU <VxD_LOCKED_DATA_ENDS>



VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA	 SEGMENT
IFB <NO_ALIGN>
	ALIGN 4
ENDIF
		ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA	 ENDS
		ENDM




;   Protected mode initialization data
VxD_IDATA_SEG	MACRO
_IDATA	SEGMENT
		ENDM
VxD_IDATA_ENDS	MACRO
_IDATA	ENDS
		ENDM

VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 3 + ??_RCODE
		  ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 3
_RCODE ENDS
		   ENDM

ENDIF

DDK_Version equ 300h

VxD_Desc_Block STRUC
DDB_Next		dd  ?			; VMM RESERVED FIELD
DDB_SDK_Version 	dw  DDK_Version 	; VMM RESERVED FIELD
DDB_Req_Device_Number	dw  Undefined_Device_ID ; Required device number
DDB_Dev_Major_Version	db  0			; Major device number
DDB_Dev_Minor_Version	db  0			; Minor device number
DDB_Flags		dw  0			; Flags for init calls complete
DDB_Name		db  "        "		; Device name
DDB_Init_Order		dd  Undefined_Init_Order; Initialization Order
DDB_Control_Proc	dd  ?			; Offset of control procedure
DDB_V86_API_Proc	dd  0			; Offset of API procedure (or 0)
DDB_PM_API_Proc 	dd  0			; Offset of API procedure (or 0)
DDB_V86_API_CSIP	dd  0			; CS:IP of API entry point
DDB_PM_API_CSIP 	dd  0			; CS:IP of API entry point
DDB_Reference_Data	dd  ?			; Reference data from real mode
DDB_Service_Table_Ptr	dd  0			; Pointer to service table
DDB_Service_Table_Size	dd  0			; Number of services
VxD_Desc_Block ENDS


IFNDEF Not_VxD

; flag values for DDB_Flags

DDB_Sys_Crit_Init_Done	    EQU 00000001b
DDB_Sys_Crit_Init_Done_Bit  EQU        0
DDB_Device_Init_Done	    EQU 00000010b
DDB_Device_Init_Done_Bit    EQU       1

BeginDoc
;******************************************************************************
;
;   Declare_Virtual_Device macro
;
; ???? Write something here ????
;
;==============================================================================
EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc
	LOCAL	V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len

dev_id_err MACRO
%OUT Device ID required when providing services
.ERR
	ENDM

IFB <V86_Proc>
	V86_API_Offset EQU 0
ELSE
IFB <Device_Num>
	dev_id_err
ENDIF
	V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF
IFB <PM_Proc>
	PM_API_Offset EQU 0
ELSE
IFB <Device_Num>
	dev_id_err
ENDIF
	PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF
IFDEF Name&_Service_Table
IFB <Device_Num>
	dev_id_err
ELSE
IFE Device_Num - Undefined_Device_ID
	dev_id_err
ENDIF
ENDIF
	Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
	Serv_Tab_Len	EQU Num_&Name&_Services
ELSE
	Serv_Tab_Offset EQU 0
	Serv_Tab_Len	EQU 0
ENDIF


VxD_LOCKED_DATA_SEG
PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
			 OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
			 ,,,Serv_Tab_Offset, Serv_Tab_Len>
VxD_LOCKED_DATA_ENDS
	ENDM


BeginDoc
;******************************************************************************
; The Begin_Control_Dispatch macro is used for building a table for dispatching
; messages passed to the VxD_Control procedure.  It is used with
; Control_Dispatch and End_Control_Dispatch.  The only parameter is used to
; contruct the procedure label by adding "_Control" to the end (normally the
; device name is used i.e. VKD results in creating the procedure VKD_Control,
; this created procedure label must be included in Declare_Virtual_Device)
;
; An example of building a complete dispatch table:
;
; Begin_Control_Dispatch MyDevice
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
; Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
; Control_Dispatch  Create_VM,	 MyDeviceCreateVMProcedure
; End_Control_Dispatch MyDevice
;
; (NOTE: Control_Dispatch can be used without Begin_Control_Dispatch, but
;	 then it is the programmer's responsibility for declaring a procedure
;	 in locked code (VxD_LOCKED_CODE_SEG) and returning Carry clear for
;	 any messages not processed.  The advantage in using
;	 Begin_Control_Dispatch is when a large # of messages are processed by
;	 a device, because a jump table is built which will usually require
;	 less code space then the compares and jumps that are done when
;	 Control_Dispatch is used alone.
;
;==============================================================================
EndDoc
Begin_Control_Dispatch MACRO VxD_Name
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control
ENDM

End_Control_Dispatch   MACRO VxD_Name
	LOCAL ignore, table

jmpproc MACRO num
	jmp	??_cd_&&num
ENDM

procoff MACRO num
IFDEF ??_cd_&&num
	dd	OFFSET32 ??_cd_&&num
ELSE
	dd	OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
	cmp	eax, ??_cd_low
	jne	short ignore
	jmpproc %(??_cd_low)
ignore:
	clc
	ret
ELSE
	cmp	eax, ??_cd_high
	ja	short ignore
	sub	eax, ??_cd_low
	jb	short ignore
	jmp	cs:[eax*4+table]
ignore:
	clc
	ret

table label dword
	REPT   ??_cd_high - ??_cd_low + 1
	procoff %(??_cd_low)
	??_cd_low = ??_cd_low + 1
	ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE jmpproc
PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc
;******************************************************************************
; The Control_Dispatch macro is used for dispatching based on message
;	passed to the VxD_Control procedure. E.G.:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
;
; (NOTE: Control_Dispatch can be used with Begin_Control_Dispatch and
;	 End_Control_Dispatch to create a jump table for dispatching messages,
;	 when a large # of messages are processed.)
;
;==============================================================================
EndDoc
Control_Dispatch MACRO Service, Procedure
	LOCAL Skip_Interseg_Jump

IFE ?_lcode
IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
	cmp	eax, Service
	jne	SHORT Skip_Interseg_Jump
	jmp	Procedure
Skip_Interseg_Jump:
ENDIF
ELSE
%OUT ERROR:  The Control proc should be in LOCKED code.
%OUT	     Control_Dispatch can only be used inside of VxD_LOCKED_CODE_SEG.
.err
ENDIF
	ENDM


BeginDoc
;******************************************************************************
; The following are the definitions for the "type of I/O" parameter passed
;   to a I/O trap routine
Byte_Input	EQU	000h
Byte_Output	EQU	004h
Word_Input	EQU	008h
Word_Output	EQU	00Ch
Dword_Input	EQU	010h
Dword_Output	EQU	014h

Output		EQU	0000000000000100b
Output_Bit	EQU	2
Word_IO 	EQU	0000000000001000b
Word_IO_Bit	EQU	3
Dword_IO	EQU	0000000000010000b
Dword_IO_Bit	EQU	4

String_IO	EQU	00000020h
String_IO_Bit	EQU	5
Rep_IO		EQU	00000040h
Rep_IO_Bit	EQU	6
Addr_32_IO	EQU	00000080h
Addr_32_IO_Bit	EQU	7
Reverse_IO	EQU	00000100h
Reverse_IO_Bit	EQU	8

IO_Seg_Mask	EQU	0FFFF0000h		; Use these bits to get segment
IO_Seg_Shift	EQU	10h			; Must shift right this many

;==============================================================================
EndDoc

BeginDoc
;******************************************************************************
;
;   Dispatch_Byte_IO macro
;
; Dispatch_Byte_IO Byte_In_Proc, Byte_Out_Proc
;==============================================================================
EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
	LOCAL	Byte_IO
	cmp	ecx, Byte_Output
	jbe	SHORT Byte_IO
	VMMjmp	Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
	je	Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
	jb	In_Proc
ELSE
	je	Out_Proc
	jmp	In_Proc
ENDIF
ENDIF
	ENDM

BeginDoc
;******************************************************************************
;
;   Emulate_Non_Byte_IO
;
; Emulate_Non_Byte_IO
;
;==============================================================================
EndDoc
Emulate_Non_Byte_IO MACRO
	LOCAL	Byte_IO
	cmp	ecx, Byte_Output
	jbe	SHORT Byte_IO
	VMMjmp	Simulate_IO
Byte_IO:
	ENDM


VxD_IOT_Hdr STRUC
VxD_IO_Ports	dw  ?
VxD_IOT_Hdr ENDS

VxD_IO_Struc STRUC
VxD_IO_Port	dw  ?
VxD_IO_Proc	dd  ?
VxD_IO_Struc ENDS


BeginDoc
;******************************************************************************
;
; Begin_VxD_IO_Table
;
;   Example:
; Begin_VxD_IO_Table MyTableName
;
;==============================================================================
EndDoc
.ERRNZ SIZE VxD_IOT_Hdr - 2	; Begin_VxD_IO_Table creates a 1 word count hdr
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD
IF2
IFNDEF Table_Name&_Entries
%OUT ERROR:  No End_VxD_IO_Table for &Table_Name
.ERR
ENDIF
	dw	Table_Name&_Entries
ELSE
	dw	?
ENDIF

	ENDM

.ERRNZ SIZE VxD_IO_Struc - 6	; VxD_IO creates 6 byte I/O port entries
VxD_IO MACRO Port, Proc_Name
	dw	Port
	dd	OFFSET32 Proc_Name
	ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
%OUT ERROR:  No Begin_VxD_IO_Table for &Table_Name
.ERR
ELSE
	Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
%OUT ERROR:  Invalid number of port traps in &Table_Name
.ERR
ENDIF
ENDIF
	    ENDM


;******************************************************************************
;******************************************************************************

Push_Client_State MACRO
	sub	esp, SIZE Client_Reg_Struc
	push	edi
	lea	edi, [esp+4]
	VMMcall Save_Client_State
	pop	edi
	ENDM

Pop_Client_State MACRO
	push	esi
	lea	esi, [esp+4]
	VMMcall Restore_Client_State
	pop	esi
	add	esp, SIZE Client_Reg_Struc
	ENDM

BeginDoc
;******************************************************************************
;
;   CallRet -- Call procedure and return.  For debugging purposes only.
;	       If compiled with debugging then this will generate a call
;	       followed by a return.  If non-debugging version then the
;	       specified label will be jumped to.
;
;   PARAMETERS:
;	Label_Name = Procedure to be called
;
;   EXIT:
;	Return from current procedure
;
;------------------------------------------------------------------------------
EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
	call	P2
ELSE
	call	P1
ENDIF
	ret
ELSE
	jmp	P1 P2
ENDIF
	ENDM


; ebp offsets to segments pushed by PMode_Fault in Fault_Dispatch
PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16


Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off

IFDIFI <Reg_32>, <EAX>
	push	eax
ENDIF
IFB <Cli_Off>
	mov	ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
	mov	ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
	VMMcall Map_Flat

IFDIFI <Reg_32>, <EAX>
	mov	Reg_32, eax
	pop	eax
ENDIF

	ENDM

;------------------------------------------------------------------------------

VxDint	MACRO	Int_Number
	push	DWORD PTR Int_Number
	VMMcall Exec_VxD_Int
	ENDM


ENDIF	; Not_VxD


BeginDoc
;******************************************************************************
;
;   The following equates are for flags sent to the real mode
;   initialization portion of a device driver:
;
Duplicate_Device_ID	    equ 0000000000000001b   ; duplicate device ID already
Duplicate_Device_ID_Bit     equ 	       0    ; loaded
Duplicate_From_INT2F	    equ 0000000000000010b   ; duplicate device ID already
Duplicate_From_INT2F_Bit    equ 	      1     ; loaded as part of INT 2F
						    ; device list
Loading_From_INT2F	    equ 0000000000000100b   ; this device was specified
Loading_From_INT2F_Bit	    equ 	     2	    ; in the INT 2F device list

EndDoc

BeginDoc
;******************************************************************************
;
;   The following equates are used to indicate the result of the real mode
;   initialization portion of a device driver:
;

Device_Load_Ok	    equ 0		; protected mode portion of device
					; should be loaded
Abort_Device_Load   equ 1		; don't load any protected mode portion
					; of this device, but continue loading
					; the rest of the devices
Abort_Win386_Load   equ 2		; fatal-error: abort the load of Win386

No_Fail_Message     equ 8000h		; The high bit is set in the return
No_Fail_Message_Bit equ 15		; code, if the loader should not print
					; any message for results
					; Abort_Device_Load or Abort_Win386_Load
;==============================================================================
EndDoc


;==============================================================================

; CR0 bit assignments
PE_Mask 	EQU	0001h	; 1 = Protected Mode
PE_Bit		EQU	0
MP_Mask 	EQU	0002h	; 1 = Monitor Coprocessor
MP_Bit		EQU	1
EM_Mask 	EQU	0004h	; 1 = Emulate Math Coprocessor
EM_Bit		EQU	2
TS_Mask 	EQU	0008h	; 1 = Task Switch occured
TS_Bit		EQU	3
ET_Mask 	EQU	0010h	; 1 = 387 present, 0 = 287 present
ET_Bit		EQU	4
PG_Mask 	EQU 80000000h	; 1 = paging enabled, 0 = paging disabled
PG_Bit		EQU	31

; EFLAGs bit assignments
CF_Mask 	EQU	000000000000000001b	; Carry flag
CF_Bit		EQU	0
PF_Mask 	EQU	000000000000000100b	; Parity flag
PF_Bit		EQU	2
AF_Mask 	EQU	000000000000010000b	; Aux flag
AF_Bit		EQU	4
ZF_Mask 	EQU	000000000001000000b	; Zero flag
ZF_Bit		EQU	6
SF_Mask 	EQU	000000000010000000b	; Sign flag
SF_Bit		EQU	7
TF_Mask 	EQU	000000000100000000b	; Trace flag
TF_Bit		EQU	8
IF_Mask 	EQU	000000001000000000b	; Int flag
IF_Bit		EQU	9
DF_Mask 	EQU	000000010000000000b	; Direction flag
DB_Bit		EQU	10
OF_Mask 	EQU	000000100000000000b	; Overflow flag
OF_Bit		EQU	11
IOPL_Mask	EQU	000011000000000000b	; IOPL flags
IOPL_Bit0	EQU	12
IOPL_Bit1	EQU	13
NT_Mask 	EQU	000100000000000000b	; Nested task flag
NT_Bit		EQU	14
RF_Mask 	EQU	010000000000000000b	; Resume flag
RF_Bit		EQU	16
VM_Mask 	EQU	100000000000000000b	; Virtual Mode flag
VM_Bit		EQU	17


;------------------------------------------------------------------------------
;
;	  Temporary MASM macros (to be removed when supported by MASM)
;
;------------------------------------------------------------------------------

loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>


;******************************************************************************
; PAGE TABLE EQUATES
;******************************************************************************


P_SIZE		equ	1000h		; page size

; ---------------------------------------------------
;
;	Page table entry bits
;
; ---------------------------------------------------

P_PRES		equ	01h		; page present bit
P_WRITE 	equ	02h		; write access bit
P_USER		equ	04h		; access bit for User mode
P_ACC		equ	20h		; page accessed bit
P_DIRTY 	equ	40h		; page dirty bit

P_AVAIL 	equ	(P_PRES+P_WRITE+P_USER) ; avail to everyone & present

; ---------------------------------------------------
;
;  Page types - definition of the OS reserved bits in the page table
;		entry.
; ---------------------------------------------------

PG_TYPE 	equ	0E00h		; TYPE bits in PTE

; ---------------------------------------------------
;
;	 Page types for page allocator calls
;
; ---------------------------------------------------
PG_VM		equ	0
PG_SYS		equ	1
PG_RESERVED1	equ	2
PG_PRIVATE	equ	3
PG_RESERVED2	equ	4
PG_RELOCK	equ	5		; PRIVATE to MMGR
PG_INSTANCE	equ	6
PG_HOOKED	equ	7
PG_IGNORE	equ	0FFFFFFFFh


; ---------------------------------------------------
;
;	 Types for page table entries
;
; ---------------------------------------------------
PgT_VM		equ	PG_VM SHL 9
PgT_SYS 	equ	PG_SYS SHL 9
PgT_RESERVED1	equ	PG_RESERVED1 SHL 9
PgT_PRIVATE	equ	PG_PRIVATE SHL 9
PgT_RESERVED2	equ	PG_RESERVED2 SHL 9
PgT_RELOCK	equ	PG_RELOCK SHL 9
PgT_INSTANCE	equ	PG_INSTANCE SHL 9
PgT_HOOKED	equ	PG_HOOKED SHL 9



;******************************************************************************

; ---------------------------------------------------
;
; Definitions for the access byte in a descriptor
;
; ---------------------------------------------------


; Following fields are common to segment and control descriptors

D_PRES		equ	080h		; present in memory
D_NOTPRES	equ	0		; not present in memory

D_DPL0		equ	0		; Ring 0
D_DPL1		equ	020h		; Ring 1
D_DPL2		equ	040h		; Ring 2
D_DPL3		equ	060h		; Ring 3

D_SEG		equ	010h		; Segment descriptor
D_CTRL		equ	0		; Control descriptor

D_GRAN_BYTE	equ	000h		; Segment length is byte granular
D_GRAN_PAGE	equ	080h		; Segment length is page granular
D_DEF16 	equ	000h		; Default operation size is 16 bits
D_DEF32 	equ	040h		; Default operation size is 32 bits


; Following fields are specific to segment descriptors

D_CODE		equ	08h		; code
D_DATA		equ	0		; data

D_RX		equ	02h		; if code, readable
D_X		equ	0		; if code, exec only
D_W		equ	02h		; if data, writable
D_R		equ	0		; if data, read only

D_ACCESSED	equ	1		; segment accessed bit


; Useful combination access rights bytes

RW_Data_Type equ (D_PRES+D_SEG+D_DATA+D_W)
R_Data_Type  equ (D_PRES+D_SEG+D_DATA+D_R)
Code_Type    equ (D_PRES+D_SEG+D_CODE+D_RX)

D_PAGE32	equ	(D_GRAN_PAGE+D_DEF32)		  ; 32 bit Page granular

; Masks for selector fields

SELECTOR_MASK	equ	0fff8h		; selector index
SEL_LOW_MASK	equ	0f8h		; mask for low byte of sel indx
TABLE_MASK	equ	04h		; table bit
RPL_MASK	equ	03h		; privilige bits
RPL_CLR 	equ	not 03h 	; clear ring bits

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\himem\himem.asm ===
;/*
; *                      Microsoft Confidential
; *			 Copyright (C) Microsoft Corporation 1988-1992
; *                      All Rights Reserved.
; */
	page	95,160
	title   'HIMEM.SYS - Microsoft XMS Device Driver'
;*****************************************************************************
;*									     *
;*  HIMEM.ASM -								     *
;*									     *
;*	Extended Memory Specification Driver -				     *
;*									     *
;*****************************************************************************
;
;	himem.inc	- global equates, macros, structures, opening segment
;	himem.asm	- main driver entry, interrupt hooks, a20/HMA functions
;	himem1.asm	- a20 switching code
;	himem2.asm	- driver initialization
;	himem3.asm	- messages for driver initialization
;	himem4.asm	- extended memory allocation functions
;	himem5.asm	- memory move function
;
;	for revision history prior to 1990, see version 2.37 or earlier
;
;	2.35	- Removed a few push/pops from IsA20On, misc	01/14/90
;		  source code reformatting
;	2.36	- Include Int 6Dh vector in shadow RAM disable	01/18/90
;		  check, also allow disable if video Ints already
;		  point at C000h segment.  Also added some CLD's near
;		  string instructions.
;	2.37	- Removed 2.33 'fix' for All Chargecard.  They	01/23/89
;		  now do Global and Local enables to turn on A20, and
;		  the previous 'fix' caused us to never didle A20 again
;		  after running Windows real mode twice (Windows does
;		  Global enables/disables too).  Also, GetParms needed to
;		  check for LF in addition to CR for end of line.
;;
;;; Following changes synced from \402\dev\himem tree
;;
;	2.50	- Revised version # for Windows 3.0 release.	02/05/90
;	 ""	- Ignore 'super'-extended memory on EISA memory 02/08/90
;		  memory boards (mem > 16 meg).  Software that
;		  uses 24 bit (80286) descriptors doesn't do
;		  well with memory @ 16 meg.
;	 ""	- Himem will now try to control A20 by default, 02/12/90
;		  even if A20 is already enabled when himem is
;		  loaded.  Added /A20CONTROL: ON | OFF switch to
;		  override this if necessary (ON is default and
;		  means we take control, OFF means we take control
;		  unless A20 was already on, in which case we
;		  don't mess with it).
;
;	2.60	- Added special A20 routine for Toshiba 1600	02/22/90
;		  laptop, and revised driver version number to
;		  be later than Compaq's (2.50) so Windows
;		  setup will install ours.
;	 ""	- Clear bit 15 in device attributes word of	02/28/90
;		  device header if driver is being flushed. The
;		  MS-DOS Encylopedia says to do this, and a
;		  system with DOS 3.21 was hanging when loading
;		  the driver after himem if himem flushed itself.
;	 ""	- Added special A20 handler for Wyse 12.5 MHz	03/27/90
;		  286 machine. Almost the same as AT, but
;		  a little different.
;	 ""	- Now displays a msg indicating which A20	04/05/90
;		  handler is installed, and allows numbers for the
;		  /MACHINE: parameter.
;;
;;; End of \402\dev\himem changes
;;
;
;	 ""	- Added /INT15=xxxx option to reserve xxxxK of	04/13/90
;		  extended memory for INT 15. Himem will reserve xxxx K
;		  (64 K of HMA inclusive) for apps which use Ext Mem thru
;		  int 15 interface. The HMA portion of the INT 15 ext memory
;		  should be protected by a VDISK header. Apps which
;		  do not recognize VDISK headers may destroy the HMA.
;
;	 ""	- When there is a /INT15=xxxx option on the	04/20/90
;		  command line, the HMA is made unavailable to the
;		  apps. But DOS 5.0 goes ahead and checks for INT 15
;		  memory if the alloc HMA call fails. And if INT 15 memory
;		  is present it uses the first 64 K for loading itself
;		  high (simulated HMA)
;
;	 ""	- ORGed the movable segment to high value for flexibility
;		  in loading into HMA. Added code to be flexible enough to
;		  run from HMA as well as low memory.

	public	Interrupt
	public	dd_int_loc
	public	fHMAExists
	public	PrevInt15
	public	fA20Check
	public	OldStackSeg
	public	pPPFIRET
	public	EnableCount
	public	pReqHdr
	public	MinHMASize
	public	MoveIt
	public	Int2fHandler
	public	ISA15Handler
	public	fHMAMayExist
	public	MemCorr
	public	PrevInt2f
	public	fCanChangeA20
	public	IsVDISKIn
	public	fVDISK

	public	LocalEnableA20
	public	LocalDisableA20
	public	FLclEnblA20
	public	FLclDsblA20
	public	IsA20On
	public	winbug_fix
	public	ATA20Delay

	public	pVersion
	public	pQuery
	public	pAlloc
	public	pFree
	public	pLock
	public	pUnlock
	public	pGetInfo
	public	pRealloc
	public	pAddMem

	public	TopOfTextSeg

	public	XMMControl
	public	pfnEnabA20
	public	pfnDisabA20


; Define a direct call to the Phoenix Cascade BIOS for A20 handling
;	Note:  if these segments are not defined here, the Int13Handler
;	definition in segment Zero in the 386 memory move will generate
;	bad code.

PTL_Seg	segment at 0f000h
PTL_Seg	ends
BiosSeg SEGMENT  AT 40h		  ; Used to locate 6300 PLUS reset address
BiosSeg ends

	include	himem.inc		; define structures, macros, open seg.
	extrn	EndText:byte
_text	ends

funky	segment	para public 'funky'
	assume	cs:funky

;	externals from himem4

	extrn	Version:near
	extrn	aQueryExtMemory:near
	extrn	aAllocExtMemory:near
	extrn	aFreeExtMemory:near
	extrn	LockExtMemory:near
	extrn	UnlockExtMemory:near
	extrn	aGetExtMemoryInfo:near
	extrn	aReallocExtMemory:near
	extrn	aAddMem:near

	extrn	HandleInfo:byte
	extrn	cHandles:word
	extrn	KiddValley:word

;	externals from himem5

	extrn	MoveBlock286:near

funky	ends

;
;------ the following segment should be the last in the sys file
;	This segment is read by the stripdd utility to remove
;	the zeroes introduced by the hi ORG in the movable segment

ZZZ	segment para 'ZZZ'
	dw	16			; len of this segment
	dw	offset _text:EndText	; len of text seg in double word
	dw	0
	dw	HISEG_ORG		; number of zeroes to be stripped
	dw	-1
	dw	-1			; terminator
	db	(4) dup (55h)		; filler
ZZZ	ends


_text	segment word public 'code'
	assume	cs:_text

;	externals from himem1

	extrn	A20Handler:near

;	externals from himem2

	extrn	InitInterrupt:near

	public	DevAttr
	public	Int15MemSize
	public	fInHMA
	public	pInt15Vector
	public	PrevISAInt15

; The Driver Header definition.
Header	dd	-1			; Link to next driver, -1 = end of list
DevAttr	dw	1010000000000000b	; Char device & Output until busy(?)
	dw	Strategy    		; "Stategy" entry point
dd_int_loc	dw	InitInterrupt	; "Interrupt" entry point
		db	'XMSXXXX0'	; Device name


;************************************************************************
;*									*
;*  Global Variables							*
;*									*
;************************************************************************


	if	keep_cs
callers_cs	dw	0
	endif

TopOfTextSeg	dw	0	; size of retained driver
pPPFIRet	dw	PPFIRet ; The offset of an IRET for the POPFF macro
pReqHdr		dd	?	; Pointer to MSDOS Request Header structure
pInt15Vector	dw	15h*4,0 ; Pointer to the INT 15 Vector
PrevInt15	dd	0	; Original INT 15 Vector
PrevInt2f	dd	0	; Original INT 2f Vector
PrevISAInt15	dd	0	; Orig Int 15 Vector for ext mem > 16 meg calls
fHMAInUse	db	0	; High Memory Control Flag, != 0 -> In Use
fCanChangeA20	db	1	; A20 Enabled at start? (assume changable)
fHMAMayExist	db	0	; True if the HMA could exist at init time
fHMAExists	db	0	; True if the HMA exists
fInstalled	db	0	; True if ext mem has been allocated
fInHMA		db	0	; true if hiseg is in HMA

fVDISK		db	0	; True if a VDISK device was found

fA20Check	db	0	; True if A20 handler supports On/Off check
ATA20Delay	db	0	; Type of AT A20 delay in use (0 - NUM_ALT_A20)

		even

EnableCount	dw	0	; A20 Enable/Disable counter
fGlobalEnable	dw	0	; Global A20 Enable/Disable flag
MinHMASize	dw	0	; /HMAMIN= parameter value
Int15MemSize	dw	0	; Memory size reserved for INT 15

MemCorr		dw	0	; KB of memory at FA0000 on AT&T 6300 Plus.
				;      This is used to correct INT 15h,
				;      Function 88h return value.
OldStackSeg	dw	0	; Stack segment save area for 6300 Plus.
				;      Needed during processor reset.

; Pointers to functions that enable and disable A20.

		even
pfnEnabA20	dw	offset _text:ExtEnabA20
pfnDisabA20	dw	offset _text:ExtDisabA20

	if	NUM_A20_RETRIES
A20Retries	db	0	; Count of retires remaining on A20 diddling
	endif

	public	lpExtA20Handler

lpExtA20Handler dd	0	; Far entry point to an external A20 handler

	public	InstldA20HndlrN	;				M008

InstldA20HndlrN	db	0	; Installed A20 handler number	M008

pAddMem		dw	aAddMem
;*----------------------------------------------------------------------*
;*									*
;*  Strategy -								*
;*									*
;*	Called by MS-DOS when ever the driver is accessed.		*
;*									*
;*  ARGS:   ES:BX = Address of Request Header				*
;*  RETS:   Nothing							*
;*  REGS:   Preserved							*
;*									*
;*----------------------------------------------------------------------*

Strategy    proc    far
	assume	ds:nothing

	; Save the address of the request header.
	mov	word ptr [pReqHdr],bx
	mov	word ptr [pReqHdr][2],es
	ret

Strategy    endp


;*----------------------------------------------------------------------*
;*									*
;*  Interrupt -								*
;*									*
;*	Called by MS-DOS immediately after Strategy routine		*
;*									*
;*  ARGS:   None							*
;*  RETS:   Return code in Request Header's Status field		*
;*  REGS:   Preserved							*
;*									*
;*	This is our permanent entry point.  By this time, the only	*
;*	useful function done by the device driver (initializing us)	*
;*	has been done by a previous call.  There are no more valid	*
;*	uses for this entry point.  All we have to do is decide		*
;*	whether to ignore the call or generate an error.		*
;*									*
;*----------------------------------------------------------------------*

Interrupt   proc    far
	assume	ds:nothing


	push    bx		; save minimal register set
	push    ds

	lds	bx,[pReqHdr]		; ds:bx = Request Header

	cmp	ds:[bx].Command,16	; legal DOS function?  (approx???)
	mov	ds:[bx].Status,100h	; "Done" for healthy calls
	jbe	FuncOk
	or	ds:[bx].Status,8003h	; Return "Unknown Command" error
FuncOk:
	pop	ds
	pop	bx
	ret

Interrupt   endp


;*----------------------------------------------------------------------*
;*									*
;*  Int2fHandler -							*
;*									*
;*	Hooks Function 43h, Subfunction 10h to return the		*
;*	address of the High Memory Manager Control function.		*
;*	Also returns 80h if Function 43h, Subfunction 0h is requested.	*
;*									*
;*  ARGS:   AH = Function, AL = Subfunction				*
;*  RETS:   ES:BX = Address of XMMControl function (if AX=4310h)	*
;*	    AL = 80h (if AX=4300)					*
;*  REGS:   Preserved except for ES:BX (if AX=4310h)			*
;*	    Preserved except for AL    (if AX=4300h)			*
;*									*
;*----------------------------------------------------------------------*

Int2fHandler proc   far
	assume	ds:nothing, es:nothing

	sti			; Flush any queued interrupts

	cmp	ah,43h		; Function 43h?
	jne     I2fNextInt
	or	al,al		; Subfunction 0?
	jne     I2fNextSub	; No, continue

	mov	al,80h		; Return 80h in AL (XMS Installed)
PPFIRet:
	iret			; Label sets up the POPFF macro

I2fNextSub:
	cmp	al,10h		; Subfunction 10?
	jne	trya20id	; No, check whther it is A20 handler request M008

	push    cs		; return XMS entry in es:bx
	pop	es
	mov	bx,offset XMMControl
	iret
;
; Check if it is A20 handler request and process it if so M008
;
trya20id:
	cmp	al, 08h
	jne	tryHandleInfo

	mov	al, ah		; mark that we did the job AL = 43H
	mov	bh, ATA20Delay	; return the delay type used
	mov	bl, InstldA20HndlrN	; return the a20 handler number in al
	iret

; Check if it is Handle table info request

tryHandleInfo:
	cmp	al, 09h
	jne     I2fNextInt	; No, goto next handler

	mov	al, ah		; mark that we did the job AL = 43H
	mov	es, cs:[hiseg]	; return ptr to HandleInfo in es:bx
	mov	bx, offset funky:HandleInfo

	iret

;	Continue down the Int 2f chain.


I2fNextInt:
	cli			; Disable interrupts again
	jmp	[PrevInt2f]

Int2fHandler endp


;*----------------------------------------------------------------------*
;*									*
;*  ControlJumpTable -							*
;*									*
;*	Contains the address for each of the XMS Functions.		*
;*									*
;*	**************** WARNING **********************			*
;*									*
;*	Assumes that offsets of functions in lo mem seg are < 8000h	*
;*	& that offsets of segment in Hiseg are >= 8000h			*
;*									*
;*----------------------------------------------------------------------*

public ControlJumpTable

ifdef debug_tsr
        JumpPtr equ <dd>        ; dword addresses for TSR
ControlJumpTable label dword
else
        JumpPtr equ <dw>        ; word offsets for DOS device driver
ControlJumpTable label word
endif

pVersion:	JumpPtr	Version		  	; Function 00h - funky
		JumpPtr	RequestHMA	  	; Function 01h - _text
		JumpPtr	ReleaseHMA	  	; Function 02h - _text
		JumpPtr	GlobalEnableA20	  	; Function 03h - _text
		JumpPtr	GlobalDisableA20  	; Function 04h - _text
                JumpPtr LocalEnableA20	  	; Function 05h - _text
                JumpPtr LocalDisableA20         ; Function 06h - _text
		JumpPtr	IsA20On		  	; Function 07h - _text
pQuery:		JumpPtr	aQueryExtMemory	  	; Function 08h - funky
pAlloc:		JumpPtr	aAllocExtMemory	  	; Function 09h - funky
pFree:		JumpPtr	aFreeExtMemory	  	; Function 0Ah - funky
MoveIt:		JumpPtr	MoveBlock286	  	; Function 0Bh - funky
pLock:		JumpPtr	LockExtMemory	  	; Function 0Ch - funky
pUnlock:	JumpPtr	UnlockExtMemory	  	; Function 0Dh - funky
pGetInfo:	JumpPtr	aGetExtMemoryInfo 	; Function 0Eh - funky
pRealloc:	JumpPtr	aReallocExtMemory	; Function 0Fh - funky

ifdef debug_tsr
NumFns	=	((offset $) - (offset ControlJumpTable))/4
else
NumFns	=	((offset $) - (offset ControlJumpTable))/2
endif

;*----------------------------------------------------------------------*
;*									*
;*  XMMControl -							*
;*									*
;*	Main Entry point for the Extended Memory Manager		*
;*									*
;*  ARGS:   AH = Function, AL = Optional parm				*
;*  RETS:   AX = Function Success Code, BL = Optional Error Code	*
;*  REGS:   AX, BX, DX and ES may not be preserved depending on func.   *
;*									*
;*  INTERNALLY REENTRANT						*
;*									*
;*----------------------------------------------------------------------*


XMMControl  proc   far

	jmp	short XCControlEntry	; For "hookability"
	nop				; NOTE: The jump must be a
	nop				;  short jump to indicate
	nop				;  the end of any hook chain.
					;  The nop's allow a far jump
					;  to be patched in.
XCControlEntry:

if keep_cs	;--------------------------------------------------------
	push	bp
	mov	bp,sp
	mov	bp,4[bp]		; get caller's cs
	mov	callers_cs,bp	        ;  (debug only)
	pop	bp
endif		;--------------------------------------------------------

	push    si
	push    di
	push	cx

	push    ds
	push    es
	pushf
	cld

	push    ds			; save ds in es
	pop	es			; NOTE: ES cannot be used for parms!

	push    cs			; ds=cs
	pop	ds
	assume	ds:_text

	push    ax			; save the function number

if debug_vers
	call	debug_dump
endif

	or	ah,ah			; GetXMSVersion?
	jz	XCCallFunc		; Yes, don't hook INT 15h yet

	and	ah, 7fh			; mask off Super bit
	cmp	ah,NumFns		; valid function number??
	jb	XCCheckHook
	pop	ax			; No, Un-preserve AX and return an error
	xor	ax,ax
	mov	bl,ERR_NOTIMPLEMENTED
	jmp	short XCExit

XCCheckHook:
	pushf				; Is INT 15h already hooked?
	cli				; This is a critical section

	cmp	word ptr [PrevInt15][2],0 ; Is the segment non-zero?
	jne     XCCheckVD

	push	dx			; save callers DX
	call	HookInt15		; claim all remaining ext mem
	pop	dx

XCCheckVD:
	popff				; End of critical section

	cmp	[fVDISK],0		; was VDISK found?
	je	XCCallFunc
	pop	ax			; Yes, Un-preserve AX and return error
	xor	ax,ax
	mov	bl,ERR_VDISKFOUND
	xor	dx,dx
	jmp	short XCExit

;	Call the appropriate API function.

XCCallFunc:
	pop	ax			; Restore AX
	push    ax			; save ax so functions get both ah & al
	mov	al,ah
	and	ax, 7fh
	shl	ax,1
ifdef debug_tsr
	shl	ax,1
endif
	mov	di,ax			; NOTE: DI cannot be used for parms!
	pop	ax			; restore callers ax for function

        ; In the TSR version, the function addresses are always in low
        ; memory, and the jump table entries are dwords.  In the DOS device
        ; driver version, the function addresses may be in low or high
        ; memory, and the jump table addresses are word offsets.

ifdef debug_tsr

        push    ax
        mov     ax, cs
        cmp     ControlJumpTable[di].sel, ax
        pop     ax
        je      NearXMSCall
        call    ControlJumpTable[di]
        jmp     short @f

NearXMSCall:
        call    ControlJumpTable[di].off

@@:

else
	mov	di,ControlJumpTable[di]	; get function address
	or	di,di
	jns	CallLowSegFn		; brif it's in the low segment

	cmp	fInHMA, 0		; is the hiseg in HMA ?
	jz	InLoMem
;
;------ Turn on the A20 line if it is off
;
	push	si
	push	di
	push	ax
	push	bx
	push	cx
	call	[pfnEnabA20]		; Note:  This is always necessary
	cmp	ax, 1
	pop	cx			; for the Memory Move function.  In
	pop	bx			; the case where this driver loads
	pop	ax			; high, it is necessary for all calls
	pop	di			; to the high segment.
	pop	si
	jne	a20_error

InLoMem:
	push	cs			; set up far return
	call	call_hi_in_di		; and call the function

	cmp	fInHMA, 0		; is the hiseg in HMA ?
	jz	XCExit

	push	ax			; save the registers which may be
	push	bx			; returning values
	call	[pfnDisabA20]		; and restore a20
	cmp	ax, 1
	pop	bx
	pop	ax

	je	short XCExit

a20_error:
	xor	ax, ax
	xor	dx, dx
	mov	bl, ERR_A20
	jmp	short XCExit

CallLowSegFn:
	call	di			; call routine in this segment

endif

XCExit:
;	if	debug_vers or tdump	;------------------------------------
;	pusha
;	call	dump_tables
;	popa
;	endif		;------------------------------------------------------

	popff				; NOTE: Flags must be restored
	pop	es			; immedately after call API functions.
	pop	ds

	pop	cx
	pop	di
	pop	si

;	if	debug_vers ;---------------------------------------------------
;	pushf
;	pusha
;	mov	al,'.'
;	call	cofa
;	mov	al,cs:byte ptr fun_number
;	sub	al,0bh			; don't get key on 0bh, 0ch or 0dh
;	cmp	al,2
;	jbe	no_keywait
;	mov	ah,1		; wait for console key now!!!!!!
;;	int	21h
;no_keywait:
;	popa
;	popf
;	endif		;------------------------------------------------------

	ret

XMMControl  endp

	if	tdump or debug_vers	;------------------------------------

fun_number	db	0		; function number for debug info

dump_tables:
	if	not tdump
	cmp	fun_number,9		; only display on allocate calls
	jnz	dd_done			;  unless full tdump is enabled
	endif
	mov	dx,offset heading
	mov	ah,9
	int	21h

	push	es
	mov	es,hiseg
	assume	es:funky
	mov	si,[KiddValley]
	mov	cx,[cHandles]
	mov	bx,SIZE Handle

xlup:
	mov	al,[si].Flags		; get flags
	cmp	al,4			; don't show UNUSED entries
	jz	x_entry_done

	mov	dx,offset msg_FREE
	cmp	al,1			; free?
	jz	x_showflags
	mov	dx,offset msg_USED
	cmp	al,2			; used?
	jz	x_showflags
	mov	dx,offset msg_BAD
x_showflags:
	mov	ah,9
	int	21h

	mov	al,[si].cLock		; get lock count
	call	hex_byte
	call	space

	mov	ax,[si].Base		; get base
	call	hex_word
	call	space

	mov	ax,[si].Len		; get length
	call	hex_word

	if	keep_cs
	call	space
	mov	ax,[si].Acs		; get the allocator's cs:
	call	hex_word
	endif

x_newline:
	mov	al,13
	call	cofa
	mov	al,10
	call	cofa

x_entry_done:
	add	si,bx
	loop	xlup

	pop	es
	assume	es:nothing
	mov	dx,offset donemsg
	mov	ah,9
	int	21h
dd_done:
	ret


heading		db	'Flags Lock Base Len CS:',13,10,'$'
msg_FREE	db	'FREE   $'
msg_USED	db	'USED   $'
msg_BAD		db	'BAD    $'
donemsg		db	'End of XMS table$'

	endif

	if	debug_vers


debug_dump	proc	near
	pusha
	mov	fun_number,ah	; save (non-reentrantly!) function number
;				;  so that we can display different debug
;				;  information on exit depending on which
;				;  function we've been doing
	mov	al,ah		; just display function number
	call	hex_nib
	popa
	ret

	if	0		; enable this if you want to see the
;				;  command block for memory moves
	cmp	ah,0bh		; memory move?
	jnz	debug_dump_done	; done if not
	pusha
	call	crlf
	mov	ax,es:2[si]	; get count-hi
	call	hex_word
	mov	ax,es:[si]	; get count-low
	call	hex_word
	add	si,4		; point to source address field

	mov	cx,2		; now display two handle/addresses
dd1:
	call	space
	lods	es:word ptr [si] ; get a handle
	call	hex_word
	mov	al,'-'
	call	cofa
	mov	ax,es:2[si]	; get high address
	call	hex_word
	mov	al,':'
	call	cofa
	lods	es:word ptr [si] ; get low address
	call	hex_word
	add	si,2		; skip to next entry for loop
	loop	dd1
	popa
debug_dump_done:
	endif
	ret
debug_dump	endp

	endif

	if	debug_vers or tdump

hex_word:
	push	ax
	mov	al,ah
	call	hex_byte
	pop	ax
hex_byte:
	push	ax
	shr	ax,4		; XMS present implies '286 or better
	call	hex_nib
	pop	ax
hex_nib:
	and	al,0fh
	add	al,90h
	daa
	adc	al,3ah
	daa
cofa:
;	mov	dl,al
;	mov	ah,2
;	int	21h
	mov	ah,0eh
	mov	bx,7
	int	10h
	ret

space:
	mov	al,' '
	jmp	cofa

crlf:
	mov	al,13
	call	cofa
	mov	al,10
	jmp	cofa

	endif		;------------------------------------------------------

;	little utility stub for calling routine in the other segment.
;	  called with the branch offset address in di
;	  a far return address is already on the stack.  Now branch to
;	  hiseg:(di)

	public	hiseg	; allow initialization code to relocate hiseg
hiseg	dw	funky

	public	call_hi_in_di
call_hi_in_di proc near
	push	hiseg
	push	di
call_hi_in_di endp
call_hi_far proc far
	ret
call_hi_far endp


;	Routines to enable and disable A20 by making (recursive) calls to
;	Himem's external XMMControl entry point.  Calling the external
;	entry point instead of internal routines allows XMS hook code to
;	see the A20 enable and disable calls.  This is important for
;	memory managers (like EMM386) that virtualize A20 when Himem is
;	using an A20 handler that the memory manager doesn't trap (for
;	example Zenith FASTGATE A20 hardware accessed via the ZBIOS A20
;	handler).

ExtEnabA20	proc	near

	mov	ah, 05				;local enable A20 service
	push	cs
	call	near ptr XMMControl
	ret

ExtEnabA20	endp

ExtDisabA20	proc	near

	mov	ah, 06				;local disable A20 service
	push	cs
	call	near ptr XMMControl
	ret

ExtDisabA20	endp


;*----------------------------------------------------------------------*
;*									*
;*  HookInt15 -								*
;*									*
;*	Insert the INT 15 hook						*
;*									*
;*  ARGS:   None							*
;*  RETS:   None							*
;*  REGS:   AX, BX, CX, DX, DI, SI, and Flags are clobbered		*
;*									*
;*  EXTERNALLY NON-REENTRANT						*
;*	Interrupts must be disabled before calling this function.	*
;*									*
;*----------------------------------------------------------------------*


HookInt15   proc    near

	push    es

	call    IsVDISKIn		; has a VDISK been installed?
	cmp	[fVDISK],0
	je	HINoVD			; No, continue
	pop	es			; Yes, return without hooking
	ret

HINoVD:
	mov	ah,88h			; Is 64K of Extended memory around?
	int	15h

ifdef WIN30COMPATIBLE
	cmp	ax,15*1024		; Limit himem.sys to using 15 meg
	jb	@f			;   of extended memory for apps
	mov	ax,15*1024		;   that don't deal with > 24 bit
@@:					;   addresses
endif

	sub	ax,[MemCorr]    	; 6300 Plus may have memory at FA0000h
	cmp	ax,64
	jb	HIInitMemory		; Less than 64K free?  Then no HMA.
	cmp	Int15MemSize, 0		; are we supporting int 15 memory
	jnz	HIInitMemory		; then we dont support HMA
	mov	[fHMAExists],1

HIInitMemory:

;	Init the first handle to be one huge free block.

	or	ax, ax			; don't do it if no Int 15 memory avail
	jz	HISkipInit

	mov	cx,1024			; base is just above 1 meg

	xor	bx, bx			; assume no HMA

	cmp	[fHMAExists],0		; Reserve room for HMA if it exists
	je	@f
	mov	bx, 64
@@:	cmp	bx, Int15MemSize
	jae	@f
	mov	bx, Int15MemSize
@@:	add	cx,bx
	sub     ax,bx
	xor	dx, dx
	mov	bx, dx

	mov	di, pAddMem
	push	cs
	call	call_hi_in_di

HISkipInit:

;	Save the current INT 15 vector.

	les     si,dword ptr pInt15Vector

;	Exchange the old vector with the new one.

	mov	ax,offset Int15Handler
	xchg    ax,es:[si][0]
	mov	word ptr [PrevInt15][0],ax
	mov	ax,cs
	xchg    ax,es:[si][2]
	mov	word ptr [PrevInt15][2],ax

	pop	es
	ret

HookInt15   endp

;*----------------------------------------------------------------------*
;*									*
;*  IsVDISKIn -								*
;*									*
;*	Looks for drivers which use the IBM VDISK method of allocating	*
;*  Extended Memory.  XMS is incompatible with the VDISK method.  It is *
;*  necessary to check two different locations since some programs only *
;*  one or the other, although they should do both.			*
;*									*
;*  ARGS:   None							*
;*  RETS:   None.  Sets "fVDISK" accordingly				*
;*  REGS:   AX, BX, CX, SI, DI and Flags are clobbered			*
;*									*
;*  INTERNALLY REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

pVDISK	label   dword
	dw	00013h
	dw	0FFFFh

szVDISK	db	'VDISK'

IsVDISKIn   proc    near

;	Look for "VDISK" signature at offset 12h in Int 19h segment

	push	es

	xor	ax,ax
	mov	es,ax
	mov	es,es:[(19h * 4)+2]
	mov	di,12h
	mov	si,offset szVDISK
	mov	cx,5
	cld
	repz	cmpsb

	pop	es

	jz	IVIFoundIt

;	Look for "VDISK" starting at the 4th byte of extended memory.

	call    LocalEnableA20		; Turn on A20

	push	es

	les	di,cs:pVDISK		; set up the comparison
	mov	si,offset szVDISK
	mov	cx,5
	cld
	repz	cmpsb			; Do the comparison

	pop	es

	pushf
	call	LocalDisableA20
	popff

	jz	IVIFoundIt

	mov	[fVDISK],0		; No VDISK device found
	ret

IVIFoundIt:
	mov	[fVDISK],1		; "VDISK" was found
	ret

IsVDISKIn   endp


;*----------------------------------------------------------------------*
;*									*
;*  Int15Handler -							*
;*									*
;*	Hooks Function 88h to return zero as the amount of extended	*
;*	memory available in the system.					*
;*									*
;*	Hooks Function 87h and preserves the state of A20 across the	*
;*	block move.							*
;*									*
;*  ARGS:   AH = Function, AL = Subfunction				*
;*  RETS:   AX = 0 (if AH == 88h)					*
;*  REGS:   AX is clobbered						*
;*									*
;*----------------------------------------------------------------------*


Int15Handler proc   far

	cmp	ah,88h			; request == report free ext mem?
	je	I15ExtMem

	cmp	ah,87h			; Block move?
	je	I15BlkMov

	jmp     cs:[PrevInt15]		; continue down the int 15h chain

I15ExtMem:
	mov	ax, cs:Int15MemSize	; return 'free' Int 15h extended memory
	iret


I15BlkMov:
	cli				; Make sure interrupts are off

	sub	sp,4			; Make space for A20 flag & flags word
	pusha				; Preserve the caller's registers

	call	IsA20On 		; Get current A20 state

	mov	bp,sp			; Stk= [pusha] [fl] [a20] [ip] [cs] [fl]
	mov	[bp+18],ax		; Save A20 state
	mov	ax,[bp+24]		; Get caller's entry flags and save on
	mov	[bp+16],ax		;   stack, forms part of iret frame

	popa				; Restore the caller's registers

;	Simulate an interrupt to lower level Int 15h handler.  Note that
;	the flags image is already on the stack from code above.  The Int
;	15h handler may or may return with interrupts enabled.

	call	cs:[PrevInt15]

	push	ax			; Save returned AX
	pushf				; Save flags returned from lower level

	push	bp			; Stack =
	mov	bp,sp			;    [bp] [fl] [ax] [a20] [ip] [cs] [fl]
	mov	ax,[bp+2]		; Setup to pass lower level flags
	mov	[bp+12],ax		;   back to caller on iret
	cmp	word ptr [bp+6],0	; While we're here test old A20 state
	pop	bp
	pop	ax			; Discard flags
	pop	ax			; Restore AX

	jz	I15HExit		; A20 was off, don't mess with it

	cli				; A20 handlers called with ints off
	pusha				; Preserve previous handler's return
	mov     ax,1
	call	A20Handler		; turn A20 back on
	popa				; Restore the previous handler's return

I15HExit:
	add	sp,2			; 'pop' A20 state flag
	iret				; Uses flags from lower level handler

Int15Handler endp

;*----------------------------------------------------------------------------*
;*                                                                            *
;*  ISA15handler -                                                            *
;*                                                                            *
;*      Hooks Function AX=E801h                                               *
;*                                                                            *
;*  ARGS:   AH = Function, AL = Subfunction                                   *
;*  If AX=E801 then:                                                          *
;*      RETS:   AX = available extended memory <16M (int 15 function 88h)     *
;*              BX = available extended memory >16M if ISA machine            *
;*		other regs = E801h int 15 return values.		      *
;*                                                                            *
;*----------------------------------------------------------------------------*

ISA15handler proc   far

        cmp     ax,0E801h
	je	ISAOurs

        jmp     cs:[PrevISAInt15]      ; Continue down the Int 15h chain.

ISAOurs:
        pushf                               ; Simualate an interrupt
        call    cs:[PrevISAInt15]

        mov     bx,0                        ; if hooked 0 memory available >16M

	cmp	word ptr cs:[PrevInt15][2],0  ; if Int 15h/88h hooked, return
	je	ISAend			      ;   whatever it would return

	mov	ax, cs:[Int15MemSize]	    ;  return free INT 15 memory
					    ;	  just like Int 15h/88h
ISAend:
        iret

ISA15handler endp


;*----------------------------------------------------------------------*
;*									*
;*  RequestHMA -					FUNCTION 01h    *
;*									*
;*	Give caller control of the High Memory Area if it is available.	*
;*									*
;*  ARGS:   DX = HMA space requested in bytes				*
;*  RETS:   AX = 1 if the HMA was reserved, 0 otherwise.  BL = Error	*
;*  REGS:   AX, BX and Flags clobbered					*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

winbug_fix	dw	0	; storage for windows bug workaround

RequestHMA  proc   near

	cli			; This is a non-reentrant function.
				; Flags are restored after the return.

	mov	bl,ERR_HMAINUSE

;	***************************
;	**  There's a problem with WIN386 2.11.  It calls XMS driver
;	**   incorrectly and then goes ahead and uses the memory
;	**   it didn't properly allocate.  In order to convince it
;	**   not to go ahead and use the extended memory, we must
;	**   fail this function when it calls us.  We know that
;	**   al=40h and dx=free memory returned from QueryExtMemory
;	**   when we're called from windows.  Hopefully no legitimate
;	**   caller will happen to have that exact same 24 bit code
;	**   in al/dx when they call this function because they will fail.
;	***************************

	cmp	al,40h		; called from win386 2.11?
	jnz	not_winbug
	cmp	dx,winbug_fix   ; dx=last result from QueryExtMem?
	jz	RHRetErr	; fail if so
not_winbug:

	cmp	[fHMAInUse],1   ; Is the HMA already allocated?
	je	RHRetErr

	mov	bl,ERR_HMANOTEXIST
	cmp	[fHMAExists],0  ; Is the HMA available?
	je	RHRetErr

	mov	bl,ERR_HMAMINSIZE
	cmp	dx,[MinHMASize] ; Is this guy allowed in?
	jb	RHRetErr

	mov	ax,1
	mov	[fHMAInUse],al  ; Reserve the High Memory Area
	xor     bl,bl		; Clear the error code
	ret

RHRetErr:
	xor     ax,ax		; Return failure with error code in BL
	ret

RequestHMA  endp


;*----------------------------------------------------------------------*
;*									*
;*  ReleaseHMA -					FUNCTION 02h    *
;*									*
;*	Caller is releasing control of the High Memory area		*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if control is released, 0 otherwise.	 BL = Error	*
;*  REGS:   AX, BX and Flags clobbered					*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

ReleaseHMA  proc   near

	cli				; This is a non-reentrant function

	mov	al,[fHMAInUse]		; HMA currently in use?
	or	al,al
	jz	RLHRetErr	 	; No, return error

	mov	[fHMAInUse],0		; Release the HMA and return success
	mov	ax,1
	xor	bl,bl
	ret

RLHRetErr:
	xor	ax,ax
	mov	bl,ERR_HMANOTALLOCED
	ret

ReleaseHMA  endp


;*----------------------------------------------------------------------*
;*									*
;*  GlobalEnableA20 -					FUNCTION 03h    *
;*									*
;*	Globally enable the A20 line					*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if the A20 line is enabled, 0 otherwise.  BL = Error	*
;*  REGS:   AX, BX CX, SI, DI and Flags clobbered			*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

GlobalEnableA20 proc near

	cli				; This is a non-reentrant function
	cmp	[fGlobalEnable],1	; Is A20 already globally enabled?
	je	GEARet

GEAEnable:
	call    LocalEnableA20		; Attempt to enable A20
	or	ax,ax
	jz	GEAA20Err

	mov	[fGlobalEnable],1	; Mark A20 global enabled

GEARet:
	mov	ax,1			; return success
	xor	bl,bl
	ret

GEAA20Err:
	mov	bl,ERR_A20		; some A20 error occurred
	xor	ax,ax
	ret
GlobalEnableA20 endp


;*----------------------------------------------------------------------*
;*									*
;*  GlobalDisableA20 -					FUNCTION 04h    *
;*									*
;*	Globally disable the A20 line					*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX=1 if the A20 line is disabled, 0 otherwise.  BL = Error	*
;*  REGS:   AX, BX, CX, SI, DI and Flags are clobbered			*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

GlobalDisableA20 proc near

	cli				; This is a non-reentrant function
	cmp	[fGlobalEnable],0	; Is A20 already global-disabled?
	je	GDARet

	call    LocalDisableA20		; Attempt to disable it
	or	ax,ax			;   (also zaps CX, SI, DI)
	jz	GDAA20Err

	mov	[fGlobalEnable],0	; mark as global-disabled

GDARet:
	mov	ax,1			; return success
	xor	bl,bl
	ret

GDAA20Err:
	mov	bl,ERR_A20		; some A20 error occurred
	xor	ax,ax
	ret
GlobalDisableA20 endp


;*----------------------------------------------------------------------*
;*									*
;*  LocalEnableA20 -					FUNCTION 05h    *
;*									*
;*	Locally enable the A20 line					*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if the A20 line is enabled, 0 otherwise.  BL = Error	*
;*  REGS:   AX, BX, CX, SI, DI and Flags clobbered			*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*


LocalEnableA20 proc near

	cli				; This is a non-reentrant function

	push	cx

	cmp	[fCanChangeA20],1	; Can we change A20?
	jne	LEARet			; No, don't touch A20

if	NUM_A20_RETRIES
	mov	A20Retries,NUM_A20_RETRIES
endif

	cmp	[EnableCount],0 	; If enable count == 0, go set it
	jz	LEASetIt		;   without bothering to check 1st

if	NUM_A20_RETRIES

LEATestIt:

endif
	call	IsA20On 		; If A20 is already on, don't do
	or	ax,ax			;   it again, but if it isn't on,
	jnz	LEAIncIt		;   then make it so

LEASetIt:
	mov	ax,1			; attempt to turn A20 on
	call    A20Handler		; Call machine-specific A20 handler

ife	NUM_A20_RETRIES
	or	ax,ax			; If we're not doing retries, then
	jz	LEAA20Err		;   use A20 handler's error return
else
	dec	A20Retries		; Any retries remaining?  If so, go
	jnz	LEATestIt		;   test current state, else return
	jmp	short LEAA20Err 	;   an error condition
endif

LEAIncIt:
	inc	[EnableCount]
LEARet:
	mov	ax,1			; return success
	xor	bl,bl
LEA9:
	pop	cx
	ret

LEAA20Err:
	mov	bl,ERR_A20		; some A20 error occurred

	xor	ax,ax
	if	debug_vers
disp_a20_err:
	pusha
	mov	al,'#'
	call	cofa
	popa
	endif
	jmp	short LEA9

LocalEnableA20 endp


;*----------------------------------------------------------------------*
;*									*
;*  LocalDisableA20 -					FUNCTION 06h    *
;*									*
;*	Locally disable the A20 line					*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX=1 if the A20 line is disabled, 0 otherwise.  BL = Error	*
;*  REGS:   AX, BX, CX, SI, DI and Flags are clobbered			*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*


LocalDisableA20 proc near

	cli				; This is a non-reentrant function

	push	cx

	cmp	[fCanChangeA20],0	; Can we change A20?
	je	LDARet			; No, don't touch A20

	cmp	[EnableCount],0		; make sure the count's not zero
	je	LDAA20Err

if	NUM_A20_RETRIES

	mov	A20Retries,NUM_A20_RETRIES

LDATestIt:

endif
	call	IsA20On 		; Currently on or off?

	cmp     [EnableCount],1		; Only if the count = 1 should A20 be
	jnz     LDAStayOn		;   turned off, otherwise it stays on

	or	ax,ax			; If A20 is already off, don't
	jz	LDADecIt		;   bother to turn off again

	xor     ax,ax			; It's on, but should be turned off
	jmp     short LDASetIt

LDAStayOn:
	or	ax,ax			; A20 must stay on, if it is on, just
	jnz	LDADecIt		;   dec count, else force A20 on

	mov     ax,1
LDASetIt:
	call	A20Handler		; Call machine-specific A20 handler

ife	NUM_A20_RETRIES
	or	ax,ax			; If we're not doing retries, then
	jz	LDAA20Err		;   use A20 handler's error return
else
	dec	A20Retries		; Any retries remaining?  If so, go
	jnz	LDATestIt		;   test current state, else return
	jmp	short LDAA20Err 	;   an error condition
endif

LDADecIt:
	dec	[EnableCount]

LDARet:
	mov	ax,1			; return success
	xor	bl,bl
LDA9:
	pop	cx
	ret

LDAA20Err:
	mov     bl,ERR_A20		; some A20 error occurred
	xor     ax,ax
	if	debug_vers
	jmp	disp_a20_err
	endif
	jmp	short LDA9

LocalDisableA20 endp

;
;---------------------------------------------------------------------------
; procedure : FLclEnblA20
; procedure : FLclDsblA20
;
;		Called from the Block move functions. Serves 2 purposes
;		1. Interfaces a far call for a near routine
;		2. If funky is in HMA does a dummy success return
;---------------------------------------------------------------------------
;

FLclEnblA20	proc	far
		cmp	cs:fInHMA, 0
		jz	@f
		mov	ax, 1
		ret
@@:
		call	LocalEnableA20
		ret
FLclEnblA20	endp

FLclDsblA20	proc	far
		cmp	cs:fInHMA, 0
		jz	@f
		mov	ax, 1
		ret
@@:
		call	LocalDisableA20
		ret
FLclDsblA20	endp
;
;*----------------------------------------------------------------------*
;*									*
;*  IsA20On -						FUNCTION 07h    *
;*									*
;*	Returns the state of the A20 line				*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if the A20 line is enabled, 0 otherwise		*
;*	    BL = 0							*
;*  REGS:   AX, BL, CX, SI, DI and Flags clobbered			*
;*									*
;*  INTERNALLY REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

if 0	;********************************************************************

LowMemory   label   dword	; Set equal to 0000:0080
	dw	00080h
	dw	00000h

HighMemory  label   dword
	dw	00090h		; Set equal to FFFF:0090
	dw	0FFFFh

else	;********************************************************************

CmpLoc	db	80h

endif	;********************************************************************


; NOTE: When this routine is called from the Int15 handler, ds is undefined.
;  Hence the CS: overrides on data references.


IsA20On     proc    near

	push	cx

	cmp	cs:[fA20Check],0    ; Does the installed A20 handler support
	jz	@f		    ;	an A20 on/off check routine?

	mov	ax,2		    ; yes, ask it to check the state
	call	A20Handler
	jmp	short IA20Exit
@@:
	push    ds
	push	es

if 0	;*******************************************************************

	xor	ax,ax		    ; assume A20 is off

	lds	si,cs:LowMemory     ; Compare the 4 words at 0000:0080
	les	di,cs:HighMemory    ;	with the 4 at FFFF:0090

	mov	cx,4
	cld
	repe    cmpsw

	jz	@f
	inc	ax		    ; must be on afterall
@@:
else	;*******************************************************************

	add	byte ptr cs:CmpLoc,08h	; change offset for this compare
	mov	al,byte ptr cs:CmpLoc
	and	ax,78h			; use 0, 8, 10, 18, ... 78, 0, ...
	mov	si,ax
	lea	di,[si+10h]		; offset 1 paragraph

	xor	ax,ax			; ax = ds = 0, es = FFFFh
	mov	ds,ax
	dec	ax
	mov	es,ax
	inc	ax

	mov	cx,4			; match up to 4 words
	cld
	repe    cmpsw

	jz	@f
	inc	ax			; must be on afterall, set ax = 1
@@:
endif	;*******************************************************************

	pop	es
	pop	ds

IA20Exit:
	xor	bl,bl		; return success

	pop	cx
	ret			; Yes, return A20 Disabled

IsA20On	endp


_text	ends
	end



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kdf.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */



	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Definition File
;;
;; This the file header and table pointers ONLY.
;; The actual tables are contained in seperate source files.
;; These are:
;;	     KDFSP.ASM	- Spanish
;;	     KDFPO.ASM	- Portuguese
;;	     KDFGR.ASM	- German
;;	     KDFIT.ASM	- Italian
;;	     KDFFR.ASM	- French
;;	     KDFSG.ASM	- Swiss German
;;	     KDFSF.ASM	- Swiss French
;;	     KDFDK.ASM	- Danish
;;	     KDFUK.ASM	- English
;;	     KDFBE.ASM	- Belgium
;;	     KDFNL.ASM	- Netherlands
;;	     KDFNO.ASM	- Norway
;;	     KDFLA.ASM	- Latin American
;;	     KDFSV.ASM	- SWEDEN
;;	     KDFSU.ASM	- Finland
;;	     Dummy US	- US
;; Linkage Instructions:
;;	The following instructions are contained in KDFLINK.BAT:
;;
;;	LINK KDF+KDFSP+KDFGE+KDFFR+KDFIT+KDFPO+KDFUK+KDFSG+KDFDK+KDFEOF;
;;	EXE2BIN KDF.EXE KEYBOARD.SYS
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; File Header
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DB   0FFh,'KEYB   '                  ;; signature
DB   8 DUP(0)			     ;; reserved
DW   650			     ;; maximum size of Common Xlat Sect
DW   350			     ;; max size of Specific Xlat Sect
DW   400			     ;; max size of State Logic
DD   0				     ;; reserved
DW   17 			     ;; number of languages
DB   'SP'
DW   OFFSET SP_LANG_ENT,0
DB   'PO'
DW   OFFSET PO_LANG_ENT,0
DB   'FR'
DW   OFFSET FR_LANG_ENT,0
DB   'DK'
DW   OFFSET DK_LANG_ENT,0
DB   'SG'
DW   OFFSET SG_LANG_ENT,0
DB   'GR'
DW   OFFSET GE_LANG_ENT,0
DB   'IT'
DW   OFFSET IT_LANG_ENT,0
DB   'UK'
DW   OFFSET UK_LANG_ENT,0
DB   'SF'
DW   OFFSET SF_LANG_ENT,0
DB   'BE'
DW   OFFSET BE_LANG_ENT,0
DB   'NL'
DW   OFFSET NL_LANG_ENT,0
DB   'NO'
DW   OFFSET NO_LANG_ENT,0
DB   'CF'
DW   OFFSET CF_LANG_ENT,0
DB   'SV'
DW   OFFSET SV_LANG_ENT,0
DB   'SU'
DW   OFFSET SV_LANG_ENT,0
DB   'LA'
DW   OFFSET LA_LANG_ENT,0
DB   'US'
DW   OFFSET DUMMY_ENT,0
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; Language Entries
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   EXTRN SP_LOGIC:NEAR		       ;;
   EXTRN SP_437_XLAT:NEAR	       ;;
   EXTRN SP_850_XLAT:NEAR	       ;;
				       ;;
SP_LANG_ENT:			       ;; language entry for SPANISH
  DB   'SP'                            ;;
  DW   0			       ;; reserved
  DW   OFFSET SP_LOGIC,0	       ;; pointer to LANG kb table
  DW   2			       ;; number of code pages
  DW   437			       ;; code page
  DW   OFFSET SP_437_XLAT,0	       ;; table pointer
  DW   850			       ;; code page
  DW   OFFSET SP_850_XLAT,0	       ;; table pointer
				       ;;
;****************************************************************************
   EXTRN PO_LOGIC:NEAR		       ;;
   EXTRN PO_860_XLAT:NEAR	       ;;
   EXTRN PO_850_XLAT:NEAR	       ;;
				       ;;
PO_LANG_ENT:			       ;; language entry for POTUGAL
  DB   'PO'                            ;;
  DW   0			       ;; reserved
  DW   OFFSET PO_LOGIC,0	       ;; pointer to LANG kb table
  DW   2			       ;; number of code pages
  DW   860			       ;; code page
  DW   OFFSET PO_860_XLAT,0	       ;; table pointer
  DW   850			       ;; code page
  DW   OFFSET PO_850_XLAT,0	       ;; table pointer
				       ;;
;*****************************************************************************
    EXTRN FR_LOGIC:NEAR 		;;
    EXTRN FR_437_XLAT:NEAR		;;
    EXTRN FR_850_XLAT:NEAR		;;
					;;
 FR_LANG_ENT:				;; language entry for POTUGAL
   DB	'FR'                            ;;
   DW	0				;; reserved
   DW	OFFSET FR_LOGIC,0		;; pointer to LANG kb table
   DW	2				;; number of code pages
   DW	437				;; code page
   DW	OFFSET FR_437_XLAT,0		;; table pointer
   DW	850				;; code page
   DW	OFFSET FR_850_XLAT,0		;; table pointer
					;;
;*****************************************************************************
   EXTRN DK_LOGIC:NEAR		       ;;
   EXTRN DK_865_XLAT:NEAR	       ;;
   EXTRN DK_850_XLAT:NEAR	       ;;
					;;
 DK_LANG_ENT:				;; language entry for POTUGAL
   DB	'DK'                            ;;
   DW	0				;; reserved
   DW	OFFSET DK_LOGIC,0		;; pointer to LANG kb table
   DW	2				;; number of code pages
   DW	865				;; code page
   DW	OFFSET DK_865_XLAT,0		;; table pointer
   DW	850				;; code page
   DW	OFFSET DK_850_XLAT,0		;; table pointer
					;;
;*****************************************************************************
   EXTRN SG_LOGIC:NEAR		       ;;
   EXTRN SG_437_XLAT:NEAR	       ;;
   EXTRN SG_850_XLAT:NEAR	       ;;
				       ;;
SG_LANG_ENT:			       ;; language entry for POTUGAL
  DB   'SG'                            ;;
  DW   0			       ;; reserved
  DW   OFFSET SG_LOGIC,0	       ;; pointer to LANG kb table
  DW   2			       ;; number of code pages
  DW   437			       ;; code page
  DW   OFFSET SG_437_XLAT,0	       ;; table pointer
  DW   850			       ;; code page
  DW   OFFSET SG_850_XLAT,0	       ;; table pointer
				       ;;
;*****************************************************************************
   EXTRN SF_LOGIC:NEAR		       ;;
   EXTRN SF_437_XLAT:NEAR	       ;;
   EXTRN SF_850_XLAT:NEAR	       ;;
				       ;;
SF_LANG_ENT:			       ;; language entry for SWISS FRENCH
  DB   'SF'                            ;;
  DW   0			       ;; reserved
  DW   OFFSET SF_LOGIC,0	       ;; pointer to LANG kb table
  DW   2			       ;; number of code pages
  DW   437			       ;; code page
  DW   OFFSET SF_437_XLAT,0	       ;; table pointer
  DW   850			       ;; code page
  DW   OFFSET SF_850_XLAT,0	       ;; table pointer
				       ;;
;*****************************************************************************
   EXTRN GE_LOGIC:NEAR		       ;;
   EXTRN GE_437_XLAT:NEAR	       ;;
   EXTRN GE_850_XLAT:NEAR	       ;;
				       ;;
GE_LANG_ENT:			       ;; language entry for POTUGAL
  DB   'GR'                            ;;
  DW   0			       ;; reserved
  DW   OFFSET GE_LOGIC,0	       ;; pointer to LANG kb table
  DW   2			       ;; number of code pages
  DW   437			       ;; code page
  DW   OFFSET GE_437_XLAT,0	       ;; table pointer
  DW   850			       ;; code page
  DW   OFFSET GE_850_XLAT,0	       ;; table pointer
				       ;;
;*****************************************************************************
    EXTRN IT_LOGIC:NEAR 		;;
    EXTRN IT_437_XLAT:NEAR		;;
    EXTRN IT_850_XLAT:NEAR		;;
					;;
 IT_LANG_ENT:				;; language entry for POTUGAL
   DB	'IT'                            ;;
   DW	0				;; reserved
   DW	OFFSET IT_LOGIC,0		;; pointer to LANG kb table
   DW	2				;; number of code pages
   DW	437				;; code page
   DW	OFFSET IT_437_XLAT,0		;; table pointer
   DW	850				;; code page
   DW	OFFSET IT_850_XLAT,0		;; table pointer
					;;
;*****************************************************************************
    EXTRN UK_LOGIC:FAR			;;
    EXTRN UK_437_XLAT:FAR		;;
    EXTRN UK_850_XLAT:FAR		;;
					;;
 UK_LANG_ENT:				;; language entry for POTUGAL
   DB	'UK'                            ;;
   DW	0				;; reserved
   DW	OFFSET UK_LOGIC,0		;; pointer to LANG kb table
   DW	2				;; number of code pages
   DW	437				;; code page
   DW	OFFSET UK_437_XLAT,0		;; table pointer
   DW	850				;; code page
   DW	OFFSET UK_850_XLAT,0		;; table pointer
					;;
;*****************************************************************************
   EXTRN BE_LOGIC:NEAR		       ;;
   EXTRN BE_437_XLAT:NEAR	       ;;
   EXTRN BE_850_XLAT:NEAR	       ;;
				       ;;
BE_LANG_ENT:			       ;; language entry for POTUGAL
  DB   'BE'                            ;;
  DW   0			       ;; reserved
  DW   OFFSET BE_LOGIC,0	       ;; pointer to LANG kb table
  DW   2			       ;; number of code pages
  DW   437			       ;; code page
  DW   OFFSET BE_437_XLAT,0	       ;; table pointer
  DW   850			       ;; code page
  DW   OFFSET BE_850_XLAT,0	       ;; table pointer
					;;
;*****************************************************************************
;*****************************************************************************
     EXTRN NL_LOGIC:NEAR		 ;;
     EXTRN NL_437_XLAT:NEAR		 ;;
     EXTRN NL_850_XLAT:NEAR		 ;;
					 ;;
  NL_LANG_ENT:				 ;; language entry for NETHERLANDS
    DB	 'NL'                            ;;
    DW	 0				 ;; reserved
    DW	 OFFSET NL_LOGIC,0		 ;; pointer to LANG kb table
    DW	 2				 ;; number of code pages
    DW	 437				 ;; code page
    DW	 OFFSET NL_437_XLAT,0		 ;; table pointer
    DW	 850				 ;; code page
    DW	 OFFSET NL_850_XLAT,0		 ;; table pointer
				     ;;
;*****************************************************************************
;*****************************************************************************
     EXTRN NO_LOGIC:NEAR		 ;;
     EXTRN NO_865_XLAT:NEAR		 ;;
     EXTRN NO_850_XLAT:NEAR		 ;;
					 ;;
  NO_LANG_ENT:				 ;; language entry for NORWAY
    DB	 'NO'                            ;;
    DW	 0				 ;; reserved
    DW	 OFFSET NO_LOGIC,0		 ;; pointer to LANG kb table
    DW	 2				 ;; number of code pages
    DW	 865				 ;; code page
    DW	 OFFSET NO_865_XLAT,0		 ;; table pointer
    DW	 850				 ;; code page
    DW	 OFFSET NO_850_XLAT,0		 ;; table pointer
				     ;;
;*****************************************************************************
;*****************************************************************************
     EXTRN SV_LOGIC:NEAR		 ;;
     EXTRN SV_437_XLAT:NEAR		 ;;
     EXTRN SV_850_XLAT:NEAR		 ;;
					 ;;
  SV_LANG_ENT:				 ;; language entry for SWEDEN
    DB	 'SV'                            ;;
    DW	 0				 ;; reserved
    DW	 OFFSET SV_LOGIC,0		 ;; pointer to LANG kb table
    DW	 2				 ;; number of code pages
    DW	 437				 ;; code page
    DW	 OFFSET SV_437_XLAT,0		 ;; table pointer
    DW	 850				 ;; code page
    DW	 OFFSET SV_850_XLAT,0		 ;; table pointer
				     ;;
;*****************************************************************************
;*****************************************************************************
;    EXTRN SU_LOGIC:NEAR		 ;;
;    EXTRN SU_437_XLAT:NEAR		 ;;
;    EXTRN SU_850_XLAT:NEAR		 ;;
;					 ;;
; SU_LANG_ENT:				 ;; language entry for FINLAND
;   DB	 'SU'                            ;;
;   DW	 0				 ;; reserved
;   DW	 OFFSET SU_LOGIC,0		 ;; pointer to LANG kb table
;   DW	 2				 ;; number of code pages
;   DW	 437				 ;; code page
;   DW	 OFFSET SU_437_XLAT,0		 ;; table pointer
;   DW	 850				 ;; code page
;   DW	 OFFSET SU_850_XLAT,0		 ;; table pointer
;				     ;;
;*****************************************************************************
;*****************************************************************************
     EXTRN CF_LOGIC:NEAR		 ;;
     EXTRN CF_863_XLAT:NEAR		 ;;
     EXTRN CF_850_XLAT:NEAR		 ;;
					 ;;
  CF_LANG_ENT:				 ;; language entry for Canadian-French
    DB	 'CF'                            ;;
    DW	 0				 ;; reserved
    DW	 OFFSET CF_LOGIC,0		 ;; pointer to LANG kb table
    DW	 2				 ;; number of code pages
    DW	 863				 ;; code page
    DW	 OFFSET CF_863_XLAT,0		 ;; table pointer
    DW	 850				 ;; code page
    DW	 OFFSET CF_850_XLAT,0		 ;; table pointer
				     ;;
;*****************************************************************************
     EXTRN LA_LOGIC:NEAR		 ;;
     EXTRN LA_850_XLAT:NEAR		 ;;
     EXTRN LA_437_XLAT:NEAR		 ;;
					 ;;
  LA_LANG_ENT:				 ;; language entry for Canadian-French
    DB	 'LA'                            ;;
    DW	 0				 ;; reserved
    DW	 OFFSET LA_LOGIC,0		 ;; pointer to LANG kb table
    DW	 2				 ;; number of code pages
    DW	 850				 ;; code page
    DW	 OFFSET LA_850_XLAT,0		 ;; table pointer
    DW	 437				 ;; code page
    DW	 OFFSET LA_437_XLAT,0		 ;; table pointer
				     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DUMMY_ENT:			       ;; language entry
  DB   'XX'                            ;;
  DW   0			       ;; reserved
  DW   OFFSET DUMMY_LOGIC,0	       ;; pointer to LANG kb table
  DW   5			       ;; number of code pages
  DW   437			       ;; code page
  DW   OFFSET DUMMY_XLAT_437,0	       ;; table pointer
  DW   850			       ;; code page
  DW   OFFSET DUMMY_XLAT_850,0	       ;; table pointer
  DW   860			       ;; code page
  DW   OFFSET DUMMY_XLAT_860,0	       ;; table pointer
  DW   863			       ;; code page
  DW   OFFSET DUMMY_XLAT_863,0	       ;; table pointer
  DW   865			       ;; code page
  DW   OFFSET DUMMY_XLAT_865,0	       ;; table pointer
				       ;;
DUMMY_LOGIC:			       ;;
   DW  LOGIC_END-$		       ;; length
   DW  0			       ;; special features
   DB  92H,0,0			       ;; EXIT_STATE_LOGIC_COMMAND
LOGIC_END:			       ;;
				       ;;
DUMMY_XLAT_437: 		       ;;
   DW	  6			       ;; length of section
   DW	  437			       ;; code page
   DW	  0			       ;; LAST STATE
				       ;;
DUMMY_XLAT_850: 		       ;;
   DW	  6			       ;; length of section
   DW	  850			       ;; code page
   DW	  0			       ;; LAST STATE
				       ;;
DUMMY_XLAT_860: 		       ;;
   DW	  6			       ;; length of section
   DW	  860			       ;; code page
   DW	  0			       ;; LAST STATE
				       ;;
DUMMY_XLAT_865: 		       ;;
   DW	  6			       ;; length of section
   DW	  865			       ;; code page
   DW	  0			       ;; LAST STATE
				       ;;
DUMMY_XLAT_863: 		       ;;
   DW	  6			       ;; length of section
   DW	  863			       ;; code page
   DW	  0			       ;; LAST STATE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;*****************************************************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kdfbe.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; ACUTE lc y added


; ****** CNS 12/18
; ****** CNS 01/21 NUM PAD
	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Belgium.
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;	       NICK SAVAGE  - IBM Corp.
;; Modded from French - DTF 11-Sep-86
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC BE_LOGIC 	       ;;
	PUBLIC BE_437_XLAT	       ;;
	PUBLIC BE_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; BE State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
BE_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  TYPEWRITER_CAPS_LK	       ;; special features
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
     IFF CAPS_STATE
	 SET_FLAG DEAD_UPPER
     ELSEF
      IFF EITHER_SHIFT		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
     ENDIFF
   ELSEF			       ;;
      IFF EITHER_SHIFT,NOT	       ;;
	IFKBD XT_KB+AT_KB
	  IFF EITHER_CTL		;;
	  ANDF ALT_SHIFT		;;
	    SET_FLAG DEAD_THIRD        ;;
	  ENDIFF			;;
	ELSEF
	 IFF R_ALT_SHIFT	       ;;
	 ANDF EITHER_CTL,NOT	       ;;
	 ANDF LC_E0,NOT 	       ;;
	    SET_FLAG DEAD_THIRD        ;;
	 ENDIFF 		       ;;
	ENDIFF
       ENDIFF
   ENDIFF			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO TILDE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
TILDE_PROC:			       ;;
				       ;;
   IFF TILDE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT TILDE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_TILDE:			       ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;***************************
NON_DEAD:			       ;;
;ADDED FOR DIVIDE SIGN		       ;;
    IFKBD G_KB+P12_KB			;; Avoid accidentally translating
    ANDF LC_E0				;;  the "/" on the numeric pad of the
      IFF EITHER_CTL,NOT
      ANDF EITHER_ALT,NOT
	XLATT DIVIDE_SIGN	       ;;
      ENDIFF
      EXIT_STATE_LOGIC		     ;;
    ENDIFF			       ;;
;BD END OF ADDITION
;****************************
;NON_DEAD:				;;
;					;;
;  IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
;  ANDF LC_E0			       ;;  the "/" on the numeric pad of the
;     EXIT_STATE_LOGIC		       ;;   G keyboard
;  ENDIFF			       ;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
      IFF EITHER_SHIFT		       ;;
;******************************************
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
;*******************************************
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	      XLATT NON_ALPHA_LOWER    ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	      XLATT NON_ALPHA_UPPER    ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
;******************************************
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
;******************************************
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
      XLATT NON_ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	     XLATT NON_ALPHA_LOWER     ;;
	  ENDIFF		       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_SHIFT,NOT	       ;;
	  IFKBD XT_KB+AT_KB	 ;;
	      IFF  EITHER_CTL	       ;;
	      ANDF ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ELSEF 		       ;;
	      IFF EITHER_CTL,NOT       ;;
	      ANDF R_ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ENDIFF		       ;;
      IFKBD AT_KB+XT_KB 	 ;;
	IFF EITHER_CTL		       ;;
	ANDF ALT_SHIFT		       ;;
	  XLATT ALT_CASE	       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
      IFKBD G_KB+P12_KB 	       ;;
	IFF EITHER_CTL		       ;;
	ANDF ALT_SHIFT		       ;;
	  IFF R_ALT_SHIFT,NOT		  ;;
	    XLATT ALT_CASE		  ;;
	  ENDIFF			  ;;
	ENDIFF				  ;;
      ENDIFF				  ;;
     ENDIFF				  ;;
   ENDIFF				  ;;
;IFF EITHER_SHIFT,NOT			  ;;
   IFKBD AT_KB+XT_KB		    ;;
     IFF EITHER_CTL,NOT 		  ;;
       IFF ALT_SHIFT			  ;; ALT - case
	 XLATT ALT_CASE 		  ;;
       ENDIFF				  ;;
     ELSEF				  ;;
	 XLATT CTRL_CASE		  ;;
     ENDIFF				  ;;
   ENDIFF				  ;;
					  ;;
   IFKBD G_KB+P12_KB			  ;;
     IFF EITHER_CTL,NOT 		  ;;
       IFF ALT_SHIFT			  ;; ALT - case
       ANDF R_ALT_SHIFT,NOT		  ;;
	 XLATT ALT_CASE 		  ;;
       ENDIFF				  ;;
     ELSEF				  ;;
       IFF EITHER_ALT,NOT		  ;;
	 XLATT CTRL_CASE		  ;;
       ENDIFF				  ;;
     ENDIFF				  ;;
     IFF EITHER_CTL			  ;;
     ANDF ALT_SHIFT			  ;;
     ANDF R_ALT_SHIFT,NOT		  ;;
	XLATT ALT_CASE			  ;;
     ENDIFF				  ;;
   ENDIFF				  ;;
					  ;;
   EXIT_STATE_LOGIC			  ;;
					  ;;
LOGIC_END:				  ;;
					  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; BE Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC BE_COMMON_XLAT		       ;;
BE_COMMON_XLAT: 		       ;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: G + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_ALT_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 8			       ;; Number of entries
   DB	 12,-1,-1		       ;;
   DB	 13,0,82H		       ;;
   DB	 16,0,1EH		       ;; A
   DB	 17,0,2CH		       ;; Z
   DB	 30,0,10H		       ;; Q
   DB	 39,0,32H		       ;; M
   DB	 44,0,11H		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_ALT_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_ALT_K1_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 10			       ;; Number of entries
   DB	 12,-1,-1		       ;;
   DB	 13,31,13		       ;;
   DB	 16,01,16		       ;; A
   DB	 17,26,17		       ;; Z
   DB	 30,17,30		       ;; Q
   DB	 39,13,39		       ;; M
   DB	 43,-1,-1		       ;; \
   DB	 44,23,44		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
   DB	 86,28,86		       ;;
COM_CTRL_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: AT + XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K2_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 AT_KB+XT_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_ALT_K2_T2_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 6			       ;; Number of entries
;  DB	 12,-1,-1		       ;; invalid key U.S. alt -
;  DB	 13,0,82H		       ;; alt - (minus sign)
;  DB	 53,0,83H		       ;; alt = (equal sign)
   DB	 16,0,1EH		       ;; A
   DB	 17,0,2CH		       ;; Z
   DB	 30,0,10H		       ;; Q
   DB	 39,0,32H		       ;; M
   DB	 44,0,11H		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_ALT_K2_T2_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_ALT_K2_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K2_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_K2_T2_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 11				;; Number of entries
   DB	 12,-1,-1		       ;; invalid U.S. -
   DB	 43,-1,-1		       ;; invalid U.S. \
   DB	 41,28,41		       ;; valid ctl + \
   DB	 07,30,07		       ;; ctl + number six key
   DB	 13,31,13		       ;; ctl - or _
   DB	 16,01,16		       ;; A
   DB	 17,26,17		       ;; Z
   DB	 30,17,30		       ;; Q
   DB	 39,13,39		       ;; M
   DB	 44,23,44		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_CTRL_K2_T2_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_K2_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K3_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 AT_KB+XT_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_K3_T3_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 11			       ;; Number of entries
   DB	 12,-1,-1		       ;;
   DB	 43,-1,-1		       ;;
   DB	 43,28,43		       ;; valid ctl + \
   DB	 07,30,07		       ;; ctl + number six key
   DB	 13,31,13		       ;; ctl - or _
   DB	 16,01,16		       ;; A
   DB	 17,26,17		       ;; Z
   DB	 30,17,30		       ;; Q
   DB	 39,13,39		       ;; M
   DB	 44,23,44		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_CTRL_K3_T3_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_K3_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_LO_END-$	       ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  CIRCUMFLEX		       ;; flag bit to set
				       ;;
				       ;;
COM_DK_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_UP_END-$	       ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  DIARESIS		       ;; flag bit to set
				       ;;
COM_DK_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: G, P12,AT
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_TH_END-$	       ;; length of state section
   DB	 DEAD_THIRD		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB	       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 3			       ;; number of entries
   DB	40			       ;;
   FLAG ACUTE			       ;;
   DB	43			       ;;
   FLAG GRAVE			       ;;
   DB	53			       ;;
   FLAG TILDE			       ;;
				       ;;
COM_DK_TH_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_TH_K1_END-$	       ;; length of state section
   DB	 DEAD_THIRD		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 3			       ;; number of entries
   DB	40			       ;;
   FLAG ACUTE			       ;;
   DB	41			       ;;
   FLAG GRAVE			       ;;
   DB	53			       ;;
   FLAG TILDE			       ;;
				       ;;
COM_DK_TH_K1_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;**************************************************** CODE eliminated**********
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	      NUM PAD altered  ********
;; CODE PAGE: 850				      CNS engraved "," out
;; STATE: Numeric Pad - Divide Sign
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					;;
;; DW	 CP850_DIVID_END-$	       ;; length of state section
;; DB	 DIVIDE_SIGN		       ;; State ID
;; DW	 G_KB+P12_KB		       ;; Keyboard Type
;; DB	 -1,-1			       ;; error character = standalone accent
;;				       ;;
;; DW	 CP850_DIVID_T1_END-$	       ;; Size of xlat table
;; DB	 TYPE_2_TAB		       ;; xlat options:
;; DB	 2			       ;; number of scans
;; DB	 0E0H,',',0E0H                ;; DIVIDE SIGN
;; DB	 51,',',0E0H                  ;;
;; CP850_DIVID_T1_END:			  ;;
;;					  ;;
;;    DW    0				  ;; Size of xlat table - null table
;;					  ;;
;; CP850_DIVID_END:			  ;;
;;					  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Numeric Key Pad - Multiplication
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;				       ;;
;; DW	 CP850_PAD_K1_END-$	       ;; length of state section
;; DB	 NUMERIC_PAD		       ;; State ID
;; DW	 P12_KB 		       ;; Keyboard Type
;; DB	 -1,-1			       ;; Buffer entry for error character
;;				       ;;
;; DW	 CP850_PAD_K1_T1_END-$	       ;; Size of xlat table
;; DB	 STANDARD_TABLE 	       ;; xlat options:
;; DB	 1			       ;; number of entries
;; DB	 51,',' ; (removed *** CNS ****)  ;; MULTIPLICATION SIGN
;;  CP850_PAD_K1_T1_END:		   ;;
;;					   ;;
;;     DW    0				   ;; Size of xlat table - null table
;;					   ;;
;;  CP850_PAD_K1_END:			   ;;
;;					   ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;*********************************************************
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_LO_END-$	       ;; length of state section
   DB	 ALPHA_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 16,'a'                        ;; small a
   DB	 17,'z'                        ;; small z
   DB	 30,'q'                        ;; small q
   DB	 39,'m'                        ;; small m
   DB	 44,'w'                        ;; small w
COM_AL_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_UP_END-$	       ;; length of state section
   DB	 ALPHA_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 16,'A'                        ;; caps  A
   DB	 17,'Z'                        ;; caps  Z
   DB	 30,'Q'                        ;; caps  Q
   DB	 39,'M'                        ;; caps  M
   DB	 44,'W'                        ;; caps  W
COM_AL_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_UP_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	 41,""                        ;; superscript 2
   DB	  2,"&"                        ;;
   DB	  3,""                        ;; acute - e
   DB	  4,'"'                        ;;
   DB	  5,"'"                        ;;
   DB	  6,"("                        ;;
   DB	  8,""                        ;; grave - e
   DB	  9,"!"                        ;;
   DB	 10,""                        ;; c - cedilla small
   DB	 11,""                        ;;
   DB	 12,")"                        ;;
   DB	 13,"-"                        ;;
   DB	 27,"$"                        ;;
   DB	 40,""                        ;; grave - u
   DB	 43,0E6H		       ;; mu
   DB	 86,'<'                        ;;
   DB	 50,','                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'='                        ;;
COM_NA_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES:AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K2_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_T1_K2_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 19			       ;; number of entries
   DB	 41,"<"                        ;;
   DB	  2,"&"                        ;;
   DB	  3,""                        ;; acute - e
   DB	  4,'"'                        ;;
   DB	  5,"'"                        ;;
   DB	  6,"("                        ;;
   DB	  8,""                        ;; grave - e
   DB	  9,"!"                        ;;
   DB	 10,""                        ;; c - cedilla small
   DB	 11,""                        ;;
   DB	 12,")"                        ;;
   DB	 13,"-"                        ;;
   DB	 27,"$"                        ;;
   DB	 40,""                        ;; grave - u
   DB	 43,0E6H		       ;; mu
   DB	 50,','                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'='                        ;;
COM_NA_LO_T1_K2_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K2_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 19			       ;; number of entries
   DB	  2,"&"                        ;;
   DB	  3,""                        ;; acute - e
   DB	  4,'"'                        ;;
   DB	  5,"'"                        ;;
   DB	  6,"("                        ;;
   DB	  8,""                        ;;
   DB	  9,"!"                        ;;
   DB	 10,""                        ;; c - cedilla small
   DB	 11,""                        ;;
   DB	 12,")"                        ;;
   DB	 13,"-"                        ;;
   DB	 27,"$"                        ;;
   DB	 40,""                        ;; grave - u
   DB	 41,0E6H		       ;; mu
   DB	 43,'<'                        ;;
   DB	 50,','                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'='                        ;;
COM_NA_LO_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	  2,'1'                        ;;
   DB	  3,'2'                        ;;
   DB	  4,'3'                        ;;
   DB	  5,'4'                        ;;
   DB	  6,'5'                        ;;
   DB	  7,'6'                        ;;
   DB	  8,'7'                        ;;
   DB	  9,'8'                        ;;
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0F8H		       ;; degree symbol
   DB	 13,"_"                        ;;
   DB	 27,"*"                        ;;
   DB	 40,'%'                        ;;
   DB	 43,''                        ;;
   DB	 86,'>'                        ;;
   DB	 50,'?'                        ;;
   DB	 51,'.'                        ;;
   DB	 52,'/'                        ;;
   DB	 53,'+'                        ;;
COM_NA_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_END:			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	 41,''                        ;;
   DB	  2,'1'                        ;;
   DB	  3,'2'                        ;;
   DB	  4,'3'                        ;;
   DB	  5,'4'                        ;;
   DB	  6,'5'                        ;;
   DB	  7,'6'                        ;;
   DB	  8,'7'                        ;;
   DB	  9,'8'                        ;;
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0F8H		       ;; degree symbol
   DB	 13,"_"                        ;;
   DB	 27,"*"                        ;;
   DB	 40,'%'                        ;;
   DB	 43,'>'                        ;;
   DB	 50,'?'                        ;;
   DB	 51,'.'                        ;;
   DB	 52,'/'                        ;;
   DB	 53,'+'                        ;;
COM_NA_UP_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K2_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	 41,'>'                        ;;
   DB	  2,'1'                        ;;
   DB	  3,'2'                        ;;
   DB	  4,'3'                        ;;
   DB	  5,'4'                        ;;
   DB	  6,'5'                        ;;
   DB	  7,'6'                        ;;
   DB	  8,'7'                        ;;
   DB	  9,'8'                        ;;
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0F8H		       ;; degree symbol
   DB	 13,"_"                        ;;
   DB	 27,"*"                        ;;
   DB	 40,'%'                        ;;
   DB	 43,''                        ;;
   DB	 50,'?'                        ;;
   DB	 51,'.'                        ;;
   DB	 52,'/'                        ;;
   DB	 53,'+'                        ;;
COM_NA_UP_T1_K2_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  9			       ;; number of entries
   DB	  2,"|"                        ;;
   DB	  3,'@'                        ;;
   DB	  4,'#'                        ;;
   DB	  7,'^'                        ;;
   DB	 10,'{'                        ;;
   DB	 11,'}'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 86,'\'                        ;;
COM_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  9			       ;; number of entries
   DB	  2,"|"                        ;;
   DB	  3,'@'                        ;;
   DB	  4,'#'                        ;;
   DB	  7,'^'                        ;;
   DB	 10,'{'                        ;;
   DB	 11,'}'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 43,'\'                        ;;
COM_THIRD_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K2_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K2_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  9			       ;; number of entries
   DB	  2,"|"                        ;;
   DB	  3,'@'                        ;;
   DB	  4,'#'                        ;;
   DB	  7,'^'                        ;;
   DB	 10,'{'                        ;;
   DB	 11,'}'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 41,'\'                        ;;
COM_THIRD_T1_K2_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K2_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES: ALL
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 COM_GR_LO_END-$		 ;; length of state section
   DB	 GRAVE_LOWER			 ;; State ID
   DW	 ANY_KB 			 ;; Keyboard Type
   DB	 96,0				 ;; error character = standalone accent
					 ;;
   DW	 COM_GR_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 5				 ;; number of scans
   DB	 18,''                          ;; scan code,ASCII - e
   DB	 16,''                          ;; scan code,ASCII - a
   DB	 24,''                          ;; scan code,ASCII - o
   DB	 22,''                          ;; scan code,ASCII - u
   DB	 23,''                          ;; scan code,ASCII - i
COM_GR_LO_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
COM_GR_LO_END:				 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_UP_END-$	       ;; length of state section
   DB	 GRAVE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 0			       ;; number of scans
COM_GR_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_UP_END:			       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 COM_GR_SP_END-$		 ;; length of state section
   DB	 GRAVE_SPACE			 ;; State ID
   DW	 ANY_KB 			 ;; Keyboard Type
   DB	 96,0				 ;; error character = standalone accent
					 ;;
   DW	 COM_GR_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 57,96				 ;; STANDALONE GRAVE
COM_GR_SP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
COM_GR_SP_END:				 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_UP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_UPPER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 0			       ;; number of scans
COM_CI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_UP_END:			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,94			       ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 COM_TI_SP_END-$		 ;; length of state section
   DB	 TILDE_SPACE			 ;; State ID
   DW	 ANY_KB 			 ;; Keyboard Type
   DB	 126,0				 ;; error character = standalone accent
					 ;;
   DW	 COM_TI_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 57,126 			 ;; STANDALONE TIDLE
COM_TI_SP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
COM_TI_SP_END:				 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; BE Specific Translate Section for 437
;;
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC BE_437_XLAT		       ;;
BE_437_XLAT:			       ;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_LO_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP437_NA_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of scans
   DB	7,15H			       ;; Section Symbol
CP437_NA_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_UP_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP437_NA_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	41,00H			       ;; 3 Superscript
CP437_NA_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_LO_END-$	       ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 16,''                        ;; a acute
   DB	 18,''                        ;; e acute
   DB	 23,''                        ;; i acute
   DB	 24,''                        ;; o acute
   DB	 22,''                        ;; u acute
CP437_AC_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP437_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER			 ;; State ID
   DW	 ANY_KB 			 ;; Keyboard Type
   DB	 39,0				 ;; error character = standalone accent
					 ;;
   DW	 CP437_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 18,''                          ;; scan code,ASCII - e
CP437_AC_UP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP437_AC_UP_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP437_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE			 ;; State ID
   DW	 ANY_KB 			 ;; Keyboard Type
   DB	 39,0				 ;; error character = standalone accent
					 ;;
   DW	 CP437_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 57,39				 ;; scan code,ASCII - SPACE
CP437_AC_SP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP437_AC_SP_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Tilde Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP437_TI_LO_END-$		 ;; length of state section
   DB	 TILDE_LOWER			 ;; State ID
   DW	 ANY_KB 			 ;; Keyboard Type
   DB	 126,0				 ;; error character = standalone accent
					 ;;
   DW	 CP437_TI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 49,164 			 ;; scan code,ASCII - n
CP437_TI_LO_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP437_TI_LO_END:			 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Tilde Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_TI_UP_END-$	       ;; length of state section
   DB	 TILDE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 126,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_TI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 49,165 		       ;; scan code,ASCII - N
CP437_TI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_TI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_DI_LO_END-$	       ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 0FEH,0 		       ;; error character = standalone accent
				       ;;
   DW	 CP437_DI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 21,''                        ;; scan code,ASCII - y
CP437_DI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_DI_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_DI_UP_END-$	       ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 0FEH,0 		       ;; error character = standalone accent
				       ;;
   DW	 CP437_DI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
CP437_DI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_DI_UP_END:		       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				       ;;
;  DW	 CP437_DI_SP_END-$	       ;; length of state section
;  DB	 DIARESIS_SPACE 	       ;; State ID
;  DW	 ANY_KB 		       ;; Keyboard Type
;  DB	 0FEH,0 		       ;; error character = standalone accent
;				       ;;
;  DW	 CP437_DI_SP_T1_END-$	       ;; Size of xlat table
;  DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;  DB	 1			       ;; number of scans
;  DB	 57,0FEH		       ;; error character = standalone accent
;CP437_DI_SP_T1_END:		       ;;
;				       ;;
;  DW	 0			       ;; Size of xlat table - null table
;CP437_DI_SP_END:		       ;; length of state section
;				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; BE Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC BE_850_XLAT		       ;;
BE_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_LO_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP850_NA_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 7,0F5H 		       ;; Section symbol - 
CP850_NA_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_LO_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_UP_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP850_NA_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of scans
   DB	41,0FCH 		       ;; 3 Superscript
CP850_NA_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Third Shift
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP850_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 0			       ;; number of scans
CP850_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_THIRD_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Tilde Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP850_TI_LO_END-$		 ;; length of state section
   DB	 TILDE_LOWER			 ;; State ID
   DW	 ANY_KB 			 ;; Keyboard Type
   DB	 126,0				 ;; error character = standalone accent
					 ;;
   DW	 CP850_TI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 3				 ;; number of scans
   DB	 49,164 			 ;; scan code,ASCII - n
   DB	 16,0C6H			 ;;		      a
   DB  24,0E4H			 ;;		      o
CP850_TI_LO_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP850_TI_LO_END:			 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Tilde Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_TI_UP_END-$	       ;; length of state section
   DB	 TILDE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 126,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_TI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 49,165 		       ;; scan code,ASCII - N
   DB	 16,0C7H		       ;;		    A
   DB	 24,0E5H		       ;;		    O
CP850_TI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_TI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_LO_END-$	       ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 0EFH,0 		       ;; error character = standalone accent
   DW	 CP850_AC_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 16,''                        ;; a acute
   DB	 18,''                        ;; e acute
   DB	 23,''                        ;; i acute
   DB	 24,''                        ;; o acute
   DB	 22,''                        ;; u acute
   DB	 21,0ECH		       ;; y acute  ADDED 12/16 CNS **********
CP850_AC_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP850_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER			 ;; State ID
   DW	 ANY_KB 			 ;; Keyboard Type
   DB	 0EFH,0 			 ;; error character = standalone accent
   DW	 CP850_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 6				 ;; number of scans
   DB	 16,0B5H			 ;;    A acute
   DB	 18,090H			 ;;    E acute
   DB	 23,0D6H			 ;;    I acute
   DB	 24,0E0H			 ;;    O acute
   DB	 22,0E9H			 ;;    U acute
   DB	 21,0EDH			 ;;    Y acute
CP850_AC_UP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP850_AC_UP_END:			 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP850_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE			 ;; State ID
   DW	 ANY_KB 			 ;; Keyboard Type
   DB	 0EFH,0 			 ;; error character = standalone accent
					 ;;
   DW	 CP850_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 57,0EFH			 ;; scan code,ASCII - SPACE
CP850_AC_SP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP850_AC_SP_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_LO_END-$	       ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 21,''                        ;; scan code,ASCII - y
CP850_DI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_LO_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					 ;;
;; CODE PAGE: 850
;; STATE: Diaresis Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP850_DI_UP_END-$		 ;; length of state section
   DB	 DIARESIS_UPPER 		 ;; State ID
   DW	 ANY_KB 			 ;; Keyboard Type
   DB	 249,0				 ;; error character = standalone accent
					 ;;
   DW	 CP850_DI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 5				 ;; number of scans
   DB	 16,8EH 			 ;;    A di
   DB	 18,0D3H			 ;;    E diaeresis
   DB	 23,0D8H			 ;;    I diaeresis
   DB	 24,99H 			 ;;    O di
   DB	 22,9AH 			 ;;    U di
CP850_DI_UP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP850_DI_UP_END:			 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Diaeresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP850_DI_SP_END-$		 ;; length of state section
   DB	 DIARESIS_SPACE 		 ;; State ID
   DW	 ANY_KB 			 ;; Keyboard Type
   DB	 0FEH,0 			 ;; error character = standalone accent
					 ;;
   DW	 CP850_DI_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 57,0F9H			 ;; scan code,ASCII - SPACE
CP850_DI_SP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP850_DI_SP_END:			 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Upper
;; KEYBOARD TYPES: ALL
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP850_GR_UP_END-$		 ;; length of state section
   DB	 GRAVE_UPPER			 ;; State ID
   DW	 ANY_KB 			 ;; Keyboard Type
   DB	 96,0				 ;; error character = standalone accent
					 ;;
   DW	 CP850_GR_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 5				 ;; number of scans
   DB	 16,0B7H			 ;;    A grave
   DB	 18,0D4H			 ;;    E grave
   DB	 23,0DEH			 ;;    I grave
   DB	 24,0E3H			 ;;    O grave
   DB	 22,0EBH			 ;;    U grave
CP850_GR_UP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP850_GR_UP_END:			 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP850_CI_UP_END-$		 ;; length of state section
   DB	 CIRCUMFLEX_UPPER		 ;; State ID
   DW	 ANY_KB 			 ;;
   DB	 94,0				 ;; error character = standalone accent
					 ;;
   DW	 CP850_CI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 5				 ;; number of scans
   DB	 16,0B6H			 ;;    A circumflex
   DB	 18,0D2H			 ;;    E circumflex
   DB	 23,0D7H			 ;;    I circumflex
   DB	 24,0E2H			 ;;    O circumflex
   DB	 22,0EAH			 ;;    U circumflex
CP850_CI_UP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP850_CI_UP_END:			 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
     DW    0				 ;; LAST STATE
					 ;;
CP850_XLAT_END: 			 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
CODE	 ENDS				 ;;
	 END				 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\himem\himem1.asm ===
;/*
; *                      Microsoft Confidential
; *			 Copyright (C) Microsoft Corporation 1988-1992
; *                      All Rights Reserved.
; */
	page	95,160
	title	himem1 - A20 Handler stuff

	.xlist
	include	himem.inc
	.list

	public	A20Handler
	extrn	ATA20Delay:byte
	extrn	InstldA20HndlrN:byte
	extrn	fQuiet:byte
	extrn	fCPUClock:byte
	extrn	fA20Check:byte
	extrn	pPPFIRET:word
	extrn	OldStackSeg:word
	extrn	f000:word
	extrn	MemCorr:word
	extrn	MachineNum:word
	extrn	TopOfTextSeg:word
	extrn	lpExtA20Handler:dword

	extrn	IsA20On:near
	extrn	DispInfoMsg:near
	extrn	DispInfoChar:near

	extrn	InsExtA20Msg:byte
	extrn	InsA20Msg:byte, InsA20EndMsg:byte, NoA20HandlerMsg:byte

	extrn	AltName1:byte, AltName2:byte, AltName3:byte, AltName4:byte
	extrn	AltName5:byte, AltName6:byte, AltName7:byte, AltName8:byte
	extrn	AltName9:byte, AltName10:byte,AltName11:byte,AltName12:byte
	extrn	AltName13:byte, AltName14:byte, AltName15:byte
	extrn	AltName16:byte, ALtName17:byte

; Define a direct call to the Phoenix Cascade BIOS for A20 handling

PTL_Seg	segment at 0f000h
	assume	cs:PTL_Seg
	org	0ff82h
PTL_A20_Bios_Entry	proc	far
PTL_A20_Bios_Entry	endp
PTL_Seg	ends

	assume	cs:_text,ds:nothing

;*--------------------------------------------------------------------------*
;*									    *
;* A20 Handler Section: 						    *
;*									    *
;* The Init code copies the proper A20 Handler in place.		    *
;*									    *
;* NOTE: the A20 handler may be called from the Int 15h hook which does     *
;*	 not set ds = _text.  DO NOT ASSUME DS == _TEXT!		    *
;*									    *
;*--------------------------------------------------------------------------*

A20Handler:

;*** A20 Handler is installed HERE! ***

TempA20Handler	dw	?	; address of A20 hander during installation

;****************************************************************************
;*									    *
;* A20 Handler Section: 						    *
;*									    *
;* The Init code copies the proper A20 Handler into place here.		    *
;*									    *
;* NOTE: A20 HANDLERS MUST ONLY HAVE RELATIVE JUMPS!  HOWEVER ANY CALLS TO  *
;*	 FUNCTIONS OUTSIDE OF THE HANDLER MUST BE NON-RELATIVE!		    *
;*									    *
;****************************************************************************

;*----------------------------------------------------------------------*
;*									*
;*  AT_A20Handler -					HARDWARE DEP.   *
;*									*
;*	Enable/Disable the A20 line on non-PS/2 machines		*
;*									*
;*  ARGS:   AX = 0 for Disable, 1 for Enable				*
;*  RETS:   AX = 1 for success, 0 otherwise				*
;*  REGS:   AX, CX and Flags clobbered					*
;*									*
;*----------------------------------------------------------------------*

NUM_ALT_A20	equ	2	; # Alternative delay methods supported

AT_A20Handler proc	near

; This entry point attempts to preserve the current CPU clock rate by
; maintaining the current value of the "unused" bits in the keyboard
; controller output port.

AT_A20CPUClock	label	near

	push	ax		; Save enable/disable parameter

	in	al,64h		; Ensure output buffer is empty
	test	al,1
	jz	AAHOutBufFree
	jmp	short $+2
	in	al,60h
AAHOutBufFree:

	call	Sync8042	; Make sure the Keyboard Controller is Ready
	jnz	AAHErr_pop

	mov	al,0D0h 	; Send D0h command (read output port)
	out	64h,al
	call	Sync8042
	jnz	AAHErr_pop

	call	AAHFullOutBuf	; Wait for data to appear
	jz	AAHErr_pop

	in	al,60h		; Read output port value

	mov	ah,0Ch		; Only want to keep the "unused" bits
	and	ah,al
	or	ah,0D1h 	; Assume disabling

	pop	cx		; Recover enable/disable parameter
	jcxz	AAHSetA20_1
	or	ah,02h		; Assumed wrong, actually enabling
	jmp	short AAHSetA20_1


; Routine to wait for 8042 output buffer to contain data.  Only needed by the
; CPU clock code, so it's stuck here before the 'normal' AT handler.

AAHFullOutBuf:
	mov	cx,12
AAH_FOB_1:
	push	cx
	xor	cx,cx
AAH_FOB_2:
	jmp	short $+2
	in	al,64h
	test	al,1
	loopz	AAH_FOB_2
	pop	cx
	loopz	AAH_FOB_1
	ret

AAHErr_pop:
	pop	ax		; Clear stack
	jmp	short AAHErr


; This is the entry point for the "normal" AT style A20 handler that does
; not worry about changing the CPU clock rate.

AT_A20Normal	label	near

	or	ax,ax
	mov	ah,0DFh 	; Assume enabling
	jnz	AAHSetA20
	mov	ah,0DDh 	; Actually disabling...

AAHSetA20:
	call	Sync8042	; Make sure the Keyboard Controller is Ready
	jnz     AAHErr

AAHSetA20_1:
	mov	al,0D1h 	; Send D1h (write output port)
	out	64h,al
	call    Sync8042
	jnz     AAHErr

	mov	al,ah		; Send enable/disable command
	out	60h,al
	call    Sync8042
	jnz	AAHErr

; Delay while waiting for the A20 line to settle--there are several methods
; to do this--the variable ATA20Delay indicates which one to use...
;
;	0 = output null command to 8042
;	1 = no delay at all
;	2 = delay on ram refresh bit toggle

	.errnz	NUM_ALT_A20 - 2 ; code below assumes max value of 2

	xor	cx,cx
	mov	cl,ATA20Delay
	jcxz	AAHDelay0
	dec	cx
	jcxz	AAHDelay1
	jmp	short AAHDelay2

; A20 Delay method 0 -- method used by original IBM PC/AT

AAHDelay0:
	mov	al,0FFh		; Send FFh (Pulse Output Port NULL)
	out	64h,al
	call    Sync8042
	jnz	AAHErr
	jmp	short AAHExit

; A20 Delay method 2

AAHDelay2:
	mov	cx,2		; Implement a delay by waiting for the
AAHWaitRam:			;   ram refresh bit to change state twice.
	jmp	short $+2	;   A long delay used by a few machines.
	in	al,61h
	test	al,10h
	jz	AAHWaitRam
@@:	jmp	short $+2
	in	al,61h
	test	al,10h
	jnz	@b
	loop	AAHWaitRam

AAHDelay1:			; Delay method 1 is actually no delay
AAHExit:
	mov	ax,1		; Successful...
	ret

AAHErr:
	xor	ax,ax		; Failure status
	ret

AT_A20Handler endp


Sync8042    proc    near

	xor	cx,cx
S8InSync:
	jmp	short $+2
	in	al,64h
	and	al,2
	loopnz  S8InSync
	ret

Sync8042    endp

EndAT_A20Handler:


;*----------------------------------------------------------------------*
;*									*
;*  Phoenix Cascade BIOS A20 Handler -			HARDWARE DEP.   *
;*									*
;*	Enable/Disable the A20 line on Phoenix Cascade BIOS		*
;*									*
;*  ARGS:   AX = 0 for Disable, 1 for Enable, 2 for On/Off check	*
;*  RETS:   AX = 1 for success, 0 otherwise				*
;*  REGS:   AX, CX and Flags clobbered					*
;*									*
;*----------------------------------------------------------------------*


PTL_A20_DisableFunc	equ 800h	; call to disable A20
PTL_A20_EnableFunc	equ 801h	; call to enable A20
PTL_A20_InquireFunc	equ 802h	; call to enquire about A20 status

PTL_String_Offset	equ 4		; offset of "PTL" in Phoenix extension
PTL_Feature1		equ 3		; offset from PTL to Feature Byte 1
PTL_A20Bit		equ 80h 	; Bit for A20 support in Feature Byte 1

PTL_CASCADE_A20Handler proc	near

	cmp	ax,1
	jz	PTLEnable		; 1 == Enable
	jb	PTLDisable		; 0 == Disable
					; 2 == On/Off Check
	mov	ax,PTL_A20_InquireFunc	; Inquire status
	call	PTL_A20_Bios_Entry
	or	ah,ah			; on or off?
	jz	PTLErr			; returns with ax = 0 (off)
	jmp	short PTLExit		; returns with ax = 1 (on)

PTLEnable:
	mov	ax,PTL_A20_EnableFunc	; call A20 enable function
	jmp	short PTLDoIt

PTLDisable:
	mov	ax,PTL_A20_DisableFunc	; Disable Function

PTLDoIt:
	call    PTL_A20_Bios_Entry

PTLExit:
	mov	ax,1			; Good status, return 1
	ret

PTLErr:
	xor	ax,ax			; Bad status, return 0
	ret

PTL_CASCADE_A20Handler endp

EndPTL_CASCADE_A20Handler:


;*----------------------------------------------------------------------*
;*									*
;*  PS2_A20Handler -					HARDWARE DEP.   *
;*									*
;*	Enable/Disable the A20 line on PS/2 machines			*
;*									*
;*  ARGS:   AX = 0 for Disable, 1 for Enable, 2 for On/Off check	*
;*  RETS:   AX = 1 for success, 0 otherwise				*
;*  REGS:   AX, CX and Flags clobbered					*
;*									*
;*----------------------------------------------------------------------*

PS2_PORTA   equ	0092h
PS2_A20BIT  equ	00000010b

PS2_A20Handler proc   near

	cmp	ax,1
	mov	ah,PS2_A20BIT		; Assume enabling
	jz	PAHEnable
	jb	PAHDisable

	in	al,PS2_PORTA		; 2 == On/Off check
	test	al,PS2_A20BIT
	jz	PAHErr			; returns ax = 0 (off)
	jmp	short PAHExit		; returns ax = 1 (on)

PAHDisable:
	xor	ah,ah			; Disabling...

PAHEnable:

	in	al,PS2_PORTA		; Get current port 92h bits
	and	al,NOT PS2_A20BIT	;    and clear A20
	or	al,ah			; Enable or Disable A20 bit
	jmp	short $+2
	jmp	short $+2
	out	PS2_PORTA,al

	xor	cx,cx			; Wait for port 92h to show
PAHWait:				;   desired A20 state
	jmp	short $+2
	in	al,PS2_PORTA
	and	al,PS2_A20BIT
	cmp	al,ah
	loopnz	PAHWait

	jnz	PAHErr

PAHExit:
	mov	ax,1
	ret

PAHErr:
	xor	ax,ax
	ret

PS2_A20Handler endp

EndPS2_A20Handler:


;*----------------------------------------------------------------------*
;*									*
;*  IC_A20Handler -							*
;*									*
;*	Enable/Disable the A20 line on the IBM 7552 Industrial		*
;*	Computer.							*
;*									*
;*  ARGS:   AX = 0 for Disable, 1 for Enable, 2 for On/Off check	*
;*  RETS:   AX = 1 for success, 0 otherwise				*
;*  REGS:   AX, CX and Flags clobbered					*
;*									*
;*----------------------------------------------------------------------*

IC_MISCPORT	equ 65h
IC_A20BIT	equ 04h

IC_A20Handler proc near

	cmp	ax,1
	mov	ah,IC_A20BIT		; Assume disabling
	jz	ICAHEnable
	jb	ICAHDisable

	in	al,IC_MISCPORT		; 2 == On/Off check
	test	al,IC_A20BIT
	jnz	ICAHErr 		; returns ax = 0 (off)
	jmp	short ICAHExit		; returns ax = 1 (on)

ICAHEnable:
	xor	ah,ah			; Enabling...

ICAHDisable:

	in	al,IC_MISCPORT		; Get current port 92h bits
	and	al,NOT IC_A20BIT	;    and clear A20
	or	al,ah			; Enable or Disable A20 bit
	jmp	short $+2
	jmp	short $+2
	out	IC_MISCPORT,al

	xor	cx,cx			; Wait for port 92h to show
ICAHWait:				 ;   desired A20 state
	jmp	short $+2
	in	al,IC_MISCPORT
	and	al,IC_A20BIT
	cmp	al,ah
	loopnz	ICAHWait

	jnz	ICAHErr

ICAHExit:
	mov	ax,1
	ret

ICAHErr:
	xor	ax,ax
	ret

IC_A20Handler endp

EndIC_A20Handler:


;*----------------------------------------------------------------------*
;*									*
;*  $6300Plus_A20Handler -				HARDWARE DEP.   *
;*									*
;*     Enable/Disable address lines A20-A23 on AT&T 6300 Plus		*
;*									*
;*  ARGS:   AX = 0 for Disable, 1 for Enable				*
;*  RETS:   AX = 1 for success, 0 otherwise				*
;*  REGS:   AX, BX, and Flags clobbered					*
;*									*
;*  Note:   Don't want to do two back to back disables on PLUS,		*
;*	    so we check to see if it is necessary.			*
;*  Warning:  The calcuation of the Rback label depends on the		*
;*	  expectation that this routine is being moved at init time.    *
;*									*
;*----------------------------------------------------------------------*

PLUS_PORT   equ		03F20h
PLUS_STATUS equ		03FA0h
PLUS_SET    equ		80h	; Turn on A20-A23
PLUS_RESET  equ		10h	; Turn off A20-A23 and point to our routine

$6300PLUS_A20Handler proc   near
	mov	bx,ax
	push	dx
	mov	dx,PLUS_STATUS
	in	al,dx
	pop	dx
	and	ax,1
	cmp	ax,bx
	jne	$6AHEnable
	mov	ax,1
	ret			; No, just return

$6AHEnable:
	pushf
	sti
	mov	al,PLUS_SET
	or	bx,bx		; Zero if disable
	jnz	$6AHNext
	mov	al,PLUS_RESET

$6AHNext:
	push	dx		; Set/reset the port
	mov     dx,PLUS_PORT
	out     dx,al
	pop     dx
	or      bx,bx
	jnz     $6AHNext1
	call    $6300Reset	; Reset the processor
$6AHNext1:
	popff
	mov	ax,1
	ret

$6300Plus_A20Handler endp



; In order to address memory above 1 MB on the AT&T 6300 PLUS, it is
; necessary to use the special OS-MERGE hardware to activate lines
; A20 to A23.  However, these lines can be disabled only by resetting
; the processor.  The address to which to return after reset are placed
; at 40:A2, noted here as RealLoc1.

BiosSeg SEGMENT  AT 40h		  ; Used to locate 6300 PLUS reset address

		org	00A2h
RealLoc1	dd	0

BiosSeg ends

;*----------------------------------------------------------------------*
;*									*
;* $6300Reset -						HARDWARE DEP.   *
;*									*
;* Reset the 80286 in order to turn off the address lines on the 6300   *
;* PLUS.  This is the only way to do this on the current hardware.	*
;* The processor itself is reset by reading or writing port 03F00h.	*
;*									*
;*  Uses flags.								*
;*									*
;*----------------------------------------------------------------------*

$6300Reset  proc    near

	pusha				; Save world
	push    ds			; Save segments
	push    es
	mov	ax,BiosSeg		; Point to the BIOS segment
	mov	ds,ax			; ds -> 40h

;	Setup the reset return address.

	assume	ds:nothing

	push    word ptr ds:[RealLoc1]  ; Save what might have been here
	push    word ptr ds:[RealLoc1+2]

;	Load our return address, remembering that we will be relocated
;	   at init time.

	mov     word ptr ds:[RealLoc1+2],cs
 mov ds:word ptr [RealLoc1],offset Rback-offset $6300Plus_A20Handler+offset A20Handler
	mov     cs:[OldStackSeg],ss     ; Save the stack segment, too

;	Reset the processor - turning off A20 in the process.

	mov	dx,03F00h
	in	ax,dx

;	We shouldn't get here.  Halt the machine if we do.

	nop
	nop
	nop
	nop
	cli
	hlt

Rback:
	mov	ss,cs:[OldStackSeg]		; Start the recovery
	pop	word ptr ds:[RealLoc1+2]	; ROM code has set ds->40h
	pop	word ptr ds:[RealLoc1]
	pop	es
	pop	ds

	xor     al,al
	mov     dx,PLUS_PORT
	out     dx,al
	popa
	ret

$6300Reset endp

End6300Plus_Handler:

;*----------------------------------------------------------------------*
;*									*
;*  HP_A20Handler -					HARDWARE DEP.   *
;*									*
;*	Enable/Disable the A20 line on HP Vectra machines		*
;*									*
;*  ARGS:   AX = 0 for Disable, 1 for Enable				*
;*  RETS:   AX = 1 for success, 0 otherwise				*
;*  REGS:   AX, CX and Flags clobbered					*
;*									*
;*----------------------------------------------------------------------*

HP_A20Handler proc   near

	or	ax,ax
	mov	ah,0DFh 	; Assume enabling
	jnz	HAHSetA20
	mov	ah,0DDh 	; Actually disabling...

HAHSetA20:

	call    HPSync8042	; Make sure the Keyboard Controller is ready
	jnz     HAHErr

	mov	al,ah		; Send enable/disable
	out	64h,al
	call    HPSync8042
	jnz     HAHErr

	mov	al,ah		; And send it again...
	out	64h,al
	call    HPSync8042
	jnz	HAHErr

HAHExit:
	mov	ax,1
	ret

HAHErr:
	xor	ax,ax
	ret

HP_A20Handler endp


HPSync8042  proc    near

	xor	cx,cx
H8InSync:
	jmp	short $+2
	in	al,64h
	and	al,2
	loopnz  H8InSync
	ret

HPSync8042  endp

EndHP_A20Handler:

;*----------------------------------------------------------------------*
;*									*
;*  NHP_A20Handler -					HARDWARE DEP.   *
;*									*
;*	Enable/Disable the A20 line on HP Vectra machines		*
;*									*
;*  ARGS:   AX = 0 for Disable, 1 for Enable				*
;*  RETS:   AX = 1 for success, 0 otherwise				*
;*  REGS:   AX, CX and Flags clobbered					*
;*									*
;*----------------------------------------------------------------------*

NHP_A20Handler proc   near

	or	ax,ax
	mov	ah,0DFh 	; Assume enabling
	jnz	NHAHSetA20
	mov	ah,0DDh 	; Actually disabling...

NHAHSetA20:

	call    NHPSync8042	; Make sure the Keyboard Controller is ready
	jnz     NHAHErr

	mov	al,ah		; Send enable/disable
	out	64h,al

	call    NHPSync8042
	jnz     NHAHErr

	mov	al,0ffh		; And send a NULL command
	out	64h,al

	call    NHPSync8042	; and wait
	jnz     NHAHErr

NHAHExit:
	mov	ax,1
	ret

NHAHErr:
	xor	ax,ax
	ret

NHP_A20Handler endp


NHPSync8042  proc    near

	xor	cx,cx
NH8InSync:
	jmp	short $+2
	in	al,64h
	and	al,2
	loopnz  NH8InSync
	ret

NHPSync8042  endp

EndNHP_A20Handler:

;M004 start
;*--------------------------------------------------------------------------*
;*									    *
;*  BM60_A20Handler -					    HARDWARE DEP.   *
;*									    *
;*	Enable/Disable the A20 line on BULL Micral BM60 machines	    *
;*									    *
;*  ARGS:   AX = 0 for Disable, 1 for Enable				    *
;*  RETS:   AX = 1 for success, 0 otherwise				    *
;*  REGS:   AX and Flags clobbered					    *
;*									    *
;*--------------------------------------------------------------------------*

BM60_A20Handler proc   near

	or	ax,ax
	jz	short BM60Disable

BM60Enable:
	mov	al,0DFh     ; Send DFh
	out	0E0h,al
	jmp	short $+2
	in	al,64h
	and	al,2
	jnz	short BM60Exit	  ; ok
	jmp	short BM60Err

BM60Disable:
	mov	al,0DDh     ; Send D1h
	out	0E0h,al
	jmp	short $+2
	in	al,64h
	and	al,2
	jnz	short BM60Err	  ; not ok

BM60Exit:
	mov	ax,1
	ret

BM60Err:
	xor	ax,ax
	ret

BM60_A20Handler endp

EndBM60_A20Handler:
;M004 end

;*----------------------------------------------------------------------*
;*									*
;*  ACER_A20Handler -							*
;*									*
;*	Enable/Disable the A20 line on ACER 1100 machines		*
;*									*
;*  ARGS:   AX = 0 for Disable, 1 for Enable				*
;*  RETS:   AX = 1 for success, 0 otherwise				*
;*  REGS:   AX and Flags clobbered					*
;*									*
;*----------------------------------------------------------------------*

ACER_A20Handler proc   near

	or	ax,ax
	mov	al,0DDh 		; Assume disable
	jz	@f
	mov	al,0DFh 		; Oh, it's actually enable
@@:
	push	dx			; ACERs do it by writing to
	mov	dx,329h 		;   this port
	out	dx,al
	pop	dx
	mov	ax,1
	ret

ACER_A20Handler endp

EndACER_A20Handler:


;*----------------------------------------------------------------------*
;*									*
;*  Wyse_A20Handler -							*
;*									*
;*	Enable/Disable the A20 line on Wyse 12.5 MHz 286 machines	*
;*									*
;*  ARGS:   AX = 0 for Disable, 1 for Enable				*
;*  RETS:   AX = 1 for success, 0 otherwise				*
;*  REGS:   AX, CX and Flags clobbered					*
;*									*
;*----------------------------------------------------------------------*

Wyse_A20Handler proc   near

	or	ax,ax
	mov	ah,0DFh 	; Assume enabling
	jnz	WAHSetA20
	mov	ah,0DDh 	; Actually disabling...

WAHSetA20:

	call	Wyse8042	; Make sure the Keyboard Controller is Ready
	jnz	WAHErr

	call	Wyse8042	; and do it again!
	jnz	WAHErr

	mov	al,0D1h		; Send D1h
	out	64h,al
	call	Wyse8042
	jnz	WAHErr

	mov	al,ah		; Send enable/disable...
	out	60h,al
	call	Wyse8042
	jnz	WAHErr

WAHExit:
	mov	ax,1
	ret

WAHErr:
	xor	ax,ax
	ret

Wyse_A20Handler endp


Wyse8042    proc    near

	xor	cx,cx
@@:	jmp	short $+2
	in	al,64h
	and	al,2
	loopnz	@b
	ret

Wyse8042    endp

EndWyse_A20Handler:


;*----------------------------------------------------------------------*
;*									*
;*  ZB_A20Handler -							*
;*									*
;*	Enable/Disable the A20 line on Zenith ZBIOS machines		*
;*									*
;*  ARGS:   AX = 0 for Disable, 1 for Enable				*
;*  RETS:   AX = 1 for success, 0 otherwise				*
;*  REGS:   AX, CX and Flags clobbered					*
;*									*
;*----------------------------------------------------------------------*



ZB_A20Handler	proc	near

	call	[lpExtA20Handler]	; It just so happens that AH/AL
					;   are setup just the way ZBIOS
	mov	ax,1			;   wants them to gate A20 on/off
	ret

ZB_A20Handler	endp

EndZB_A20Handler:

;*----------------------------------------------------------------------*
;*									*
;*  Dell_A20Handler							*
;*					                        	*				*
;*      Enable/disable A20 on Dell XBIOS-equipped machines              *
;*									*
;*  ARGS:   AX = 0 for Disable, 1 for Enable		 		*
;*  RETS:   AX = 1 (no failure conditions)                              *
;*  REGS:   All regs/flags preserved except AX				*
;*									*
;*  Note: Provided by Dell Computer Corp.                               *
;*									*
;*----------------------------------------------------------------------*
;
; M010
;
Dell_A20Handler PROC NEAR
	pushf					; BUGBUG all regs!?!?!?!?
	pusha
	push	ds
	push	es

	push	ax
	mov	ax,ss
	mov	es,ax
	mov	bx,sp
	call	DWORD PTR [lpExtA20Handler]
	add	sp,2

	pop	es
	pop	ds
	popa
	mov	ax,1
	popf
	ret

Dell_A20Handler ENDP
EndDell_A20Handler:


;*----------------------------------------------------------------------*
;*									*
;*  Ext_A20Handler -							*
;*									*
;*	Enable/Disable the A20 line using an external handler.		*
;*	Query A20 calls (AX=2) may also be supported by the handler.	*
;*									*
;*  ARGS:   AX = 0 for Disable, 1 for Enable				*
;*  RETS:   AX = 1 for success, 0 otherwise				*
;*									*
;*----------------------------------------------------------------------*


Ext_A20Handler	proc	near

	call	[lpExtA20Handler]
	ret

Ext_A20Handler	endp

EndExt_A20Handler:


;****************************************************************************
;*									    *
;* The following routines detect the special case systems supported by	    *
;* specific A20 handling routines.  This code is called once during	    *
;* initialization, and then is overwritten or discarded.		    *
;*									    *
;****************************************************************************

	assume	cs:_text, ds:_text

;*----------------------------------------------------------------------*
;*									*
;*  IsAT								*
;*									*
;*	Check for IBM PC/AT 'standard' A20 handling.			*
;*									*
;*	This routine detects AT style A20 handling by invoking the	*
;*	DiddleA20 routine to toggle A20 on & off.  The AT handler	*
;*	supports a number of different delay methods, controlled by	*
;*	the ATA20Delay global variable.  IsAT calls DiddleA20 with	*
;*	different ATA20Delay values until it find one that works, or	*
;*	runs out of choices.						*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if we can control A20 via the 8042, 0 otherwise.	*
;*									*
;*----------------------------------------------------------------------*

	public	IsAT

IsAT	proc	near

IATAgain:
	pushf				;disable ints while gating A20
	cli

	call	DiddleA20

	popff

	or	ax,ax
	jnz	IsAT_Yes

	inc	ATA20Delay
	cmp	ATA20Delay,NUM_ALT_A20
	jbe	IATAgain

IsAT_No:
	xor	ax,ax
	ret

IsAT_Yes:
	mov	ax,1
	ret

IsAt	endp

;*----------------------------------------------------------------------*
;*									*
;*  Trace_PTL_Func					HARDWARE DEP.	*
;*									*
;*	Check for Phoenix Cascade BIOS enabling interrupts on an A20	*
;*	manipulation function call.  Early copies of the Phoenix	*
;*	Cascade BIOS enabled interrupts on calls to manipulate the A20	*
;*	line.  Unfortunately, this BIOS was source-licensed to OEMs, to *
;*	there is no easy detection method.  This function installs a	*
;*	trace exception handler, then calls the ROM with the trace flag *
;*	set.  The trace exception handler inspects the flags image on	*
;*	the stack, and sets a variable if it is ever called with	*
;*	interrupts enabled.						*
;*									*
;*  ARGS:   AX = PTL BIOS function to call				*
;*  RETS:   Ints_Are_Disabled set to zero if interrupts have been	*
;*	    enabled.							*
;*  REGS:   AX, flags used.						*
;*									*
;*----------------------------------------------------------------------*

Ints_Are_Disabled	dw	1
Original_INT1_Hook	dd	?

	public	Trace_PTL_Func

Trace_PTL_Func	proc	near
;
; Save the original trace exception handler.
; Install our own trace exception handler.
;
	pushf
	cli
	push	bx
	push	ax		; AX = function number
	push	es

	xor	ax,ax
	mov	es,ax
	lea	ax,INT1_Hook
	xchg	ax,es:[4]
	mov	word ptr [Original_INT1_Hook],ax
	mov	ax,cs
	xchg	ax,es:[6]
	mov	word ptr [Original_INT1_Hook+2],ax
	pop	es
;
; Set the trace flag, then call the BIOS to perform the requested function.
;
	pop	bx
	pushf
	pop	ax
	or	ah,1			; Set the trace flag.
	push	ax
	mov	ax,bx
	popf
	call	PTL_A20_Bios_Entry

	pop	bx
	popf
	ret

Trace_PTL_Func	endp


;*----------------------------------------------------------------------*
;*									*
;*  INT1_Hook						HARDWARE DEP.	*
;*									*
;*	Trace exception handler.  Inspects the flags image on the stack *
;*	to determine whether the ROM BIOS enables interrupts.  If	*
;*	called from code with interrupts enabled, sets the variable	*
;*	Ints_Are_Disabled to zero.  De-installs itself if interrupts	*
;*	are enabled or interrupted CS is equal to our CS.		*
;*									*
;*----------------------------------------------------------------------*

	public	INT1_Hook

INT1_Hook	proc	near

	push	bp
	mov	bp,sp		    ; BP -> BP IP CS Flags
	push	ax
;
; Un-hook INT on entry, so we can debug (portions of) this routine.
;
	push	es
	pushf
	cli
	xor	ax,ax
	mov	es,ax
	mov	ax,word ptr [Original_INT1_Hook]
	mov	es:[4],ax
	mov	ax,word ptr [Original_INT1_Hook+2]
	mov	es:[6],ax
	and	byte ptr [bp+7],NOT 1	; Zap trace flag.
	popf
	pop	es

	test	byte ptr [bp+7],2   ; Interrupts enabled?
	jz	I1H_checkCS

	mov	[Ints_Are_Disabled],0
	jmp	short I1H_done

I1H_checkCS:

	mov	ax,cs
	cmp	[bp+4],ax
	je	I1H_done

I1H_continue:
;
; Re-hook INT 1, and IRET to traced code.
;
	push	es
	pushf
	cli
	xor	ax,ax
	mov	es,ax
	lea	ax,INT1_Hook
	mov	es:[4],ax
	mov	ax,cs
	mov	es:[6],ax
	popf
	pop	es
	or	byte ptr [bp+7],1	; Reset trace flag.

I1H_done:

	pop	ax
	pop	bp
	iret

INT1_Hook	endp

;*----------------------------------------------------------------------*
;*									*
;*  IsPTLCascade					HARDWARE DEP.   *
;*									*
;*	Check for Phoenix Cascade BIOS					*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if we're on an Phoenix Cascade BIOS, 0 otherwise	*
;*  REGS:   AX, flags used.						*
;*									*
;*----------------------------------------------------------------------*

	public	IsPTLCascade

IsPTLCascade  proc near

	mov	ah,0C0h		; Get System Description Vector
	stc			; using interrupt 15h, function C0h.
	int	15h
	jc	IPTLNo		; Error - Not a Phoenix Cascade BIOS

	add	bx,es:[bx]	; Get to system config. table extension
	add	bx,2+PTL_STRING_Offset ; add the offset to the PTL string
	cmp	es:[bx],'TP'	; Look for 'TP' (start of PTL)
	jne	IPTLNo		; Not a Phoenix Cascade BIOS
	cmp	BYTE PTR es:[bx+2],'L' ; Look for 'L' (end of PTL)
	jne	IPTLNo		; Not a Phoenix Cascade BIOS

	mov	al,es:[bx+PTL_Feature1] ; Get Phoenix feature byte 1
	test    al,PTL_A20Bit	; Test the A20 support bit
	jz	IPTLNo		; No support for A20 control

IPTLFoundIt:

;
; Set the trace flag, then call the ROM BIOS to "inquire" A20.
; Our trace handler will detect whether the ROM BIOS enables
; interrupts or not, by monitoring the state of the flags
; word during the call.
;
	mov	ax,PTL_A20_InquireFunc	 ; call to inquire A20 state
	call	Trace_PTL_Func
	push	ax			 ; save result

;
; Set the trace flag, then call the ROM BIOS to enable A20.
; Our trace handler will detect whether the ROM BIOS enables
; interrupts or not, by monitoring the state of the flags
; word during the call.
;
	mov	ax,PTL_A20_EnableFunc	 ; call to enable A20
	call	Trace_PTL_Func
;
; Set the trace flag, then call the ROM BIOS to disable A20.
; Our trace handler will detect whether the ROM BIOS enables
; interrupts or not, by monitoring the state of the flags
; word during the call.
;
	mov	ax,PTL_A20_DisableFunc	 ; call to disable A20
	call	Trace_PTL_Func
	pop	ax			 ; AL = 1: A20 was on before
	or	al,al
	jz	@F
	mov	ax,PTL_A20_EnableFunc	 ; call to enable A20
	call	PTL_A20_Bios_Entry
@@:

	mov	ax,[Ints_Are_Disabled]	 ; Yup! Phoenix A20 support, return 1
	ret

;	IsFail is an alternate entry point, used for machines that we
;	  don't know how to detect.

IsFail:
IPTLNo:
	xor	ax,ax		; Not Phoenix or No support, return 0
	ret

IsPTLCascade	endp


;*----------------------------------------------------------------------*
;*									*
;*  Is6300Plus						HARDWARE DEP.   *
;*									*
;*	Check for AT&T 6300 Plus					*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if we're on an AT&T 6300 Plus, 0 otherwise		*
;*  REGS:   AX, flags used.						*
;*									*
;*  Side Effects:   MemCorr value updated to 384 if necessary.		*
;*									*
;*----------------------------------------------------------------------*

	public	Is6300Plus

Is6300Plus  proc near

	xor	ax,ax
	push    bx
	mov	bx,0fc00h		; Look for 'OL' at fc00:50
	mov	es,bx
	cmp	es:[0050h],'LO'
	jne     I6PNotPlus		; Not found
	mov	es,f000
	cmp	word ptr es:[0fffdh],0fc00h ; Look for 6300 PLUS
	jne     I6PNotPlus

	in	al,66h			; Look for upper extended memory
	and	al,00001111b
	cmp	al,00001011b
	jne     I6PNoMem
	mov	[MemCorr],384		; Save value

I6PNoMem:
	mov	ax,1			; We found a PLUS
I6PNotPlus:
	pop	bx
	ret

Is6300Plus  endp


;*----------------------------------------------------------------------*
;*									*
;*  IsPS2Machine					HARDWARE DEP.   *
;*									*
;*	Check for PS/2 machine						*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if we're on a valid PS/2 machine, 0 otherwise	*
;*  REGS:   AX	and Flags clobbered					*
;*									*
;*----------------------------------------------------------------------*

	public	IsPS2Machine

IsPS2Machine proc   near

	mov	ax,2403h	; Query A20 gate support
	stc
	int	15h
	jc	IPMNotYet	; CY must be clear
	or	ah,ah		;   and AH must be 00h
	jnz	IPMNotYet

	test	bl,00000010b	; Is port 92h gating supported?
	jnz	IPMFoundIt	; Yes!

IPMNotYet:
	mov     ah,0c0h		; Get System Description Vector
	stc
	int	15h
	jc	IPMNoPS2  	; Error?  Not a PS/2.

;	Do we have a "Micro Channel" computer?

	mov     al,byte ptr es:[bx+5] ; Get "Feature Information Byte 1"
	test    al,00000010b    ; Test the "Micro Channel Implemented" bit
	jnz	IPMFoundIt	; MCA, use PS/2 A20 code

;	The PS/2 Model 30/286 also uses the PS/2 A20 code, but it isn't
;	a MCA machine, check for the 30/286 model/submodel.  Likewise
;	with a few others...

	cmp	word ptr es:[bx+2],19F8h	; Tortuga ?
	jz	IPMFoundIt

	cmp	word ptr es:[bx+2],23F8h	; Aloha?
	jz	IPMFoundIt

	cmp	word ptr es:[bx+2],25F8h	; Bounty?
	jz	IPMFoundIt

	cmp	word ptr es:[bx+2],09FCh	; Model 30/286?
	jz	IPMFoundIt

	cmp	word ptr es:[bx+2],0BFCh	; Type/subtype FC/0Bh?
	jnz	IPMNoPS2

IPMFoundIt:
	xor	ax,ax		; Disable A20. Fixes PS2 Ctl-Alt-Del bug
	call    PS2_A20Handler
	mov	ax,1
	ret

IPMNoPS2:
	xor	ax,ax
	ret

IsPS2Machine endp


;*----------------------------------------------------------------------*
;*									*
;*  IsHPMachine						HARDWARE DEP.   *
;*									*
;*	Check for HP Vectra Machine, Model A or A+			*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if we're on a HP Vectra machine, 0 otherwise		*
;*  REGS:   AX, ES and Flags clobbered					*
;*									*
;*----------------------------------------------------------------------*

HPVectraMask	equ	00011111b	; Bit mask to check for HP Vectra

	public	IsHPMachine

IsHPMachine proc   near

	mov	es,f000
;
; M009 - Begin
;
	mov	ax, NOT 'PH'		; lets not have the pattern 'PH'
					; in the bus
	not	ax			; generate it indirectly

	cld				; charge the bus with CLDs 0xFC
	cld				
	cld
	cld
	cld
	cld
	cld
	cld

	cmp	ax, word ptr es:[0f8h]

	cld				; Charge the bus with 0xFC even
	cld				; on instruction prefetch
	cld
	cld
	cld
	cld
	cld
	cld
;
; M009 - end
;
	jne	IHMNoHP

	mov	al,es:[0fah]		; In f000:fa, 0 means A or A+
	and	al,HPVectraMask		; other HP Vectras are treated as an AT
	jnz	IHMNoHP

IHMIsHP:
	mov	ax,1
	ret

IHMNoHP:
	xor	ax,ax
	ret

IsHPMachine endp


;*----------------------------------------------------------------------*
;*									*
;*  IsHPVectra						HARDWARE DEP.   *
;*									*
;*	Check for HP Vectra Machine, Other than Classic A, A+ & HP LS/12*			*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if we're on a HP Vectra machine, 0 otherwise		*
;*  REGS:   AX, ES and Flags clobbered					*
;*									*
;*  If this routine gets called then the machine has already failed to	*
;*  satisfy that it is a HP Classic Vectra A & A+. So we dont have to	*
;*  eliminate Classic Vectra explicitly in this routine			*
;*----------------------------------------------------------------------*

HPLS12MASK	equ	01011b

	public	IsHPVectra

IsHPVectra proc   near

	mov	es,f000
;
; M009 - Begin
;
	mov	ax, NOT 'PH'		; lets not have the pattern 'PH'
					; floating on the bus
	not	ax			; generate it indirectly

	cld				; charge the bus with CLDs 0xFC
	cld				
	cld
	cld
	cld
	cld
	cld
	cld

	cmp	ax,word ptr es:[0f8h]

	cld				; Charge the bus with 0xFC even
	cld				; on instruction prefetch
	cld
	cld
	cld
	cld
	cld
	cld
;
; M009 - end
;
	jne	IHVNoHP

	mov	al,es:[0fah]		; In f000:fa, 0 means A or A+
	and	al,HPVectraMask		; other HP Vectras are treated as an AT
	cmp	al, HPLS12MASK
	je	IHVNoHP
IHVIsHP:
	mov	ax,1
	ret

IHVNoHP:
	xor	ax,ax
	ret

IsHPVectra endp


;*----------------------------------------------------------------------*
;*									*
;*  IsToshiba								*
;*									*
;*	Check for Toshiba 1600 or 1200XE				*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if we're on a T1600 or T1200XE, 0 otherwise          *
;*  REGS:   AX, ES and Flags clobbered					*
;*									*
;*----------------------------------------------------------------------*

	public	IsToshiba

IsToshiba proc	 near

	mov	ax,0FFFFh
	mov	es,ax
	cmp	byte ptr es:[0Eh],0FCh	; PC/AT id?
	jne	ITNo			; can't be what we want then

	mov	al,byte ptr es:[0Ah]	; Toshiba puts their own id here
	cmp	al,02Bh 		; Special T1600 id?
	je	ITMaybe
	cmp	al,02Ah 		; Special T1200XE id?
	jne	ITNo
ITMaybe:
	mov	ax,0FE00h		; Do a further check, the Toshiba
	mov	es,ax			;   machines have a name string at
	cmp	word ptr es:[0],'1T'	;   FE00:0000 (T1600 or T1200XE)
	jne	ITNo
	mov	ax,word ptr es:[2]
	cmp	ax,'06' 		; T160...
	je	ITYes
	cmp	ax,'02' 		; T120...
	jne	ITNo
ITYes:
	mov	ax,1
	ret

ITNo:
	xor	ax,ax
	ret

IsToshiba endp


;*----------------------------------------------------------------------*
;*									*
;*  IsZBIOS								*
;*									*
;*	Check for Zenith ZBIOS machine					*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if we're on a Zenith ZBIOS system, 0 otherwise       *
;*  REGS:   BX, ES and Flags clobbered					*
;*									*
;*----------------------------------------------------------------------*

ZBIOS_Id	dw	0FFE3h, 0F000h
ZBIOS_Entry_Off equ	0FFE8h

	public	IsZBIOS

IsZBIOS proc	near

	push	cx

	les	bx,dword ptr cs:[ZBIOS_ID]	; ZBIOS Machines are
	cmp	es:[bx],'BZ'			;   identified by the
	jnz	IZB_No				;   string 'ZBIOS' at
	cmp	es:[bx+2],'OI'			;   a fixed location
	jnz	IZB_No
	cmp	byte ptr es:[bx+4],'S'
	jnz	IZB_No

	mov	bx,es:[ZBIOS_Entry_Off] 	; Build far pointer to
	mov	word ptr [lpExtA20Handler],bx	;   ZBIOS entry point for
	mov	word ptr [lpExtA20Handler+2],es ;   A20 handler

;	This machine has a ZBIOS.  Make sure it supports the Gate A20 function.

	mov	ax, 00FFh		; ZBIOS Gate A20 Query call
	call	[lpExtA20Handler]	; Is Gate A20 supported?
	jc	IZB_No			;   CY set if not...

	mov	ax,1		; Yes, it's a ZBIOS machine
	pop	cx
	ret

IZB_No: 			; Not a ZBIOS machine
	xor	ax,ax
	pop	cx
	ret

IsZBIOS endp


;*----------------------------------------------------------------------*
;*									*
;*  IsBM60								*
;*									*
;*	Check for Bull Micral BM60					*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if we're on a BM60, 0 otherwise                      *
;*  REGS:   BX, ES and Flags clobbered					*
;*									*
;*----------------------------------------------------------------------*

BullSA_ID	dw	0E01Eh, 0F000h

	public	IsBM60
IsBM60	proc	near

	xor	ax,ax				; Clear AX

	les	bx,dword ptr cs:[BullSA_ID]	; Check for "Bull S.A"
	cmp	es:[bx	],'uB'			; to determine correct
	jnz	IsBM60_No			; family of machines
	cmp	es:[bx+2],'ll'
	jnz	IsBM60_No
	cmp	es:[bx+4],'S '
	jnz	IsBM60_No
	cmp	es:[bx+6],'A.'
	jnz	IsBM60_No

	cmp	byte ptr es:[bx-14h],'V'	; Q: Is this a BM60?
	jne	IsBM60_No			;   N:
	inc	ax				;   Y: We found one

IsBM60_NO:
	ret

IsBM60	endp


;*----------------------------------------------------------------------*
;*									*
;*  IsPhilips								*
;*									*
;*	Check for Philips machines					*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if we're on a Philips machine, 0 otherwise           *
;*  REGS:   AX and Flags clobbered					*
;*									*
;*  Note: Philips code received from Philips Corp.			*
;*									*
;*----------------------------------------------------------------------*

IsPhilips proc	 near

	push	cx
	push	ds
	push	es
	push	si
	push	di

	mov	ax,0f000h
	mov	ds,ax
	mov	si,0e000h		; ds:si -> @ BIOS signature location

	push	cs
	pop	es
	mov	di,offset phl_name	; es:di -> @ signature to check
	mov	cx,phl_name_len
	repz	cmpsb

	mov	ax,1			; assume found it
	jz	IsPhilips_exit		; condition from 'cmpsb'
	
	mov	ax,0			; did not find it

IsPhilips_exit:
	pop	di
	pop	si
	pop	es
	pop	ds
	pop	cx
	ret

phl_name	db	' PHILIPS'
phl_name_len	equ	$-phl_name

IsPhilips endp


;*----------------------------------------------------------------------*
;*									*
;*  IsCSS								*
;*									*
;*	Check for CSS Lab machines					*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if we're on a CSS Lab machine, 0 otherwise           *
;*  REGS:   AX and Flags clobbered					*
;*									*
;*  Note: ID method given by CSS labs & Award Software Inc.
;*									*
;*----------------------------------------------------------------------*


ROMCSSPtr	dw	0e0c1h, 0f000h
CSSStr		db	'CSS LAB'
CSSSTRLEN	equ	$ - offset CSSStr

IsCSS	proc	near
	push	ds
	push	si
	push	es
	push	di
	push	cx
	xor	ax, ax				; assume it is not
	mov	si, offset CSSStr
	push	cs
	pop	ds
	les	di, dword ptr cs:ROMCSSPtr
	mov	cx, CSSSTRLEN
	rep	cmpsb
	jne	@f
	inc	ax
@@:
	pop	cx
	pop	di
	pop	es
	pop	si
	pop	ds
	ret
IsCSS	endp


;*----------------------------------------------------------------------*
;*									*
;*  IsDellXBIOS								*
;*					                        	*				*
;*	Check for Dell XBIOS machines					*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1 if we're on a Dell XBIOS machine, 0 otherwise        *
;*  REGS:   trashes SI, DI, CX, AX					*
;*									*
;*          Stores address of XBIOS A20 handler in lpExtA20Handler      *
;*									*
;*  Note: ID method given by Dell Computer Corp.                        *
;*									*
;*----------------------------------------------------------------------*
;
; M010
;
xb_signature    db 'DELLXBIOS',00       ;XBIOS signature string & len
xb_sig_len      equ 10                  

                PUBLIC IsDellXBIOS
IsDellXBIOS     PROC NEAR

	push	ds
	push	es
	cld
             
	mov	ax,0f000h                   
	mov	es,ax                       
	les	di,es:[0ed00h]
	push	ds

	push	cs
	pop	ds
	lea	si,cs:xb_signature
	mov	cx,xb_sig_len		;look for XBIOS signature text

;	repe	cmpsb			;at *(F000:ED00)
idx05:
	lodsb

	cld
	cld
	cld
	cld
	cld
	cld
	cld
	cld

	cmp	al, byte ptr es:[di]
	jne	idx10
	inc	di
	loop	idx05
idx10:
	pop	ds
	add	di,2			;skip version ID, if present
	jcxz	for_feature                

xbios_fail:
	xor	ax, ax			;no XBIOS A20 handler present
	jmp	short xb_init_done      

xbios_chain:
	les	di,es:[di+2]		;handle XFT chain feature...

for_feature:
	mov	ax,es:[di]		;get feature identifier
	add	di,2			;index attribute flags
	cmp	ax,0			;NULL feature?
	je	xbios_fail		;yes, end of feature table
	cmp	ax,65535		;CHAIN feature?
	je	xbios_chain		;yes, go find next fragment...
	cmp	ax,11			;A20 feature?
	jne	next_feature		;no, skip it           
	mov	ax,es:[di]		;else get feature attributes
	test	ax,00001000b		;standard seg:off pointer?
	jz	next_feature		;no, wouldn't be prudent at 
					;this juncture
	les	bx,es:[di+2]
	mov	WORD PTR lpExtA20Handler,bx	;else record handler addr...
	mov	WORD PTR lpExtA20Handler+2,es 
	mov	ax, 1
xb_init_done:
	pop	es			;C=1 if XBIOS OK, 0 otherwise
	pop	ds
	ret

next_feature:
	mov	ax,es:[di]		;get feature attributes
	add	di,6			;skip attribs & handler addr
	test	al,110000b		;keystroke or appendix?
	jz	for_feature		;no, nothing else to skip
	mov	bx,ax
	and	bx,10000b		;keystroke?
	shr	bx,1
	shr	bx,1			;BX=2 if keystroke present,
	shr	bx,1			;else 0
	add	di,bx
	test	ax,100000b		;appendix?
	jz	for_feature
	add	di,es:[di]		;yes, add blocklen+2 to skip
	add	di,2
	jmp	for_feature

IsDellXBIOS     ENDP




;*----------------------------------------------------------------------*
;*									*
;*  DiddleA20 - 							*
;*									*
;*	Test the operation of the A20 line.				*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = 1,   able to enable & disable A20			*
;*	    AX = 0 &							*
;*	       CY clear, able to enable, but not disable		*
;*	       CY set,	 unable to enable				*
;*									*
;*----------------------------------------------------------------------*

	public	DiddleA20

DiddleA20	proc	near

	call	IsA20On 		; Is A20 already on?
	or	ax,ax			;   no, go check it out...
	jz	DiddleIt

	xor	ax,ax			;   yes, try to start off clean
	call	[TempA20Handler]	;   (disabled)

;	Verify that we can turn A20 on and off on command.

DiddleIt:
	mov	cx,1024 		; Diddle A20 this many times to be
					;   somewhat assured it really works.
DiddleAgain:
	push	cx
	mov	ax,1
	call	[TempA20Handler]	; Try to enable A20
	or	ax,ax
	jz	DA20Error		; Nope - phoosh ourselves

	call    IsA20On			; Is A20 on?
	or	ax,ax
	jz	DA20Error		; Nope - phoosh ourselves

	xor	ax,ax
	call	[TempA20Handler]	; Try to disable A20
	or	ax,ax
	jz	DA20Warn

	call    IsA20On			; Is A20 off?
	or	ax,ax
	jnz	DA20Warn

	pop	cx
	loop	DiddleAgain

DA20Okay:
	mov	ax,1			; Able to control A20,
	or	ax,ax			;   success == AX != 0 & CY clear
	ret

DA20Warn:				; Able to enable, but not disable!
	pop	cx			;   warning == AX = 0 & CY clear
	xor	ax,ax
	ret

DA20Error:				; Unable to enable!
	pop	cx			;   error == AX = 0 & CY set
	xor	ax,ax
	stc
	ret

DiddleA20	endp

;****************************************************************************
;*									    *
;*  The following routines install the proper A20 handler for this system.  *
;*  This code is called once during initialization, and then is overwritten *
;*  or discarded.							    *
;*									    *
;****************************************************************************

A20Struc	struc
 pfnDetect	dw	0	; offset of detection routine
 pStart 	dw	0	; A20 handler starting offset
 pEnd		dw	0	; A20 handler ending offset
 fA20Query	db	0	; NZ if handler supports A20 on/off query
 fDelayType	db	0	; -1 normally, otherwise special delay logic
 szName 	dw	0	; offset of handler name string
 bNum		db	0	; A20 handler number			M008
A20Struc ends

;*----------------------------------------------------------------------*
;*									*
;*  InstallA20 -					HARDWARE DEP.   *
;*									*
;*	Attempt to install the proper A20 Handler			*
;*									*
;*  ARGS:   None							*
;*  RETS:   None							*
;*  REGS:   AX, BX, CX, DI, SI, ES and Flags are clobbered		*
;*									*
;*----------------------------------------------------------------------*

	public	InstallA20

InstallA20  proc near

;  If the user selected a specific A20 handler, then use it.

	mov	bx,MachineNum		; if a machine number has been
	cmp	bx,-1			;   selected, use the corresponding
	jz	IA20Detect		;   A20 handler, else try to detect

	mov	ax,size A20Struc	; point to selected handler entry
	mul	bx
	mov	bx,ax
	add	bx,offset A20_scan_table

					; invoke the handler's detection rtn
	call	InsA20Detect		;   in case it needs to set something
					;   up for later use by the handler
	jmp	short InstallA20_Foundit


;  User didn't select A20 hander, detect which one to use.  First look
;  for an external handler.

IA20Detect:
	mov	ax,(INT2F_ID SHL 8) OR INT2F_EXT_A20
	int	2Fh
	cmp	al,80h			; al set to 80h if external handler
	jne	IA20NotExt

	mov	word ptr [lpExtA20Handler],bx	; got one, es:bx = entry point
	mov	word ptr [lpExtA20Handler+2],es

	mov	bx,offset ExtA20Entry
	mov	[bx].fA20Query,cl		; cl = query support flag

	push	dx
	mov	dx, offset InsExtA20Msg ; "Installed external A20 handler."
	call	DispInfoMsg
	pop	dx

	jmp	short InstallA20_Foundit


;  No external A20 handler, go down our internal list of handlers,
;  and pick one.

IA20NotExt:
	mov	bx,offset A20_scan_table

InstallA20_scanloop:
	cmp	bx,offset EndA20_scan_table
	jae	InstallA20_none
	call	InsA20Detect		; is this the one for us?
	or	ax,ax
	jnz	InstallA20_Foundit
	add	bx,size A20Struc
	jmp	short InstallA20_scanloop

; We didn't detect a valid A20 handler, point to error msg & return with error

InstallA20_none:
	mov	dx, offset NoA20HandlerMsg
	stc
	ret


InstallA20_Foundit:
	mov	cl, [bx].bNum
	mov	InstldA20HndlrN, cl	; update the handler number
	xor	cx,cx
	mov	cl,[bx].fA20Query	; global flag for handler supporting
	mov	fA20Check,cl		;   it's own A20 on/off check

	mov	cl,[bx].fDelayType	; flag for special A20 delay routine
	cmp	cl,-1			;   -1 if no special delay required
	jz	@f
	mov	ATA20Delay,cl
@@:
	mov	si,[bx].pStart

	cmp	si,offset _text:AT_A20Handler
	jnz	InsA20AsIs		; if this is the AT handler, do
	cmp	fCPUClock,0		;   we need to install the CPU Clock
	jnz	InsA20AsIs		;   rate prefix?
	mov	si,offset _text:AT_A20Normal	;AT_A20Normal == No
InsA20AsIs:

	mov	cx,[bx].pEnd
	sub	cx,si			; get length of driver to install

	push	cs			; es = cs
	pop	es
	mov	di,offset A20Handler
	rep	movsb			; move it!
	mov	[TopOfTextSeg],di	; keep track of used space

ifndef debug_tsr

;  Display which A20 handler was selected.

	mov	bx,[bx].szName		; skip it if no name string to display
	or	bx,bx
	jz	IA20NoName

	cmp	fQuiet, 0		; skip it if quiet mode
	jnz	IA20NoName

	push	dx			; display which handler installed
	mov	dx, offset InsA20Msg	; "Installed A20 handler number "
	call	DispInfoMsg
@@:
	mov	dl,[bx]
	or	dl,dl			; name string is null, not $ terminated
	jz	@f
	call	DispInfoChar
	inc	bx
	jmp	short @b
@@:
	cmp	ATA20Delay,0		; display which delay code is in effect
	jz	@f			;   (if any)
	mov	dl,','
	call	DispInfoChar
	mov	dl,ATA20Delay
	or	dl,30h
	call	DispInfoChar
@@:
	mov	dl,'.'
	call	DispInfoChar
	pop	dx

IA20NoName:

endif

	ret

; Common routine to invoke A20 handler detect routine

InsA20Detect:
	push	bx			; put A20 handler start address in
	mov	ax,[bx].pStart		;   known location for detect routine
	cmp	ax,offset _text:AT_A20Handler
	jnz	InsA20AsIs_1		; if this is the AT handler, do
	cmp	fCPUClock,0		;   we need to install the CPU Clock
	jnz	InsA20AsIs_1		;   rate prefix?
	mov	ax,offset _text:AT_A20Normal	;AT_A20Normal == No
InsA20AsIs_1:
	mov	TempA20Handler,ax
	call	[bx].pfnDetect		; is this the one for us?
	pop	bx
	ret

;  Note: the following table MUST be in the same order as the entries in
;  the MachineName table.  If you add one here, also add one there!

A20_scan_table	  label byte
	A20Struc <IsPTLCascade,PTL_CASCADE_A20Handler,EndPTL_CASCADE_A20Handler,1,-1,AltName3,3>
	A20Struc <Is6300Plus,$6300PLUS_A20Handler,End6300PLUS_Handler,0,-1,AltName5,5>
	A20Struc <IsPS2Machine,PS2_A20Handler,EndPS2_A20Handler,1,-1,AltName2,2>
	A20Struc <IsHPMachine,HP_A20Handler,EndHP_A20Handler,0,-1,AltName4,4>
	A20Struc <IsFail,ACER_A20Handler,EndACER_A20Handler,0,-1,AltName6,6>
	A20Struc <IsToshiba,AT_A20Handler,EndAT_A20Handler,0,2,AltName7,7>
	A20Struc <IsFail,Wyse_A20Handler,EndWyse_A20Handler,0,-1,AltName8,8>
	A20Struc <IsFail,Wyse_A20Handler,EndWyse_A20Handler,0,-1,AltName9,9>
	A20Struc <IsZBIOS,ZB_A20Handler,EndZB_A20Handler,0,-1,AltName10,10>
	A20Struc <IsFail,AT_A20Handler,EndAT_A20Handler,0,0,AltName11,11>
	A20Struc <IsFail,AT_A20Handler,EndAT_A20Handler,0,1,AltName12,12>
	A20Struc <IsFail,AT_A20Handler,EndAT_A20Handler,0,2,AltName13,13>
	A20Struc <IsPhilips,AT_A20Handler,EndAT_A20Handler,0,2,AltName13,13>
	A20Struc <IsCSS,AT_A20Handler,EndAT_A20Handler,0,1,AltName12,12>
	A20Struc <IsHPVectra,NHP_A20Handler,EndNHP_A20Handler,0,-1,AltName14,14>
	A20Struc <isFail,IC_A20Handler,EndIC_A20Handler,1,-1,AltName15,15>
	A20Struc <IsBM60,BM60_A20Handler,EndBM60_A20Handler,0,-1,AltName16,16>
	A20Struc <isDellXBIOS,Dell_A20Handler,EndDell_A20Handler,0,-1,AltName17,17>
	A20Struc <IsAT,AT_A20Handler,EndAT_A20Handler,0,-1,AltName1,1>
EndA20_scan_table label byte

ExtA20Entry	label	byte
	A20Struc <IsFail,Ext_A20Handler,EndExt_A20Handler,0,-1,0,0>

InstallA20  endp


_text	ends
	end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\himem\himem4.asm ===
;/*
; *                      Microsoft Confidential
; *			 Copyright (C) Microsoft Corporation 1988-1992
; *                      All Rights Reserved.
; */
	page	95,160
	title	himem4 - block allocation stuff (common to both 286&386)

	.xlist
	include	himem.inc
	.list

;	The stuff we provide:

	public	Version
	public	GetExtMemoryInfo
	public	LockExtMemory
	public	UnlockExtMemory
	public	end_of_hiseg
	public	textseg
	public	KiddValley
	public	KiddValleyTop
	public	segKiddValley
	public	cHandles

	public	ValidateHandle
	public	BlkMovX

;	externals from himem.asm

	extrn	PrevInt15:dword
	extrn	fHMAMayExist:byte
	extrn	fHMAExists:byte
	extrn	winbug_fix:word
	extrn	FLclEnblA20:far
	extrn	FLclDsblA20:far

        extrn   pAddMem:word

ifdef debug_tsr

	extrn	pQuery:dword
        extrn   pAlloc:dword
        extrn   pFree:dword
        extrn   MoveIt:dword
        extrn   pGetInfo:dword
        extrn   pRealloc:dword

else

	extrn	pQuery:word
        extrn   pAlloc:word
        extrn   pFree:word
        extrn   MoveIt:word
        extrn   pGetInfo:word
        extrn   pRealloc:word

endif

_text	ends

funky	segment	word public 'funky'
	assume	cs:funky,ds:_text

	extrn	mmove_segreinit:near
	extrn	IsCPU286:near
	extrn	end_of_funky_seg:near

ifndef debug_tsr
		org	HISEG_ORG
endif

;-----------------------------------------------------------------
; Following entries must be kept together in the same order

	public	HandleInfo
HandleInfo	label	byte
		db	1		; info structure version #
		db	SIZE Handle	; size of handle entries
cHandles	dw	DEFHANDLES	; number of handles
KiddValley	dw	end_of_funky_seg; The address of the handle table
segKiddValley	dw	seg funky	; segment of handle table
KiddValleyTop	dw	0		; end of handle table

; Above entries must be kept together in the same order
;-----------------------------------------------------------------

	public	LEnblA20
	public	LDsblA20

end_of_hiseg	dw	End286
textseg		dw	_text
LEnblA20	dd	_text:FLclEnblA20
LDsblA20	dd	_text:FLclDsblA20
;*----------------------------------------------------------------------*
;*									*
;*  Get XMS Version Number -				FUNCTION 00h    *
;*									*
;*	Returns the XMS version number					*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = XMS Version Number					*
;*	BX = Internal Driver Version Number				*
;*	DX = 1 if HMA exists, 0 if it doesn't				*
;*  REGS:   AX, BX and DX are clobbered					*
;*									*
;*  INTERNALLY REENTRANT						*
;*									*
;*----------------------------------------------------------------------*


Version	proc    far

	mov	ax,XMSVersion
	mov	bx,HimemVersion
	xor	dh,dh

;	Is Int 15h hooked?

	cmp	word ptr [PrevInt15][2],0	; Is the segment non-zero?
	jne     VHooked
	mov	dl,[fHMAMayExist]		; No, return the status at
	ret					;  init time.

VHooked:
	mov	dl,[fHMAExists]			; Yes, return the real status
	ret

Version	endp

;*----------------------------------------------------------------------*
;*									*
;*  LockExtMemory -					FUNCTION 0Ch    *
;*									*
;*	Locks a block of extended memory				*
;*									*
;*  ARGS:   DX = 16-bit handle to the extended memory block		*
;*  RETS:   AX = 1 of successful, 0 otherwise.	BL = Error code		*
;*	DX:BX = 32-bit linear address of the base of the memory block   *
;*  REGS:   AX, BX, DX and Flags clobbered				*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

LockExtMemory proc far

	cli 				; This is a non-reentrant function

	call    ValidateHandle		; Is the handle valid?
	jnc     LEMBadh
	mov     bx,dx			; Move the handle into BX

;	Are we at some preposterously large limit?

	cmp	[bx].cLock,0FFh
	je	LEMOverflow

	inc	[bx].cLock		; lock the block

	mov	dx, [bx].Base.hi	; return the 32-bit address of base
	mov	bx, [bx].Base.lo

	mov	ax, bx			; save low 16 bits
	shl	dx, 10			; *1024 of hi 16 bits
	shl	bx, 10			; *1024 of low 16 bits
	shr	ax, 06			; take the overflow into account
	or	dx, ax

	mov	ax,1			; return success
	ret

LEMBadh:
	mov	bl,ERR_INVALIDHANDLE
	jmp	short LEMErrExit

LEMOverflow:
	mov	bl,ERR_LOCKOVERFLOW
LEMErrExit:
	xor     ax,ax			; Return failure
	mov	dx,ax
	ret

LockExtMemory endp


;*----------------------------------------------------------------------*
;*									*
;*  UnlockExtMemory -					FUNCTION 0Dh    *
;*									*
;*	Unlocks a block of extended memory				*
;*									*
;*  ARGS:   DX = 16-bit handle to the extended memory block		*
;*  RETS:   AX = 1 if successful, 0 otherwise.	BL = Error code		*
;*  REGS:   AX, BX and Flags clobbered					*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

UnlockExtMemory proc far

	cli				; This is a non-reentrant function

	call    ValidateHandle		; Is the handle valid?
	jnc     UEMBadh
	mov	bx,dx			; Move the handle into BX

	cmp	[bx].cLock,0		; is handle locked?
	je	UEMUnlocked		; No, return error

	dec	[bx].cLock		; Unlock the block

	mov     ax,1			; Return success
	xor     bl,bl
	ret

UEMUnlocked:
	mov	bl,ERR_EMBUNLOCKED
	jmp	short UEMErrExit

UEMBadh:
	mov	bl,ERR_INVALIDHANDLE
UEMErrExit:
	xor	ax,ax
	ret

UnlockExtMemory endp

;*----------------------------------------------------------------------*
;*									*
;*  ValidateHandle -							*
;*									*
;*	Validates an extended memory block handle			*
;*									*
;*  ARGS:   DX = 16-bit handle to the extended memory block		*
;*  RETS:   Carry is set if the handle is valid				*
;*  REGS:   Preserved except the carry flag				*
;*									*
;*----------------------------------------------------------------------*

ValidateHandle proc near

	push	ax
	push	bx
	push	cx
	push	dx

	mov	bx,dx		; Move the handle into BX

;	The handle must be equal to or above "KiddValley".

	cmp	bx,[KiddValley]
	jb	VH9f

;	The handle must not be above "KiddValleyTop".

	cmp	bx,[KiddValleyTop]
	ja	VH9f

;	(The handle-"KiddValley") must be a multiple of a handle's size.

	sub	dx,[KiddValley]
	mov	ax,dx
	xor	dx,dx
	mov	cx,SIZE Handle
	div	cx
	or	dx,dx		; Any remainder?
	jnz     VH9f 		; Yup, it's bad

;	Does the handle point to a currently USED block?

	cmp	[bx].Flags,USEDFLAG
	jne     VH9f 		; This handle is not being used.

;	The handle looks good to me...

	stc			; return success
VH9:
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret

VH9f:

;	It's really bad.
	clc 			; Return failure
	jmp	short vh9	; we can take a performance hit if it is
				;  a bad handle
	ret

ValidateHandle endp

BlkMovX	proc	near
	assume	ds:_text
	jmp	MoveIt
BlkMovX	endp

.286p
	include	himem4a.asm
.386p
	include	himem4b.asm
.286p	
;*----------------------------------------------------------------------*
;*									*
;*  InstallMoveBlock -					HARDWARE DEP.   *
;*									*
;*	Copies 386 move down on top of 286 move and adjusts end pointer *
;*	  if needed.  Also performs mmove_segreinit to set segment	*
;*	  of the installed move routine.				*
;*									*
;*  ARGS:   None							*
;*  RETS:   None							*
;*  REGS:   AX, CX, DX, DI, SI, ES and Flags are clobbered		*
;*									*
;*----------------------------------------------------------------------*

	public	InstallMoveBlock

SKEW	equ	(offset Begin386 - offset Begin286)

InstallMoveBlock proc far
	assume	ds:_text,es:nothing

	call	IsCPU286
	jz	IMB_done		; done if cpu is 286

	mov     si,offset Begin386
	mov	cx,(offset End386-offset Begin386)
	push	ds			; save _text segment

	push	cs			; es = cs
	pop	es
	push	cs
	pop	ds			; ds = cs
	assume	ds:nothing

	mov	di,offset Begin286
	rep	movsb			; move it!

	pop	ds			; restore ds -> _text
	assume	ds:_text
	mov	end_of_hiseg,di		; save new end of hi segment

        ; For the TSR version, these jump labels point to dwords.  For the
        ; DOS device driver version, these jump labels point to word offsets.

ifdef debug_tsr

        ; All these functions live in the 'funky' segment.  We need to patch
        ; up their selectors to match the new hiseg value after compacting in
        ; pack_and_truncate().

	mov	MoveIt.off, offset MoveExtended386
	mov	pQuery.off, (offset QueryExtMemory - SKEW)
	mov	pAlloc.off, (offset AllocExtMemory - SKEW)
	mov	pFree.off, (offset FreeExtMemory - SKEW)
	mov	pGetInfo.off, (offset GetExtMemoryInfo - SKEW)
	mov	pRealloc.off, (offset ReallocExtMemory - SKEW)

else

	mov	MoveIt, offset MoveExtended386
	mov	pQuery, (offset QueryExtMemory - SKEW)
	mov	pAlloc, (offset AllocExtMemory - SKEW)
	mov	pFree, (offset FreeExtMemory - SKEW)
	mov	pGetInfo, (offset GetExtMemoryInfo - SKEW)
	mov	pRealloc, (offset ReallocExtMemory - SKEW)

endif

        ; pAddMem should be a word offset for both Himem versions - TSR and
        ; DOS device driver.

	mov	pAddMem, (offset AddMem - SKEW)

IMB_done:
	push	cs
	pop	es			; point es: to new segment
	call	mmove_segreinit		; now adjust the segment stuff
	ret				; far return
InstallMoveBlock endp


;*----------------------------------------------------------------------*
;*									*
;*  NOTE: RequestUMB and ReleaseUMB will not be implemented by HIMEM.	*
;*									*
;*----------------------------------------------------------------------*

funky	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\himem\himem5.asm ===
;/*
; *                      Microsoft Confidential
; *			 Copyright (C) Microsoft Corporation 1988-1992
; *                      All Rights Reserved.
; */
	page	95,160
	title	himem5.asm - Extended Memory Moves

;
;----------------------------------------------------------------------------
;
; M001 : inserted a jmp $+2 between an out & in while reading the ISR
; M003 : fixed bug to do with not returning int 15h errors on a blockmove
;	call.
; M006 : Preserve _textseg in DS.
;
;----------------------------------------------------------------------------
;
	.xlist
	include	himem.inc
	.list


	extrn	TopOfTextSeg:word
	extrn	hiseg:word
	extrn	pReqHdr:dword
	extrn	dd_int_loc:word
	extrn	interrupt:word

ifdef debug_tsr

	extrn	pVersion:dword
	extrn	pQuery:dword
        extrn   pAlloc:dword
        extrn   pFree:dword
        extrn   pLock:dword
        extrn   pUnlock:dword
        extrn   MoveIt:dword
        extrn   pGetInfo:dword
        extrn   pRealloc:dword

endif

	extrn	fInHMA:byte
	extrn	EndText:byte
_text	ends

funky	segment	word public 'funky'
	assume	cs:funky

	extrn	KiddValley:word
	extrn	KiddValleyTop:word
	extrn	segKiddValley:word
	extrn	end_of_hiseg:word
	extrn	textseg:word

	extrn	CS0:word, CS1:word, LCSS:word, CSDES:word
	extrn	Patch3:word, descCS:byte, OurGDT:byte, GDTPtr:byte

;*----------------------------------------------------------------------*
;*									*
;*   pack_and_truncate - packs everything down into the			*
;*	lowest available memory and sets up variable for driver		*
;*	truncation, then terminates.					*
;*									*
;*----------------------------------------------------------------------*

	public	pack_and_truncate
pack_and_truncate	proc	far

	assume	ds:_text,es:nothing
	push	ds
	mov	dx, offset _text:EndText	; end of text seg
	add	dx, 15
	and	dx, not 15		; size of text seg including init code

	mov	ax, TopOfTextSeg	; end of resident text seg
	or	ax, ax
	jnz	@f
	xor	di, di
	pop	es
	jmp	InitFailed
	
@@:
	add	ax, 15
	and	ax, not 15		; size of resident text seg

	sub	dx, ax			; size of memory whole between
	shr	dx, 4			;  resident text seg and funky seg
					;  The funky seg should be moved down
					;  'dx' number of paragraphs
	mov	ax, hiseg		; Get the current seg at which funky
					;  is running from

	cmp	ax, dx			; If funky is already running from a
					;  segment value less than 'dx'
					;  number of paras funky can be
					;  moved to zero segment only
	jbe	@f
	mov	ax, dx			; ax has min of seg of funky
					;             & memory whole size in para
@@:
	or	ax, ax			; if funky is to be moved by zero
					;  paras our job is over
	jnz	@f
	mov	si, end_of_hiseg	; init regs for entry into
					;  MoveTableHandle label
	mov	di, si
	mov	es, hiseg
	mov	ds, hiseg
	jmp	short MoveHandleTable
@@:
	mov	dx, hiseg		; current segment value of funky
	push	ds
	pop	es
	assume	es:_text
	mov	ds, dx			; which is our source for move
	assume	ds:nothing
	sub	dx, ax			; less the 'paras' to be shrinked
	mov	hiseg, dx		; is the new seg value of funky
	mov	es, dx			; which is our dest. for the move
	assume	es:nothing
	mov	si, HISEG_ORG
	mov	di, si
	mov	cx, end_of_hiseg
	sub	cx, si			; size of funky without ORG
	cld
	rep	movsb			; move it!!!

;;
MoveHandleTable:
	inc	di			; round to word value
	and	di,0fffeh

	mov	si,di
	assume	es:funky
	mov	es:[segKiddValley], es	; segment of handle table
	xchg	si,es:KiddValley	; replace KiddValley with new location
	mov	cx,es:KiddValleyTop
	sub	cx,si
;
COMMENT ^
LBL	label byte
;
LBLOFF	= ( (offset LBL) - (offset MoveBlock286) )
SIZE286	= ( SizeMoveBlock286 + (MAXHANDLES * (size Handle)) )
SIZE386	= ( SizeMoveBlock386 + (MAXHANDLES * (size Handle)) )
IF ( SIZE286 GT LBLOFF )
 %OUT HANDLE TABLE OVERFLOWING INTO INIT CODE ON 286!!!
 .ERR
ENDIF
;;
IF ( SIZE386 GT LBLOFF )
 %OUT HANDLE TABLE OVERFLOWING INTO INIT CODE ON 386!!!
 .ERR
ENDIF
;;
^
	rep	movsb			; move the handle table down
	mov	es:KiddValleyTop,di	; update end of table
	call	mmove_segreinit		; set the memory mover up
	assume	es:nothing

	pop	ds			; restore _text segment
	assume	ds:_text

ifdef debug_tsr

        ; We need to patch up the selector values for the far function
        ; addresses in ControlJumpTable for those functions that live in the
        ; 'funky' segment.

	mov     ax, hiseg
	mov     pVersion.sel, ax
	mov     pQuery.sel, ax
        mov     pAlloc.sel, ax
        mov     pFree.sel, ax
        mov     pLock.sel, ax
        mov     pUnlock.sel, ax
        mov     MoveIt.sel, ax
        mov     pGetInfo.sel, ax
        mov     pRealloc.sel, ax

endif

	add	di,15			; round new segment to paragraph
	and	di,not 15

InitFailed:
ifdef	debug_tsr
	mov	ax,ds			; # paragraphs to keep =
	mov	dx,es			;   (ES - DS) +
	sub	dx,ax			;      (DI >> 4) +
	mov	ax,di			;	 10h
	shr	ax,4
	add	dx,ax
	add	dx,10h			; PSP size
	mov	ax,3100h
	int	21h
else

	push	ds			; save textseg		M006
	lds	si,[pReqHdr]		; discard the initialization code
	mov	word ptr ds:[si].Address[0],di
	mov	word ptr ds:[si].Address[2],es
	mov	ds:[si].Status,100h	; Store return code - DONE
	pop	ds			; restore textseg	M006

	pop	ax			; throw away return from InitDriver

	push	cs
	call	an_iret			; call an iret in our segment

	or	di, di
	jz	we_are_quitting


	mov	dd_int_loc,offset Interrupt	; replace Interrupt with
						; tiny permanent stub

	mov	ax, es:KiddValleyTop	; M006
	sub	ax, es:KiddValley	; M006
	add	ax, es:end_of_hiseg	; M006

	sub	ax, HISEG_ORG		; size of resident funky including
	mov	cs:HMALen, ax

	mov	ax, ((multMULT shl 8)+multMULTGETHMAPTR)
	xor	bx, bx			; in case there is no HMA handler
	int	2fh
	cmp	cs:HMALen, bx
	ja	we_are_quitting

	cmp	di, HISEG_ORG
	ja	we_are_quitting

	mov	bx, cs:HMALen
	mov	ax, ((multMULT shl 8)+multMULTALLOCHMA)
	int	2fh
	cmp	di, 0ffffh
	je	we_are_quitting

	call	MoveHi

we_are_quitting:
	pop	bp
	pop	si
	pop	di
	pop	es
	pop	ds
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret				; far return from driver init
endif

pack_and_truncate	endp

HMALen		dw	?		; Length of funky (without init code)


;
;---------------------------------------------------------------------------
;
; procedure : MoveHi
;
;---------------------------------------------------------------------------
;
MoveHi	proc	near
	push	ds			; M006
	push	di			; remember offset in HMA
	mov	si, HISEG_ORG
	mov	cx, cs:HMALen

;	mov	ax, textseg		; DS is already inited to textseg
;	mov	ds, ax

	assume	ds:_text
	mov	ds, hiseg
	assume	ds:nothing
	rep	movsb			; move it to HMA
	pop	di			; get back offset in HMA
	mov	ax, HISEG_ORG
	sub	ax, di
	shr	ax, 1
	shr	ax, 1
	shr	ax, 1
	shr	ax, 1
	mov	bx, es
	sub	bx, ax


;	mov	ax, textseg
;	mov	ds, ax			; get addressability to text seg		

	pop	ds			; M006

	assume	ds:_text
	mov	fInHMA, 1		; Flag that we are running from HMA

	mov	hiseg, bx
	mov	es, bx
	mov	es:[segKiddValley], es

	call	mmove_segreinit		; update the mem mover segments

	mov	di, TopOfTextSeg	; end of resident text code

	mov	ax, ds			; M006

	lds	si, pReqHdr
	assume	ds:nothing

	mov	word ptr ds:[si].Address[0],di
	mov	word ptr ds:[si].Address[2],ax
	
	ret
MoveHi	endp

;
an_iret proc near
	iret
an_iret	endp

;*----------------------------------------------------------------------*
;*									*
;*   mmove_segreinit - sets segment of memory move routine		*
;*									*
;*	es: new segment value						*
;*									*
;*----------------------------------------------------------------------*

	public	mmove_segreinit

mmove_segreinit proc near
	assume	ds:nothing,es:nothing
	call	IsCPU286
	jnz	mmove_segre_386

	assume	es:funky		; note: es = new funky segment
;					;       cs = current funky segment
	mov	ax,es
	mov	es:[cs0],ax			; Patch far jumps to restore
	mov	es:[cs1],ax			; Patch far jumps to restore
	inc	ax				;* Trick 3
	mov	es:[LCSS],ax
	dec	ax
	mov	dx,16
	mul	dx				; Believe or not, this is
	mov	es:[CSDES].seg_base_lo,ax	; faster than a 32 bit shift
	mov	es:[CSDES].seg_base_hi,dl
	ret

;	Install the 386 MoveBlock routine.

mmove_segre_386:
	mov     ax,es			; dx has CS of codeg
	mov     es:[patch3],ax 		; Patch code
	mov     cx,16
	mul     cx
	mov     es:[descCS].LO_apDesc386,ax ; Set up selector for our CS
	mov     es:[descCS].MID_apDesc386,dl
	add	ax,offset OurGDT	; Calculate Base of GDT
	adc     dx,0
	mov     es:[GDTPtr.LO_apBaseGdt],ax
	mov     es:[GDTPtr.HI_apBaseGdt],dx
	assume	es:nothing
	ret

mmove_segreinit endp

;
;------------------------------------------------------------------------
;
; procedure : MmovSegReinit
;
;             Interface rooutine to call mmove_segreinit as a far rtn
;
;------------------------------------------------------------------------
;
		public	MmovSegReinit
MmovSegReinit	proc	far
		call	mmove_segreinit
		ret
MmovSegReinit	endp

;*----------------------------------------------------------------------*
;*									*
;*   IsCPU286 -- returns zero true if CPU is a pre-386 (286)		*
;*									*
;*	Trashes AX                                                      *
;*									*
;*      M006 - preserve state of flags during check
;*----------------------------------------------------------------------*

        public  IsCPU286
IsCPU286 proc	near
	pushf
        pop     ax                      ; Get flags into AX
        or      ax,0F000h		; Set the top bits, preserve the low
	push    ax
	popf
	pushf				; Try and get it back out
	pop     ax
	test    ax,0F000h		; If the top four bits are zero...
	                                ;  it's an 80-286
        ret                             ; Return the Z flag				

IsCPU286 endp


	public	end_of_funky_seg
end_of_funky_seg:
funky	ends
	end



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\himem\himem2.asm ===
;/*
; *                      Microsoft Confidential
; *			 Copyright (C) Microsoft Corporation 1988-1992
; *                      All Rights Reserved.
; */
	page	95,160
	title   'HIMEM2 - Initialization code'

funky	segment word public 'funky'
	extrn	InstallMoveBlock:near	; in high segment
	extrn	textseg:word		; in high segment
	extrn	KiddValley:word
	extrn	KiddValleyTop:word
	extrn	segKiddValley:word
	extrn	cHandles:word
	extrn	pack_and_truncate:near
	extrn	MmovSegReinit:far
	extrn	end_of_funky_seg:byte
	extrn	LEnblA20:word
	extrn	LDsblA20:word
funky	ends

	.xlist
	include	himem.inc		; get structures, equ's, etc.
					;  and open segment
	.list

	public	f000
	public	InitInterrupt
	public	MachineNum

;************************************************************************
;*									*
;*  Global Variables							*
;*									*
;************************************************************************

	extrn	pPPFIRET:word
	extrn	dd_int_loc:word
	extrn	Interrupt:near
	extrn	hiseg:word
	extrn	call_hi_in_di:near
	extrn	fCanChangeA20:byte
	extrn	fHMAMayExist:byte

	extrn	fVDISK:byte
	extrn	IsVDISKIn:near

	extrn	A20Handler:near
	extrn	EnableCount:word
	extrn	MemCorr:word
	extrn	MinHMASize:word

ifdef debug_tsr
	extrn	MoveIt:dword
else
	extrn	MoveIt:word
endif

	extrn	pReqHdr:dword
	extrn	PrevInt2f:dword
	extrn	TopOfTextSeg:word

	extrn	InstallA20:near
	extrn	Int2fHandler:near
	extrn	Is6300Plus:near
	extrn	IsA20On:near

	extrn	pAddMem:word
	extrn	SignOnMsg:byte
	extrn	ROMDisabledMsg:byte
	extrn	UnsupportedROMMsg:byte
	extrn	ROMHookedMsg:byte
	extrn	BadDOSMsg:byte
	extrn	NowInMsg:byte
	extrn	On8086Msg:byte
	extrn	NoExtMemMsg:byte
	extrn	FlushMsg:byte
	extrn	StartMsg:byte
	extrn	HandlesMsg:byte
	extrn	HMAMINMsg:byte
	extrn	KMsg:byte
	extrn	NoHMAMsg:byte
	extrn	A20OnMsg:byte
	extrn	HMAOKMsg:byte
	extrn	VDISKInMsg:byte
	extrn	BadArgMsg:byte

	extrn	DevAttr:word
	extrn	Int15MemSize:word
	extrn	pInt15Vector:word

	extrn	PrevISAInt15:dword
	extrn	ISA15Handler:near

	extrn	EndText:byte

	extrn	XMMControl:far
	extrn	pfnEnabA20:word
	extrn	pfnDisabA20:word
	extrn	LocalEnableA20:near
	extrn	LocalDisableA20:near

;************************************************************************
;*									*
;*   Code/Data below here will be discarded after driver initialization *
;*									*
;************************************************************************

;	Discardable Initialization Data

pCOMPAQ		label	dword	; Pointer to COMPAQ specific for BIM
		dw	0FFE8h	;
		dw	0F000h	;
pBIMGDT 	dw	offset BIMGDT	    ; Offset to BIMGDT for BIM alloc'n
GetBIMMemProc	dw	offset GetBIMMemory ; Offset of GetBIMMemory procedure
BIMBase 	dw	0	; Base address and Lenght of remaining Compaq
BIMLength	dw	0	;   Built-In Memory (set at Init time)

BIMBuffer	dw	?	; Buffer for unlock/lock ROM for BIM
	public	fShadowOff, f1stWasWarning

fShadowOff	db	0	; NZ if shadow RAM should be disabled,
				;   0/1 set by command line switch, 0FFh
				;   set if little extended and hope to disable

f1stWasWarning	db	0	; NZ if 1st attempt to diddle A20 generated
				; a warning (and not an error)
	public	fA20Control

fA20Control	db	0ffh	; NZ if himem should take control of A20, even
				;   it was already on when himem loaded.

	public	fCPUClock

fCPUClock	db	0	; NZ if himem should try to preserve CPU clock
				;   speed when gating A20

fEISA		db	0	; NZ if himem should take all EISA memory
				;   blocks
		public	fQuiet
fQuiet		db	0ffh	; NZ if himem should be quiet during install

fSignOnMsg	db	0	; NZ if sign on msg has been displayed

fBigMem 	db	0ffh	; NZ if ISA memory above 16 meg allowed

fNumHandSet	db	0	; NZ if /NUMHANDLES= parameter used
fHMAminSet	db	0	; NZ if /HMAMIN= parameter used


; Parameter tables for GetParms

ParmEntry   struc
cParmChar   db	    0		; 1st char of option on cmd line
pParmRtn    dw	    0		; offset of routine to process option
ParmEntry   ends

; The 1st table is for parameters that have no arguments

ParmTbl1 label	 byte
	ParmEntry   <'E',GPGotEisa>		; /EISA
	ParmEntry   <'V',GPGotVerbose>		; /VERBOSE
	ParmEntry   <'N',GPGotBigMem>		; /NOABOVE16
	ParmEntry   <'Z',GPZSwitch>		; /Z
	db	0				; ** END OF TABLE **

; The 2nd table is for parameters with arguments

ParmTbl2 label	 byte
	ParmEntry   <'H',GPGotMin>		; /HMAMIN=
	ParmEntry   <'N',GPGotHands>		; /NUMHANDLES=
	ParmEntry   <'M',GPGotMachine>		; /MACHINE:
	ParmEntry   <'A',GPGotA20Control>	; /A20CONTROL:
	ParmEntry   <'S',GPGotShadow>		; /SHADOWRAM:
	ParmEntry   <'I',GPGotInt15>		; /INT15=
	ParmEntry   <'C',GPGotCPUClock> 	; /CPUCLOCK:
	db	0				; ** END OF TABLE **


	public	StringParm, MachineNum, MachineName

StringParm	db	13 DUP (' ')

MachineNum	dw	-1

;  Note: the following table MUST be in the same order as the entries in the
;  A20_Scan_Table!  If you add entries here, also add one there!

MachineName	label	byte
	db	'ptlcascade',0		; Phoenix Cascade BIOS
	db	'att6300plus',0 	; AT&T 6300 Plus
	db	'ps2',0 		; IBM PS/2
	db	'hpvectra',0		; HP 'Classic' Vectra (A & A+)
	db	'acer1100',0		; Acer 1100
	db	'toshiba',0		; Toshiba 1600 & 1200XE
	db	'wyse',0		; Wyse 12.5 MHz 286 machine
	db	'tulip',0		; Tulip machines
	db	'zenith',0		; Zenith ZBIOS
	db	'at1',0 		; IBM AT/delay 0
	db	'at2',0 		; IBM AT/delay 1
	db	'at3',0 		; IBM AT/delay 2
	db	'philips',0		; Philips machines
	db	'css',0			; CSS Lab machines
	db	'fasthp',0		; Single byte method for HP Vectras
	db	'ibm7552',0		; IBM 7552 Industrial Computer
	db	'bullmicral',0		; Bull Micral 60 M004
	db	'dell',0		; DELL XBIOS		; M010
	db	'at',0			; IBM AT
	db	0FFh			; end of table

;NOTE: there is code in GetParms which depends on AltNameTbl coming
;      after MachineName table.

	public	AltName1, AltName2, AltName3, AltName4, AltName5
	public	AltName6, AltName7, AltName8, AltName9, AltName10
	public	AltName11, AltName12, AltName13, AltName14, AltName15
	public	AltName16,AltName17	;M004

AltNameTbl	label	byte
AltName3    db	'3',0			; Phoenix Cascade BIOS
AltName5    db	'5',0			; AT&T 6300 Plus
AltName2    db	'2',0			; IBM PS/2
AltName4    db	'4',0			; HP 'Classic' Vectra (A & A+)
AltName6    db	'6',0			; Acer 1100
AltName7    db	'7',0			; Toshiba 1600 & 1200XE
AltName8    db	'8',0			; Wyse 12.5 Mhz 286 machine
AltName9    db	'9',0			; Tulip machine
AltName10   db	'10',0			; Zenith ZBIOS
AltName11   db	'11',0			; IBM AT/delay 0
AltName12   db	'12',0			; IBM AT/delay 1
AltName13   db	'13',0			; IBM AT/delay 2
	    db	'13',0			; Philips machines (same as AT3)
	    db	'12',0			; CSS machines
AltName14   db	'14',0			; Single byte HP Vectra m/cs
AltName15   db	'15',0			; IBM 7552 Industrial Computer
AltName16   db	'16',0			; Bull Micral 60          M004
AltName17   db	'17',0
AltName1    db	'1',0			; IBM AT
	    db	0FFh			; end of table

ifdef	debug_tsr	;-----------------------------------------------

;*----------------------------------------------------------------------*
;*									*
;*  ExeStart -								*
;*									*
;*	Entry point when himem is invoked as an .EXE.			*
;*									*
;*----------------------------------------------------------------------*

lpCmdLine	dd	81h		; far ptr to command tail

	public	ExeStart

ExeStart:

	mov	word ptr cs:[lpCmdLine+2],es	; save PSP segment in pointer

	mov	ax,cs		; Setup segment regs to all be the same
	mov	ds,ax
	mov	es,ax

	call	InitDriver	; Initialize...

	mov	ax,TopOfTextSeg	; TopOfTextSeg == 0 is error installing
	or	ax,ax
	jnz	@f

	mov	ax,4C03h	; error, so just terminate
	int	21h
@@:
	mov	di,offset pack_and_truncate
	jmp	call_hi_in_di	; terminate and stay resident

endif			;------------------------------------------------



;*----------------------------------------------------------------------*
;*									*
;*  InitInterrupt -							*
;*									*
;*	Called by MS-DOS immediately after Strategy routine		*
;*									*
;*  ARGS:   None							*
;*  RETS:   Return code in Request Header's Status field		*
;*  REGS:   Preserved							*
;*									*
;*	This entry point is used only during initialization.		*
;*	It replaces itself with a much shorter version which only	*
;*	serves to report the appropriate errors when this driver	*
;*	is called in error.						*
;*									*
;*----------------------------------------------------------------------*

InitInterrupt   proc    far

	; Save the registers including flags.

	push    ax		; We cannot use pusha\popa because
	push    bx		;	we could be on an 8086 at this point
	push    cx
	push    dx
	push    ds
	push    es
	push    di
	push    si
	push    bp
	pushf

	push	cs		; Set DS=CS for access to global variables.
	pop	ds

	les	di,[pReqHdr]	; ES:DI = Request Header

	mov     bl,es:[di].Command ; Get Function code in BL

	or	bl,bl		; Only Function 00h (Init) is legal
	jz	IInit

	cmp     bl,16		; Test for "legal" DOS functions
	jle     IOtherFunc

IBogusFunc:
	mov     ax,8003h	; Return "Unknown Command"
	jmp     short IExit

IOtherFunc:
	xor     ax,ax		; Return zero for unsupported functions
	jmp     short IExit

IInit:
	call    InitDriver	; Initialize the driver
	les	di,[pReqHdr]	; Restore es:di = Request Header

IExit:
	or	ax,0100h	; Turn on the "Done" bit
	mov	es:[di].Status,ax ; Store return code

	popff			; restore the registers
	pop	bp
	pop	si
	pop	di
	pop	es
	pop	ds
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	mov	dd_int_loc,offset Interrupt	; replace Interrupt with
	ret					; tiny permanent stub

InitInterrupt   endp

;*----------------------------------------------------------------------*
;*									*
;*  InitDriver -							*
;*									*
;*	Called when driver is Initialized.				*
;*									*
;*  ARGS:   ES:DI = Address of the Request Header			*
;*  RETS:   pHdr.Address = Bottom of resident driver code		*
;*  REGS:   AX, CX and Flags are clobbered				*
;*									*
;*----------------------------------------------------------------------*

	public	InitDriver

InitDriver  proc    near

	cld

ifndef	debug_tsr
	call	LocateHiSeg	; locate the hiseg in low memory properly

	mov	di, offset MMovSegReinit
	mov	es, hiseg
	push	cs
	call	call_hi_in_di	; re-initialize the mem mover

	mov	ax,cs
	push	es
	mov	es,hiseg
	assume	es:funky
	add	textseg,ax	; relocate text segment pointer
	add	LEnblA20+2, ax	; update ptrs to enble & disable a20 rtns
	add	LDsblA20+2, ax
	pop	es
	assume	es:nothing
endif

	mov	ah,30h		; make sure we've got DOS 3.00 or higher
	int	21h		; Get DOS versions number
	cmp	al,3
	jae     IDCheckXMS

	mov	dx,offset BadDOSMsg
	jmp	IDFlushMe

IDCheckXMS:
	mov	ax,(INT2F_ID SHL 8) OR INT2F_INS_CHK
	int	2Fh		; make sure there's no other XMS installed
	cmp	al,80h		; Is INT 2F hooked?
	jne     IDNotInYet
	mov	dx,offset NowInMsg
	jmp	IDFlushMe

IDNotInYet:
	xor     ax,ax			; Move 0 into the Flags register
	push    ax
	popf
	pushf				; Try and get it back out
	pop     ax
	and     ax,0F000h		; If the top four bits are set...
	cmp     ax,0F000h
	mov	dx,offset On8086Msg	; we're on an 8086
	jnz	@f
	jmp	IDFlushMe		; so crap out
@@:
	call	GetInt15Memory		; If Int 15h/88h reports < 384k of
	cmp	ax,384			;   extended memory available, then
	jae	@f			;   we will try to increase memory
	mov	fShadowOFF,0FFh 	;   by stealing shadow RAM
@@:
	call	GetParms		; process command line parameters

	mov	ah, 2			; Force VERBOSE mode if user is
	int	16h			;   holding down the Alt key
	test	al, 08h 		; Int 16h/2 == Get Keyboard Flags
	jz	@f			;   08h set if Alt key down
	mov	fQuiet, 0
@@:

ifndef	debug_tsr
	call	DispSignOnMsg
endif
	mov	di,offset InstallMoveBlock ; install moveblock function
	push	cs			; setup for far return
	call	call_hi_in_di		; call into high segment

	call	IsA20On 		; Is A20 already enabled?
	or	ax,ax			;   (may zap cx, si, di)
	jz	IDInsA20		;   no, go install A20 handler

	mov	dx,offset A20OnMsg	; "A20 already on" message
	cmp	fA20Control,0		; should we take control of A20 anyway?
	jne	IDInsA20		;   yes, go muck with it
	mov	[fCanChangeA20],0	;   no,  don't allow changing of A20
	call	DispInfoMsg		;	 and tell user about it
	jmp	short IDAfterA20

IDInsA20:
	call	InstallA20		; install proper A20 handler
	jnc	@f
	jmp	IDFlushMe		; CY means fatal error
@@:

;	Note:  A side affect of the previous InstallA20 is that MemCorr
;	  is set to reflect the adjustment factor if we're on an AT&T 6300+

IDAfterA20:
	call	InitHandles	; initialize handle table

	call	ScanEISA	; scan EISA memory into table

	call	CheckZBim	; Check for & allocate Zenith BIM

	call	CheckBIM	; Check for & allocate Compaq BIM

;	Turn off shadow RAM if desired/possible

	cmp	fShadowOFF,0	; should shadow RAM be turned off?
	jz	@f

	call	ShadowRAMOff	; try to turn it off--also adds to free list

	or	dx,dx		; display a msg if ShadowRAMOff is
	jz	@f		;   pointing to one
	call	DispInfoMsg
@@:
	call	IsVDISKIn		; Is a VDISK style allocator already
	cmp	[fVDISK],0		;   installed?	Don't bother to load
	jz	@f			;   if so, cause we'll just fail all
	mov	dx,offset VDISKInMsg	;   future calls anyway...
	jmp	short IDFlushMe
@@:

;	Looks like himem will install, allocate Big ISA memory (above 16 meg)
;	now if available

	cmp	[fBigMem], 0		; Was parameter specified?
	je	@f			; NO: don't bother trying to get it
	call	GetBIGMemory		; Get extra ISA memory
@@:

	call    GetInt15Memory	; how much extended memory is installed?
	cmp     ax,64		; Is there >= 64K of extended?
	jae	IDHMAOK

	push	es
	mov	es,hiseg
	assume	es:funky
	mov	bx,[KiddValley]	; get size of memory we already have in tables
	mov	cx,[cHandles]

IDAnyMem:
	cmp	[bx].Flags,FREEFLAG
	jnz	IDAnyMem_1	; brif not a valid free block
	mov	ax, [bx].Len.hi
	or	ax, [bx].Len.lo
	jnz	IDAnyMem_2
IDAnyMem_1:
	add	bx,SIZE Handle
	loop	IDAnyMem
IDAnyMem_2:
	pop	es
	assume	es:nothing

	mov	dx,offset NoHMAMsg
	or	ax,ax			; no HMA, any other memory to control?
	jnz	disp_hma_msg		; jmp if some memory

;	We can't find any memory to manage.

	mov	dx,offset NoExtMemMsg

;	Display the message in DX followed by the "Flush" message.

IDFlushMe:
	call	DispErrMsg
	mov	dx,offset FlushMsg
	call	DispErrMsg

	xor	ax,ax			; discard the driver
	mov	[TopOfTextSeg],ax

ifndef	debug_tsr			;-------------------------------
	les	di,[pReqHdr]
	mov	es:[di].Units,al
	and	cs:DevAttr,not 8000h	; clr bit 15 in attrib of driver header
endif
	jmp	short IDReturn		;-------------------------------

IDHMAOK:
	mov     [fHMAMayExist],1
	mov	dx,offset HMAOKMsg
disp_hma_msg:
	call	DispInfoMsg

	call    HookInt2F		; "turn on" the driver

;	Initialization finished (or failed) -- return to caller

IDReturn:

ifndef	debug_tsr			;-------------------------------
	mov	di,offset pack_and_truncate
	jmp	call_hi_in_di		; pack stuff down and terminate
else
	mov	ax, hiseg		; make sure far pointer to handle
	mov	es, ax			;   table has correct segment
	mov	es:[segKiddValley], ax
endif					;-------------------------------
	ret

InitDriver	endp

;----------------------------------------------------------------------------
;  DispXxxMsg Routines -- Display informational, error or sign on messages,
;			  if enabled by /VERBOSE parameter.  Error msgs
;			  are displayed regardless of /VERBOSE.
;  Entry:
;	DX = offset of msg to display
;  Exit:
;
;  Used:
;	AX
;----------------------------------------------------------------------------
	public	DispInfoMsg, DispInfoChar, DispErrMsg

DispInfoMsg	proc	near
	cmp	cs:[fQuiet], 0		; display an informational msg if
	jnz	short DIM_ret		;   not in QUIET mode
	call	DispSignOnMsg		; make sure user sees signon msg
	mov	ah, 9
	int	21h
DIM_ret:
	ret
DispInfoMsg	endp


DispInfoChar	proc	near
	cmp	cs:[fQuiet], 0
	jnz	short DIC_ret
	call	DispSignOnMsg		; make sure user sees signon msg
	mov	ah, 2
	int	21h
DIC_ret:
	ret
DispInfoChar	endp


DispErrMsg	proc	near		; display an error msg
	mov	cs:[fQuiet], 0		; no longer in QUIET mode
	call	DispSignOnMsg		; make sure user sees signon before
	mov	ah, 9			;   error msg
	int	21h
	ret
DispErrMsg	endp


DispSignOnMsg	proc	near
	cmp	cs:[fQuiet], 0		; don't signon if in QUIET mode
	jnz	short DSM_ret
	cmp	cs:[fSignOnMsg], 0	; don't signon more than once
	jnz	short DSM_ret
	push	dx			; display the signon message
	push	ds
	push	cs			; in case ds != _text
	pop	ds
	mov	ah, 9
	mov	dx,offset SignOnMsg
	int	21h
	mov	cs:[fSignOnMsg], 0FFh
	pop	ds
	pop	dx
DSM_ret:
	ret
DispSignOnMsg	endp

;
;----------------------------------------------------------------------------
; procedure : LocateHiSeg
;
;		Locate the movable segment properly in the low seg.
;		taking care of the stripped ORG zeroes. This function
;		calculates the segment at which the hiseg should run
;		with the ORG. If the segment cvalue goes below zero the
;		code is moved up high enough to run the code from a seg value
;		of zero.
;
;		This function assumes that the 'funky' segment follows
;		immediately after the text seg.
;
;----------------------------------------------------------------------------
; 
LocateHiSeg	proc	near
	push	ds
	mov	ax, cs				; para start of text seg
	mov	cx, offset _text:EndText	; end of text seg
	add	cx, 15				; para round it
	shr	cx, 1
	shr	cx, 1
	shr	cx, 1
	shr	cx, 1
	add	ax, cx				; para start of funky seg
	cmp	ax, (HISEG_ORG shr 4)		; will the seg go below zero?
	jb	MoveHiSeg			; yeah, we have to move it
	sub	ax, (HISEG_ORG shr 4)		; no, it fits in
	pop	ds
	mov	hiseg, ax			; update the segment in which
						;   it is going to run from.
	ret
MoveHiSeg:
	mov	ds, ax				; segment at which funky
						;  resides without the ORG
 	xor	ax, ax
 	mov	es, ax				; we want to movve the code
						;  to 0:HISEG_ORG
	mov	di, offset funky:end_of_funky_seg
	mov	si, di
	sub	si, HISEG_ORG
	mov	cx, si
	dec	di
	dec	si
  	std					; move backward (safe when
						;  source & dest overlap
    	rep	movsb
	cld
    	pop	ds
    	mov	hiseg, 0			; funky is going to run from
						;  segment zero
    	ret
LocateHiSeg	endp


;*----------------------------------------------------------------------*
;*									*
;*  HookInt2F -								*
;*									*
;*	Insert the INT 2F hook						*
;*									*
;*  ARGS:   None							*
;*  RETS:   None							*
;*  REGS:   AX, SI, ES and Flags are clobbered				*
;*									*
;*----------------------------------------------------------------------*

	public	HookInt2F

HookInt2F   proc    near

	cli
	xor	ax,ax
	mov	es,ax
	mov	si,2Fh * 4		; save previous int2f vector
	mov	ax,offset Int2FHandler	; and exchange with new one
	xchg    ax,es:[si][0]
	mov	word ptr [PrevInt2F][0],ax
	mov	ax,cs
	xchg    ax,es:[si][2]
	mov	word ptr [PrevInt2F][2],ax
	sti
	ret

HookInt2F   endp



;*----------------------------------------------------------------------*
;*									*
;*  ShadowRAMOff -							*
;*									*
;*	Attempt to turn off shadow RAM on selected machines.  Add the	*
;*	memory to our free pool if successful.				*
;*									*
;*  ARGS:   None							*
;*  RETS:   DX	- Msg to show user (or 0), &				*
;*	    CY clear - success, 					*
;*	    CY set   - warning/failed					*
;*  REGS:   AX destroyed						*
;*									*
;*----------------------------------------------------------------------*

	public	ShadowRAMOff

ShadowRAMOff	proc	near

	push	es
	push	di
	push	si
	push	cx
	push	bx

	call	Compaq386		; on a Compaq 386?
	jz	SOIsCompaq
	jmp	SONotCompaq

;	Disable shadow RAM on a Compaq 386

SOIsCompaq:
					; check if the video bios points
	xor	ax,ax			;   into the ROM copy, we don't
	mov	es,ax			;   want to disable if someone has
	mov	ax,es:[10h*4+2] 	;   already hooked Int 10h, 1Fh, 43h,
	call	IsC000orE000		;   or 6Dh
	jnz	SORomHooked
	mov	ax,es:[1Fh*4+2]
	call	IsC000orE000
	jnz	SORomHooked
	mov	ax,es:[43h*4+2]
	call	IsC000orE000
	jnz	SORomHooked

	cmp	word ptr es:[6dh*4+2],0C000h	; finally, make sure Int 6Dh
	jae	SOVideoOkay			;   points somewhere reasonable

SORomHooked:
	mov	dx,offset ROMHookedMsg	; somebody has video ROM hooked!
	jmp	short SONoCanDo

SOVideoOkay:

;	Check to see if this machine allows the ROM to be unmapped

	call	unmap_permited
	jc	SOROMNotSupported

;	Looks good, lets disable the RAM copy.	This is done by doing
;	an Int 15h blockmove of a command word to the Compaq diagnostic
;	register.  We share data structures with the Compaq BIM code.

	mov	si,pBIMGDT		; setup block move GDT
	mov	ax,cs
	mov	es,ax
	mov	cx,16
	mul	cx
	add	ax,offset BIMBuffer
	adc	dl,0
	mov	[si].S_BASE_LOW,ax
	mov	[si].S_BASE_HI,dl
	mov	cx,1

	mov	word ptr [BIMBuffer],0FFFFh	; disable ROM replace command

	mov	ah,87h
	int	15h

;	Point the video vectors back at the original ROM

	mov	ax,0
	mov	es,ax
	mov	ax,0C000h
	mov	es:[10h*4+2],ax
	mov	es:[1Fh*4+2],ax
	mov	es:[43h*4+2],ax

;	If Int 6Dh points at the now disabled ROM, change that too

	cmp	word ptr es:[6Dh*4+2],0E000h
	jnz	@f
	mov	es:[6Dh*4+2],ax
@@:

;	Add the ram space to our free list

	mov	ax,128				;128k @ FE0000h
	mov	cx,3F80h			;  (FE0000h / 1024)
	xor	dx, dx
	mov	bx, dx

	mov	di, pAddMem
	push	cs
	call	call_hi_in_di

	mov	dx,offset ROMDisabledMsg	; Success!
	clc

SODone:
	pop	bx
	pop	cx
	pop	si
	pop	di
	pop	es
	ret


SONotCompaq:
SOROMNotSupported:

	mov	dx,offset UnsupportedROMMsg	; don't know how to disable

SONoCanDo:					; only show msg if user wanted
	cmp	fShadowOFF,0FFh 		; to disable--if trying cause
	jnz	SOFailed			; of too little extended mem,
	xor	dx,dx				; keep quiet.

SOFailed:
	stc
	jmp	short SODone

ShadowRAMOff	endp


IsC000orE000	proc

	cmp	ax,0C000h			; Video ROM pointers can
	jz	@f				;   point to either of
	cmp	ax,0E000h			;   these locations, but
@@:	ret					;   no others.

isC000orE000	endp


;------------------------------------------------------------------------
;  UNMAP_PERMITED - This function will check if unmap roms is available.
;
;  Entry:    Nothing.
;
;  Returns:  Carry Flag Clear -  Can Unmap
;	     Carry Flag Set   -  Can Not Unmap
;
;------------------------------------------------------------------------

MACHINE_ID    equ  25h

unmap_permited	proc near		; == Check if unmap roms permitted ==

	mov	al, MACHINE_ID		; CMOS location to read
	out	70h, al 		; Out CMOS location address
	in	al, 71h 		; Read data at that location
	or	al, al			; Q: Is it Zero
	jz	unmap_permited_error	;  Y: Can not unmap
	test	al, 1000b		; Q: can we unmap (Soft drive type)
	jz	unmap_permited_ok	;  Y: continue

unmap_permited_error:
	stc				; Set error condition - Can not unmap

unmap_permited_ok:
	ret				; Done

unmap_permited	endp

;*----------------------------------------------------------------------*
;*									*
;*  GetBIMMemory -							*
;*									*
;*	Look for Compaq 'Built In Memory' and add it to the pool of	*
;*  available memory							*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = Amount of BIM memory found				*
;*  REGS:   AX, BX, CX, and Flags are clobbered				*
;*									*
;*----------------------------------------------------------------------*

; "Built In Memory" (BIM) starts at FE00:0000h and grows downward.  It is
; controlled by a data structure at F000:FFE0h.  Changing the data structure
; involves un-write-protecting the ROMs (!) by flipping bit 1 of 80C00000.

pBIMSTRUCT  equ     0FFE0h
AVAILABLE   equ     0		; Set to -1 if BIM isn't around
TOTALBIM    equ     2		; Total amount of BIM in the system
AVAILBIM    equ     4		; Amount of BIM available in paragraphs
LASTUSED    equ     6		; Paragraph address of last (lowest) used
				;  paragraph of BIM

GDT_TYPE    struc
	dw	0,0,0,0
	dw	0,0,0,0

S_LIMIT     dw	1
S_BASE_LOW  dw	0
S_BASE_HI   db	0
S_RIGHTS    db	93h
S_RESERVED  dw	0

D_LIMIT     dw	1
D_BASE_LOW  dw	0000h
D_BASE_HI   db	0C0h
D_RIGHTS    db	93h
D_RES386    db	0
D_BASE_XHI  db	080h

	dw	0,0,0,0
	dw	0,0,0,0
GDT_TYPE    ends

BIMGDT	GDT_TYPE <>


GetBIMMemory proc near

	xor     ax,ax

;	Are we on a Compaq 386 machine?

	push    bx
	push    es

;	Is there a 32-bit memory board installed?

	mov	es,cs:WORD PTR (pCOMPAQ+2) ; ROM segment
	mov     bx,pBIMSTRUCT
	mov     bx,es:[bx]		; De-reference the pointer
	mov     dx,es:[bx+AVAILABLE]    ; -1 means no board is installed
	inc     dx
	jz	FCMNoMem2		; Nope, return

;	How much memory is available and where does it start?

	mov     dx,es:[bx+AVAILBIM]     ; Size in paragraphs
	or	dx,dx			; Any left?
	jz	FCMNoMem2
	mov     cx,dx			; CX = Size in paragraphs
	mov     ax,es:[bx+LASTUSED]
	sub     ax,cx			; AX = Starting location - F0000h
					;  in paragraphs
	push    es			; Save for a rainy day...
	push    bx
	push    ax

	shr     ax,4			; get base address in KBytes
	add     ax,0f000h
	shr     ax,2

	shr     cx,6			; get the size in Kbytes

	mov     [BIMBase],ax		; store for use by HookInt15
	mov     [BIMLength],cx

;	Un-WriteProtect the ROMs.

	mov     si,pBIMGDT		; Set up the BlockMove GDT
	mov     ax,cs
	mov     es,ax
	mov     cx,16
	mul     cx
	add     ax,offset BIMBuffer
	adc     dl,0
	mov     [si].S_BASE_LOW,ax
	mov     [si].S_BASE_HI,dl
	mov     cx,1

	mov     word ptr [BIMBuffer],0fefeh ; 0feh unlocks the ROMs

	mov     ah,87h			; Do the BlockMove
	int     15h
	or	ah,ah			; Was there an error?
	jz	FCMReserve		; Nope - continue

;	Return error.

	pop     ax			; Clean up
	pop     bx
	pop     es
	xor     ax,ax
	mov     [BIMBase],ax
	mov     [BIMLength],ax
FCMNoMem2:
	jmp     short FCMNoMem

;	Change the ROM values to reserve the BIM stuff.

FCMReserve:
	pop     ax
	pop     bx
	pop     es
	mov     word ptr es:[bx+AVAILBIM],0 ; Reserve all remaining BIM
	mov     word ptr es:[bx+LASTUSED],ax

;	Re-WriteProtect the ROMs.

	push    cs
	pop     es
	mov     si,pBIMGDT		; Set up the BlockMove GDT

	mov     word ptr [BIMBuffer],0fcfch ; 0fch locks the ROMs

	mov     ah,87h			; Do the BlockMove
	int     15h

	mov     ax,1			; Return success

FCMNoMem:
	pop     es
	pop	bx
	ret
EndGetBIMMemory:

GetBIMMemory endp


;*----------------------------------------------------------------------*
;*									*
;*  CheckBIM -								*
;*									*
;*	Check if Compaq built in memory is available			*
;*									*
;*  ARGS:   AX = Kbytes of int 15 memory				*
;*  RETS:   AX = Amount of BIM and int 15 memory			*
;*  REGS:   AX and Flags are clobbered					*
;*									*
;*----------------------------------------------------------------------*

	public	CheckBIM

CheckBIM  proc	near
	push	es
	push	bx
	push	dx

	call	Compaq386	; Are we on a Compaq 386 machine?
	jnz	CBNoBIM 	; N: return

	mov	bx,pBIMSTRUCT	; ROM data sructure
	mov	bx,es:[bx]	; pointer to BIM data structure
	mov	dx,es:[bx+AVAILABLE] ; -1 means no board is installed
	inc	dx		;Q: Is there a 32-bit memory board installed?
	jz	CBNoBIM		; N: return
				; Y: How much memory is available?
	mov	dx,es:[bx+AVAILBIM] ; Size in paragraphs
	or	dx,dx		;Q: Any BIM available?
	jz	CBNoBIM		; N: return

	call	getBIMMemory	; allocate it and get base/size

;	Just allocate the damn BIM memory now.  (Used to be a big headache
;	  to install a deferred BIM driver, depending on whether Shadow
;	  RAM was disabled.)

	mov	cx,[BIMBase]		;   add Compaq BIM to our free list
	jcxz	CBNoBIM
	mov     ax,[BIMLength]
	xor	dx, dx
	mov	bx, dx

	mov	di, pAddMem
	push	cs
	call	call_hi_in_di

CBNoBIM:
	pop	dx
	pop	bx
	pop	es
	ret
CheckBIM  endp


;*----------------------------------------------------------------------*
;*									*
;*  Compaq386 - 							*
;*									*
;*	Check if running on a Compaq 386 system.			*
;*									*
;*  ARGS:   none							*
;*  RETS:   Z set - on a Compaq 386, NZ - not Compaq 386		*
;*	    ES = ROM segment						*
;*  REGS:   Flags are clobbered 					*
;*									*
;*----------------------------------------------------------------------*

szCOMPAQ    db	'03COMPAQ'

	public	Compaq386

Compaq386	proc	near

	push	si
	push	di
	push	cx

	les	di,cs:pCOMPAQ		; Are we on a Compaq 386 machine?
	mov	si,offset szCOMPAQ
	mov	cx,8
	cld
	rep	cmpsb			;Q: Are we?

	pop	cx
	pop	di
	pop	si

	ret

Compaq386	endp

;*----------------------------------------------------------------------*
;*									*
;*  CheckZBim -								*
;*									*
;*	Check if Zenith Bim (0fa0000h x 256K) is available		*
;*	   Call AddMem with it if so					*
;*									*
;*----------------------------------------------------------------------*

ZDS_string	db	'ZDS CORP'
ZDS_len	=	($-ZDS_string)

f000		dw	0f000h

	public	CheckZBIM

CheckZBim	proc	near

	call	GetInt15Memory		; This code added for old systems with
	cmp	ax, 2048		;   low memory, skip it if 'sufficient'
	jae	no_ZBIM 		;   ext memory cause it scribbles on
					;   memory just below 16 meg

	cld				; better safe than sorry

	mov	si,offset ZDS_string
	mov	es,f000
	mov	di,800ch		; look for ZDS CORP at f000:800c
	mov	cx,ZDS_len
	repz	cmpsb
	jnz	no_ZBim			; done if not Zenith machine

;	Now we've got to go out and look for 256KBytes at 0fa0000h
;	  Let's use the BlockMove function to help us with that so we
;	  don't have to write any messy protect mode code.  We'll
;	  snag a handle and set up a dummy block while we work.

	cli
	push	es
	mov	es,hiseg
	assume	es:funky
	mov	di,[KiddValley]
	mov	cx,[cHandles]

chk_zb0:
	cmp	[di].Flags,UNUSEDFLAG
	jz	ZBim_01			; brif found free handle
	add	di,SIZE Handle
	loop	chk_zb0
	pop	es
	sti				; restore interrupts
no_ZBim:
	ret

ZBim_01:
	mov	[di].cLock,1		; lock it
	mov	[di].Base.lo,3e80h	; number of K at 0fa0000h
	mov	[di].Base.hi,0
	mov	[di].Len.lo,256
	mov	[di].Len.hi, 0
	mov	[di].Flags, USEDFLAG
	pop	es
	assume	es:nothing
	sti

	mov	save_ss,ss		; get more elbow room for this
	mov	save_sp,sp
	push	cs
	pop	ss
	mov	sp,offset EISA_stack

;	allocate a move structure on the stack
;	  for now, we'll just test the first 512 bytes.  It might be
;	  a good idea to test the whole damn thing, but a lot more work.

	sub	sp,0fffeh and (1+SIZE MoveExtendedStruc)
	push    ss			; point es:si to stack frame
	pop	es
	mov	si,sp

	mov	es:[si].SourceHandle,0	; move from conventional memory
	mov	es:[si].DestHandle,di	; to our fake block at 0fa0000h
	mov	es:word ptr [si].DestOffset,0 ; move data to base of block
	mov	es:word ptr [si].DestOffset+2,0

	mov	es:word ptr [si].SourceOffset,8000h
	mov	es:word ptr [si].SourceOffset+2,0f000h	; move from ROM
	mov	es:word ptr [si].bCount,512	; move 512 bytes
	mov	es:word ptr [si].bCount+2,0

	push	si			; save move structure
	push    di			; save handle

	push	cs			; fake far call
	call	BlockMove

	pop	di
	pop	si

;	now move the 512 bytes back out into our buffer and compare

	push	ss
	pop	es
	mov	es:[si].SourceHandle,di	; move from the fake block
	mov	es:[si].DestHandle,0	; to conventional memory
	mov	es:word ptr [si].DestOffset,offset ZDS_Buffer
	mov	es:word ptr [si].DestOffset+2,cs
	mov	es:word ptr [si].SourceOffset,0
	mov	es:word ptr [si].SourceOffset+2,0

	push	di			; save handle for deallocation

	push	cs			; fake far call
	call	BlockMove


;	now all we've gotta do is see if the ZDS_Buffer matches the
;	  first 512 bytes of the ROM at 0f000:8000

	mov	es,f000
	mov	di,8000h
	mov	si,offset ZDS_Buffer
	mov	cx,256			; 256 words
	repz	cmpsw			; does it match?
	jnz	check_zb1		; done if not

;	Use AddMem to add the memory to our pool, even though we
;	  could have just marked the fake block we allocated as UNUSED.
;	  Why?  What if some other source (like and EISA BIOS) also
;	  told us about that same memory?  We might as well take advantage
;	  of all of the smarts in AddMem to eliminate overlaps.

	mov	cx,3e80h		; add memory to pool then
	mov	ax,256
	xor	dx, dx
	mov	bx, dx

	mov	di, pAddMem
	push	cs
	call	call_hi_in_di

;	Now we've got to fill the damn block, cuz the
;	  parity isn't initialized yet.

	push	ds
	pop	es
	mov	di,offset ZDS_Buffer
	mov	cx,256
	xor	ax,ax
	rep	stosw			; fill 512 byte block with zeros

	push	ss			; point es: to stack frame again
	pop	es
	mov	es:[si].SourceHandle,0	; move from conventional memory
	pop	di
	push	di			; get handle from stack
	mov	es:[si].DestHandle,di	; to our fake block at 0fa0000h
	mov	es:word ptr [si].DestOffset,0 ; move data to base of block
	mov	es:word ptr [si].DestOffset+2,0

	mov	es:word ptr [si].SourceOffset,offset ZDS_Buffer
	mov	es:word ptr [si].SourceOffset+2,cs	; move from ZDS_Buffer
	mov	es:word ptr [si].bCount,512	; move 512 bytes
	mov	es:word ptr [si].bCount+2,0
	mov	cx,512			; 256K/512 bytes
zfill_loop:
	push	es
	push	si
	push	cx

	push	cs			; fake far call
	call	BlockMove

	pop	cx
	pop	si
	pop	es
	add	es:word ptr [si].DestOffset,512
	jnc	zfill_skip
	inc	es:word ptr [si].DestOffset+2
zfill_skip:
	loop	zfill_loop

check_zb1:

;	Release the move structure stack frame

	pop	di			; restore temporary handle
	add	sp,0fffeh and (1+SIZE MoveExtendedStruc)
	push	es
	mov	es,hiseg
	assume	es:funky
	mov	[di].Flags,UNUSEDFLAG	; then handle is free again
	pop	es
	assume	es:nothing

	mov	ss,save_ss
	mov	sp,save_sp		; restore normal stack

	ret

CheckZBim	endp

;	Call MoveIt function in other segment.  Make sure we enable A20.

BlockMove	proc	near

ifdef debug_tsr
        jmp     MoveIt
else
	mov	di,MoveIt		; get function in funky segment
	jmp	call_hi_in_di
endif

BlockMove	endp

;*----------------------------------------------------------------------*
;*									*
;*  GetInt15Memory -							*
;*									*
;*	Returns the amount of memory INT 15h, Function 88h says is free	*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = Amount of free extended memory in K-bytes		*
;*  REGS:   AX and Flags are clobbered					*
;*									*
;*----------------------------------------------------------------------*


GetInt15Memory proc near

	mov	ah,88h			; snag the int 15h memory
	clc
	int	15h			; Is Function 88h around?
	jnc     xret_geti15
	xor	ax,ax			; No, return 0
xret_geti15:

ifdef WIN30COMPATIBLE
	cmp	ax,15*1024		; Limit himem.sys to using 15 meg
	jb	@f			;   of extended memory for apps
	mov	ax,15*1024		;   that don't deal with > 24 bit
@@:					;   addresses
endif
	ret

GetInt15Memory endp

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  GetBIGMemory -                                                          *
;*                                                                          *
;*      Returns the amount of memory Extended INT 15h, >16 Meg              *
;*      Uses new INT 15 function E801                                       *
;*                                                                          *
;*  ARGS:   None                                                            *
;*  RETS:   None							    *
;*  REGS:   AX and Flags are clobbered                                      *
;*                                                                          *
;*--------------------------------------------------------------------------*

GetBIGMemory proc near

        push    dx
        push    cx
        push    bx
        push    si
        push    es

        call    IsEISAMachine       ; Is this an EISA machine ?
	jc	short GBM_end	    ;  Y: Ignore parameter

	call	Compaq386	    ; is it a Compaq system?
	jnz	short GBM_end

        mov     ax,0E801h           ; determine >16M memory
        clc
	int	15h		    ; Is Function 88h around?
	jc	short GBM_end	    ; No, exit

        mov     ax,bx               ; DX:AX to = length of block in 1K blocks
        mov     dx,64               ; DX should always be zero (16M extra max)
        mul     dx

        mov     cx,BIGISA_START     ; BIGISA_START=16384 in (HIMEM.INC)
	xor	dx, dx
	mov	bx, dx

	mov	di, pAddMem
	push	cs
	call	call_hi_in_di	    ; add that memory to our tables

        les     si,dword ptr pInt15Vector   ; Save the current INT 15 vector.

	cli
        mov     ax,offset ISA15Handler      ; Exchange the old vector with
        xchg    ax,es:[si][0]               ;  the new one.
        mov     word ptr [PrevISAInt15][0],ax
        mov     ax,cs
        xchg    ax,es:[si][2]
	mov	word ptr [PrevISAInt15][2],ax
	sti

GBM_end:
        pop     es
        pop     si
        pop     bx
        pop     cx
        pop     dx
        ret

GetBIGMemory endp

;*--------------------------------------------------------------------------*
;*                                                                          *
;*  IsEISAMachine                                           HARDWARE DEP.   *
;*                                                                          *
;*  Determine if we are on an EISA machine                                  *
;*                                                                          *
;*  ARGS:   None                                                            *
;*  RETS:   CY = 1 if we're on a EISA machine                               *
;*             = 0 otherwise                                                *
;*  REGS:   Flags clobbered                                                 *
;*                                                                          *
;*--------------------------------------------------------------------------*

pEISASTRUC  equ     0FFD9h      ; offset to EISA name in ROM
pROM	    equ     0F000h	; ROM segment

IsEISAMachine     proc    near                                            ;

        push    es                      ; save registers we'll use
        push    bx                      ;  ...

    ;-----------------------------------------
    ; Determine if this is an EISA system by
    ;  looking for ROM signature
    ;-----------------------------------------
        mov     bx,pROM
        mov     es,bx                   ; ROM segment
        mov     bx,pEISASTRUC           ; offset to EISA name
        cmp     word ptr es:[bx],'IE'   ; Q: is this an 'EISA' system
        jne     short IEM_NO            ;  N: set flag and return
        cmp     word ptr es:[bx+2],'AS' ;
        je      short IEM_YES           ;  Y: set flag and return

IEM_NO:
        clc                             ; Not an EISA machine...
        jmp     short IEM_Done

IEM_YES:
        stc                             ; Yes, it is an EISA box
IEM_Done:
        pop     bx
        pop     es

        ret

IsEISAMachine        endp

;*----------------------------------------------------------------------*
;*									*
;*  GetParms -								*
;*									*
;*	Get any parameters off of the HIMEM command line		*
;*									*
;*  ARGS:   None							*
;*  RETS:   None							*
;*  REGS:   AX, BX, CX, DX, DI, SI, ES and Flags clobbered		*
;*									*
;*  Side Effects:   cHandles and MinHMASize may be changed		*
;*									*
;*----------------------------------------------------------------------*

GPArgPtr	dd	?
GPRegSave	dw	?

	public	GetParms

GetParms    proc    near

	cld				; better safe than sorry

	push	ds

ifdef	debug_tsr			;-------------------------------
	lds	si,lpCmdLine
else					;-------------------------------
	les	di,[pReqHdr]		; Running as a device driver
	lds	si,es:[di].pCmdLine	; DS:SI points to first char
					;   after "DEVICE="
@@:	call	GPGetChar		; Skip over driver name, up to
	jc	GPDatsAll		;   first blank or / or eol
	jz	GPNextArg
	cmp	al,'/'
	jnz	@b
	dec	si			; Backup to get / again
endif					;-------------------------------

	assume	ds:nothing,es:nothing

;	Scan until we see a non-blank or the end of line.

GPNextArg:
	call	GPGetChar
	jc	GPDatsAll		; eol
	jz	GPNextArg		; blank

	mov	word ptr cs:[GPArgPtr], si	; save ptr to start of arg
	mov	word ptr cs:[GPArgPtr+2], ds	;   incase we want to complain
	dec	word ptr cs:[GPArgPtr]		;   (GPGetChar points at next)

	cmp	al,'/'			; better be a / or not a valid arg
	jz	GPGotOne

;	Detected invalid parameter or value, complain to user

GPBadParm:
	mov	ah,9			; tell'm something isn't right
	push	cs
	pop	ds
	mov	dx, offset BadArgMsg
	call	DispErrMsg

	lds	si,cs:[GPArgPtr]	; backup to last parameter

GPBadDisp:
	call	GPGetChar		; disp arg up to space or eol
	jc	GPDatsAll		;  skips over bad arg while we're at it
	jz	GPNextArg

	cmp	al,'/'				; start of next arg?
	jnz	@f
	dec	si				; maybe yes, maybe no--might
	cmp	si,word ptr cs:[GPArgPtr]	;   be same arg
	jnz	GPNextArg			;   next, go process new arg
	inc	si				;   same, keep displaying
@@:
	mov	dl,al
	call	DispInfoChar
	jmp	short GPBadDisp

;	Finished, we're outta here...

GPDatsAll:
	jmp	GPExit

;	Save what we found and try to process as parameter without argument

GPGotOne:
	lodsb
	mov	cs:[GPRegSave],ax

	mov	bx, offset ParmTbl1	; Process parameters with no arguments
	call	GPCheckParm
	jc	GPNeedParm		; CY means it wasn't processed

GPSkip2Next:				; Parameter was processed, skip
	call	GPGetChar		;   over any remaining text in the
	jc	GPDatsAll		;   parameter name
	jz	GPNextArg
	cmp	al,'/'
	jnz	GPSkip2Next
	dec	si			; backup to get / again
	jmp	GPNextArg

;	Must need an argument -- scan for a number, EOL, or a space.

GPNeedParm:
	call	GPGetChar
	jc	GPBadParm
	jz	GPBadParm	; blank
	cmp	al,':'		; start of string arg
	je	GPString
	cmp	al,'='
	jne	GPNeedParm

;	Read the number at DS:SI into DX

GPNeedNum:
	call	GPGetChar
	jc	GPDatsAll
	cmp	al,'0'
	jb	GPNeedNum
	cmp	al,'9'
	ja	GPNeedNum

	xor	dx,dx
GPNumLoop:
	sub	al,'0'
	cbw
	add	dx,ax
	call	GPGetChar
	jc	GPNumDone
	jz	GPNumDone
	cmp	al,'0'
	jb	GPBadParm
	cmp	al,'9'
	ja	GPBadParm
	shl	dx,1		; Stupid multiply DX by 10
	mov	bx,dx
	shl	dx,1
	shl	dx,1
	add	dx,bx
	jmp	short GPNumLoop

;	Move the string arg from ds:si to StringParm

GPString:
	mov	cx,(SIZE StringParm) - 1
	push	cs
	pop	es
	mov	di,offset _text:StringParm

GPStrLoop:
	call	GPGetChar
	jc	GPStrDone
	jz	GPStrDone
	stosb
	loop	GPStrLoop

GPStrDone:

	mov	byte ptr es:[di],0	; Null terminate the string
	mov	dx,-1			; In case parm expects a num, give'm
					;   a likely invalid one

;	Which parameter are we dealing with here?

GPNumDone:
	xchg	ax,cs:[GPRegSave]

	mov	bx, offset ParmTbl2	; parameters with arguments
	call	GPCheckParm		; process it valid
	jnc	GPNextParm
	jmp	GPBadParm

GPNextParm:
	mov	ax,cs:[GPRegSave]	; are we at the end of the line?
	cmp	al,13			; may not be needed any longer...
	je	GPExit
	cmp	al,10
	je	GPExit
	jmp	GPNextArg

GPExit:
	call	GPPrintInfo		; Display user messages
	pop	ds
	ret

GetParms    endp


;*----------------------------------------------------------------------*

; In:  AL =  1st character of parameter
;      BX -> Parameter table to use
; Out: CY set if parameter not matched
;      CY clear if parameter matched, and routine will be called

GPCheckParm	proc	near

GPCP_loop:
	cmp	cs:[bx].cParmChar, 0	; end of table?
	je	GPCP_failed

	cmp	cs:[bx].cParmChar, al	; match?
	je	GPCP_match

	add	bx, SIZE ParmEntry
	jmp	short GPCP_loop

GPCP_match:
	clc				; got it, call routine to process
	call	cs:[bx].pParmRtn	; (handler returns with CY clr or set)
	ret

GPCP_failed:
	stc				; no match
	ret

GPCheckParm	endp


;*----------------------------------------------------------------------*

; Routines to process specific command line parameters

GPDoParameters	proc	near


;---------------------------------------

GPGotEISA:				; /EISA
	mov	fEISA, 0FFh
	ret				; (CY already clear)

GPGotVerbose:				; /VERBOSE
	mov	fQuiet, 0
	ret				; (CY already clear)

GPGotBigMem:				; /NOABOVE16
	cmp	byte ptr [si], 'O'	; /NOABOVE16 & /NUMHANDLES= both start
	jne	GPBadParmRet		;   with 'N', make sure only /NOABOVE16
					;   is processed here.
	mov	fBigMem, 0
	ret				; (CY already clear)

;	The /Z switch is for compatibility with pervious version of himem.
;	By default, himem will now call it's own XMMControl entry point to
;	enable/disable A20 around calls to himem code in the HMA.  The
;	external calls allow XMS hookers (like EMM386) to see the A20
;	changes.  The previous behavior of calling internal A20 routines
;	can be selected with the /Z switch in case the external (recursive)
;	calls cause compatibility problems with other software.

GPZSwitch:				; /Z switch

	mov	cs:[pfnEnabA20],  offset _text:LocalEnableA20
	mov	cs:[pfnDisabA20], offset _text:LocalDisableA20

	ret				; (CY already clear)

;---------------------------------------
;	Process /A20CONTROL: parameter

GPGotA20Control:
	mov	ax,word ptr [StringParm]
	or	ax,2020h
	mov	bl,0FFh
	cmp	ax,'no' 		; ON ?	- means we take control
	jz	GPSetA20
	inc	bl
	cmp	ax,'fo' 		; OFF ? - means we leave alone if on
	jz	GPSetA20

GPBadParmRet:				; common failure exit
	stc
	ret

GPSetA20:
	mov	fA20Control,bl		; Z if A20 should be left alone if
					;   it's already on when we're loaded

GPGoodParmRet:				; common success exit
	clc
	ret

;---------------------------------------
;	Process /MACHINE: parameter.

GPGotMachine:
	push	si				; save current location
	push	ds				;    in param string

	push	cs
	pop	ds
	mov	di,offset _text:MachineName	; es:di -> MachineName

GPNextTbl:
	xor	bx,bx

GPNextName:
	mov	si,offset _text:StringParm	; ds:si -> StringParm

GPChkNext:
	cmp	byte ptr es:[di],0FFh		; end of name table?
	jz	GPNoName

	lodsb				; char from StringParm
	cmp	al,'A'			; force to lower case for match
	jb	@f			; (might be numeric, so don't just OR)
	cmp	al,'Z'
	ja	@f
	or	al,20h
@@:
	cmp	al,es:[di]		; match so far?
	jnz	GPFlushName

	or	al,al			; finished if matched up to & incl NULL
	jz	GPFoundName

	inc	di			; still matches, check next char
	jmp	short GPChkNext

GPFlushName:
	inc	bx
GPFN2:
	inc	di
	cmp	byte ptr es:[di],0FFh
	jz	GPNoName

	cmp	byte ptr es:[di],0
	jnz	GPFN2
	inc	di
	jmp	short GPNextName

GPFoundName:
	mov	cs:[MachineNum],bx	; found a match, remember which entry
	jmp	short GPNameDone	;   it is for later

GPNoName:

	cmp	di,offset _text:AltNameTbl
	ja	GPBadName
	mov	di,offset _text:AltNameTbl
	jmp	short GPNextTbl

GPNameDone:
	pop	ds			; recover parm line pointer
	pop	si
	jmp	GPGoodParmRet

GPBadName:
	pop	ds			; clear stack and error out...
	pop	si
	jmp	GPBadParmRet

;---------------------------------------
;	Process /NUMHANDLES= parameter.

GPGotHands:
	cmp	dx,MAXHANDLES
	jna	@f
	jmp	GPBadParmRet
@@:
	or	dx,dx		; Zero?
	jnz	@f
	jmp	GPBadParmRet
@@:
	push	es
	mov	es,hiseg
	assume	es:funky
	mov     [cHandles],dx ; Store it
	pop	es
	assume	es:nothing

	mov	fNumHandSet, 0FFh

	jmp	GPGoodParmRet

;---------------------------------------
;	 Process /HMAMIN= parameter

GPGotMin:
	cmp	dx,64
	jna	@f
	jmp	GPBadParmRet
@@:
	mov	cl,10		; Convert from K to bytes
	shl	dx,cl
	mov	cs:[MinHMASize],dx
	mov	fHMAminSet, 0FFh
	jmp	GPGoodParmRet


;---------------------------------------
;	Process /SHADOWRAM: parameter

GPGotShadow:
	mov	ax,word ptr [StringParm]
	or	ax,2020h
	xor	bl,bl
	cmp	ax,'no' 		; ON ?	- means we leave it alone
	jz	GPSetShadow
	inc	bl
	cmp	ax,'fo' 		; OFF ? - means we turn it off
	jz	GPSetShadow
	jmp	GPBadParmRet

GPSetShadow:
	mov	fShadowOff,bl		; NZ if Shadow RAM should be turned off
	jmp	GPGoodParmRet


;---------------------------------------
;	Process /CPUCLOCK: parameter

GPGotCPUClock:

	mov	ax,word ptr [StringParm]
	or	ax,2020h
	xor	bl,bl
	cmp	ax,'fo' 		; OFF ? - means we don't worry about it
	jz	GPSetClock
	inc	bl
	cmp	ax,'no' 		; ON ?	- means we preserve CPU clock
	jz	GPSetClock		;	  rate
	jmp	GPBadParmRet

GPSetClock:
	mov	fCPUClock,bl		; NZ if clock rate preserved
	jmp	GPGoodParmRet


;---------------------------------------
;	Process /INT15= parameter

GPGotInt15:
	cmp	dx, 64			; atleast 64K
	jae	@f
	jmp	GPBadParmRet
@@:	call	GetInt15Memory
	cmp	ax, dx			; enuf Ext Mem ?
	jae	@f
	jmp	GPBadParmRet
@@:	mov	[Int15MemSize], dx
	jmp	GPGoodParmRet


GPDoParameters	endp


;*----------------------------------------------------------------------*

; Get the next character from DS:SI, set CY if it's an EOL (CR, LF), set
; Z if it's a space

GPOffEOL	dw	-1

	public	GPGetChar

GPGetChar	proc	near

	cmp	si,cs:[GPOffEOL]	; are we already at EOL?
	jnb	GPAtEOL

	lodsb				; no, get next char
	cmp	al,10			; is this the EOL?
	je	GPHitEOL
	cmp	al,13
	je	GPHitEOL

	cmp	al,' '			; set Z if blank

	clc
	ret

GPHitEOL:
	mov	cs:[GPOffEOL],si	; save EOL offset once
GPAtEOL:
	stc
	ret

GPGetChar	endp


;*----------------------------------------------------------------------*

;  Print user msgs now instead of while processing so they can be
;  suppressed if /V (verbose) doesn't appear on command line.

GPPrintInfo proc   near

	; /NUMHANDLES=

	cmp	fNumHandSet, 0
	je	GPPI_HMAMin

	mov	dx,offset StartMsg ; display descriptive message
	call    GPPrintIt

	push	es
	mov	es,hiseg
	mov	ax,es:[cHandles]
	pop	es

	call    GPPrintAX
	mov	dx,offset HandlesMsg
	call	GPPrintIt

GPPI_HMAMin:

	; /HMAMIN=

	cmp	fHMAminSet, 0
	je	GPPI_exit

	mov	dx,offset HMAMINMsg ; print a descriptive message
	call    GPPrintIt
	mov	ax,cs:[MinHMASize]
	mov	cl, 10			; convert from bytes to k
	shr	ax, cl
	call    GPPrintAX
	mov	dx,offset KMsg
	call    GPPrintIt

GPPI_exit:
	ret

GPPrintInfo endp

;*----------------------------------------------------------------------*

GPPrintIt   proc    near

	push    ds		; Save current DS
	push    cs		; Set DS=CS
	pop	ds
	call	DispInfoMsg
	pop	ds		; Restore DS
	ret

GPPrintIt   endp

;*----------------------------------------------------------------------*

GPPrintAX   proc    near

	mov	cx,10
	xor	dx,dx
	div	cx
	or	ax,ax
	jz	GPAPrint
	push    dx
	call    GPPrintAX
	pop	dx
GPAPrint:
	add	dl,'0'
	call	DispInfoChar
	ret

GPPrintAX   endp

;*----------------------------------------------------------------------*
;*									*
;*  InitHandles -							*
;*									*
;*	Initialize the Extended Memory Handle Table			*
;*									*
;*  ARGS:   None							*
;*  RETS:   None							*
;*  REGS:   AX, BX, CX, and Flags are clobbered				*
;*									*
;*----------------------------------------------------------------------*

	assume	ds:_text

	public	InitHandles

InitHandles proc    near
	push	es
	mov	es,hiseg
	assume	es:funky
	mov	cx,[cHandles]

;	Init the Handle table.

	mov	bx,[KiddValley]

	xor	ax,ax
IHTabLoop:
	mov	[bx].Flags,UNUSEDFLAG
	mov	[bx].cLock,al
	mov	[bx].Base.lo,ax
	mov	[bx].Base.hi,ax
	mov	[bx].Len.lo,ax
	mov	[bx].Len.hi,ax
	if	keep_cs
	mov	[bx].Acs,ax
	endif
	add	bx,SIZE Handle
	loop    IHTabLoop

	mov	[KiddValleyTop],bx	; save top for handle validation
	pop	es
	assume	es:nothing
	ret

InitHandles endp


;*----------------------------------------------------------------------*
;*									*
;*  ScanEISA - poll any EISA devices through the BIOS's Int15(0d8h)	*
;*     and add any memory we find out about to our free memory table.	*
;*     Note:  this code (including a big buffer) gets thrown out after	*
;*     completion of the initialization sequence.			*
;*									*
;*	Note:  The COMPAQ BIOS uses up 1.5K of stack during int15(d80x) *
;*		so we'll set up a separate stack while we're here	*
;*									*
;*----------------------------------------------------------------------*

save_ss	dw	0
save_sp	dw	0

	public	ScanEISA

ScanEISA	proc	near
	assume	ds:_text

	mov	save_ss,ss
	mov	save_sp,sp
	push	cs
	pop	ss
	mov	sp,offset EISA_stack

	xor	cl,cl			; start with slot zero

SEISA_01:
	push    cx			; save slot number
	mov	ax,0d800h		; get summary of configuration
	int	15h
	pop	cx			; restore slot number
	jc	SEISA_09		;  skip if any kind of error
	test    dl,2			; does that slot have any memory?
	jz	SEISA_09		;  skip if not
	cmp	dh,0			; zero functions would be an
	jz	SEISA_09		;  error condition
	mov	ch,dh			; copy function number to ch

;	Now we've found a valid slot with some memory.  Let's find out
;	  what kind of memory it is, where its located, and how much there is.

SEISA_02:
	push    cx			; save slot and function
	mov	ax,0d801h		; read function information
	lea	si,EISABuffer		; pass pointer to our buffer
	int	15h
	jc	SEISA_04		; brif any error

;	Now look into buffer for memory information

	test    byte ptr EISA_FncInfo,80h ; function disabled?
	jnz	SEISA_04		;  brif so
	test    byte ptr EISA_FncInfo,2	; memory information follows?
	jz	SEISA_04		;  done if not

	lea	si,EISA_MemConfig	; point to memory information
SEISA_03:

; M007
	mov	al, ds:byte ptr [si]
	and	al, 079h
	cmp	al, 1			; Make sure that Reserved bit = 0
					;		 Shared bit   = 0
					;		 memory type = SYSTEM
					;		 Read/Write  = TRUE
	jne	SEISA_03a		; (See EISA spec for bit definitions)
; M007

	mov	cx,ds:word ptr 2[si]    ; get base address in 256 bytes
	mov	bl,ds:byte ptr 4[si]    ;  get highest byte
	xor	bh, bh
	mov	al,cl			; save lowest bits for later
	shr	bl,1			; convert to our internal 1k format
	rcr	cx,1
	shr	bl,1
	rcr	cx,1
	test    al,3			; was base not on a 1k boundary?
	mov	ax,ds:word ptr 5[si]    ; get length in k
	jz	SEISA_03b		;  brif base was on 1k boundary
	dec	ax			; sacrifice the partial k
	add	cx,1			; and bump base to first complete k
	adc	bx,0
SEISA_03b:
	xor	dx, dx
	or	ax, ax
	jnz	@f
	inc	dx
@@:
	push    si
	cmp	cx,1024			; is it below a meg?
	jb	seisa_0xx		; ignore it if so
ifdef WIN30COMPATIBLE				;M005
	or	bx, bx
	jnz	seisa_0xx
	cmp	cx,1024*16		; is it above 16 meg?
	jae	seisa_0xx		; ignore it if so
endif                                           ;M005
	mov	di, pAddMem
	push	cs
	call	call_hi_in_di		; add that memory to our tables
seisa_0xx:
	pop	si
SEISA_03a:
	add	si,7			; next entry
	test    ds:byte ptr -7[si],80h  ;  was that the last one?
	jnz	SEISA_03		;  loop if not
SEISA_04:
	pop	cx			; restore slot and function
	dec	ch			; next lower function
	jnl	SEISA_02		; valid functions are 0..n

SEISA_09:
	inc	cl			; next slot
	cmp	cl,16
	jae	@f
	jmp	SEISA_01
@@:

; Now check for EISA memory and Int 15h/88h overlap.  In the default case
; we'll ignore any EISA blocks starting at 1Meg under the assumption that
; this memory will be claimed later via the Int 15h hook.  If the Int 15h/88h
; call indicates less memory than the EISA scan, it may be that an Int 15h
; allocator has been loaded before us, and if we just grabbed all EISA
; memory starting at 1Meg, we would stomp all over them.  On the other hand,
; a number of BIOS' never return > 15 (16?) meg of extended memory via Int 15h
; (even if there is much more memory installed), so we provide the /EISA
; command line parameter to override this default and allow himem to steal
; all EISA memory.  If the /EISA switch is used, there better not be any
; Int 15h allocators loaded before himem!

;	Locate a free memory block in the handle table at 1 Meg (1024k)

	push	es
	mov	es,hiseg
	assume	es:funky
	mov	bx,[KiddValley]
	mov     cx,[cHandles]		; Loop through the handle table
SEISA_09a:
	cmp	[bx].Flags,FREEFLAG	; is this a valid free memory block?
	jnz	SEISA_09b		; branch if not
	cmp	[bx].Base.hi, 0
	jnz	SEISA_09b
	cmp	[bx].Base.lo,1024	; based at 1Meg?
	jz	SEISA_09c		; yup...

SEISA_09b:
	add	bx,SIZE Handle
	loop    SEISA_09a
	jmp	short SEISA_09e

SEISA_09c:
	cmp	fEISA, 0		; want all EISA memory, regardless?
	jz	SEISA_default		; no...

ifdef WIN30COMPATIBLE		;GetInt15Memory has an ifdef WIN30COMPATIBLE
.err				;  that would be silly to use with the
endif				;  following code

	call	GetInt15Memory		; yes, start EISA block above current
	add	[bx].Base.lo, ax	;   Int 15h/88h line.  The Int 15h mem
	adc	[bx].Base.hi, 0 	;   will be added when Int 15h hooked.
	sub	[bx].Len.lo, ax 	;   Existing hook and /INT15= code
	sbb	[bx].Len.hi, 0		;   will work as before.
	jc	SEISA_09d		; (just for safeties sake)
	mov	ax, [bx].Len.lo 	; Len will be 0 if Int 15h covers
	or	ax, [bx].Len.hi 	;   entire EISA block
	jz	SEISA_09d
	jmp	short SEISA_09e

SEISA_default:
	cmp	[bx].Len.hi, 0		; If the length is > 64 Meg (which is
	jz	SEISA_09d		;   the max that Int 15h/88h could
	inc	[bx].Base.hi		;   return), keep the memory above
	dec	[bx].Len.hi		;   that for XMS
	jmp	short SEISA_09e

SEISA_09d:
	mov	[bx].Flags,UNUSEDFLAG	; free the block at 1024

SEISA_09e:
	pop	es
	assume	es:nothing

SEISA_exit:
	mov	ss,save_ss
	mov	sp,save_sp		; restore normal stack
	ret
	assume	ds:nothing

ScanEISA	endp

;	The buffer for scanning EISA devices is big, but disposable

ZDS_Buffer	label	byte		; also use for Zenith memory check

EISABuffer	db	22h dup (0)
EISA_FncInfo	db	(73h-22h) dup (0)
EISA_MemConfig	db	(320-73h) dup (0)

		db	(512-320) dup (0)	; make it 512 for Zenith

	db	2000 dup (?)
EISA_Stack:

_text	ends

ifdef	debug_tsr			;-------------------------------

EndStmt equ	<end	ExeStart>

STACK	segment	stack 'STACK'
	db	1024 dup (?)
STACK	ends

else

EndStmt equ	<end>

endif					;-------------------------------

	EndStmt
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\himem\himem4b.asm ===
;/*
; *                      Microsoft Confidential
; *			 Copyright (C) Microsoft Corporation 1988-1992
; *                      All Rights Reserved.
; */
;
;*****************************************************************************
;
; HIMEM4B.ASM : 386 SPECIFIC routines
;
;*****************************************************************************
;
Begin386	label	byte	; Start of 386 code

;*----------------------------------------------------------------------*
;*									*
;*  QueryExtMemory -					FUNCTION 08h    *
;*									*
;*	Returns the size of the largest free extended memory block in K	*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = Size of largest free block in K.  BL = Error code	*
;*	DX = Total amount of free extended memory in K			*
;*  REGS:   AX, BX, DX and Flags clobbered				*
;*									*
;*  INTERNALLY REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

QueryExtMemory proc far

	test	ah, 80h				; Super call ?
	jnz	SQueryExtMemoryNear
	push	si
	push	di

	push	eax
	push	ecx
	push	edx

	push	cs
	call	SQueryExtMemoryNear		; call the super ONE!
;
;------ if (eax < 64M) si = ax ; else di = 64M ;
;
	mov	si, ax
	cmp	eax, 0ffffh
	jbe	short @f
	mov	si, 0ffffh
@@:
;
;------ if (edx < 64M) di = ax ; else di = 64M ;
;
	mov	di, dx
	cmp	edx, 0ffffh
	jbe	short @f
	mov	di, 0ffffh
@@:
	pop	edx
	pop	ecx
	pop	eax

	mov	ax, si
	mov	dx, di

	pop	di
	pop	si
	ret

QueryExtMemory endp


;*----------------------------------------------------------------------*
;*									*
;*  AllocExtMemory -					FUNCTION 09h    *
;*									*
;*	Reserve a block of extended memory				*
;*									*
;*  ARGS:   DX = Amount of K being requested				*
;*  RETS:   AX = 1 of successful, 0 otherwise.	BL = Error Code		*
;*	DX = 16-bit handle to the allocated block			*
;*  REGS:   AX, BX, DX and Flags clobbered				*
;*									*
;*	Notice:  called internally from ReallocExtMemory		*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

AllocExtMemoryNear proc near
AllocExtMemoryNear endp
AllocExtMemory proc far

	test	ah, 80h
	jnz	SAllocExtMemoryNear
	push	si
	push	edx
	movzx	edx, dx
	push	cs
	call	SAllocExtMemoryNear	; call the super ONE!
	mov	si, dx
	pop	edx
	mov	dx, si
	pop	si
	ret

AllocExtMemory endp

;*----------------------------------------------------------------------*
;*									*
;*  FreeExtMemory -					FUNCTION 0Ah    *
;*									*
;*	Frees a block of extended memory				*
;*									*
;*  ARGS:   DX = 16-bit handle to the extended memory block		*
;*  RETS:   AX = 1 if successful, 0 otherwise.	BL = Error code		*
;*  REGS:   AX, BX, CX, DX, SI, DI and Flags clobbered			*
;*									*
;*	called internally from ReallocExtMemory				*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

FreeExtMemoryNear proc near
FreeExtMemoryNear endp

FreeExtMemory proc far

	cli 				; This is a non-reentrant function

	push	si
	push	di
	push	cx
	push	edx

	push	eax
	push	ebx

	mov	si, offset ValidateHandle
	call	si

;	call    ValidateHandle		; Make sure handle is valid

	jnc     short FEMBadh
	mov	si,dx			; Move the handle into SI

	cmp	[si].cLock,0		; make sure it points to unlocked block
	jne     short FEMLockedh

	mov	[si].Flags,UNUSEDFLAG	;  mark it as UNUSED
	cmp	[si].Len,0		; if zero length block
	jz	short FEMExit			; done if it was zero length
	mov	[si].Flags,FREEFLAG	; mark it as FREE

;	now see if there's a free adjacent block

FEMScanIt:
	mov	ebx,[si].Base		; BX = base of block
	mov	eax,ebx			; calculate ax = top of block
	add	eax,[si].Len

;	Search for an adjacent FREE block.

	mov	di,[KiddValley]		; di = Handle being scanned
	mov     cx,[cHandles]		; Loop through the handle table
FEMLoopTop:
	cmp	[di].Flags,FREEFLAG	; Is this block free?
	jne     short FEMNexth		; No, continue

	mov	edx,[di].Base		; is this block just above freed one?
	cmp     edx,eax
	je	short FEMBlockAbove     	; Yes, coalesce upwards

	add	edx,[di].Len		; is it just below?
	cmp     edx,ebx
	je	short FEMBlockBelow     	; Yes, coalesce downwards

FEMNexth:
	add	di,SIZE Handle
	loop    FEMLoopTop

;	No adjacent blocks to coalesce.

FEMExit:
	pop	ebx
	pop	eax

	mov     ax,1			; Return success
	xor	bl,bl
FEM9:
	pop	edx
	pop	cx
	pop	di
	pop	si

	ret

;	Exchange the pointer to the "upper" and "lower" blocks.

FEMBlockBelow:
	xchg    si,di

;	Move the free block above into the current handle.

FEMBlockAbove:
	mov	edx,[si].Len
	add     edx,[di].Len 		; Combine the lengths
	mov	[si].Len,edx
	mov     [di].Flags,UNUSEDFLAG   ; Mark old block's handle as UNUSED
	jmp	short FEMScanIt		; Rescan the list

FEMBadh:
	pop	ebx
	mov	bl,ERR_INVALIDHANDLE
	jmp	short FEMErrExit

FEMLockedh:
	pop	ebx
	mov	bl,ERR_EMBLOCKED
FEMErrExit:
	pop	eax
	xor     ax,ax			; Return failure
	jmp	short FEM9

FreeExtMemory endp

;*----------------------------------------------------------------------*
;*									*
;*  GetExtMemoryInfo -					FUNCTION 0Eh    *
;*									*
;*	Gets other information about an extended memory block		*
;*									*
;*  ARGS:   DX = 16-bit handle to the extended memory block		*
;*  RETS:   AX = 1 if successful, 0 otherwise.	BL = Error code		*
;*	    BH = EMB's lock count					*
;*	    BL = Total number of unused handles in the system		*
;*	    DX = EMB's length						*
;*  REGS:   AX, BX, CX, DX and Flags clobbered				*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

GetExtMemoryInfo proc	far

	test	ah, 80h
	jnz	SGetExtMemoryInfoNear

	cli 			; This is a non-reentrant function

	push	cx
	push	si

	mov	si, offset ValidateHandle
	call	si

;	call    ValidateHandle	; is the handle valid?

	jnc     short GEMBadh
	mov     si,dx		; Move the handle into SI

	cmp	[si].Len.hi, 0	; Size > 64M ?
	jne	short GEMBadh		; yes, we cannot handle this function

	xor     ax,ax		; count number of UNUSED handles
	mov     bx,[KiddValley]
	mov     cx,[cHandles]	; Loop through the handle table
GEMLoop:
	cmp     [bx].Flags,USEDFLAG ; Is this handle in use?
	je	short GEMNexth	; Yes, continue
	inc     ax		; No, increment the count
GEMNexth:
	add     bx,SIZE Handle
	loop    GEMLoop

	mov     dx,[si].Len.lo 	; Length in DX
	mov     bh,[si].cLock	; Lock count in BH
	or	ah, ah		; Free handles > 255 ?
	jz	short @f
	mov	al, 0ffh	; make it 255 if > 255
@@:
	pop	si
	pop	cx
	mov     bl,al
	mov	ax,1
	ret

GEMBadh:
	pop	si
	pop	cx
	mov	bl,ERR_INVALIDHANDLE
	xor	ax,ax
	ret

GetExtMemoryInfo endp


;*----------------------------------------------------------------------*
;*									*
;*  ReallocExtMemory -					FUNCTION 0Fh    *
;*									*
;*	Reallocates a block of extended memory				*
;*									*
;*  ARGS:   DX = 16-bit handle to the extended memory block		*
;*	    BX = new size for block					*
;*  RETS:   AX = 1 if successful, 0 otherwise.	BL = Error code		*
;*  REGS:   trashes si,di,bx,cx,dx					*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

;	Define our memory move structure for calling the move function

ReallocExtMemory	proc	far
	test	ah, 80h
	jnz	SReallocExtMemoryNear
	push	si
	push	di
	push	eax
	push	ebx
	movzx	ebx, bx
	push	cs
	call	SReallocExtMemoryNear
	mov	si, ax
	mov	di, bx
	pop	ebx
	mov	bx, di
	pop	eax
	mov	ax, si
	pop	di
	pop	si
	ret
ReallocExtMemory	endp

;*----------------------------------------------------------------------*
;*									*
;*  SQueryExtMemory -					FUNCTION 88h    *
;*									*
;*	Returns the size of the largest free extended memory block in K	*
;*									*
;*  ARGS:   None							*
;*  RETS:   EAX = Size of largest free block in K.  BL = Error code	*
;*	    EDX = Total amount of free extended memory in K		*
;*	    ECX = Highest Ending Address of any block			*
;*  REGS:   AX, BX, DX, DI, SI and Flags clobbered			*
;*									*
;*  INTERNALLY REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

SQueryExtMemoryNear proc near
SQueryExtMemoryNear endp

SQueryExtMemory proc far

	push	esi
	push	edi

;	scan for largest FREE block

	xor	eax, eax	       	; eax = Max. size found so far
	xor	edx, edx		; edx = Total amount of free memory
	xor	esi, esi		; esi = Highest Address so far

	mov	bx,[KiddValley]
	mov     cx,[cHandles]		; Loop through the handle table
SQEMLoop:
	cmp	[bx].Flags, UNUSEDFLAG
	je	short SQEMBottom

	mov	edi, [bx].Base
	add	edi, [bx].Len
	dec	edi			; edi=Addr of last byte of the block
	cmp	esi, edi		; Have we found a bigger end address
	jae	short @f
	mov	esi, edi
@@:
	cmp	[bx].Flags,FREEFLAG
	jne     short SQEMBottom

	mov	edi, [bx].Len
	add     edx, edi 		; add free block to total

	cmp	eax, edi		; is this the largest so far?
	jae     short SQEMBottom

	mov	eax, edi		; Yes, save it away
SQEMBottom:
	add	bx,SIZE Handle
	loop    SQEMLoop

	mov	ecx, esi		; get the address of last byte into ecx

	mov	bl, ERR_OUTOMEMORY	; assume error
	or	edx, edx		; do we have any free memory
	jz	short @f			; if not keep error code in BL
	xor	bl, bl			; else clear the error
@@:
	pop	edi
	pop	esi
	ret

SQueryExtMemory endp


;*----------------------------------------------------------------------*
;*									*
;*  SAllocExtMemory -					FUNCTION 09h    *
;*									*
;*	Reserve a block of extended memory				*
;*									*
;*  ARGS:   EDX = Amount of K being requested				*
;*  RETS:   AX = 1 of successful, 0 otherwise.	BL = Error Code		*
;*	DX = 16-bit handle to the allocated block			*
;*  REGS:   AX, BX, DX and Flags clobbered				*
;*									*
;*	Notice:  called internally from ReallocExtMemory		*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

; Algorithm -
;
;   Scan the Handle Table looking for BOTH an unused handle and
;	a free block which is large enough:
;
;   1.	If both are found -
;	Mark the free block as used and adjust its size.
;	Make the unused handle a free block containing the remaining
;		unallocated portion of the original free block.
;
;   2.	If only an unused handle is found -
;	We're out of memory.  (Unless zero length block requested)
;
;   3.	If only a properly sized free block is found -
;	We only have one handle left.
;	Mark the free block as used.  The requester gets all of the
;		block's memory.
;
;   4.	If neither are found -
;	We're out of memory.

;hFreeBlock	dw  ?
;hUnusedBlock	dw  ?

;aemStack	struc
; hFreeBlock	dw	?
; hUnusedBlock	dw	?
;aemStack	ends

SAllocExtMemoryNear proc near
SAllocExtMemoryNear endp

SAllocExtMemory proc far
 
	cli 			; This is a non-reentrant function

	push	cx
	push	si
	push	di


; Scan the handle table looking for BOTH an unused handle and
;	a free block which is large enough.

	xor	si, si			; Have not found Free Handle
	mov	di, si			; Have not found Unused Handle

	mov	bx, [KiddValley]
	mov     cx, [cHandles]		; Loop through the handle table

;	Have we already found a free block which is large enough?

SAEMhLoop:
	or	si, si			; did we already find a Free Handle ?
	jne     short SAEMUnused		; Yes, see if this one is unused

	cmp     [bx].Flags, FREEFLAG	; Is this block free?
	jne     short SAEMUnused		; No, see if it is unused

	cmp	edx, [bx].Len		; Is it large enough?
	ja	short SAEMNexth		; No, get the next handle

	mov	si, bx			; save this one away
	jmp	short SAEMBottom

SAEMUnused:
	or	di, di			; did we already find an unused handle?
	jne     short SAEMNexth		; Yes, get the next handle

	cmp     [bx].Flags, UNUSEDFLAG	; Is this block unused?
	jne     short SAEMNexth		; No, get the next handle

	mov	di, bx			; save this guy away

	cmp	si, 0			; have we found all we need?
	je	short SAEMNexth
SAEMBottom:
	cmp	di, 0
	jne     short SAEMGotBoth		; Yes, continue

SAEMNexth:
	add	bx, SIZE Handle		; go check the next handle
	loop    SAEMhLoop

;	We are at the end of the handle table and we didn't find both
;	things we were looking for.  Did we find a free block?

	or	si, si
	jnz     short SAEMRetSuc		; Yes, Case 3 - Alloc the entire block

	or	di, di			; did we find an unused handle?
	jz	short SAEMOOHandles		; No, Case 4 - We're out of handles

	or	edx, edx		; Case 2 - req for zero-length handle?
	jnz     short SAEMOOMemory		; No, we're out of memory

	mov	si, di			; reserve the zero-length handle
	mov	[si].Len, 0		; force length field to zero
	jmp	short SAEMRetSuc

SAEMGotBoth:

;	 We're at Case 1 above.
;	Mark the free block as used (done below) and adjust its size.
;	Make the unused handle a free block containing the remaining
;	   unallocated portion of the original free block.

	push	eax

	mov	eax, [si].Base		; Unused.Base = Old.Base + request
	add	eax, edx
	mov	[di].Base, eax

	mov	eax, edx		; New.Len = request
	xchg    [si].Len, eax

	sub	eax, edx		; Unused.Len = Old.Len - request
	mov	[di].Len, eax
	mov	[di].Flags, FREEFLAG	; Unused.Flags = FREE
	jnz	short SAEM_nonzero_residual
	mov	[di].Flags, UNUSEDFLAG	; Unused.Flags = UNUSED

SAEM_nonzero_residual:

	pop	eax
SAEMRetSuc:
	mov	[si].Flags, USEDFLAG	; New.Flags = USED

	if	keep_cs
	mov	ax, callers_cs
	mov	[si].Acs, ax		; keep track of allocator's cs:
	endif

	mov	dx, si
	mov	ax, 1
	xor	bl, bl
SAEM9:
	pop	di
	pop	si
	pop	cx
	ret

SAEMOOMemory:
	mov	bl, ERR_OUTOMEMORY
	jmp	short SAEMErrRet

SAEMOOHandles:
	mov	bl, ERR_OUTOHANDLES
SAEMErrRet:
	xor	ax, ax			; Return failure
	mov	dx, ax
	jmp	short SAEM9		;
SAllocExtMemory endp

;*----------------------------------------------------------------------*
;*									*
;*  GetExtMemoryInfo -					FUNCTION 0Eh    *
;*									*
;*	Gets other information about an extended memory block		*
;*									*
;*  ARGS:   DX = 16-bit handle to the extended memory block		*
;*  RETS:   AX = 1 if successful, 0 otherwise.	BL = Error code		*
;*	    BH = EMB's lock count					*
;*	    BL = Total number of unused handles in the system		*
;*	    DX = EMB's length						*
;*  REGS:   AX, BX, CX, DX and Flags clobbered				*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

SGetExtMemoryInfoNear	proc	near
SGetExtMemoryInfoNear	endp

SGetExtMemoryInfo proc	far

	cli 			; This is a non-reentrant function

	push	cx
	push	si

	mov	si, offset ValidateHandle
	call	si

;	call    ValidateHandle	; is the handle valid?

	jnc     short SGEMBadh
	mov     si,dx		; Move the handle into SI

	xor     ax,ax		; count number of not USED handles
	mov     bx,[KiddValley]
	mov     cx,[cHandles]	; Loop through the handle table
SGEMLoop:
	cmp     [bx].Flags,USEDFLAG ; Is this handle in use?
	je	short SGEMNexth	; Yes, continue
	inc     ax		; No, increment the count
SGEMNexth:
	add     bx,SIZE Handle
	loop    SGEMLoop

	mov     edx,[si].Len 	; Length in EDX
	mov     bh,[si].cLock	; Lock count in BH
	xchg	cx, ax		; number of free handles in CX
	pop	si
	pop	cx
	mov	ax,1
	xor	bl, bl
	ret

SGEMBadh:
	pop	si
	pop	cx
	mov	bl,ERR_INVALIDHANDLE
	xor	ax,ax
	ret

SGetExtMemoryInfo endp


;*----------------------------------------------------------------------*
;*									*
;*  SReallocExtMemory -					FUNCTION 8Fh    *
;*									*
;*	Reallocates a block of extended memory				*
;*									*
;*  ARGS:   DX = 16-bit handle to the extended memory block		*
;*	    BX = new size for block					*
;*  RETS:   AX = 1 if successful, 0 otherwise.	BL = Error code		*
;*  REGS:   trashes si,di,bx,cx,dx					*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

;	Define our memory move structure for calling the move function

SReallocExtMemoryNear	proc	near
SReallocExtMemoryNear	endp

SReallocExtMemory	proc	far

	cli 			; This is a non-reentrant function

	push    bp		; preserve caller's bp

	push	edx
	push	si
	push	di


	mov	si, offset ValidateHandle
	call	si

;	call    ValidateHandle	; is the handle valid?
	mov	si,dx		; Move the handle into SI
	mov	edx,ebx		; Move the new length into dx
	mov	bl,ERR_INVALIDHANDLE
	jnc     short REMError

	cmp	[si].cLock,0	; We can only work on unlocked EMBs
	mov	bl,ERR_EMBLOCKED
	jnz	short REMError

;	There are basically five successful cases for this function:
;
;	1. The new size is the same.  No operation.
;
;	2. We're making the block smaller.  Truncate & Coalesce.
;
;	3. We're making the block bigger and sufficient memory is
;	   available from the immediately following block to append.
;
;	4. We're making the block bigger and sufficient memory is
;	   available from the immediately preceding block (and possibly
;	   the following block as well).  Add the memory and slide data down.
;
;	5. We must find a whole new block which is bigger.
;
	cmp	edx,[si].Len		; check for cases 1 and 2
	ja	REMGrow			; cases 3, 4, 5 - growing
	jb	short REMShrink		; case 2 - shrinking

;	Case 1:  no change in size.  We're done.

REMExit:
	mov	ax,1			; succesful return
	xor	bl,bl			; non-documented no-error return
	pop	di
	pop	si
	pop	edx
	pop	bp
	ret

;	Case 2: Truncate the block and coalesce
;	   Scan the list of handles to see if there is an
;	   existing EMB immediately following us that we can
;	   append the memory to.

REMShrink:

	push    edx			; save new size
	call    FindAdjacent		; see if a block follows us
	pop	edx			; restore our new size
	or	bp,bp			; does a block follow us?
	jz	short REMShrink5		;  brif not

;	This is the easy case of shrinking.  All we have to do is move
;	   the deallocated memory into the following block

	mov	eax,[si].Len		; old length
	sub	eax,edx			; we're truncating this much
	mov	[si].Len,edx		; adjust our block downwards

	add	ds:[bp].Len,eax		; increase next block by same
	sub	ds:[bp].Base,eax	;  and lower its base

	jmp	short REMExit		; exit okay!

;	Locate an error return here for easy access

REMError:
	xor	ax,ax
	pop	di
	pop	si
	pop	edx
	pop	bp			; preserve caller's bp
	ret

;	We'll have to create a new block to give the freed space to.

REMShrink5:
	push	cx
	mov	di,[KiddValley]		; look for an available handle
	mov	cx,[cHandles]
REMS5a:
	cmp	[di].Flags,UNUSEDFLAG
	jz	short REMS5b			; brif found free handle
	add	di,SIZE Handle
	loop    REMS5a
	pop	cx

	mov	bl,ERR_OUTOHANDLES
	jmp	short REMError		; Abort without shrinking if none

REMS5b:
	pop	cx
	mov	eax,edx			; get new length
	add	eax,[si].Base		;  calculate begin of new block
	mov	[di].Base,eax

	mov	eax,[si].Len		; new length
	sub	eax,edx			;  calculate length of new block
	mov	[di].Len,eax

	mov	[di].Flags,FREEFLAG     ; setup lock count and flags
	mov	[di].cLock,0

	mov	[si].Len,edx		; adjust length of original block

	jmp	short REMExit		; exit okay!


REMGrow:
	push    edx			; save new length
	call    FindAdjacent		; locate adjacent blocks
	pop	edx

;	hopefully the following block is big enough.  that's the easiest
;	   case.  If so, we'll just snatch the space and then kill it if
;	   its size goes to zero.

;	Don't forget:  di = preceding block's handle (or zero)
;		   si = original block's handle
;		   bp = following block's handle (or zero)

	or	bp,bp			; is there a following block?
	jz	short REMGrow4		; skip if not
	mov	eax,edx			; new size
	sub	eax,[si].Len		;  calculate growth amount
	cmp	eax,ds:[bp].Len		; will next block accomodate?
	ja	short REMGrow4		;  nope.  not big enough.

;	Case 3: The following block has enough space for our needs.

	jz	short REMGrow2		; skip if we're using whole block

	sub	ds:[bp].Len,eax		; make it smaller
	add	ds:[bp].Base,eax		;  and start later
	jmp	short REMGrow3

REMGrow2:
	mov	ds:[bp].Flags,UNUSEDFLAG; mark it as free
REMGrow3:
	mov	[si].Len,edx		; update length of caller's block
	jmp	REMExit

;	Come here if we can't find enough room from a following block.
;	  Now decide whether to use case 4 (use prev or both adjacent blocks)
;	  or case 5 (find another block entirely).  Notice that either
;	  of these solutions will require a memory move operation.

REMGrow4:
	or	di,di			; is there a preceding block?
	jz	short REMGrow7x		;  nope.  resort to case 5

	mov	eax,[di].Len
	add	eax,[si].Len		; get size of prev + orig block
	or	bp,bp			; Is there a following block?
	jz	short REMGrow4a		;  skip if not
	add	eax,ds:[bp].Len		; calculate max possible resource
REMGrow4a:
	cmp	edx,eax			; is all of that sufficient
	jna	short REMGrow5		;  to handle whole thing? brif so
REMGrow7x:
	jmp	REMGrow7

;	There will be only one or two blocks left of the possible three
;	 when we're finished.  We'll start by merging the following block
;	 onto the middle block and freeing its handle, but we'll save the
;	 original length of the middle block so we don't end up moving more
;	 memory than we need.

REMGrow5:

;	Now we need a move structure.  Allocate one on the stack and point
;	   es:bx to it

;	Always make sure stack stays on even boundary

	sub	sp,0fffeh and (1+SIZE MoveExtendedStruc)
	push    ss			; point es:bx to stack frame
	pop	es
	mov	bx,sp

	push    [si].Len		; save length of move
	or	bp,bp			;  is there a following block?
	jz	short REMGrow5a		;  brif not

	mov	eax,ds:[bp].Len		; get it's length
	add	[si].Len,eax		; suck it in
	mov	ds:[bp].Flags,UNUSEDFLAG; that handle is now unused

;	Now change the main block to include all of the space.  Notice
;	  that the 'previous' block will still exist as an overlapping
;	  subset of the total block during the move.  We'll sort it out
;	  again after the move when we're able to disable interrupts
;	  again.

REMGrow5a:
	mov	eax,[di].Len		; get length of bottom block
	add	[si].Len,eax		; add it into our target block
	push    [si].Base		; save base of data block to move
	mov	eax,[di].Base		; base of bottom block becomes
	mov	[si].Base,eax		;  of super block
	inc	[di].cLock		; lock both blocks so's we don't
	inc	[si].cLock		;  get moved around

;	Now make the move in the new merged block.  Offsets are relative
;	  to the base of the block.  Zero is the destination.  The old
;	  base ([sp]) is the source (in 1k), the old length ([sp+2]) is
;	  the length (in 1k).

	mov	es:[bx].SourceHandle,si	; both handles = our main block
	mov	es:[bx].DestHandle,si
	mov	es:[bx].DestOffset,0	; move data to base of block

	pop	eax			; get source begin address
	sub	eax,[si].Base		; find offset within block

;	now use trick to make cx:ax = ax * 1024

;	rcr	ax,6			; like rcl ax,10 but faster
;	mov	cx,ax
;	and	cx,3ffh
;	and	ax,0fc00h

	shl	eax, 10

	mov	es:[bx].SourceOffset,eax

	pop	eax			; get length in Kilobytes

;	rcr	ax,6			; trick multiply by 1024 again
;	mov	cx,ax
;	and	cx,3ffh
;	and	ax,0fc00h

	shl	eax, 10

	mov	es:[bx].bCount,eax

	push    si			; save main handle
	push    di			; save residual handle
	push    edx			; save new block length
	mov	si,bx
;
	push	cs

	mov	bx, offset BlkMovX
	call	bx

;	call	BlkMovX

	pop	edx
	pop	di
	pop	si

;	Release the move structure stack frame

	add	sp,0fffeh and (1+SIZE MoveExtendedStruc)

	cli				; can't mess with us
	dec	[di].cLock		; remove our locks
	dec	[si].cLock
	mov	eax,[si].Len		; get total block length
	sub	eax,edx			;  less amount requested by user
	mov	[si].Len,edx
	jz	short REMGrow5b		; branch if no residual block

	add	edx,[si].Base		; get base of residual block
	mov	[di].Base,edx
	mov	[di].Len,eax		; save length of residual block
	jmp	REMExit			; We're done!

REMGrow5b:
	mov	[di].Flags,UNUSEDFLAG   ; free the handle if block empty
	jmp	REMExit			; DONE!

;	Another error return centrally for easy conditional branch access

REMErrora:
	xor	ax,ax			; indicate error condition
	pop	di
	pop	si
	pop	edx
	pop	bp			; restore caller's bp
	ret

REMGrow7:
	push    si			; save our handle
	push    dx			; save our desired length
	push	cs			; fake a far call
	call	SAllocExtMemoryNear	; try to allocate a new block
	cli
	mov	di,dx			;  save its results
	pop	dx
	pop	si
	or	ax,ax			; did we fail?
	mov	bl,ERR_OUTOMEMORY	;  not enough memory
	jz	REMErrora
	inc	[di].cLock		; lock both blocks so's we don't
	inc	[si].cLock		;  get moved around

;	Now move the data from the old block to the new one before
;	  swapping the handles and deallocating the original block

;	Allocate a stack frame for a move structure

	sub	sp,0fffeh and (1+SIZE MoveExtendedStruc)
	push    ss			; point es:bx to a move structure
	pop	es
	mov	bx,sp

	mov	es:[bx].SourceHandle,si ; source handle = our main block
	mov	es:[bx].DestHandle,di   ; dest handle = new block
	xor	eax,eax
	mov	es:[bx].DestOffset,eax	; move to base of new block
	mov	es:[bx].SourceOffset,eax; from base of old block

	mov	eax,[si].Len		; get length of old block

;	rcr	ax,6			; trick multiply by 1024
;	mov	cx,ax
;	and	cx,3ffh
;	and	ax,0fc00h

	shl	eax, 10

	mov	es:[bx].bCount,eax

	push    si			; save main handle
	push    di			; save new handle
	mov	si,bx
	push	cs

	mov	bx, offset BlkMovX
	call	bx

;	call	BlkMovX

	pop	di
	pop	si

;	Deallocate stack frame

	add	sp,0fffeh and (1+SIZE MoveExtendedStruc)

	cli				; can't mess with us

;	Now we have to reverse the two handles so that we can return
;	  the new block to the user without changing his handle

	mov	eax,[si].Base
	xchg    eax,[di].Base
	mov	[si].Base,eax

	mov	eax,[si].Len
	xchg    eax,[di].Len
	mov	[si].Len,eax

	dec	[si].cLock		; remove our locks
	dec	[di].cLock

	mov	ax,di			; handle to free
	pop	di
	pop	si
	pop	edx
	mov	dx, ax			; handle to free
	pop	bp
	jmp	FreeExtMemoryNear	; do it!, return any errors

SReallocExtMemory	endp

;*----------------------------------------------------------------------*
;*									*
;*  FindAdjacent unused blocks						*
;*									*
;*	Scan through handle list looking for blocks adjacent		*
;*	  to a given handle.						*
;*									*
;*  ARGS:   SI handle of original block					*
;*  RETS:   DI = handle of adjacent block below or zero if none		*
;*	BP = handle of adjacent block above or zero if none		*
;*									*
;*  TRASHES: AX,BX,CX,DX						*
;*									*
;*  messes with handle table - not reentrant - assumes ints disabled	*
;*									*
;*----------------------------------------------------------------------*

FindAdjacent	proc	near

	mov	eax,[si].Base		; look for blocks ending here
	mov	edx,[si].Len
	add	edx,eax			; and ending here

	xor	di,di			; initialize to fail condition
	mov	bp,di

	mov	bx,[KiddValley]		; prepare to loop thru handle tab
	mov	cx,[cHandles]

	push    esi			; preserve original handle

FindAdj1:
	cmp	[bx].Flags,FREEFLAG
	jnz	short FindAdj3		; ignore blocks that aren't UNUSED
	mov	esi,[bx].Base
	cmp	edx,esi			; found beg block?
	jnz	short FindAdj2		;  skip if not
	mov	bp,bx			;  remember the handle
	or	di,di			; did we already find a follower?
	jnz	short FindAdj9		;  we're done if so

FindAdj2:
	add	esi,[bx].Len		; find length
	cmp	esi,eax			; does this block end at spec addr?
	jnz	short FindAdj3		;  skip if not
	mov	di,bx			;  remember the handle
	or	bp,bp			; did we already find a leader?
	jnz	short FindAdj9		;  we're done if so

FindAdj3:
	add	bx,SIZE handle
	loop    FindAdj1

FindAdj9:
	pop	esi			; restore original handle
	ret
;

FindAdjacent	endp

;*----------------------------------------------------------------------*

Zero segment at 0
	org	13*4
	public	Int13Vector
Int13Vector	label	dword
Zero	ends


	public	Patch3, descCS, OurGDT, GDTPtr
	public	MoveExtended386

MoveBlock386:


Here3	equ	($+(offset Begin286-offset Begin386))

OurGDT	=	byte ptr Here3		; Simple GDT
		DESC386	<>
descCS	=	byte ptr Here3
		DESC386	<0FFFFh,0,0,09Fh,0,0>		; Conforming CS
descRealBig	=	byte ptr Here3
		DESC386	<0FFFFh,0,0,093h,0cfh,0>	; Page Granularity
							; 4Gb Limit
GDTLen	EQU Here3-OurGDT

GDTPtr	=	qword ptr Here3
		GDT386 <GDTLen,0,0>

OldInt13	=	dword ptr Here3
		dd	0			; Old contents of int 13 vector

GDTMoveBlock	= byte ptr Here3
						; 386 Template OK for Move Block
		DESC386	<>			; Nul Descriptor
		DESC386	<>			; GDT Descriptor
descSource	= byte ptr Here3
		DESC386 <0FFFFh,0,0,93h,0,0>	; Source Segment Descriptor
descDest	= byte ptr Here3
		DESC386 <0FFFFh,0,0,93h,0,0>	; Destination Segment Descriptor
		DESC386	<>			; BIOS use
		DESC386	<>			; BIOS use

;******************************************************************************
;
; Movext386
;	XMM Move Extended Memory Block for the 80386
;
; Entry:
;	ES:BX	Points to structure containing:
;		bCount		dd	?	; Length of block to move
;		SourceHandle	dw	?	; Handle for souce
;		SourceOffset	dd	?	; Offset into source
;		DestHandle	dw	?	; Handle for destination
;		DestOffset	dd	?	; Offset into destination
;
; Return:
;	AX = 1	Success
;	AX = 0	Failure
;		Error code in BL
;
; Registers Destroyed:
;	Flags
;
;------------------------------------------------------------------------------

	public	MoveExtended386
MoveExtended386 = Here3

Movext386	proc	far
	assume	ds:_text


	sti					; Be nice
	push	bp				; Set up stack frame so we
	mov	bp, sp				; can have local variables
	sub	sp, 18
Count	= -4					; Local DWORD for byte count
Return	= -6					; Local WORD for return code
SrcHandle = -8
DstHandle = -10
SrcLinear = -14
DstLinear = -18
	push	eax				; Save upper word of registers
	push	ecx
	push	esi
	push	edi
	push	bx

	xor	ax, ax
	mov	[bp.Return], ax			; Assume success
	mov	[bp.SrcHandle], ax
	mov	[bp.DstHandle], ax
	mov	ecx, es:[si].bCount
	mov	[bp.Count], ecx

	shr	dword ptr [bp.Count], 1		; No odd byte counts
	jc	MEM3_InvCount
	jz	MEM3_Exit			; Exit immediately if zero

	lea	bx, [si].SourceHandle		; Normalize Source
	call	GetLinear386			; Linear address in edi
	jc	MEM3_SrcError			; Have Dest Error Code
	xchg	esi, edi			; Save source address in ESI
	mov	[bp.SrcHandle], bx		; Save Handle for Unlock

	lea	bx, [di].DestHandle
	call	GetLinear386			; Normalize Destination
	jc	MEM3_Error
	mov	[bp.DstHandle], bx		; Save Handle for Unlock

	smsw	ax
	shr	ax, 1				; Protected mode?
	jc	MEM3_MoveBlock			;   if so, use int 15h
						; Must preserve DS
	push	si
	push	di
	call	LEnblA20
	pop	di
	pop	si

	cmp	ax, 1
	jne	MEM3_Error

	xor	cx, cx
	mov	es, cx
	assume	es:Zero
	mov	ax, cs
	shl	eax, 16
	mov	ax, offset Int13Handx
	cli
	push	[OldInt13]			; For reentrancy
	xchg	eax, [Int13Vector]		; Install our int 13 handler
	mov	[OldInt13], eax
	sti

	push	ds				; save _text segment
	mov	ds, cx
	assume	ds:Zero
	mov	ecx, [bp.Count]
	shr	ecx, 1				; Now DWORD count
						; Odd word count in carry
	cld

; Now we have:
;	ESI = 32 bit Source Linear Address
;	EDI = 32 bit Destination Linear Address
;	DS = ES = 0
;
;	 If the limit of DS or ES is still the Real Mode
;	 default of 64k and ESI or EDI is greater than 64k,
;	 these instructions will fault with an int 13.
;	 In this case, our int 13 handler will set up
;	 the descriptors to have 4Gb limits (real big mode)
;	 and will iret to the faulting instruction.

;	 The following persuades masm to output
;	 both a 66h and 67h prefix

Fault0	=	Here3

	rep movs dword ptr [esi], dword ptr [edi]	; DWORDS first
			; THE NEXT INSTRUCTION MUST HAVE ADDRESS SIZE OVERRIDE
	db	67h		; BUG AVOIDANCE - DO NOT REMOVE
	nop			; BUG AVOIDANCE - DO NOT REMOVE

	rcl	ecx, 1
Fault1	=	Here3

	rep movs word ptr [esi], word ptr [edi]		; Now the odd word
			; THE NEXT INSTRUCTION MUST HAVE ADDRESS SIZE OVERRIDE
	db	67h		; BUG AVOIDANCE - DO NOT REMOVE
	nop			; BUG AVOIDANCE - DO NOT REMOVE

	pop	ds
	assume	ds:_text
	pop	eax				; saved [OldInt13]
	cli					; NECESSARY
	xchg	eax, [OldInt13]			; OldInt13 potentially INVALID
	mov	[Int13Vector], eax		; Deinstall our handler
	sti

	call	LDsblA20
	cmp	ax, 1
	jne	short MEM3_Error

MEM3_Exit:
	mov	bx, [bp.SrcHandle]		; Unlock Handles if necessary
	or	bx, bx
	jz	short MEM3_NoSrcHandle
	dec	[bx].cLock			; Unlock Source
MEM3_NoSrcHandle:
	mov	bx, [bp.DstHandle]
	or	bx, bx
	jz	short MEM3_NoDstHandle
	dec	[bx].cLock			; Unlock Destination
MEM3_NoDstHandle:
	pop	bx				; Restore original registers
	pop	edi
	pop	esi
	pop	ecx
	pop	eax
	mov	ax, 1
	cmp	word ptr [bp.Return], 0
	je	short MEM3_Success
	dec	ax				; AX = 0 for error
	mov	bl, byte ptr [bp.Return]
MEM3_Success:
	mov	sp, bp				; Unwind stack
	pop	bp
	ret

MEM3_InvCount:
	mov	bl, ERR_LENINVALID
	jmp	short MEM3_Error
MEM3_SrcError:
	cmp	bl, ERR_LENINVALID		; Invalid count
	je	short MEM3_Error		;   yes, no fiddle
	sub	bl, 2				; Convert to Source error code
MEM3_Error:
	mov	[bp.Return], bl
	jmp	short MEM3_Exit

;******************************************************************************
;
; GetLinear386
;	Convert Handle and Offset (or 0 and SEG:OFFSET) into Linear address
;	Locks Handle if necessary
;	Nested with Movext386 to access local variables
;
; Entry:
;	ES:BX	Points to structure containing:
;		Handle	dw
;		Offset	dd
;	ECX	Count of bytes to move
;
; Return:
;	BX	Handle of block (0 if conventional)
;	EDI	Linear address
;	CARRY	=> Error
;
; Registers Destroyed:
;	EAX
;
;------------------------------------------------------------------------------

GetLinear386	proc	near
	cli					; NO INTERRUPTS
	mov	edi, dword ptr es:[bx+2]	; Offset from start of handle
	mov	bx, word ptr es:[bx]		; Handle in bx
	or	bx, bx
	jz	short GL3_Conventional

	cmp	[bx].Flags, USEDFLAG		; Valid Handle?
	jne	short GL3_InvHandle

	mov	eax, [bx].Len			; Length of Block
	shl	eax, 10				; now in bytes
	sub	eax, edi			; EAX = max possible count
	jb	short GL3_InvOffset		; Base past end of block
	cmp	eax, ecx
	jb	short GL3_InvCount		; Count too big

	inc	[bx].cLock			; Lock Handle
	mov	eax, [bx].Base
	shl	eax, 10				; Base byte address
	add	edi, eax			; Linear address

GL3_OKExit:
	clc
	sti
	ret

GL3_Conventional:
	movzx	eax, di				; Offset in EAX
	shr	edi, 16
	shl	edi, 4				; Segment*16 in EDI
	add	edi, eax			; Linear address in EDI
	mov	eax, edi
	add	eax, ecx
	cmp	eax, 10FFF0h			; Max addressable inc. HMA
	jbe	GL3_OKExit
GL3_InvCount:
	mov	bl, ERR_LENINVALID
	jmp	short GL3_Error
GL3_InvHandle:
	mov	bl, ERR_DHINVALID		; Dest handle invalid
	jmp	short GL3_Error
GL3_InvOffset:
	mov	bl, ERR_DOINVALID		; Dest Offset invalid
GL3_Error:
	stc
	sti
	ret

GetLinear386	endp

;******************************************************************************
;
; Int13Handler
;	Handler for int 13 during our rep moves
;	If it is a real interrupt, jump to the old handler
;	If it is a fault, set Real Big Mode and return
;
; Entry:
;
; Return:
;
; Registers Destroyed:
;	BX, DS, ES if fault from one of our instructions, otherwise
;	NONE
;
;------------------------------------------------------------------------------

Int13Handx	=	Here3
Int13Handler	proc	far
	assume	ds:nothing, es:nothing
	push	bp
	mov	bp, sp			; Base to look at faulting address
	push	ax

	mov	al, 0Bh			; Party on PIC to see if interrupt
	out	20h, al
	jmp	$+2			; M001
	in	al, 20h			; ISR
	test	al, 20h			; IRQ5, int 13
	jnz	short NotOurInt13

	mov	ax, cs
	cmp	[bp+4], ax		; Fault from our cs?
	jne	short NotOurInt13	;   no, SOMETHING IS FUNNY!
	cmp	word ptr [bp+2], offset Fault0
	je	short LoadDescriptorCache
	cmp	word ptr [bp+2], offset Fault1
	jne	short NotOurInt13	; Not one of our instructions ????

LoadDescriptorCache:
	mov	bx, descRealBig - OurGDT ; Special 4Gb selector
	lgdt	fword ptr cs:[GDTPtr]

	mov	eax, cr0
	or	al,1
	mov	cr0, eax		; Go into Protected Mode
					; NOTE: NMIs will kill us!!!

	db	0eah			; jmp far flush_prot
	dw	offset flush_prot	; Clears the prefetch
	dw	descCS - OurGDT

flush_prot	=	Here3
	mov	es, bx			; Set up the segments we want
	mov	ds, bx

	and	al, 0FEh
	mov	cr0, eax		; Return to Real Mode

	db	0EAH			; jmp far flush_real
	dw	offset flush_real
patch3	= word ptr Here3
	dw	0

flush_real	=	Here3

	xor	ax, ax
	mov	ds, ax
	mov	es, ax

	pop	ax
	pop	bp
	iret				; Back to faulting instruction

NotOurInt13:
	pop	ax
	pop	bp
	jmp	cs:[OldInt13]

Int13Handler	endp

;******************************************************************************
;
; MEM3_MoveBlock
;	Set up GDT and call int 15h Move Block
;	Nested within Movext386
;	See 80286 programmer's reference manual for GDT entry format
;	See Int 15h documentation for Move Block function
;
; Entry:
;	[BP.Count]	Word count for move
;	ESI		Linear address of the source
;	EDI		Linear address of the destination
;
;	Interrupts are ON
;
; Return:
;	CARRY	=> Error
;		Error code in BL
;
; Registers Destroyed:
;	Flags, EAX, ECX, ESI, EDI, ES
;
;------------------------------------------------------------------------------
MEM3_MoveBlock:
	mov	[bp.SrcLinear], esi
	mov	[bp.DstLinear], edi

	push	cs			; set es -> funky segment
	pop	es


DMB_loop:
	mov	ecx, 512			; Do max of # words left or
	cmp	ecx, [bp.Count]			; or max Move Block allows
	jbe	short DMB0
	mov	ecx, [bp.Count]
DMB0:
	push	ecx
	lea	si, [GDTMoveBlock]		; Pointer to GDT for Block Move

	lea	di, [descSource.LO_apDesc386]	; Source Descriptor
	mov	eax, dword ptr [bp.SrcLinear]

	CLI					; No interrupts until int 15h
						; Allows reentrancy
	cld

	stosw
	shr	eax, 16
	stosb
	mov	byte ptr es:[di+2],ah		; Source Descriptor done

	lea	di, [descDest.LO_apDesc386]	; Destination Descriptor
	mov	eax, dword ptr [bp.DstLinear]
	stosw
	shr	eax, 16
	stosb
	mov	byte ptr es:[di+2],ah		; Destination Descriptor done

	clc					; MUST DO THIS, int 15h doesn't
	mov	ah, 87h				; Block Move - Assumes protect
	int	15h				; mode code allows interrupts

	sti
	pop	ecx
	jc	short DMB_Error

	sub	[bp.Count], ecx
	jz	MEM3_Exit			; All done
	shl	ecx, 1				; Back to byte count
	add	[bp.SrcLinear], ecx		; Update source for next chunk
	add	[bp.DstLinear], ecx		; Update destination
	jmp	short DMB_loop

DMB_Error:
	xor	bh, bh
	mov	bl, ah			; ah contains errorcode ;M003
	mov	bl, cs:[Int15Err][bx]		; Pick up correct error code
	jmp	MEM3_Error

Int15Err	=	byte ptr Here3
		db	0, ERR_PARITY, ERR_LENINVALID, ERR_A20

Movext386	endp
;*----------------------------------------------------------------------*
;*									*
;*  aAddMem - add memory to free pool					*
;*									*
;*	The trick here is that we're going to check for overlapping	*
;*	  or adjacent blocks and crunch them together.  The thinking	*
;*	  here is that we may be informed of a memory resource from	*
;*	  more than one source.  In any case, we NEVER want the same	*
;*	  memory to appear in our resource table more than once.	*
;*									*
;*	Note:  there's presently no way of reporting errors if the	*
;*	  handle table is full.  If it happens, we'll just lose the	*
;*	  memory block.  This should not be a problem as long as	*
;*	  we're only being called during program initialization.	*
;*									*
;*	It would be nice if we could throw this code away after		*
;*	  initialization, unfortunately this is actually invoked	*
;*	  at HookInt15 time, so it's too late to do away with		*
;*	  obsolete code.						*
;*									*
;*  ARGS:    BX:CX - base of block in 1K increments			*
;*	     DX:AX - length of block in 1K increments			*
;*  TRASHES: AX,BX,CX,DX,SI,DI						*
;*									*
;*  messes with handle table - not reentrant - assumes ints disabled	*
;*									*
;*----------------------------------------------------------------------*

AddMem	proc	far

	push	eax
	push	edx
	push	esi

;	We might as well be scanning for a free handle while we're
;	 at it since we're normally going to need one at the end

	mov	si, bx
	shl	esi, 16
	mov	si, cx		; ESI = Base of block to be added

	shl	edx, 16
	mov	dx, ax		; EDX = Len of block to be added

	xor	di,di		; haven't found free handle yet

	mov	bx,[KiddValley]	; prepare to loop thru handle tab
	mov	cx,[cHandles]

AM01:
	cmp	[bx].Flags,UNUSEDFLAG ; is this handle available?
	jnz	short AM02		; skip if not

	or	di,di		; use the first free handle we
	jnz	short AM05		;  find.  skip if we've got one

	mov	di,bx		; save the unused handle in di
	jmp	short AM05

AM02:


;	Note:  Normally all handles will be either UNUSED or FREE at
;	  this point.  However, in the case of checking for Zenith memory,
;	  it may have a temporarily allocated dummy block.  Therefore
;	  we'll only be merging blocks marked as FREE.

	cmp	[bx].Flags,FREEFLAG
	jnz	short AM05		; ignore USED blocks

;	   First check for new block being entirely after block at [bx]

	mov	eax,[bx].Base
	add	eax,[bx].Len
	cmp	eax,esi		; is [bx].end < new.Base?
	jb	short AM05	;  done checking this entry if so

;	   Now check for new block being entirely before block at [bx]

	mov	eax,esi		; new.base
	add	eax,edx		; + new.len = new.end
	cmp	eax,[bx].Base
	jb	short AM05		; brif no overlap at all
;
;	   Now suck the block at [bx] up into our block in registers so
;	   that we can continue the scan.  There may be other adjacent
;	   blocks, even in the case of no overlap, fr'instance when a
;	   block is added which entirely fills the gap between two others.

	mov	eax, [bx].Len
	add	eax, [bx].Base	; EAX = end of this block
	add	edx, esi	; EDX = end of new block

	cmp	esi, [bx].Base	; does the current block start before the new
	jbe	short @f	;  no, keep the new start
	mov	esi, [bx].Base	;  yes, update new block start
@@:
	cmp	edx, eax	; does the cur block end after the new one
	jae	short @f	;  no, keep the new end
	mov	edx, eax	;  yes, update the new end
@@:
	sub	edx, esi	; DX = Length of combined block
				; SI = Base of Combined block

	mov	[bx].Flags,UNUSEDFLAG ; mark the block unused
	or	di,di		; did we find an unused handle yet?
	jnz	short AM05	;  brif so
	mov	di,bx		; save this one if not

AM05:
	add	bx,SIZE handle
	loop    AM01

	or	di,di		; did we find a free handle?
	jz	short AM06	;  error!  no handles free!

	mov	[di].cLock,0
	mov	[di].Flags,FREEFLAG ; create the free memory block
	mov	[di].Base,esi
	mov	[di].Len,edx
AM06:
	pop	esi
	pop	edx
	pop	eax
	ret

AddMem	endp

End386	label	byte


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kdfeof.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */





	PAGE	,132
	TITLE	MS-DOS TUGBOAT Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS TUGBOAT - NLS Support - Keyboard Definition File
;;
;; This file contains the eof marker for the entire table
;; and the keyboard.sys copyright information
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
				       ;;
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Copyright statement
;;	DB 'Authors : Bill Devlin, Nick Savage, Mike Saunders, et al..',13,10
;;	DB 'Development: Toronto,Boca Raton,Basingstoke',13,10

include copyrigh.inc
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	DB  1AH 		       ;; EOF
				       ;;
CODE	ENDS			       ;;
	END			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kdfdk.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	PAGE	,132


	TITLE	MS-DOS 5.0 Keyboard Definition File

;; LATEST CHANGE P12 NUMERIC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Definition File
;;
;; This file contains the keyboard tables for Danish
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;; Updated:    MIKE SAUNDERS - WSD IBM Hursley Laboratory - August 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC DK_LOGIC 	       ;;
	PUBLIC DK_865_XLAT	       ;;
	PUBLIC DK_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a linear search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; DK State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
DK_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  0			       ;; special features
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;  ***BD - THIS SECTION HAS BEEN UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 IFF EITHER_CTL,NOT		       ;;
    IFF EITHER_ALT,NOT		       ;;
      IFF EITHER_SHIFT		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
    ELSEF			       ;;
      IFKBD G_KB+P12_KB 	       ;; For ENHANCED keyboard some
      ANDF R_ALT_SHIFT		       ;;  dead keys are on third shift
      ANDF EITHER_SHIFT,NOT	       ;;   which is accessed via the altgr key
	 SET_FLAG DEAD_THIRD	       ;;
      ENDIFF			       ;;
    ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO TILDE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TILDE_PROC:			       ;;
				       ;;
   IFF TILDE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT TILDE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_UPPER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_LOWER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_TILDE:			       ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;; ***BD - NON_DEAD THRU LOGIC_END IS UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NON_DEAD:			       ;;
				       ;;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
				       ;;
 IFF  EITHER_CTL,NOT		       ;; Lower and upper case.  Alphabetic
    IFF EITHER_ALT,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  ENDIFF		       ;;
      ENDIFF			       ;; Third and Fourth shifts
    ELSEF			       ;; ctl off, alt on at this point
      IFKBD XT_KB+AT_KB 	 ;; XT, AT,  keyboards. Nordics
	 IFF EITHER_SHIFT	       ;; only.
	    XLATT FOURTH_SHIFT	       ;; ALT + shift
	 ELSEF			       ;;
	    XLATT THIRD_SHIFT	       ;; ALT
	 ENDIFF 		       ;;
      ELSEF			       ;; ENHANCED keyboard
	 IFF R_ALT_SHIFT	       ;; ALTGr
	 ANDF EITHER_SHIFT,NOT	       ;;
	    XLATT THIRD_SHIFT	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
    ENDIFF			       ;;
 ENDIFF 			       ;;
;**************************************;;
 IFF EITHER_SHIFT,NOT		       ;;
   IFKBD XT_KB+AT_KB		 ;;
     IFF EITHER_CTL		       ;;
     ANDF ALT_SHIFT		       ;;
       XLATT ALT_CASE		       ;;
     ENDIFF			       ;;
   ENDIFF			       ;;
   IFKBD G_KB+P12_KB		       ;;
     IFF EITHER_CTL		       ;;
     ANDF ALT_SHIFT		       ;;
       IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ALT_CASE 	       ;;
       ENDIFF			       ;;
     ENDIFF			       ;;
   ENDIFF			       ;;
 ENDIFF 			       ;;
;**************************************;;
 IFKBD AT_KB+XT_KB		 ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF ALT_SHIFT		       ;; ALT - case
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
 IFKBD G_KB+P12_KB		       ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF ALT_SHIFT		       ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
 EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;**********************************************************************
;; DK Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; Some common Characters are included from 128 - 165 where appropriate.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC DK_COMMON_XLAT		       ;;
DK_COMMON_XLAT: 		       ;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_LO_END-$	       ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 13			       ;; scan code
   FLAG  ACUTE			       ;; flag bit to set
   DB	 27			       ;;
   FLAG  DIARESIS		       ;;
				       ;;
				       ;;
COM_DK_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_UP_END-$	       ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 13			       ;; scan code
   FLAG  GRAVE			       ;; flag bit to set
   DB	 27			       ;;
   FLAG  CIRCUMFLEX		       ;;
				       ;;
COM_DK_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_TH_END-$	       ;; length of state section
   DB	 DEAD_THIRD		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 27			       ;; scan code
   FLAG  TILDE			       ;; flag bit to set
				       ;;
COM_DK_TH_END:			       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR NUMERIC PAD (DECIMAL SEPERATOR)
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common		       ;;change **********CNS **************
;; STATE: Numeric Key Pad
;; KEYBOARD TYPES: All except the p12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_PAD_K1_END-$	       ;; length of state section
   DB	 NUMERIC_PAD		       ;; State ID
   DW	 G_KB+AT_KB+XT_KB	       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_PAD_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 83,','                        ;; decimal seperator = ,
COM_PAD_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_PAD_K1_END: 		       ;;
				       ;;
;;******************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_ALT_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 0			       ;; 2 number of entries
;  DB	 12,-1,-1		       ;;
;  DB	 53,0,082H		       ;;
COM_ALT_K1_T1_END:		       ;;
					;;
    DW	  0				;; Size of xlat table - null table
				       ;;
COM_ALT_K1_END: 		       ;;
					;;
;;******************************
;;***BD - ADDED FOR CTRL CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: XT, , AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 XT_KB+AT_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	 12,-1,-1		       ;;
   DB	 53,01FH,35h		       ;;
COM_CTRL_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K2_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K2_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 8			       ;; number of entries
   DB	  9,01BH,09H		       ;;
   DB	 10,01DH,0AH		       ;;
   DB	 12,-1,-1		       ;;
   DB	 26,-1,-1		       ;;
   DB	 27,-1,-1		       ;;
   DB	 43,-1,-1		       ;;
   DB	 53,01FH,35H			;;
   DB	 86,01CH,56H			;;
COM_CTRL_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_LO_END-$	       ;; length of state section
   DB	 ALPHA_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of entries
   DB	 26,086H		       ;; a-overcircle
   DB	 39,091H		       ;; ae-dipthong
   DB	 40,09BH		       ;; o-slash
COM_AL_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_UP_END-$	       ;; length of state section
   DB	 ALPHA_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of entries
   DB	 26,08FH		       ;; A-OVERCIRCLE
   DB	 39,092H		       ;; AE-DIPTHONG
   DB	 40,09DH		       ;; O-SLASH
COM_AL_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_UP_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 41,0ABH		       ;; 
   DB	 12,"+"                        ;; + INCLUDED FOR SIMPLIC.
   DB	 43,"'"                        ;; '
   DB	 86,"<"                        ;; <
   DB	 53,"-"                        ;; -
COM_NA_LO_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K2_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K2_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 41,"'"                        ;; '
   DB	 12,"+"                        ;; +
   DB	 43,"<"                        ;; <
   DB	 53,"-"                        ;; -
COM_NA_LO_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K2_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K3_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K3_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 12,"+"                        ;; +
   DB	 41,"<"                        ;; <
   DB	 43,"'"                        ;; '
   DB	 53,"-"                        ;; -
COM_NA_LO_K3_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K3_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 12			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 43,'*'                        ;;
   DB	 86,'>'                        ;;
COM_NA_UP_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K2_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 12			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 41,'*'                        ;;
   DB	 43,'>'                        ;;
COM_NA_UP_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K3_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K3_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 12			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
   DB	 41,'>'                        ;;
   DB	 43,'*'                        ;;
COM_NA_UP_K3_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K3_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type FERRARI
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	  3,'@'                        ;;
   DB	  4,09CH		       ;; 
   DB	  5,'$'                        ;;
   DB	  8,'{'                        ;;
   DB	  9,'['                        ;;
   DB	 10,']'                        ;;
   DB	 11,'}'                        ;;
   DB	 13,'|'                        ;; Broken Vertical Line
   DB	 86,'\'                        ;;
COM_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift (ALTERNATE)
;; KEYBOARD TYPES: XT,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	 12,'-','-'                    ;;
   DB	 13,'=','='                    ;;
   DB	 26,'[','['                    ;;
   DB	 27,']',']'                    ;;
   DB	 39,';',';'                    ;;
   DB	 40,027H,027H		       ;;
   DB	 41,060H,060H		       ;;
   DB	 43,'\','\'                    ;;
   DB	 53,'/','/'                    ;;
COM_THIRD_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift (ALTERNATE)
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K2_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K2_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	 12,'-','-'                    ;;
   DB	 13,'=','='                    ;;
   DB	 26,'[','['                    ;;
   DB	 27,']',']'                    ;;
   DB	 39,';',';'                    ;;
   DB	 40,027H,027H		       ;;
   DB	 41,'\','\'                    ;;
   DB	 43,060H,060H		       ;;
   DB	 53,'/','/'                    ;;
COM_THIRD_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Fourth Shift (ALTERNATE+SHIFT)
;; KEYBOARD TYPES: XT,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_FOURTH_END-$	       ;; length of state section
   DB	 FOURTH_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_FOURTH_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 18			       ;; number of entries
   DB	  3,'@','@'                    ;;
   DB	  5,'$','$'                    ;;
   DB	  7,'^','^'                    ;;
   DB	  8,'&','&'                    ;;
   DB	  9,'*','*'                    ;;
   DB	 10,'(','('                    ;;
   DB	 11,')',')'                    ;;
   DB	 12,'_','_'                    ;;
   DB	 13,'+','+'                    ;;
   DB	 26,'{','{'                    ;;
   DB	 27,'}','}'                    ;;
   DB	 39,':',':'                    ;;
   DB	 40,'"','"'                    ;;
   DB	 41,'~','~'                    ;;
   DB	 43,'|','|'                    ;;
   DB	 51,'<','<'                    ;;
   DB	 52,'>','>'                    ;;
   DB	 53,'?','?'                    ;;
COM_FOURTH_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_FOURTH_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Fourth Shift (ALTERNATE+SHIFT)
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_FOURTH_K1_END-$	       ;; length of state section
   DB	 FOURTH_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_FOURTH_K1_T1_END-$        ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 18			       ;; number of entries
   DB	  3,'@','@'                    ;;
   DB	  5,'$','$'                    ;;
   DB	  7,'^','^'                    ;;
   DB	  8,'&','&'                    ;;
   DB	  9,'*','*'                    ;;
   DB	 10,'(','('                    ;;
   DB	 11,')',')'                    ;;
   DB	 12,'_','_'                    ;;
   DB	 13,'+','+'                    ;;
   DB	 26,'{','{'                    ;;
   DB	 27,'}','}'                    ;;
   DB	 39,':',':'                    ;;
   DB	 40,'"','"'                    ;;
   DB	 41,'|','|'                    ;;
   DB	 43,'~','~'                    ;;
   DB	 51,'<','<'                    ;;
   DB	 52,'>','>'                    ;;
   DB	 53,'?','?'                    ;;
COM_FOURTH_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_FOURTH_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_LO_END-$	       ;; length of state section
   DB	 GRAVE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
COM_GR_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_SP_END-$	       ;; length of state section
   DB	 GRAVE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,96			       ;; STANDALONE GRAVE
COM_GR_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,94			       ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_LO_END-$		;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  COM_TI_LO_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  1				;; number of scans
    DB	  49,0A4H			;; scan code,ASCII - 
 COM_TI_LO_T1_END:			;;
					;;
    DW	  0				;;
					;;
 COM_TI_LO_END: 			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: Common
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  COM_TI_UP_END-$		;; length of state section
    DB	  TILDE_UPPER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  COM_TI_UP_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  1				;; number of scans
    DB	  49,0A5H			;; scan code,ASCII - 
 COM_TI_UP_T1_END:			;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 COM_TI_UP_END: 			;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_TI_SP_END-$	       ;; length of state section
   DB	 TILDE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 07EH,0 		       ;; error character = standalone accent
				       ;;
   DW	 COM_TI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,07EH		       ;; STANDALONE TILDE
COM_TI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_TI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; DK Specific Translate Section for 865
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC DK_865_XLAT		       ;;
DK_865_XLAT:			       ;;
				       ;;
   DW	  CP865_XLAT_END-$	       ;; length of section
   DW	  865			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 865
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT, , AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP865_NA_UP_END-$		 ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB+AT_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP865_NA_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	  5,0AFH		       ;; International Currency Symb
CP865_NA_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP865_NA_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 865
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP865_NA_UP_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP865_NA_UP_K1_T1_END-$       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	  5,0AFH		       ;; International Currency Symb
   DB	 41,015H		       ;; SECTION Symb
CP865_NA_UP_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP865_NA_UP_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 865
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP865_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP865_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP865_AC_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP865_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 865
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP865_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP865_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 18,''                        ;; scan code,ASCII - 
CP865_AC_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP865_AC_UP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 865
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP865_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP865_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,39			       ;; scan code,ASCII - SPACE
CP865_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP865_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP865
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP865_DI_LO_END-$		 ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 254,0			       ;; error character = standalone accent
				       ;;
   DW	 CP865_DI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 21,''                        ;; scan code,ASCII - y
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP865_DI_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP865_DI_LO_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP865
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP865_DI_UP_END-$		 ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 254,0			       ;; error character = standalone accent
				       ;;
   DW	 CP865_DI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 22,''                        ;; scan code,ASCII - U
   DB	 24,''                        ;; scan code,ASCII - O
   DB	 30,''                        ;; scan code,ASCII - A
CP865_DI_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP865_DI_UP_END:			 ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 865
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				       ;;
;  DW	 CP865_DI_SP_END-$		 ;; length of state section
;  DB	 DIARESIS_SPACE 	       ;; State ID
;  DW	 ANY_KB 		       ;; Keyboard Type
;  DB	 254,0			       ;; error character = standalone accent
;				       ;;
;  DW	 CP865_DI_SP_T1_END-$		 ;; Size of xlat table
;  DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;  DB	 1			       ;; number of scans
;  DB	 57,254 		       ;; error character = standalone accent
;CP865_DI_SP_T1_END:			 ;;
;				       ;;
;  DW	 0			       ;; Size of xlat table - null table
;CP865_DI_SP_END:			 ;; length of state section
;				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	  0			       ;; LAST STATE
				       ;;
CP865_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; DK Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC DK_850_XLAT		       ;;
DK_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT, , AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_UP_END-$		 ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB+AT_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_NA_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	  5,0CFH		       ;; International Currency Symb
CP850_NA_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_UP_END:			 ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G, P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_UP_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_NA_UP_K1_T1_END-$       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of entries
   DB	  5,0CFH		       ;; International Currency Symb
   DB	 41,0F5H		       ;; SECTION Symb
CP850_NA_UP_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_UP_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 21,0ECH		       ;; y acute
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP850_AC_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of entries
   DB	 18,090H		       ;;    E acute
   DB	 21,0EDH		       ;;    Y acute
   DB	 22,0E9H		       ;;    U acute
   DB	 23,0D6H		       ;;    I acute
   DB	 24,0E0H		       ;;    O acute
   DB	 30,0B5H		       ;;    A acute
CP850_AC_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_UP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 239,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,239 		       ;; scan code,ASCII - SPACE
CP850_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_LO_END-$		 ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 21,''                        ;; scan code,ASCII - y
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
CP850_DI_LO_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_LO_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_UP_END-$		 ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D3H		       ;;    E Diaeresis
   DB	 22,''                        ;;    U Diaeresis
   DB	 23,0D8H		       ;;    I Diaeresis
   DB	 24,''                        ;;    O Diaeresis
   DB	 30,''                        ;;    A Diaeresis
CP850_DI_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_UP_END:			 ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_SP_END-$		 ;; length of state section
   DB	 DIARESIS_SPACE 	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,249 		       ;; error character = standalone accent
CP850_DI_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
CP850_DI_SP_END:			 ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_GR_UP_END-$	       ;; length of state section
   DB	 GRAVE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_GR_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D4H		       ;;    E grave
   DB	 22,0EBH		       ;;    U grave
   DB	 23,0DEH		       ;;    I grave
   DB	 24,0E3H		       ;;    O grave
   DB	 30,0B7H		       ;;    A grave
CP850_GR_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_GR_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Tilde Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_LO_END-$		;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  CP850_TI_LO_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  24,0E4H			;; scan code,ASCII - o tilde
    DB	  30,0C6H			;; scan code,ASCII - a tilde
 CP850_TI_LO_T1_END:			;;
					;;
    DW	  0				;;
					;;
 CP850_TI_LO_END:			;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: 850
;;; STATE: Tilde Upper Case
;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_UP_END-$		;; length of state section
    DB	  TILDE_UPPER			;; State ID
    DW	  ANY_KB			;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  CP850_TI_UP_T1_END-$		;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  24,0E5H			;; scan code,ASCII - O tilde
    DB	  30,0C7H			;; scan code,ASCII - A tilde
 CP850_TI_UP_T1_END:			;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 CP850_TI_UP_END:			;; length of state section
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_CI_UP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_UPPER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_CI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,0D2H		       ;;    E circumflex
   DB	 22,0EAH		       ;;    U circumflex
   DB	 23,0D7H		       ;;    I circumflex
   DB	 24,0E2H		       ;;    O circumflex
   DB	 30,0B6H		       ;;    A circumflex
CP850_CI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_CI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kdffr.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;; LATEST CHANGE ALT & CTL  disenabled US invalids


;; Section symbol scan code incorrect
;; zero scan code tag deleted from end of tag field
;; Changed key #5 for the XT "/" instead of "'"..Pubs error
;; ****************** CNS 12/18/86*************************

	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Spanish.
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC FR_LOGIC 	       ;;
	PUBLIC FR_437_XLAT	       ;;
	PUBLIC FR_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; FR State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
FR_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  TYPEWRITER_CAPS_LK	       ;; special features (shift lock state)
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
     IFF CAPS_STATE
	 SET_FLAG DEAD_UPPER
     ELSEF
      IFF EITHER_SHIFT		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
     ENDIFF			      ;;
   ENDIFF			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_SPACE    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
NON_DEAD:			       ;;
				       ;;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
;;***BD ADDED FOR ALT, CTRL CASES      ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF  ALT_SHIFT 	       ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
;;***BD END OF ADDITION
				       ;;
   IFF	EITHER_ALT,NOT		       ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
;	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	      XLATT NON_ALPHA_LOWER    ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  XLATT NON_ALPHA_UPPER        ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
;	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  XLATT NON_ALPHA_UPPER        ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  XLATT NON_ALPHA_LOWER        ;;
	  ENDIFF		       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_SHIFT,NOT	       ;;
	  IFKBD XT_KB+AT_KB	 ;;
	      IFF  EITHER_CTL	       ;;
	      ANDF ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ELSEF 		       ;;
	      IFF EITHER_CTL,NOT       ;;
	      ANDF R_ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	   ENDIFF		       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
				       ;;
   EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;					;;
;NON_DEAD:				;;
;					;;
;   IFF  EITHER_ALT,NOT 		;; Lower and upper case.  Alphabetic
;   ANDF EITHER_CTL,NOT 		;; keys are affected by CAPS LOCK.
;      IFF EITHER_SHIFT 		;; Numeric keys are not.
;	   XLATT NON_ALPHA_UPPER	;;
;	   IFF CAPS_STATE		;;
;	       XLATT ALPHA_LOWER	;;
;	   ELSEF			;;
;	       XLATT ALPHA_UPPER	;;
;	   ENDIFF			;;
;      ELSEF				;;
;	   XLATT NON_ALPHA_LOWER	;;
;	   IFF CAPS_STATE		;;
;	      XLATT ALPHA_UPPER 	;;
;	   ELSEF			;;
;	      XLATT ALPHA_LOWER 	;;
;	   ENDIFF			;;
;      ENDIFF				;;
;   ELSEF				;;
;      IFF EITHER_SHIFT,NOT		;;
;	   IFKBD XT_KB+AT_KB	  ;;
;	       IFF  EITHER_CTL		;;
;	       ANDF ALT_SHIFT		;;
;		   XLATT THIRD_SHIFT	;;
;	       ENDIFF			;;
;	   ELSEF			;;
;	       IFF EITHER_CTL,NOT	;;
;	       ANDF R_ALT_SHIFT 	;;
;		   XLATT THIRD_SHIFT	;;
;	       ENDIFF			;;
;	    ENDIFF			;;
;      ENDIFF				;;
;   ENDIFF				;;
;					;;
;   EXIT_STATE_LOGIC			;;
;					;;
;LOGIC_END:				;;
;					;;
;					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; FR Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC FR_COMMON_XLAT		       ;;
FR_COMMON_XLAT: 		       ;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_LO_END-$	       ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  CIRCUMFLEX		       ;; flag bit to set
;  DB	 40	    eliminate	       ;;
;  FLAG  ACUTE			       ;;
				       ;;
				       ;;
COM_DK_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_UP_END-$	       ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  DIARESIS		       ;; flag bit to set
;  DB	 40	      eliminate        ;;
;  FLAG  DIARESIS		       ;;
				       ;;
COM_DK_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;**********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    COM_DK_TH_END-$		 ;; length of state section
;;   DB    DEAD_THIRD			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    -1,-1			 ;; Buffer entry for error character
;;					 ;; Set Flag Table
;;   DW    1				 ;; number of entries
;;   DB    8				 ;; scan code
;;   FLAG  GRAVE			 ;; flag bit to set
;;					 ;;
;;COM_DK_TH_END:			 ;;
;;					 ;;
;;					 ;;
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_ALT_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 10			       ;; Number of entries
   DB	 12,-1,-1		       ;; invalid key U.S. alt -
   DB	 13,-1,-1		       ;; invalid key U.S. alt =
   DB	 07,0,82H		       ;; alt - (minus sign)
   DB	 13,0,83H		       ;; alt = (equal sign)
   DB	 16,0,1EH		       ;; A
   DB	 17,0,2CH		       ;; Z
   DB	 30,0,10H		       ;; Q
   DB	 39,0,32H		       ;; M
   DB	 44,0,11H		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_ALT_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_ALT_K1_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 12			       ;; Number of entries
   DB	 12,-1,-1		       ;;
   DB	 07,30,07		       ;; ctl + number six key
   DB	 12,29,12		       ;; ctl + ]
   DB	 13,31,13		       ;;
   DB	 16,01,16		       ;; A
   DB	 17,26,17		       ;; Z
   DB	 30,17,30		       ;; Q
   DB	 39,13,39		       ;; M
   DB	 43,-1,-1		       ;; \
   DB	 44,23,44		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
   DB	 9,28,9 		      ;;  \ position (this is also the underscore position)
COM_CTRL_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: AT + XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K2_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 AT_KB+XT_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_ALT_K2_T2_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 9			       ;; Number of entries
   DB	 12,-1,-1		       ;; invalid key U.S. alt -
   DB	 13,0,82H		       ;; alt - (minus sign)
   DB	 53,0,83H		       ;; alt = (equal sign)
   DB	 16,0,1EH		       ;; A
   DB	 17,0,2CH		       ;; Z
   DB	 30,0,10H		       ;; Q
   DB	 39,0,32H		       ;; M
   DB	 44,0,11H		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_ALT_K2_T2_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_ALT_K2_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K2_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_K2_T2_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 11				;; Number of entries
   DB	 12,-1,-1		       ;; invalid U.S. -
   DB	 43,-1,-1		       ;; invalid U.S. \
   DB	 41,28,41		       ;; valid ctl + \
   DB	 07,30,07		       ;; ctl + number six key
   DB	 13,31,13		       ;; ctl - or _
   DB	 16,01,16		       ;; A
   DB	 17,26,17		       ;; Z
   DB	 30,17,30		       ;; Q
   DB	 39,13,39		       ;; M
   DB	 44,23,44		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_CTRL_K2_T2_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_K2_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K3_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 AT_KB+XT_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_K3_T3_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 11			       ;; Number of entries
   DB	 12,-1,-1		       ;;
   DB	 43,-1,-1		       ;;
   DB	 43,28,43		       ;; valid ctl + \
   DB	 07,30,07		       ;; ctl + number six key
   DB	 13,31,13		       ;; ctl - or _
   DB	 16,01,16		       ;; A
   DB	 17,26,17		       ;; Z
   DB	 30,17,30		       ;; Q
   DB	 39,13,39		       ;; M
   DB	 44,23,44		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_CTRL_K3_T3_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_K3_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;******************************************************************************
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_LO_END-$	       ;; length of state section
   DB	 ALPHA_LOWER		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 16,'a'                        ;; small a
   DB	 17,'z'                        ;; small z
   DB	 30,'q'                        ;; small q
   DB	 39,'m'                        ;; small m
   DB	 44,'w'                        ;; small w
COM_AL_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_UP_END-$	       ;; length of state section
   DB	 ALPHA_UPPER		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 16,'A'                        ;; caps  A
   DB	 17,'Z'                        ;; caps  Z
   DB	 30,'Q'                        ;; caps  Q
   DB	 39,'M'                        ;; caps  M
   DB	 44,'W'                        ;; caps  W
COM_AL_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_UP_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_T1_K1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 21			       ;; number of entries
   DB	 41,""                        ;; superscript 2
   DB	  2,"&"                        ;;
   DB	  3,""                        ;; acute - e
   DB	  4,'"'                        ;;
   DB	  5,"'"                        ;;
   DB	  6,"("                        ;;
   DB	  7,"-"                        ;;
   DB	  8,""                        ;; grave - e
   DB	  9,"_"                        ;;
   DB	 10,""                        ;; c - cedilla small
   DB	 11,""                        ;;
   DB	 12,")"                        ;;
   DB	 13,"="                        ;;
   DB	 27,"$"                        ;;
   DB	 40,""                        ;; grave - u
   DB	 43,"*"                        ;;
   DB	 86,'<'                        ;; +
   DB	 50,','                        ;; <
   DB	 51,';'                        ;; -
   DB	 52,':'                        ;;
   DB	 53,'!'                        ;;

COM_NA_LO_T1_K1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_T1_K2_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	  2,"&"                        ;;
   DB	  3,""                        ;; acute - e
   DB	  4,'"'                        ;;
   DB	  5,"'"                        ;;
   DB	  6,"("                        ;;
   DB	  7,"-"                        ;;
   DB	  8,""                        ;; grave - e
   DB	  9,"!"                        ;;
   DB	 10,""                        ;; c - cedilla small
   DB	 11,""                        ;; grave - a small
   DB	 12,")"                        ;;
   DB	 13,"-"                        ;;
   DB	 27,"$"                        ;;
   DB	 40,""                        ;; grave  small
   DB	 43,0E6H		       ;; mu symbol - 
   DB	 41,'<'                        ;; +
   DB	 50,','                        ;; <
   DB	 51,';'                        ;; -
   DB	 52,':'                        ;;
   DB	 53,'='                        ;;

COM_NA_LO_T1_K2_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K2_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_T1_K3_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	  2,"&"                        ;;
   DB	  3,""                        ;; acute - e
   DB	  4,'"'                        ;; ' on the AT_KB
   DB	  5,"'"                        ;; *** CNS **** 12/18/86 pubs wrong
   DB	  6,"("                        ;;
   DB	  7,"-"                        ;;
   DB	  8,""                        ;; grave - e
   DB	  9,"!"                        ;;
   DB	 10,""                        ;; c - cedilla small
   DB	 11,""                        ;;
   DB	 12,")"                        ;;
   DB	 13,"-"                        ;;
   DB	 27,"$"                        ;;
   DB	 40,""                        ;; grave  small
   DB	 41,0E6H		       ;; mu symbol - 
   DB	 43,'<'                        ;; +
   DB	 50,','                        ;; <
   DB	 51,';'                        ;; -
   DB	 52,':'                        ;;
   DB	 53,'='                        ;;
COM_NA_LO_T1_K3_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K3_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 21			       ;; number of entries
   DB	  2,'1'                        ;;
   DB	  3,'2'                        ;;
   DB	  4,'3'                        ;;
   DB	  5,'4'                        ;;
   DB	  6,'5'                        ;;
   DB	  7,'6'                        ;;
   DB	  8,'7'                        ;;
   DB	  9,'8'                        ;;
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0F8H		       ;; degree symbol
   DB	 13,"+"                        ;; plus sign
   DB	 27,09CH		       ;;  symbol
   DB	 40,'%'                        ;;
   DB	 41,""                        ;; superscript 3
   DB	 43,0E6H		       ;;  - mu symbol
   DB	 86,'>'                        ;;
   DB	 50,'?'                        ;;
   DB	 51,'.'                        ;;
   DB	 52,'/'                        ;;
   DB	 53,'+'                        ;;
COM_NA_UP_T1_K1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K2_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	  2,'1'                        ;;
   DB	  3,'2'                        ;;
   DB	  4,'3'                        ;;
   DB	  5,'4'                        ;;
   DB	  6,'5'                        ;;
   DB	  7,'6'                        ;;
   DB	  8,'7'                        ;;
   DB	  9,'8'                        ;;
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0F8H		       ;; degree symbol
   DB	 13,"_"                        ;; underscore
   DB	 43,09CH		       ;;  symbol
   DB	 40,'%'                        ;;
   DB	 27,"*"                        ;; asterisk
   DB	 41,'>'                        ;;
   DB	 50,'?'                        ;;
   DB	 51,'.'                        ;;
   DB	 52,'/'                        ;;
   DB	 53,'+'                        ;;
COM_NA_UP_T1_K2_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K3_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	  2,'1'                        ;;
   DB	  3,'2'                        ;;
   DB	  4,'3'                        ;;
   DB	  5,'4'                        ;;
   DB	  6,'5'                        ;;
   DB	  7,'6'                        ;;
   DB	  8,'7'                        ;;
   DB	  9,'8'                        ;;
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0F8H		       ;; degree symbol
   DB	 13,"_"                        ;; underscore
   DB	 41,09CH		       ;;  symbol
   DB	 40,'%'                        ;;
   DB	 27,"*"                        ;; asterisk
   DB	 43,'>'                        ;;
   DB	 50,'?'                        ;;
   DB	 51,'.'                        ;;
   DB	 52,'/'                        ;;
   DB	 53,'+'                        ;;
COM_NA_UP_T1_K3_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K3_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB +P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 11			       ;; number of entries
   DB	  3,'~'                        ;;
   DB	  4,'#'                        ;;
   DB	  5,'{'                        ;;
   DB	  6,'['                        ;;
   DB	  7,'|'                        ;;
   DB	  8,'`'                        ;; grave symbol not a dead key rep
   DB	  9,'\'                        ;;
   DB	 10,'^'                        ;; circumflex (caret)
   DB	 11,'@'                        ;;
   DB	 12,']'                        ;;
   DB	 13,'}'                        ;;
COM_THIRD_T1_K1_END:			  ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K2_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K2_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  6			       ;; number of entries
   DB	  4,'#'                        ;;
   DB	  26,'['                       ;;
   DB	  27,']'                       ;;
   DB	  41,'\'                       ;;
   DB	  3,'@'                        ;;
   DB	  7,'^'                        ;; circumflex (caret)
COM_THIRD_T1_K2_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K2_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: XT_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K3_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K3_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  6			       ;; number of entries
   DB	  4,'#'                        ;;
   DB	  26,'['                       ;;
   DB	  27,']'                       ;;
   DB	  43,'\'                       ;;
   DB	  3,'@'                        ;;
   DB	  7,'^'                        ;; circumflex (caret)
COM_THIRD_T1_K3_END:			  ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K3_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AC_LO_END-$	       ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_AC_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
COM_AC_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AC_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    COM_AC_UP_END-$		 ;; length of state section
;;   DB    ACUTE_UPPER			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    39,0 			 ;; error character = standalone accent
;;					 ;;
;;   DW    COM_AC_UP_T1_END-$		 ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
;;   DB    2				 ;; number of scans
;;   DB    18,''                        ;; scan code,ASCII - e
;;COM_AC_UP_T1_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;COM_AC_UP_END:			 ;;
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    COM_AC_SP_END-$		 ;; length of state section
;;   DB    ACUTE_SPACE			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    39,0 			 ;; error character = standalone accent
;;					 ;;
;;   DW    COM_AC_SP_T1_END-$		 ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
;;   DB    1				 ;; number of scans
;;   DB    57,39			 ;; scan code,ASCII - SPACE
;;COM_AC_SP_T1_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;COM_AC_SP_END:			 ;;
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_LO_END-$	       ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_DI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 21,''                        ;; scan code,ASCII - y
COM_DI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_UP_END-$	       ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_DI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
COM_DI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_UP_END:			       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_SP_END-$	       ;; length of state section
   DB	 DIARESIS_SPACE 	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_DI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,249 		       ;; error character = standalone accent
COM_DI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
COM_DI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    COM_GR_LO_END-$		 ;; length of state section
;;   DB    GRAVE_LOWER			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    96,0 			 ;; error character = standalone accent
;;					 ;;
;;   DW    COM_GR_LO_T1_END-$		 ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
;;   DB    5				 ;; number of scans
;;   DB    18,''                        ;; scan code,ASCII - e
;;   DB    30,''                        ;; scan code,ASCII - a
;;   DB    24,''                        ;; scan code,ASCII - o
;;   DB    22,''                        ;; scan code,ASCII - u
;;   DB    23,''                        ;; scan code,ASCII - i
;;COM_GR_LO_T1_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;COM_GR_LO_END:			 ;; length of state section
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    COM_GR_SP_END-$		 ;; length of state section
;;   DB    GRAVE_SPACE			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    96,0 			 ;; error character = standalone accent
;;					 ;;
;;   DW    COM_GR_SP_T1_END-$		 ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
;;   DB    1				 ;; number of scans
;;   DB    57,96			 ;; STANDALONE GRAVE
;;COM_GR_SP_T1_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;COM_GR_SP_END:			 ;; length of state section
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,94			       ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; FR Specific Translate Section for 437
;; 437 IS COMPLETELY COVERED BY THE COMMON TABLE.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC FR_437_XLAT		       ;;
FR_437_XLAT:			       ;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+ p12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP437_NA_UP_T1_K1_END-$	  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options: **** CNS 12/18
   DB	 1			       ;; number of scans
   DB	 53,015H		       ;; Section symbol - 
CP437_NA_UP_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_UP_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT + XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_LO_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB+XT_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP437_NA_LO_T1_K1_END-$	  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options: **** CNS 12/18
   DB	 1			       ;; number of scans
   DB	 7,015H 		       ;; Section symbol - 
CP437_NA_LO_T1_K1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_LO_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437    ???????????????????May need change....
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP437_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options: *** CNS 12/18
   DB	 1			       ;; number of scans
   DB	 27,'$'                        ;; dollar currency symbol
CP437_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_THIRD_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; FR Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC FR_850_XLAT		       ;;
FR_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP850_NA_UP_T1_K1_END-$	  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options: ***** CNS 12/18
   DB	 1			       ;; number of scans
   DB	 53,0F5H		       ;; Section symbol - 
CP850_NA_UP_T1_K1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_UP_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT_KB+XT+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_LO_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB+XT_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP850_NA_LO_T1_K1_END-$	  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options: ***** CNS **** 12/18
   DB	 1			       ;; number of scans
   DB	 7,0F5H 		       ;; Section symbol - 
CP850_NA_LO_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_LO_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP850_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options: *** CNS 12/18
   DB	 1			       ;; number of scans
   DB	 27,0CFH		       ;; international currency symbol
CP850_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_THIRD_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    CP850_AC_LO_END-$		 ;; length of state section
;;   DB    ACUTE_LOWER			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    39,0 			 ;; error character = standalone accent
;;					 ;;
;;   DW    CP850_AC_LO_T1_END-$ 	 ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
;;   DB    1				 ;; number of scans
;;   DB    21,0ECH			 ;; y acute
;;CP850_AC_LO_T1_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;CP850_AC_LO_END:			 ;;
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; CODE PAGE: 850
;;;; STATE: Acute Upper Case
;;;; KEYBOARD TYPES: All
;;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    CP850_AC_UP_END-$		 ;; length of state section
;;   DB    ACUTE_UPPER			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    39,0 			 ;; error character = standalone accent
;;					 ;;
;;   DW    CP850_AC_UP_T1_END-$ 	 ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
;;   DB    5				 ;; number of scans
;;   DB    30,0B5H			 ;;    A acute
;;   DB    23,0D6H			 ;;    I acute
;;   DB    24,0E0H			 ;;    O acute
;;   DB    22,0E9H			 ;;    U acute
;;   DB    21,0EDH			 ;;    Y acute
;;CP850_AC_UP_T1_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;CP850_AC_UP_END:			 ;;
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; CODE PAGE: 850
;;;; STATE: Diaresis Upper
;;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
     DW    CP850_DI_UP_END-$		 ;; length of state section
     DB    DIARESIS_UPPER		 ;; State ID
     DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
     DB    249,0			 ;; error character = standalone accent
					 ;;
     DW    CP850_DI_UP_T1_END-$ 	 ;; Size of xlat table
     DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
     DB    2				 ;; number of scans
     DB    18,0D3H			 ;;    E diaeresis
     DB    23,0D8H			 ;;    I diaeresis
  CP850_DI_UP_T1_END:			 ;;
					 ;;
     DW    0				 ;; Size of xlat table - null table
					 ;;
  CP850_DI_UP_END:			 ;; length of state section
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: 850
;; STATE: Grave Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    CP850_GR_UP_END-$		 ;; length of state section
;;   DB    GRAVE_UPPER			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    96,0 			 ;; error character = standalone accent
;;					 ;;
;;   DW    CP850_GR_UP_T1_END-$ 	 ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
;;   DB    5				 ;; number of scans
;;   DB    30,0B7H			 ;;    A grave
;;   DB    18,0D4H			 ;;    E grave
;;   DB    23,0DEH			 ;;    I grave
;;   DB    24,0E3H			 ;;    O grave
;;   DB    22,0EBH			 ;;    U grave
;;CP850_GR_UP_T1_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;CP850_GR_UP_END:			 ;; length of state section
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; CODE PAGE: 850
;;;; STATE: Circumflex Upper
;;;; KEYBOARD TYPES: All
;;;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
     DW    CP850_CI_UP_END-$		 ;; length of state section
     DB    CIRCUMFLEX_UPPER		 ;; State ID
     DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
     DB    94,0 			 ;; error character = standalone accent
					 ;;
     DW    CP850_CI_UP_T1_END-$ 	 ;; Size of xlat table
     DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
     DB    5				 ;; number of scans
     DB    16,0B6H			 ;;    A circumflex
     DB    18,0D2H			 ;;    E circumflex
     DB    23,0D7H			 ;;    I circumflex
     DB    24,0E2H			 ;;    O circumflex
     DB    22,0EAH			 ;;    U circumflex
  CP850_CI_UP_T1_END:			 ;;
					 ;;
     DW    0				 ;; Size of xlat table - null table
					 ;;
  CP850_CI_UP_END:			 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
     DW    0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kdfcf.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */



	PAGE	,132
	TITLE	MS-DOS 5.0 KEYBOARD.SYS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - KEYBOARD.SYS
;;
;; This file contains the keyboard table for Canadian French
;;
;; Linkage Instructions:
;;    Refer to KDF.ASM
;;
;; Author:     T.T. CHEN  & BILL DEVLIN- IBM Canada Laboratory - July 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC CF_LOGIC 	       ;;
	PUBLIC CF_863_XLAT	       ;;
	PUBLIC CF_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; CF State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CF_LOGIC:			       ;;
				       ;;
   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  JR_HOT_KEY_1_2		     ;; special features
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
      IFF CIRCUMFLEX		       ;;
	  RESET_NLS		       ;;
	  XLATT CIRCUMFLEX_CIRCUMFLEX  ;;
	  GOTO CIRCUMFLEX_ON	       ;;
      ENDIFF			       ;;
      IFF GRAVE 		       ;;
	  RESET_NLS		       ;;
	  XLATT GRAVE_GRAVE	       ;;
	  GOTO GRAVE_ON 	       ;;
      ENDIFF			       ;;
      IFF EITHER_SHIFT		       ;;
	  IFF DIARESIS		       ;;
	      RESET_NLS 	       ;;
	      XLATT DIARESIS_DIARESIS  ;;
	      GOTO DIARESIS_ON	       ;;
	  ENDIFF		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  IFF CEDILLA		       ;;
	      RESET_NLS 	       ;;
	      XLATT CEDILLA_CEDILLA    ;;
	      GOTO CEDILLA_ON	       ;;
	  ENDIFF		       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF  R_ALT_SHIFT,NOT	       ;;
      ANDF ALT_SHIFT		       ;;
	 IFF  EITHER_SHIFT	       ;; Third shift is activated by ALT_GR
				       ;; OR ALT + SHIFT.
	     IFF ACUTE		       ;;
		RESET_NLS	       ;;
		XLATT ACUTE_ACUTE      ;;
		GOTO ACUTE_ON	       ;;
	     ENDIFF		       ;;
	     SET_FLAG DEAD_THIRD       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF R_ALT_SHIFT	       ;;
;;;**************************************
;;;	       BIOS sets ALT_SHIFT when R_ALT_SHIFT is pressed.
;;;	       We must suppress this to detect both ALT keys simultaneously.
;;;	     ANDF ALT_SHIFT,NOT        ;;
;;;**************************************
	 ANDF EITHER_SHIFT,NOT	       ;;
	     IFF ACUTE		       ;;
		 RESET_NLS	       ;;
		 XLATT ACUTE_ACUTE     ;;
		 GOTO ACUTE_ON	       ;;
	     ENDIFF		       ;;
	     SET_FLAG DEAD_THIRD       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
ACUTE_ON:			       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
				       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      EXIT_INT_9		       ;; Either is invalid so BEEP.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
GRAVE_ON:			       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_UPPER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_LOWER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
				       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      EXIT_INT_9		       ;; Either is invalid so BEEP.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
DIARESIS_ON:			       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
				       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      EXIT_INT_9		       ;; Either is invalid so BEEP.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO CEDILLA_PROC 	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
CIRCUMFLEX_ON:			       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
				       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      EXIT_INT_9		       ;; Either is invalid so BEEP.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CEDILLA ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CEDILLA_PROC:			       ;;
				       ;;
   IFF CEDILLA,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
CEDILLA_ON:			       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CEDILLA_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CEDILLA_LOWER      ;;
	   ELSEF		       ;;
	      XLATT CEDILLA_UPPER      ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CEDILLA_UPPER      ;;
	   ELSEF		       ;;
	      XLATT CEDILLA_LOWER      ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CEDILLA:		       ;;
				       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      EXIT_INT_9		       ;; Either is invalid so BEEP.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
NON_DEAD:			       ;;
   IFKBD G_KB+P12_KB		       ;;
   ANDF LC_E0			       ;;
      EXIT_STATE_LOGIC		       ;;
   ENDIFF			       ;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT		       ;; keys are affected by CAPS LOCK.
      GOTO NO_THIRD		       ;;
      ENDIFF			       ;;
				       ;;
      IFF  R_ALT_SHIFT,NOT	       ;; Third shift is activated by ALT_GR
      ANDF ALT_SHIFT		       ;; OR ALT + SHIFT.
	 IFF EITHER_SHIFT	       ;;
	     XLATT THIRD_SHIFT	       ;;
	     IFF SCAN_MATCH,NOT        ;;
		EXIT_INT_9	       ;;
	     ENDIFF		       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF R_ALT_SHIFT	       ;;
;;;**************************************
;;;	      BIOS sets ALT_SHIFT when R_ALT_SHIFT is pressed.
;;;	      We must suppress this to detect both ALT keys simultaneously.
;;;	 ANDF ALT_SHIFT,NOT	       ;;
;;;**************************************
	 ANDF EITHER_SHIFT,NOT	       ;;
	     XLATT THIRD_SHIFT	       ;;
	     IFF SCAN_MATCH,NOT        ;;
		EXIT_INT_9	       ;;
	     ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
      EXIT_STATE_LOGIC		       ;;
				       ;;
				       ;;
NO_THIRD:			       ;; Lower and upper case.  Alphabetic
				       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  ENDIFF		       ;;
      ENDIFF			       ;;
				       ;;
      EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; CF Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC CF_COMMON_XLAT		       ;;
CF_COMMON_XLAT: 		       ;;
				       ;;
   DW	   COMMON_XLAT_END-$	       ;; length of Common Tranlate Section
   DW	   -1			       ;; code page
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD: All
;; TABLE TYPE: Set Dead Key Flag
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 COM_DE_LO_END-$	       ;;
				       ;;  label format:
				       ;;    codepage_state_n_END
				       ;;	codepage = COMmon
				       ;;		   codepage1,
				       ;;		   codepage2.
				       ;;	state refers to
				       ;;	alpha, case, and dead:
				       ;;	 DE_LO:  DEAD_LOWER
				       ;;	 DE_UP:  DEAD_UPPER
				       ;;	 DE_TH:  DEAD_THIRD
				       ;;	 AL_LO:  ALPHA_LOWER
				       ;;	 AL_UP:  ALPHA_UPPER
				       ;;	 NA_LO:  NON_ALPHA_LOWER
				       ;;	 NA_UP:  NON_ALPHA_UPPER
				       ;;	 NA_TH:  THIRD_SHIFT
				       ;;	 AC_LO:  ACUTE_LOWER
				       ;;	 AC_UP:  ACUTE_UPPER
				       ;;	 AC_SP:  ACUTE_SPACE
				       ;;	 AC_AC:  ACUTE_ACUTE
				       ;;	 GR_LO:  GRAVE_LOWER
				       ;;	 GR_UP:  GRAVE_UPPER
				       ;;	 GR_SP:  GRAVE_SPACE
				       ;;	 GR_GR:  GRAVE_GRAVE
				       ;;	 DI_LO:  DIARESIS_LOWER
				       ;;	 DI_UP:  DIARESIS_UPPER
				       ;;	 DI_SP:  DIARESIS_SPACE
				       ;;	 DI_DI:  DIARESIS_DIARESIS
				       ;;	 CI_LO:  CIRCUMFLEX_LOWER
				       ;;	 CI_UP:  CIRCUMFLEX_UPPER
				       ;;	 CI_SP:  CIRCUMFLEX_SPACE
				       ;;	 CI_CI:  CIRCUMFLEX_CIRCUMFLEX
				       ;;	 CE_LO:  CEDILLA_LOWER
				       ;;	 CE_UP:  CEDILLA_UPPER
				       ;;	 CE_SP:  CEDILLA_SPACE
				       ;;	 CE_CE:  CEDILLA_CEDILLA
				       ;;
				       ;;	 n = 1,2,... to distinguish
				       ;;	     for different KB
   DB	 DEAD_LOWER		       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 3			       ;; number of dead keys
   DB	 40			       ;; scan code
   FLAG  GRAVE			       ;; flag bit assignment
   DB	 26			       ;;
   FLAG  CIRCUMFLEX		       ;;
   DB	 27			       ;;
   FLAG  CEDILLA		       ;;
COM_DE_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD: ALL
;; TABLE TYPE: Set Dead Key Flag
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 COM_DE_UP_END-$	       ;;
   DB	 DEAD_UPPER		       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 3			       ;; number of dead keys
   DB	 40			       ;; scan code
   FLAG  GRAVE			       ;; flag bit assignment
   DB	 26			       ;;
   FLAG  CIRCUMFLEX		       ;;
   DB	 27			       ;;
   FLAG  DIARESIS		       ;;
COM_DE_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift Dead Key
;; KEYBOARD: All
;; TABLE TYPE: Set Dead Key Flag
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 COM_DE_TH_END-$	       ;;
   DB	 DEAD_THIRD		       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of dead keys
   DB	 53			       ;; scan code
   FLAG  ACUTE			       ;; flag bit assignment
COM_DE_TH_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_LO_END-$	       ;; Length of state section
   DB	 ALPHA_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_000400-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 53,''                        ;;
CF_000400:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_UP_END-$	       ;;
   DB	 ALPHA_UPPER		       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_002400-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 53,''                        ;;
CF_002400:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_UP_END:			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-alpha lower Case
;; KEYBOARD: G_KB, P_KB, P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_1_END-$	       ;; Length of state section
   DB	 NON_ALPHA_LOWER	       ;;
   DW	 G_KB+P_KB+P12_KB	       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_004300-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 41,'#'                        ;;
   DB	 43,'<'                        ;;
   DB	 86,''                        ;;
CF_004300:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-alpha lower Case
;; KEYBOARD: XT_KB, AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_2_END-$	       ;; Length of state section
   DB	 NON_ALPHA_LOWER	       ;;
   DW	 XT_KB+AT_KB		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_004400-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 2			       ;; number of scans
   DB	 41,'<'                        ;;
   DB	 43,'\'                        ;;
CF_004400:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table : null
				       ;;
COM_NA_LO_2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-alpha lower Case
;; KEYBOARD: JR_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_3_END-$	       ;; Length of state section
   DB	 NON_ALPHA_LOWER	       ;;
   DW	 JR_KB			       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_004401-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 51,','                        ;;
CF_004401:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table : null
				       ;;
COM_NA_LO_3_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-alpha Upper Case
;; KEYBOARD: G_KB, P_KB, P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_1_END-$	       ;; Length of state section
   DB	 NON_ALPHA_UPPER	       ;;
   DW	 G_KB+P_KB+P12_KB	       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_005300-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 8			       ;; number of scans
   DB	 3,'"'                         ;;
   DB	 4,'/'                         ;;
   DB	 7,'?'                         ;;
   DB	 41,'|'                        ;;
   DB	 43,'>'                        ;;
   DB	 51,27H 		       ;;    single quote
   DB	 52,'.'                        ;;
   DB	 86,''                        ;;
CF_005300:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_1_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-alpha Upper Case
;; KEYBOARD: XT_KB+AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_2_END-$	       ;; Length of state section
   DB	 NON_ALPHA_UPPER	       ;;
   DW	 XT_KB+AT_KB		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_005400-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 7			       ;; number of scans
   DB	 3,'"'                         ;;
   DB	 4,'/'                         ;;
   DB	 7,'?'                         ;;
   DB	 41,'>'                        ;;
   DB	 43,'|'                        ;;
   DB	 51,27H 		       ;;    single quote
   DB	 52,'.'                        ;;    period
CF_005400:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table : null
				       ;;
COM_NA_UP_2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-alpha Upper Case
;; KEYBOARD: JR_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_3_END-$	       ;; Length of state section
   DB	 NON_ALPHA_UPPER	       ;;
   DW	 JR_KB			       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_005100-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;;
   DB	 3,'"'                         ;;
   DB	 4,'/'                         ;;
   DB	 7,'?'                         ;;
   DB	 51,27H 		       ;;    single quote
   DB	 52,02EH		       ;;    period
CF_005100:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table : null
				       ;;
				       ;;
COM_NA_UP_3_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-alpha Third Case
;; KEYBOARD: G_KB, P_KB, P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_TH_1_END-$	       ;; Length of state section
   DB	 THIRD_SHIFT		       ;;
   DW	 G_KB+P_KB+P12_KB	       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_007760-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 15			       ;; number of entries
   DB	 2,''                         ;;
   DB	 3,'@'                         ;;
   DB	 4,''                         ;;
   DB	 7,''                         ;;
   DB	 9,''                         ;;
   DB	 11,''                        ;;
   DB	 12,''                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 39,'~'                        ;;
   DB	 40,'{'                        ;;
   DB	 41,'\'                        ;;
   DB	 43,'}'                        ;;

; these are not supported in Enhanced keyboard (p12).
;   DB	 47,''                        ;;
;   DB	 48,''                        ;;
;   DB	 49,''                        ;;

   DB	 50,''                        ;;
   DB	 86,''                        ;;
CF_007760:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_TH_1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-alpha Third Case
;; KEYBOARD: XT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_TH_2_END-$	       ;; Length of state section
   DB	 THIRD_SHIFT		       ;;
   DW	 XT_KB			       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_006500-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 17			       ;; number of scans
   DB	 2,''                         ;;
   DB	 3,'@'                         ;;
   DB	 4,''                         ;;
   DB	 7,''                         ;;
   DB	 9,''                         ;;
   DB	 11,''                        ;;
   DB	 12,''                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 39,'~'                        ;;
   DB	 40,'{'                        ;;
   DB	 41,'}'                        ;;
   DB	 43,'#'                        ;;
   DB	 47,''                        ;;
   DB	 48,''                        ;;
   DB	 49,''                        ;;
   DB	 50,''                        ;;
CF_006500:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_TH_2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-alpha Third Case
;; KEYBOARD: AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_TH_3_END-$	       ;; Length of state section
   DB	 THIRD_SHIFT		       ;;
   DW	 AT_KB			       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_006300-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 17			       ;; number of scans
   DB	 2,''                         ;;
   DB	 3,'@'                         ;;
   DB	 4,''                         ;;
   DB	 7,''                         ;;
   DB	 9,''                         ;;
   DB	 11,''                        ;;
   DB	 12,''                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 38,'~'                        ;;
   DB	 39,'{'                        ;;
   DB	 40,'}'                        ;;
   DB	 43,'#'                        ;;
   DB	 47,''                        ;;
   DB	 48,''                        ;;
   DB	 49,''                        ;;
   DB	 50,''                        ;;
CF_006300:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_TH_3_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-alpha Third Case
;; KEYBOARD: PCJR
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CF_COM_NA_TH_4_END-$	       ;; Length of state section
   DB	 THIRD_SHIFT		       ;;
   DW	 JR_KB			       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_007100-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 21			       ;;
   DB	 2,''                         ;;
   DB	 3,'@'                         ;;
   DB	 4,''                         ;;
   DB	 7,''                         ;;
   DB	 9,''                         ;;
   DB	 11,''                        ;;
   DB	 16,''                        ;;
   DB	 17,''                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 30,'<'                        ;;
   DB	 31,'>'                        ;;
   DB	 38,'~'                        ;;
   DB	 39,'{'                        ;;
   DB	 40,'}'                        ;;
   DB	 44,'\'                        ;;
   DB	 45,'#'                        ;;
   DB	 46,'|'                        ;;
   DB	 47,''                        ;;
   DB	 48,''                        ;;
   DB	 49,''                        ;;
CF_007100:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CF_COM_NA_TH_4_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Lower Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AC_LO_END-$	       ;; Length of state section
   DB	 ACUTE_LOWER		       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_001100-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 18,''                        ;;
   DB	 24,''                        ;;
   DB	 22,''                        ;;
CF_001100:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AC_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Upper Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AC_UP_END-$	       ;; Length of state section
   DB	 ACUTE_UPPER		       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_003100-$			;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 18,''                        ;;
CF_003100:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AC_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_LO_END-$	       ;; Length of state section
   DB	 GRAVE_LOWER		       ;;
   DW	 ANY_KB 		       ;;
   DB	 '`',0                        ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_001200-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 30,''                        ;;
   DB	 18,''                        ;;
   DB	 22,''                        ;;
CF_001200:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave + Space Bar
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_SP_END-$	       ;; Length of state section
   DB	 GRAVE_SPACE		       ;;
   DW	 ANY_KB 		       ;;
   DB	 '`',0                         ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_004500-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,'`'                        ;;
CF_004500:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_SP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave + Grave
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_GR_END-$	       ;; Length of state section
   DB	 GRAVE_GRAVE		       ;;
   DW	 ANY_KB 		       ;;
   DB	 '`',0                         ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_004501-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 40,'`'                        ;;
CF_004501:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_GR_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Lower Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_LO_END-$	       ;; Length of state section
   DB	 DIARESIS_LOWER 	       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_001400-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 18,''                        ;;
   DB	 23,''                        ;;
   DB	 22,''                        ;;
CF_001400:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; Length of state section
   DB	 CIRCUMFLEX_LOWER	       ;;
   DW	 ANY_KB 		       ;;
   DB	 '^',0                         ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_001300-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,''                        ;;
   DB	 18,''                        ;;
   DB	 23,''                        ;;
   DB	 24,''                        ;;
   DB	 22,''                        ;;
CF_001300:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex + Space Bar
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; Length of state section
   DB	 CIRCUMFLEX_SPACE	       ;;
   DW	 ANY_KB 		       ;;
   DB	 '^',0                         ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_004555-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,'^'                        ;;
CF_004555:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex + Circumflex
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_CI_END-$	       ;; Length of state section
   DB	 CIRCUMFLEX_CIRCUMFLEX	       ;;
   DW	 ANY_KB 		       ;;
   DB	 '^',0                         ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_004551-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 26,'^'                        ;;
CF_004551:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_CI_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Upper Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_UP_END-$	       ;; Length of state section
   DB	 DIARESIS_UPPER 	       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_003300-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 22,''                        ;;
CF_003300:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Cedilla Lower Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CE_LO_END-$	       ;; Length of state section
   DB	 CEDILLA_LOWER		       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_001500-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 46,''                        ;;
CF_001500:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CE_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Cedilla Upper Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CE_UP_END-$	       ;; Length of state section
   DB	 CEDILLA_UPPER		       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_003400-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 46,''                        ;;
CF_003400:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CE_UP_END:			       ;;
				       ;;
   DW	 0			       ;; Last State
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMON_XLAT_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; CF 863 Translate Section
;; This section contains translations for the UPPER 128 characters
;; of Code Page 863.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC CF_863_XLAT		       ;;
CF_863_XLAT:			       ;;
				       ;;
   DW	   CP863_XLAT_END-$	       ;; length of 863 Tranlate Section
   DW	   863			       ;; code page id
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 863
;; STATE: Non-alpha Third Case
;; KEYBOARD: G_B, P_KB, P12_KB
;;	     XT_KB, AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP863_NA_TH_1_END-$	       ;; Length of state section
   DB	 THIRD_SHIFT		       ;;
   DW	 G_KB+P_KB+P12_KB+XT_KB+AT_KB  ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_106300-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 8			       ;; number of scan
   DB	 5,''                         ;;
   DB	 6,98H			       ;;    international currency symbol
   DB	 8,0A0H 		       ;;    vertical line broken
   DB	 10,0A6H		       ;;    superscript 3
   DB	 13,0ADH		       ;;    3 quarters
   DB	 24,08FH		       ;;    section
   DB	 25,086H		       ;;    paragraph
   DB	 51,0A7H		       ;;    overscore
CF_106300:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP863_NA_TH_1_END:		       ;; Length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 863
;; STATE: Non-alpha Third Case
;; KEYBOARD: JR_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP863_NA_TH_2_END-$	       ;; Length of state section
   DB	 THIRD_SHIFT		       ;;
   DW	 JR_KB			       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_106600-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 8			       ;; number of scan
   DB	 5,''                         ;;
   DB	 6,98H			       ;;    international currency symbol
   DB	 8,0A0H 		       ;;    vertical line broken
   DB	 12,0A6H		       ;;    superscript 3
   DB	 18,0ADH		       ;;    3 quarters
   DB	 24,08FH		       ;;    section
   DB	 25,086H		       ;;    paragraph
   DB	 51,0A7H		       ;;    overscore
CF_106600:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP863_NA_TH_2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 863
;; STATE: Acute  INPUT: Space Bar
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP863_AC_SP_END-$	       ;; Length of state section
   DB	 ACUTE_SPACE		       ;;
   DW	 ANY_KB 		       ;;
   DB	 0A1H,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_104500-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,0A1H		       ;;   acute
CF_104500:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP863_AC_SP_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 863
;; STATE: Acute  INPUT: Acute
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP863_AC_AC_END-$	       ;; Length of state section
   DB	 ACUTE_ACUTE		       ;;
   DW	 ANY_KB 		       ;;
   DB	 0A1H,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_104505-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 53,0A1H		       ;;   acute
CF_104505:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP863_AC_AC_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 863
;; STATE: Grave Upper Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP863_GR_UP_END-$	       ;; Length of state section
   DB	 GRAVE_UPPER		       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_104700-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 30,8EH 		       ;;    A grave
   DB	 18,91H 		       ;;    E grave
   DB	 22,9DH 		       ;;    U grave
CF_104700:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP863_GR_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 863
;; STATE: Diaresis Upper Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP863_DI_UP_END-$	       ;; Length of state section
   DB	 DIARESIS_UPPER 	       ;;
   DW	 ANY_KB 		       ;;
   DB	 0A4H,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_104800-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 2			       ;; number of scans
   DB	 18,94H 		       ;;    E diaeresis
   DB	 23,95H 		       ;;    I diaeresis
CF_104800:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP863_DI_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 863
;; STATE: Diaresis  INPUT: Space Bar
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP863_DI_SP_END-$	       ;; Length of state section
   DB	 DIARESIS_SPACE 	       ;;
   DW	 ANY_KB 		       ;;
   DB	 0A4H,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_104550-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,0A4H		       ;;   diaeresis
CF_104550:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP863_DI_SP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 863
;; STATE: Diaresis  INPUT: Diaresis
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP863_DI_DI_END-$	       ;; Length of state section
   DB	 DIARESIS_DIARESIS	       ;;
   DW	 ANY_KB 		       ;;
   DB	 0A4H,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_104551-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 27,0A4H		       ;;   diaeresis
CF_104551:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP863_DI_DI_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 863
;; STATE: Circumflex Upper Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP863_CI_UP_END-$	       ;; Length of state section
   DB	 CIRCUMFLEX_UPPER	       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_104750-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,84H 		       ;;    A circumflex
   DB	 18,92H 		       ;;    E circumflex
   DB	 23,0A8H		       ;;    I circumflex
   DB	 24,99H 		       ;;    O circumflex
   DB	 22,9EH 		       ;;    U circumflex
CF_104750:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP863_CI_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 863
;; STATE: Cedilla  INPUT: Space Bar
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP863_CE_SP_END-$	       ;; Length of state section
   DB	 CEDILLA_SPACE		       ;;
   DW	 ANY_KB 		       ;;
   DB	 0A5H,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_104600-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,0A5H		       ;;   cedilla
CF_104600:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP863_CE_SP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 863
;; STATE: Cedilla  INPUT: Cedilla
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP863_CE_CE_END-$	       ;; Length of state section
   DB	 CEDILLA_CEDILLA	       ;;
   DW	 ANY_KB 		       ;;
   DB	 0A5H,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_104601-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 27,0A5H		       ;;   cedilla
CF_104601:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP863_CE_CE_END:		       ;;
				       ;;
				       ;;
   DW	 0			       ;; Last State
CP863_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; CF 850 Translate Section
;; This section contains translations for the UPPER 128 characters
;; of Code Page 850.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC CF_850_XLAT		       ;;
CF_850_XLAT:			       ;;
				       ;;
   DW	   CP850_XLAT_END-$	       ;; length of 850 Tranlate Section
   DW	   850			       ;; code page id
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-alpha Third Case
;; KEYBOARD: G_KB, P_KB, P12_KB
;;	     XT_KB, AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_TH_1_END-$	       ;; Length of state section
   DB	 THIRD_SHIFT		       ;;
   DW	 G_KB+P_KB+P12_KB+XT_KB+AT_KB  ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_206300-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 8			       ;; number of scan
   DB	 5,0BDH 		       ;;    cent
   DB	 6,0CFH 		       ;;    international currency symbol
   DB	 8,0DDH 		       ;;    vertical line broken
   DB	 10,0FCH		       ;;    superscript 3
   DB	 13,0F3H		       ;;    3 quarters
   DB	 24,0F5H		       ;;    section
   DB	 25,0F4H		       ;;    paragraph
   DB	 51,0EEH		       ;;    overscore
CF_206300:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_TH_1_END:		       ;; Length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-alpha Third Case
;; KEYBOARD: JR_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_TH_2_END-$	       ;; Length of state section
   DB	 THIRD_SHIFT		       ;;
   DW	 JR_KB			       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_206600-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 8			       ;; number of scan
   DB	 5,0BDH 		       ;;    cent
   DB	 6,0CFH 		       ;;    international currency symbol
   DB	 8,0DDH 		       ;;    vertical line broken
   DB	 12,0FCH		       ;;    superscript 3
   DB	 18,0F3H		       ;;    3 quarters
   DB	 24,0F5H		       ;;    section
   DB	 25,0F4H		       ;;    paragraph
   DB	 51,0EEH		       ;;    overscore
CF_206600:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_TH_2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Lower Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_LO_END-$	       ;; Length of state section
   DB	 ACUTE_LOWER		       ;;
   DW	 ANY_KB 		       ;;
   DB	 0EFH,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_201100-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 30,''                        ;;
   DB	 23,''                        ;;
   DB	 21,0ECH		       ;; y acute
CF_201100:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Upper Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_UP_END-$	       ;; Length of state section
   DB	 ACUTE_UPPER		       ;;
   DW	 ANY_KB 		       ;;
   DB	 0EFH,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_203100-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,0B5H		       ;;    A acute
   DB	 23,0D6H		       ;;    I acute
   DB	 24,0E0H		       ;;    O acute
   DB	 22,0E9H		       ;;    U acute
   DB	 21,0EDH		       ;;    Y acute
CF_203100:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute  INPUT: Space Bar
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_SP_END-$	       ;; Length of state section
   DB	 ACUTE_SPACE		       ;;
   DW	 ANY_KB 		       ;;
   DB	 0EFH,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_204500-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,0EFH		       ;;   acute
CF_204500:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_SP_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute  INPUT: Acute
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_AC_END-$	       ;; Length of state section
   DB	 ACUTE_ACUTE		       ;;
   DW	 ANY_KB 		       ;;
   DB	 0EFH,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_204501-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 53,0EFH		       ;;   acute
CF_204501:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_AC_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Lower Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_GR_LO_END-$	       ;; Length of state section
   DB	 GRAVE_LOWER		       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_201200-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 2			       ;; number of scans
   DB	 23,''                        ;;
   DB	 24,''                        ;;
CF_201200:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_GR_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Upper Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_GR_UP_END-$	       ;; Length of state section
   DB	 GRAVE_UPPER		       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_203200-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,0B7H		       ;;    A grave
   DB	 18,0D4H		       ;;    E grave
   DB	 23,0DEH		       ;;    I grave
   DB	 24,0E3H		       ;;    O grave
   DB	 22,0EBH		       ;;    U grave
CF_203200:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_GR_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_LO_END-$	       ;; Length of state section
   DB	 DIARESIS_LOWER 	       ;;
   DW	 ANY_KB 		       ;;
   DB	 0F9H,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_201400-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 30,''                        ;;
   DB	 24,''                        ;;
   DB	 21,''                        ;;
CF_201400:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Upper Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_UP_END-$	       ;; Length of state section
   DB	 DIARESIS_UPPER 	       ;;
   DW	 ANY_KB 		       ;;
   DB	 0F9H,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_203400-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 4			       ;; number of scans
   DB	 30,''                        ;;
   DB	 18,0D3H		       ;;    E diaeresis
   DB	 23,0D8H		       ;;    I diaeresis
   DB	 24,''                        ;;
CF_203400:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis  INPUT: Space Bar
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_SP_END-$	       ;; Length of state section
   DB	 DIARESIS_SPACE 	       ;;
   DW	 ANY_KB 		       ;;
   DB	 0F9H,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_204550-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,0F9H		       ;;   diaeresis
CF_204550:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_SP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis  INPUT: Diaresis
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_DI_END-$	       ;; Length of state section
   DB	 DIARESIS_DIARESIS	       ;;
   DW	 ANY_KB 		       ;;
   DB	 0F9H,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_204551-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 27,0F9H		       ;;   diaeresis
CF_204551:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_DI_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Circumflex Upper Case
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_CI_UP_END-$	       ;; Length of state section
   DB	 CIRCUMFLEX_UPPER	       ;;
   DW	 ANY_KB 		       ;;
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_003305-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,0B6H		       ;;    A circumflex
   DB	 18,0D2H		       ;;    E circumflex
   DB	 23,0D7H		       ;;    I circumflex
   DB	 24,0E2H		       ;;    O circumflex
   DB	 22,0EAH		       ;;    U circumflex
CF_003305:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_CI_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Cedilla  INPUT: Space Bar
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_CE_SP_END-$	       ;; Length of state section
   DB	 CEDILLA_SPACE		       ;;
   DW	 ANY_KB 		       ;;
   DB	 0F7H,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_204600-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,0F7H		       ;;   cedilla
CF_204600:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_CE_SP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Cedilla  INPUT: Cedilla
;; KEYBOARD: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_CE_CE_END-$	       ;; Length of state section
   DB	 CEDILLA_CEDILLA	       ;;
   DW	 ANY_KB 		       ;;
   DB	 0F7H,0 		       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 CF_204601-$		       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 27,0F7H		       ;;   cedilla
CF_204601:			       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_CE_CE_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; no more states
				       ;;
CP850_XLAT_END: 		       ;;

CODE   ENDS
       END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kdfbr.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;; XT section enabled
;; ************* CNS 12/18/86


	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Brazil
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;	       Adapted for Brazil by Mihindu Senanayake (Microsoft) - Oct 1990
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC BR_LOGIC 	       ;;
	PUBLIC BR_437_XLAT	       ;;
	PUBLIC BR_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a linear search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BR State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
BR_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  0			       ;; special features
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
      IFF EITHER_SHIFT		       ;;
	  IFF CIRCUMFLEX		   ;;
	      RESET_NLS 		   ;;
	      XLATT CIRCUMFLEX_CIRCUMFLEX  ;;
	      SET_FLAG DEAD_UPPER	   ;;
	      GOTO CIRCUMFLEX_ON	   ;;
	  ENDIFF			   ;;
	  IFF TILDE		    ;;
	      RESET_NLS 	       ;;
	      XLATT TILDE_TILDE  ;;
	      SET_FLAG DEAD_UPPER	   ;;
	      GOTO TILDE_ON	    ;;
	  ENDIFF		       ;;
	  IFF DIARESIS		       ;;
	      RESET_NLS 	       ;;
	      XLATT DIARESIS_DIARESIS  ;;
	      SET_FLAG DEAD_UPPER	   ;;
	      GOTO DIARESIS_ON	       ;;
	  ENDIFF		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF
	  IFF GRAVE			   ;;
	      RESET_NLS 		   ;;
	      XLATT GRAVE_GRAVE 	   ;;
	      SET_FLAG DEAD_LOWER
	      GOTO GRAVE_ON		   ;;
	  ENDIFF			   ;;
	  IFF ACUTE		    ;;
	     RESET_NLS		    ;;
	     XLATT ACUTE_ACUTE	    ;;
	     SET_FLAG DEAD_LOWER
	     GOTO ACUTE_ON	    ;;
	  ENDIFF		    ;;
	  SET_FLAG DEAD_LOWER
      ENDIFF			       ;;
   ENDIFF			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
ACUTE_ON:			       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
DIARESIS_ON:			       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO TILDE_PROC		    ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
GRAVE_ON:			       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TILDE_PROC:			       ;;
				       ;;
   IFF TILDE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
TILDE_ON:			       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT TILDE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_UPPER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_LOWER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_TILDE:			       ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
CIRCUMFLEX_ON:			       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
NON_DEAD:			       ;;
				       ;;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  ENDIFF		       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_SHIFT,NOT	       ;;
	  IFKBD XT_KB+AT_KB	       ;;
	      IFF  EITHER_CTL	       ;;
	      ANDF ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ELSEF 		       ;;
	      IFF EITHER_CTL,NOT       ;;
	      ANDF R_ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	   ENDIFF		       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
;**************************************;;
 IFF EITHER_SHIFT,NOT		       ;;
   IFKBD XT_KB+AT_KB		       ;;
     IFF EITHER_CTL		       ;;
     ANDF ALT_SHIFT		       ;;
       XLATT ALT_CASE		       ;;
     ENDIFF			       ;;
   ENDIFF			       ;;
   IFKBD G_KB+P12_KB		       ;;
     IFF EITHER_CTL		       ;;
     ANDF ALT_SHIFT		       ;;
       IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ALT_CASE 	       ;;
       ENDIFF			       ;;
     ENDIFF			       ;;
   ENDIFF			       ;;
 ENDIFF 			       ;;
;**************************************;;
 IFKBD AT_KB+XT_KB		 ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF ALT_SHIFT		       ;; ALT - case
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
 IFKBD G_KB+P12_KB		       ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF ALT_SHIFT		       ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL		       ;;
      ANDF ALT_SHIFT		       ;;
      ANDF R_ALT_SHIFT,NOT	       ;;
	   XLATT ALT_CASE	       ;;
      ENDIFF			       ;;
 ENDIFF 			       ;;
				       ;;
 EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BR Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC BR_COMMON_XLAT		       ;;
BR_COMMON_XLAT: 		       ;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_LO_K1_END-$		  ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 40			       ;; scan code
   FLAG  ACUTE			       ;; flag bit to set
   DB	 41			       ;;
   FLAG  GRAVE			       ;;
				       ;;
				       ;;
COM_DK_LO_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: Any,
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_UP_K1_END-$		  ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 3			       ;; number of entries
   DB	 7			       ;; scan code
   FLAG  CIRCUMFLEX		       ;; flag bit to set
   DB	 40			       ;;
   FLAG  DIARESIS		       ;;
   DB	 41			       ;;
   FLAG  TILDE			       ;;
				       ;;
COM_DK_UP_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES: Any,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_LO_END-$	       ;; length of state section
   DB	 GRAVE_LOWER		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
				       ;;
COM_GR_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: Any,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_SP_END-$	       ;; length of state section
   DB	 GRAVE_SPACE		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,96			       ;; STANDALONE GRAVE
				       ;;
COM_GR_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Twice
;; KEYBOARD TYPES: Any,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_GR_END-$	       ;; length of state section
   DB	 GRAVE_GRAVE		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_GR_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 41,96			       ;; STANDALONE GRAVE
				       ;;
COM_GR_GR_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_GR_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: Any,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 22,'' 		       ;; scan code,ASCII - u
   DB	 23,'' 		       ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
				       ;;
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: Any,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,94			       ;; STANDALONE CIRCUMFLEX
				       ;;
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Twice
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_CI_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_CIRCUMFLEX		    ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_CI_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 7,94			       ;; STANDALONE CIRCUMFLEX
				       ;;
COM_CI_CI_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_CI_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Lower
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
   DW	 COM_TI_LO_K1_END-$		  ;; length of state section
   DB	 TILDE_LOWER		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 07EH,0 		       ;; error character = standalone accent
				       ;;
   DW	 COM_TI_LO_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 49,0A4H		       ;; scan code,ASCII - 
				       ;;
COM_TI_LO_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_TI_LO_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Upper Case
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_TI_UP_K1_END-$		  ;; length of state section
   DB	 TILDE_UPPER		      ;; State ID
   DW	 ANY_KB 	     ;; Keyboard Type
   DB	 07EH,0 			;; error character = standalone accent
				       ;;
   DW	 COM_TI_UP_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 49,0A5H		       ;; scan code,ASCII - 
				       ;;
COM_TI_UP_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_TI_UP_K1_END:			  ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Space Bar
;; KEYBOARD TYPES: Any,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_TI_SP_END-$	       ;; length of state section
   DB	 TILDE_SPACE		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 07EH,0 			 ;; error character = standalone accent
				       ;;
   DW	 COM_TI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,07EH		      ;; STANDALONE TILDE
				       ;;
COM_TI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_TI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Twice
;; KEYBOARD TYPES: Any,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_TI_TI_END-$	       ;; length of state section
   DB	 TILDE_TILDE		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 07EH,0 			 ;; error character = standalone accent
				       ;;
   DW	 COM_TI_TI_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 41,07EH		       ;; STANDALONE TILDE
				       ;;
COM_TI_TI_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_TI_TI_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: Any,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AC_LO_END-$	       ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_AC_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			      ;; number of scans
   DB	 18,'' 		       ;; scan code,ASCII - e
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 30,''                        ;; scan code,ASCII - a
   DB	 46,'' 		       ;; scan code,ASCII - c-cedilla
				       ;;
COM_AC_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AC_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AC_UP_END-$	     ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_AC_UP_T1_END-$	     ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 2			       ;; number of scans
   DB	 18,090H		       ;; scan code,ASCII - E
   DB	 46,080H		       ;; C cedilla
				       ;;
COM_AC_UP_T1_END:		     ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AC_UP_END:			     ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AC_SP_END-$	       ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_AC_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			      ;; number of scans
   DB	 57,39			       ;; scan code,ASCII - SPACE
				       ;;
COM_AC_SP_T1_END:		     ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AC_SP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Twice
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AC_AC_END-$	       ;; length of state section
   DB	 ACUTE_ACUTE		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_AC_AC_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 40,39			       ;; scan code,ASCII - ACUTE
				       ;;
COM_AC_AC_T1_END:		     ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AC_AC_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Lower
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_LO_END-$	     ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 '"',0			 ;; error character = standalone accent
				       ;;
   DW	 COM_DI_LO_T1_END-$	     ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,089H		       ;;    e diaeresis
   DB	 21,098H		       ;;    y diaeresis
   DB	 22,081H		       ;;    u diaeresis
   DB	 23,08BH		       ;;    i diaeresis
   DB	 24,094H		       ;;    o diaeresis
   DB	 30,084H		       ;;    a diaeresis
				       ;;
COM_DI_LO_T1_END:		     ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_LO_END:			     ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Upper
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_UP_END-$	     ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 -1,-1			       ;; error character = standalone accent
				       ;;
   DW	 COM_DI_UP_T1_END-$	     ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 22,09AH		       ;;    U diaeresis
   DB	 24,099H		       ;;    O diaeresis
   DB	 30,08EH		       ;;    A diaeresis
				       ;;
COM_DI_UP_T1_END:		     ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_UP_END:			     ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_SP_END-$	       ;; length of state section
   DB	 DIARESIS_SPACE 		  ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 '"',0				;; error character = standalone accent
				       ;;
   DW	 COM_DI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,'"' 			;; scan code,ASCII - SPACE
				       ;;
COM_DI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_SP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Twice
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_DI_END-$	       ;; length of state section
   DB	 DIARESIS_DIARESIS		     ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 '"',0				;; error character = standalone accent
				       ;;
   DW	 COM_DI_DI_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 40,'"' 			;; scan code,ASCII - SPACE
				       ;;
COM_DI_DI_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_DI_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; BR Specific Translate Section for 437
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC BR_437_XLAT		       ;;
BR_437_XLAT:			       ;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BR Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC BR_850_XLAT		       ;;
BR_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Alt Case
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_ALT_K1_END-$		  ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 -1,-1			       ;; error character = standalone accent
				       ;;
   DW	 CP850_ALT_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 40,0EFH		       ;; scan code, acute
				       ;;
CP850_ALT_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_ALT_K1_END:			  ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Third Shift
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_THIRD_K1_END-$		    ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 CP850_THIRD_K1_T1_END-$	    ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 40,0F9H		       ;; scan code, diaresis
				       ;;
CP850_THIRD_K1_T1_END:			    ;;
				       ;;
   DW	 0			       ;; Last xlat table
CP850_THIRD_K1_END:			    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_LO_END-$	       ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 21,0ECH		       ;; y acute
				       ;;
CP850_AC_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_UP_END-$	       ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 21,0EDH		       ;;    Y acute
   DB	 22,0E9H		       ;;    U acute
   DB	 23,0D6H		       ;;    I acute
   DB	 24,0E0H		       ;;    O acute
   DB	 30,0B5H		       ;;    A acute
				       ;;
CP850_AC_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_LO_END-$	       ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 '"',0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 0			       ;; number of scans
				       ;;
CP850_DI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_LO_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Upper
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_DI_UP_END-$	       ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 '"',0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_DI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 2			       ;; number of scans
   DB	 18,0D3H		       ;;    E diaeresis
   DB	 23,0D8H		       ;;    I diaeresis
				       ;;
CP850_DI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_DI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Upper
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_GR_UP_END-$	       ;; length of state section
   DB	 GRAVE_UPPER		       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_GR_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,0B7H		       ;;    A grave
   DB	 18,0D4H		       ;;    E grave
   DB	 23,0DEH		       ;;    I grave
   DB	 24,0E3H		       ;;    O grave
   DB	 22,0EBH		       ;;    U grave
CP850_GR_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_GR_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Tilde Lower
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_LO_END-$		  ;; length of state section
    DB	  TILDE_LOWER			;; State ID
    DW	  ANY_KB	     ;; Keyboard Type
    DB	  07EH,0			;; error character = standalone accent
					;;
    DW	  CP850_TI_LO_T1_END-$		  ;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  30,0C6H			;; scan code,ASCII - a tilde
    DB	  24,0E4H			;; scan code,ASCII - o tilde
					;;
 CP850_TI_LO_T1_END:			  ;;
					;;
    DW	  0				;;
					;;
 CP850_TI_LO_END:			  ;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Tilde Upper Case
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW	  CP850_TI_UP_END-$		  ;; length of state section
    DB	  TILDE_UPPER		       ;; State ID
    DW	  ANY_KB	    ;; Keyboard Type
    DB	  07eH,0		       ;; error character = standalone accent
					;;
    DW	  CP850_TI_UP_T1_END-$		  ;; Size of xlat table
    DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
    DB	  2				;; number of scans
    DB	  30,0C7H			;; scan code,ASCII - A tilde
    DB	  24,0E5H			;; scan code,ASCII - O tilde
					;;
 CP850_TI_UP_T1_END:			  ;;
					;;
    DW	  0				;; Size of xlat table - null table
					;;
 CP850_TI_UP_END:			  ;; length of state section
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: Any
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_CI_UP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_UPPER	       ;; State ID
   DW	 ANY_KB 	    ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 CP850_CI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,0B6H		       ;;    A circumflex
   DB	 18,0D2H		       ;;    E circumflex
   DB	 23,0D7H		       ;;    I circumflex
   DB	 24,0E2H		       ;;    O circumflex
   DB	 22,0EAH		       ;;    U circumflex
				       ;;
CP850_CI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_CI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kdfcz.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
       PAGE    ,132
        TITLE   MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Definition File
;;
;;
;; This file contains the keyboard tables for:
;; Czechoslovakia (Czech)
;; Alterations created by Gyorgy Balint on behalf of IBM ROECE
;; 21.10.87 Basingstoke
;;
;;
;; Linkage Instructions:
;;      Refer to KDF.ASM.
;;
;;
;; WRITTEN:    Michael J. Saunders 2.OCTOBER 1987
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        INCLUDE KEYBSHAR.INC           ;;
        INCLUDE POSTEQU.INC            ;;
        INCLUDE KEYBMAC.INC            ;;
                                       ;;
        PUBLIC CZ_LOGIC                ;;
        PUBLIC CZ_850_XLAT             ;;
        PUBLIC CZ_852_XLAT             ;;
                                       ;;
CODE    SEGMENT PUBLIC 'CODE'          ;;
        ASSUME CS:CODE,DS:CODE         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a linear search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
STANDARD_TABLE      EQU   TYPE_2_TAB+ASCII_ONLY
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; CZ State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
                                       ;;
CZ_LOGIC:                              ;;
                                       ;;
   DW  LOGIC_END-$                     ;; length
                                       ;;
   DW  0                               ;; special features
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   OPTION EXIT_IF_FOUND                ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;  ***BD - THIS SECTION HAS BEEN UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKBD G_KB                             ;;P12_KB - ONLY VALID FOR ENHANCED KB
                                       ;;
 IFF EITHER_CTL,NOT                    ;;
    IFF EITHER_ALT,NOT                 ;;
      IFF EITHER_SHIFT                 ;;
          SET_FLAG DEAD_UPPER          ;;
      ELSEF                            ;;
          SET_FLAG DEAD_LOWER          ;;
      ENDIFF                           ;;
    ELSEF                              ;;
      IFF R_ALT_SHIFT                  ;;
      ANDF EITHER_SHIFT,NOT            ;;
         SET_FLAG DEAD_THIRD           ;;
      ENDIFF                           ;;
    ENDIFF                             ;;
 ENDIFF                                ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
ACUTE_PROC:                            ;;
                                       ;;
   IFF ACUTE,NOT                       ;;
      GOTO CEDILLA_PROC                ;;
      ENDIFF                           ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT ACUTE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT ACUTE_LOWER       ;;
            ELSEF                      ;;
               XLATT ACUTE_UPPER       ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT ACUTE_UPPER       ;;
            ELSEF                      ;;
               XLATT ACUTE_LOWER       ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_ACUTE:                         ;;
      PUT_ERROR_CHAR ACUTE_SPACE       ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
                                       ;; through to generate the second char.
                                       ;; Note that the dead key flag will be
                                       ;; reset before we get here.
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CEDILLA ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CEDILLA_PROC:                          ;;
                                       ;;
   IFF CEDILLA,NOT                     ;;
      GOTO DIARESIS_PROC               ;;
      ENDIFF                           ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT CEDILLA_SPACE           ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT CEDILLA_LOWER     ;;
            ELSEF                      ;;
               XLATT CEDILLA_UPPER     ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT CEDILLA_UPPER     ;;
            ELSEF                      ;;
               XLATT CEDILLA_LOWER     ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_CEDILLA:                       ;;
      PUT_ERROR_CHAR CEDILLA_LOWER     ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
                                       ;; through to generate the second char.
                                       ;; Note that the dead key flag will be
                                       ;; reset before we get here.
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
DIARESIS_PROC:                         ;;
                                       ;;
   IFF DIARESIS,NOT                    ;;
      GOTO GRAVE_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT DIARESIS_SPACE          ;;  exist for 850 so beep for
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT DIARESIS_LOWER    ;;
            ELSEF                      ;;
               XLATT DIARESIS_UPPER    ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT DIARESIS_UPPER    ;;
            ELSEF                      ;;
               XLATT DIARESIS_LOWER    ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_DIARESIS:                      ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
GRAVE_PROC:                            ;;
                                       ;;
   IFF GRAVE,NOT                       ;;
      GOTO TILDE_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT GRAVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT GRAVE_LOWER        ;;
           ELSEF                       ;;
              XLATT GRAVE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT GRAVE_LOWER        ;;
           ELSEF                       ;;
              XLATT GRAVE_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_GRAVE:                         ;;
      PUT_ERROR_CHAR GRAVE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TILDE_PROC:                            ;;
                                       ;;
   IFF TILDE,NOT                       ;;
      GOTO CIRCUMFLEX_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT TILDE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT TILDE_LOWER        ;;
           ELSEF                       ;;
              XLATT TILDE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE              ;;
              XLATT TILDE_UPPER        ;;
           ELSEF                       ;;
              XLATT TILDE_LOWER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
INVALID_TILDE:                         ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CIRCUMFLEX_PROC:                       ;;
                                       ;;
   IFF CIRCUMFLEX,NOT                  ;;
      GOTO CARON_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT CIRCUMFLEX_LOWER   ;;
           ELSEF                       ;;
              XLATT CIRCUMFLEX_UPPER   ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT CIRCUMFLEX_LOWER   ;;
           ELSEF                       ;;
              XLATT CIRCUMFLEX_UPPER   ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_CIRCUMFLEX:                    ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CARON ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CARON_PROC:                            ;;
                                       ;;
   IFF CARON,NOT                       ;;
      GOTO BREVE_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT CARON_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT CARON_LOWER        ;;
           ELSEF                       ;;
              XLATT CARON_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT CARON_LOWER        ;;
           ELSEF                       ;;
              XLATT CARON_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_CARON:                         ;;
      PUT_ERROR_CHAR CARON_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BREVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
BREVE_PROC:                            ;;
                                       ;;
   IFF BREVE,NOT                       ;;
      GOTO OVERCIRCLE_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT BREVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT BREVE_LOWER        ;;
           ELSEF                       ;;
              XLATT BREVE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT BREVE_LOWER        ;;
           ELSEF                       ;;
              XLATT BREVE_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_BREVE:                         ;;
      PUT_ERROR_CHAR BREVE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OVERCIRCLE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
OVERCIRCLE_PROC:                            ;;
                                       ;;
   IFF OVERCIRCLE,NOT                       ;;
      GOTO OGONEK_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT OVERCIRCLE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT OVERCIRCLE_LOWER        ;;
           ELSEF                       ;;
              XLATT OVERCIRCLE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT OVERCIRCLE_LOWER        ;;
           ELSEF                       ;;
              XLATT OVERCIRCLE_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_OVERCIRCLE:                         ;;
      PUT_ERROR_CHAR OVERCIRCLE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OGONEK ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
OGONEK_PROC:                            ;;
                                       ;;
   IFF OGONEK,NOT                       ;;
      GOTO OVERDOT_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT OGONEK_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT OGONEK_LOWER        ;;
           ELSEF                       ;;
              XLATT OGONEK_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT OGONEK_LOWER        ;;
           ELSEF                       ;;
              XLATT OGONEK_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_OGONEK:                         ;;
      PUT_ERROR_CHAR OGONEK_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OVERDOT ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
OVERDOT_PROC:                            ;;
                                       ;;
   IFF OVERDOT,NOT                       ;;
      GOTO DOUBLEACUTE_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT OVERDOT_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT OVERDOT_LOWER        ;;
           ELSEF                       ;;
              XLATT OVERDOT_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT OVERDOT_LOWER        ;;
           ELSEF                       ;;
              XLATT OVERDOT_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_OVERDOT:                         ;;
      PUT_ERROR_CHAR OVERDOT_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DOUBLEACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
DOUBLEACUTE_PROC:                            ;;
                                       ;;
   IFF DOUBLEACUTE,NOT                       ;;
      GOTO NON_DEAD                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT DOUBLEACUTE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT DOUBLEACUTE_LOWER        ;;
           ELSEF                       ;;
              XLATT DOUBLEACUTE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT DOUBLEACUTE_LOWER        ;;
           ELSEF                       ;;
              XLATT DOUBLEACUTE_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_DOUBLEACUTE:                         ;;
      PUT_ERROR_CHAR DOUBLEACUTE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;; ***BD - NON_DEAD THRU LOGIC_END IS UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NON_DEAD:                              ;;
                                       ;;
   IFKBD G_KB                          ;; Avoid accidentally translating
   ANDF LC_E0                          ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC                 ;;   G keyboard
   ENDIFF                              ;;
                                       ;;
 IFF  EITHER_CTL,NOT                   ;; Lower and upper case.  Alphabetic
    IFF EITHER_ALT,NOT                 ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT                 ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
          IFF NUM_STATE,NOT            ;;
              XLATT NUMERIC_PAD        ;;
          ENDIFF                       ;;
;;***BD END OF ADDITION
          XLATT NON_ALPHA_UPPER        ;;
          IFF CAPS_STATE               ;;
              XLATT ALPHA_LOWER        ;;
          ELSEF                        ;;
              XLATT ALPHA_UPPER        ;;
          ENDIFF                       ;;
      ELSEF                            ;;
;;***BD ADDED FOR NUMERIC PAD
          IFF NUM_STATE                ;;
              XLATT NUMERIC_PAD        ;;
          ENDIFF                       ;;
;;***BD END OF ADDITION
          XLATT NON_ALPHA_LOWER        ;;
          IFF CAPS_STATE               ;;
             XLATT ALPHA_UPPER         ;;
          ELSEF                        ;;
             XLATT ALPHA_LOWER         ;;
          ENDIFF                       ;;
      ENDIFF                           ;; Third and Fourth shifts
    ELSEF                              ;; ctl off, alt on at this point
         IFF R_ALT_SHIFT               ;; ALTGr
         ANDF EITHER_SHIFT,NOT         ;;
            XLATT THIRD_SHIFT          ;;
         ENDIFF                        ;;
    ENDIFF                             ;;
 ENDIFF                                ;;
;**************************************;;
 IFF EITHER_SHIFT,NOT                  ;;
     IFF EITHER_CTL                    ;;
     ANDF ALT_SHIFT                    ;;
       IFF R_ALT_SHIFT,NOT             ;;
         XLATT ALT_CASE                ;;
       ENDIFF                          ;;
     ENDIFF                            ;;
 ENDIFF                                ;;
;**************************************;;
      IFF EITHER_CTL,NOT               ;;
         IFF ALT_SHIFT                 ;; ALT - case
         ANDF R_ALT_SHIFT,NOT          ;;
            XLATT ALT_CASE             ;;
         ENDIFF                        ;;
      ELSEF                            ;;
         IFF EITHER_ALT,NOT            ;; CTRL - case
            XLATT CTRL_CASE            ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
ENDIFF                                 ;;
                                       ;;
 EXIT_STATE_LOGIC                      ;;
                                       ;;
LOGIC_END:                             ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;**********************************************************************
;; CZ Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; Some common Characters are included from 128 - 165 where appropriate.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC CZ_COMMON_XLAT                 ;;
CZ_COMMON_XLAT:                        ;;
                                       ;;
   DW     COMMON_XLAT_END-$            ;; length of section
   DW     -1                           ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: low shift Dead_lower
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_PL_LO_END-$               ;; length of state section
   DB    DEAD_LOWER                    ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;; Set Flag Table
   DW    1                             ;; number of entries
   DB    13                            ;;
   FLAG  ACUTE                         ;;
                                       ;;
COM_PL_LO_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: low shift Dead_UPPER
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_PL_UP_END-$               ;; length of state section
   DB    DEAD_UPPER                    ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;; Set Flag Table
   DW    2                             ;; number of entries
   DB    41                            ;;
   FLAG  OVERCIRCLE                    ;;
   DB    13                            ;;
   FLAG  CARON                         ;;
                                       ;;
COM_PL_UP_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CZ_TH_END-$               ;; length of state section
   DB    DEAD_THIRD                    ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;; Set Flag Table
   DW    11                            ;; number of entries
;; DB    2                             ;; TILDE IS NOT AN ACCENT KEY
;; FLAG  TILDE                         ;;
   DB    3                             ;;
   FLAG  CARON                         ;;
   DB    4                             ;;
   FLAG  CIRCUMFLEX                    ;;
   DB    5                             ;;
   FLAG  BREVE                         ;;
   DB    6                             ;;
   FLAG  OVERCIRCLE                    ;;
   DB    7                             ;;
   FLAG  OGONEK                        ;;
   DB    8                             ;;
   FLAG  GRAVE                         ;;
   DB    9                             ;;
   FLAG  OVERDOT                       ;;
   DB    10                            ;;
   FLAG  ACUTE                         ;;
   DB    11                            ;;
   FLAG  DOUBLEACUTE                   ;;
   DB    12                            ;;
   FLAG  DIARESIS                      ;;
   DB    13                            ;;
   FLAG  CEDILLA                       ;;
                                       ;;
COM_CZ_TH_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR NUMERIC PAD (DECIMAL SEPERATOR)
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Numeric Key Pad
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_PAD_K1_END-$              ;; length of state section
   DB    NUMERIC_PAD                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_PAD_K1_T1_END-$           ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    83,','                        ;; decimal seperator = ,
COM_PAD_K1_T1_END:                     ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_PAD_K1_END:                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Alt Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_ALT_K1_END-$              ;; length of state section
   DB    ALT_CASE                      ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_ALT_K1_T1_END-$           ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    3                             ;; number of entries
   DB    21,0,2CH                      ;;
   DB    44,0,15H                      ;;
   DB    53,0,82H                      ;;
COM_ALT_K1_T1_END:                     ;;
                                       ;;
    DW    0                            ;; Size of xlat table - null table
                                       ;;
COM_ALT_K1_END:                        ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CTRL_K2_END-$             ;; length of state section
   DB    CTRL_CASE                     ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_CTRL_K2_T1_END-$          ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    3                             ;; number of entries
   DB    21,01AH,2CH                   ;;
   DB    44,019H,15H                   ;;
   DB    53,01FH,0CH                   ;;
COM_CTRL_K2_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CTRL_K2_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AL_LO_K1_END-$            ;; length of state section
   DB    ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_AL_LO_K1_T1_END-$         ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    2                             ;; number of entries
   DB    21,"z",2CH                    ;;
   DB    44,"y",15H                    ;;
COM_AL_LO_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_AL_LO_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AL_UP_K1_END-$            ;; length of state section
   DB    ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_AL_UP_K1_T1_END-$         ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    2                             ;; number of entries
   DB    21,"Z",2CH                    ;;
   DB    44,"Y",15H                    ;;
COM_AL_UP_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_AL_UP_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_LO_K1_END-$            ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_LO_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    6                             ;; number of entries
   DB    41,";"                        ;;      changes made!!!!!  x
   DB    02h,"+"                       ;;                         x
   DB    0ch,"="                       ;;                         x
   DB    01bh,")"                      ;;                         x
   DB    056h,"&"                      ;;                         x
   DB    035h,"-"                      ;;                         x
COM_NA_LO_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_LO_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_UP_K1_END-$            ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_UP_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    20                            ;; number of entries
   DB    002h,"1"                      ;;                              x
   DB    003h,"2"                      ;;                              x
   DB    004h,"3"                      ;;                              x
   DB    005h,"4"                      ;;                              x
   DB    006h,"5"                      ;;                              x
   DB    007h,"6"                      ;;                              x
   DB    008h,"7"                      ;;                              x
   DB    009h,"8"                      ;;                              x
   DB    00ah,"9"                      ;;                              x
   DB    00bh,"0"                      ;;                              x
   DB    00ch,"%"                      ;;                              x
   DB    01ah,"/"                      ;;                              x
   DB    01bh,"("                      ;;                              x
   DB    027h,'"'                      ;;                              x
   DB    028h,"!"                      ;;                              x
   DB    02Bh,"`"                      ;;                              x
   DB    056h,"*"                      ;;                              x
   DB    033H,"?"                      ;;
   DB    034H,":"                      ;;
   DB    035h,"_"                      ;;                              x
COM_NA_UP_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_UP_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Third Shift
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_THIRD_END-$               ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    G_KB                          ;; Keyboard Type FERRARI
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_THIRD_T1_END-$            ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    14                            ;; number of entries
   DB     2,'~',02H                    ;;
   DB    16,'\',10H                    ;;
   DB    17,'|',11H                    ;;
   DB    26,'',1AH                    ;;
   DB    33,"[",021h                   ;;                             x
   DB    34,"]",022h                   ;;                             x
   DB    39,"$",027H                   ;;                             x
   db    40,0e1h,028h                  ;; sharpes s                   x
   DB    86,"<",056h                   ;;                             x
   DB    44,">",02ch                   ;;                             x
   DB    45,"#",02dh                   ;;                             x
   DB    47,"@",02fh                   ;;                             x
   DB    48,"{",30h                    ;;                             x
   DB    49,"}",031h                   ;;                             x
COM_THIRD_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Last xlat table
COM_THIRD_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Caron Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CA_SP_END-$             ;; length of state section
   DB    CARON_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_CA_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F3H                       ;; Caron Space
COM_CA_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CA_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Breve Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_BR_SP_END-$             ;; length of state section
   DB    BREVE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_BR_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F4H                       ;; BREVE SPACE
COM_BR_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_BR_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Ogonek Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_OG_SP_END-$             ;; length of state section
   DB    OGONEK_SPACE                  ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_OG_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F2H                       ;; OGONEK SPACE
COM_OG_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_OG_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Double Acute Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_DC_SP_END-$             ;; length of state section
   DB    DOUBLEACUTE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_DC_SP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    57,0F1H                       ;; DOUBLEACUTE SPACE
COM_DC_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_DC_SP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CI_LO_END-$               ;; length of state section
   DB    CIRCUMFLEX_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
                                       ;;
   DW    COM_CI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    23,''                        ;;  "    "  ,  "   - i
   DB    24,''                        ;; scan code,ASCII - o
   DB    30,''                        ;; scan code,ASCII - a
COM_CI_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;;
                                       ;;
COM_CI_LO_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CI_SP_END-$               ;; length of state section
   DB    CIRCUMFLEX_SPACE              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
                                       ;;
   DW    COM_CI_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,94                         ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CI_SP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Overcircle Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_OC_SP_END-$               ;; length of state section
   DB    OVERCIRCLE_SPACE              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_OC_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F8H                       ;; STANDALONE OVERCIRCLE
COM_OC_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_OC_SP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_GR_SP_END-$               ;; length of state section
   DB    GRAVE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    96,0                          ;; error character = standalone accent
                                       ;;
   DW    COM_GR_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,96                         ;; STANDALONE GRAVE
COM_GR_SP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_GR_SP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Overdot
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ;;
    DW    COM_OD_SP_END-$               ;; length of state section
    DB    OVERDOT_SPACE                 ;; State ID
    DW    G_KB                          ;; Keyboard Type
    DB    0FAH,0                        ;; error character = standalone accent
                                        ;;
    DW    COM_OD_SP_T1_END-$            ;; Size of xlat table
    DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
    DB    1                             ;; number of scans
    DB    57,0FAH                       ;; STANDALONE OVERDOT
COM_OD_SP_T1_END:                       ;;
                                        ;;
    DW    0                             ;;
                                        ;;
COM_OD_SP_END:                          ;;
                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AC_LO_END-$               ;; length of state section
   DB    ACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_AC_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    5                             ;; number of entries
   DB    18,082H                       ;;    e acute
   DB    22,0A3H                       ;;    u acute
   DB    23,0A1H                       ;;    i acute
   DB    24,0A2H                       ;;    o acute
   DB    30,0A0H                       ;;    a acute
COM_AC_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_AC_LO_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AC_UP_END-$               ;; length of state section
   DB    ACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_AC_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    18,090H                       ;;    E acute
COM_AC_UP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_AC_UP_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_AC_SP_END-$             ;; length of state section
   DB    ACUTE_SPACE                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    027H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_AC_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,027H                        ;; error character = standalone accent
COM_AC_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
COM_AC_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CE_LO_END-$               ;; length of state section
   DB    CEDILLA_LOWER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_CE_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    46,''                        ;; scan code,ASCII - 
COM_CE_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CE_LO_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CE_UP_END-$               ;; length of state section
   DB    CEDILLA_UPPER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_CE_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    46,''                        ;;     CEDILLA
COM_CE_UP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CE_UP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CE_SP_END-$             ;; length of state section
   DB    CEDILLA_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    COM_CE_SP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    57,0F7H                       ;; CEDILLA SPACE
COM_CE_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CE_SP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_DI_LO_END-$               ;; length of state section
   DB    DIARESIS_LOWER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
                                       ;;
   DW    COM_DI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    4                             ;; number of scans
   DB    18,''                        ;; scan code,ASCII - e
   DB    22,''                        ;; scan code,ASCII - u
   DB    24,''                        ;; scan code,ASCII - o
   DB    30,''                        ;; scan code,ASCII - a
COM_DI_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_DI_LO_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_DI_UP_END-$               ;; length of state section
   DB    DIARESIS_UPPER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
                                       ;;
   DW    COM_DI_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    22,''                        ;;    U Diaeresis
   DB    24,''                        ;;    O Diaeresis
   DB    30,''                        ;;    A Diaeresis
COM_DI_UP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_DI_UP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_DI_SP_END-$             ;; length of state section
   DB    DIARESIS_SPACE                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
                                       ;;
   DW    COM_DI_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,249                        ;; error character = standalone accent
COM_DI_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
COM_DI_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; Last State
COMMON_XLAT_END:                       ;;  END OF COMMON SECTION
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CODE PAGE 850 MULTILINGUAL 2  SPECIFIC TRANSLATION
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC CZ_850_XLAT                    ;;
CZ_850_XLAT:                           ;;
                                       ;;
    DW   CP850_XLAT_END-$              ;;
    DW   850                           ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_NA_UP_K1_END-$            ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP850_NA_UP_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    2                             ;; number of entries
   DB     5,-1                         ;; CURRENCY SYMBOL
   DB    40,015H                       ;;
CP850_NA_UP_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_NA_UP_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_AL_LO_END-$             ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; error character = standalone accent
                                       ;;
   DW    CP850_AL_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    2                             ;; number of entries
   DB    13,-1
   DB    27,-1                         ;; BLOT OUT CHAR UNDER 850
CP850_AL_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_AL_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_AL_UP_END-$             ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; error character = standalone accent
                                       ;;
   DW    CP850_AL_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    2                             ;; number of entries
   DB    13,-1                         ;; BLOT OUT CHAR UNDER 850
   DB    27,-1                         ;; BLOT OUT CHAR UNDER 850
CP850_AL_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_AL_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_CI_LO_END-$               ;; length of state section
   DB    CIRCUMFLEX_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
                                       ;;
   DW    CP850_CI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,88H                        ;;  e CIRCUMFLEX
   DB    23,8CH                        ;;  i CIRCUMFLEX
CP850_CI_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;;
                                       ;;
CP850_CI_LO_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Overcircle Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_OC_LO_END-$               ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_OC_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,86H                        ;; a OVERCIRCLE
CP850_OC_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_OC_LO_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Overcircle Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_OC_UP_END-$               ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_OC_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,8FH                        ;; A OVERCIRCLE
CP850_OC_UP_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_OC_UP_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_GR_LO_END-$               ;; length of state section
   DB    GRAVE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    060H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_GR_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    5                             ;; number of scans
   DB    18,8AH                        ;; e GRAVE
   DB    22,97H                        ;; u GRAVE
   DB    23,8DH                        ;; i GRAVE
   DB    24,95H                        ;; o GRAVE
   DB    30,85H                        ;; a GRAVE
CP850_GR_LO_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_GR_LO_END:                         ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_DI_LO_END-$             ;; length of state section
   DB    DIARESIS_LOWER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    0FEH,0                         ;; error character = standalone accent
                                       ;;
   DW    CP850_DI_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    16,8BH                        ;; i DIARESIS
CP850_DI_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
CP850_DI_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_DI_SP_END-$             ;; length of state section
   DB    DIARESIS_SPACE                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    0FEH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_DI_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0FEH,0                     ;; error character = standalone accent
CP850_DI_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
CP850_DI_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Ogonek Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_OG_SP_END-$             ;; length of state section
   DB    OGONEK_SPACE                  ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0FEH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP850_OG_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0FEH                       ;; OGONEK SPACE
CP850_OG_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP850_OG_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; LAST STATE
                                       ;;
CP850_XLAT_END:                        ;; END OF CP850 SECTION
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CODE PAGE 852 MULTILINGUAL 2  SPECIFIC TRANSLATION
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC CZ_852_XLAT                    ;;
CZ_852_XLAT:                           ;;
                                       ;;
    DW     CP852_XLAT_END-$            ;;
    DW     852                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;section commented out by gy.balint     ;;
;  DW    CP852_AL_LO_END-$           ;; length of state section
;  DB    ALPHA_LOWER                   ;; State ID
;  DW    G_KB                          ;; Keyboard Type
;  DB    -1,-1                         ;; Buffer entry for error character
;                                      ;;
;  DW    CP852_AL_LO_T1_END-$        ;; Size of xlat table
;  DB    STANDARD_TABLE                ;; xlat options:
;  DB    2                             ;; number of entries
;  DB    13,088H                       ;; l STROKE
;  DB    27,0D0H                       ;; d STROKE
;CP852_AL_LO_T1_END:                  ;;
                                       ;;
;  DW    0                             ;; Size of xlat table - null table
                                       ;;
;CP852_AL_LO_END:                     ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;section commented out by gy. balint   ;;
;  DW    CP852_AL_UP_END-$           ;; length of state section
;  DB    ALPHA_UPPER                   ;; State ID
;  DW    G_KB                          ;; Keyboard Type
;  DB    -1,-1                         ;; Buffer entry for error character
;                                      ;;
;  DW    CP852_AL_UP_T1_END-$        ;; Size of xlat table
;  DB    STANDARD_TABLE                ;; xlat options:
;  DB    2                             ;; number of entries
;  DB    13,09DH                       ;; L STROKE
;  DB    27,0D1H                       ;; D STROKE
;CP852_AL_UP_T1_END:                  ;;
                                       ;;
;  DW    0                             ;; Size of xlat table - null table
                                       ;;
;CP852_AL_UP_END:                     ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Third Shift
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_THIRD_END-$               ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    G_KB                          ;; Keyboard Type FERRARI
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP852_THIRD_T1_END-$            ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    6                             ;; number of entries
   DB    27,09eh,1bh                   ;; multiple sign               x
   DB    31,0d0h,1fh                   ;; d stroke small              x
   DB    32,0d1h,20h                   ;; D stroke capital            x
   DB    37,088h,025h                  ;; l stroke small              x
   DB    38,09dh,026h                  ;; L stroke capital
   DB    43,0cfh,02Bh                  ;; sun
CP852_THIRD_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Last xlat table
CP852_THIRD_END:                         ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE:CP 852
;; STATE: Non-alpha lower case
;; KEYBOARD TYPES: G
;;TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_NA_LO_K1_END-$          ;; length of section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard type
   DB    -1,-1                         ;; Buffer entry for error chars.
                                       ;;
   DW    CP852_NA_LO_K1_T1_END-$       ;; Size of xlat table
   DB STANDARD_TABLE                   ;; xlat options:
   DB    13                            ;; NUMBER OF ENTRIES
   DB    03h,0d8h                      ;;       e caron small     x
   DB    04h,0e7h                      ;;       s caron small     x
   DB    05h,09fh                      ;;       c caron small     x
   DB    06h,0fdh                      ;;       r caron small     x
   DB    07h,0a7h                      ;;       z caron small     x
   DB    08h,0ech                      ;;       y acute small     x
   DB    09h,0a0h                      ;;       a acute small     x
   DB    0ah,0a1h                      ;;       i acute small     x
   DB    0bh,082h                      ;;       e acute small     x
;  DB    0DH,0EFH                      ;;       ACUTE ACCENT DEAD KEY!
   DB    01ah,0a3h                     ;;       u acute small     x
   DB    027h,085h                     ;;       u overdot small   x
   DB    028h,0f5h                     ;;       section symbol    x
   DB    02Bh,0f9h                     ;;       diaresis accent   x

CP852_NA_LO_K1_T1_END:
   DW   0
CP852_NA_LO_K1_END:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP852
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                     ;;
;; DW    CP852_NA_UP_K1_END-$            ;; length of state section
;; DB    NON_ALPHA_UPPER               ;; State ID
;; DW    G_KB                          ;; Keyboard Type
;; DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
;; DW    CP852_NA_UP_K1_T1_END-$         ;; Size of xlat table
;; DB    STANDARD_TABLE                ;; xlat options:
;; DB    2                             ;; number of entries
;; DB    029h,0f8h                     ;; overcircle
;; DB    0dh,0f3h                      ;; caron
;;CP852_NA_UP_K1_T1_END:                   ;;
                                       ;;
;; DW    0                             ;; Size of xlat table - null table
                                       ;;
;;CP852_NA_UP_K1_END:                      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CA_LO_END-$             ;; length of state section
   DB    CARON_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CA_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    9                             ;; number of scans
   DB    18,0D8H                       ;; e CARON
   DB    19,0FDH                       ;; r CARON
   DB    20,09CH                       ;; t CARON
   DB    21,0A7H                       ;; z CARON
   DB    31,0E7H                       ;; s CARON
   DB    32,0D4H                       ;; d CARON
   DB    38,096H                       ;; l CARON
   DB    46,09FH                       ;; c CARON
   DB    49,0E5H                       ;; n CARON
CP852_CA_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CA_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CA_UP_END-$             ;; length of state section
   DB    CARON_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CA_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    9                             ;; number of scans
   DB    18,0B7H                       ;; E CARON
   DB    19,0FCH                       ;; R CARON
   DB    20,09BH                       ;; T CARON
   DB    21,0A6H                       ;; Z CARON
   DB    31,0E6H                       ;; S CARON
   DB    32,0D2H                       ;; D CARON
   DB    38,095H                       ;; L CARON
   DB    46,0ACH                       ;; C CARON
   DB    49,0D5H                       ;; N CARON
CP852_CA_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CA_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_CA_SP_END-$             ;; length of state section
;;   DB    CARON_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F3H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_CA_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F3H                       ;; e CARON
;;CP852_CA_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_CA_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CI_UP_END-$             ;; length of state section
   DB    CIRCUMFLEX_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    05EH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CI_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    23,0D7H                       ;; I CIRCUMFLEX
   DB    24,0E2H                       ;; O CIRCUMFLEX
   DB    30,0B6H                       ;; A CIRCUMFLEX
CP852_CI_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CI_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_BR_LO_END-$             ;; length of state section
   DB    BREVE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_BR_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,0C7H                       ;; a BREVE
CP852_BR_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_BR_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_BR_UP_END-$             ;; length of state section
   DB    BREVE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_BR_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,0C6H                       ;; A BREVE
CP852_BR_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_BR_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_BR_SP_END-$             ;; length of state section
;;   DB    BREVE_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F4H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_BR_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F4H                       ;; BREVE SPACE
;;CP852_BR_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_BR_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overcirle Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OC_LO_END-$             ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OC_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    22,085H                       ;; u OVERCIRCLE
CP852_OC_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OC_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overcircle Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OC_UP_END-$             ;; length of state section
   DB    OVERCIRCLE_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OC_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    22,0DEH                       ;; O OVERCIRCLE
CP852_OC_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OC_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OG_LO_END-$             ;; length of state section
   DB    OGONEK_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OG_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,0A9H                       ;; e OGONEK
   DB    30,0A5H                       ;; a OGONEK
CP852_OG_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OG_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OG_UP_END-$             ;; length of state section
   DB    OGONEK_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OG_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,0A8H                       ;; E OGONEK
   DB    30,0A4H                       ;; A OGONEK
CP852_OG_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OG_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_OG_SP_END-$             ;; length of state section
;;   DB    OGONEK_SPACE                  ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F2H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_OG_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F2H                       ;; OGONEK SPACE
;;CP852_OG_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_OG_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overdot Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OD_LO_END-$             ;; length of state section
   DB    OVERDOT_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0FAH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OD_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    21,0BEH                       ;; z OVERDOT
CP852_OD_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OD_LO_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overdot Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_OD_UP_END-$             ;; length of state section
   DB    OVERDOT_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0FAH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_OD_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    21,0BDH                       ;; Z OVERDOT
CP852_OD_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_OD_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AC_LO_END-$             ;; length of state section
   DB    ACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_AC_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    7                             ;; number of entries
   DB    19,0EAH                       ;; r ACUTE
   DB    21,0ABH                       ;; z ACUTE
   DB    31,098H                       ;; s ACUTE
   DB    38,092H                       ;; l ACUTE
   DB    44,0ECH                       ;; y ACUTE
   DB    46,086H                       ;; c ACUTE
   DB    49,0E4H                       ;; n ACUTE
CP852_AC_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_AC_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AC_UP_END-$             ;; length of state section
   DB    ACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_AC_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    11                            ;; number of entries
   DB    19,0E8H                       ;; R ACUTE
   DB    21,08DH                       ;; Z ACUTE
   DB    22,0E9H                       ;; U ACUTE
   DB    23,0D6H                       ;; I ACUTE
   DB    24,0E0H                       ;; O ACUTE
   DB    30,0B5H                       ;; A ACUTE
   DB    31,097H                       ;; S ACUTE
   DB    38,091H                       ;; L ACUTE
   DB    44,0EDH                       ;; Y ACUTE
   DB    46,08FH                       ;; C ACUTE
   DB    49,0E3H                       ;; N ACUTE
CP852_AC_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_AC_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_AC_SP_END-$             ;; length of state section
   DB    ACUTE_SPACE                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_AC_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0EFH                       ;; error character = standalone accent
CP852_AC_SP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
CP852_AC_SP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_DC_LO_END-$             ;; length of state section
   DB    DOUBLEACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_DC_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    22,0FBH                       ;; u DOUBLEACUTE
   DB    24,08BH                       ;; o DOUBLEACUTE
CP852_DC_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_DC_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_DC_UP_END-$             ;; length of state section
   DB    DOUBLEACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_DC_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    22,0EBH                       ;; U DOUBLEACUTE
   DB    24,08AH                       ;; O DOUBLEACUTE
CP852_DC_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_DC_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_DC_SP_END-$             ;; length of state section
;;   DB    DOUBLEACUTE_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F1H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_DC_SP_T1_END-$        ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of entries
;;   DB    57,0F1H                       ;; DOUBLEACUTE SPACE
;;CP852_DC_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_DC_SP_END:                       ;;
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_DI_UP_END-$             ;; length of state section
   DB    DIARESIS_UPPER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
                                       ;;
   DW    CP852_DI_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    18,0D3H                       ;;    E Diaeresis
CP852_DI_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_DI_UP_END:                       ;; length of state section
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CE_LO_END-$             ;; length of state section
   DB    CEDILLA_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CE_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    20,0EEH                       ;; t CEDILLA
   DB    31,0ADH                       ;; s CEDILLA
CP852_CE_LO_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CE_LO_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP852_CE_UP_END-$             ;; length of state section
   DB    CEDILLA_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
                                       ;;
   DW    CP852_CE_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    20,0DDH                       ;; T CEDILLA
   DB    31,0B8H                       ;; S CEDILLA
CP852_CE_UP_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CP852_CE_UP_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_CE_SP_END-$             ;; length of state section
;;   DB    CEDILLA_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F7H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_CE_SP_T1_END-$        ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of entries
;;   DB    57,0F7H                       ;; CEDILLA SPACE
;;CP852_CE_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_CE_SP_END:                       ;;
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    0                             ;; LAST STATE
                                       ;;
CP852_XLAT_END:                        ;;  END OF CP852 SECTION
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CODE     ENDS                          ;;  END OF PROGRAM
         END                           ;;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\himem\himem4a.asm ===
;/*
; *                      Microsoft Confidential
; *			 Copyright (C) Microsoft Corporation 1988-1992
; *                      All Rights Reserved.
; */

;
;*****************************************************************************
;
; HIMEM4A.ASM : 286 SPECIFIC routines
;
;*****************************************************************************
;
		public	aQueryExtMemory
		public	aAllocExtMemory
		public	aFreeExtMemory
		public	aGetExtMemoryInfo
		public	aReallocExtMemory
		public	MoveBlock286
		public	aAddMem

Begin286	label	byte

;*----------------------------------------------------------------------*
;*									*
;*  QueryExtMemory -					FUNCTION 08h    *
;*									*
;*	Returns the size of the largest free extended memory block in K	*
;*									*
;*  ARGS:   None							*
;*  RETS:   AX = Size of largest free block in K.  BL = Error code	*
;*	DX = Total amount of free extended memory in K			*
;*  REGS:   AX, BX, DX, DI, SI and Flags clobbered			*
;*									*
;*  INTERNALLY REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

aQueryExtMemory proc far

	test	ah, 80h
	jnz	BadFuncJ

	push	cx
	push	si
	push	di

	mov	dl,ERR_OUTOMEMORY	; init error code in dl

;	scan for largest FREE block

	xor	di,di			; di = Max. size found so far
	xor	si,si			; si = Total amount of free memory
	mov	bx,[KiddValley]
	mov     cx,[cHandles]		; Loop through the handle table
aQEMLoop:
	cmp	[bx].Flags,FREEFLAG
	jne     aQEMBottom

	add     si,[bx].Len.lo 		; add free block to total

	mov	ax,[bx].Len.lo		; is this the largest so far?
	cmp	di,ax
	jae     aQEMBottom

	mov	di,ax			; Yes, save it away
	xor     dl,dl			; We ain't Out o' Memory

aQEMBottom:
	add	bx,SIZE Handle
	loop    aQEMLoop

	mov	ax,di
	mov	bl,dl		; Retrieve the error code
	mov     dx,si
	mov	winbug_fix,dx	; save for windows bug workaround

	pop	di
	pop	si
	pop	cx
	ret

BadFuncJ:
	jmp	BadFunc

aQueryExtMemory endp

;*----------------------------------------------------------------------*
;*									*
;*  AllocExtMemory -					FUNCTION 09h    *
;*									*
;*	Reserve a block of extended memory				*
;*									*
;*  ARGS:   DX = Amount of K being requested				*
;*  RETS:   AX = 1 of successful, 0 otherwise.	BL = Error Code		*
;*	DX = 16-bit handle to the allocated block			*
;*  REGS:   AX, BX, DX and Flags clobbered				*
;*									*
;*	Notice:  called internally from ReallocExtMemory		*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

; Algorithm -
;
;   Scan the Handle Table looking for BOTH an unused handle and
;	a free block which is large enough:
;
;   1.	If both are found -
;	Mark the free block as used and adjust its size.
;	Make the unused handle a free block containing the remaining
;		unallocated portion of the original free block.
;
;   2.	If only an unused handle is found -
;	We're out of memory.  (Unless zero length block requested)
;
;   3.	If only a properly sized free block is found -
;	We only have one handle left.
;	Mark the free block as used.  The requester gets all of the
;		block's memory.
;
;   4.	If neither are found -
;	We're out of memory.

;hFreeBlock	dw  ?
;hUnusedBlock	dw  ?

;aemStack	struc
; hFreeBlock	dw	?
; hUnusedBlock	dw	?
;aemStack	ends

aAllocExtMemoryNear proc near
aAllocExtMemoryNear endp
aAllocExtMemory proc far

	test	ah, 80h
	jnz	BadFuncJ

	cli 			; This is a non-reentrant function

	push	cx
	push	si
	push	di


; Scan the handle table looking for BOTH an unused handle and
;	a free block which is large enough.

	xor	si, si			; Have not found Free Handle
	mov	di, si			; Have not found Unused Handle

	mov	bx, [KiddValley]
	mov     cx, [cHandles]		; Loop through the handle table

;	Have we already found a free block which is large enough?

aAEMhLoop:
	or	si, si			; did we already find a Free Handle ?
	jne     aAEMUnused		; Yes, see if this one is unused

	cmp     [bx].Flags, FREEFLAG	; Is this block free?
	jne     aAEMUnused		; No, see if it is unused

	cmp	dx, [bx].Len.lo		; Is it large enough?
	ja	aAEMNexth		; No, get the next handle

	mov	si, bx			; save this one away
	jmp	short aAEMBottom

aAEMUnused:
	or	di, di			; did we already find an unused handle?
	jne     aAEMNexth		; Yes, get the next handle

	cmp     [bx].Flags, UNUSEDFLAG	; Is this block unused?
	jne     aAEMNexth		; No, get the next handle

	mov	di, bx			; save this guy away

	cmp	si, 0			; have we found all we need?
	je	aAEMNexth
aAEMBottom:
	cmp	di, 0
	jne     aAEMGotBoth		; Yes, continue

aAEMNexth:
	add	bx, SIZE Handle		; go check the next handle
	loop    aAEMhLoop

;	We are at the end of the handle table and we didn't find both
;	things we were looking for.  Did we find a free block?

	or	si, si
	jnz     aAEMRetSuc		; Yes, Case 3 - Alloc the entire block

	or	di, di			; did we find an unused handle?
	jz	aAEMOOHandles		; No, Case 4 - We're out of handles

	or	dx, dx			; Case 2 - req for zero-length handle?
	jnz     aAEMOOMemory		; No, we're out of memory

	mov	si, di			; reserve the zero-length handle
	mov	[si].Len.lo, 0		; force length field to zero
	jmp	short aAEMRetSuc

aAEMGotBoth:

;	 We're at Case 1 above.
;	Mark the free block as used (done below) and adjust its size.
;	Make the unused handle a free block containing the remaining
;	   unallocated portion of the original free block.

	mov	ax, [si].Base.lo	; Unused.Base = Old.Base + request
	add	ax, dx
	mov	[di].Base.lo, ax

	mov	ax, dx			; New.Len = request
	xchg    [si].Len.lo, ax

	sub	ax, dx			; Unused.Len = Old.Len - request
	mov	[di].Len.lo, ax
	mov	[di].Flags, FREEFLAG	; Unused.Flags = FREE
	jnz	aAEM_nonzero_residual
	mov	[di].Flags, UNUSEDFLAG	; Unused.Flags = UNUSED
aAEM_nonzero_residual:

aAEMRetSuc:
	mov	[si].Flags, USEDFLAG	; New.Flags = USED

	if	keep_cs
	mov	ax, callers_cs
	mov	[si].Acs, ax		; keep track of allocator's cs:
	endif

	mov	dx, si
	mov	ax, 1
	xor	bl, bl
aAEM9:
	pop	di
	pop	si
	pop	cx
	ret

aAEMOOMemory:
	mov	bl, ERR_OUTOMEMORY
	jmp	short aAEMErrRet

aAEMOOHandles:
	mov	bl, ERR_OUTOHANDLES
aAEMErrRet:
	xor	ax, ax			; Return failure
	mov	dx, ax
	jmp	short aAEM9		;
aAllocExtMemory endp

;*----------------------------------------------------------------------*
;*									*
;*  FreeExtMemory -					FUNCTION 0Ah    *
;*									*
;*	Frees a block of extended memory				*
;*									*
;*  ARGS:   DX = 16-bit handle to the extended memory block		*
;*  RETS:   AX = 1 if successful, 0 otherwise.	BL = Error code		*
;*  REGS:   AX, BX, CX, DX, SI, DI and Flags clobbered			*
;*									*
;*	called internally from ReallocExtMemory				*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

aFreeExtMemoryNear proc near
aFreeExtMemoryNear endp

aFreeExtMemory proc far

	cli 				; This is a non-reentrant function

	push	cx
	push	dx
	push	si
	push	di

	call    ValidateHandle		; Make sure handle is valid
	jnc     aFEMBadh
	mov	si,dx			; Move the handle into SI

	cmp	[si].cLock,0		; make sure it points to unlocked block
	jne     aFEMLockedh

	mov	[si].Flags,UNUSEDFLAG	;  mark it as UNUSED
	cmp	[si].Len.lo,0		; if zero length block
	jz	aFEMExit			; done if it was zero length
	mov	[si].Flags,FREEFLAG	; mark it as FREE

;	now see if there's a free adjacent block

aFEMScanIt:
	mov	bx,[si].Base.lo		; BX = base of block
	mov	ax,bx			; calculate ax = top of block
	add	ax,[si].Len.lo

;	Search for an adjacent FREE block.

	mov	di,[KiddValley]		; di = Handle being scanned
	mov     cx,[cHandles]		; Loop through the handle table
aFEMLoopTop:
	cmp	[di].Flags,FREEFLAG	; Is this block free?
	jne     aFEMNexth		; No, continue

	mov	dx,[di].Base.lo		; is this block just above freed one?
	cmp     dx,ax
	je	aFEMBlockAbove     	; Yes, coalesce upwards

	add	dx,[di].Len.lo		; is it just below?
	cmp     dx,bx
	je	aFEMBlockBelow     	; Yes, coalesce downwards

aFEMNexth:
	add	di,SIZE Handle
	loop    aFEMLoopTop

;	No adjacent blocks to coalesce.

aFEMExit:
	mov     ax,1			; Return success
	xor	bl,bl
aFEM9:
	pop	di
	pop	si
	pop	dx
	pop	cx

	ret

;	Exchange the pointer to the "upper" and "lower" blocks.

aFEMBlockBelow:
	xchg    si,di

;	Move the free block above into the current handle.

aFEMBlockAbove:
	mov	dx,[si].Len.lo
	add     dx,[di].Len.lo 		; Combine the lengths
	mov	[si].Len.lo,dx
	mov     [di].Flags,UNUSEDFLAG   ; Mark old block's handle as UNUSED
	jmp	short aFEMScanIt		; Rescan the list

aFEMBadh:
	mov	bl,ERR_INVALIDHANDLE
	jmp	short aFEMErrExit

aFEMLockedh:
	mov	bl,ERR_EMBLOCKED
aFEMErrExit:
	xor     ax,ax			; Return failure
	jmp	short aFEM9
aFreeExtMemory endp



;*----------------------------------------------------------------------*
;*									*
;*  aGetExtMemoryInfo -					FUNCTION 0Eh    *
;*									*
;*	Gets other information about an extended memory block		*
;*									*
;*  ARGS:   DX = 16-bit handle to the extended memory block		*
;*  RETS:   AX = 1 if successful, 0 otherwise.	BL = Error code		*
;*	    BH = EMB's lock count					*
;*	    BL = Total number of unused handles in the system		*
;*	    DX = EMB's length						*
;*  REGS:   AX, BX, CX, DX and Flags clobbered				*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

aGetExtMemoryInfo proc	far

	test	ah, 80h
	jnz	BadFunc

	cli 			; This is a non-reentrant function

	push	cx
	push	si

	call    ValidateHandle	; is the handle valid?
	jnc     aGEMBadh
	mov     si,dx		; Move the handle into SI

	cmp	[si].Len.hi, 0	; Size > 64M ?
	jne	aGEMBadh		; yes, we cannot handle this function

	xor     ax,ax		; count number of UNUSED handles
	mov     bx,[KiddValley]
	mov     cx,[cHandles]	; Loop through the handle table
aGEMLoop:
	cmp     [bx].Flags,USEDFLAG ; Is this handle in use?
	je	aGEMNexth	; Yes, continue
	inc     ax		; No, increment the count
aGEMNexth:
	add     bx,SIZE Handle
	loop    aGEMLoop

	mov     dx,[si].Len.lo 	; Length in DX
	mov     bh,[si].cLock	; Lock count in BH
	or	ah, ah		; Free handles > 255 ?
	jz	@f
	mov	al, 0ffh	; make it 255 if > 255
@@:
	pop	si
	pop	cx
	mov     bl,al
	mov	ax,1
	ret

aGEMBadh:
	pop	si
	pop	cx
	mov	bl,ERR_INVALIDHANDLE
	xor	ax,ax
	ret

aGetExtMemoryInfo endp

;*----------------------------------------------------------------------*
;*									*
;*  BadFunc -								*
;*									*
;*  ARGS:   None							*
;*  RETS:   Invalid function error in Bl and 0 in AX			*
;*  REGS:   Trashes AX & BL						*
;*									*
;*----------------------------------------------------------------------*

BadFunc	proc	near
	mov	bl, ERR_NOTIMPLEMENTED
	xor	ax, ax
	ret
BadFunc	endp

;*----------------------------------------------------------------------*
;*									*
;*  ReallocExtMemory -					FUNCTION 0Fh    *
;*									*
;*	Reallocates a block of extended memory				*
;*									*
;*  ARGS:   DX = 16-bit handle to the extended memory block		*
;*	    BX = new size for block					*
;*  RETS:   AX = 1 if successful, 0 otherwise.	BL = Error code		*
;*  REGS:   trashes si,di,bx,cx,dx					*
;*									*
;*  INTERNALLY NON-REENTRANT						*
;*									*
;*----------------------------------------------------------------------*

;	Define our memory move structure for calling the move function

aReallocExtMemory	proc	far

	test	ah, 80h
	jnz	BadFunc

	cli 			; This is a non-reentrant function

	push	cx
	push	dx
	push	si
	push	di

	push    bp		; preserve caller's bp

	call    ValidateHandle	; is the handle valid?
	mov	si,dx		; Move the handle into SI
	mov	dx,bx		; Move the new length into dx
	mov	bl,ERR_INVALIDHANDLE
	jnc     aREMError

	cmp	[si].cLock,0	; We can only work on unlocked EMBs
	mov	bl,ERR_EMBLOCKED
	jnz	aREMError

;	There are basically five successful cases for this function:
;
;	1. The new size is the same.  No operation.
;
;	2. We're making the block smaller.  Truncate & Coalesce.
;
;	3. We're making the block bigger and sufficient memory is
;	   available from the immediately following block to append.
;
;	4. We're making the block bigger and sufficient memory is
;	   available from the immediately preceding block (and possibly
;	   the following block as well).  Add the memory and slide data down.
;
;	5. We must find a whole new block which is bigger.
;
	cmp	dx,[si].Len.lo		; check for cases 1 and 2
	ja	aREMGrow			; cases 3, 4, 5 - growing
	jb	aREMShrink		; case 2 - shrinking

;	Case 1:  no change in size.  We're done.

aREMExit:
	mov	ax,1			; succesful return
	xor	bl,bl			; non-documented no-error return
aREM9:
	pop	bp			; restore caller's bp
	pop	di
	pop	si
	pop	dx
	pop	cx
	ret

;	Case 2: Truncate the block and coalesce
;	   Scan the list of handles to see if there is an
;	   existing EMB immediately following us that we can
;	   append the memory to.

aREMShrink:

	push    dx			; save new size
	call    aFindAdjacent		; see if a block follows us
	pop	dx			; restore our new size
	or	bp,bp			; does a block follow us?
	jz	aREMShrink5		;  brif not

;	This is the easy case of shrinking.  All we have to do is move
;	   the deallocated memory into the following block

	mov	ax,[si].Len.lo		; old length
	sub	ax,dx			; we're truncating this much
	mov	[si].Len.lo,dx		; adjust our block downwards

	add	ds:[bp].Len.lo,ax		; increase next block by same
	sub	ds:[bp].Base.lo,ax		;  and lower its base

	jmp	short aREMExit		; exit okay!

;	Locate an error return here for easy access

aREMError:
	xor	ax,ax
	jmp	short aREM9

;	We'll have to create a new block to give the freed space to.

aREMShrink5:
	mov	di,[KiddValley]		; look for an available handle
	mov	cx,[cHandles]
aREMS5a:
	cmp	[di].Flags,UNUSEDFLAG
	jz	aREMS5b			; brif found free handle
	add	di,SIZE Handle
	loop    aREMS5a
	mov	bl,ERR_OUTOHANDLES
	jmp	short aREMError		; Abort without shrinking if none

aREMS5b:
	mov	ax,dx			; get new length
	add	ax,[si].Base.lo		;  calculate begin of new block
	mov	[di].Base.lo,ax

	mov	ax,[si].Len.lo		; new length
	sub	ax,dx			;  calculate length of new block
	mov	[di].Len.lo,ax

	mov	[di].Flags,FREEFLAG     ; setup lock count and flags
	mov	[di].cLock,0

	mov	[si].Len.lo,dx		; adjust length of original block

	jmp	short aREMExit		; exit okay!


aREMGrow:
	push    dx			; save new length
	call    aFindAdjacent		; locate adjacent blocks
	pop	dx

;	hopefully the following block is big enough.  that's the easiest
;	   case.  If so, we'll just snatch the space and then kill it if
;	   its size goes to zero.

;	Don't forget:  di = preceding block's handle (or zero)
;		   si = original block's handle
;		   bp = following block's handle (or zero)

	or	bp,bp			; is there a following block?
	jz	aREMGrow4		; skip if not
	mov	ax,dx			; new size
	sub	ax,[si].Len.lo		;  calculate growth amount
	cmp	ax,ds:[bp].Len.lo	; will next block accomodate?
	ja	aREMGrow4		;  nope.  not big enough.

;	Case 3: The following block has enough space for our needs.

	jz	aREMGrow2		; skip if we're using whole block

	sub	ds:[bp].Len.lo,ax	; make it smaller
	add	ds:[bp].Base.lo,ax		;  and start later
	jmp	short aREMGrow3

aREMGrow2:
	mov	ds:[bp].Flags,UNUSEDFLAG; mark it as free
aREMGrow3:
	mov	[si].Len.lo,dx		; update length of caller's block
	jmp	aREMExit

;	Come here if we can't find enough room from a following block.
;	  Now decide whether to use case 4 (use prev or both adjacent blocks)
;	  or case 5 (find another block entirely).  Notice that either
;	  of these solutions will require a memory move operation.

aREMGrow4:
	or	di,di			; is there a preceding block?
	jz	aREMGrow7x		;  nope.  resort to case 5

	mov	ax,[di].Len.lo
	add	ax,[si].Len.lo		; get size of prev + orig block
	or	bp,bp			; Is there a following block?
	jz	aREMGrow4a		;  skip if not
	add	ax,ds:[bp].Len.lo		; calculate max possible resource
aREMGrow4a:
	cmp	dx,ax			; is all of that sufficient
	jna	aREMGrow5		;  to handle whole thing? brif so
aREMGrow7x:
	jmp	aREMGrow7

;	There will be only one or two blocks left of the possible three
;	 when we're finished.  We'll start by merging the following block
;	 onto the middle block and freeing its handle, but we'll save the
;	 original length of the middle block so we don't end up moving more
;	 memory than we need.

aREMGrow5:

;	Now we need a move structure.  Allocate one on the stack and point
;	   es:bx to it

;	Always make sure stack stays on even boundary

	sub	sp,0fffeh and (1+SIZE MoveExtendedStruc)
	push    ss			; point es:bx to stack frame
	pop	es
	mov	bx,sp

	push    [si].Len.lo		; save length of move
	or	bp,bp			;  is there a following block?
	jz	aREMGrow5a		;  brif not

	mov	ax,ds:[bp].Len.lo		; get it's length
	add	[si].Len.lo,ax		; suck it in
	mov	ds:[bp].Flags,UNUSEDFLAG; that handle is now unused

;	Now change the main block to include all of the space.  Notice
;	  that the 'previous' block will still exist as an overlapping
;	  subset of the total block during the move.  We'll sort it out
;	  again after the move when we're able to disable interrupts
;	  again.

aREMGrow5a:
	mov	ax,[di].Len.lo		; get length of bottom block
	add	[si].Len.lo,ax		; add it into our target block
	push    [si].Base.lo		; save base of data block to move
	mov	ax,[di].Base.lo		; base of bottom block becomes
	mov	[si].Base.lo,ax		;  of super block
	inc	[di].cLock		; lock both blocks so's we don't
	inc	[si].cLock		;  get moved around

;	Now make the move in the new merged block.  Offsets are relative
;	  to the base of the block.  Zero is the destination.  The old
;	  base ([sp]) is the source (in 1k), the old length ([sp+2]) is
;	  the length (in 1k).

	mov	es:[bx].SourceHandle,si	; both handles = our main block
	mov	es:[bx].DestHandle,si
	mov	es:word ptr [bx].DestOffset,0 ; move data to base of block
	mov	es:word ptr [bx].DestOffset+2,0

	pop	ax			; get source begin address
	sub	ax,[si].Base.lo		; find offset within block

;	now use trick to make cx:ax = ax * 1024

	ror	ax,6			; like rcl ax,10 but faster
	mov	cx,ax
	and	cx,3ffh
	and	ax,0fc00h
	mov	es:word ptr [bx].SourceOffset,ax
	mov	es:word ptr [bx].SourceOffset+2,cx

	pop	ax			; get length in Kilobytes
	ror	ax,6			; trick multiply by 1024 again
	mov	cx,ax
	and	cx,3ffh
	and	ax,0fc00h
	mov	es:word ptr [bx].bCount,ax
	mov	es:word ptr [bx].bCount+2,cx

	push    si			; save main handle
	push    di			; save residual handle
	push    dx			; save new block length
	mov	si,bx
;
	push	cs
	call	BlkMovX
	pop	dx
	pop	di
	pop	si

;	Release the move structure stack frame

	add	sp,0fffeh and (1+SIZE MoveExtendedStruc)

	cli				; can't mess with us
	dec	[di].cLock		; remove our locks
	dec	[si].cLock
	mov	ax,[si].Len.lo		; get total block length
	sub	ax,dx			;  less amount requested by user
	mov	[si].Len.lo,dx
	jz	aREMGrow5b		; branch if no residual block

	add	dx,[si].Base.lo		; get base of residual block
	mov	[di].Base.lo,dx
	mov	[di].Len.lo,ax		; save length of residual block
	jmp	aREMExit			; We're done!

aREMGrow5b:
	mov	[di].Flags,UNUSEDFLAG   ; free the handle if block empty
	jmp	aREMExit			; DONE!

;	Another error return centrally for easy conditional branch access

aREMErrora:
	xor	ax,ax			; indicate error condition
	jmp	aREM9

aREMGrow7:
	push    si			; save our handle
	push    dx			; save our desired length
	push	cs			; fake a far call
	call	aAllocExtMemoryNear	; try to allocate a new block
	cli
	mov	di,dx			;  save its results
	pop	dx
	pop	si
	or	ax,ax			; did we fail?
	mov	bl,ERR_OUTOMEMORY	;  not enough memory
	jz	aREMErrora
	inc	[di].cLock		; lock both blocks so's we don't
	inc	[si].cLock		;  get moved around

;	Now move the data from the old block to the new one before
;	  swapping the handles and deallocating the original block

;	Allocate a stack frame for a move structure

	sub	sp,0fffeh and (1+SIZE MoveExtendedStruc)
	push    ss			; point es:bx to a move structure
	pop	es
	mov	bx,sp

	mov	es:[bx].SourceHandle,si ; source handle = our main block
	mov	es:[bx].DestHandle,di   ; dest handle = new block
	xor	cx,cx
	mov	es:word ptr [bx].DestOffset,cx ; move to base of new block
	mov	es:word ptr [bx].DestOffset+2,cx
	mov	es:word ptr [bx].SourceOffset,cx ; from base of old block
	mov	es:word ptr [bx].SourceOffset+2,cx

	mov	ax,[si].Len.lo		; get length of old block
	ror	ax,6			; trick multiply by 1024
	mov	cx,ax
	and	cx,3ffh
	and	ax,0fc00h
	mov	es:word ptr [bx].bCount,ax
	mov	es:word ptr [bx].bCount+2,cx

	push    si			; save main handle
	push    di			; save new handle
	mov	si,bx
	push	cs
	call	BlkMovX
	pop	di
	pop	si

;	Deallocate stack frame

	add	sp,0fffeh and (1+SIZE MoveExtendedStruc)

	cli				; can't mess with us

;	Now we have to reverse the two handles so that we can return
;	  the new block to the user without changing his handle

	mov	ax,[si].Base.lo
	xchg    ax,[di].Base.lo
	mov	[si].Base.lo,ax

	mov	ax,[si].Len.lo
	xchg    ax,[di].Len.lo
	mov	[si].Len.lo,ax

	dec	[si].cLock		; remove our locks
	dec	[di].cLock

	mov	dx,di			; handle to free
	pop	bp			; restore caller's bp

	pop	di
	pop	si
	pop	cx			; suck out dx on stack
	pop	cx

	jmp	aFreeExtMemoryNear	; do it!, return any errors

aReallocExtMemory	endp


;*----------------------------------------------------------------------*
;*									*
;*  FindAdjacent unused blocks						*
;*									*
;*	Scan through handle list looking for blocks adjacent		*
;*	  to a given handle.						*
;*									*
;*  ARGS:   SI handle of original block					*
;*  RETS:   DI = handle of adjacent block below or zero if none		*
;*	BP = handle of adjacent block above or zero if none		*
;*									*
;*  TRASHES: AX,BX,CX,DX						*
;*									*
;*  messes with handle table - not reentrant - assumes ints disabled	*
;*									*
;*----------------------------------------------------------------------*

aFindAdjacent	proc	near

	mov	ax,[si].Base.lo		; look for blocks ending here
	mov	dx,[si].Len.lo
	add	dx,ax			; and ending here

	xor	di,di			; initialize to fail condition
	mov	bp,di

	mov	bx,[KiddValley]		; prepare to loop thru handle tab
	mov	cx,[cHandles]

	push    si			; preserve original handle

aFindAdj1:
	cmp	[bx].Flags,FREEFLAG
	jnz	aFindAdj3		; ignore blocks that aren't UNUSED
	mov	si,[bx].Base.lo
	cmp	dx,si			; found beg block?
	jnz	aFindAdj2		;  skip if not
	mov	bp,bx			;  remember the handle
	or	di,di			; did we already find a follower?
	jnz	aFindAdj9		;  we're done if so

aFindAdj2:
	add	si,[bx].Len.lo		; find length
	cmp	si,ax			; does this block end at spec addr?
	jnz	aFindAdj3		;  skip if not
	mov	di,bx			;  remember the handle
	or	bp,bp			; did we already find a leader?
	jnz	aFindAdj9		;  we're done if so

aFindAdj3:
	add	bx,SIZE handle
	loop    aFindAdj1

aFindAdj9:
	pop	si			; restore original handle
	ret
;

aFindAdjacent	endp

;*----------------------------------------------------------------------*
;*									*
;*  MoveExtMemory -					FUNCTION 0Bh    *
;*									*
;*	Copys a block of memory from anywhere to anywhere		*
;*									*
;*  ARGS:   ES:SI = Pointer to an Extended Memory Block Move Structure	*
;*		(NOTE: Originally passed in as DS:SI)			*
;*  RETS:   AX = 1 of successful, 0 otherwise.	BL = Error code.	*
;*  REGS:   Everybody clobbered						*
;*									*
;*	Note:  A20 must be enabled before we're invoked!!!!		*
;*									*
;*	Notice:  called internally from ReallocExtMemory		*
;*									*
;*  INTERNALLY REENTRANT (believe it or not)				*
;*									*
;*----------------------------------------------------------------------*

	EVEN				; Must be word aligned.

; NOTE: From here on, the code/data is variable, and will be setup
; by the init code.

;*----------------------------------------------------------------------*

	public	CS0, CS1, LCSS, CSDES

MoveBlock286:

;*******************************************************************************
;
; MoveExtended286
;	XMM Move Extended Memory Block for the 80286
;
;	Copyright (c) 1988, Microsoft Corporation
;
; Entry:
;	ES:BX	Points to a MoveExtendedStruc
;
; Return:
;	AX = 1	Success
;	AX = 0	Failure
;		Error Code in BL
;
; Registers Destroyed:
;	Flags, CX, SI, DI, ES
;
;			WARNING
;			=======
;
; This routine enables interrupts and can be re-entered
;
; Notes:
;	The case of copying from conventional to conventional memory
;	is not treated specially in this example.
;
; History:
;	Wed Jul 13 - AWG - Original version
;-------------------------------------------------------------------------------
MoveExtended286 proc	far

	assume	ds:_text

	sti					; Be nice
	push	bp				; Set up stack frame so we
	mov	bp, sp				; can have local variables
	sub	sp, 18				; Space for local variables
Count	  = -4					; Local DWORD for byte count
MEReturn  = -6					; Local WORD for return code
SrcHandle = -8
DstHandle = -10
SrcLinear = -14
DstLinear = -18
	push	bx
	push	dx

	xor	ax, ax
	mov	[bp.MEReturn], ax		; Assume success
	mov	[bp.SrcHandle], ax
	mov	[bp.DstHandle], ax
	mov	ax, word ptr es:[si].bCount	; Pick up length specified
	mov	word ptr [bp.Count], ax
	mov	cx, word ptr es:[si].bCount+2
	mov	word ptr [bp.Count+2], cx
	or	cx, ax
	jcxz	MEM2_Exit			; Exit immediately if zero

	lea	bx, [si].SourceHandle		; Normalize Source
	call	GetLinear286			; Linear address in DX:AX
	jc	MEM2_SrcError			; Have Dest Error Code

	mov	word ptr [bp.SrcLinear], ax	; Save Linear address
	mov	word ptr [bp.SrcLinear+2], dx
	mov	[bp.SrcHandle], bx		; Save Handle for Unlock

	lea	bx, [si].DestHandle		; Normalize Destination
	call	GetLinear286
	jc	MEM2_Error

	mov	word ptr [bp.DstLinear], ax	; Save Linear address
	mov	word ptr [bp.DstLinear+2], dx
	mov	[bp.DstHandle], bx		; Save Handle for Unlock

	shr	word ptr [bp.Count+2], 1	; Make word count
	rcr	word ptr [bp.Count], 1
	jc	MEM2_InvCount			; Odd count not allowed

	call	LEnblA20
	cmp	ax, 1
	jne	MEM2_Error

	call	DoLoadAll

	call	LDSblA20
	cmp	ax, 1
	jne	MEM2_Error

MEM2_Exit:
	mov	bx, [bp.SrcHandle]		; Unlock Handles if necessary
	or	bx, bx
	jz	NoSrcHandle
	dec	[bx].cLock			; Unlock Source
NoSrcHandle:
	mov	bx, [bp.DstHandle]
	or	bx, bx
	jz	NoDstHandle
	dec	[bx].cLock			; Unlock Destination
NoDstHandle:
	pop	dx
	pop	bx
	mov	ax, 1
	cmp	word ptr [bp.MEReturn], 0
	jz	MEM2_Success
	dec	ax
	mov	bl, byte ptr [bp.MEReturn]
MEM2_Success:
	mov	sp, bp				; Unwind stack
	pop	bp
	ret

MEM2_SrcError:
	cmp	bl, ERR_LENINVALID		; Invalid count
	je	MEM2_Error			;  yes, no fiddle
	sub	bl, 2				; Convert to Source error code
	jmp	short MEM2_Error
MEM2_InvCount:
	mov	bl, ERR_LENINVALID
MEM2_Error:
	mov	byte ptr [bp.MEReturn], bl	; Pass error code through
	jmp	short MEM2_Exit

;*******************************************************************************
;
; GetLinear286
;	Convert Handle and Offset (or 0 and SEG:OFFSET) into Linear address
;	Locks Handle if necessary
;	Nested with MoveExtended286 to access local variables
;
; Entry:
;	ES:BX	Points to structure containing:
;			Handle	dw
;			Offset	dd
;	[BP.Count]	Count of bytes to move
;
; Return:
;	BX	Handle of block (0 if conventional)
;	AX:DX	Linear address
;	CARRY	=> Error
;		Error code in BL
;
; Registers Destroyed:
;	Flags, CX, DI
;
;-------------------------------------------------------------------------------

GetLinear286	proc	near
	push	si
	cli					; NO INTERRUPTS
	mov	si, word ptr es:[bx+2]		; Offset from start of handle
	mov	di, word ptr es:[bx+4]		; in DI:SI
	mov	bx, word ptr es:[bx]		; Handle in bx
	or	bx, bx
	jz	GL2_Conventional

	test	[bx].Flags, USEDFLAG		; Valid Handle?
	jz	GL2_InvHandle

	mov	ax, [bx].Len.lo			; Length of Block
	mov	cx, 1024
	mul	cx				; mul is faster on the 286
	sub	ax, si
	sbb	dx, di				; DX:AX = max possible count
	jc	GL2_InvOffset			; Base past end of block
	sub	ax, word ptr [bp.Count]
	sbb	dx, word ptr [bp.Count+2]
	jc	GL2_InvCount			; Count too big

	inc	[bx].cLock			; Lock the Handle
	mov	ax, [bx].Base.lo
	mul	cx
	add	ax, si				; Linear address
	adc	dx, di				; in DX:AX

GL2_OKExit:
	clc
GL2_Exit:
	sti
	pop	si
	ret

GL2_Conventional:
	mov	ax, di				; Convert SEG:OFFSET into
	mov	dx, 16				; 24 bit address
	mul	dx
	add	ax, si
	adc	dx, 0				; DX:AX has base address
	mov	di, dx
	mov	si, ax
	add	si, word ptr [bp.Count]		; Get End of Block + 1 in DI:SI
	adc	di, word ptr [bp.Count+2]

	cmp	di, 010h			; Make sure it doesn't wrap
	ja	GL2_InvCount			;  past the end of the HMA
	jb	GL2_OKExit
	cmp	si, 0FFF0h
	jbe	GL2_OKExit			; Must be < 10FFF0h
GL2_InvCount:
	mov	bl, ERR_LENINVALID
	jmp	short GL2_Error

GL2_InvHandle:
	mov	bl, ERR_DHINVALID		; Dest handle invalid
	jmp	short GL2_Error

GL2_InvOffset:
	mov	bl, ERR_DOINVALID		; Dest Offset invalid
GL2_Error:
	stc
	jmp	short GL2_Exit

GetLinear286	endp

;******************************************************************************
;
; DoLoadAll
;	Use 286 LoadAll for copy - see warnings below
;	Nested within MoveExtended286
;
; Entry:
;	[BP.Count]	Word count for move
;	[BP.SrcLinear]	Linear address of the source
;	[BP.DstLinear]	Linear address of the destination
;
;	Interrupts are ON
;
; Return:
;	CARRY	=> Error
;		Error code in BL
;
; Registers Destroyed:
;	Flags, AX, BX, CX, DX, SI, DI
;
;------------------------------------------------------------------------------

	EVEN		;* WORD alignment for data

; Swap buffer for contents of 80:0
cwBuffer  EQU	51
rgwSwap80 DW	cwBuffer DUP (?)

; LOADALL data buffer placed at 80:0
;
LOADALL_TBL	LABEL	BYTE
	DB	6 DUP(0)
LDSW	DW	?
	DB	14 DUP (0)
TR	DW	0
LFLAGS	DW	0		; High 4 bits 0, Int off, Direction clear
				;   Trace clear. Rest don't care.
LIP	DW	OFFSET	AFTER_LOADALL
LDT	DW	0
LDSS	DW	8000H
LSSS	DW	80H
LCSS	DW	?
LESS	DW	8000H
LDI	DW	0
LSI	DW	Offset rgwSwap80
LBP	DW	0
LSP	DW	?
LBX	DW	?
LDX	DW	?
LCX	DW	cwBuffer
LAX	DW	80H
ESDES	SEGREG_DESCRIPTOR <>
CSDES	SEGREG_DESCRIPTOR <>
SSDES	SEGREG_DESCRIPTOR <800H,0>
DSDES	SEGREG_DESCRIPTOR <>
GDTDES	DTR_DESCRIPTOR <>
LDTDES	DTR_DESCRIPTOR <0D000H,0,0FFH,0088H>
IDTDES	DTR_DESCRIPTOR <>
TSSDES	DTR_DESCRIPTOR <0C000H,0,0FFH,0800H>

DescSaved	dw	-1		; Flag for reentrancy

SaveDesc	macro	reg
	push	word ptr reg		; Save 3 word descriptor
	push	word ptr reg+2	; pointed to by reg
	push	word ptr reg+4
	endm

RestoreDesc	macro	reg
	pop	word ptr reg+4	; Restore 3 word descriptor
	pop	word ptr reg+2	; pointed to by reg
	pop	word ptr reg
	endm

NOP4	macro
	sti				; Faster than nop
	sti
	sti
	sti
	endm

DoLoadAll	proc	near


	cld					;* just to be sure

	mov	ax, word ptr [bp.SrcLinear]	; Create descriptors for source
	mov	dl, byte ptr [bp.SrcLinear+2]	; and destination of transfer
	mov	cx, word ptr [bp.DstLinear]
	mov	dh, byte ptr [bp.DstLinear+2]
	xchg	[DSDES].SEG_BASE_LO,ax		; Fill in table and pick up
	xchg	[DSDES].SEG_BASE_HI,dl		; old values
	xchg	[ESDES].SEG_BASE_LO,cx
	xchg	[ESDES].SEG_BASE_HI,dh

	mov	bx,Offset IDTDES
	mov	si,Offset GDTDES

	inc	[DescSaved]
	jz	DLA_NoSave			; Don't save old vals 1st time
	push	ax				; Save so we can be re-entrant
	push	cx
	push	dx
	push	[LDSW]
	SaveDesc	cs:[bx]			; Save IDTDES on stack
	SaveDesc	cs:[si]			; Save GDTDES on stack
DLA_NoSave:

	smsw	[LDSW]				; put MSW, GDT & IDT in buffer

;* NOW The damn SXXX instructions store the desriptors in a
;*	  different order than LOADALL wants

	sidt	cs:fword ptr [bx]
	call	FixDescriptor
	mov	bx, si
	sgdt	cs:fword ptr [bx]
	call	FixDescriptor

DLA_MoveLoop:
						; byte count fits in one word
	mov	cx, 7fffh			; Must be < 8000h
	cmp	word ptr [bp.Count+2], 0	; Lots to do?
	ja	DLA_DoMove
	cmp	word ptr [bp.Count], cx
	jae	DLA_DoMove
	mov	cx, word ptr [bp.Count]		; Just what is left

DLA_DoMove:
	push	ds
	push	bp			;* gets trashed later
	mov	ax, 80H			; Set up for first copy - can do before
	mov	bx, cs			; disabling interrupts
	mov	dx, cwBuffer
	xor	si, si
	mov	es, bx
	mov	di, Offset rgwSwap80	;* ES:DI = CS:rgwSwap80 = save address

	CLI				; Un interruptable
	MOV	[LSP], sp		;* the real stack limit
	mov	[LBX], ss
	mov	[LDX], cx		;* the actual count of words to move
					;* will be in DX
	mov	ds, ax			;* DS:SI = 80:0 = source address

	assume	ds:nothing

	mov	cx, dx			; cwBuffer

	rep movsw			; Save contents of 80:0

;*	* now move info from LOADALL_TBL buffer into 80:0

	xor	di, di
	mov	es, ax			;* ES:DI = 80:0 (dest)
	mov	si, Offset LOADALL_TBL
	mov	ds, bx			;* DS:SI = CS:LOADALL_TBL (src)
	mov	cx, dx			; cwBuffer
	rep movsw			; Transfer in LOADALL info
	LODAL286			;* LOADALL INSTRUCTION (set AX = 80H)

; now set up stack for moving 80:0 info back again
; LOADALL will set the following registers:
;	AX = 80H
;	BX = old SS
;	CX = cwBufer
;	DX = word count to move
;	SI = OFFSET rgwSwap80
;	DI = 0
;	BP = 0, SS = 80H  (SS:BP => loadall area to restore)
;	DS:0 = source address (DS may be outside real mode), do not rely
;		on the DS register.
;	ES:0 = destination address (ES may be outside real mode), do not
;		rely on the ES register unless reading.

AFTER_LOADALL:
move_loop:
	lods	word ptr cs:[si]
	mov	ss:[bp],ax		;* can't override ES
	inc	bp
	inc	bp
	loop	move_loop

;*	* now actually move the data

	mov	ss, bx	 		;* restore SS
	mov	cx, dx			;* actual word count
	mov	si, di			;* source and destination 0
	STI

;* * * ** End Interrupt Off Code
;* * * ** Begin Interrupt Protected Code

	rep movsw			;* Move data

	db	0EAh				; jmp far move_stopped
	dw	Offset move_stopped		;	fixes up CS
cs0	dw	0

;* * * ** End Interrupt Protected Code
;*	* if this ever gets interrupted, we will jump 16 bytes
;*	*  CS will be bogus CS+1 value
;		CX WILL INDICATE IF THE MOVE WAS COMPLETED
	NOP4
	NOP4
	NOP4
	NOP4

	db	0EAh				; jmp far move_stopped
	dw	Offset move_stopped		;	fixes up CS
cs1	dw	0

move_stopped:					;* resume after move stops
	pop	bp
	pop	ds				; Get our DS back
	assume	ds:_text

	mov	cx, si
	shr	cx, 1				; # words moved
	sub	word ptr [bp.Count], cx		; Subtract what we just did
	jz	DLA_TestDone
	sbb	word ptr [bp.Count+2], 0	; Not zero, more to do
DLA_KeepGoing:
	add	[DSDES].SEG_BASE_LO, si		; Update base of segments to end
	adc	[DSDES].SEG_BASE_HI, 0		; of transfer done so far.  Our
	add	[ESDES].SEG_BASE_LO, di		; LoadAll buffer always puts 0
	adc	[ESDES].SEG_BASE_HI, 0		; in SI and DI
	jmp	DLA_MoveLoop

DLA_TestDone:
	sbb	word ptr [bp.Count+2], 0
	jnz	DLA_KeepGoing			; High word nonzero, more to do

DLA_done:
	cmp	[DescSaved], 0			; Did we save registers?
	jz	DLA_NoRestore

	mov	bx, offset GDTDES
	RestoreDesc	cs:[bx]
	mov	bx, offset IDTDES
	RestoreDesc	cs:[bx]
	pop	[LDSW]
	pop	dx				; Restore original Segment bases
	pop	bx				; in our LoadAll buffer
	pop	ax
	mov	[DSDES].SEG_BASE_LO, ax
	mov	[DSDES].SEG_BASE_HI, dl
	mov	[ESDES].SEG_BASE_LO, bx
	mov	[ESDES].SEG_BASE_HI, dh
DLA_NoRestore:
	dec	[DescSaved]
	ret

;**	FixDescriptor - Shuffle GTD IDT descriptors
;*
;*	The segment descriptors for the IDT and GDT are stored
;*	by the SIDT instruction in a slightly different format
;*	than the LOADALL instruction wants them. This routine
;*	performs the transformation.
;*
;*	ENTRY:
;*	    CS:BX points to IDT or GDT descriptor in SIDT form
;*	EXIT:
;*	    CS:BX points to IDT or GDT descriptor in LOADALL form
;*	USES: AX,CX,DX
;*
FixDescriptor	proc	near
	mov	ax,cs:[bx+4]
	mov	cx,cs:[bx+2]
	mov	dx,cs:[bx]
	mov	cs:[bx+4],dx
	mov	cs:[bx],cx
	mov	cs:[bx+2],ax
	ret
FixDescriptor	endp

DoLoadAll	endp

MoveExtended286	endp

;*----------------------------------------------------------------------*
;*									*
;*  aAddMem - add memory to free pool					*
;*									*
;*	The trick here is that we're going to check for overlapping	*
;*	  or adjacent blocks and crunch them together.  The thinking	*
;*	  here is that we may be informed of a memory resource from	*
;*	  more than one source.  In any case, we NEVER want the same	*
;*	  memory to appear in our resource table more than once.	*
;*									*
;*	Note:  there's presently no way of reporting errors if the	*
;*	  handle table is full.  If it happens, we'll just lose the	*
;*	  memory block.  This should not be a problem as long as	*
;*	  we're only being called during program initialization.	*
;*									*
;*	It would be nice if we could throw this code away after		*
;*	  initialization, unfortunately this is actually invoked	*
;*	  at HookInt15 time, so it's too late to do away with		*
;*	  obsolete code.						*
;*									*
;*  ARGS:    CX - base of block in 1K increments			*
;*	     AX - length of block in 1K increments			*
;*  TRASHES: AX,BX,CX,DX,SI,DI						*
;*									*
;*  messes with handle table - not reentrant - assumes ints disabled	*
;*									*
;*----------------------------------------------------------------------*

aAddMem	proc	far

;	We might as well be scanning for a free handle while we're
;	 at it since we're normally going to need one at the end

	mov	dx,ax		; save new block length in dx
	mov	si,cx		; save new block base in si
	xor	di,di		; haven't found free handle yet

	mov	bx,[KiddValley]	; prepare to loop thru handle tab
	mov	cx,[cHandles]

aAM01:
	cmp	[bx].Flags,UNUSEDFLAG ; is this handle available?
	jnz	aAM02		; skip if not

	or	di,di		; use the first free handle we
	jnz	aAM05		;  find.  skip if we've got one

	mov	di,bx		; save the unused handle in di
	jmp	short aAM05

aAM02:


;	Note:  Normally all handles will be either UNUSED or FREE at
;	  this point.  However, in the case of checking for Zenith memory,
;	  it may have a temporarily allocated dummy block.  Therefore
;	  we'll only be merging blocks marked as FREE.

	cmp	[bx].Flags,FREEFLAG
	jnz	aAM05		; ignore USED blocks

;	   First check for new block being entirely after block at [bx]

	mov	ax,[bx].Base.lo
	add	ax,[bx].Len.lo
	cmp	ax,si		; is [bx].end < new.Base?
	jb	aAM05		;  done checking this entry if so

;	   Now check for new block being entirely before block at [bx]

	mov	ax,si		; new.base
	add	ax,dx		; + new.len = new.end
	cmp	ax,[bx].Base.lo
	jb	aAM05		; brif no overlap at all
;
;	   Now suck the block at [bx] up into our block in registers so
;	   that we can continue the scan.  There may be other adjacent
;	   blocks, even in the case of no overlap, fr'instance when a
;	   block is added which entirely fills the gap between two others.

	mov	ax, [bx].Len.lo
	add	ax, [bx].Base.lo; AX = end of this block
	add	dx, si		; DX = end of new block

	cmp	si, [bx].Base.lo; does the current block start before the new
	jbe	@f		;  no, keep the new start
	mov	si, [bx].Base.lo;  yes, update new block start
@@:
	cmp	dx, ax		; does the cur block end after the new one
	jae	@f		;  no, keep the new end
	mov	dx, ax		;  yes, update the new end
@@:
	sub	dx, si		; DX = Length of combined block
				; SI = Base of Combined block

	mov	[bx].Flags,UNUSEDFLAG ; mark the block unused
	or	di,di		; did we find an unused handle yet?
	jnz	aAM05		;  brif so
	mov	di,bx		; save this one if not

aAM05:
	add	bx,SIZE handle
	loop    aAM01

	or	di,di		; did we find a free handle?
	jz	aAM06		;  error!  no handles free!

	mov	[di].cLock,0
	mov	[di].Flags,FREEFLAG ; create the free memory block
	mov	[di].Base.lo,si
	mov	[di].Len.lo,dx

aAM06:
	ret

aAddMem	endp

End286	label	byte



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kdfhu.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
       PAGE    ,132
	TITLE   MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Definition File
;;
;; This file contains the keyboard tables for:
;; HUNGARY
;; which form the Multilingual (ML) Group 2.
;;
;; Linkage Instructions:
;;      Refer to KDF.ASM.
;;
;;
;; WRITTEN:    Michael J. Saunders 2.OCTOBER 1987
;;	       Adapted by Mihindu (Microsoft) Nov. 30, 1990
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC           ;;
	INCLUDE POSTEQU.INC            ;;
	INCLUDE KEYBMAC.INC            ;;
				       ;;
	PUBLIC HU_LOGIC                ;;
	PUBLIC HU_850_XLAT             ;;
	PUBLIC HU_852_XLAT             ;;
				       ;;
CODE    SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a linear search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE      EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; HU State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
HU_LOGIC:                              ;;
				       ;;
   DW  LOGIC_END-$                     ;; length
				       ;;
   DW  0                               ;; special features
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND                ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;  ***BD - THIS SECTION HAS BEEN UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKBD G_KB                             ;;P12_KB - ONLY VALID FOR ENHANCED KB
				       ;;
 IFF EITHER_CTL,NOT                    ;;
    IFF EITHER_ALT,NOT                 ;;
      IFF EITHER_SHIFT                 ;;
	  SET_FLAG DEAD_UPPER          ;;
      ELSEF                            ;;
	  SET_FLAG DEAD_LOWER          ;;
      ENDIFF                           ;;
    ELSEF                              ;;
      IFF R_ALT_SHIFT                  ;;
      ANDF EITHER_SHIFT,NOT            ;;
	 SET_FLAG DEAD_THIRD           ;;
      ENDIFF                           ;;
    ENDIFF                             ;;
 ENDIFF                                ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:                            ;;
				       ;;
   IFF ACUTE,NOT                       ;;
      GOTO CEDILLA_PROC                ;;
      ENDIFF                           ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT ACUTE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	 IFF EITHER_SHIFT              ;;
	    IFF CAPS_STATE             ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF                      ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF                     ;;
	 ELSEF                         ;;
	    IFF CAPS_STATE             ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF                      ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF                     ;;
	 ENDIFF                        ;;
      ENDIFF                           ;;
				       ;;
INVALID_ACUTE:                         ;;
      PUT_ERROR_CHAR ACUTE_SPACE       ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CEDILLA ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CEDILLA_PROC:                          ;;
				       ;;
   IFF CEDILLA,NOT                     ;;
      GOTO DIARESIS_PROC               ;;
      ENDIFF                           ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT CEDILLA_SPACE           ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	 IFF EITHER_SHIFT              ;;
	    IFF CAPS_STATE             ;;
	       XLATT CEDILLA_LOWER     ;;
	    ELSEF                      ;;
	       XLATT CEDILLA_UPPER     ;;
	    ENDIFF                     ;;
	 ELSEF                         ;;
	    IFF CAPS_STATE             ;;
	       XLATT CEDILLA_UPPER     ;;
	    ELSEF                      ;;
	       XLATT CEDILLA_LOWER     ;;
	    ENDIFF                     ;;
	 ENDIFF                        ;;
      ENDIFF                           ;;
				       ;;
INVALID_CEDILLA:                       ;;
      PUT_ERROR_CHAR CEDILLA_LOWER     ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:                         ;;
				       ;;
   IFF DIARESIS,NOT                    ;;
      GOTO GRAVE_PROC                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT DIARESIS_SPACE          ;;  exist for 850 so beep for
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	 IFF EITHER_SHIFT              ;;
	    IFF CAPS_STATE             ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF                      ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF                     ;;
	 ELSEF                         ;;
	    IFF CAPS_STATE             ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF                      ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF                     ;;
	 ENDIFF                        ;;
      ENDIFF                           ;;
				       ;;
INVALID_DIARESIS:                      ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:                            ;;
				       ;;
   IFF GRAVE,NOT                       ;;
      GOTO TILDE_PROC                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT GRAVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_GRAVE:                         ;;
      PUT_ERROR_CHAR GRAVE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TILDE_PROC:                            ;;
				       ;;
   IFF TILDE,NOT                       ;;
      GOTO CIRCUMFLEX_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT TILDE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE              ;;
	      XLATT TILDE_UPPER        ;;
	   ELSEF                       ;;
	      XLATT TILDE_LOWER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
INVALID_TILDE:                         ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:                       ;;
				       ;;
   IFF CIRCUMFLEX,NOT                  ;;
      GOTO CARON_PROC                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF                       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF                       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_CIRCUMFLEX:                    ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CARON ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CARON_PROC:                            ;;
				       ;;
   IFF CARON,NOT                       ;;
      GOTO BREVE_PROC                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT CARON_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT CARON_LOWER        ;;
	   ELSEF                       ;;
	      XLATT CARON_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT CARON_LOWER        ;;
	   ELSEF                       ;;
	      XLATT CARON_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_CARON:                         ;;
      PUT_ERROR_CHAR CARON_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BREVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
BREVE_PROC:                            ;;
				       ;;
   IFF BREVE,NOT                       ;;
      GOTO OVERCIRCLE_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT BREVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT BREVE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT BREVE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT BREVE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT BREVE_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_BREVE:                         ;;
      PUT_ERROR_CHAR BREVE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OVERCIRCLE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
OVERCIRCLE_PROC:                            ;;
				       ;;
   IFF OVERCIRCLE,NOT                       ;;
      GOTO OGONEK_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT OVERCIRCLE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT OVERCIRCLE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OVERCIRCLE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT OVERCIRCLE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OVERCIRCLE_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_OVERCIRCLE:                         ;;
      PUT_ERROR_CHAR OVERCIRCLE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OGONEK ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
OGONEK_PROC:                            ;;
				       ;;
   IFF OGONEK,NOT                       ;;
      GOTO OVERDOT_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT OGONEK_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT OGONEK_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OGONEK_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT OGONEK_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OGONEK_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_OGONEK:                         ;;
      PUT_ERROR_CHAR OGONEK_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OVERDOT ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
OVERDOT_PROC:                            ;;
				       ;;
   IFF OVERDOT,NOT                       ;;
      GOTO DOUBLEACUTE_PROC             ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT OVERDOT_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT OVERDOT_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OVERDOT_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT OVERDOT_LOWER        ;;
	   ELSEF                       ;;
	      XLATT OVERDOT_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_OVERDOT:                         ;;
      PUT_ERROR_CHAR OVERDOT_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DOUBLEACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DOUBLEACUTE_PROC:                            ;;
				       ;;
   IFF DOUBLEACUTE,NOT                       ;;
      GOTO NON_DEAD                  ;;
      ENDIFF                           ;;
				       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
	 XLATT DOUBLEACUTE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
	IFF EITHER_SHIFT               ;;
	   IFF CAPS_STATE              ;;
	      XLATT DOUBLEACUTE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT DOUBLEACUTE_UPPER        ;;
	   ENDIFF                      ;;
	ELSEF                          ;;
	   IFF CAPS_STATE,NOT          ;;
	      XLATT DOUBLEACUTE_LOWER        ;;
	   ELSEF                       ;;
	      XLATT DOUBLEACUTE_UPPER        ;;
	   ENDIFF                      ;;
	ENDIFF                         ;;
      ENDIFF                           ;;
				       ;;
INVALID_DOUBLEACUTE:                         ;;
      PUT_ERROR_CHAR DOUBLEACUTE_SPACE       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;; ***BD - NON_DEAD THRU LOGIC_END IS UPDATED
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NON_DEAD:                              ;;
				       ;;
   IFKBD G_KB			       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
				       ;;
 IFF  EITHER_CTL,NOT                   ;; Lower and upper case.  Alphabetic
    IFF EITHER_ALT,NOT                 ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT                 ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT            ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF                       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE               ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF                        ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF                       ;;
      ELSEF                            ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE                ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF                       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE               ;;
	     XLATT ALPHA_UPPER         ;;
	  ELSEF                        ;;
	     XLATT ALPHA_LOWER         ;;
	  ENDIFF                       ;;
      ENDIFF                           ;; Third and Fourth shifts
    ELSEF                              ;; ctl off, alt on at this point
	 IFF R_ALT_SHIFT               ;; ALTGr
	 ANDF EITHER_SHIFT,NOT         ;;
	    XLATT THIRD_SHIFT          ;;
	 ENDIFF                        ;;
    ENDIFF                             ;;
 ENDIFF                                ;;
;**************************************;;
 IFF EITHER_SHIFT,NOT                  ;;
     IFF EITHER_CTL                    ;;
     ANDF ALT_SHIFT                    ;;
       IFF R_ALT_SHIFT,NOT             ;;
	 XLATT ALT_CASE                ;;
       ENDIFF                          ;;
     ENDIFF                            ;;
 ENDIFF                                ;;
;**************************************;;
      IFF EITHER_CTL,NOT               ;;
	 IFF ALT_SHIFT                 ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT          ;;
	    XLATT ALT_CASE             ;;
	 ENDIFF                        ;;
      ELSEF                            ;;
	 IFF EITHER_ALT,NOT            ;; CTRL - case
	    XLATT CTRL_CASE            ;;
	 ENDIFF                        ;;
      ENDIFF                           ;;
ENDIFF                                 ;;
				       ;;
 EXIT_STATE_LOGIC                      ;;
				       ;;
LOGIC_END:                             ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;**********************************************************************
;; HU Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; Some common Characters are included from 128 - 165 where appropriate.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC HU_COMMON_XLAT                 ;;
HU_COMMON_XLAT:                        ;;
				       ;;
   DW     COMMON_XLAT_END-$            ;; length of section
   DW     -1                           ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: low shift Dead_lower
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;  DW    COM_HU_LO_END-$               ;; length of state section
;  DB    DEAD_LOWER                    ;; State ID
;  DW    G_KB                          ;; Keyboard Type
;  DB    -1,-1                         ;; Buffer entry for error character
;                                      ;; Set Flag Table
;  DW    1                             ;; number of entries
;  DB    41                            ;;
;  FLAG  OGONEK                        ;;
				       ;;
;COM_HU_LO_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: low shift Dead_UPPER
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;  DW    COM_HU_UP_END-$               ;; length of state section
;  DB    DEAD_UPPER                    ;; State ID
;  DW    G_KB                          ;; Keyboard Type
;  DB    -1,-1                         ;; Buffer entry for error character
;                                      ;; Set Flag Table
;  DW    1                             ;; number of entries
;  DB    41                            ;;
;  FLAG  OVERDOT                       ;;
;                                      ;;
;COM_HU_UP_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: G
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_HU_TH_END-$               ;; length of state section
   DB    DEAD_THIRD                    ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 11			       ;; number of entries
;; DB    2                             ;; TILDE IS NOT AN ACCENT KEY
;; FLAG  TILDE                         ;;
   DB    3                             ;;
   FLAG  CARON                         ;;
   DB    4                             ;;
   FLAG  CIRCUMFLEX                    ;;
   DB    5                             ;;
   FLAG  BREVE                         ;;
   DB    6                             ;;
   FLAG  OVERCIRCLE                    ;;
   DB    7                             ;;
   FLAG  OGONEK                        ;;
   DB    8                             ;;
   FLAG  GRAVE                         ;;
   DB    9                             ;;
   FLAG  OVERDOT                       ;;
   DB    10                            ;;
   FLAG  ACUTE                         ;;
   DB    11                            ;;
   FLAG  DOUBLEACUTE                   ;;
   DB    12                            ;;
   FLAG  DIARESIS                      ;;
   DB	 13			       ;;
   FLAG  CEDILLA		       ;;
				       ;;
COM_HU_TH_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR NUMERIC PAD (DECIMAL SEPERATOR)
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Numeric Key Pad
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_PAD_K1_END-$              ;; length of state section
   DB    NUMERIC_PAD                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_PAD_K1_T1_END-$           ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    83,','                        ;; decimal seperator = ,
COM_PAD_K1_T1_END:                     ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_PAD_K1_END:                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Alt Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_ALT_K1_END-$              ;; length of state section
   DB    ALT_CASE                      ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_ALT_K1_T1_END-$           ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    3                             ;; number of entries
   DB    21,0,2CH                      ;;
   DB    44,0,15H                      ;;
   DB    53,0,82H                      ;;
COM_ALT_K1_T1_END:                     ;;
				       ;;
    DW    0                            ;; Size of xlat table - null table
				       ;;
COM_ALT_K1_END:                        ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CTRL_K2_END-$             ;; length of state section
   DB    CTRL_CASE                     ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_CTRL_K2_T1_END-$          ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    3                             ;; number of entries
   DB    21,01AH,2CH                   ;;
   DB    44,019H,15H                   ;;
   DB    53,01FH,0CH                   ;;
COM_CTRL_K2_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CTRL_K2_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AL_LO_K1_END-$            ;; length of state section
   DB    ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_AL_LO_K1_T1_END-$         ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    4                             ;; number of entries
   DB    11,"",0BH                    ;;
   DB    12,"",0CH                    ;;
   DB    21,"z",2CH                    ;;
   DB    44,"y",15H                    ;;
COM_AL_LO_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_AL_LO_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AL_UP_K1_END-$            ;; length of state section
   DB    ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_AL_UP_K1_T1_END-$         ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB	 4			       ;; number of entries
   DB    11,"",0BH                    ;;
   DB    12,"",0CH                    ;;
   DB    21,"Z",2CH                    ;;
   DB    44,"Y",15H                    ;;
COM_AL_UP_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_AL_UP_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_NA_LO_K1_END-$            ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_NA_LO_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    2                             ;; number of entries
   DB    41,"0"                        ;;
   DB    53,"-"                        ;; -
COM_NA_LO_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_NA_UP_K1_END-$            ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_NA_UP_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    12                            ;; number of entries
   DB     2,"'"                        ;;
   DB     3,'"'                        ;;
   DB     4,"+"                        ;;
   DB     5,"!"                        ;;
   DB     7,'/'                        ;;
   DB     8,'='                        ;;
   DB     9,'('                        ;;
   DB    10,')'                        ;;
   DB    41,15H                        ;;
   DB    51,'?'                        ;;
   DB    52,':'                        ;;
   DB    53,'_'                        ;;
COM_NA_UP_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Third Shift
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_THIRD_END-$               ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    G_KB                          ;; Keyboard Type FERRARI
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    COM_THIRD_T1_END-$            ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    17                            ;; number of entries
   DB     2,'~',02H                    ;;
   DB    16,'\',10H                    ;;
   DB    17,'|',11H                    ;;
   DB    26,'',1AH                    ;;
   DB    33,'[',21H                    ;;
   DB    34,']',22H                    ;;
   DB    39,'$',27H                    ;;
   DB    40,0E1H,28H                   ;; SHARP S
   DB    44,'>',2CH                    ;;
   DB    45,'#',2DH                    ;;
   DB    46,'&',28H                    ;;
   DB    47,'@',2FH                    ;;
   DB    48,'{',20H                    ;;
   DB    49,'}',21H                    ;;
   DB    51,';',33H                    ;;
   DB    53,'*',35H                    ;;
   DB    86,'<',56H                    ;;
COM_THIRD_T1_END:                      ;;
				       ;;
   DW    0                             ;; Last xlat table
COM_THIRD_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Caron Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CA_SP_END-$             ;; length of state section
   DB    CARON_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_CA_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F3H                       ;; Caron Space
COM_CA_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CA_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COM
;; STATE: Breve Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_BR_SP_END-$             ;; length of state section
   DB    BREVE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_BR_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F4H                       ;; BREVE SPACE
COM_BR_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_BR_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Ogonek Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_OG_SP_END-$             ;; length of state section
   DB    OGONEK_SPACE                  ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_OG_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F2H                       ;; OGONEK SPACE
COM_OG_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_OG_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Double Acute Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_DC_SP_END-$             ;; length of state section
   DB    DOUBLEACUTE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_DC_SP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    57,0F1H                       ;; DOUBLEACUTE SPACE
COM_DC_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_DC_SP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CI_LO_END-$               ;; length of state section
   DB    CIRCUMFLEX_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
				       ;;
   DW    COM_CI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    23,''                        ;;  "    "  ,  "   - i
   DB    24,''                        ;; scan code,ASCII - o
   DB    30,''                        ;; scan code,ASCII - a
COM_CI_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;;
				       ;;
COM_CI_LO_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CI_SP_END-$               ;; length of state section
   DB    CIRCUMFLEX_SPACE              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
				       ;;
   DW    COM_CI_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,94                         ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Overcircle Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_OC_SP_END-$               ;; length of state section
   DB    OVERCIRCLE_SPACE              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_OC_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0F8H                       ;; STANDALONE OVERCIRCLE
COM_OC_SP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_OC_SP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_GR_SP_END-$               ;; length of state section
   DB    GRAVE_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    96,0                          ;; error character = standalone accent
				       ;;
   DW    COM_GR_SP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,96                         ;; STANDALONE GRAVE
COM_GR_SP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_GR_SP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Overdot
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
    DW    COM_OD_SP_END-$               ;; length of state section
    DB    OVERDOT_SPACE                 ;; State ID
    DW    G_KB                          ;; Keyboard Type
    DB    0FAH,0                        ;; error character = standalone accent
					;;
    DW    COM_OD_SP_T1_END-$            ;; Size of xlat table
    DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
    DB    1                             ;; number of scans
    DB    57,0FAH                       ;; STANDALONE OVERDOT
COM_OD_SP_T1_END:                       ;;
					;;
    DW    0                             ;;
					;;
COM_OD_SP_END:                          ;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AC_LO_END-$               ;; length of state section
   DB    ACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    COM_AC_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    5                             ;; number of entries
   DB    18,082H                       ;;    e acute
   DB    22,0A3H                       ;;    u acute
   DB    23,0A1H                       ;;    i acute
   DB    24,0A2H                       ;;    o acute
   DB    30,0A0H                       ;;    a acute
COM_AC_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_AC_LO_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AC_UP_END-$               ;; length of state section
   DB    ACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    COM_AC_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    18,090H                       ;;    E acute
COM_AC_UP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_AC_UP_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_AC_SP_END-$             ;; length of state section
   DB    ACUTE_SPACE                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    027H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_AC_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,027H                        ;; error character = standalone accent
COM_AC_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
COM_AC_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CE_LO_END-$               ;; length of state section
   DB    CEDILLA_LOWER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_CE_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    46,''                        ;; scan code,ASCII - 
COM_CE_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CE_LO_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CE_UP_END-$               ;; length of state section
   DB    CEDILLA_UPPER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_CE_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    46,''                        ;;     CEDILLA
COM_CE_UP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CE_UP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Cedilla Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_CE_SP_END-$             ;; length of state section
   DB    CEDILLA_SPACE                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    COM_CE_SP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of entries
   DB    57,0F7H                       ;; CEDILLA SPACE
COM_CE_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_CE_SP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_DI_LO_END-$               ;; length of state section
   DB    DIARESIS_LOWER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
				       ;;
   DW    COM_DI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    4                             ;; number of scans
   DB    18,''                        ;; scan code,ASCII - e
   DB    22,''                        ;; scan code,ASCII - u
   DB    24,''                        ;; scan code,ASCII - o
   DB    30,''                        ;; scan code,ASCII - a
COM_DI_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_DI_LO_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_DI_UP_END-$               ;; length of state section
   DB    DIARESIS_UPPER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
				       ;;
   DW    COM_DI_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    22,''                        ;;    U Diaeresis
   DB    24,''                        ;;    O Diaeresis
   DB    30,''                        ;;    A Diaeresis
COM_DI_UP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
COM_DI_UP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    COM_DI_SP_END-$             ;; length of state section
   DB    DIARESIS_SPACE                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
				       ;;
   DW    COM_DI_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,249                        ;; error character = standalone accent
COM_DI_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
COM_DI_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; Last State
COMMON_XLAT_END:                       ;;  END OF COMMON SECTION
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CODE PAGE 850 MULTILINGUAL 2  SPECIFIC TRANSLATION
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC HU_850_XLAT                    ;;
HU_850_XLAT:                           ;;
				       ;;
    DW   CP850_XLAT_END-$              ;;
    DW   850                           ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_NA_LO_K1_END-$            ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    CP850_NA_LO_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB     5,-1                         ;; CURRENCY SYMBOL
CP850_NA_LO_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_NA_LO_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_NA_UP_K1_END-$            ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    CP850_NA_UP_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB     5,-1                         ;; CURRENCY SYMBOL
CP850_NA_UP_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_NA_UP_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_AL_LO_END-$             ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; error character = standalone accent
				       ;;
   DW    CP850_AL_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    27,-1                         ;; BLOT OUT CHAR UNDER 850
CP850_AL_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_AL_LO_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_AL_UP_END-$             ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; error character = standalone accent
				       ;;
   DW    CP850_AL_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    27,-1                         ;; BLOT OUT CHAR UNDER 850
CP850_AL_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_AL_UP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_CI_LO_END-$               ;; length of state section
   DB    CIRCUMFLEX_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    94,0                          ;; error character = standalone accent
				       ;;
   DW    CP850_CI_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,88H                        ;;  e CIRCUMFLEX
   DB    23,8CH                        ;;  i CIRCUMFLEX
CP850_CI_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;;
				       ;;
CP850_CI_LO_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Overcircle Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_OC_LO_END-$               ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    CP850_OC_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,86H                        ;; a OVERCIRCLE
CP850_OC_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_OC_LO_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Overcircle Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_OC_UP_END-$               ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    CP850_OC_UP_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,8FH                        ;; A OVERCIRCLE
CP850_OC_UP_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_OC_UP_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_GR_LO_END-$               ;; length of state section
   DB    GRAVE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    060H,0                        ;; error character = standalone accent
				       ;;
   DW    CP850_GR_LO_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    5                             ;; number of scans
   DB    18,8AH                        ;; e GRAVE
   DB    22,97H                        ;; u GRAVE
   DB    23,8DH                        ;; i GRAVE
   DB    24,95H                        ;; o GRAVE
   DB    30,85H                        ;; a GRAVE
CP850_GR_LO_T1_END:                      ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_GR_LO_END:                         ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_DI_LO_END-$             ;; length of state section
   DB    DIARESIS_LOWER                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    0FEH,0                         ;; error character = standalone accent
				       ;;
   DW    CP850_DI_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    16,8BH                        ;; i DIARESIS
CP850_DI_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
CP850_DI_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_DI_SP_END-$             ;; length of state section
   DB    DIARESIS_SPACE                ;; State ID
   DW    G_KB                   ;; Keyboard Type
   DB    0FEH,0                        ;; error character = standalone accent
				       ;;
   DW    CP850_DI_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0FEH,0                     ;; error character = standalone accent
CP850_DI_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
CP850_DI_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP850_OG_SP_END-$             ;; length of state section
   DB    OGONEK_SPACE                  ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0FEH,0                        ;; error character = standalone accent
				       ;;
   DW    CP850_OG_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0FEH                       ;; OGONEK SPACE
CP850_OG_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP850_OG_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; LAST STATE
				       ;;
CP850_XLAT_END:                        ;; END OF CP850 SECTION
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; CODE PAGE 852 MULTILINGUAL 2  SPECIFIC TRANSLATION
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC HU_852_XLAT                    ;;
HU_852_XLAT:                           ;;
				       ;;
    DW     CP852_XLAT_END-$            ;;
    DW     852                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_AL_LO_END-$           ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    CP852_AL_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    7                             ;; number of entries
   DB    13,0A2H                       ;; o ACUTE
   DB    26,08BH                       ;; o DOUBLE ACUTE
   DB    27,0A3H                       ;; u ACUTE
   DB    39,082H                       ;; e ACUTE
   DB    40,0A0H                       ;; a ACUTE
   DB    43,0FBH                       ;; u DOUBLE ACUTE
   DB    86,0A1H                       ;; i ACUTE
CP852_AL_LO_T1_END:                  ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_AL_LO_END:                     ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_AL_UP_END-$           ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    CP852_AL_UP_T1_END-$        ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    7                             ;; number of entries
   DB	 13,0E0H		       ;; O ACUTE
   DB    26,08AH                       ;; O DOUBLE ACUTE
   DB    27,0E9H                       ;; U ACUTE
   DB    39,090H                       ;; E ACUTE
   DB    40,0B5H                       ;; A ACUTE
   DB    43,0EBH                       ;; U DOUBLE ACUTE
   DB    86,214                        ;; I ACUTE
CP852_AL_UP_T1_END:                  ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_AL_UP_END:                     ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Third Shift
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_THIRD_END-$               ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    G_KB                          ;; Keyboard Type FERRARI
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    CP852_THIRD_T1_END-$            ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    6                             ;; number of entries
   DB    27,09EH,1BH                   ;;
   DB    31,0D0H,1FH                   ;; d STROKE
   DB    32,0D1H,20H                   ;; D STROKE
   DB    37,088H,25H                   ;; l STROKE
   DB    38,09DH,26H                   ;; L STROKE
   DB    43,0CFH,2BH                   ;; CURRENCY SYMBOL
CP852_THIRD_T1_END:                      ;;
				       ;;
   DW    0                             ;; Last xlat table
CP852_THIRD_END:                         ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP852
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_NA_LO_K1_END-$            ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    CP852_NA_LO_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    0                             ;; number of entries
CP852_NA_LO_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_NA_LO_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP852
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_NA_UP_K1_END-$            ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
				       ;;
   DW    CP852_NA_UP_K1_T1_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    0                             ;; number of entries
CP852_NA_UP_K1_T1_END:                   ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_NA_UP_K1_END:                      ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CA_LO_END-$             ;; length of state section
   DB    CARON_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CA_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    9                             ;; number of scans
   DB    18,0D8H                       ;; e CARON
   DB    19,0FDH                       ;; r CARON
   DB    20,09CH                       ;; t CARON
   DB    21,0A7H                       ;; z CARON
   DB    31,0E7H                       ;; s CARON
   DB    32,0D4H                       ;; d CARON
   DB    38,096H                       ;; l CARON
   DB    46,09FH                       ;; c CARON
   DB    49,0E5H                       ;; n CARON
CP852_CA_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CA_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CA_UP_END-$             ;; length of state section
   DB    CARON_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F3H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CA_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    9                             ;; number of scans
   DB    18,0B7H                       ;; E CARON
   DB    19,0FCH                       ;; R CARON
   DB    20,09BH                       ;; T CARON
   DB    21,0A6H                       ;; Z CARON
   DB    31,0E6H                       ;; S CARON
   DB    32,0D2H                       ;; D CARON
   DB    38,095H                       ;; L CARON
   DB    46,0ACH                       ;; C CARON
   DB    49,0D5H                       ;; N CARON
CP852_CA_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CA_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Caron Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_CA_SP_END-$             ;; length of state section
;;   DB    CARON_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F3H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_CA_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F3H                       ;; e CARON
;;CP852_CA_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_CA_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CI_UP_END-$             ;; length of state section
   DB    CIRCUMFLEX_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    05EH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CI_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    3                             ;; number of scans
   DB    23,0D7H                       ;; I CIRCUMFLEX
   DB    24,0E2H                       ;; O CIRCUMFLEX
   DB    30,0B6H                       ;; A CIRCUMFLEX
CP852_CI_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CI_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_BR_LO_END-$             ;; length of state section
   DB    BREVE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_BR_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,0C7H                       ;; a BREVE
CP852_BR_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_BR_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_BR_UP_END-$             ;; length of state section
   DB    BREVE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F4H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_BR_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    30,0C6H                       ;; A BREVE
CP852_BR_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_BR_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Breve Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_BR_SP_END-$             ;; length of state section
;;   DB    BREVE_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F4H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_BR_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F4H                       ;; BREVE SPACE
;;CP852_BR_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_BR_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overcirle Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OC_LO_END-$             ;; length of state section
   DB    OVERCIRCLE_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OC_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    22,085H                       ;; u OVERCIRCLE
CP852_OC_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OC_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overcircle Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OC_UP_END-$             ;; length of state section
   DB    OVERCIRCLE_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F8H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OC_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    22,0DEH                       ;; O OVERCIRCLE
CP852_OC_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OC_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OG_LO_END-$             ;; length of state section
   DB    OGONEK_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OG_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,0A9H                       ;; e OGONEK
   DB    30,0A5H                       ;; a OGONEK
CP852_OG_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OG_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OG_UP_END-$             ;; length of state section
   DB    OGONEK_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F2H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OG_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of scans
   DB    18,0A8H                       ;; E OGONEK
   DB    30,0A4H                       ;; A OGONEK
CP852_OG_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OG_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Ogonek Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_OG_SP_END-$             ;; length of state section
;;   DB    OGONEK_SPACE                  ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F2H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_OG_SP_T1_END-$          ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of scans
;;   DB    57,0F2H                       ;; OGONEK SPACE
;;CP852_OG_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_OG_SP_END:                       ;; length of state section
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overdot Lower
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OD_LO_END-$             ;; length of state section
   DB    OVERDOT_LOWER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0FAH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OD_LO_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    21,0BEH                       ;; z OVERDOT
CP852_OD_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OD_LO_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Overdot Upper
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_OD_UP_END-$             ;; length of state section
   DB    OVERDOT_UPPER              ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0FAH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_OD_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    21,0BDH                       ;; Z OVERDOT
CP852_OD_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_OD_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_AC_LO_END-$             ;; length of state section
   DB    ACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_AC_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    7                             ;; number of entries
   DB    19,0EAH                       ;; r ACUTE
   DB    21,0ABH                       ;; z ACUTE
   DB    31,098H                       ;; s ACUTE
   DB    38,092H                       ;; l ACUTE
   DB    44,0ECH                       ;; y ACUTE
   DB    46,086H                       ;; c ACUTE
   DB    49,0E4H                       ;; n ACUTE
CP852_AC_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_AC_LO_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_AC_UP_END-$             ;; length of state section
   DB    ACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_AC_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    11                            ;; number of entries
   DB    19,0E8H                       ;; R ACUTE
   DB    21,08DH                       ;; Z ACUTE
   DB    22,0E9H                       ;; U ACUTE
   DB    23,0D6H                       ;; I ACUTE
   DB    24,0E0H                       ;; O ACUTE
   DB    30,0B5H                       ;; A ACUTE
   DB    31,097H                       ;; S ACUTE
   DB    38,091H                       ;; L ACUTE
   DB    44,0EDH                       ;; Y ACUTE
   DB    46,08FH                       ;; C ACUTE
   DB    49,0E3H                       ;; N ACUTE
CP852_AC_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_AC_UP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: P12_KB+G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_AC_SP_END-$             ;; length of state section
   DB    ACUTE_SPACE                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0EFH,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_AC_SP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    57,0EFH                       ;; error character = standalone accent
CP852_AC_SP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
CP852_AC_SP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_DC_LO_END-$             ;; length of state section
   DB    DOUBLEACUTE_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_DC_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    22,0FBH                       ;; u DOUBLEACUTE
   DB    24,08BH                       ;; o DOUBLEACUTE
CP852_DC_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_DC_LO_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_DC_UP_END-$             ;; length of state section
   DB    DOUBLEACUTE_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F1H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_DC_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    22,0EBH                       ;; U DOUBLEACUTE
   DB    24,08AH                       ;; O DOUBLEACUTE
CP852_DC_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_DC_UP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Double Acute Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_DC_SP_END-$             ;; length of state section
;;   DB    DOUBLEACUTE_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F1H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_DC_SP_T1_END-$        ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of entries
;;   DB    57,0F1H                       ;; DOUBLEACUTE SPACE
;;CP852_DC_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_DC_SP_END:                       ;;
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_DI_UP_END-$             ;; length of state section
   DB    DIARESIS_UPPER                ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    249,0                         ;; error character = standalone accent
				       ;;
   DW    CP852_DI_UP_T1_END-$          ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    1                             ;; number of scans
   DB    18,0D3H                       ;;    E Diaeresis
CP852_DI_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_DI_UP_END:                       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Lower Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CE_LO_END-$             ;; length of state section
   DB    CEDILLA_LOWER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CE_LO_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    20,0EEH                       ;; t CEDILLA
   DB    31,0ADH                       ;; s CEDILLA
CP852_CE_LO_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CE_LO_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Upper Case
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    CP852_CE_UP_END-$             ;; length of state section
   DB    CEDILLA_UPPER                   ;; State ID
   DW    G_KB                          ;; Keyboard Type
   DB    0F7H,0                        ;; error character = standalone accent
				       ;;
   DW    CP852_CE_UP_T1_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB    2                             ;; number of entries
   DB    20,0DDH                       ;; T CEDILLA
   DB    31,0B8H                       ;; S CEDILLA
CP852_CE_UP_T1_END:                    ;;
				       ;;
   DW    0                             ;; Size of xlat table - null table
				       ;;
CP852_CE_UP_END:                       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 852
;; STATE: Cedilla Space
;; KEYBOARD TYPES: G_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                       ;;
;;   DW    CP852_CE_SP_END-$             ;; length of state section
;;   DB    CEDILLA_SPACE                   ;; State ID
;;   DW    G_KB                          ;; Keyboard Type
;;   DB    0F7H,0                        ;; error character = standalone accent
;;                                       ;;
;;   DW    CP852_CE_SP_T1_END-$        ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;;   DB    1                             ;; number of entries
;;   DB    57,0F7H                       ;; CEDILLA SPACE
;;CP852_CE_SP_T1_END:                    ;;
;;                                       ;;
;;   DW    0                             ;; Size of xlat table - null table
;;                                       ;;
;;CP852_CE_SP_END:                       ;;
;;                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW    0                             ;; LAST STATE
				       ;;
CP852_XLAT_END:                        ;;  END OF CP852 SECTION
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE     ENDS                          ;;  END OF PROGRAM
	 END                           ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kdfit.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;; LATEST CHANGE ALT & CTL


	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Spanish.
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC IT_LOGIC 	       ;;
	PUBLIC IT_437_XLAT	       ;;
	PUBLIC IT_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; IT State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
IT_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  0			       ;; special features
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
      IFF EITHER_SHIFT		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_SPACE    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
NON_DEAD:			       ;;
				       ;;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
;;***BD ADDED FOR ALT, CTRL CASES      ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF  ALT_SHIFT 	       ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
;;***BD END OF ADDITION
				       ;;
   IFF	EITHER_ALT,NOT		       ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  ENDIFF		       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_SHIFT,NOT	       ;;
	  IFKBD XT_KB+AT_KB	 ;;
	      IFF  EITHER_CTL	       ;;
	      ANDF ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ELSEF 		       ;;
	      IFF EITHER_CTL,NOT       ;;
	      ANDF R_ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	   ENDIFF		       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
				       ;;
   EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;***************************************
;; IT Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC IT_COMMON_XLAT		       ;;
IT_COMMON_XLAT: 		       ;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_ALT_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 3			       ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,225,0		       ;; TEST ENTRY
   DB	 53,0,82H		       ;; valid alt -
   DB	 12,-1,-1		       ;; invalid alt -
   DB	 13,-1,-1		       ;; invalid alt =
COM_ALT_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_ALT_K1_END: 		       ;;
				       ;;
;;******************************
;;***BD - ADDED FOR CTRL CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G_KB+P12_KB+AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB	       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 2			       ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,226,0		       ;; TEST ENTRY
   DB	 43,-1,-1		       ;; invalid slash
   DB	 41,28,41		       ;; valid slash
COM_CTRL_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		     ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 10			       ;; number of entries
   DB	 41,"\"                        ;; \
   DB	 12,"'"                        ;; '
   DB	 13,141 		       ;; grave i - ;
   DB	 27,'+'                        ;; +
   DB	 86,'<'                        ;; <
   DB	 53,'-'                        ;; -
   DB	 39,149 		       ;; grave o - 
   DB	 40,133 		       ;; grave a - ;
   DB	 43,151 		       ;; grave u - ;
   DB	 26,138 		       ;; grave e - ;
COM_NA_LO_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K2_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	 41,"<"                        ;; <
   DB	 12,"'"                        ;; '
   DB	 13,141 		       ;; grave i - ;
   DB	 27,'+'                        ;; +
   DB	 53,'-'                        ;; -
   DB	 39,149 		       ;; grave o - 
   DB	 40,133 		       ;; grave a - ;
   DB	 43,151 		       ;; grave u - ;
   DB	 26,138 		       ;; grave e - ;
COM_NA_LO_K2_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K2_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES:  XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K3_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	 12,"'"                        ;; '
   DB	 13,141 		       ;; grave i - ;
   DB	 27,'+'                        ;; +
   DB	 43,'<'                        ;; <
   DB	 53,'-'                        ;; -
   DB	 39,149 		       ;; grave o - 
   DB	 40,133 		       ;; grave a - ;
   DB	 41,151 		       ;; grave u - ;
   DB	 26,138 		       ;; grave e - ;
COM_NA_LO_K3_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K3_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		     ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 18			       ;; number of entries
   DB	  41,07CH		       ;; Solid vertical bar - |
   DB	  3,'"'                        ;;
   DB	  4,''                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 13,'^'                        ;;
   DB	 26,130 		       ;; acute e - ;
   DB	 39,135 		       ;; c - cedilla - 
   DB	 27,'*'                        ;;
   DB	 40,0F8H		       ;;  - degree symbol
   DB	 86,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
				       ;;
COM_NA_UP_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K2_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 18			       ;; number of entries
   DB	  41,'>'                       ;; >
   DB	  3,'"'                        ;;
   DB	  4,''                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 13,'^'                        ;;
   DB	 26,130 		       ;; acute e - ;
   DB	 39,'@'                        ;; @ AT sign replaces c - cedilla - 
   DB	 27,'*'                        ;;
   DB	 40,'#'                        ;; # sign replaces  - degree symbol
   DB	 86,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
				       ;;
COM_NA_UP_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K3_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 17			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  4,''                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 13,'^'                        ;;
   DB	 26,130 		       ;; acute e - ;
   DB	 39,'@'                        ;; @ AT sign replaces c - cedilla - 
   DB	 27,'*'                        ;;
   DB	 40,'#'                        ;; # sign replaces  - degree symbol
   DB	 43,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
				       ;;
COM_NA_UP_K3_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K3_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 39,'@'                        ;;
   DB	 40,'#'                        ;;
COM_THIRD_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K2_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K2_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of entries
   DB	 41,'\'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
COM_THIRD_K2_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K2_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES:  XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K3_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K3_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of entries
   DB	 43,'\'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
COM_THIRD_K3_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K3_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; IT Specific Translate Section for 437
;; 437 IS COMPLETELY COVERED BY THE COMMON TABLE.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC IT_437_XLAT		       ;;
IT_437_XLAT:			       ;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Upper case
;; KEYBOARD TYPES: G_KB+P12+AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
     DW    CP437_NA_UP_K1_END-$ 	 ;; length of state section
     DB    NON_ALPHA_UPPER		 ;; State ID
     DW    G_KB+P12_KB+AT_KB		 ;; Keyboard Type
     DB    -1,-1			 ;; error character = standalone accent
					 ;;
     DW    CP437_NA_UP_T1_K1_END-$	 ;; Size of xlat table
     DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
     DB    1				 ;; number of scans
     DB    43,015H			 ;; Section symbol - 
  CP437_NA_UP_T1_K1_END:		 ;;
					 ;;
     DW    0				 ;; Size of xlat table - null table
					 ;;
  CP437_NA_UP_K1_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Upper case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
     DW    CP437_NA_UP_K2_END-$ 	 ;; length of state section
     DB    NON_ALPHA_UPPER		 ;; State ID
     DW    XT_KB			 ;; Keyboard Type
     DB    -1,-1			 ;; error character = standalone accent
					 ;;
     DW    CP437_NA_UP_T1_K2_END-$	 ;; Size of xlat table
     DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
     DB    1				 ;; number of scans
     DB    41,015H			 ;; Section symbol - 
  CP437_NA_UP_T1_K2_END:		 ;;
					 ;;
     DW    0				 ;; Size of xlat table - null table
					 ;;
  CP437_NA_UP_K2_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; IT Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC IT_850_XLAT		       ;;
IT_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper case
;; KEYBOARD TYPES: G_KB+P12+AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
     DW    CP850_NA_UP_K1_END-$ 	 ;; length of state section
     DB    NON_ALPHA_UPPER		 ;; State ID
     DW    G_KB+P12_KB+AT_KB		 ;; Keyboard Type
     DB    -1,-1			 ;; error character = standalone accent
					 ;;
     DW    CP850_NA_UP_T1_K1_END-$	 ;; Size of xlat table
     DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
     DB    1				 ;; number of scans
     DB    43,0F5H			 ;; Section symbol - 
  CP850_NA_UP_T1_K1_END:		 ;;
					 ;;
     DW    0				 ;; Size of xlat table - null table
					 ;;
  CP850_NA_UP_K1_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper case
;; KEYBOARD TYPES: XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
     DW    CP850_NA_UP_K2_END-$ 	 ;; length of state section
     DB    NON_ALPHA_UPPER		 ;; State ID
     DW    XT_KB			 ;; Keyboard Type
     DB    -1,-1			 ;; error character = standalone accent
					 ;;
     DW    CP850_NA_UP_T1_K2_END-$	 ;; Size of xlat table
     DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
     DB    1				 ;; number of scans
     DB    41,0F5H			 ;; Section symbol - 
  CP850_NA_UP_T1_K2_END:		 ;;
					 ;;
     DW    0				 ;; Size of xlat table - null table
					 ;;
  CP850_NA_UP_K2_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kdfge.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;; LATEST CHANGE ALT & CTL "Z & Y", "-" symbol  (AT)

;; Eliminated zero scan tag from alpha upper CP section
;; SECTION SYMBOL
;; SCAN CODE OUTPUT CHANGES MADE 12/18/86
;; **************** CNS ************************
	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Spanish.
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC GE_LOGIC 	       ;;
	PUBLIC GE_437_XLAT	       ;;
	PUBLIC GE_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; GE State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
GE_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  TYPEWRITER_CAPS_LK	       ;; special features (shift lock state)
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
    IFKBD G_KB+P12_KB		       ;; FUNCTIONS AS A SHIFT LOCK
     IFF CAPS_STATE		       ;;
     ANDF EITHER_SHIFT		       ;;
	 SET_FLAG DEAD_LOWER		;;
     ELSEF
	IFF CAPS_STATE			 ;;
	  SET_FLAG DEAD_UPPER	       ;;
	ELSEF
	 IFF EITHER_SHIFT		;;
	  SET_FLAG DEAD_UPPER	       ;;
	 ELSEF
	  SET_FLAG DEAD_LOWER	       ;; NORMAL STATE LC
	 ENDIFF 		      ;; SHIFT OR NORMAL CHECK END
	ENDIFF			      ;; CAPS OR SHIFT CHECK END
     ENDIFF			      ;; BOTH SHIFT LOCK AND CAPS END
    ELSEF			      ;;
     IFF CAPS_STATE			;; THIS MEANS IT IS A at OR xt
     ANDF EITHER_SHIFT
	 SET_FLAG DEAD_UPPER
     ELSEF
	IFF CAPS_STATE			 ;;
	  SET_FLAG DEAD_LOWER	       ;;
	ELSEF
	 IFF EITHER_SHIFT		;;
	  SET_FLAG DEAD_UPPER	       ;;
	 ELSEF
	  SET_FLAG DEAD_LOWER	       ;; NORMAL STATE LC
	 ENDIFF 		       ;; SHIFT OR NORMAL CHECK END
	ENDIFF			       ;; CAPS OR SHIFT CHECK END
      ENDIFF			       ;; BOTH SHIFT LOCK AND CAPS END ;;
    ENDIFF			       ;; IS IT ENHANCED OR NOT END
   ENDIFF			       ;; NO CONTROL OR ALT END
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_SPACE    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
NON_DEAD:			       ;;
				       ;;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
;;***BD ADDED FOR ALT, CTRL CASES      ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF  ALT_SHIFT 	       ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
;;***BD END OF ADDITION
				       ;;
   IFF	EITHER_ALT,NOT		       ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
;	  XLATT NON_ALPHA_UPPER        ;;  add in keyboard logic
	 IFKBD G_KB+P12_KB		 ;;  SHIFT STATE ONLY FOR P12 & G
	  IFF CAPS_STATE	       ;;  for AT and XT
	      XLATT ALPHA_LOWER        ;;
	      XLATT NON_ALPHA_LOWER    ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;THIS MEANS normal SHIFT STATE
	   XLATT NON_ALPHA_UPPER	;;FOR G AND P12
	  ENDIFF		       ;;
	 ELSEF
	  IFF CAPS_STATE	       ;;  for AT and XT
	      XLATT ALPHA_LOWER        ;;  shift state & caps
	  XLATT NON_ALPHA_UPPER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;  shift state & no caps
	      XLATT NON_ALPHA_UPPER	   ;;
	  ENDIFF		       ;;
	 ENDIFF
      ELSEF			       ;; SHIFT STATE DOES NOT EXIST
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
;;	  XLATT NON_ALPHA_LOWER        ;;
	 IFKBD G_KB+P12_KB	       ;; G & p12 NO shift state
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	     XLATT NON_ALPHA_UPPER	  ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	     XLATT NON_ALPHA_LOWER	  ;;
	  ENDIFF		       ;;
	 ELSEF			       ;;AT & XT WITH NO SHIFT
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	     XLATT NON_ALPHA_LOWER	  ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	     XLATT NON_ALPHA_LOWER	  ;;
	  ENDIFF		       ;;
	 ENDIFF
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_SHIFT,NOT	       ;;
	  IFKBD XT_KB+AT_KB	 ;;
	      IFF  EITHER_CTL	       ;;
	      ANDF ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ELSEF 		       ;;
	      IFF EITHER_CTL,NOT       ;;
	      ANDF R_ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	   ENDIFF		       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
				       ;;
   EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; GE Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC GE_COMMON_XLAT		       ;;
GE_COMMON_XLAT: 		       ;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_LO_END-$	       ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 2			       ;; number of entries
   DB	 13			       ;; scan code
   FLAG  ACUTE			       ;; flag bit to set
   DB	 41
   FLAG  CIRCUMFLEX
				       ;;
				       ;;
COM_DK_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_UP_END-$	       ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 13			       ;; scan code
   FLAG  GRAVE			       ;; flag bit to set
COM_DK_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_ALT_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 2			       ;; 5 number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,225,0		       ;; TEST ENTRY - switch  two keys
;  DB	 12,-1,-1		       ;; invalid key U.S. -
;  DB	 13,-1,-1		       ;; invalid key U.S. =
   DB	 21,0,44		       ;; alt z function
   DB	 44,0,21		       ;; alt y function
;  DB	 53,0,82H		       ;; alt - (minus sign)
COM_ALT_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_ALT_K1_END: 		       ;;
				       ;;
;;******************************
;;***BD - ADDED FOR CTRL CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 5			       ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,226,0		       ;; TEST ENTRY
   DB	 43,-1,-1		       ;; no backslash
   DB	 53,31,53		       ;; ctl + - or _
   DB	 21,1AH,21		       ;; ctl z function
   DB	 44,19h,44		       ;; ctl y function
   DB	 12,28,12		       ;;  \ position
COM_CTRL_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K2_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K2_T2_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 6			       ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,226,0		       ;; TEST ENTRY
   DB	 12,-1,-1		       ;; invalid key U.S. -
   DB	 43,-1,-1		       ;; no backslash
   DB	 53,31,53		       ;; ctl + - or _
   DB	 21,1AH,21		       ;; ctl z function
   DB	 44,19h,44		       ;; ctl y function
   DB	 41,28,41		       ;;  \ position
COM_CTRL_K2_T2_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K2_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K3_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 XT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K3_T3_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 6			       ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,226,0		       ;; TEST ENTRY
   DB	 43,-1,-1		       ;; no backslash
   DB	 12,-1,-1		       ;; invalid key U.S. -
   DB	 53,31,53		       ;; ctl + - or _
   DB	 21,1AH,21		       ;; ctl z function
   DB	 44,19h,44		       ;; ctl y function
   DB	 43,28,43		       ;;  \ position
COM_CTRL_K3_T3_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K3_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_LO_END-$	       ;; length of state section
   DB	 ALPHA_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 26,081h		       ;; diaresis - 
   DB	 39,094h		       ;; diaresis - 
   DB	 40,084h		       ;; diaresis - 
   DB	 44,'y'                        ;;
   DB	 21,'z'                        ;;                          ;;
COM_AL_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_UP_END-$	       ;; length of state section
   DB	 ALPHA_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 26,09AH		       ;; Diaresis - 
   DB	 39,099H		       ;; Diaresis - 
   DB	 40,08EH		       ;; Diaresis - 
   DB	 44,'Y'                        ;;
   DB	 21,'Z'                        ;;
COM_AL_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_UP_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;******************************
;;***BD - ADDED FOR NUMERIC PAD (DECIMAL SEPERATOR)
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Numeric Key Pad	       ;;**********CNS******************
;; KEYBOARD TYPES: G_KB 	       ;;change does not apply to P12
;; TABLE TYPE: Translate	       ;;P12 Key #54 has a comma available
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_PAD_K1_END-$	       ;; length of state section
   DB	 NUMERIC_PAD		       ;; State ID
   DW	 G_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_PAD_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 83,44			       ;; decimal seperator = ,
COM_PAD_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_PAD_K1_END: 		       ;;
				       ;;
;;******************************
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K1_T1_END-$	      ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 18				;; number of entries
   DB	 41,'^'                        ;;
   DB	 2,'1'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 3,'2'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 4,'3'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 5,'4'                        ;;
   DB	 6,'5'                        ;;
   DB	 7,'6'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 8,'7'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 9,'8'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 10,'9'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 11,'0'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 12,0E1H		       ;; 
   DB	 27,'+'                        ;;
   DB	 43,'#'                        ;; pound sign
   DB	 86,'<'                        ;;
   DB	 51,','                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 52,'.'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 53,'-'                        ;;
COM_NA_LO_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K2_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 17			       ;; number of entries
   DB	 41,'<'                        ;; different than enhanced
   DB	 2,'1'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 3,'2'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 4,'3'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 5,'4'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 6,'5'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 7,'6'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 8,'7'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 9,'8'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0E1H		       ;; 
   DB	 27,'+'                        ;;
   DB	 43,'#'                        ;; pound sign
   DB	 51,','                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 52,'.'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 53,'-'                        ;;
COM_NA_LO_K2_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K2_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K3_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 17			       ;; number of entries
   DB	 2,'1'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 3,'2'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 4,'3'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 5,'4'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 6,'5'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 7,'6'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 8,'7'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 9,'8'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0E1H		       ;; 
   DB	 27,'+'                        ;;
   DB	 41,'#'                        ;; pound sign
   DB	 43,'<'                        ;;
   DB	 51,','                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 52,'.'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 53,'-'                        ;;
COM_NA_LO_K3_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K3_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 17			       ;; number of entries
   DB	 41,0F8H		       ;;
   DB	 3,'"'                        ;;
   DB	 2,'!'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 5,'$'                        ;;
   DB	 6,'%'                        ;;
   DB	 7,'&'                        ;;
   DB	 8,'/'                        ;;
   DB	 9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 27,'*'                        ;;
   DB	 43,"'"                        ;;
   DB	 86,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;

COM_NA_UP_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			      ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K2_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 16			      ;; number of entries
   DB	 41,'>'                        ;;
   DB	  3,'"'                        ;;
   DB	 2,'!'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 5,'$'                        ;;
   DB	 6,'%'                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 27,'*'                        ;;
   DB	 43,"^"                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;

COM_NA_UP_K2_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB			;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K3_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 16			      ;; number of entries
   DB	  3,'"'                        ;;
   DB	 2,'!'                        ;;IMPLEMENTED FOR SHIFT STATE STATUS
   DB	 5,'$'                        ;;
   DB	 6,'%'                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 27,'*'                        ;;
   DB	 41,"^"                        ;;
   DB	 43,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;

COM_NA_UP_K3_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K3_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB			      ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 11			       ;; number of entries
   DB	  3,0FDH		       ;; 
   DB	  4,0FCH		       ;;  - converted to script 3 in Germany
   DB	  8,'{'                        ;;
   DB	  9,'['                        ;;
   DB	 10,']'                        ;;
   DB	 11,'}'                        ;;
   DB	 12,'\'                        ;;
   DB	 16,'@'                        ;;
   DB	 27,07EH		       ;; Tilde - ~
   DB	 86,07CH		       ;; Solid vertical bar
   DB	 50,0E6H		       ;;  - mu symbol
COM_THIRD_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K2_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K2_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			      ;; number of entries
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 41,'\'                        ;;
   DB	 3,'@'                        ;;
COM_THIRD_K2_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K2_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: XT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K3_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K3_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 43,'\'                        ;;
   DB	 3,'@'                         ;;
COM_THIRD_K3_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K3_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				       ;;
;  DW	 COM_AC_LO_END-$	       ;; length of state section
;  DB	 ACUTE_LOWER		       ;; State ID
;  DW	 ANY_KB 		       ;; Keyboard Type
;  DB	 39,0			       ;; error character = standalone accent
;				       ;;
;  DW	 COM_AC_LO_T1_END-$	       ;; Size of xlat table
;  DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;  DB	 5			       ;; number of scans
;  DB	 18,''                        ;; scan code,ASCII - e
;  DB	 30,''                        ;; scan code,ASCII - a
;  DB	 24,''                        ;; scan code,ASCII - o
;  DB	 22,''                        ;; scan code,ASCII - u
;  DB	 23,''                        ;; scan code,ASCII - i
;COM_AC_LO_T1_END:			;;
;					;;
;   DW	  0				;; Size of xlat table - null table
;					;;
;COM_AC_LO_END: 			;;
;					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: Common
;;; STATE: Acute Upper Case
;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;					;;
;   DW	  COM_AC_UP_END-$		;; length of state section
;   DB	  ACUTE_UPPER			;; State ID
;   DW	  ANY_KB			;; Keyboard Type
;   DB	  39,0				;; error character = standalone accent
;					;;
;   DW	  COM_AC_UP_T1_END-$		;; Size of xlat table
;   DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
;   DB	  1				;; number of scans
;   DB	  18,''                        ;; scan code,ASCII - e
;COM_AC_UP_T1_END:			;;
;					;;
;   DW	  0				;; Size of xlat table - null table
;					;;
;COM_AC_UP_END: 			;;
;					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: Common
;;; STATE: Acute Space Bar
;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;					;;
;   DW	  COM_AC_SP_END-$		;; length of state section
;   DB	  ACUTE_SPACE			;; State ID
;   DW	  ANY_KB			;; Keyboard Type
;   DB	  39,0				;; error character = standalone accent
;					;;
;   DW	  COM_AC_SP_T1_END-$		;; Size of xlat table
;   DB	  STANDARD_TABLE+ZERO_SCAN	;; xlat options:
;   DB	  1				;; number of scans
;   DB	  57,39 			;; scan code,ASCII - SPACE
;COM_AC_SP_T1_END:			;;
;					;;
;   DW	  0				;; Size of xlat table - null table
;					;;
;COM_AC_SP_END: 			;;
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,'' 		       ;; scan code,ASCII - a
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,94			       ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_LO_END-$	       ;; length of state section
   DB	 GRAVE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 30,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
COM_GR_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_SP_END-$	       ;; length of state section
   DB	 GRAVE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,96			       ;; STANDALONE GRAVE
COM_GR_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_SP_END:			       ;; length of state section
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; GE Specific Translate Section for 437
;; 437 IS COMPLETELY COVERED BY THE COMMON TABLE.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC GE_437_XLAT		       ;;
GE_437_XLAT:			       ;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;; eliminated !!!!
   DW	 CP437_NA_LO_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; error character = standalone accent
				       ;;
   DW	 CP437_NA_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 0			       ;; number of scans
CP437_NA_LO_T1_END:		       ;;
				       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_LO_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_UP_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; error character = standalone accent
				       ;;
   DW	 CP437_NA_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 		;; xlat options:  ***** CNS 12/18
   DB	 1			       ;; number of scans
   DB	 4,015H 		       ;;   - Section symbol
CP437_NA_UP_T1_END:		       ;;
				       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_UP_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 30,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
 CP437_AC_LO_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
CP437_AC_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_UP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,39			       ;; scan code,ASCII - SPACE
CP437_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; GE Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC GE_850_XLAT		       ;;
GE_850_XLAT:			       ;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_LO_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; error character = standalone accent
				       ;;
   DW	 CP850_NA_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 0			       ;; number of scans
CP850_NA_LO_T1_END:		       ;;
				       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_LO_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_UP_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; error character = standalone accent
				       ;;
   DW	 CP850_NA_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 		;; xlat options: **** CNS 12/18
   DB	 1			       ;; number of scans
   DB	 4,0F5H 		       ;;   - Section symbol
				       ;;
CP850_NA_UP_T1_END:		       ;;
				       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_UP_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_LO_END-$		 ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 0eFh,0 			 ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 30,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
 CP850_AC_LO_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_LO_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 0efh,0 		       ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,0B5H			;; Caps acute A
   DB	 23,0D6H			;; Caps acute I
   DB	 24,0E0H			;; Caps acute O
   DB	 22,0E9H			;; Caps acute U
   DB	 18,''                        ;; scan code,ASCII - e
CP850_AC_UP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_UP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 0efh,0 			 ;; error character = standalone accent
				       ;;
   DW	 CP850_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,0efh			 ;; scan code,ASCII - SPACE
CP850_AC_SP_T1_END:			 ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_AC_SP_END:			 ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; CODE PAGE: 850
;;;; STATE: Circumflex Upper
;;;; KEYBOARD TYPES: All
;;;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
     DW    CP850_CI_UP_END-$		 ;; length of state section
     DB    CIRCUMFLEX_UPPER		 ;; State ID
     DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
     DB    94,0 			 ;; error character = standalone accent
					 ;;
     DW    CP850_CI_UP_T1_END-$ 	 ;; Size of xlat table
     DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
     DB    5				 ;; number of scans
     DB    30,0B6H			 ;;    A circumflex
     DB    18,0D2H			 ;;    E circumflex
     DB    23,0D7H			 ;;    I circumflex
     DB    24,0E2H			 ;;    O circumflex
     DB    22,0EAH			 ;;    U circumflex
  CP850_CI_UP_T1_END:			 ;;
					 ;;
     DW    0				 ;; Size of xlat table - null table
					 ;;
  CP850_CI_UP_END:			 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Grave Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_GR_UP_END-$	       ;; length of state section
   DB	 GRAVE_UPPER		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; error character = standalone accent
				       ;;
   DW	 CP850_GR_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 30,0B7H			;; Caps grave A
   DB	 18,0D4H			;; Caps grave E
   DB	 23,0DEH			;; Caps grave I
   DB	 24,0E3H			;; Caps grave O
   DB	 22,0EBH			;; Caps grave U
				       ;;
CP850_GR_UP_T1_END:		       ;;
				       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_GR_UP_END:		       ;;
				       ;;
   DW	  0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kdfit141.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */



	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Spanish.
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC IT2_LOGIC		;;
	PUBLIC IT2_437_XLAT		;;
	PUBLIC IT2_850_XLAT		;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; IT State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
IT2_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  0			       ;; special features
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
      IFF EITHER_SHIFT		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_SPACE    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
NON_DEAD:			       ;;
				       ;;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
;;***BD ADDED FOR ALT, CTRL CASES      ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF  ALT_SHIFT 	       ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
;;***BD END OF ADDITION
				       ;;
   IFF	EITHER_ALT,NOT		       ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  ENDIFF		       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_SHIFT,NOT	       ;;
	  IFKBD XT_KB+AT_KB	 ;;
	      IFF  EITHER_CTL	       ;;
	      ANDF ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ELSEF 		       ;;
	      IFF EITHER_CTL,NOT       ;;
	      ANDF R_ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	   ENDIFF		       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
				       ;;
   EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;***************************************
;; IT Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC IT2_COMMON_XLAT 		;;
IT2_COMMON_XLAT:			;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 ANY_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_ALT_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 0			       ;; 3 number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,225,0		       ;; TEST ENTRY
;;   DB    53,0,82H			 ;; valid alt -
;;   DB    12,-1,-1			 ;; invalid alt -
;;   DB    13,-1,-1			 ;; invalid alt =
COM_ALT_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_ALT_K1_END: 		       ;;
				       ;;
;;******************************
;;***BD - ADDED FOR CTRL CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G_KB+P12_KB+AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB	       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_CTRL_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;; xlat options:
   DB	 2			       ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB	 53,226,0		       ;; TEST ENTRY
   DB	 43,-1,-1		       ;; invalid slash
   DB	 41,28,41		       ;; valid slash
COM_CTRL_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CTRL_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		     ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 10			       ;; number of entries
   DB	 41,"\"                        ;; \
   DB	 12,"'"                        ;; '
   DB	 13,141 		       ;; grave i - ;
   DB	 27,'+'                        ;; +
   DB	 86,'<'                        ;; <
   DB	 53,'-'                        ;; -
   DB	 39,149 		       ;; grave o - 
   DB	 40,133 		       ;; grave a - ;
   DB	 43,151 		       ;; grave u - ;
   DB	 26,138 		       ;; grave e - ;
COM_NA_LO_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K2_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	 41,"<"                        ;; <
   DB	 12,"'"                        ;; '
   DB	 13,141 		       ;; grave i - ;
   DB	 27,'+'                        ;; +
   DB	 53,'-'                        ;; -
   DB	 39,149 		       ;; grave o - 
   DB	 40,133 		       ;; grave a - ;
   DB	 43,151 		       ;; grave u - ;
   DB	 26,138 		       ;; grave e - ;
COM_NA_LO_K2_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K2_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES:  XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K3_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 9			       ;; number of entries
   DB	 12,"'"                        ;; '
   DB	 13,141 		       ;; grave i - ;
   DB	 27,'+'                        ;; +
   DB	 43,'<'                        ;; <
   DB	 53,'-'                        ;; -
   DB	 39,149 		       ;; grave o - 
   DB	 40,133 		       ;; grave a - ;
   DB	 41,151 		       ;; grave u - ;
   DB	 26,138 		       ;; grave e - ;
COM_NA_LO_K3_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K3_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		     ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 18			       ;; number of entries
   DB	  41,07CH		       ;; Solid vertical bar - |
   DB	  3,'"'                        ;;
   DB	  4,''                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 13,'^'                        ;;
   DB	 26,130 		       ;; acute e - ;
   DB	 39,135 		       ;; c - cedilla - 
   DB	 27,'*'                        ;;
   DB	 40,0F8H		       ;;  - degree symbol
   DB	 86,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
				       ;;
COM_NA_UP_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K2_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 18			       ;; number of entries
   DB	  41,'>'                       ;; >
   DB	  3,'"'                        ;;
   DB	  4,''                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 13,'^'                        ;;
   DB	 26,130 		       ;; acute e - ;
   DB	 39,'@'                        ;; @ AT sign replaces c - cedilla - 
   DB	 27,'*'                        ;;
   DB	 40,'#'                        ;; # sign replaces  - degree symbol
   DB	 86,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
				       ;;
COM_NA_UP_K2_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_K3_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 17			       ;; number of entries
   DB	  3,'"'                        ;;
   DB	  4,''                        ;;
   DB	  7,'&'                        ;;
   DB	  8,'/'                        ;;
   DB	  9,'('                        ;;
   DB	 10,')'                        ;;
   DB	 11,'='                        ;;
   DB	 12,'?'                        ;;
   DB	 13,'^'                        ;;
   DB	 26,130 		       ;; acute e - ;
   DB	 39,'@'                        ;; @ AT sign replaces c - cedilla - 
   DB	 27,'*'                        ;;
   DB	 40,'#'                        ;; # sign replaces  - degree symbol
   DB	 43,'>'                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'_'                        ;;
				       ;;
COM_NA_UP_K3_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K3_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K1_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 4			       ;; number of entries
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 39,'@'                        ;;
   DB	 40,'#'                        ;;
COM_THIRD_K1_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K2_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K2_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of entries
   DB	 41,'\'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
COM_THIRD_K2_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K2_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES:  XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K3_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_K3_T1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 3			       ;; number of entries
   DB	 43,'\'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
COM_THIRD_K3_T1_END:			  ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K3_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; IT Specific Translate Section for 437
;; 437 IS COMPLETELY COVERED BY THE COMMON TABLE.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC IT2_437_XLAT			;;
IT2_437_XLAT:				;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Upper case
;; KEYBOARD TYPES: G_KB+P12+AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
     DW    CP437_NA_UP_K1_END-$ 	 ;; length of state section
     DB    NON_ALPHA_UPPER		 ;; State ID
     DW    G_KB+P12_KB+AT_KB		 ;; Keyboard Type
     DB    -1,-1			 ;; error character = standalone accent
					 ;;
     DW    CP437_NA_UP_T1_K1_END-$	 ;; Size of xlat table
     DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
     DB    1				 ;; number of scans
     DB    43,015H			 ;; Section symbol - 
  CP437_NA_UP_T1_K1_END:		 ;;
					 ;;
     DW    0				 ;; Size of xlat table - null table
					 ;;
  CP437_NA_UP_K1_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Upper case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
     DW    CP437_NA_UP_K2_END-$ 	 ;; length of state section
     DB    NON_ALPHA_UPPER		 ;; State ID
     DW    XT_KB			 ;; Keyboard Type
     DB    -1,-1			 ;; error character = standalone accent
					 ;;
     DW    CP437_NA_UP_T1_K2_END-$	 ;; Size of xlat table
     DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
     DB    1				 ;; number of scans
     DB    41,015H			 ;; Section symbol - 
  CP437_NA_UP_T1_K2_END:		 ;;
					 ;;
     DW    0				 ;; Size of xlat table - null table
					 ;;
  CP437_NA_UP_K2_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; IT Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC IT2_850_XLAT			;;
IT2_850_XLAT:				;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper case
;; KEYBOARD TYPES: G_KB+P12+AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
     DW    CP850_NA_UP_K1_END-$ 	 ;; length of state section
     DB    NON_ALPHA_UPPER		 ;; State ID
     DW    G_KB+P12_KB+AT_KB		 ;; Keyboard Type
     DB    -1,-1			 ;; error character = standalone accent
					 ;;
     DW    CP850_NA_UP_T1_K1_END-$	 ;; Size of xlat table
     DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
     DB    1				 ;; number of scans
     DB    43,0F5H			 ;; Section symbol - 
  CP850_NA_UP_T1_K1_END:		 ;;
					 ;;
     DW    0				 ;; Size of xlat table - null table
					 ;;
  CP850_NA_UP_K1_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper case
;; KEYBOARD TYPES: XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
     DW    CP850_NA_UP_K2_END-$ 	 ;; length of state section
     DB    NON_ALPHA_UPPER		 ;; State ID
     DW    XT_KB			 ;; Keyboard Type
     DB    -1,-1			 ;; error character = standalone accent
					 ;;
     DW    CP850_NA_UP_T1_K2_END-$	 ;; Size of xlat table
     DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
     DB    1				 ;; number of scans
     DB    41,0F5H			 ;; Section symbol - 
  CP850_NA_UP_T1_K2_END:		 ;;
					 ;;
     DW    0				 ;; Size of xlat table - null table
					 ;;
  CP850_NA_UP_K2_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kdffr189.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;; LATEST CHANGE ALT & CTL  disenabled US invalids

;; Section symbol scan code incorrect
;; zero scan code tag deleted from end of tag field
;; Changed key #5 for the XT "/" instead of "'"..Pubs error
;; ****************** CNS 12/18/86*************************

	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Spanish.
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC FR2_LOGIC		;;
	PUBLIC FR2_437_XLAT		;;
	PUBLIC FR2_850_XLAT		;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; FR State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
FR2_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  TYPEWRITER_CAPS_LK	       ;; special features (shift lock state)
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
     IFF CAPS_STATE
	 SET_FLAG DEAD_UPPER
     ELSEF
      IFF EITHER_SHIFT		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
     ENDIFF			      ;;
   ENDIFF			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_SPACE    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
NON_DEAD:			       ;;
				       ;;
   IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
   ANDF LC_E0			       ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC		       ;;   G keyboard
   ENDIFF			       ;;
;;***BD ADDED FOR ALT, CTRL CASES      ;;
      IFF EITHER_CTL,NOT	       ;;
	 IFF  ALT_SHIFT 	       ;; ALT - case
	 ANDF R_ALT_SHIFT,NOT	       ;;
	    XLATT ALT_CASE	       ;;
	 ENDIFF 		       ;;
      ELSEF			       ;;
	 IFF EITHER_ALT,NOT	       ;; CTRL - case
	    XLATT CTRL_CASE	       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
;;***BD END OF ADDITION
				       ;;
   IFF	EITHER_ALT,NOT		       ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT		       ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT		       ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
;	  XLATT NON_ALPHA_UPPER        ;;
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	      XLATT NON_ALPHA_LOWER    ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	  XLATT NON_ALPHA_UPPER        ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
;	  XLATT NON_ALPHA_LOWER        ;;
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
	  XLATT NON_ALPHA_UPPER        ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	  XLATT NON_ALPHA_LOWER        ;;
	  ENDIFF		       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_SHIFT,NOT	       ;;
	  IFKBD XT_KB+AT_KB	 ;;
	      IFF  EITHER_CTL	       ;;
	      ANDF ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ELSEF 		       ;;
	      IFF EITHER_CTL,NOT       ;;
	      ANDF R_ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	   ENDIFF		       ;;
      ENDIFF			       ;;
   ENDIFF			       ;;
				       ;;
   EXIT_STATE_LOGIC		       ;;
				       ;;
LOGIC_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;					;;
;NON_DEAD:				;;
;					;;
;   IFF  EITHER_ALT,NOT 		;; Lower and upper case.  Alphabetic
;   ANDF EITHER_CTL,NOT 		;; keys are affected by CAPS LOCK.
;      IFF EITHER_SHIFT 		;; Numeric keys are not.
;	   XLATT NON_ALPHA_UPPER	;;
;	   IFF CAPS_STATE		;;
;	       XLATT ALPHA_LOWER	;;
;	   ELSEF			;;
;	       XLATT ALPHA_UPPER	;;
;	   ENDIFF			;;
;      ELSEF				;;
;	   XLATT NON_ALPHA_LOWER	;;
;	   IFF CAPS_STATE		;;
;	      XLATT ALPHA_UPPER 	;;
;	   ELSEF			;;
;	      XLATT ALPHA_LOWER 	;;
;	   ENDIFF			;;
;      ENDIFF				;;
;   ELSEF				;;
;      IFF EITHER_SHIFT,NOT		;;
;	   IFKBD XT_KB+AT_KB	  ;;
;	       IFF  EITHER_CTL		;;
;	       ANDF ALT_SHIFT		;;
;		   XLATT THIRD_SHIFT	;;
;	       ENDIFF			;;
;	   ELSEF			;;
;	       IFF EITHER_CTL,NOT	;;
;	       ANDF R_ALT_SHIFT 	;;
;		   XLATT THIRD_SHIFT	;;
;	       ENDIFF			;;
;	    ENDIFF			;;
;      ENDIFF				;;
;   ENDIFF				;;
;					;;
;   EXIT_STATE_LOGIC			;;
;					;;
;LOGIC_END:				;;
;					;;
;					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; FR Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC FR2_COMMON_XLAT 		;;
FR2_COMMON_XLAT:			;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_LO_END-$	       ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  CIRCUMFLEX		       ;; flag bit to set
;  DB	 40	    eliminate	       ;;
;  FLAG  ACUTE			       ;;
				       ;;
				       ;;
COM_DK_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_UP_END-$	       ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  DIARESIS		       ;; flag bit to set
;  DB	 40	      eliminate        ;;
;  FLAG  DIARESIS		       ;;
				       ;;
COM_DK_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;**********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    COM_DK_TH_END-$		 ;; length of state section
;;   DB    DEAD_THIRD			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    -1,-1			 ;; Buffer entry for error character
;;					 ;; Set Flag Table
;;   DW    1				 ;; number of entries
;;   DB    8				 ;; scan code
;;   FLAG  GRAVE			 ;; flag bit to set
;;					 ;;
;;COM_DK_TH_END:			 ;;
;;					 ;;
;;					 ;;
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: G_KB + P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_ALT_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 6			       ;; 10 Number of entries
;  DB	 12,-1,-1		       ;; invalid key U.S. alt -
;  DB	 13,-1,-1		       ;; invalid key U.S. alt =
;  DB	 07,0,82H		       ;; alt - (minus sign)
;  DB	 13,0,83H		       ;; alt = (equal sign)
   DB	 16,0,1EH		       ;; A
   DB	 17,0,2CH		       ;; Z
   DB	 30,0,10H		       ;; Q
   DB	 39,0,32H		       ;; M
   DB	 44,0,11H		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_ALT_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_ALT_K1_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 12			       ;; Number of entries
   DB	 12,-1,-1		       ;;
   DB	 07,30,07		       ;; ctl + number six key
   DB	 12,29,12		       ;; ctl + ]
   DB	 13,31,13		       ;;
   DB	 16,01,16		       ;; A
   DB	 17,26,17		       ;; Z
   DB	 30,17,30		       ;; Q
   DB	 39,13,39		       ;; M
   DB	 43,-1,-1		       ;; \
   DB	 44,23,44		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
   DB	 9,28,9 		      ;;  \ position (this is also the underscore position)
COM_CTRL_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: AT + XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K2_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 AT_KB+XT_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_ALT_K2_T2_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 6			       ;; 9 Number of entries
;  DB	 12,-1,-1		       ;; invalid key U.S. alt -
;  DB	 13,0,82H		       ;; alt - (minus sign)
;  DB	 53,0,83H		       ;; alt = (equal sign)
   DB	 16,0,1EH		       ;; A
   DB	 17,0,2CH		       ;; Z
   DB	 30,0,10H		       ;; Q
   DB	 39,0,32H		       ;; M
   DB	 44,0,11H		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_ALT_K2_T2_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_ALT_K2_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K2_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_K2_T2_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 11				;; Number of entries
   DB	 12,-1,-1		       ;; invalid U.S. -
   DB	 43,-1,-1		       ;; invalid U.S. \
   DB	 41,28,41		       ;; valid ctl + \
   DB	 07,30,07		       ;; ctl + number six key
   DB	 13,31,13		       ;; ctl - or _
   DB	 16,01,16		       ;; A
   DB	 17,26,17		       ;; Z
   DB	 30,17,30		       ;; Q
   DB	 39,13,39		       ;; M
   DB	 44,23,44		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_CTRL_K2_T2_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_K2_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K3_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 AT_KB+XT_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_K3_T3_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 11			       ;; Number of entries
   DB	 12,-1,-1		       ;;
   DB	 43,-1,-1		       ;;
   DB	 43,28,43		       ;; valid ctl + \
   DB	 07,30,07		       ;; ctl + number six key
   DB	 13,31,13		       ;; ctl - or _
   DB	 16,01,16		       ;; A
   DB	 17,26,17		       ;; Z
   DB	 30,17,30		       ;; Q
   DB	 39,13,39		       ;; M
   DB	 44,23,44		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_CTRL_K3_T3_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_K3_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;******************************************************************************
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_LO_END-$	       ;; length of state section
   DB	 ALPHA_LOWER		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 16,'a'                        ;; small a
   DB	 17,'z'                        ;; small z
   DB	 30,'q'                        ;; small q
   DB	 39,'m'                        ;; small m
   DB	 44,'w'                        ;; small w
COM_AL_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_UP_END-$	       ;; length of state section
   DB	 ALPHA_UPPER		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 16,'A'                        ;; caps  A
   DB	 17,'Z'                        ;; caps  Z
   DB	 30,'Q'                        ;; caps  Q
   DB	 39,'M'                        ;; caps  M
   DB	 44,'W'                        ;; caps  W
COM_AL_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_UP_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_T1_K1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 21			       ;; number of entries
   DB	 41,""                        ;; superscript 2
   DB	  2,"&"                        ;;
   DB	  3,""                        ;; acute - e
   DB	  4,'"'                        ;;
   DB	  5,"'"                        ;;
   DB	  6,"("                        ;;
   DB	  7,"-"                        ;;
   DB	  8,""                        ;; grave - e
   DB	  9,"_"                        ;;
   DB	 10,""                        ;; c - cedilla small
   DB	 11,""                        ;;
   DB	 12,")"                        ;;
   DB	 13,"="                        ;;
   DB	 27,"$"                        ;;
   DB	 40,""                        ;; grave - u
   DB	 43,"*"                        ;;
   DB	 86,'<'                        ;; +
   DB	 50,','                        ;; <
   DB	 51,';'                        ;; -
   DB	 52,':'                        ;;
   DB	 53,'!'                        ;;

COM_NA_LO_T1_K1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_T1_K2_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	  2,"&"                        ;;
   DB	  3,""                        ;; acute - e
   DB	  4,'"'                        ;;
   DB	  5,"'"                        ;;
   DB	  6,"("                        ;;
   DB	  7,"-"                        ;;
   DB	  8,""                        ;; grave - e
   DB	  9,"!"                        ;;
   DB	 10,""                        ;; c - cedilla small
   DB	 11,""                        ;; grave - a small
   DB	 12,")"                        ;;
   DB	 13,"-"                        ;;
   DB	 27,"$"                        ;;
   DB	 40,""                        ;; grave  small
   DB	 43,0E6H		       ;; mu symbol - 
   DB	 41,'<'                        ;; +
   DB	 50,','                        ;; <
   DB	 51,';'                        ;; -
   DB	 52,':'                        ;;
   DB	 53,'='                        ;;

COM_NA_LO_T1_K2_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K2_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_T1_K3_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	  2,"&"                        ;;
   DB	  3,""                        ;; acute - e
   DB	  4,'"'                        ;; ' on the AT_KB
   DB	  5,"'"                        ;; *** CNS **** 12/18/86 pubs wrong
   DB	  6,"("                        ;;
   DB	  7,"-"                        ;;
   DB	  8,""                        ;; grave - e
   DB	  9,"!"                        ;;
   DB	 10,""                        ;; c - cedilla small
   DB	 11,""                        ;;
   DB	 12,")"                        ;;
   DB	 13,"-"                        ;;
   DB	 27,"$"                        ;;
   DB	 40,""                        ;; grave  small
   DB	 41,0E6H		       ;; mu symbol - 
   DB	 43,'<'                        ;; +
   DB	 50,','                        ;; <
   DB	 51,';'                        ;; -
   DB	 52,':'                        ;;
   DB	 53,'='                        ;;
COM_NA_LO_T1_K3_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K3_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:

   DB	 21			       ;; number of entries

   DB	  2,'1'                        ;;
   DB	  3,'2'                        ;;
   DB	  4,'3'                        ;;
   DB	  5,'4'                        ;;
   DB	  6,'5'                        ;;
   DB	  7,'6'                        ;;
   DB	  8,'7'                        ;;
   DB	  9,'8'                        ;;
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0F8H		       ;; degree symbol
   DB	 13,"+"                        ;; plus sign
   DB	 27,09CH		       ;;  symbol
   DB	 40,'%'                        ;;
   DB	41,-1				;; invalid key

;   DB	 41,""                        ;; superscript 3

   DB	 43,0E6H		       ;;  - mu symbol
   DB	 86,'>'                        ;;
   DB	 50,'?'                        ;;
   DB	 51,'.'                        ;;
   DB	 52,'/'                        ;;
   DB	 53,'+'                        ;;
COM_NA_UP_T1_K1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K2_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	  2,'1'                        ;;
   DB	  3,'2'                        ;;
   DB	  4,'3'                        ;;
   DB	  5,'4'                        ;;
   DB	  6,'5'                        ;;
   DB	  7,'6'                        ;;
   DB	  8,'7'                        ;;
   DB	  9,'8'                        ;;
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0F8H		       ;; degree symbol
   DB	 13,"_"                        ;; underscore
   DB	 43,09CH		       ;;  symbol
   DB	 40,'%'                        ;;
   DB	 27,"*"                        ;; asterisk
   DB	 41,'>'                        ;;
   DB	 50,'?'                        ;;
   DB	 51,'.'                        ;;
   DB	 52,'/'                        ;;
   DB	 53,'+'                        ;;
COM_NA_UP_T1_K2_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K3_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K3_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	  2,'1'                        ;;
   DB	  3,'2'                        ;;
   DB	  4,'3'                        ;;
   DB	  5,'4'                        ;;
   DB	  6,'5'                        ;;
   DB	  7,'6'                        ;;
   DB	  8,'7'                        ;;
   DB	  9,'8'                        ;;
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0F8H		       ;; degree symbol
   DB	 13,"_"                        ;; underscore
   DB	 41,09CH		       ;;  symbol
   DB	 40,'%'                        ;;
   DB	 27,"*"                        ;; asterisk
   DB	 43,'>'                        ;;
   DB	 50,'?'                        ;;
   DB	 51,'.'                        ;;
   DB	 52,'/'                        ;;
   DB	 53,'+'                        ;;
COM_NA_UP_T1_K3_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K3_END:			  ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB +P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K1_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 11			       ;; number of entries
   DB	  3,'~'                        ;;
   DB	  4,'#'                        ;;
   DB	  5,'{'                        ;;
   DB	  6,'['                        ;;
   DB	  7,'|'                        ;;
   DB	  8,'`'                        ;; grave symbol not a dead key rep
   DB	  9,'\'                        ;;
   DB	 10,'^'                        ;; circumflex (caret)
   DB	 11,'@'                        ;;
   DB	 12,']'                        ;;
   DB	 13,'}'                        ;;
COM_THIRD_T1_K1_END:			  ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K2_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K2_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  6			       ;; number of entries
   DB	  4,'#'                        ;;
   DB	  26,'['                       ;;
   DB	  27,']'                       ;;
   DB	  41,'\'                       ;;
   DB	  3,'@'                        ;;
   DB	  7,'^'                        ;; circumflex (caret)
COM_THIRD_T1_K2_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K2_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: XT_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K3_END-$		  ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K3_END-$		  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  6			       ;; number of entries
   DB	  4,'#'                        ;;
   DB	  26,'['                       ;;
   DB	  27,']'                       ;;
   DB	  43,'\'                       ;;
   DB	  3,'@'                        ;;
   DB	  7,'^'                        ;; circumflex (caret)
COM_THIRD_T1_K3_END:			  ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K3_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AC_LO_END-$	       ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_AC_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
COM_AC_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AC_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    COM_AC_UP_END-$		 ;; length of state section
;;   DB    ACUTE_UPPER			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    39,0 			 ;; error character = standalone accent
;;					 ;;
;;   DW    COM_AC_UP_T1_END-$		 ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
;;   DB    2				 ;; number of scans
;;   DB    18,''                        ;; scan code,ASCII - e
;;COM_AC_UP_T1_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;COM_AC_UP_END:			 ;;
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    COM_AC_SP_END-$		 ;; length of state section
;;   DB    ACUTE_SPACE			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    39,0 			 ;; error character = standalone accent
;;					 ;;
;;   DW    COM_AC_SP_T1_END-$		 ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
;;   DB    1				 ;; number of scans
;;   DB    57,39			 ;; scan code,ASCII - SPACE
;;COM_AC_SP_T1_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;COM_AC_SP_END:			 ;;
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_LO_END-$	       ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_DI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 21,''                        ;; scan code,ASCII - y
COM_DI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_UP_END-$	       ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_DI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
COM_DI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_UP_END:			       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_SP_END-$	       ;; length of state section
   DB	 DIARESIS_SPACE 	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_DI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,249 		       ;; error character = standalone accent
COM_DI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
COM_DI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    COM_GR_LO_END-$		 ;; length of state section
;;   DB    GRAVE_LOWER			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    96,0 			 ;; error character = standalone accent
;;					 ;;
;;   DW    COM_GR_LO_T1_END-$		 ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
;;   DB    5				 ;; number of scans
;;   DB    18,''                        ;; scan code,ASCII - e
;;   DB    30,''                        ;; scan code,ASCII - a
;;   DB    24,''                        ;; scan code,ASCII - o
;;   DB    22,''                        ;; scan code,ASCII - u
;;   DB    23,''                        ;; scan code,ASCII - i
;;COM_GR_LO_T1_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;COM_GR_LO_END:			 ;; length of state section
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    COM_GR_SP_END-$		 ;; length of state section
;;   DB    GRAVE_SPACE			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    96,0 			 ;; error character = standalone accent
;;					 ;;
;;   DW    COM_GR_SP_T1_END-$		 ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
;;   DB    1				 ;; number of scans
;;   DB    57,96			 ;; STANDALONE GRAVE
;;COM_GR_SP_T1_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;COM_GR_SP_END:			 ;; length of state section
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,94			       ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; FR Specific Translate Section for 437
;; 437 IS COMPLETELY COVERED BY THE COMMON TABLE.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC FR2_437_XLAT			;;
FR2_437_XLAT:				;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+ p12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP437_NA_UP_T1_K1_END-$	  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options: **** CNS 12/18
   DB	 1			       ;; number of scans
   DB	 53,015H		       ;; Section symbol - 
CP437_NA_UP_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_UP_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT + XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_LO_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB+XT_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP437_NA_LO_T1_K1_END-$	  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options: **** CNS 12/18
   DB	 1			       ;; number of scans
   DB	 7,015H 		       ;; Section symbol - 
CP437_NA_LO_T1_K1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_LO_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437    ???????????????????May need change....
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP437_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options: *** CNS 12/18
   DB	 1			       ;; number of scans
   DB	 27,'$'                        ;; dollar currency symbol
CP437_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_THIRD_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; FR Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC FR2_850_XLAT			;;
FR2_850_XLAT:				;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB + P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP850_NA_UP_T1_K1_END-$	  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options: ***** CNS 12/18
   DB	 1			       ;; number of scans
   DB	 53,0F5H		       ;; Section symbol - 
CP850_NA_UP_T1_K1_END:			  ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_UP_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT_KB+XT+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_LO_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB+XT_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP850_NA_LO_T1_K1_END-$	  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options: ***** CNS **** 12/18
   DB	 1			       ;; number of scans
   DB	 7,0F5H 		       ;; Section symbol - 
CP850_NA_LO_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_LO_K1_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB+P12_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP850_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options: *** CNS 12/18
   DB	 1			       ;; number of scans
   DB	 27,0CFH		       ;; international currency symbol
CP850_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_THIRD_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    CP850_AC_LO_END-$		 ;; length of state section
;;   DB    ACUTE_LOWER			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    39,0 			 ;; error character = standalone accent
;;					 ;;
;;   DW    CP850_AC_LO_T1_END-$ 	 ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
;;   DB    1				 ;; number of scans
;;   DB    21,0ECH			 ;; y acute
;;CP850_AC_LO_T1_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;CP850_AC_LO_END:			 ;;
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; CODE PAGE: 850
;;;; STATE: Acute Upper Case
;;;; KEYBOARD TYPES: All
;;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    CP850_AC_UP_END-$		 ;; length of state section
;;   DB    ACUTE_UPPER			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    39,0 			 ;; error character = standalone accent
;;					 ;;
;;   DW    CP850_AC_UP_T1_END-$ 	 ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
;;   DB    5				 ;; number of scans
;;   DB    30,0B5H			 ;;    A acute
;;   DB    23,0D6H			 ;;    I acute
;;   DB    24,0E0H			 ;;    O acute
;;   DB    22,0E9H			 ;;    U acute
;;   DB    21,0EDH			 ;;    Y acute
;;CP850_AC_UP_T1_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;CP850_AC_UP_END:			 ;;
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; CODE PAGE: 850
;;;; STATE: Diaresis Upper
;;;; KEYBOARD TYPES: All
;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
     DW    CP850_DI_UP_END-$		 ;; length of state section
     DB    DIARESIS_UPPER		 ;; State ID
     DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
     DB    249,0			 ;; error character = standalone accent
					 ;;
     DW    CP850_DI_UP_T1_END-$ 	 ;; Size of xlat table
     DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
     DB    2				 ;; number of scans
     DB    18,0D3H			 ;;    E diaeresis
     DB    23,0D8H			 ;;    I diaeresis
  CP850_DI_UP_T1_END:			 ;;
					 ;;
     DW    0				 ;; Size of xlat table - null table
					 ;;
  CP850_DI_UP_END:			 ;; length of state section
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CODE PAGE: 850
;; STATE: Grave Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					 ;;
;;   DW    CP850_GR_UP_END-$		 ;; length of state section
;;   DB    GRAVE_UPPER			 ;; State ID
;;   DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
;;   DB    96,0 			 ;; error character = standalone accent
;;					 ;;
;;   DW    CP850_GR_UP_T1_END-$ 	 ;; Size of xlat table
;;   DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
;;   DB    5				 ;; number of scans
;;   DB    30,0B7H			 ;;    A grave
;;   DB    18,0D4H			 ;;    E grave
;;   DB    23,0DEH			 ;;    I grave
;;   DB    24,0E3H			 ;;    O grave
;;   DB    22,0EBH			 ;;    U grave
;;CP850_GR_UP_T1_END:			 ;;
;;					 ;;
;;   DW    0				 ;; Size of xlat table - null table
;;					 ;;
;;CP850_GR_UP_END:			 ;; length of state section
;;					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; CODE PAGE: 850
;;;; STATE: Circumflex Upper
;;;; KEYBOARD TYPES: All
;;;;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
     DW    CP850_CI_UP_END-$		 ;; length of state section
     DB    CIRCUMFLEX_UPPER		 ;; State ID
     DW    G_KB+P12_KB+AT_KB+XT_KB			  ;; Keyboard Type
     DB    94,0 			 ;; error character = standalone accent
					 ;;
     DW    CP850_CI_UP_T1_END-$ 	 ;; Size of xlat table
     DB    STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
     DB    5				 ;; number of scans
     DB    16,0B6H			 ;;    A circumflex
     DB    18,0D2H			 ;;    E circumflex
     DB    23,0D7H			 ;;    I circumflex
     DB    24,0E2H			 ;;    O circumflex
     DB    22,0EAH			 ;;    U circumflex
  CP850_CI_UP_T1_END:			 ;;
					 ;;
     DW    0				 ;; Size of xlat table - null table
					 ;;
  CP850_CI_UP_END:			 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
     DW    0			       ;; LAST STATE
				       ;;
CP850_XLAT_END: 		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CODE	 ENDS			       ;;
	 END			       ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\dev\keyboard\kdffr120.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; ACUTE lc y added

; ****** CNS 12/18
; ****** CNS 01/21 NUM PAD
	PAGE	,132
	TITLE	MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;;
;; This file contains the keyboard tables for Belgium.
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;	       NICK SAVAGE  - IBM Corp.
;; Modded from French - DTF 11-Sep-86
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	INCLUDE KEYBSHAR.INC	       ;;
	INCLUDE POSTEQU.INC	       ;;
	INCLUDE KEYBMAC.INC	       ;;
				       ;;
	PUBLIC FR1_LOGIC	       ;;
	PUBLIC FR1_437_XLAT	       ;;
	PUBLIC FR1_850_XLAT	       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
STANDARD_TABLE	    EQU   TYPE_2_TAB+ASCII_ONLY
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; FR State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
FR1_LOGIC:

   DW  LOGIC_END-$		       ;; length
				       ;;
   DW  TYPEWRITER_CAPS_LK	       ;; special features
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   OPTION EXIT_IF_FOUND 	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
     IFF CAPS_STATE
	 SET_FLAG DEAD_UPPER
     ELSEF
      IFF EITHER_SHIFT		       ;;
	  SET_FLAG DEAD_UPPER	       ;;
      ELSEF			       ;;
	  SET_FLAG DEAD_LOWER	       ;;
      ENDIFF			       ;;
     ENDIFF
   ELSEF			       ;;
      IFF EITHER_SHIFT,NOT	       ;;
	IFKBD XT_KB+AT_KB
	  IFF EITHER_CTL		;;
	  ANDF ALT_SHIFT		;;
	    SET_FLAG DEAD_THIRD        ;;
	  ENDIFF			;;
	ELSEF
	 IFF R_ALT_SHIFT	       ;;
	 ANDF EITHER_CTL,NOT	       ;;
	 ANDF LC_E0,NOT 	       ;;
	    SET_FLAG DEAD_THIRD        ;;
	 ENDIFF 		       ;;
	ENDIFF
       ENDIFF
   ENDIFF			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE_PROC:			       ;;
				       ;;
   IFF ACUTE,NOT		       ;;
      GOTO TILDE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT ACUTE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_LOWER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_UPPER       ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT ACUTE_UPPER       ;;
	    ELSEF		       ;;
	       XLATT ACUTE_LOWER       ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_ACUTE:			       ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP			       ;; failed or we are ina bad shift state.
      GOTO NON_DEAD		       ;; Either is invalid so BEEP and fall
				       ;; through to generate the second char.
				       ;; Note that the dead key flag will be
				       ;; reset before we get here.
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TILDE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
TILDE_PROC:			       ;;
				       ;;
   IFF TILDE,NOT		       ;;
      GOTO DIARESIS_PROC	       ;;
      ENDIFF			       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT TILDE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT TILDE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT TILDE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_TILDE:			       ;;
      PUT_ERROR_CHAR TILDE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DIARESIS_PROC:			       ;;
				       ;;
   IFF DIARESIS,NOT		       ;;
      GOTO GRAVE_PROC		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT DIARESIS_SPACE	       ;;  exist for 437 so beep for
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	 IFF EITHER_SHIFT	       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ENDIFF		       ;;
	 ELSEF			       ;;
	    IFF CAPS_STATE	       ;;
	       XLATT DIARESIS_UPPER    ;;
	    ELSEF		       ;;
	       XLATT DIARESIS_LOWER    ;;
	    ENDIFF		       ;;
	 ENDIFF 		       ;;
      ENDIFF			       ;;
				       ;;
INVALID_DIARESIS:		       ;;
      PUT_ERROR_CHAR DIARESIS_LOWER    ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
GRAVE_PROC:			       ;;
				       ;;
   IFF GRAVE,NOT		       ;;
      GOTO CIRCUMFLEX_PROC	       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT GRAVE_SPACE	       ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT GRAVE_LOWER        ;;
	   ELSEF		       ;;
	      XLATT GRAVE_UPPER        ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_GRAVE:			       ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
CIRCUMFLEX_PROC:		       ;;
				       ;;
   IFF CIRCUMFLEX,NOT		       ;;
      GOTO NON_DEAD		       ;;
      ENDIFF			       ;;
				       ;;
      RESET_NLS 		       ;;
      IFF R_ALT_SHIFT,NOT	       ;;
	 XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF			       ;;
      IFF EITHER_CTL,NOT	       ;;
      ANDF EITHER_ALT,NOT	       ;;
	IFF EITHER_SHIFT	       ;;
	   IFF CAPS_STATE	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ELSEF			       ;;
	   IFF CAPS_STATE,NOT	       ;;
	      XLATT CIRCUMFLEX_LOWER   ;;
	   ELSEF		       ;;
	      XLATT CIRCUMFLEX_UPPER   ;;
	   ENDIFF		       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
				       ;;
INVALID_CIRCUMFLEX:		       ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP			       ;; Invalid dead key combo.
      GOTO NON_DEAD		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;***************************
NON_DEAD:			       ;;
;ADDED FOR DIVIDE SIGN		       ;;
    IFKBD G_KB+P12_KB			;; Avoid accidentally translating
    ANDF LC_E0				;;  the "/" on the numeric pad of the
      IFF EITHER_CTL,NOT
      ANDF EITHER_ALT,NOT
	XLATT DIVIDE_SIGN	       ;;
      ENDIFF
      EXIT_STATE_LOGIC		     ;;
    ENDIFF			       ;;
;BD END OF ADDITION
;****************************
;NON_DEAD:				;;
;					;;
;  IFKBD G_KB+P12_KB		       ;; Avoid accidentally translating
;  ANDF LC_E0			       ;;  the "/" on the numeric pad of the
;     EXIT_STATE_LOGIC		       ;;   G keyboard
;  ENDIFF			       ;;
				       ;;
   IFF	EITHER_ALT,NOT		       ;;
   ANDF EITHER_CTL,NOT		       ;;
      IFF EITHER_SHIFT		       ;;
;******************************************
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE,NOT	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
;*******************************************
	  IFF CAPS_STATE	       ;;
	      XLATT ALPHA_LOWER        ;;
	      XLATT NON_ALPHA_LOWER    ;;
	  ELSEF 		       ;;
	      XLATT ALPHA_UPPER        ;;
	      XLATT NON_ALPHA_UPPER    ;;
	  ENDIFF		       ;;
      ELSEF			       ;;
;******************************************
;;***BD ADDED FOR NUMERIC PAD
	  IFF NUM_STATE 	       ;;
	      XLATT NUMERIC_PAD        ;;
	  ENDIFF		       ;;
;;***BD END OF ADDITION
;******************************************
	  IFF CAPS_STATE	       ;;
	     XLATT ALPHA_UPPER	       ;;
      XLATT NON_ALPHA_UPPER	       ;;
	  ELSEF 		       ;;
	     XLATT ALPHA_LOWER	       ;;
	     XLATT NON_ALPHA_LOWER     ;;
	  ENDIFF		       ;;
      ENDIFF			       ;;
   ELSEF			       ;;
      IFF EITHER_SHIFT,NOT	       ;;
	  IFKBD XT_KB+AT_KB	 ;;
	      IFF  EITHER_CTL	       ;;
	      ANDF ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ELSEF 		       ;;
	      IFF EITHER_CTL,NOT       ;;
	      ANDF R_ALT_SHIFT	       ;;
		  XLATT THIRD_SHIFT    ;;
	      ENDIFF		       ;;
	  ENDIFF		       ;;
      IFKBD AT_KB+XT_KB 	 ;;
	IFF EITHER_CTL		       ;;
	ANDF ALT_SHIFT		       ;;
	  XLATT ALT_CASE	       ;;
	ENDIFF			       ;;
      ENDIFF			       ;;
      IFKBD G_KB+P12_KB 	       ;;
	IFF EITHER_CTL		       ;;
	ANDF ALT_SHIFT		       ;;
	  IFF R_ALT_SHIFT,NOT		  ;;
	    XLATT ALT_CASE		  ;;
	  ENDIFF			  ;;
	ENDIFF				  ;;
      ENDIFF				  ;;
     ENDIFF				  ;;
   ENDIFF				  ;;
;IFF EITHER_SHIFT,NOT			  ;;
   IFKBD AT_KB+XT_KB		    ;;
     IFF EITHER_CTL,NOT 		  ;;
       IFF ALT_SHIFT			  ;; ALT - case
	 XLATT ALT_CASE 		  ;;
       ENDIFF				  ;;
     ELSEF				  ;;
	 XLATT CTRL_CASE		  ;;
     ENDIFF				  ;;
   ENDIFF				  ;;
					  ;;
   IFKBD G_KB+P12_KB			  ;;
     IFF EITHER_CTL,NOT 		  ;;
       IFF ALT_SHIFT			  ;; ALT - case
       ANDF R_ALT_SHIFT,NOT		  ;;
	 XLATT ALT_CASE 		  ;;
       ENDIFF				  ;;
     ELSEF				  ;;
       IFF EITHER_ALT,NOT		  ;;
	 XLATT CTRL_CASE		  ;;
       ENDIFF				  ;;
     ENDIFF				  ;;
     IFF EITHER_CTL			  ;;
     ANDF ALT_SHIFT			  ;;
     ANDF R_ALT_SHIFT,NOT		  ;;
	XLATT ALT_CASE			  ;;
     ENDIFF				  ;;
   ENDIFF				  ;;
					  ;;
   EXIT_STATE_LOGIC			  ;;
					  ;;
LOGIC_END:				  ;;
					  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; BE Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC FR1_COMMON_XLAT 		;;
FR1_COMMON_XLAT:			;;
				       ;;
   DW	 COMMON_XLAT_END-$	       ;; length of section
   DW	 -1			       ;; code page
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: G + P
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K1_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 G_KB			       ;P12_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_ALT_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 6			       ;;8  Number of entries
;   DB	  12,-1,-1			;;
;   DB	  13,0,82H			;;
   DB	 16,0,1EH		       ;; A
   DB	 17,0,2CH		       ;; Z
   DB	 30,0,10H		       ;; Q
   DB	 39,0,32H		       ;; M
   DB	 44,0,11H		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_ALT_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_ALT_K1_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;***************************************** CNS P12 Addition *****************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_PK1_END-$		;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 P12_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_ALT_PK1_T1_END-$		;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 6			       ;; 10 Number of entries
;  DB	 12,-1,-1		       ;; invalid key U.S. alt -
;  DB	 13,-1,-1		       ;; invalid key U.S. alt =
;  DB	 07,0,82H		       ;; alt - (minus sign)
;  DB	 13,0,83H		       ;; alt = (equal sign)
   DB	 16,0,1EH		       ;; A
   DB	 17,0,2CH		       ;; Z
   DB	 30,0,10H		       ;; Q
   DB	 39,0,32H		       ;; M
   DB	 44,0,11H		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_ALT_PK1_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_ALT_PK1_END:			;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;***************************************** CNS P12 Addition *****************
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: GKB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K1_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 G_KB			       ;P12_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_K1_T1_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 10			       ;; Number of entries
   DB	 12,-1,-1		       ;;
   DB	 13,31,13		       ;;
   DB	 16,01,16		       ;; A
   DB	 17,26,17		       ;; Z
   DB	 30,17,30		       ;; Q
   DB	 39,13,39		       ;; M
   DB	 43,-1,-1		       ;; \
   DB	 44,23,44		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
   DB	 86,28,86		       ;;
COM_CTRL_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_K1_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;***************************************** CNS P12 Addition *****************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_PK1_END-$		;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 P12_KB 		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_PK1_T1_END-$		;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 12			       ;; Number of entries
   DB	 12,-1,-1		       ;;
   DB	 07,30,07		       ;; ctl + number six key
   DB	 12,29,12		       ;; ctl + ]
   DB	 13,31,13		       ;;
   DB	 16,01,16		       ;; A
   DB	 17,26,17		       ;; Z
   DB	 30,17,30		       ;; Q
   DB	 39,13,39		       ;; M
   DB	 43,-1,-1		       ;; \
   DB	 44,23,44		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
   DB	 9,28,9 		      ;;  \ position (this is also the underscore position)
COM_CTRL_PK1_T1_END:			;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_PK1_END:			;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;***************************************** CNS P12 Addition *****************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: AT + XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_ALT_K2_END-$	       ;; length of state section
   DB	 ALT_CASE		       ;; State ID
   DW	 AT_KB+XT_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_ALT_K2_T2_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 6			       ;; 9 Number of entries
;  DB	 12,-1,-1		       ;; invalid key U.S. alt -
;  DB	 13,0,82H		       ;; alt - (minus sign)
;  DB	 53,0,83H		       ;; alt = (equal sign)
   DB	 16,0,1EH		       ;; A
   DB	 17,0,2CH		       ;; Z
   DB	 30,0,10H		       ;; Q
   DB	 39,0,32H		       ;; M
   DB	 44,0,11H		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_ALT_K2_T2_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_ALT_K2_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K2_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_K2_T2_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 10;11				   ;; Number of entries
   DB	 12,-1,-1		       ;; invalid U.S. -
   DB	 43,-1,-1		       ;; invalid U.S. \
   DB	 41,28,41		       ;; valid ctl + \
   DB	 07,30,07		       ;; ctl + number six key
;  DB	 13,31,13		       ;; ctl - or _
   DB	 16,01,16		       ;; A
   DB	 17,26,17		       ;; Z
   DB	 30,17,30		       ;; Q
   DB	 39,13,39		       ;; M
   DB	 44,23,44		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_CTRL_K2_T2_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_K2_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CTRL_K3_END-$	       ;; length of state section
   DB	 CTRL_CASE		       ;; State ID
   DW	 AT_KB+XT_KB		       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 COM_CTRL_K3_T3_END-$	       ;; Size of xlat table
   DB	 TYPE_2_TAB		       ;;
   DB	 6			       ;; Number of entries
   DB	 12,-1,-1		       ;;
   DB	 43,-1,-1		       ;;
   DB	 43,28,43		       ;; valid ctl + \
   DB	 07,30,07		       ;; ctl + number six key
;  DB	 13,31,13		       ;; ctl - or _
   DB	 16,01,16		       ;; A
   DB	 17,26,17		       ;; Z
   DB	 30,17,30		       ;; Q
   DB	 39,13,39		       ;; M
   DB	 44,23,44		       ;; W
   DB	 50,-1,-1		       ;; U.S. 'M'
COM_CTRL_K3_T3_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CTRL_K3_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Lower Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_LO_END-$	       ;; length of state section
   DB	 DEAD_LOWER		       ;; State ID
   DW	 G_KB+AT_KB+XT_KB+P12_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  CIRCUMFLEX		       ;; flag bit to set
				       ;;
				       ;;
COM_DK_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;*************************************** CNS P12 Addition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Upper Shift Dead Key
;; KEYBOARD TYPES: All
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_UP_END-$	       ;; length of state section
   DB	 DEAD_UPPER		       ;; State ID
   DW	 G_KB+AT_KB+XT_KB+P12_KB		 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 1			       ;; number of entries
   DB	 26			       ;; scan code
   FLAG  DIARESIS		       ;; flag bit to set
				       ;;
COM_DK_UP_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: G, AT
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_TH_END-$	       ;; length of state section
   DB	 DEAD_THIRD		       ;; State ID
   DW	 G_KB+AT_KB		;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 3			       ;; number of entries
   DB	40			       ;;
   FLAG ACUTE			       ;;
   DB	43			       ;;
   FLAG GRAVE			       ;;
   DB	53			       ;;
   FLAG TILDE			       ;;
				       ;;
COM_DK_TH_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;***************************************** CNS P12 Addition *****************
;NO THRD SHIFT DEAD KEY FOR THE P12
;***************************************** CNS P12 Addition *****************
;; CODE PAGE: Common
;; STATE: Third Shift Dead Key
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Flag Table
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DK_TH_K1_END-$	       ;; length of state section
   DB	 DEAD_THIRD		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;; Set Flag Table
   DW	 3			       ;; number of entries
   DB	40			       ;;
   FLAG ACUTE			       ;;
   DB	41			       ;;
   FLAG GRAVE			       ;;
   DB	53			       ;;
   FLAG TILDE			       ;;
				       ;;
COM_DK_TH_K1_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;********************************************** CNS P12 Addition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_LO_END-$	       ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_DI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 21,''                        ;; scan code,ASCII - y
COM_DI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;********************************************** CNS P12 Addition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common		       ;;change **********CNS **************
;; STATE: Numeric Key Pad
;; KEYBOARD TYPES: All except the p12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_PAD_K1_END-$	       ;; length of state section
   DB	 NUMERIC_PAD		       ;; State ID
   DW	 G_KB+AT_KB+XT_KB	       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_PAD_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of entries
   DB	 83,','                        ;; decimal seperator = ,
COM_PAD_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_PAD_K1_END: 		       ;;
				       ;;
;**************************************************** CODE eliminated**********
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	      NUM PAD altered  ********
;; CODE PAGE: 850				      CNS engraved "," out
;; STATE: Numeric Pad - Divide Sign
;; KEYBOARD TYPES: G
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;					;;
;; DW	 CP850_DIVID_END-$	       ;; length of state section
;; DB	 DIVIDE_SIGN		       ;; State ID
;; DW	 G_KB+P12_KB		       ;; Keyboard Type
;; DB	 -1,-1			       ;; error character = standalone accent
;;				       ;;
;; DW	 CP850_DIVID_T1_END-$	       ;; Size of xlat table
;; DB	 TYPE_2_TAB		       ;; xlat options:
;; DB	 2			       ;; number of scans
;; DB	 0E0H,',',0E0H                ;; DIVIDE SIGN
;; DB	 51,',',0E0H                  ;;
;; CP850_DIVID_T1_END:			  ;;
;;					  ;;
;;    DW    0				  ;; Size of xlat table - null table
;;					  ;;
;; CP850_DIVID_END:			  ;;
;;					  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Numeric Key Pad - Multiplication
;; KEYBOARD TYPES: G,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;				       ;;
;; DW	 CP850_PAD_K1_END-$	       ;; length of state section
;; DB	 NUMERIC_PAD		       ;; State ID
;; DW	 G_KB			     ;; Keyboard Type
;; DB	 -1,-1			       ;; Buffer entry for error character
;;				       ;;
;; DW	 CP850_PAD_K1_T1_END-$	       ;; Size of xlat table
;; DB	 STANDARD_TABLE 	       ;; xlat options:
;; DB	 1			       ;; number of entries
;; DB	 51,',' ; (removed *** CNS ****)  ;; MULTIPLICATION SIGN
;;  CP850_PAD_K1_T1_END:		   ;;
;;					   ;;
;;     DW    0				   ;; Size of xlat table - null table
;;					   ;;
;;  CP850_PAD_K1_END:			   ;;
;;					   ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;*********************************************************
;; CODE PAGE: Common
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_LO_END-$	       ;; length of state section
   DB	 ALPHA_LOWER		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 16,'a'                        ;; small a
   DB	 17,'z'                        ;; small z
   DB	 30,'q'                        ;; small q
   DB	 39,'m'                        ;; small m
   DB	 44,'w'                        ;; small w
COM_AL_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AL_UP_END-$	       ;; length of state section
   DB	 ALPHA_UPPER		       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_AL_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 5			       ;; number of entries
   DB	 16,'A'                        ;; caps  A
   DB	 17,'Z'                        ;; caps  Z
   DB	 30,'Q'                        ;; caps  Q
   DB	 39,'M'                        ;; caps  M
   DB	 44,'W'                        ;; caps  W
COM_AL_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AL_UP_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB			       ;P12_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	 41,""                        ;; superscript 2
   DB	  2,"&"                        ;;
   DB	  3,""                        ;; acute - e
   DB	  4,'"'                        ;;
   DB	  5,"'"                        ;;
   DB	  6,"("                        ;;
   DB	  8,""                        ;; grave - e
   DB	  9,"!"                        ;;
   DB	 10,""                        ;; c - cedilla small
   DB	 11,""                        ;;
   DB	 12,")"                        ;;
   DB	 13,"-"                        ;;
   DB	 27,"$"                        ;;
   DB	 40,""                        ;; grave - u
   DB	 43,0E6H		       ;; mu
   DB	 86,'<'                        ;;
   DB	 50,','                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'='                        ;;
COM_NA_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_END:			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;***************************************** CNS P12 Addition *****************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_PK1_END-$		   ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 P12_KB 		  ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_PT1_K1_END-$ 	   ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 21			       ;; number of entries
   DB	 41,""                        ;; superscript 2
   DB	  2,"&"                        ;;
   DB	  3,""                        ;; acute - e
   DB	  4,'"'                        ;;
   DB	  5,"'"                        ;;
   DB	  6,"("                        ;;
   DB	  7,"-"                        ;;
   DB	  8,""                        ;; grave - e
   DB	  9,"_"                        ;;
   DB	 10,""                        ;; c - cedilla small
   DB	 11,""                        ;;
   DB	 12,")"                        ;;
   DB	 13,"="                        ;;
   DB	 27,"$"                        ;;
   DB	 40,""                        ;; grave - u
   DB	 43,"*"                        ;;
   DB	 86,'<'                        ;; +
   DB	 50,','                        ;; <
   DB	 51,';'                        ;; -
   DB	 52,':'                        ;;
   DB	 53,'!'                        ;;

COM_NA_LO_PT1_K1_END:			   ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_PK1_END:			   ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;***************************************** CNS P12 Addition *****************
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES:AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K2_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_T1_K2_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 19			       ;; number of entries
   DB	 41,"<"                        ;;
   DB	  2,"&"                        ;;
   DB	  3,""                        ;; acute - e
   DB	  4,'"'                        ;;
   DB	  5,"'"                        ;;
   DB	  6,"("                        ;;
   DB	  8,""                        ;; grave - e
   DB	  9,"!"                        ;;
   DB	 10,""                        ;; c - cedilla small
   DB	 11,""                        ;;
   DB	 12,")"                        ;;
   DB	 13,"-"                        ;;
   DB	 27,"$"                        ;;
   DB	 40,""                        ;; grave - u
   DB	 43,0E6H		       ;; mu
   DB	 50,','                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'='                        ;;
COM_NA_LO_T1_K2_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K2_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_LO_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_LO_K1_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 19			       ;; number of entries
   DB	  2,"&"                        ;;
   DB	  3,""                        ;; acute - e
   DB	  4,'"'                        ;;
   DB	  5,"'"                        ;;
   DB	  6,"("                        ;;
   DB	  8,""                        ;;
   DB	  9,"!"                        ;;
   DB	 10,""                        ;; c - cedilla small
   DB	 11,""                        ;;
   DB	 12,")"                        ;;
   DB	 13,"-"                        ;;
   DB	 27,"$"                        ;;
   DB	 40,""                        ;; grave - u
   DB	 41,0E6H		       ;; mu
   DB	 43,'<'                        ;;
   DB	 50,','                        ;;
   DB	 51,';'                        ;;
   DB	 52,':'                        ;;
   DB	 53,'='                        ;;
COM_NA_LO_K1_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_LO_K1_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB			       ;+P12_KB 		  ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 21			       ;; number of entries
   DB	  2,'1'                        ;;
   DB	  3,'2'                        ;;
   DB	  4,'3'                        ;;
   DB	  5,'4'                        ;;
   DB	  6,'5'                        ;;
   DB	  7,'6'                        ;;
   DB	  8,'7'                        ;;
   DB	  9,'8'                        ;;
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0F8H		       ;; degree symbol
   DB	 13,"_"                        ;;
   DB	 27,"*"                        ;;
   DB	 40,'%'                        ;;
   DB	 41,0FCH                       ;; Superscript 3
   DB	 43,''                        ;;
   DB	 86,'>'                        ;;
   DB	 50,'?'                        ;;
   DB	 51,'.'                        ;;
   DB	 52,'/'                        ;;
   DB	 53,'+'                        ;;
COM_NA_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_END:			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;***************************************** CNS P12 Addition *****************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_PK1_END-$		   ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 P12_KB 		  ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_PT1_K1_END-$ 	;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 21			       ;; number of entries
   DB	  2,'1'                        ;;
   DB	  3,'2'                        ;;
   DB	  4,'3'                        ;;
   DB	  5,'4'                        ;;
   DB	  6,'5'                        ;;
   DB	  7,'6'                        ;;
   DB	  8,'7'                        ;;
   DB	  9,'8'                        ;;
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0F8H		       ;; degree symbol
   DB	 13,"+"                        ;; plus sign
   DB	 27,09CH		       ;;  symbol
   DB	 40,'%'                        ;;
   DB	 41,""                        ;; superscript 3
   DB	 43,0E6H		       ;;  - mu symbol
   DB	 86,'>'                        ;;
   DB	 50,'?'                        ;;
   DB	 51,'.'                        ;;
   DB	 52,'/'                        ;;
   DB	 53,'+'                        ;;
COM_NA_UP_PT1_K1_END:			   ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_PK1_END:			   ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;***************************************** CNS P12 Addition *****************
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT +
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K1_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	 41,''                        ;;
   DB	  2,'1'                        ;;
   DB	  3,'2'                        ;;
   DB	  4,'3'                        ;;
   DB	  5,'4'                        ;;
   DB	  6,'5'                        ;;
   DB	  7,'6'                        ;;
   DB	  8,'7'                        ;;
   DB	  9,'8'                        ;;
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0F8H		       ;; degree symbol
   DB	 13,"_"                        ;;
   DB	 27,"*"                        ;;
   DB	 40,'%'                        ;;
   DB	 43,'>'                        ;;
   DB	 50,'?'                        ;;
   DB	 51,'.'                        ;;
   DB	 52,'/'                        ;;
   DB	 53,'+'                        ;;
COM_NA_UP_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K1_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_NA_UP_K2_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_NA_UP_T1_K2_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 20			       ;; number of entries
   DB	 41,'>'                        ;;
   DB	  2,'1'                        ;;
   DB	  3,'2'                        ;;
   DB	  4,'3'                        ;;
   DB	  5,'4'                        ;;
   DB	  6,'5'                        ;;
   DB	  7,'6'                        ;;
   DB	  8,'7'                        ;;
   DB	  9,'8'                        ;;
   DB	 10,'9'                        ;;
   DB	 11,'0'                        ;;
   DB	 12,0F8H		       ;; degree symbol
   DB	 13,"_"                        ;;
   DB	 27,"*"                        ;;
   DB	 40,'%'                        ;;
   DB	 43,''                        ;;
   DB	 50,'?'                        ;;
   DB	 51,'.'                        ;;
   DB	 52,'/'                        ;;
   DB	 53,'+'                        ;;
COM_NA_UP_T1_K2_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_NA_UP_K2_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: G,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 G_KB			       ;+P12_KB 		  ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  9			       ;; number of entries
   DB	  2,"|"                        ;;
   DB	  3,'@'                        ;;
   DB	  4,'#'                        ;;
   DB	  7,'^'                        ;;
   DB	 10,'{'                        ;;
   DB	 11,'}'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 86,'\'                        ;;
COM_THIRD_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;******************************************* CNS Addition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_AC_LO_END-$	       ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 P12_KB 		       ;;	   ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_AC_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
COM_AC_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_AC_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;******************************************* CNS Addition
;***************************************** CNS P12 Addition *****************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_PK1_END-$		   ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 P12_KB 		  ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_PT1_K1_END-$ 	   ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 11			       ;; number of entries
   DB	  3,'~'                        ;;
   DB	  4,'#'                        ;;
   DB	  5,'{'                        ;;
   DB	  6,'['                        ;;
   DB	  7,'|'                        ;;
   DB	  8,'`'                        ;; grave symbol not a dead key rep
   DB	  9,'\'                        ;;
   DB	 10,'^'                        ;; circumflex (caret)
   DB	 11,'@'                        ;;
   DB	 12,']'                        ;;
   DB	 13,'}'                        ;;
COM_THIRD_PT1_K1_END:			   ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_PK1_END:			   ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;***************************************** CNS P12 Addition *****************
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: XT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K1_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  9			       ;; number of entries
   DB	  2,"|"                        ;;
   DB	  3,'@'                        ;;
   DB	  4,'#'                        ;;
   DB	  7,'^'                        ;;
   DB	 10,'{'                        ;;
   DB	 11,'}'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 43,'\'                        ;;
COM_THIRD_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K1_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Third Shift
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_THIRD_K2_END-$	       ;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 AT_KB			       ;; Keyboard Type
   DB	 -1,-1			       ;; Buffer entry for error character
				       ;;
   DW	 COM_THIRD_T1_K2_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	  9			       ;; number of entries
   DB	  2,"|"                        ;;
   DB	  3,'@'                        ;;
   DB	  4,'#'                        ;;
   DB	  7,'^'                        ;;
   DB	 10,'{'                        ;;
   DB	 11,'}'                        ;;
   DB	 26,'['                        ;;
   DB	 27,']'                        ;;
   DB	 41,'\'                        ;;
COM_THIRD_T1_K2_END:		       ;;
				       ;;
   DW	 0			       ;; Last xlat table
COM_THIRD_K2_END:		       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Lower
;; KEYBOARD TYPES: ALL
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 COM_GR_LO_END-$		 ;; length of state section
   DB	 GRAVE_LOWER			 ;; State ID
   DW	 G_KB+AT_KB+XT_KB			   ;; Keyboard Type
   DB	 96,0				 ;; error character = standalone accent
					 ;;
   DW	 COM_GR_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 5				 ;; number of scans
   DB	 18,''                          ;; scan code,ASCII - e
   DB	 16,''                          ;; scan code,ASCII - a
   DB	 24,''                          ;; scan code,ASCII - o
   DB	 22,''                          ;; scan code,ASCII - u
   DB	 23,''                          ;; scan code,ASCII - i
COM_GR_LO_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
COM_GR_LO_END:				 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_GR_UP_END-$	       ;; length of state section
   DB	 GRAVE_UPPER		       ;; State ID
   DW	 G_KB+AT_KB+XT_KB			 ;; Keyboard Type
   DB	 96,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_GR_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 0			       ;; number of scans
COM_GR_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_GR_UP_END:			       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Grave Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 COM_GR_SP_END-$		 ;; length of state section
   DB	 GRAVE_SPACE			 ;; State ID
   DW	 G_KB+AT_KB+XT_KB			   ;; Keyboard Type
   DB	 96,0				 ;; error character = standalone accent
					 ;;
   DW	 COM_GR_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 57,96				 ;; STANDALONE GRAVE
COM_GR_SP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
COM_GR_SP_END:				 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_LO_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_LOWER	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
COM_CI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_LO_END:			       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Upper
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_UP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_UPPER	       ;; State ID
   DW	 G_KB+AT_KB+XT_KB			 ;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 0			       ;; number of scans
COM_CI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;;
				       ;;
COM_CI_UP_END:			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Circumflex Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_CI_SP_END-$	       ;; length of state section
   DB	 CIRCUMFLEX_SPACE	       ;; State ID
   DW	 G_KB+P12_KB+AT_KB+XT_KB			;; Keyboard Type
   DB	 94,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_CI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,94			       ;; STANDALONE CIRCUMFLEX
COM_CI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_CI_SP_END:			       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Tilde Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 COM_TI_SP_END-$		 ;; length of state section
   DB	 TILDE_SPACE			 ;; State ID
   DW	 G_KB+AT_KB+XT_KB			   ;; Keyboard Type
   DB	 126,0				 ;; error character = standalone accent
					 ;;
   DW	 COM_TI_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 57,126 			 ;; STANDALONE TIDLE
COM_TI_SP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
COM_TI_SP_END:				 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	 0			       ;; Last State
COMMON_XLAT_END:		       ;;
				       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; BE Specific Translate Section for 437
;;
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC FR1_437_XLAT			;;
FR1_437_XLAT:				;;
				       ;;
   DW	  CP437_XLAT_END-$	       ;; length of section
   DW	  437			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_LO_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+AT_KB+XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP437_NA_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of scans
   DB	7,15H			       ;; Section Symbol
CP437_NA_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;**************************************** CNS Addition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: p12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_UP_K1_END-$		  ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 P12_KB 		  ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP437_NA_UP_T1_K1_END-$	  ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options: **** CNS 12/18
   DB	 1			       ;; number of scans
   DB	 53,015H		       ;; Section symbol - 
CP437_NA_UP_T1_K1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_UP_K1_END:			  ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;**************************************** CNS Addition
;; CODE PAGE: 437
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G,
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_NA_UP_END-$	       ;; length of state section
   DB	 NON_ALPHA_UPPER	       ;; State ID
   DW	 G_KB			       ;+P12_KB 		  ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP437_NA_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of scans
   DB	41,00H			       ;; 3 Superscript
CP437_NA_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_NA_UP_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;***************************************** CNS P12 Addition *****************
;***************************************** CNS P12 Addition *****************
;; CODE PAGE: CP437
;; STATE: Acute Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_AC_LO_END-$	       ;; length of state section
   DB	 ACUTE_LOWER		       ;; State ID
   DW	 G_KB+AT_KB+XT_KB			 ;; Keyboard Type
   DB	 39,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_AC_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 5			       ;; number of scans
   DB	 16,''                        ;; a acute
   DB	 18,''                        ;; e acute
   DB	 23,''                        ;; i acute
   DB	 24,''                        ;; o acute
   DB	 22,''                        ;; u acute
CP437_AC_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_AC_LO_END:		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Acute Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP437_AC_UP_END-$		 ;; length of state section
   DB	 ACUTE_UPPER			 ;; State ID
   DW	 G_KB+AT_KB+XT_KB			   ;; Keyboard Type
   DB	 39,0				 ;; error character = standalone accent
					 ;;
   DW	 CP437_AC_UP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 18,''                          ;; scan code,ASCII - e
CP437_AC_UP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP437_AC_UP_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Acute Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP437_AC_SP_END-$		 ;; length of state section
   DB	 ACUTE_SPACE			 ;; State ID
   DW	 G_KB+AT_KB+XT_KB			   ;; Keyboard Type
   DB	 39,0				 ;; error character = standalone accent
					 ;;
   DW	 CP437_AC_SP_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 57,39				 ;; scan code,ASCII - SPACE
CP437_AC_SP_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP437_AC_SP_END:			 ;;
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Tilde Lower
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					 ;;
   DW	 CP437_TI_LO_END-$		 ;; length of state section
   DB	 TILDE_LOWER			 ;; State ID
   DW	 G_KB+AT_KB+XT_KB			   ;; Keyboard Type
   DB	 126,0				 ;; error character = standalone accent
					 ;;
   DW	 CP437_TI_LO_T1_END-$		 ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN	 ;; xlat options:
   DB	 1				 ;; number of scans
   DB	 49,164 			 ;; scan code,ASCII - n
CP437_TI_LO_T1_END:			 ;;
					 ;;
   DW	 0				 ;; Size of xlat table - null table
					 ;;
CP437_TI_LO_END:			 ;; length of state section
					 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Tilde Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_TI_UP_END-$	       ;; length of state section
   DB	 TILDE_UPPER		       ;; State ID
   DW	 G_KB+AT_KB+XT_KB			 ;; Keyboard Type
   DB	 126,0			       ;; error character = standalone accent
				       ;;
   DW	 CP437_TI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 49,165 		       ;; scan code,ASCII - N
CP437_TI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_TI_UP_END:		       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Diaresis Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_DI_LO_END-$	       ;; length of state section
   DB	 DIARESIS_LOWER 	       ;; State ID
   DW	 G_KB+AT_KB+XT_KB	       ;; Keyboard Type
   DB	 0FEH,0 		       ;; error character = standalone accent
				       ;;
   DW	 CP437_DI_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 6			       ;; number of scans
   DB	 18,''                        ;; scan code,ASCII - e
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
   DB	 23,''                        ;; scan code,ASCII - i
   DB	 21,''                        ;; scan code,ASCII - y
CP437_DI_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_DI_LO_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_DI_UP_END-$	       ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 G_KB+AT_KB+XT_KB			 ;; Keyboard Type
   DB	 0FEH,0 		       ;; error character = standalone accent
				       ;;
   DW	 CP437_DI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
CP437_DI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_DI_UP_END:		       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Upper Case
;; KEYBOARD TYPES: P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_UP_END-$	       ;; length of state section
   DB	 DIARESIS_UPPER 	       ;; State ID
   DW	 P12_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_DI_UP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 3			       ;; number of scans
   DB	 16,''                        ;; scan code,ASCII - a
   DB	 24,''                        ;; scan code,ASCII - o
   DB	 22,''                        ;; scan code,ASCII - u
COM_DI_UP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
COM_DI_UP_END:			       ;; length of state section
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 COM_DI_SP_END-$	       ;; length of state section
   DB	 DIARESIS_SPACE 	       ;; State ID
   DW	 P12_KB 		       ;; Keyboard Type
   DB	 249,0			       ;; error character = standalone accent
				       ;;
   DW	 COM_DI_SP_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 57,249 		       ;; error character = standalone accent
COM_DI_SP_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
COM_DI_SP_END:			       ;; length of state section
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;***************************************** CNS P12 Addition *****************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 437    ???????????????????May need change....
;; STATE: Third Shift
;; KEYBOARD TYPES: P12
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP437_THIRD_PEND-$		;; length of state section
   DB	 THIRD_SHIFT		       ;; State ID
   DW	 P12_KB 		  ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP437_THIRD_T1_PEND-$		;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options: *** CNS 12/18
   DB	 1			       ;; number of scans
   DB	 27,'$'                        ;; dollar currency symbol
CP437_THIRD_T1_PEND:			;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP437_THIRD_PEND:			;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;***************************************** CNS P12 Addition *****************
;; CODE PAGE: CP437
;; STATE: Diaresis Space Bar
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;				       ;;
;  DW	 CP437_DI_SP_END-$	       ;; length of state section
;  DB	 DIARESIS_SPACE 	       ;; State ID
;  DW	 G_KB+AT_KB+XT_KB			 ;; Keyboard Type
;  DB	 0FEH,0 		       ;; error character = standalone accent
;				       ;;
;  DW	 CP437_DI_SP_T1_END-$	       ;; Size of xlat table
;  DB	 STANDARD_TABLE+ZERO_SCAN      ;; xlat options:
;  DB	 1			       ;; number of scans
;  DB	 57,0FEH		       ;; error character = standalone accent
;CP437_DI_SP_T1_END:		       ;;
;				       ;;
;  DW	 0			       ;; Size of xlat table - null table
;CP437_DI_SP_END:		       ;; length of state section
;				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW	  0			       ;; LAST STATE
				       ;;
CP437_XLAT_END: 		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; BE Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
 PUBLIC FR1_850_XLAT			;;
FR1_850_XLAT:				;;
				       ;;
   DW	  CP850_XLAT_END-$	       ;; length of section
   DW	  850			       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
   DW	 CP850_NA_LO_END-$	       ;; length of state section
   DB	 NON_ALPHA_LOWER	       ;; State ID
   DW	 G_KB+AT_KB+XT_KB			 ;; Keyboard Type
   DB	 -1,-1			       ;; default ignore error state
				       ;;
   DW	 CP850_NA_LO_T1_END-$	       ;; Size of xlat table
   DB	 STANDARD_TABLE 	       ;; xlat options:
   DB	 1			       ;; number of scans
   DB	 7,0F5H 		       ;; Section symbol - 
CP850_NA_LO_T1_END:		       ;;
				       ;;
   DW	 0			       ;; Size of xlat table - null table
				       ;;
CP850_NA_LO_END:		       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;**************************************** CNS Addition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: 850
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: P12
;; TABLE TYPE: Translate
;;;;;;;;;;;