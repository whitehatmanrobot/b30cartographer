          if (FAILED(hr = GetBasicShowInfo(&s_pShowInfo)))
                ReportError(IDS_COMPONENTFILESPROBLEM, hr);
            LeaveCrashProtection( DXD_IN_SI_KEY, DXD_IN_SI_VALUE, 3 );
        }
    }
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    // Stop if the UI thread is gone 
    if( s_hUIThread != NULL && WAIT_TIMEOUT != WaitForSingleObject( s_hUIThread, 0 ) )
        return S_FALSE;

    // ******* DiagnoseDxFiles ********
    DiagnoseDxFiles(&s_sysInfo, s_pDxComponentsFileInfoFirst, 
                    s_pDxWinComponentsFileInfoFirst);
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        
    
    // ******* DiagnoseDisplay ********
    DiagnoseDisplay(&s_sysInfo, s_pDisplayInfoFirst);
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        
    
    // ******* DiagnoseSound ********
    DiagnoseSound(s_pSoundInfoFirst);
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        
    
    // ******* DiagnoseInput ********
    DiagnoseInput(&s_sysInfo, s_pInputInfo);
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        
    
    // ******* DiagnoseMusic ********
    DiagnoseMusic(&s_sysInfo, s_pMusicInfo);
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    // ******* DiagnoseNetInfo ********
    DiagnoseNetInfo(&s_sysInfo, s_pNetInfo);
    SendMessage( s_hwndMain, WM_APP_PROGRESS, 0, 0 );        

    return S_OK;
}


/****************************************************************************
 *
 *  SaveInfo
 *
 ****************************************************************************/
VOID SaveInfo(VOID)
{
    HRESULT hr;
    OPENFILENAME ofn;
    TCHAR szFile[MAX_PATH];
    TCHAR szFilter[MAX_PATH];
    TCHAR szExt[MAX_PATH];
    TCHAR* pch = NULL;

    LoadString(NULL, IDS_FILTER, szFilter, MAX_PATH);
    // Filter strings are weird because they contain nulls.
    // The string loaded from a resource has # where nulls
    // should be inserted.
    for (pch = szFilter; *pch != TEXT('\0'); pch++)
    {
        if (*pch == TEXT('#'))
            *pch = TEXT('\0');
    }

    LoadString(NULL, IDS_DEFAULTFILENAME, szFile, MAX_PATH);
    LoadString(NULL, IDS_DEFAULTEXT, szExt, MAX_PATH);

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = s_hwndMain;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY;
    ofn.lpstrDefExt = szExt;

    TCHAR szInitialPath[MAX_PATH];
    if( FALSE == GetTxtPath( szInitialPath ) )
        ofn.lpstrInitialDir = NULL;
    else
        ofn.lpstrInitialDir = szInitialPath;

    if (GetSaveFileName(&ofn))
    {
        lstrcpy( szInitialPath, ofn.lpstrFile );
        TCHAR* strLastSlash = _tcsrchr(szInitialPath, '\\' );
        if( NULL != strLastSlash )
        {
            *strLastSlash = 0;
            SetTxtPath( szInitialPath );
        }

        if (FAILED(hr = SaveAllInfo(ofn.lpstrFile, &s_sysInfo, 
            s_pDxWinComponentsFileInfoFirst, s_pDxComponentsFileInfoFirst, 
            s_pDisplayInfoFirst, s_pSoundInfoFirst, s_pMusicInfo,
            s_pInputInfo, s_pNetInfo, s_pShowInfo)))
        {
        }
    }
}


/****************************************************************************
 *
 *  ToggleDDAccel
 *
 ****************************************************************************/
VOID ToggleDDAccel(VOID)
{
    HRESULT hr;
    TCHAR szTitle[MAX_PATH];
    TCHAR szMessage[MAX_PATH];
    BOOL bEnabled = IsDDHWAccelEnabled();
    HKEY hkey;
    DWORD dwData;

    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
    if (bEnabled)
        LoadString(NULL, IDS_DISABLEDDWARNING, szMessage, MAX_PATH);
    else
        LoadString(NULL, IDS_ENABLEDDWARNING, szMessage, MAX_PATH);
    if (IDOK == MessageBox(s_hwndMain, szMessage, szTitle, MB_OKCANCEL))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            TEXT("SOFTWARE\\Microsoft\\DirectDraw"), 0, KEY_ALL_ACCESS, &hkey))
        {
            if (bEnabled) // if acceleration enabled
                dwData = TRUE; // force emulation
            else
                dwData = FALSE; // disable emulation
            if (ERROR_SUCCESS != RegSetValueEx(hkey, TEXT("EmulationOnly"), NULL, 
                REG_DWORD, (BYTE *)&dwData, sizeof(dwData)))
            {
                // TODO: report error
                RegCloseKey(hkey);
                return;

            }
            RegCloseKey(hkey);
        }
        else
        {
            // TODO: report error
            return;
        }
    }

    // update all DisplayInfo to reflect new state:

    // ******* GetExtraDisplayInfo (DD:2) ********
    if( s_bUseDisplay )
    {
        s_bUseDisplay = QueryCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, IDS_DD, 2 );
        if( s_bUseDisplay )
        {
            EnterCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 2 );
            if (FAILED(hr = GetExtraDisplayInfo(s_pDisplayInfoFirst)))
                ReportError(IDS_NOEXTRADISPLAYINFO, hr);
            LeaveCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 2 );
        }
    }

    // ******* GetDDrawDisplayInfo (DD:3) ********
    if( s_bUseDisplay )
    {
        s_bUseDisplay = QueryCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, IDS_DD, 3 );
        if( s_bUseDisplay )
        {
            EnterCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 3 );
            if(FAILED(hr = GetDDrawDisplayInfo(s_pDisplayInfoFirst)))
                ReportError(IDS_NOEXTRADISPLAYINFO, hr); 
            LeaveCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 3 );
        }
    }

    SetupDisplayPage(s_lwCurPage - s_iPageDisplayFirst); // refresh page
}


/****************************************************************************
 *
 *  ToggleD3DAccel
 *
 ****************************************************************************/
VOID ToggleD3DAccel(VOID)
{
    TCHAR szTitle[MAX_PATH];
    TCHAR szMessage[MAX_PATH];
    BOOL bEnabled = IsD3DHWAccelEnabled();
    HKEY hkey;
    DWORD dwData;

    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
    if (bEnabled)
        LoadString(NULL, IDS_DISABLED3DWARNING, szMessage, MAX_PATH);
    else
        LoadString(NULL, IDS_ENABLED3DWARNING, szMessage, MAX_PATH);
    if (IDOK == MessageBox(s_hwndMain, szMessage, szTitle, MB_OKCANCEL))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            TEXT("SOFTWARE\\Microsoft\\Direct3D\\Drivers"), 0, KEY_WRITE, &hkey))
        {
            if (bEnabled) // if acceleration enabled
                dwData = TRUE; // force emulation
            else
                dwData = FALSE; // disable emulation
            if (ERROR_SUCCESS != RegSetValueEx(hkey, TEXT("SoftwareOnly"), NULL, 
                REG_DWORD, (BYTE *)&dwData, sizeof(dwData)))
            {
                // TODO: report error
                RegCloseKey(hkey);
                return;

            }
            RegCloseKey(hkey);
            // update all DisplayInfo to reflect new state:
            DisplayInfo* pDisplayInfo;
            for (pDisplayInfo = s_pDisplayInfoFirst; pDisplayInfo != NULL; 
                pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
            {
                pDisplayInfo->m_b3DAccelerationEnabled = !bEnabled;
            }
        }
        else
        {
            // TODO: report error
            return;
        }
    }
    SetupDisplayPage(s_lwCurPage - s_iPageDisplayFirst); // refresh page
}


/****************************************************************************
 *
 *  ToggleAGPSupport
 *
 ****************************************************************************/
VOID ToggleAGPSupport(VOID)
{
    HRESULT hr;
    TCHAR szTitle[MAX_PATH];
    TCHAR szMessage[MAX_PATH];
    BOOL bEnabled = IsAGPEnabled();
    HKEY hkey;
    DWORD dwData;

    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
    if (bEnabled)
        LoadString(NULL, IDS_DISABLEAGPWARNING, szMessage, MAX_PATH);
    else
        LoadString(NULL, IDS_ENABLEAGPWARNING, szMessage, MAX_PATH);
    if (IDOK == MessageBox(s_hwndMain, szMessage, szTitle, MB_OKCANCEL))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            TEXT("SOFTWARE\\Microsoft\\DirectDraw"), 0, KEY_WRITE, &hkey))
        {
            if (bEnabled) // if AGP enabled
                dwData = TRUE; // disable
            else
                dwData = FALSE; // enable
            if (ERROR_SUCCESS != RegSetValueEx(hkey, TEXT("DisableAGPSupport"), NULL, 
                REG_DWORD, (BYTE *)&dwData, sizeof(dwData)))
            {
                // TODO: report error
                RegCloseKey(hkey);
                return;

            }
            RegCloseKey(hkey);
            // update all DisplayInfo to reflect new state:
            DisplayInfo* pDisplayInfo;
            for (pDisplayInfo = s_pDisplayInfoFirst; pDisplayInfo != NULL; 
                pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
            {
                pDisplayInfo->m_bAGPEnabled = !bEnabled;
            }
        }
        else
        {
            // TODO: report error
            return;
        }
    }

    // ******* GetDDrawDisplayInfo (DD:3) ********
    if( s_bUseDisplay )
    {
        s_bUseDisplay = QueryCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, IDS_DD, 3 );
        if( s_bUseDisplay )
        {
            EnterCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 3 );
            if(FAILED(hr = GetDDrawDisplayInfo(s_pDisplayInfoFirst)))
                ReportError(IDS_NOEXTRADISPLAYINFO, hr); 
            LeaveCrashProtection( DXD_IN_DD_KEY, DXD_IN_DD_VALUE, 3 );
        }
    }

    SetupDisplayPage(s_lwCurPage - s_iPageDisplayFirst); // refresh page
}


/****************************************************************************
 *
 *  ToggleDMAccel
 *
 ****************************************************************************/
VOID ToggleDMAccel(VOID)
{
    HRESULT hr;
    TCHAR szTitle[MAX_PATH];
    TCHAR szMessage[MAX_PATH];
    BOOL bEnabled = s_pMusicInfo->m_bAccelerationEnabled;
    HKEY hkey;
    DWORD dwData;

    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
    if (bEnabled)
        LoadString(NULL, IDS_DISABLEDMWARNING, szMessage, MAX_PATH);
    else
        LoadString(NULL, IDS_ENABLEDMWARNING, szMessage, MAX_PATH);
    if (IDOK == MessageBox(s_hwndMain, szMessage, szTitle, MB_OKCANCEL))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
            TEXT("SOFTWARE\\Microsoft\\DirectMusic"), 0, KEY_ALL_ACCESS, &hkey))
        {
            if (bEnabled) // if acceleration enabled
            {
                dwData = TRUE; // force emulation
                if (ERROR_SUCCESS != RegSetValueEx(hkey, TEXT("DisableHWAcceleration"), NULL, 
                    REG_DWORD, (BYTE *)&dwData, sizeof(dwData)))
                {
                    // TODO: report error
                    RegCloseKey(hkey);
                    return;

                }
            }
            else
            {
                if (ERROR_SUCCESS != RegDeleteValue( hkey, TEXT("DisableHWAcceleration") ))
                {
                    // TODO: report error
                    RegCloseKey(hkey);
                    return;

                }
            }
            RegCloseKey(hkey);
        }
        else
        {
            // TODO: report error
            return;
        }
    }

    // update all MusicInfo to reflect new state:
    if (s_pMusicInfo != NULL)
        DestroyMusicInfo(s_pMusicInfo);

    // ******* GetBasicMusicInfo (DM:1)  ********
    if( s_bUseDMusic )
    {
        s_bUseDMusic = QueryCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, IDS_DM, 1 );
        if( s_bUseDMusic )
        {
            EnterCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 1 );
            if (FAILED(hr = GetBasicMusicInfo(&s_pMusicInfo)))
                ReportError(IDS_NOBASICMUSICINFO, hr);  
            LeaveCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 1 );
        }
    }

    // ******* GetExtraMusicInfo (DM:2) *******
    if( s_bUseDMusic )
    {
        s_bUseDMusic = QueryCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, IDS_DM, 2 );
        if( s_bUseDMusic )
        {
            EnterCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 2 );
            if (FAILED(hr = GetExtraMusicInfo(s_pMusicInfo)))
                ReportError(IDS_NOBASICMUSICINFO, hr);  
            LeaveCrashProtection( DXD_IN_DM_KEY, DXD_IN_DM_VALUE, 2 );
        }
    }

    if (s_pMusicInfo->m_pMusicPortFirst != NULL)
        s_pMusicInfo->m_guidMusicPortTest = s_pMusicInfo->m_pMusicPortFirst->m_guid;
    SetupMusicPage(); // refresh page
}


/****************************************************************************
 *
 *  OverrideDDRefresh
 *
 ****************************************************************************/
VOID OverrideDDRefresh(VOID)
{
    HINSTANCE hinst = (HINSTANCE)GetWindowLongPtr(s_hwndMain, GWLP_HINSTANCE);
    DialogBox(hinst, MAKEINTRESOURCE(IDD_OVERRIDEDD), s_hwndMain, 
        OverrideRefreshDialogProc);
}


/****************************************************************************
 *
 *  OverrideRefreshDialogProc
 *
 ****************************************************************************/
INT_PTR CALLBACK OverrideRefreshDialogProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    HWND hwndTabs = GetDlgItem(hwnd, IDC_TAB);
    HKEY hkey;
    ULONG ulType = 0;
    DWORD dwRefresh;
    DWORD cbData;

    switch (msg)
    {
    case WM_INITDIALOG:
        dwRefresh = 0;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\DirectDraw"), 0, KEY_READ, &hkey))
        {
            cbData = sizeof(DWORD);
            RegQueryValueEx(hkey, TEXT("ForceRefreshRate"), 0, &ulType, (LPBYTE)&dwRefresh, &cbData);
            RegCloseKey(hkey);
        }
        if (dwRefresh == 0)
        {
            CheckRadioButton(hwnd, IDC_DEFAULTREFRESH, IDC_OVERRIDEREFRESH, IDC_DEFAULTREFRESH);
        }
        else
        {
            CheckRadioButton(hwnd, IDC_DEFAULTREFRESH, IDC_OVERRIDEREFRESH, IDC_OVERRIDEREFRESH);
            SetDlgItemInt(hwnd, IDC_OVERRIDEREFRESHVALUE, dwRefresh, FALSE);
        }
        return TRUE;
    case WM_COMMAND:
        {
            WORD wID = LOWORD(wparam);
            BOOL bDontEnd = FALSE;
            switch(wID)
            {
            case IDOK:
                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    TEXT("Software\\Microsoft\\DirectDraw"), 0, KEY_ALL_ACCESS, &hkey))
                {
                    DWORD dwButtonState;
                    dwButtonState = (DWORD)SendMessage(GetDlgItem(hwnd, IDC_DEFAULTREFRESH), BM_GETCHECK, 0, 0);
                    if (dwButtonState == BST_CHECKED)
                    {
                        RegDeleteValue(hkey, TEXT("ForceRefreshRate"));
                    }
                    else
                    {
                        BOOL bTranslated;
                        UINT ui = GetDlgItemInt(hwnd, IDC_OVERRIDEREFRESHVALUE, &bTranslated, TRUE);
                        if (bTranslated && ui >= 40 && ui <= 120)
                            RegSetValueEx(hkey, TEXT("ForceRefreshRate"), 0, REG_DWORD, (LPBYTE)&ui, sizeof(DWORD));
                        else
                        {
                            TCHAR sz[MAX_PATH];
                            TCHAR szTitle[MAX_PATH];
                            SetDlgItemText(hwnd, IDC_OVERRIDEREFRESHVALUE, TEXT(""));
                            CheckRadioButton(hwnd, IDC_DEFAULTREFRESH, IDC_OVERRIDEREFRESH, IDC_DEFAULTREFRESH);
                            LoadString(NULL, IDS_BADREFRESHVALUE, sz, MAX_PATH);
                            LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
                            MessageBox(hwnd, sz, szTitle, MB_OK);
                            bDontEnd = TRUE;
                        }
                    }
                    RegCloseKey(hkey);
                }
                else
                {
                }
                if (!bDontEnd)
                    EndDialog(hwnd, IDOK);
                break;
            case IDCANCEL:
                EndDialog(hwnd, IDCANCEL);
                break;
            case IDC_OVERRIDEREFRESHVALUE:
                if (HIWORD(wparam) == EN_SETFOCUS)
                {
                    CheckRadioButton(hwnd, IDC_DEFAULTREFRESH, IDC_OVERRIDEREFRESH, IDC_OVERRIDEREFRESH);
                }
                else if (HIWORD(wparam) == EN_KILLFOCUS)
                {
                    TCHAR szEdit[MAX_PATH];
                    BOOL bTranslated;
                    if (GetDlgItemText(hwnd, IDC_OVERRIDEREFRESHVALUE, szEdit, 100) == 0)
                    {
                        CheckRadioButton(hwnd, IDC_DEFAULTREFRESH, IDC_OVERRIDEREFRESH, IDC_DEFAULTREFRESH);
                    }
                    else
                    {
                        UINT ui = GetDlgItemInt(hwnd, IDC_OVERRIDEREFRESHVALUE, &bTranslated, TRUE);
                        if (!bTranslated || ui < 40 || ui > 120)
                        {
                            TCHAR sz[MAX_PATH];
                            TCHAR szTitle[MAX_PATH];
                            LoadString(NULL, IDS_BADREFRESHVALUE, sz, MAX_PATH);
                            LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
                            MessageBox(hwnd, sz, szTitle, MB_OK);
                            SetDlgItemText(hwnd, IDC_OVERRIDEREFRESHVALUE, TEXT(""));
                            CheckRadioButton(hwnd, IDC_DEFAULTREFRESH, IDC_OVERRIDEREFRESH, IDC_DEFAULTREFRESH);
                        }
                    }
                }
                break;
            }
        }
        return TRUE;
    }
    return FALSE;
}


/****************************************************************************
 *
 *  ShowHelp - Look for dxdiag.chm in <windows>\help first, then try the 
 *      same dir as the exe.
 *
 ****************************************************************************/
VOID ShowHelp(VOID)
{
    TCHAR szHelpDir[MAX_PATH];
    TCHAR szHelpFile[MAX_PATH];
    TCHAR szHelpLeaf[MAX_PATH];
    TCHAR szTestPath[MAX_PATH];

    // Since we use HTML help, complain if at least IE5 is not found
    BOOL bIE5Found = FALSE;
    HKEY hkey;
    TCHAR szVersion[MAX_PATH];
    DWORD dwType;
    DWORD cbData;
    DWORD dwMajor;
    DWORD dwMinor;
    DWORD dwRevision;
    DWORD dwBuild;
    lstrcpy(szVersion, TEXT(""));
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        TEXT("Software\\Microsoft\\Internet Explorer"), 0, KEY_READ, &hkey))
    {
        cbData = 100;
        RegQueryValueEx(hkey, TEXT("Version"), 0, &dwType, (LPBYTE)szVersion, &cbData);
        RegCloseKey(hkey);
        if (lstrlen(szVersion) > 0)
        {
            if( _stscanf(szVersion, TEXT("%d.%d.%d.%d"), &dwMajor, &dwMinor, &dwRevision, &dwBuild) == 4 )
            {
                if (dwMajor >= 5)
                    bIE5Found = TRUE;
            }
        }
    }
    if (!bIE5Found)
    {
        ReportError(IDS_HELPNEEDSIE5);
        return;
    }


    LoadString(NULL, IDS_HELPFILE, szHelpFile, MAX_PATH);
    if( GetWindowsDirectory(szHelpDir, MAX_PATH) == 0 )
        return;
    LoadString(NULL, IDS_HELPDIRLEAF, szHelpLeaf, MAX_PATH);
    lstrcat(szHelpDir, szHelpLeaf);
    lstrcpy(szTestPath, szHelpDir);
    lstrcat(szTestPath, TEXT("\\"));
    lstrcat(szTestPath, szHelpFile);
    if (GetFileAttributes(szTestPath) == 0xffffffff)
    {
        // File not in windows\help, so try exe's dir:
        GetModuleFileName(NULL, szHelpDir, MAX_PATH);
        TCHAR* pstr = _tcsrchr(szHelpDir, TEXT('\\'));
        if( pstr )
            *pstr = TEXT('\0');
    }
    
    HINSTANCE hInstResult = ShellExecute( s_hwndMain, NULL, szHelpFile, 
                                          NULL, szHelpDir, SW_SHOWNORMAL ) ;
    if( (INT_PTR)hInstResult < 32 ) 
        ReportError(IDS_NOHELP);
}


/****************************************************************************
 *
 *  BTranslateError
 *
 ****************************************************************************/
BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish)
{
    LONG ids;

    switch (hr)
    {
    case E_INVALIDARG: ids = bEnglish ? IDS_INVALIDARG_ENGLISH : IDS_INVALIDARG; break;
    case E_FAIL: ids = bEnglish ? IDS_FAIL_ENGLISH : IDS_FAIL; break;
    case E_UNEXPECTED: ids = bEnglish ? IDS_UNEXPECTED_ENGLISH : IDS_UNEXPECTED; break;
    case E_NOTIMPL: ids = bEnglish ? IDS_NOTIMPL_ENGLISH : IDS_NOTIMPL; break;
    case E_OUTOFMEMORY: ids = bEnglish ? IDS_OUTOFMEMORY_ENGLISH : IDS_OUTOFMEMORY; break;
    case E_NOINTERFACE: ids = bEnglish ? IDS_NOINTERFACE_ENGLISH : IDS_NOINTERFACE; break;
    case REGDB_E_CLASSNOTREG: ids = bEnglish ? IDS_REGDB_E_CLASSNOTREG_ENGLISH : IDS_REGDB_E_CLASSNOTREG; break;
    
    case DDERR_INVALIDMODE: ids = bEnglish ? IDS_INVALIDMODE_ENGLISH : IDS_INVALIDMODE; break;
    case DDERR_INVALIDPIXELFORMAT: ids = bEnglish ? IDS_INVALIDPIXELFORMAT_ENGLISH : IDS_INVALIDPIXELFORMAT; break;
    case DDERR_CANTCREATEDC: ids = bEnglish ? IDS_CANTCREATEDC_ENGLISH : IDS_CANTCREATEDC; break;
    case DDERR_NOTFOUND: ids = bEnglish ? IDS_NOTFOUND_ENGLISH : IDS_NOTFOUND; break;
    case DDERR_NODIRECTDRAWSUPPORT: ids = bEnglish ? IDS_NODIRECTDRAWSUPPORT_ENGLISH : IDS_NODIRECTDRAWSUPPORT; break;
    case DDERR_NO3D: ids = bEnglish ? IDS_NO3D_ENGLISH : IDS_NO3D; break;

    case D3DERR_INVALID_DEVICE: ids = bEnglish ? IDS_INVALID_DEVICE_ENGLISH : IDS_INVALID_DEVICE; break;
    case D3DERR_INITFAILED: ids = bEnglish ? IDS_INITFAILED_ENGLISH : IDS_INITFAILED; break;
    case D3DERR_MATERIAL_CREATE_FAILED: ids = bEnglish ? IDS_MATERIAL_CREATE_FAILED_ENGLISH : IDS_MATERIAL_CREATE_FAILED; break;
    case D3DERR_LIGHT_SET_FAILED: ids = bEnglish ? IDS_LIGHT_SET_FAILED_ENGLISH : IDS_LIGHT_SET_FAILED; break;
    case DDERR_OUTOFVIDEOMEMORY: ids = bEnglish ? IDS_OUT_OF_VIDEO_MEMORY_ENGLISH : IDS_OUT_OF_VIDEO_MEMORY; break;
#define D3DERR_NOTAVAILABLE 0x8876086a 
    case D3DERR_NOTAVAILABLE: ids = bEnglish ? IDS_D3DERR_NOTAVAILABLE_ENGLISH : IDS_D3DERR_NOTAVAILABLE; break;        

    case DSERR_CONTROLUNAVAIL: ids = bEnglish ? IDS_CONTROLUNAVAIL_ENGLISH : IDS_CONTROLUNAVAIL; break;
    case DSERR_BADFORMAT: ids = bEnglish ? IDS_BADFORMAT_ENGLISH : IDS_BADFORMAT; break;
    case DSERR_BUFFERLOST: ids = bEnglish ? IDS_BUFFERLOST_ENGLISH : IDS_BUFFERLOST; break;
    case DSERR_NODRIVER: ids = bEnglish ? IDS_NODRIVER_ENGLISH : IDS_NODRIVER; break;
    case DSERR_ALLOCATED: ids = bEnglish ? IDS_ALLOCATED_ENGLISH : IDS_ALLOCATED; break;

    case DMUS_E_DRIVER_FAILED: ids = bEnglish ? IDS_DRIVER_FAILED_ENGLISH : IDS_DRIVER_FAILED; break;
    case DMUS_E_PORTS_OPEN: ids = bEnglish ? IDS_PORTS_OPEN_ENGLISH : IDS_PORTS_OPEN; break;
    case DMUS_E_DEVICE_IN_USE: ids = bEnglish ? IDS_DEVICE_IN_USE_ENGLISH : IDS_DEVICE_IN_USE; break;
    case DMUS_E_INSUFFICIENTBUFFER: ids = bEnglish ? IDS_INSUFFICIENTBUFFER_ENGLISH : IDS_INSUFFICIENTBUFFER; break;
    case DMUS_E_CHUNKNOTFOUND: ids = bEnglish ? IDS_CHUNKNOTFOUND_ENGLISH : IDS_CHUNKNOTFOUND; break;
    case DMUS_E_BADINSTRUMENT: ids = bEnglish ? IDS_BADINSTRUMENT_ENGLISH : IDS_BADINSTRUMENT; break;
    case DMUS_E_CANNOTREAD: ids = bEnglish ? IDS_CANNOTREAD_ENGLISH : IDS_CANNOTREAD; break;
    case DMUS_E_LOADER_BADPATH: ids = bEnglish ? IDS_LOADER_BADPATH_ENGLISH : IDS_LOADER_BADPATH; break;
    case DMUS_E_LOADER_FAILEDOPEN: ids = bEnglish ? IDS_LOADER_FAILEDOPEN_ENGLISH : IDS_LOADER_FAILEDOPEN; break;
    case DMUS_E_LOADER_FORMATNOTSUPPORTED: ids = bEnglish ? IDS_LOADER_FORMATNOTSUPPORTED_ENGLISH : IDS_LOADER_FORMATNOTSUPPORTED; break;
    case DMUS_E_LOADER_OBJECTNOTFOUND: ids = bEnglish ? IDS_OBJECTNOTFOUND_ENGLISH : IDS_OBJECTNOTFOUND; break;

    case DPERR_ACCESSDENIED: ids = bEnglish ? IDS_DPERR_ACCESSDENIED_ENGLISH : IDS_DPERR_ACCESSDENIED; break;
    case DPERR_CANTADDPLAYER: ids = bEnglish ? IDS_DPERR_CANTADDPLAYER_ENGLISH : IDS_DPERR_CANTADDPLAYER; break;
    case DPERR_CANTCREATESESSION: ids = bEnglish ? IDS_DPERR_CANTCREATESESSION_ENGLISH : IDS_DPERR_CANTCREATESESSION; break;
    case DPERR_EXCEPTION: ids = bEnglish ? IDS_DPERR_EXCEPTION_ENGLISH : IDS_DPERR_EXCEPTION; break;
    case DPERR_INVALIDOBJECT: ids = bEnglish ? IDS_DPERR_INVALIDOBJECT_ENGLISH : IDS_DPERR_INVALIDOBJECT; break;
    case DPERR_NOCONNECTION: ids = bEnglish ? IDS_DPERR_NOCONNECTION_ENGLISH : IDS_DPERR_NOCONNECTION; break;
    case DPERR_TIMEOUT: ids = bEnglish ? IDS_DPERR_TIMEOUT_ENGLISH : IDS_DPERR_TIMEOUT; break;
    case DPERR_BUSY: ids = bEnglish ? IDS_DPERR_BUSY_ENGLISH : IDS_DPERR_BUSY; break;
    case DPERR_CONNECTIONLOST: ids = bEnglish ? IDS_DPERR_CONNECTIONLOST_ENGLISH : IDS_DPERR_CONNECTIONLOST; break;
    case DPERR_NOSERVICEPROVIDER: ids = bEnglish ? IDS_DPERR_NOSERVICEPROVIDER_ENGLISH : IDS_DPERR_NOSERVICEPROVIDER; break;
    case DPERR_UNAVAILABLE: ids = bEnglish ? IDS_DPERR_UNAVAILABLE_ENGLISH : IDS_DPERR_UNAVAILABLE; break;

    default: ids = bEnglish ? IDS_UNKNOWNERROR_ENGLISH : IDS_UNKNOWNERROR; break;
    }
    LoadString(NULL, ids, psz, 200); 
    if (ids != IDS_UNKNOWNERROR && ids != IDS_UNKNOWNERROR_ENGLISH)
        return TRUE;
    else
        return FALSE;
}


/****************************************************************************
 *
 *  RestoreDrivers
 *
 ****************************************************************************/
VOID RestoreDrivers(VOID)
{
    TCHAR szDir[MAX_PATH];
    lstrcpy( szDir, TEXT("") );
    
    if (GetProgramFilesFolder(szDir))
    {
        lstrcat(szDir, TEXT("\\DirectX\\Setup"));

        HINSTANCE hInstResult = ShellExecute( s_hwndMain, NULL, TEXT("DxSetup.exe"), 
                                              NULL, szDir, SW_SHOWNORMAL ) ;
        if( (INT_PTR)hInstResult < 32 ) 
            ReportError(IDS_NODXSETUP);
    }
}


/****************************************************************************
 *
 *  BCanRestoreDrivers - Returns whether backed-up drivers can be restored.
 *      This function checks for the presence of dxsetup.exe where it should 
 *      be, and the existence of files in either <system>\dxbackup\display or
 *      <system>\dxbackup\media.
 *
 ****************************************************************************/
BOOL BCanRestoreDrivers(VOID)
{
    TCHAR szPath[MAX_PATH];
    lstrcpy( szPath, TEXT("") );

    if (!GetProgramFilesFolder(szPath))
        return FALSE;
    lstrcat(szPath, TEXT("\\DirectX\\Setup\\DxSetup.exe"));
    if (GetFileAttributes(szPath) == 0xffffffff)
        return FALSE;

    if (!GetSystemDirectory(szPath, MAX_PATH))
        return FALSE;
    lstrcat(szPath, TEXT("\\dxbackup\\display"));
    if (GetFileAttributes(szPath) != 0xffffffff)
        return TRUE;

    if (!GetSystemDirectory(szPath, MAX_PATH))
        return FALSE;
    lstrcat(szPath, TEXT("\\dxbackup\\media"));
    if (GetFileAttributes(szPath) != 0xffffffff)
        return TRUE;

    return FALSE;
}


/****************************************************************************
 *
 *  HandleSndSliderChange
 *
 ****************************************************************************/
VOID HandleSndSliderChange(INT nScrollCode, INT nPos)
{
    TCHAR sz[MAX_PATH];

    if (nScrollCode != SB_THUMBTRACK && nScrollCode != SB_THUMBPOSITION)
        nPos = (INT)SendMessage(GetDlgItem(s_hwndCurPage, IDC_SNDACCELSLIDER), TBM_GETPOS, 0, 0);

    if (nScrollCode == SB_THUMBTRACK ||
        nScrollCode == SB_LEFT ||
        nScrollCode == SB_RIGHT ||
        nScrollCode == SB_LINELEFT ||
        nScrollCode == SB_LINERIGHT ||
        nScrollCode == SB_PAGELEFT ||
        nScrollCode == SB_PAGERIGHT)
    {
        switch (nPos)
        {
        case 0:
            LoadString(NULL, IDS_NOSNDACCELERATION, sz, MAX_PATH);
            break;
        case 1:
            LoadString(NULL, IDS_BASICSNDACCELERATION, sz, MAX_PATH);
            break;
        case 2:
            LoadString(NULL, IDS_STANDARDSNDACCELERATION, sz, MAX_PATH);
            break;
        case 3:
            LoadString(NULL, IDS_FULLSNDACCELERATION, sz, MAX_PATH);
            break;
        default:
            lstrcpy(sz, TEXT(""));
            break;
        }
        SetWindowText(GetDlgItem(s_hwndCurPage, IDC_SNDACCELDESC), sz);
    }

    if (nScrollCode != SB_THUMBTRACK && nScrollCode != SB_ENDSCROLL &&
        s_pSoundInfoFirst != NULL )
    {
        HRESULT hr;

        SoundInfo* pSoundInfo = s_pSoundInfoFirst;
        LONG iSound = s_lwCurPage - s_iPageSoundFirst;
        while (iSound > 0)
        {
            pSoundInfo = pSoundInfo->m_pSoundInfoNext;
            iSound--;
        }

        if (nPos != pSoundInfo->m_lwAccelerationLevel)
        {
            if (FAILED(hr = ChangeAccelerationLevel(pSoundInfo, nPos)))
            {
                // TODO: report error
            }

            DestroySoundInfo(s_pSoundInfoFirst);
            pSoundInfo        = NULL;
            s_pSoundInfoFirst = NULL;

            // ******* GetBasicSoundInfo (DS:1) ********
            s_bUseDSound = QueryCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, IDS_DS, 1 );
            if( s_bUseDSound )
            {
                EnterCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 1 );
                if (FAILED(hr = GetBasicSoundInfo(&s_pSoundInfoFirst)))
                    ReportError(IDS_NOBASICSOUNDINFO, hr);  
                LeaveCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 1 );
            }

            // ******* GetExtraSoundInfo (DS:2) ********
            if( s_bUseDSound )
            {
                s_bUseDSound = QueryCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, IDS_DS, 2 );
                if( s_bUseDSound )
                {
                    EnterCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 2 );
                    if (FAILED(hr = GetExtraSoundInfo(s_pSoundInfoFirst)))
                        ReportError(IDS_NOEXTRASOUNDINFO, hr);
                    LeaveCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 2 );
                }
            }

            // ******* GetDSSoundInfo (DS:3) ********
            if( s_bUseDSound )
            {
                s_bUseDSound = QueryCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, IDS_DS, 3 );
                if( s_bUseDSound )
                {
                    EnterCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 3 );
                    if (FAILED(hr = GetDSSoundInfo(s_pSoundInfoFirst)))
                        ReportError(IDS_NOEXTRASOUNDINFO, hr);
                    LeaveCrashProtection( DXD_IN_DS_KEY, DXD_IN_DS_VALUE, 3 );
                }
            }

            SetupSoundPage( s_lwCurPage - s_iPageSoundFirst );
        }
    }
}


/****************************************************************************
 *
 *  TroubleShoot
 *
 ****************************************************************************/
VOID TroubleShoot( BOOL bTroubleShootSound )
{
    TCHAR szHelpDir[MAX_PATH];
    TCHAR szHelpLeaf[MAX_PATH];
    TCHAR szHelpExe[MAX_PATH];
    TCHAR szTroubleshooter[MAX_PATH];
    TCHAR szSubInfo[MAX_PATH];

    if( GetWindowsDirectory(szHelpDir, MAX_PATH) == 0 )
        return;
    LoadString(NULL, IDS_HELPDIRLEAF, szHelpLeaf, MAX_PATH);
    LoadString(NULL, IDS_HELPEXE, szHelpExe, MAX_PATH);

    lstrcat(szHelpDir, szHelpLeaf);

    if( bTroubleShootSound )
    {
        if( BIsWin98() || BIsWin95() )
        {
            TCHAR szHelpPath[MAX_PATH];
            LoadString(NULL, IDS_TROUBLESHOOTER_WIN98SE, szTroubleshooter, MAX_PATH);
            lstrcpy(szHelpPath, szHelpDir);
            lstrcat(szHelpPath, TEXT("\\"));
            lstrcat(szHelpPath, szTroubleshooter);
            if (GetFileAttributes(szHelpPath) == 0xffffffff)
            {
                LoadString(NULL, IDS_SOUNDTROUBLESHOOTER_WIN98, szTroubleshooter, MAX_PATH);
                lstrcpy( szSubInfo, TEXT("") );
            }
            else
            {
                LoadString(NULL, IDS_TROUBLESHOOTER_WIN98SE, szTroubleshooter, MAX_PATH);
                LoadString(NULL, IDS_TSSOUNDSUBINFO_WIN98SE, szSubInfo, MAX_PATH);
            }
        }
        else if( BIsWinME() )
        {
            LoadString(NULL, IDS_TROUBLESHOOTER_WINME_HCP, szHelpExe, MAX_PATH);
            LoadString(NULL, IDS_TSSOUNDSUBINFO_WINME_HCP, szSubInfo, MAX_PATH);

            lstrcat(szHelpExe, szSubInfo);
            lstrcpy(szTroubleshooter, TEXT("") );
            lstrcpy(szSubInfo, TEXT("") );
        }
        else if( BIsWin2k() )
        {
            LoadString(NULL, IDS_TROUBLESHOOTER_WIN2K, szTroubleshooter, MAX_PATH);
            LoadString(NULL, IDS_TSSOUNDSUBINFO_WIN2K, szSubInfo, MAX_PATH);
        }
        else // if( BIsWhistler() )
        {
            lstrcpy( szHelpExe, TEXT("hcp://help/tshoot/tssound.htm") );
            lstrcpy( szTroubleshooter, TEXT("") );
            lstrcpy( szSubInfo, TEXT("") );
        }
    }
    else
    {
        if( BIsWin98() || BIsWin95() )
        {
            TCHAR szHelpPath[MAX_PATH];
            LoadString(NULL, IDS_TROUBLESHOOTER_WIN98SE, szTroubleshooter, MAX_PATH);
            lstrcpy(szHelpPath, szHelpDir);
            lstrcat(szHelpPath, TEXT("\\"));
            lstrcat(szHelpPath, szTroubleshooter);
            if (GetFileAttributes(szHelpPath) == 0xffffffff)
            {
                LoadString(NULL, IDS_TROUBLESHOOTER_WIN98, szTroubleshooter, MAX_PATH);
                lstrcpy( szSubInfo, TEXT("") );
            }
            else
            {
                LoadString(NULL, IDS_TROUBLESHOOTER_WIN98SE, szTroubleshooter, MAX_PATH);
                LoadString(NULL, IDS_TSSUBINFO_WIN98SE, szSubInfo, MAX_PATH);
            }
        }
        else if( BIsWinME() )
        {
            LoadString(NULL, IDS_TROUBLESHOOTER_WINME_HCP, szHelpExe, MAX_PATH);   
            LoadString(NULL, IDS_TSSUBINFO_WINME_HCP, szSubInfo, MAX_PATH);

            lstrcat(szHelpExe, szSubInfo);
            lstrcpy(szTroubleshooter, TEXT("") );
            lstrcpy(szSubInfo, TEXT("") );
        }
        else if( BIsWin2k() )
        {
            LoadString(NULL, IDS_TROUBLESHOOTER_WIN2K, szTroubleshooter, MAX_PATH);   
            LoadString(NULL, IDS_TSSUBINFO_WIN2K, szSubInfo, MAX_PATH);
        }
        else // if( BIsWhistler() )
        {
            lstrcpy( szHelpExe, TEXT("hcp://help/tshoot/tsgame.htm") );
            lstrcpy( szTroubleshooter, TEXT("") );
            lstrcpy( szSubInfo, TEXT("") );
        }
    }

    lstrcat(szTroubleshooter, szSubInfo);
    HINSTANCE hInstResult = ShellExecute( s_hwndMain, NULL, szHelpExe, 
                                      szTroubleshooter, 
                                      szHelpDir, SW_SHOWNORMAL ) ;
    if( (INT_PTR)hInstResult < 32 ) 
        ReportError(IDS_NOTROUBLESHOOTER);
}


/****************************************************************************
 *
 *  QueryCrashProtection
 *
 ****************************************************************************/
BOOL QueryCrashProtection( TCHAR* strKey, TCHAR* strValue, 
                           int nSkipComponent, DWORD dwCurrentStep )
{
    HKEY    hkey            = NULL;
    BOOL    bAllowCall      = TRUE;

    // Open the key
    if( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, strKey, 0, KEY_ALL_ACCESS, &hkey) )
    {
        DWORD dwType = 0;
        DWORD dwCrashedOnStep = 0;
        DWORD cbData = sizeof(dwCrashedOnStep);

        // Query the key for the value of where the last crash occurred
        if( ERROR_SUCCESS == RegQueryValueEx( hkey, strValue, 0, &dwType, 
                                              (BYTE*)&dwCrashedOnStep, &cbData) )
        {
            // If we are at or beyond the crash step, then ask the user
            // to continue or not
            if( dwCurrentStep >= dwCrashedOnStep )
            {
                if( !s_bGUI )
                {
                    // If there's no gui, don't ask just don't use it
                    bAllowCall = FALSE;
                }
                else
                {
                    // If the UI is alive then have it ask the user, 
                    // otherwise do it ourselves
                    if( s_hwndMain && s_hUIThread )
                    {
                        // Mark down which component we're skipping in s_nSkipComponent,
                        // and then post a WM_QUERYSKIP message to the UI thread
                        // it will process this message, ask the user, and signal the
                        // s_hQuerySkipEvent event.
                        s_nSkipComponent = nSkipComponent;
                        PostMessage( s_hwndMain, WM_QUERYSKIP, 0, 0 );

                        HANDLE aWait[2];
                        DWORD dwResult;
                        aWait[0] = s_hQuerySkipEvent;
                        aWait[1] = s_hUIThread;

                        // Its possible that the UI thread exited before it processed the
                        // WM_QUERYSKIP message, so wait for either the event and thread exiting
                        dwResult = WaitForMultipleObjects( 2, aWait, FALSE, INFINITE );
            
                        // If the event was signaled, then get the result from s_bQuerySkipAllow,
                        // otherwise skip this call (the main code will exit if it sees the UI thread gone)
                        if( dwResult == WAIT_OBJECT_0 )
                            bAllowCall = s_bQuerySkipAllow;
                        else
                            bAllowCall = FALSE;
                    }
                    else
                    {
                        // If there's is no gui, ask if to use it now
                        TCHAR szTitle[MAX_PATH];
                        TCHAR szMessage[MAX_PATH];
                        TCHAR szFmt[MAX_PATH];
                        TCHAR szMessageComponent[MAX_PATH];
                        LoadString(0, IDS_APPFULLNAME, szTitle, MAX_PATH);
                        LoadString(0, IDS_SKIP, szFmt, MAX_PATH);
                        LoadString(0, nSkipComponent, szMessageComponent, MAX_PATH);
                        wsprintf( szMessage, szFmt, szMessageComponent, szMessageComponent );
                        if( IDYES == MessageBox( s_hwndMain, szMessage, szTitle, MB_YESNO) )
                            bAllowCall = FALSE;
                    }
                }
            }
        }

        RegCloseKey(hkey);
    }

    return bAllowCall;
}


/****************************************************************************
 *
 *  EnterCrashProtection
 *
 ****************************************************************************/
VOID EnterCrashProtection( TCHAR* strKey, TCHAR* strValue, DWORD dwCurrentStep )
{
    HKEY  hkey = NULL;
    BOOL  bSetValue = FALSE;
    DWORD dwDisposition;

    // Write reg key indicating we are inside the crash protection
    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_LOCAL_MACHINE, strKey, 0, 
                                         NULL, REG_OPTION_NON_VOLATILE, 
                                         KEY_ALL_ACCESS, NULL, &hkey, &dwDisposition) )
    {
        DWORD dwType = 0;
        DWORD dwCrashedOnStep = 0;
        DWORD cbData = sizeof(dwCrashedOnStep);

        // Query the key for the value of where the last crash occurred
        if( ERROR_SUCCESS == RegQueryValueEx( hkey, strValue, 0, &dwType, 
                                             (BYTE*)&dwCrashedOnStep, &cbData) )
        {
            // If we are beyond whats currently in the reg, then update the value
            if( dwCurrentStep > dwCrashedOnStep )
                bSetValue = TRUE;
        }
        else
        {
            // If the value doesn't exist current, then create it
            bSetValue = TRUE;
        }

        if( bSetValue )
        {
            RegSetValueEx( hkey, strValue, 0, REG_DWORD, 
                           (BYTE*)&dwCurrentStep, sizeof(dwCurrentStep));
        }

        RegCloseKey(hkey);
    }        
}


/****************************************************************************
 *
 *  LeaveCrashProtection
 *
 ****************************************************************************/
VOID LeaveCrashProtection( TCHAR* strKey, TCHAR* strValue, DWORD dwCurrentStep )
{
    HKEY  hkey = NULL;

    // Remove reg key since we're done with the crash protection
    if (ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, strKey, 0, 
                                       KEY_ALL_ACCESS, &hkey))
    {
        DWORD dwType = 0;
        DWORD dwCrashedOnStep = 0;
        DWORD cbData = sizeof(dwCrashedOnStep);

        // Query the key for the value of where the last crash occurred
        if( ERROR_SUCCESS == RegQueryValueEx( hkey, strValue, 0, &dwType, 
                                              (BYTE*)&dwCrashedOnStep, &cbData) )
        {
            // If we are at or beyond that crash step, then delete the key
            if( dwCurrentStep >= dwCrashedOnStep )
            {
                RegDeleteValue(hkey, strValue);
            }
        }

        RegCloseKey(hkey);
    }
}


/****************************************************************************
 *
 *  TestD3D
 *
 ****************************************************************************/
VOID TestD3D(HWND hwndMain, DisplayInfo* pDisplayInfo)
{
    TCHAR               sz[MAX_PATH];
    TCHAR               szTitle[MAX_PATH];

    LoadString(NULL, IDS_STARTD3DTEST, sz, MAX_PATH);
    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);

    if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
        return;

    // Erase old D3D7 test results
    ZeroMemory(&pDisplayInfo->m_testResultD3D7, sizeof(TestResult));
    pDisplayInfo->m_testResultD3D7.m_bStarted = TRUE;

    // Erase old D3D8 test results
    ZeroMemory(&pDisplayInfo->m_testResultD3D8, sizeof(TestResult));
    pDisplayInfo->m_testResultD3D8.m_bStarted = TRUE;

    if( FALSE == BIsIA64() )
    {
        // First test (D3D7)
        LoadString(NULL, IDS_D3DTEST1, sz, MAX_PATH);
        if (IDCANCEL == MessageBox(hwndMain, sz, szTitle, MB_OKCANCEL))
        {
            pDisplayInfo->m_testResultD3D7.m_bCancelled = TRUE;
            goto LEnd;
        }
    
        // Run D3D7 test
        TestD3Dv7( TRUE, hwndMain, pDisplayInfo );
    
        if( pDisplayInfo->m_testResultD3D7.m_bCancelled ||
            pDisplayInfo->m_testResultD3D7.m_iStepThatFailed != 0 )
            goto LEnd;
    }
 
    // Second test (D3D8)
    LoadString(NULL, IDS_D3DTEST2, sz, MAX_PATH);
    if (IDCANCEL == MessageBox(hwndMain, sz, szTitle, MB_OKCANCEL))
    {
        pDisplayInfo->m_testResultD3D8.m_bCancelled = TRUE;
        goto LEnd;
    }

    // Run D3D8 test
    TestD3Dv8( TRUE, hwndMain, pDisplayInfo );

    if( pDisplayInfo->m_testResultD3D8.m_bCancelled ||
        pDisplayInfo->m_testResultD3D8.m_iStepThatFailed != 0 )
        goto LEnd;

LEnd:
    // Default to displaying results of D3D8 tests 
    pDisplayInfo->m_dwTestToDisplayD3D = 8;

    if (pDisplayInfo->m_testResultD3D7.m_bCancelled || pDisplayInfo->m_testResultD3D8.m_bCancelled)
    {
        LoadString(NULL, IDS_TESTSCANCELLED, sz, MAX_PATH);
        lstrcpy(pDisplayInfo->m_testResultD3D7.m_szDescription, sz);
        lstrcpy(pDisplayInfo->m_testResultD3D8.m_szDescription, sz);

        LoadString(NULL, IDS_TESTSCANCELLED_ENGLISH, sz, MAX_PATH);
        lstrcpy(pDisplayInfo->m_testResultD3D7.m_szDescriptionEnglish, sz);
        lstrcpy(pDisplayInfo->m_testResultD3D8.m_szDescriptionEnglish, sz);
    }
    else
    {
        if( pDisplayInfo->m_testResultD3D7.m_iStepThatFailed == 0 )
        {
            LoadString(NULL, IDS_TESTSSUCCESSFUL_ENGLISH, sz, MAX_PATH);
            lstrcpy(pDisplayInfo->m_testResultD3D7.m_szDescriptionEnglish, sz);
            
            LoadString(NULL, IDS_TESTSSUCCESSFUL, sz, MAX_PATH);
            lstrcpy(pDisplayInfo->m_testResultD3D7.m_szDescription, sz);
        }
        
        if( pDisplayInfo->m_testResultD3D8.m_iStepThatFailed == 0 )
        {
            LoadString(NULL, IDS_TESTSSUCCESSFUL, sz, MAX_PATH);
            lstrcpy(pDisplayInfo->m_testResultD3D8.m_szDescription, sz);
            
            LoadString(NULL, IDS_TESTSSUCCESSFUL_ENGLISH, sz, MAX_PATH);
            lstrcpy(pDisplayInfo->m_testResultD3D8.m_szDescriptionEnglish, sz);
        }
        
        if( pDisplayInfo->m_testResultD3D7.m_iStepThatFailed != 0 ||
            pDisplayInfo->m_testResultD3D8.m_iStepThatFailed != 0 )
        {
            TCHAR szDesc[MAX_PATH];
            TCHAR szError[MAX_PATH];
            TestResult* pFailedTestResult = NULL;

            if( pDisplayInfo->m_testResultD3D7.m_iStepThatFailed != 0 )
            {
                pFailedTestResult = &pDisplayInfo->m_testResultD3D7;
                pDisplayInfo->m_dwTestToDisplayD3D = 7;
            }
            else
            {
                pFailedTestResult = &pDisplayInfo->m_testResultD3D8;
                pDisplayInfo->m_dwTestToDisplayD3D = 8;
            }

            if (0 == LoadString(NULL, IDS_FIRSTD3DTESTERROR + pFailedTestResult->m_iStepThatFailed - 1,
                szDesc, MAX_PATH))
            {
                LoadString(NULL, IDS_UNKNOWNERROR, sz, MAX_PATH);
                lstrcpy(szDesc, sz);
            }
            LoadString(NULL, IDS_FAILUREFMT, sz, MAX_PATH);
            BTranslateError(pFailedTestResult->m_hr, szError);
            wsprintf(pFailedTestResult->m_szDescription, sz, 
                pFailedTestResult->m_iStepThatFailed,
                szDesc, pFailedTestResult->m_hr, szError);

            // Nonlocalized version:
            if (0 == LoadString(NULL, IDS_FIRSTD3DTESTERROR_ENGLISH + pFailedTestResult->m_iStepThatFailed - 1,
                szDesc, MAX_PATH))
            {
                LoadString(NULL, IDS_UNKNOWNERROR_ENGLISH, sz, MAX_PATH);
                lstrcpy(szDesc, sz);
            }
            LoadString(NULL, IDS_FAILUREFMT_ENGLISH, sz, MAX_PATH);
            BTranslateError(pFailedTestResult->m_hr, szError, TRUE);
            wsprintf(pFailedTestResult->m_szDescriptionEnglish, sz, 
                        pFailedTestResult->m_iStepThatFailed,
                        szDesc, pFailedTestResult->m_hr, szError);
        }
    }
}


/****************************************************************************
 *
 *  GetTxtPath
 *
 ****************************************************************************/
BOOL GetTxtPath( TCHAR* strTxtPath )
{
    HKEY hkey   = NULL;
    BOOL bFound = FALSE;
    DWORD ulType;
    DWORD cbData;

    // Get default user info from registry
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectX Diagnostic Tool"),
        0, KEY_READ, &hkey))
    {
        cbData = MAX_PATH;
        if( ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("TxtPath"), 0, &ulType, (LPBYTE)strTxtPath, &cbData ) )
            bFound = TRUE;

        RegCloseKey(hkey);
    }

    if( !bFound )
    {
        HKEY hkeyFolder;

        // Same as SHGetSpecialFolderPath( hwnd, szFilename, CSIDL_DESKTOPDIRECTORY, FALSE );
        if (ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
            0, KEY_READ, &hkeyFolder) ) 
        {
            cbData = MAX_PATH;
            if (ERROR_SUCCESS == RegQueryValueEx( hkeyFolder, TEXT("Desktop"), 0, &ulType, (LPBYTE)strTxtPath, &cbData ) )
                bFound = TRUE;

            RegCloseKey( hkeyFolder );
        }
    }

    return bFound;
}


/****************************************************************************
 *
 *  SetTxtPath
 *
 ****************************************************************************/
VOID SetTxtPath( TCHAR* strTxtPath )
{
    HKEY hkey = NULL;

    // Try to save user info into registry
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectX Diagnostic Tool"),
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL))
    {
        RegSetValueEx(hkey, TEXT("TxtPath"), 0, REG_SZ, (BYTE*)strTxtPath, sizeof(TCHAR)*(lstrlen(strTxtPath) + 1));

        RegCloseKey(hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\mmddk.h ===
/****************************************************************************/
/*                                                                          */
/*      MMDDK.H - Include file for Multimedia Device Development Kit        */
/*                                                                          */
/*      Note: You must include the WINDOWS.H and MMSYSTEM.H header files    */
/*            before including this file.                                   */
/*                                                                          */
/*      Copyright (c) 1990-1998, Microsoft Corp.  All rights reserved.      */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MMDDK
#define _INC_MMDDK

#include "pshpack1.h"   // Assume byte packing throughout

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *        MMNOMIDIDEV         - MIDI support
 *        MMNOWAVEDEV         - Waveform support
 *        MMNOAUXDEV          - Auxiliary output support
 *        MMNOMIXERDEV        - Mixer support
 *        MMNOTIMERDEV        - Timer support
 *        MMNOJOYDEV          - Joystick support
 *        MMNOMCIDEV          - MCI support
 *        MMNOTASKDEV         - Task support
 */
#ifdef MMNOTIMER
  #define MMNOTIMERDEV
#endif
#ifdef MMNOWAVE
  #define MMNOWAVEDEV
#endif
#ifdef MMNOMIDI
  #define MMNOMIDIDEV
#endif
#ifdef MMNOAUX
  #define MMNOAUXDEV
#endif
#ifdef MMNOJOY
  #define MMNOJOYDEV
#endif
#ifdef MMNOMMIO
  #define MMNOMMIODEV
#endif
#ifdef MMNOMCI
  #define MMNOMCIDEV
#endif


/***************************************************************************

                       Helper functions for drivers

***************************************************************************/

#ifndef NODRIVERS
#define DRV_LOAD               0x0001
#define DRV_ENABLE             0x0002
#define DRV_OPEN               0x0003
#define DRV_CLOSE              0x0004
#define DRV_DISABLE            0x0005
#define DRV_FREE               0x0006
#define DRV_CONFIGURE          0x0007
#define DRV_QUERYCONFIGURE     0x0008
#define DRV_INSTALL            0x0009
#define DRV_REMOVE             0x000A

#define DRV_RESERVED           0x0800
#define DRV_USER               0x4000

#define DRIVERS_SECTION  TEXT("DRIVERS32")     // Section name for installed drivers
#define MCI_SECTION      TEXT("MCI32")         // Section name for installed MCI drivers

#endif /* !NODRIVERS */

#define DCB_NOSWITCH   0x0008           // don't switch stacks for callback
#define DCB_TYPEMASK   0x0007           // callback type mask
#define DCB_NULL       0x0000           // unknown callback type

// flags for wFlags parameter of DriverCallback()
#define DCB_WINDOW     0x0001           // dwCallback is a HWND
#define DCB_TASK       0x0002           // dwCallback is a HTASK
#define DCB_FUNCTION   0x0003           // dwCallback is a FARPROC
#define DCB_EVENT      0x0005           // dwCallback is an EVENT

BOOL APIENTRY DriverCallback(DWORD_PTR dwCallback, DWORD dwFlags,
    HDRVR hDevice, DWORD dwMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

// generic prototype for audio device driver entry-point functions
// midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage()
//typedef DWORD (SOUNDDEVMSGPROC)(WORD, WORD, DWORD, DWORD, DWORD);
//typedef SOUNDDEVMSGPROC FAR *LPSOUNDDEVMSGPROC;

#define DRVM_INIT               100
#define DRVM_EXIT               101
#define DRVM_DISABLE            102
#define DRVM_ENABLE             103


// message base for driver specific messages.
//
#define DRVM_MAPPER             0x2000
#define DRVM_USER               0x4000
#define DRVM_MAPPER_STATUS      (DRVM_MAPPER+0)
#define DRVM_MAPPER_RECONFIGURE (DRVM_MAPPER+1)
#define	DRVM_MAPPER_QUERYDEST	                  (DRVM_MAPPER+20) /* ;Internal*/
#define DRVM_MAPPER_PREFERRED_GET                 (DRVM_MAPPER+21)
#define DRVM_MAPPER_PREFERRED_SET                 (DRVM_MAPPER+22) /* ;Internal*/

#define DRV_QUERYDRVENTRY            (DRV_RESERVED + 1)         /* ;Internal*/
#define DRV_QUERYDEVNODE             (DRV_RESERVED + 2)         /* ;Internal*/
#define DRV_QUERYNAME                (DRV_RESERVED + 3)         /* ;Internal*/
#define DRV_QUERYDRIVERIDS           (DRV_RESERVED + 4)         /* ;Internal*/
#define DRV_QUERYMAPPABLE            (DRV_RESERVED + 5)         /* ;Internal*/
#define DRV_QUERYMAPID               (DRV_RESERVED + 6)         /* ;Internal*/
#define DRV_QUERYNUMPORTS            (DRV_RESERVED + 8)         /* ;Internal*/
#define DRV_QUERYMODULE              (DRV_RESERVED + 9)
#define DRV_QUERYFILENAME            (DRV_RESERVED + 10)        /* ;Internal*/
#define DRV_PNPINSTALL               (DRV_RESERVED + 11)
#define DRV_QUERYDEVICEINTERFACE     (DRV_RESERVED + 12)        /* ;Internal*/
#define DRV_QUERYDEVICEINTERFACESIZE (DRV_RESERVED + 13)        /* ;Internal*/

//
// DRVM_MAPPER_PREFERRED_GET flags
//
#define DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY   0x00000001



//
// messages that have IOCTL format
//    dw1 = NULL or handle
//    dw2 = NULL or ptr to DRVM_IOCTL_DATA
//    return is MMRESULT
//
#define DRVM_IOCTL                0x100
#define DRVM_ADD_THRU             (DRVM_IOCTL+1)
#define DRVM_REMOVE_THRU          (DRVM_IOCTL+2)
#define DRVM_IOCTL_LAST           (DRVM_IOCTL+5)

typedef struct {
    DWORD  dwSize; // size of this structure (inclusive)
    DWORD  dwCmd;  // IOCTL command code, 0x80000000 and above reserved for system
    } DRVM_IOCTL_DATA, FAR * LPDRVM_IOCTL_DATA;

// command code ranges for dwCmd field of DRVM_IOCTL message
// codes from 0 to 0x7FFFFFFF are user defined
// codes from 0x80000000 to 0xFFFFFFFF are reserved for future
// definition by microsoft
//
#define DRVM_IOCTL_CMD_USER   0x00000000L
#define DRVM_IOCTL_CMD_SYSTEM 0x80000000L

// device ID for 386 AUTODMA VxD
#define VADMAD_Device_ID    0X0444

/* PnP version of media device caps */
typedef struct {
    DWORD	cbSize;
    LPVOID	pCaps;
} MDEVICECAPSEX;

#ifndef MMNOWAVEDEV
/****************************************************************************

                       Waveform device driver support

****************************************************************************/

// maximum number of wave device drivers loaded
#ifndef NOWIN31
#define MAXWAVEDRIVERS 10
#else
#define MAXWAVEDRIVERS 4
#endif

#define WODM_INIT      DRVM_INIT
#define WIDM_INIT      DRVM_INIT

// waveform input and output device open information structure
typedef struct waveopendesc_tag {
    HWAVE          hWave;             // handle
    LPWAVEFORMAT   lpFormat;          // format of wave data
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    UINT           uMappedDeviceID;   // device to map to if WAVE_MAPPED set
    DWORD_PTR      dnDevNode;         /* if device is PnP */
} WAVEOPENDESC;
typedef WAVEOPENDESC FAR *LPWAVEOPENDESC;

// messages sent to wodMessage() entry-point function
#define WODM_GETNUMDEVS       3
#define WODM_GETDEVCAPS       4
#define WODM_OPEN             5
#define WODM_CLOSE            6
#define WODM_PREPARE          7
#define WODM_UNPREPARE        8
#define WODM_WRITE            9
#define WODM_PAUSE            10
#define WODM_RESTART          11
#define WODM_RESET            12
#define WODM_GETPOS           13
#define WODM_GETPITCH         14
#define WODM_SETPITCH         15
#define WODM_GETVOLUME        16
#define WODM_SETVOLUME        17
#define WODM_GETPLAYBACKRATE  18
#define WODM_SETPLAYBACKRATE  19
#define WODM_BREAKLOOP        20
// #if (WINVER >= 0x030B)
#define WODM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEOUT_MAPPER_STATUS_DEVICE    0
#define WAVEOUT_MAPPER_STATUS_MAPPED    1
#define WAVEOUT_MAPPER_STATUS_FORMAT    2
// #endif /* WINVER >= 0x030B */
#define WODM_BUSY             21

// messages sent to widMessage() entry-point function
#define WIDM_GETNUMDEVS  50
#define WIDM_GETDEVCAPS  51
#define WIDM_OPEN        52
#define WIDM_CLOSE       53
#define WIDM_PREPARE     54
#define WIDM_UNPREPARE   55
#define WIDM_ADDBUFFER   56
#define WIDM_START       57
#define WIDM_STOP        58
#define WIDM_RESET       59
#define WIDM_GETPOS      60
// #if (WINVER >= 0x030B)
#define WIDM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEIN_MAPPER_STATUS_DEVICE     0
#define WAVEIN_MAPPER_STATUS_MAPPED     1
#define WAVEIN_MAPPER_STATUS_FORMAT     2
// #endif /* WINVER >= 0x30B */

#endif // ifndef MMNOWAVEDEV


#ifndef MMNOMIDIDEV
/****************************************************************************

                          MIDI device driver support

****************************************************************************/

// maximum number of MIDI device drivers loaded
#ifndef NOWIN31
#define MAXMIDIDRIVERS 10
#else
#define MAXMIDIDRIVERS 4
#endif

#define MODM_USER      DRVM_USER
#define MIDM_USER      DRVM_USER
#define MODM_MAPPER    DRVM_MAPPER
#define MIDM_MAPPER    DRVM_MAPPER

#define MODM_INIT      DRVM_INIT
#define MIDM_INIT      DRVM_INIT

#ifndef MMNOMIDI   // This protects the definition of HMIDI in WINMM.H
                   // Win 3.1 works the same way
typedef struct midiopenstrmid_tag {
    DWORD          dwStreamID;
    UINT           uDeviceID;
} MIDIOPENSTRMID;
// MIDI input and output device open information structure
typedef struct midiopendesc_tag {
    HMIDI          hMidi;             // handle
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    DWORD_PTR      dnDevNode;         // DevNode
    DWORD          cIds;              // If stream open, # stream ids
    MIDIOPENSTRMID rgIds[1];          // Array of device ID's (actually [cIds])
} MIDIOPENDESC;
typedef MIDIOPENDESC FAR *LPMIDIOPENDESC;
#endif // MMNOMIDI


/* Flags for MODM_OPEN */
#define MIDI_IO_PACKED      0x00000000L     /* Compatibility mode */
#define MIDI_IO_COOKED      0x00000002L

// messages sent to modMessage() entry-point function
#define MODM_GETNUMDEVS     1
#define MODM_GETDEVCAPS     2
#define MODM_OPEN           3
#define MODM_CLOSE          4
#define MODM_PREPARE        5
#define MODM_UNPREPARE      6
#define MODM_DATA           7
#define MODM_LONGDATA       8
#define MODM_RESET          9
#define MODM_GETVOLUME      10
#define MODM_SETVOLUME      11
#define MODM_CACHEPATCHES       12
#define MODM_CACHEDRUMPATCHES   13

#if (WINVER >= 0x400)
#define MODM_STRMDATA               14
#define MODM_GETPOS                 17
#define MODM_PAUSE                  18
#define MODM_RESTART                19
#define MODM_STOP                   20
#define MODM_PROPERTIES             21
#define MODM_RECONFIGURE            (MODM_USER+0x0768)
#endif


// messages sent to midMessage() entry-point function
#define MIDM_GETNUMDEVS  53
#define MIDM_GETDEVCAPS  54
#define MIDM_OPEN        55
#define MIDM_CLOSE       56
#define MIDM_PREPARE     57
#define MIDM_UNPREPARE   58
#define MIDM_ADDBUFFER   59
#define MIDM_START       60
#define MIDM_STOP        61
#define MIDM_RESET       62

#endif // ifndef MMNOMIDIDEV


#ifndef MMNOAUXDEV
/****************************************************************************

                    Auxiliary audio device driver support

****************************************************************************/

// maximum number of auxiliary device drivers loaded
#ifndef NOWIN31
#define MAXAUXDRIVERS 10
#else
#define MAXAUXDRIVERS 4
#endif

#define AUXM_INIT      DRVM_INIT

// messages sent to auxMessage() entry-point function
#define AUXDM_GETNUMDEVS    3
#define AUXDM_GETDEVCAPS    4
#define AUXDM_GETVOLUME     5
#define AUXDM_SETVOLUME     6

#endif // ifndef MMNOAUXDEV

// #if (WINVER >= 0x030B)
#ifndef MMNOMIXERDEV

#ifndef MAXMIXERDRIVERS

//
//  maximum number of mixer drivers that can be loaded by MSMIXMGR.DLL
//
#define MAXMIXERDRIVERS     10


//
//  mixer device open information structure
//
//
typedef struct tMIXEROPENDESC
{
    HMIXER          hmx;            // handle that will be used
    LPVOID          pReserved0;     // reserved--driver should ignore
    DWORD_PTR       dwCallback;     // callback
    DWORD_PTR       dwInstance;     // app's private instance information
    DWORD_PTR       dnDevNode;      // if device is PnP

} MIXEROPENDESC, *PMIXEROPENDESC, FAR *LPMIXEROPENDESC;



//
//
//
//
#define MXDM_INIT                   100
#define MXDM_USER                   DRV_USER

#define MXDM_BASE                   (1)
#define MXDM_GETNUMDEVS             (MXDM_BASE + 0)
#define MXDM_GETDEVCAPS             (MXDM_BASE + 1)
#define MXDM_OPEN                   (MXDM_BASE + 2)
#define MXDM_CLOSE                  (MXDM_BASE + 3)
#define MXDM_GETLINEINFO            (MXDM_BASE + 4)
#define MXDM_GETLINECONTROLS        (MXDM_BASE + 5)
#define MXDM_GETCONTROLDETAILS      (MXDM_BASE + 6)
#define MXDM_SETCONTROLDETAILS      (MXDM_BASE + 7)

#endif // MAXMIXERDRIVERS

#endif // MMNOMIXERDEV
// #endif /* ifdef WINVER >= 0x030B */

#if !defined(MMNOTIMERDEV)
/****************************************************************************

                        Timer device driver support

****************************************************************************/

typedef struct timerevent_tag {
    WORD                wDelay;         // delay required
    WORD                wResolution;    // resolution required
    LPTIMECALLBACK      lpFunction;     // ptr to callback function
    DWORD               dwUser;         // user DWORD
    WORD                wFlags;         // defines how to program event
    WORD                wReserved1;     // structure packing
} TIMEREVENT;
typedef TIMEREVENT FAR *LPTIMEREVENT;

// messages sent to tddMessage() function
#define TDD_KILLTIMEREVENT  (DRV_RESERVED+0)  // indices into a table of
#define TDD_SETTIMEREVENT   (DRV_RESERVED+4)  // functions; thus offset by
#define TDD_GETSYSTEMTIME   (DRV_RESERVED+8)  // four each time...
#define TDD_GETDEVCAPS      (DRV_RESERVED+12) // room for future expansion
#define TDD_BEGINMINPERIOD  (DRV_RESERVED+16) // room for future expansion
#define TDD_ENDMINPERIOD    (DRV_RESERVED+20) // room for future expansion

#endif // ifndef MMNOTIMERDEV


#ifndef MMNOJOYDEV
/****************************************************************************

                       Joystick device driver support

****************************************************************************/

/* RegisterWindowMessage with this to get msg id of config changes */
#define JOY_CONFIGCHANGED_MSGSTRING     "MSJSTICK_VJOYD_MSGSTR"

/* pre-defined joystick types */
#define JOY_HW_NONE                     0
#define JOY_HW_CUSTOM                   1
#define JOY_HW_2A_2B_GENERIC            2
#define JOY_HW_2A_4B_GENERIC            3
#define JOY_HW_2B_GAMEPAD               4
#define JOY_HW_2B_FLIGHTYOKE            5
#define JOY_HW_2B_FLIGHTYOKETHROTTLE    6
#define JOY_HW_3A_2B_GENERIC            7
#define JOY_HW_3A_4B_GENERIC            8
#define JOY_HW_4B_GAMEPAD               9
#define JOY_HW_4B_FLIGHTYOKE            10
#define JOY_HW_4B_FLIGHTYOKETHROTTLE    11
#define JOY_HW_LASTENTRY                12

/* calibration flags */
#define JOY_ISCAL_XY            0x00000001l     /* XY are calibrated */
#define JOY_ISCAL_Z             0x00000002l     /* Z is calibrated */
#define JOY_ISCAL_R             0x00000004l     /* R is calibrated */
#define JOY_ISCAL_U             0x00000008l     /* U is calibrated */
#define JOY_ISCAL_V             0x00000010l     /* V is calibrated */
#define JOY_ISCAL_POV           0x00000020l     /* POV is calibrated */

/* point of view constants */
#define JOY_POV_NUMDIRS          4
#define JOY_POVVAL_FORWARD       0
#define JOY_POVVAL_BACKWARD      1
#define JOY_POVVAL_LEFT          2
#define JOY_POVVAL_RIGHT         3

/* Specific settings for joystick hardware */
#define JOY_HWS_HASZ            0x00000001l     /* has Z info? */
#define JOY_HWS_HASPOV          0x00000002l     /* point of view hat present */
#define JOY_HWS_POVISBUTTONCOMBOS 0x00000004l   /* pov done through combo of buttons */
#define JOY_HWS_POVISPOLL       0x00000008l     /* pov done through polling */
#define JOY_HWS_ISYOKE          0x00000010l     /* joystick is a flight yoke */
#define JOY_HWS_ISGAMEPAD       0x00000020l     /* joystick is a game pad */
#define JOY_HWS_ISCARCTRL       0x00000040l     /* joystick is a car controller */
/* X defaults to J1 X axis */
#define JOY_HWS_XISJ1Y          0x00000080l     /* X is on J1 Y axis */
#define JOY_HWS_XISJ2X          0x00000100l     /* X is on J2 X axis */
#define JOY_HWS_XISJ2Y          0x00000200l     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
#define JOY_HWS_YISJ1X          0x00000400l     /* Y is on J1 X axis */
#define JOY_HWS_YISJ2X          0x00000800l     /* Y is on J2 X axis */
#define JOY_HWS_YISJ2Y          0x00001000l     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
#define JOY_HWS_ZISJ1X          0x00002000l     /* Z is on J1 X axis */
#define JOY_HWS_ZISJ1Y          0x00004000l     /* Z is on J1 Y axis */
#define JOY_HWS_ZISJ2X          0x00008000l     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
#define JOY_HWS_POVISJ1X        0x00010000l     /* pov done through J1 X axis */
#define JOY_HWS_POVISJ1Y        0x00020000l     /* pov done through J1 Y axis */
#define JOY_HWS_POVISJ2X        0x00040000l     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
#define JOY_HWS_HASR            0x00080000l     /* has R (4th axis) info */
#define JOY_HWS_RISJ1X          0x00100000l     /* R done through J1 X axis */
#define JOY_HWS_RISJ1Y          0x00200000l     /* R done through J1 Y axis */
#define JOY_HWS_RISJ2Y          0x00400000l     /* R done through J2 X axis */
/* U & V for future hardware */
#define JOY_HWS_HASU            0x00800000l     /* has U (5th axis) info */
#define JOY_HWS_HASV            0x01000000l     /* has V (6th axis) info */

/* Usage settings */
#define JOY_US_HASRUDDER        0x00000001l     /* joystick configured with rudder */
#define JOY_US_PRESENT          0x00000002l     /* is joystick actually present? */
#define JOY_US_ISOEM            0x00000004l     /* joystick is an OEM defined type */

/* struct for storing x,y, z, and rudder values */
typedef struct joypos_tag {
    DWORD       dwX;
    DWORD       dwY;
    DWORD       dwZ;
    DWORD       dwR;
    DWORD       dwU;
    DWORD       dwV;
} JOYPOS, FAR *LPJOYPOS;

/* struct for storing ranges */
typedef struct joyrange_tag {
    JOYPOS      jpMin;
    JOYPOS      jpMax;
    JOYPOS      jpCenter;
} JOYRANGE,FAR *LPJOYRANGE;

typedef struct joyreguservalues_tag {
    DWORD       dwTimeOut;      /* value at which to timeout joystick polling */
    JOYRANGE    jrvRanges;      /* range of values app wants returned for axes */
    JOYPOS      jpDeadZone;     /* area around center to be considered
                                   as "dead". specified as a percentage
                                   (0-100). Only X & Y handled by system driver */
} JOYREGUSERVALUES, FAR *LPJOYREGUSERVALUES;

typedef struct joyreghwsettings_tag {
    DWORD       dwFlags;
    DWORD       dwNumButtons;           /* number of buttons */
} JOYREGHWSETTINGS, FAR *LPJOYHWSETTINGS;

/* range of values returned by the hardware (filled in by calibration) */
typedef struct joyreghwvalues_tag {
    JOYRANGE    jrvHardware;            /* values returned by hardware */
    DWORD       dwPOVValues[JOY_POV_NUMDIRS];/* POV values returned by hardware */
    DWORD       dwCalFlags;             /* what has been calibrated */
} JOYREGHWVALUES, FAR *LPJOYREGHWVALUES;

/* hardware configuration */
typedef struct joyreghwconfig_tag {
    JOYREGHWSETTINGS    hws;            /* hardware settings */
    DWORD               dwUsageSettings;/* usage settings */
    JOYREGHWVALUES      hwv;            /* values returned by hardware */
    DWORD               dwType;         /* type of joystick */
    DWORD               dwReserved;     /* reserved for OEM drivers */
} JOYREGHWCONFIG, FAR *LPJOYREGHWCONFIG;

// joystick calibration info structure
typedef struct joycalibrate_tag {
    WORD    wXbase;
    WORD    wXdelta;
    WORD    wYbase;
    WORD    wYdelta;
    WORD    wZbase;
    WORD    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;

// prototype for joystick message function
typedef DWORD (JOYDEVMSGPROC)(DWORD, UINT, LONG, LONG);
typedef JOYDEVMSGPROC FAR *LPJOYDEVMSGPROC;

// messages sent to joystick driver's DriverProc() function
#define JDD_GETNUMDEVS          (DRV_RESERVED + 0x0001)
#define JDD_GETDEVCAPS          (DRV_RESERVED + 0x0002)
#define JDD_GETPOS              (DRV_RESERVED + 0x0101)
#define JDD_SETCALIBRATION      (DRV_RESERVED + 0x0102)
#define JDD_CONFIGCHANGED       (DRV_RESERVED + 0x0103)
#define JDD_GETPOSEX            (DRV_RESERVED + 0x0104)

#endif // ifndef MMNOJOYDEV

#ifndef MAKELRESULT
#define MAKELRESULT(low, high)   ((LRESULT)MAKELONG(low, high))
#endif//MAKELRESULT


#ifndef MMNOMCIDEV
/****************************************************************************

                        MCI device driver support

****************************************************************************/


// internal MCI messages
#define MCI_OPEN_DRIVER             0x0801
#define MCI_CLOSE_DRIVER            0x0802

#define MAKEMCIRESOURCE(wRet, wRes) MAKELRESULT((wRet), (wRes))

// string return values only used with MAKEMCIRESOURCE
#define MCI_FALSE                       (MCI_STRING_OFFSET + 19)
#define MCI_TRUE                        (MCI_STRING_OFFSET + 20)

// resource string return values
#define MCI_FORMAT_RETURN_BASE          MCI_FORMAT_MILLISECONDS_S
#define MCI_FORMAT_MILLISECONDS_S       (MCI_STRING_OFFSET + 21)
#define MCI_FORMAT_HMS_S                (MCI_STRING_OFFSET + 22)
#define MCI_FORMAT_MSF_S                (MCI_STRING_OFFSET + 23)
#define MCI_FORMAT_FRAMES_S             (MCI_STRING_OFFSET + 24)
#define MCI_FORMAT_SMPTE_24_S           (MCI_STRING_OFFSET + 25)
#define MCI_FORMAT_SMPTE_25_S           (MCI_STRING_OFFSET + 26)
#define MCI_FORMAT_SMPTE_30_S           (MCI_STRING_OFFSET + 27)
#define MCI_FORMAT_SMPTE_30DROP_S       (MCI_STRING_OFFSET + 28)
#define MCI_FORMAT_BYTES_S              (MCI_STRING_OFFSET + 29)
#define MCI_FORMAT_SAMPLES_S            (MCI_STRING_OFFSET + 30)
#define MCI_FORMAT_TMSF_S               (MCI_STRING_OFFSET + 31)

#define MCI_VD_FORMAT_TRACK_S           (MCI_VD_OFFSET + 5)

#define WAVE_FORMAT_PCM_S               (MCI_WAVE_OFFSET + 0)
#define WAVE_MAPPER_S                   (MCI_WAVE_OFFSET + 1)

#define MCI_SEQ_MAPPER_S                (MCI_SEQ_OFFSET + 5)
#define MCI_SEQ_FILE_S                  (MCI_SEQ_OFFSET + 6)
#define MCI_SEQ_MIDI_S                  (MCI_SEQ_OFFSET + 7)
#define MCI_SEQ_SMPTE_S                 (MCI_SEQ_OFFSET + 8)
#define MCI_SEQ_FORMAT_SONGPTR_S        (MCI_SEQ_OFFSET + 9)
#define MCI_SEQ_NONE_S                  (MCI_SEQ_OFFSET + 10)
#define MIDIMAPPER_S                    (MCI_SEQ_OFFSET + 11)

#define MCI_TABLE_NOT_PRESENT   ((UINT)-1)
// parameters for internal version of MCI_OPEN message sent from
// mciOpenDevice() to the driver
typedef struct {
    MCIDEVICEID wDeviceID;             // device ID
    LPCWSTR     lpstrParams;           // parameter string for entry in SYSTEM.INI
    UINT        wCustomCommandTable;   // custom command table ((-1) if none)
                                       // filled in by the driver
    UINT        wType;                 // driver type
                                       // filled in by the driver
} MCI_OPEN_DRIVER_PARMS;
typedef MCI_OPEN_DRIVER_PARMS FAR * LPMCI_OPEN_DRIVER_PARMS;

// maximum length of an MCI device type
#define MCI_MAX_DEVICE_TYPE_LENGTH 80

// flags for mciSendCommandInternal() which direct mciSendString() how to
// interpret the return value
#define MCI_RESOURCE_RETURNED       0x00010000  // resource ID
#define MCI_COLONIZED3_RETURN       0x00020000  // colonized ID, 3 bytes data
#define MCI_COLONIZED4_RETURN       0x00040000  // colonized ID, 4 bytes data
#define MCI_INTEGER_RETURNED        0x00080000  // integer conversion needed
#define MCI_RESOURCE_DRIVER         0x00100000  // driver owns returned resource

// invalid command table ID
#define MCI_NO_COMMAND_TABLE    ((UINT)(-1))

// command table information type tags
#define MCI_COMMAND_HEAD        0
#define MCI_STRING              1
#define MCI_INTEGER             2
#define MCI_END_COMMAND         3
#define MCI_RETURN              4
#define MCI_FLAG                5
#define MCI_END_COMMAND_LIST    6
#define MCI_RECT                7
#define MCI_CONSTANT            8
#define MCI_END_CONSTANT        9
#define MCI_HWND               10
#define MCI_HPAL               11
#define MCI_HDC                12

// function prototypes for MCI driver functions
DWORD_PTR APIENTRY mciGetDriverData(MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciSetDriverData(MCIDEVICEID wDeviceID, DWORD_PTR dwData);
UINT      APIENTRY mciDriverYield (MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciDriverNotify (HANDLE hwndCallback, MCIDEVICEID wDeviceID,
    UINT uStatus);
UINT  APIENTRY mciLoadCommandResource(HANDLE hInstance,
    LPCWSTR lpResName, UINT wType);
BOOL  APIENTRY mciFreeCommandResource(UINT wTable);

#endif // ifndef MMNOMCIDEV


#ifndef MMNOTASKDEV
/*****************************************************************************

                               Task support

*****************************************************************************/

// error return values
#define TASKERR_NOTASKSUPPORT 1
#define TASKERR_OUTOFMEMORY   2

// task support function prototypes
typedef VOID (TASKCALLBACK) (DWORD dwInst);

typedef TASKCALLBACK FAR *LPTASKCALLBACK;

UINT    APIENTRY mmTaskCreate(LPTASKCALLBACK lpfn, HANDLE FAR * lph, DWORD_PTR dwInst);
VOID    APIENTRY mmTaskBlock(DWORD h);
BOOL    APIENTRY mmTaskSignal(DWORD h);
VOID    APIENTRY mmTaskYield(VOID);
DWORD   APIENTRY mmGetCurrentTask(VOID);

#endif // endif MMNOTASKDEV

#define MMDDKINC

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include "poppack.h"        /* Revert to default packing */

#endif /* _INC_MMDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\reginfo.h ===
/****************************************************************************
 *
 *    File: reginfo.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather and hold registry information 
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef REGINFO_H
#define REGINFO_H

enum RegErrorType
{
    RET_NOERROR = 0,
    RET_MISSINGKEY,
    RET_MISSINGVALUE,
    RET_VALUEWRONGTYPE,
    RET_VALUEWRONGDATA
};

struct RegError
{
    HKEY m_hkeyRoot; // HKLM, HKCU, etc.
    TCHAR m_szKey[300];
    TCHAR m_szValue[100];
    RegErrorType m_ret;
    DWORD m_dwTypeExpected; // REG_DWORD, REG_SZ, or REG_BINARY
    DWORD m_dwTypeActual;

    // The following are used if m_dwType is REG_DWORD:
    DWORD m_dwExpected;
    DWORD m_dwActual;

    // The following are used if m_dwType is REG_SZ:
    TCHAR m_szExpected[200];
    TCHAR m_szActual[200];

    // The following are used if m_dwType is REG_BINARY:
    BYTE m_bExpected[200];
    BYTE m_bActual[200];
    DWORD m_dwExpectedSize;
    DWORD m_dwActualSize;

    RegError* m_pRegErrorNext;
};

enum CheckRegFlags
{
    CRF_NONE = 0,
    CRF_LEAF = 1, // if string is a path, just compare against the leaf
};

HRESULT CheckRegDword(RegError** ppRegErrorFirst, HKEY hkeyRoot, TCHAR* pszKey, TCHAR* pszValue, DWORD dwExpected);
HRESULT CheckRegString(RegError** ppRegErrorFirst, HKEY hkeyRoot, TCHAR* pszKey, TCHAR* pszValue, TCHAR* pszExpected, CheckRegFlags crf = CRF_NONE, HRESULT* phrError = NULL );
HRESULT CheckRegBinary(RegError** ppRegErrorFirst, HKEY hkeyRoot, TCHAR* pszKey, TCHAR* pszValue, BYTE* pbDataExpected, DWORD dwSizeExpected);
VOID DestroyReg( RegError** ppRegErrorFirst );

#endif // REGINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\save.cpp ===
/****************************************************************************
 *
 *    File: save.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Save gathered information to a file in text or CSV format
 *
 * Note that the text file is always ANSI, even on Unicode builds, to make
 * the resulting file easier to use (e.g., Win9x Notepad doesn't understand 
 * Unicode).
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <tchar.h>
#include <Windows.h>
#include <multimon.h>
#include <stdio.h>
#include "reginfo.h"
#include "sysinfo.h"
#include "fileinfo.h"
#include "dispinfo.h"
#include "sndinfo.h"
#include "musinfo.h"
#include "showinfo.h"
#include "inptinfo.h"
#include "netinfo.h"
#include "save.h"


static HRESULT SaveBugInfo(FILE* pFile, BugInfo* pBugInfo);
static HRESULT SaveSysInfo(FILE* pFile, SysInfo* pSysInfo);
static HRESULT SaveNotesInfo(FILE* pFile, SysInfo* pSysInfo, DisplayInfo* pDisplayInfoFirst, SoundInfo* pSoundInfoFirst);
static HRESULT SaveNote(FILE* pFile, TCHAR* strNote );
static HRESULT SaveDxComponentFileInfo(FILE* pFile, FileInfo* pFileInfoFirst);
static HRESULT SaveDxWinComponentFileInfo(FILE* pFile, FileInfo* pFileInfoFirst);
static HRESULT SaveBackedUpFileInfo(FILE* pFile);
static HRESULT SaveDisplayInfo(FILE* pFile, DisplayInfo* pDisplayInfoFirst);
static HRESULT SaveSoundInfo(FILE* pFile, SoundInfo* pSoundInfoFirst);
static HRESULT SaveMusicInfo(FILE* pFile, MusicInfo* pMusicInfo);
static HRESULT SaveShowInfo(FILE* pFile, ShowInfo* pShowInfo);
static HRESULT SaveInputInfo(FILE* pFile, InputInfo* pInputInfo);
static HRESULT SaveNetInfo(FILE* pFile, NetInfo* pNetInfo);
static HRESULT SaveInactiveDriverInfo(FILE* pFile, DisplayInfo* pDisplayInfoFirst);
static HRESULT SaveRegistryErrorInfo(FILE* pFile, RegError* pRegErrorFirst);
static HRESULT SaveDebugLevels(FILE* pFile, SysInfo* pSysInfo);



/****************************************************************************
 *
 *  SaveAllInfo - Save all gathered information in text format.
 *
 ****************************************************************************/
HRESULT SaveAllInfo(TCHAR* pszFile, SysInfo* pSysInfo, 
    FileInfo* pFileInfoWinComponentsFirst, FileInfo* pFileInfoComponentsFirst, 
    DisplayInfo* pDisplayInfoFirst, SoundInfo* pSoundInfoFirst,
    MusicInfo* pMusicInfo, InputInfo* pInputInfo, 
    NetInfo* pNetInfo, ShowInfo* pShowInfo, BugInfo* pBugInfo)
{
    HRESULT hr = S_OK;
    FILE* pFile;

    pFile = _tfopen(pszFile, TEXT("wt"));
    if (pFile == NULL)
        goto LEnd;

    if (pBugInfo != NULL)
    {
        if (FAILED(hr = SaveBugInfo(pFile, pBugInfo)))
            goto LEnd;
    }

    if (FAILED(hr = SaveSysInfo(pFile, pSysInfo)))
        goto LEnd;
    
    if (FAILED(hr = SaveNotesInfo(pFile, pSysInfo, pDisplayInfoFirst, pSoundInfoFirst)))
        goto LEnd;

    if (FAILED(hr = SaveDxComponentFileInfo(pFile, pFileInfoComponentsFirst)))
        goto LEnd;
    
    if (FAILED(hr = SaveDxWinComponentFileInfo(pFile, pFileInfoWinComponentsFirst)))
        goto LEnd;
    
    if (FAILED(hr = SaveBackedUpFileInfo(pFile)))
        goto LEnd;
    
    if (FAILED(hr = SaveDisplayInfo(pFile, pDisplayInfoFirst)))
        goto LEnd;

    if (FAILED(hr = SaveSoundInfo(pFile, pSoundInfoFirst)))
        goto LEnd;

    if (FAILED(hr = SaveMusicInfo(pFile, pMusicInfo)))
        goto LEnd;

    if (FAILED(hr = SaveShowInfo(pFile, pShowInfo)))
        goto LEnd;
    
    if (FAILED(hr = SaveInputInfo(pFile, pInputInfo)))
        goto LEnd;

    if (FAILED(hr = SaveNetInfo(pFile, pNetInfo)))
        goto LEnd;

    if (FAILED(hr = SaveInactiveDriverInfo(pFile, pDisplayInfoFirst)))
        goto LEnd;

    if (FAILED(hr = SaveDebugLevels(pFile, pSysInfo)))
        goto LEnd;

LEnd:
    if (pFile != NULL)
        fclose(pFile);
    return hr;
}


/****************************************************************************
 *
 *  SaveAllInfoCsv - Save all gathered information in CSV format.
 *
 ****************************************************************************/
HRESULT SaveAllInfoCsv(TCHAR* pszFile, SysInfo* pSysInfo, 
    FileInfo* pFileInfoComponentsFirst, DisplayInfo* pDisplayInfoFirst, 
    SoundInfo* pSoundInfoFirst, InputInfo* pInputInfo)
{
    HRESULT hr = S_OK;
    FILE* pFile;

    pFile = _tfopen(pszFile, TEXT("wt"));
    if (pFile == NULL)
        goto LEnd;

    // Date
    _ftprintf(pFile, TEXT("%02d%02d%d,%02d%02d"),
        pSysInfo->m_time.wMonth, pSysInfo->m_time.wDay, pSysInfo->m_time.wYear,
        pSysInfo->m_time.wHour, pSysInfo->m_time.wMinute);

    // Machine name
    _ftprintf(pFile, TEXT(",%s"), pSysInfo->m_szMachine);

    // DX Version
    _ftprintf(pFile, TEXT(",%s"), pSysInfo->m_szDirectXVersion);
    
    // OS
    _ftprintf(pFile, TEXT(",%s,%d.%d,%d,"),
        pSysInfo->m_szOS, pSysInfo->m_dwMajorVersion, pSysInfo->m_dwMinorVersion,
        LOWORD(pSysInfo->m_dwBuildNumber));
    _ftprintf(pFile, TEXT("%s"), pSysInfo->m_szCSDVersion);

    // Processor - string may have commas, so change them to semicolons
    TCHAR szProcessor[1024];
    TCHAR* psz;
    lstrcpy(szProcessor, pSysInfo->m_szProcessor);
    for (psz = szProcessor; *psz != TEXT('\0'); psz++)
    {
        if (*psz == TEXT(','))
            *psz = TEXT(';');
    }
    _ftprintf(pFile, TEXT(",%s"), szProcessor);

    // Display devices 
    // (chip type, matching ID, DAC type, disp memory, driver name, driver version)
    DisplayInfo* pDisplayInfo;
    pDisplayInfo = pDisplayInfoFirst;
    {
        _ftprintf(pFile, TEXT(",%s"), pDisplayInfo->m_szChipType);
        _ftprintf(pFile, TEXT(",%s"), pDisplayInfo->m_szKeyDeviceID);
        _ftprintf(pFile, TEXT(",%s"), pDisplayInfo->m_szDACType);
        _ftprintf(pFile, TEXT(",%s"), pDisplayInfo->m_szDisplayMemoryEnglish);
        _ftprintf(pFile, TEXT(",%s"), pDisplayInfo->m_szDriverName);
        _ftprintf(pFile, TEXT(",%s"), pDisplayInfo->m_szDriverVersion);
    }

    // Sound devices
    SoundInfo* pSoundInfo;
    for (pSoundInfo = pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfo->m_pSoundInfoNext)
    {
        _ftprintf(pFile, TEXT(",%s"), pSoundInfo->m_szDescription);
        _ftprintf(pFile, TEXT(",%s"), pSoundInfo->m_szDeviceID);
        _ftprintf(pFile, TEXT(",%s"), pSoundInfo->m_szDriverName);
        _ftprintf(pFile, TEXT(",%s"), pSoundInfo->m_szDriverVersion);
    }

LEnd:
    if (pFile != NULL)
        fclose(pFile);
    return hr;
}


/****************************************************************************
 *
 *  SaveBugInfo
 *
 ****************************************************************************/
HRESULT SaveBugInfo(FILE* pFile, BugInfo* pBugInfo)
{
    _ftprintf(pFile, TEXT("---------------\n"));
    _ftprintf(pFile, TEXT("Bug Information\n"));
    _ftprintf(pFile, TEXT("---------------\n"));
    _ftprintf(pFile, TEXT("      User name: %s\n"), pBugInfo->m_szName);
    _ftprintf(pFile, TEXT("          Email: %s\n"), pBugInfo->m_szEmail);
    _ftprintf(pFile, TEXT("        Company: %s\n"), pBugInfo->m_szCompany);
    _ftprintf(pFile, TEXT("          Phone: %s\n"), pBugInfo->m_szPhone);
    _ftprintf(pFile, TEXT("    City, State: %s\n"), pBugInfo->m_szCityState);
    _ftprintf(pFile, TEXT("        Country: %s\n"), pBugInfo->m_szCountry);
    _ftprintf(pFile, TEXT("Bug Description: %s\n"), pBugInfo->m_szBugDescription);
    _ftprintf(pFile, TEXT("    Repro Steps: %s\n"), pBugInfo->m_szReproSteps);
    _ftprintf(pFile, TEXT("   SW/HW Config: %s\n"), pBugInfo->m_szSwHw);
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}


/****************************************************************************
 *
 *  SaveSysInfo
 *
 ****************************************************************************/
HRESULT SaveSysInfo(FILE* pFile, SysInfo* pSysInfo)
{
    _ftprintf(pFile, TEXT("------------------\n"));
    _ftprintf(pFile, TEXT("System Information\n"));
    _ftprintf(pFile, TEXT("------------------\n"));
    _ftprintf(pFile, TEXT("Time of this report: %s\n"), pSysInfo->m_szTime);
    _ftprintf(pFile, TEXT("       Machine name: %s\n"), pSysInfo->m_szMachine);
    _ftprintf(pFile, TEXT("   Operating System: %s\n"), pSysInfo->m_szOSExLong);
    _ftprintf(pFile, TEXT("           Language: %s\n"), pSysInfo->m_szLanguages);
    _ftprintf(pFile, TEXT("System Manufacturer: %s\n"), pSysInfo->m_szSystemManufacturerEnglish);
    _ftprintf(pFile, TEXT("       System Model: %s\n"), pSysInfo->m_szSystemModelEnglish);
    _ftprintf(pFile, TEXT("               BIOS: %s\n"), pSysInfo->m_szBIOSEnglish);
    _ftprintf(pFile, TEXT("          Processor: %s\n"), pSysInfo->m_szProcessor);
    _ftprintf(pFile, TEXT("             Memory: %s\n"), pSysInfo->m_szPhysicalMemory);
    _ftprintf(pFile, TEXT("          Page File: %s\n"), pSysInfo->m_szPageFileEnglish);
    _ftprintf(pFile, TEXT("Primary File System: %s\n"), pSysInfo->m_szD3D8CacheFileSystem );
    _ftprintf(pFile, TEXT("    DirectX Version: %s\n"), pSysInfo->m_szDirectXVersionLong);
    _ftprintf(pFile, TEXT("DX Setup Parameters: %s\n"), pSysInfo->m_szSetupParam);
    
    TCHAR szUnicode[1024];
    TCHAR szBit[1024];

#ifdef _WIN64
    _tcscpy(szBit, TEXT(" 64bit"));
#else
    _tcscpy(szBit, TEXT(" 32bit"));
#endif

#ifdef UNICODE
    _tcscpy(szUnicode, TEXT(" Unicode"));
#else
    _tcscpy(szUnicode, TEXT(""));
#endif

    _ftprintf(pFile, TEXT("     DxDiag Version: %s%s%s\n"), pSysInfo->m_szDxDiagVersion, szBit, szUnicode );
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}




/****************************************************************************
 *
 *  SaveNote
 *
 ****************************************************************************/
HRESULT SaveNote(FILE* pFile, TCHAR* strNote )
{
    TCHAR strBuffer[1024*7]; 
    _tcsncpy( strBuffer, strNote, 1024*7-1 );
    strBuffer[1024*7-1]=0;

    TCHAR* pEndOfLine;
    TCHAR* pCurrent = strBuffer;
    TCHAR* pStartOfNext;
    BOOL bFirstTime = TRUE;

    pEndOfLine = _tcschr( pCurrent, TEXT('\r') );
    if( pEndOfLine == NULL )
    {
        _ftprintf(pFile, TEXT("%s\n"), pCurrent );
        return S_OK;
    }

    while(TRUE) 
    {
        *pEndOfLine = 0;
        pStartOfNext = pEndOfLine + 2;

        // Output the current line, iff its not a "To test" line
        if( _tcsstr( pCurrent, TEXT("To test") ) == NULL )
        {
            // Ouput trailing spaces everytime except the first time
            if( !bFirstTime )
                _ftprintf(pFile, TEXT("                     ") );
            bFirstTime = FALSE;

            _ftprintf(pFile, TEXT("%s\n"), pCurrent );
        }

        // Advance current
        pCurrent = pStartOfNext;

        // Look for the end of the next, and stop if there's no more
        pEndOfLine = _tcschr( pStartOfNext, TEXT('\r') );
        if( pEndOfLine == NULL )
            break;
    }

    return S_OK;
}


/****************************************************************************
 *
 *  SaveNotesInfo
 *
 ****************************************************************************/
HRESULT SaveNotesInfo(FILE* pFile, SysInfo* pSysInfo, 
                      DisplayInfo* pDisplayInfoFirst, SoundInfo* pSoundInfoFirst)
{
    DisplayInfo* pDisplayInfo;
    SoundInfo* pSoundInfo;
    DWORD dwIndex;

    _ftprintf(pFile, TEXT("------------\n"));
    _ftprintf(pFile, TEXT("DxDiag Notes\n"));
    _ftprintf(pFile, TEXT("------------\n"));
    _ftprintf(pFile, TEXT("  DirectX Files Tab: ") );
    SaveNote(pFile, pSysInfo->m_szDXFileNotesEnglish);

    dwIndex = 1;
    for (pDisplayInfo = pDisplayInfoFirst; pDisplayInfo != NULL; 
        pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
    {
        _ftprintf(pFile, TEXT("      Display Tab %d: "), dwIndex);
        SaveNote(pFile, pDisplayInfo->m_szNotesEnglish);
        dwIndex++;
    }

    dwIndex = 1;
    for (pSoundInfo = pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfo->m_pSoundInfoNext)
    {
        _ftprintf(pFile, TEXT("        Sound Tab %d: "), dwIndex);
        SaveNote(pFile, pSoundInfo->m_szNotesEnglish);
        dwIndex++;
    }

    _ftprintf(pFile, TEXT("          Music Tab: "));
    SaveNote(pFile, pSysInfo->m_szMusicNotesEnglish);
    _ftprintf(pFile, TEXT("          Input Tab: "));
    SaveNote(pFile, pSysInfo->m_szInputNotesEnglish);
    _ftprintf(pFile, TEXT("        Network Tab: "));
    SaveNote(pFile, pSysInfo->m_szNetworkNotesEnglish);
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}


/****************************************************************************
 *
 *  SaveDxComponentFileInfo
 *
 ****************************************************************************/
HRESULT SaveDxComponentFileInfo(FILE* pFile, FileInfo* pFileInfoFirst)
{
    FileInfo* pFileInfo;
    TCHAR sz[1024];

    _ftprintf(pFile, TEXT("------------------\n"));
    _ftprintf(pFile, TEXT("DirectX Components\n"));
    _ftprintf(pFile, TEXT("------------------\n"));
    for (pFileInfo = pFileInfoFirst; pFileInfo != NULL; 
        pFileInfo = pFileInfo->m_pFileInfoNext)
    {
        if (!pFileInfo->m_bExists && !pFileInfo->m_bProblem)
            continue;
        wsprintf(sz, TEXT("%12s: %s %s %s %s %s %d bytes %s\n"), 
            pFileInfo->m_szName, 
            pFileInfo->m_szVersion, 
            pFileInfo->m_szLanguage,
            pFileInfo->m_bBeta ? TEXT("Beta") : TEXT("Final"),
            pFileInfo->m_bDebug ? TEXT("Debug") : TEXT("Retail"),
            pFileInfo->m_szDatestamp,
            pFileInfo->m_numBytes,
            pFileInfo->m_bSigned ? TEXT("Digitally Signed") : TEXT(""));
        _ftprintf(pFile, sz);
    }
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}


/****************************************************************************
 *
 *  SaveDxWinComponentFileInfo
 *
 ****************************************************************************/
HRESULT SaveDxWinComponentFileInfo(FILE* pFile, FileInfo* pFileInfoFirst)
{
    if (pFileInfoFirst == NULL)
        return S_OK;
    
    FileInfo* pFileInfo;
    TCHAR sz[1024];

    _ftprintf(pFile, TEXT("------------------------------------------------\n"));
    _ftprintf(pFile, TEXT("Components Incorrectly Located in Windows Folder\n"));
    _ftprintf(pFile, TEXT("------------------------------------------------\n"));
    for (pFileInfo = pFileInfoFirst; pFileInfo != NULL; 
        pFileInfo = pFileInfo->m_pFileInfoNext)
    {
        _sntprintf(sz, 1024, TEXT("%12s: %s %s %s %s %s %d bytes %s\n"), 
            pFileInfo->m_szName, 
            pFileInfo->m_szVersion, 
            pFileInfo->m_szLanguage,
            pFileInfo->m_bBeta ? TEXT("Beta") : TEXT("Final"),
            pFileInfo->m_bDebug ? TEXT("Debug") : TEXT("Retail"),
            pFileInfo->m_szDatestamp,
            pFileInfo->m_numBytes,
            pFileInfo->m_bSigned ? TEXT("Digitally Signed") : TEXT(""));
        sz[1023]=0;
        _ftprintf(pFile, sz);
    }
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}


/****************************************************************************
 *
 *  SaveBackedUpFileInfo - Since this only shows up in the saved report, 
 *      we gather this info on the fly.
 *
 ****************************************************************************/
HRESULT SaveBackedUpFileInfo(FILE* pFile)
{
    FileInfo fileInfo;
    TCHAR szBackupDir[1024];
    TCHAR szCurrentDir[1024];
    TCHAR szFileSpec[1024];
    HANDLE hFindFile;
    WIN32_FIND_DATA findData;
    BOOL bFirstFile = TRUE;
    BOOL bFirstFileThisDir;
    HANDLE hFindFile2;
    WIN32_FIND_DATA findData2;

    GetSystemDirectory(szBackupDir, MAX_PATH);
    lstrcat(szBackupDir, TEXT("\\DXBackup"));
    lstrcpy(szFileSpec, szBackupDir);
    lstrcat(szFileSpec, TEXT("\\*.*"));

    hFindFile = FindFirstFile(szFileSpec, &findData); 
    if (hFindFile != INVALID_HANDLE_VALUE)
    {
        while (TRUE)
        {
            if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY &&
                lstrcmp(findData.cFileName, TEXT(".")) != 0 &&
                lstrcmp(findData.cFileName, TEXT("..")) != 0)
            {
                bFirstFileThisDir = TRUE;
                wsprintf(szCurrentDir, TEXT("%s\\%s"), szBackupDir, findData.cFileName);
                lstrcpy(szFileSpec, szCurrentDir);
                lstrcat(szFileSpec, TEXT("\\*.*"));
                hFindFile2 = FindFirstFile(szFileSpec, &findData2);
                if (hFindFile2 != INVALID_HANDLE_VALUE)
                {
                    while (TRUE)
                    {
                        if ((findData2.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                        {
                            if (bFirstFile)
                            {
                                bFirstFile = FALSE;
                                _ftprintf(pFile, TEXT("-----------------------------------------------\n"));
                                _ftprintf(pFile, TEXT("Backed-up drivers in %s\n"), szBackupDir);
                                _ftprintf(pFile, TEXT("-----------------------------------------------\n"));
                            }
                            else if (bFirstFileThisDir)
                            {
                                _ftprintf(pFile, TEXT("\n"));
                            }
                            if (bFirstFileThisDir)
                            {
                                bFirstFileThisDir = FALSE;
                                _ftprintf(pFile, TEXT("%s:\n"), szCurrentDir);
                            }
                            
                            wsprintf(szFileSpec, TEXT("%s\\%s"), szCurrentDir, findData2.cFileName);
                            ZeroMemory(&fileInfo, sizeof(fileInfo));
                            lstrcpy(fileInfo.m_szName, findData2.cFileName);
                            GetFileVersion(szFileSpec, fileInfo.m_szVersion, fileInfo.m_szAttributes, fileInfo.m_szLanguageLocal, fileInfo.m_szLanguage, &fileInfo.m_bBeta, &fileInfo.m_bDebug);
                            GetFileDateAndSize(szFileSpec, fileInfo.m_szDatestampLocal, fileInfo.m_szDatestamp, &fileInfo.m_numBytes);
                            FileIsSigned(szFileSpec, &fileInfo.m_bSigned, NULL);

                            _ftprintf(pFile, TEXT("%12s: %s %s %s %s Date: %s Size: %d bytes %s\n"), 
                                fileInfo.m_szName, 
                                fileInfo.m_szVersion, 
                                fileInfo.m_szLanguage,
                                fileInfo.m_bBeta ? TEXT("Beta") : TEXT("Final"),
                                fileInfo.m_bDebug ? TEXT("Debug") : TEXT("Retail"),
                                fileInfo.m_szDatestamp,
                                fileInfo.m_numBytes,
                                fileInfo.m_bSigned ? TEXT("Digitally Signed") : TEXT(""));
                        }
                        if (!FindNextFile(hFindFile2, &findData2))
                            break;
                    }
                    FindClose(hFindFile2);
                }
            }
            if (!FindNextFile(hFindFile, &findData))
                break;
        }
        FindClose(hFindFile);
    }; 

    if (!bFirstFile)
        _ftprintf(pFile, TEXT("\n"));

    return S_OK;
}


/****************************************************************************
 *
 *  SaveDisplayInfo
 *
 ****************************************************************************/
HRESULT SaveDisplayInfo(FILE* pFile, DisplayInfo* pDisplayInfoFirst)
{
    DisplayInfo* pDisplayInfo;
    TCHAR szVersion[1024];

    _ftprintf(pFile, TEXT("---------------\n"));
    _ftprintf(pFile, TEXT("Display Devices\n"));
    _ftprintf(pFile, TEXT("---------------\n"));
    for (pDisplayInfo = pDisplayInfoFirst; pDisplayInfo != NULL; 
        pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
    {
        wsprintf(szVersion, TEXT("%s (%s)"), pDisplayInfo->m_szDriverVersion, pDisplayInfo->m_szDriverLanguage);

        _ftprintf(pFile, TEXT("        Card name: %s\n"), pDisplayInfo->m_szDescription);
        _ftprintf(pFile, TEXT("     Manufacturer: %s\n"), pDisplayInfo->m_szManufacturer);
        _ftprintf(pFile, TEXT("        Chip type: %s\n"), pDisplayInfo->m_szChipType);
        _ftprintf(pFile, TEXT("         DAC type: %s\n"), pDisplayInfo->m_szDACType);
        _ftprintf(pFile, TEXT("        Device ID: %s\n"), pDisplayInfo->m_szKeyDeviceID);
        _ftprintf(pFile, TEXT("   Display Memory: %s\n"), pDisplayInfo->m_szDisplayMemoryEnglish);
        _ftprintf(pFile, TEXT("     Current Mode: %s\n"), pDisplayInfo->m_szDisplayModeEnglish);
        _ftprintf(pFile, TEXT("          Monitor: %s\n"), pDisplayInfo->m_szMonitorName);
        _ftprintf(pFile, TEXT("  Monitor Max Res: %s\n"), pDisplayInfo->m_szMonitorMaxRes);
        _ftprintf(pFile, TEXT("      Driver Name: %s\n"), pDisplayInfo->m_szDriverName);
        _ftprintf(pFile, TEXT("   Driver Version: %s\n"), szVersion);
        _ftprintf(pFile, TEXT("      DDI Version: %s\n"), pDisplayInfo->m_szDDIVersion);
        _ftprintf(pFile, TEXT("Driver Attributes: %s %s\n"), pDisplayInfo->m_bDriverBeta ? TEXT("Beta") : TEXT("Final"), pDisplayInfo->m_bDriverDebug ? TEXT("Debug") : TEXT("Retail"));
        _ftprintf(pFile, TEXT(" Driver Date/Size: %s, %d bytes\n"), pDisplayInfo->m_szDriverDate, pDisplayInfo->m_cbDriver);
        _ftprintf(pFile, TEXT("    Driver Signed: %s\n"), pDisplayInfo->m_bDriverSignedValid ? ( pDisplayInfo->m_bDriverSigned ? TEXT("Yes") : TEXT("No") ) : TEXT("n/a") );
        _ftprintf(pFile, TEXT("  WHQL Date Stamp: %s\n"), pDisplayInfo->m_bDX8DriverSignedValid ? ( pDisplayInfo->m_bDX8DriverSigned ? pDisplayInfo->m_szDX8DriverSignDate : TEXT("None") ) : TEXT("n/a") );
        _ftprintf(pFile, TEXT("              VDD: %s\n"), pDisplayInfo->m_szVdd);
        _ftprintf(pFile, TEXT("         Mini VDD: %s\n"), pDisplayInfo->m_szMiniVdd);
        _ftprintf(pFile, TEXT("    Mini VDD Date: %s, %d bytes\n"), pDisplayInfo->m_szMiniVddDate, pDisplayInfo->m_cbMiniVdd);
        _ftprintf(pFile, TEXT("Device Identifier: %s\n"), pDisplayInfo->m_szDX8DeviceIdentifier );
        _ftprintf(pFile, TEXT("        Vendor ID: %s\n"), pDisplayInfo->m_szDX8VendorId );
        _ftprintf(pFile, TEXT("        Device ID: %s\n"), pDisplayInfo->m_szDX8DeviceId );
        _ftprintf(pFile, TEXT("        SubSys ID: %s\n"), pDisplayInfo->m_szDX8SubSysId );
        _ftprintf(pFile, TEXT("      Revision ID: %s\n"), pDisplayInfo->m_szDX8Revision );

        if (pDisplayInfo->m_pRegErrorFirst == NULL)
        {
            _ftprintf(pFile, TEXT("         Registry: OK\n"));
        }
        else
        {
            _ftprintf(pFile, TEXT("         Registry: Errors found:\n"));
            SaveRegistryErrorInfo(pFile, pDisplayInfo->m_pRegErrorFirst);
        }

        _ftprintf(pFile, TEXT("     DDraw Status: %s\n"), pDisplayInfo->m_szDDStatusEnglish);
        _ftprintf(pFile, TEXT("       D3D Status: %s\n"), pDisplayInfo->m_szD3DStatusEnglish);
        _ftprintf(pFile, TEXT("       AGP Status: %s\n"), pDisplayInfo->m_szAGPStatusEnglish);

        _ftprintf(pFile, TEXT("DDraw Test Result: %s\n"), pDisplayInfo->m_testResultDD.m_szDescriptionEnglish);
        _ftprintf(pFile, TEXT(" D3D7 Test Result: %s\n"), pDisplayInfo->m_testResultD3D7.m_szDescriptionEnglish);
        _ftprintf(pFile, TEXT(" D3D8 Test Result: %s\n"), pDisplayInfo->m_testResultD3D8.m_szDescriptionEnglish);
        _ftprintf(pFile, TEXT("\n"));
    }

    return S_OK;
}


/****************************************************************************
 *
 *  SaveSoundInfo
 *
 ****************************************************************************/
HRESULT SaveSoundInfo(FILE* pFile, SoundInfo* pSoundInfoFirst)
{
    SoundInfo* pSoundInfo;
    TCHAR szAcceleration[1024];
    TCHAR szVersion[1024];
    TCHAR szAttributes[1024];
    TCHAR szSigned[1024];
    TCHAR szDateSize[1024];

    _ftprintf(pFile, TEXT("-------------\n"));
    _ftprintf(pFile, TEXT("Sound Devices\n"));
    _ftprintf(pFile, TEXT("-------------\n"));
    for (pSoundInfo = pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfo->m_pSoundInfoNext)
    {
        switch (pSoundInfo->m_lwAccelerationLevel)
        {
        case 0:
            lstrcpy(szAcceleration, TEXT("Emulation Only"));
            break;
        case 1:
            lstrcpy(szAcceleration, TEXT("Basic"));
            break;
        case 2:
            lstrcpy(szAcceleration, TEXT("Standard"));
            break;
        case 3:
            lstrcpy(szAcceleration, TEXT("Full"));
            break;
        default:
            lstrcpy(szAcceleration, TEXT("Unknown"));
            break;
        }
        if (lstrlen(pSoundInfo->m_szDriverName) > 0)
        {
            wsprintf(szVersion, TEXT("%s (%s)"), pSoundInfo->m_szDriverVersion, pSoundInfo->m_szDriverLanguage);
            wsprintf(szAttributes, TEXT("%s %s"), pSoundInfo->m_bDriverBeta ? TEXT("Beta") : TEXT("Final"), pSoundInfo->m_bDriverDebug ? TEXT("Debug") : TEXT("Retail"));
            lstrcpy( szSigned, pSoundInfo->m_bDriverSignedValid ? ( pSoundInfo->m_bDriverSigned ? TEXT("Yes") : TEXT("No") ) : TEXT("n/a") );
            wsprintf(szDateSize, TEXT("%s, %d bytes"), pSoundInfo->m_szDriverDate, pSoundInfo->m_numBytes);
        }
        else
        {
            lstrcpy(szVersion, TEXT(""));
            lstrcpy(szAttributes, TEXT(""));
            lstrcpy(szSigned, TEXT(""));
            lstrcpy(szDateSize, TEXT(""));
        }

        _ftprintf(pFile, TEXT("      Description: %s\n"), pSoundInfo->m_szDescription);
        _ftprintf(pFile, TEXT("        Device ID: %s\n"), pSoundInfo->m_szDeviceID);
        _ftprintf(pFile, TEXT("  Manufacturer ID: %s\n"), pSoundInfo->m_szManufacturerID);
        _ftprintf(pFile, TEXT("       Product ID: %s\n"), pSoundInfo->m_szProductID);
        _ftprintf(pFile, TEXT("             Type: %s\n"), pSoundInfo->m_szType);
        _ftprintf(pFile, TEXT("      Driver Name: %s\n"), pSoundInfo->m_szDriverName);
        _ftprintf(pFile, TEXT("   Driver Version: %s\n"), szVersion);
        _ftprintf(pFile, TEXT("Driver Attributes: %s\n"), szAttributes);
        _ftprintf(pFile, TEXT("    Driver Signed: %s\n"), szSigned);
        _ftprintf(pFile, TEXT("    Date and Size: %s\n"), szDateSize);
        _ftprintf(pFile, TEXT("      Other Files: %s\n"), pSoundInfo->m_szOtherDrivers);
        _ftprintf(pFile, TEXT("  Driver Provider: %s\n"), pSoundInfo->m_szProvider);
        _ftprintf(pFile, TEXT("   HW Accel Level: %s\n"), szAcceleration);
        if (pSoundInfo->m_pRegErrorFirst == NULL)
        {
            _ftprintf(pFile, TEXT("         Registry: OK\n"));
        }
        else
        {
            _ftprintf(pFile, TEXT("         Registry: Errors found:\n"));
            SaveRegistryErrorInfo(pFile, pSoundInfo->m_pRegErrorFirst);
        }
        _ftprintf(pFile, TEXT("Sound Test Result: %s\n"), pSoundInfo->m_testResultSnd.m_szDescriptionEnglish);
        _ftprintf(pFile, TEXT("\n"));
    }
    return S_OK;
}


/****************************************************************************
 *
 *  SaveMusicInfo
 *
 ****************************************************************************/
HRESULT SaveMusicInfo(FILE* pFile, MusicInfo* pMusicInfo)
{
    MusicPort* pMusicPort;

    if (pMusicInfo == NULL || !pMusicInfo->m_bDMusicInstalled)
        return S_OK;

    _ftprintf(pFile, TEXT("-----------\n"));
    _ftprintf(pFile, TEXT("DirectMusic\n"));
    _ftprintf(pFile, TEXT("-----------\n"));

    _ftprintf(pFile, TEXT(" DLS Path: %s\n"), pMusicInfo->m_szGMFilePath);
    _ftprintf(pFile, TEXT("  Version: %s\n"), pMusicInfo->m_szGMFileVersion);
    _ftprintf(pFile, TEXT("    Ports:\n"));

    for (pMusicPort = pMusicInfo->m_pMusicPortFirst; pMusicPort != NULL; 
        pMusicPort = pMusicPort->m_pMusicPortNext)
    {
        _ftprintf(pFile, TEXT("           %s, %s (%s), %s, %s, %s%s\n"), 
            pMusicPort->m_szDescription, 
            pMusicPort->m_bSoftware ? TEXT("Software") : TEXT("Hardware"),
            pMusicPort->m_bKernelMode ? TEXT("Kernel Mode") : TEXT("Not Kernel Mode"),
            pMusicPort->m_bOutputPort ? TEXT("Output") : TEXT("Input"), 
            pMusicPort->m_bUsesDLS ? TEXT("DLS") : TEXT("No DLS"), 
            pMusicPort->m_bExternal ? TEXT("External") : TEXT("Internal"), 
            pMusicPort->m_bDefaultPort ? TEXT(", Default Port") : TEXT("")
            );
    }
    if (pMusicInfo->m_pRegErrorFirst == NULL)
    {
        _ftprintf(pFile, TEXT(" Registry: OK\n"));
    }
    else
    {
        _ftprintf(pFile, TEXT(" Registry: Errors found:\n"));
        SaveRegistryErrorInfo(pFile, pMusicInfo->m_pRegErrorFirst);
    }
    _ftprintf(pFile, TEXT("Music Test Result: %s\n"), pMusicInfo->m_testResult.m_szDescriptionEnglish);
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}


/****************************************************************************
 *
 *  SaveShowInfo - Since this only shows up in the saved report, 
 *      we gather this info on the fly.
 *
 ****************************************************************************/
HRESULT SaveShowInfo(FILE* pFile, ShowInfo* pShowInfo)
{
    if( pShowInfo == NULL )
        return S_OK;      

    _ftprintf(pFile, TEXT("------------------\n"));
    _ftprintf(pFile, TEXT("DirectShow Filters\n"));
    _ftprintf(pFile, TEXT("------------------\n"));

    FilterInfo* pFilterInfo;

    TCHAR szCurCatName[1024];        
    TCHAR* szFileName = NULL;
    TCHAR* szLastSlash = NULL;
    _tcscpy( szCurCatName, TEXT("") );
    
    pFilterInfo = pShowInfo->m_pFilters;
    while(pFilterInfo)
    {
        if( _tcscmp( pFilterInfo->m_szCatName, szCurCatName ) != 0 )
        {
            _ftprintf(pFile, TEXT("\n%s:\n"), pFilterInfo->m_szCatName);
            _tcscpy( szCurCatName, pFilterInfo->m_szCatName );
        }
            
        _ftprintf(pFile, TEXT("%s,"), pFilterInfo->m_szName);
        _ftprintf(pFile, TEXT("0x%08x,"), pFilterInfo->m_dwMerit);
        _ftprintf(pFile, TEXT("%d,"), pFilterInfo->m_dwInputs);
        _ftprintf(pFile, TEXT("%d,"), pFilterInfo->m_dwOutputs);

        // Display only the file name
        szFileName = pFilterInfo->m_szFileName;
        szLastSlash = _tcsrchr( pFilterInfo->m_szFileName, TEXT('\\') );
        if( szLastSlash ) 
            szFileName = szLastSlash + 1;
        _ftprintf(pFile, TEXT("%s,"), szFileName);

        _ftprintf(pFile, TEXT("%s\n"), pFilterInfo->m_szFileVersion);

        pFilterInfo = pFilterInfo->m_pFilterInfoNext;
    }
    _ftprintf(pFile, TEXT("\n"));

    return S_OK;
}


/****************************************************************************
 *
 *  SaveInputInfo
 *
 ****************************************************************************/
HRESULT SaveInputInfo(FILE* pFile, InputInfo* pInputInfo)
{
    InputDeviceInfo* pInputDeviceInfo;
    InputDeviceInfoNT* pInputDeviceInfoNT;
    InputDriverInfo* pInputDriverInfo;

    _ftprintf(pFile, TEXT("-------------\n"));
    _ftprintf(pFile, TEXT("Input Devices\n"));
    _ftprintf(pFile, TEXT("-------------\n"));

    if( pInputInfo == NULL )
        return S_OK;

    if (pInputInfo->m_bNT)
    {
        for (pInputDeviceInfoNT = pInputInfo->m_pInputDeviceInfoNTFirst; pInputDeviceInfoNT != NULL; 
            pInputDeviceInfoNT = pInputDeviceInfoNT->m_pInputDeviceInfoNTNext)
        {
            _ftprintf(pFile, TEXT("      Device Name: %s\n"), pInputDeviceInfoNT->m_szName);
            _ftprintf(pFile, TEXT("         Provider: %s\n"), pInputDeviceInfoNT->m_szProvider);
            _ftprintf(pFile, TEXT("      Hardware ID: %s\n"), pInputDeviceInfoNT->m_szId);
            _ftprintf(pFile, TEXT("           Status: %d\n"), pInputDeviceInfoNT->m_dwProblem);
            _ftprintf(pFile, TEXT("        Port Name: %s\n"), pInputDeviceInfoNT->m_szPortName);
            _ftprintf(pFile, TEXT("    Port Provider: %s\n"), pInputDeviceInfoNT->m_szPortProvider);
            _ftprintf(pFile, TEXT("          Port ID: %s\n"), pInputDeviceInfoNT->m_szPortId);
            _ftprintf(pFile, TEXT("      Port Status: %d\n"), pInputDeviceInfoNT->m_dwPortProblem);
            _ftprintf(pFile, TEXT("\n"));
        }
    }
    else
    {
        for (pInputDeviceInfo = pInputInfo->m_pInputDeviceInfoFirst; pInputDeviceInfo != NULL; 
            pInputDeviceInfo = pInputDeviceInfo->m_pInputDeviceInfoNext)
        {
            _ftprintf(pFile, TEXT("      Device Name: %s\n"), pInputDeviceInfo->m_szDeviceName);
            _ftprintf(pFile, TEXT("      Driver Name: %s\n"), pInputDeviceInfo->m_szDriverName);
            _ftprintf(pFile, TEXT("   Driver Version: %s"), pInputDeviceInfo->m_szDriverVersion);
            _ftprintf(pFile, TEXT(" (%s)\n"), pInputDeviceInfo->m_szDriverLanguage);
            _ftprintf(pFile, TEXT("Driver Attributes: %s %s\n"), pInputDeviceInfo->m_bBeta ? TEXT("Beta") : TEXT("Final"), pInputDeviceInfo->m_bDebug ? TEXT("Debug") : TEXT("Retail") );
            _ftprintf(pFile, TEXT("    Date and Size: %s, %d bytes\n"), pInputDeviceInfo->m_szDriverDate, pInputDeviceInfo->m_numBytes);
            _ftprintf(pFile, TEXT("\n"));
        }
    }
    
    _ftprintf(pFile, TEXT("Poll w/ Interrupt: "));
    TCHAR sz[200];
    lstrcpy( sz, (pInputInfo->m_bPollFlags) ? TEXT("Yes\n") : TEXT("No\n") );
    _ftprintf(pFile, sz);

    if (pInputInfo->m_pRegErrorFirst == NULL)
    {
        _ftprintf(pFile, TEXT("         Registry: OK\n"));
    }
    else
    {
        _ftprintf(pFile, TEXT("         Registry: Errors found:\n"));
        SaveRegistryErrorInfo(pFile, pInputInfo->m_pRegErrorFirst);
    }
    _ftprintf(pFile, TEXT("\n"));
    _ftprintf(pFile, TEXT("-------------\n"));
    _ftprintf(pFile, TEXT("Input Drivers\n"));
    _ftprintf(pFile, TEXT("-------------\n"));
    for (pInputDriverInfo = pInputInfo->m_pInputDriverInfoFirst; pInputDriverInfo != NULL; 
        pInputDriverInfo = pInputDriverInfo->m_pInputDriverInfoNext)
    {
        _ftprintf(pFile, TEXT("  Registry Key: %s\n"), pInputDriverInfo->m_szRegKey);
        _ftprintf(pFile, TEXT("        Active: %s\n"), pInputDriverInfo->m_bActive ? TEXT("Yes") : TEXT("No") );
        _ftprintf(pFile, TEXT("      DeviceID: %s\n"), pInputDriverInfo->m_szDeviceID);
        _ftprintf(pFile, TEXT("Matching DevID: %s\n"), pInputDriverInfo->m_szMatchingDeviceID);
        _ftprintf(pFile, TEXT(" 16-bit Driver: %s\n"), pInputDriverInfo->m_szDriver16);
        _ftprintf(pFile, TEXT(" 32-bit Driver: %s\n"), pInputDriverInfo->m_szDriver32);
        _ftprintf(pFile, TEXT("\n"));
    }
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}


/****************************************************************************
 *
 *  SaveNetInfo
 *
 ****************************************************************************/
HRESULT SaveNetInfo(FILE* pFile, NetInfo* pNetInfo)
{
    NetSP* pNetSP;
    NetApp* pNetApp;

    _ftprintf(pFile, TEXT("----------------------------\n"));
    _ftprintf(pFile, TEXT("DirectPlay Service Providers\n"));
    _ftprintf(pFile, TEXT("----------------------------\n"));

    if( pNetInfo == NULL )
        return S_OK;

    for (pNetSP = pNetInfo->m_pNetSPFirst; pNetSP != NULL; pNetSP = pNetSP->m_pNetSPNext)
    {
        _ftprintf(pFile, TEXT("%s - Registry: %s, File: %s (%s)\n"), 
            pNetSP->m_szNameEnglish,
            pNetSP->m_bRegistryOK ? TEXT("OK") : TEXT("Error"),
            pNetSP->m_szFile,
            pNetSP->m_szVersionEnglish);
    }
    _ftprintf(pFile, TEXT("DirectPlay Test Result: %s\n"), pNetInfo->m_testResult.m_szDescriptionEnglish);
    _ftprintf(pFile, TEXT("\n"));

    _ftprintf(pFile, TEXT("-------------------------\n"));
    _ftprintf(pFile, TEXT("DirectPlay Lobbyable Apps\n"));
    _ftprintf(pFile, TEXT("-------------------------\n"));
    for (pNetApp = pNetInfo->m_pNetAppFirst; pNetApp != NULL; pNetApp = pNetApp->m_pNetAppNext)
    {
        if( pNetApp->m_dwDXVer == 7 )
        {
            _ftprintf(pFile, TEXT("%s (DX%d) - Registry: %s, ExeFile: %s (%s)\n"), 
                pNetApp->m_szName,
                pNetApp->m_dwDXVer,
                pNetApp->m_bRegistryOK ? TEXT("OK") : TEXT("Error"),
                pNetApp->m_szExeFile,
                pNetApp->m_szExeVersionEnglish);
        }
        else
        {
            _ftprintf(pFile, TEXT("%s (DX%d) - Registry: %s, ExeFile: %s (%s) LauncherFile: %s (%s)\n"), 
                pNetApp->m_szName,
                pNetApp->m_dwDXVer,
                pNetApp->m_bRegistryOK ? TEXT("OK") : TEXT("Error"),
                pNetApp->m_szExeFile,
                pNetApp->m_szExeVersionEnglish,
                pNetApp->m_szLauncherFile,
                pNetApp->m_szLauncherVersionEnglish);
        }
    }
    _ftprintf(pFile, TEXT("\n"));
    return S_OK;
}


/****************************************************************************
 *
 *  SaveInactiveDriverInfo
 *
 ****************************************************************************/
HRESULT SaveInactiveDriverInfo(FILE* pFile, DisplayInfo* pDisplayInfoFirst)
{
    BOOL bNoInactive;
    HKEY hKey;
    DWORD cbData;
    DWORD dwIndex;
    TCHAR szSubKeyName[1024];
    DisplayInfo* pDisplayInfo;
    HKEY hSubKey;
    TCHAR szSubSubKey[1024];
    TCHAR szDriverDesc[1024];
    DWORD ulType;
    TCHAR szTempString[1024];

    if (BIsPlatformNT())
        return S_OK;

    _ftprintf(pFile, TEXT("------------------------------------\n"));
    _ftprintf(pFile, TEXT("Inactive Display Entries in Registry\n"));
    _ftprintf(pFile, TEXT("------------------------------------\n"));

    bNoInactive = TRUE;

    // Display info (inactive).
    hKey = 0;
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Services\\Class\\Display"), 0, KEY_READ, &hKey))
    {
        cbData = sizeof szSubKeyName;
        dwIndex = 0;

        while (!RegEnumKeyEx(hKey, dwIndex, szSubKeyName, &cbData, NULL, NULL, NULL, NULL))
        {
            TCHAR* pch;
            BOOL bMatch = FALSE;

            // See if this driver is used:
            for (pDisplayInfo = pDisplayInfoFirst; pDisplayInfo != NULL;
                pDisplayInfo = pDisplayInfo->m_pDisplayInfoNext)
            {
                pch = _tcsrchr(pDisplayInfo->m_szKeyDeviceKey, TEXT('\\'));
                if (pch != NULL)
                {
                    pch++;
                    
                    if (lstrcmp(szSubKeyName, pch) == 0)
                    {
                        bMatch = TRUE;
                        break;
                    }
                }
            }            

            if (!bMatch)
            {
                hSubKey = 0;
                wsprintf(szSubSubKey, TEXT("System\\CurrentControlSet\\Services\\Class\\Display\\%s"), szSubKeyName);

                if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubSubKey, 0, KEY_READ, &hSubKey))
                {
                    cbData = sizeof szDriverDesc;
                    szDriverDesc[0] = 0;
                    RegQueryValueEx(hSubKey, TEXT("DriverDesc"), 0, &ulType, (LPBYTE)szDriverDesc, &cbData);

                    _ftprintf(pFile, TEXT(" Card name: %s\n"), szDriverDesc);
                    bNoInactive = FALSE;
                }

                if (hSubKey)
                {
                    RegCloseKey(hSubKey);
                    hSubKey = 0;
                }

                wsprintf(szSubSubKey, TEXT("System\\CurrentControlSet\\Services\\Class\\Display\\%s\\DEFAULT"), szSubKeyName);

                if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubSubKey, 0, KEY_READ, &hSubKey))
                {
                    TCHAR szDisplayDriverName[1024];     
                    cbData = sizeof szDisplayDriverName;
                    szDisplayDriverName[0] = 0;
                    RegQueryValueEx(hSubKey, TEXT("DRV"), 0, &ulType, (LPBYTE)szDisplayDriverName, &cbData);

                    _ftprintf(pFile, TEXT("    Driver: %s\n"), szDisplayDriverName);
                    bNoInactive = FALSE;
                }

                if (hSubKey)
                {
                    RegCloseKey(hSubKey);
                    hSubKey = 0;
                }
            } 

            cbData = sizeof szSubKeyName;
            dwIndex++;
        }
    }

    if (hKey)
    {
        RegCloseKey(hKey);
        hKey = 0;
    }

    if (bNoInactive)
        _ftprintf(pFile, TEXT(" None\n"));

    _ftprintf(pFile, TEXT("\n"));

    _ftprintf(pFile, TEXT("----------------------------------\n"));
    _ftprintf(pFile, TEXT("Inactive Sound Entries in Registry\n"));
    _ftprintf(pFile, TEXT("----------------------------------\n"));

    bNoInactive = TRUE;

    hKey = 0;
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\control\\MediaResources\\wave"), 0, KEY_READ, &hKey))
    {
        dwIndex = 0;
        while (TRUE)
        {
            cbData = sizeof szSubKeyName;
            if (ERROR_SUCCESS != RegEnumKeyEx(hKey, dwIndex, szSubKeyName, &cbData, NULL, NULL, NULL, NULL))
                break;

            if (!RegOpenKeyEx(hKey, szSubKeyName, 0, KEY_READ, &hSubKey))
            {
                cbData = sizeof szTempString;
                if (!RegQueryValueEx(hSubKey, TEXT("Active"), 0, &ulType, (LPBYTE)szTempString, &cbData))
                {
                    if (lstrcmp(szTempString, TEXT("0")) == 0)
                    {
                        TCHAR szWaveOutDesc[1024];
                        TCHAR szWaveDriverName[1024];
                        cbData = sizeof szWaveOutDesc;
                        RegQueryValueEx(hSubKey, TEXT("Description"), 0, &ulType, (LPBYTE)szWaveOutDesc, &cbData);

                        cbData = sizeof szWaveDriverName;
                        RegQueryValueEx(hSubKey, TEXT("Driver"), 0, &ulType, (LPBYTE)szWaveDriverName, &cbData);

                        _ftprintf(pFile, TEXT(" Card name: %s\n"), szWaveOutDesc);
                        _ftprintf(pFile, TEXT("    Driver: %s\n"), szWaveDriverName);
                        bNoInactive = FALSE;
                    }
                }
                RegCloseKey(hSubKey);
            }
            dwIndex++;
        }
        RegCloseKey(hKey);
    }

    if (bNoInactive)
        _ftprintf(pFile, TEXT(" None\n"));

    _ftprintf(pFile, TEXT("\n"));

    return S_OK;
}


/****************************************************************************
 *
 *  SaveRegistryErrorInfo
 *
 ****************************************************************************/
HRESULT SaveRegistryErrorInfo(FILE* pFile, RegError* pRegErrorFirst)
{
    RegError* pRegError = pRegErrorFirst;
    DWORD i;
    TCHAR* pszRoot;

    while (pRegError != NULL)
    {
        switch ((DWORD_PTR)pRegError->m_hkeyRoot)
        {
        case (DWORD_PTR)HKEY_LOCAL_MACHINE:
            pszRoot = TEXT("HKLM");
            break;
        case (DWORD_PTR)HKEY_CURRENT_USER:
            pszRoot = TEXT("HKCU");
            break;
        case (DWORD_PTR)HKEY_CLASSES_ROOT:
            pszRoot = TEXT("HKCR");
            break;
        case (DWORD_PTR)HKEY_USERS:
            pszRoot = TEXT("HKU");
            break;
        case (DWORD_PTR)HKEY_CURRENT_CONFIG:
            pszRoot = TEXT("HKCC");
            break;
        default:
            pszRoot = TEXT("");
            break;
        }

        _ftprintf(pFile, TEXT("Key '%s\\%s'"), pszRoot, pRegError->m_szKey);
        switch (pRegError->m_ret)
        {
        case RET_MISSINGKEY:
            _ftprintf(pFile, TEXT(" is missing.\n"));
            break;
        case RET_MISSINGVALUE:
            _ftprintf(pFile, TEXT(" is missing value '%s'.\n"), pRegError->m_szValue);
            break;
        case RET_VALUEWRONGTYPE:
            _ftprintf(pFile, TEXT(" has value '%s', but it is the wrong type.\n"), pRegError->m_szValue);
            break;
        case RET_VALUEWRONGDATA:
            _ftprintf(pFile, TEXT(", Value '%s'"), pRegError->m_szValue);
            switch(pRegError->m_dwTypeActual)
            {
            case REG_DWORD:
                _ftprintf(pFile, TEXT(", should be '%d' but is '%d'.\n"), pRegError->m_dwExpected, pRegError->m_dwActual);
                break;
            case REG_SZ:
                _ftprintf(pFile, TEXT(", should be '%s'"), pRegError->m_szExpected);
                _ftprintf(pFile, TEXT(", but is '%s'.\n"), pRegError->m_szActual);
                break;
            case REG_BINARY:
                _ftprintf(pFile, TEXT(", should be '"));
                for (i = 0; i < pRegError->m_dwExpectedSize; i++)
                    _ftprintf(pFile, TEXT("%02x"), pRegError->m_bExpected[i]);
                _ftprintf(pFile, TEXT("' but is '"));
                for (i = 0; i < pRegError->m_dwActualSize; i++)
                    _ftprintf(pFile, TEXT("%02x"), pRegError->m_bActual[i]);
                _ftprintf(pFile, TEXT("'.\n"));
                break;
            }
            break;
        }
        pRegError = pRegError->m_pRegErrorNext;
    }

    return S_OK;
}




/****************************************************************************
 *
 *  SaveDebugLevels
 *
 ****************************************************************************/
HRESULT SaveDebugLevels(FILE* pFile, SysInfo* pSysInfo)
{
    TCHAR sz[1024];

    if( pSysInfo->m_bIsD3D8DebugRuntimeAvailable        ||
        pSysInfo->m_bIsDInput8DebugRuntimeAvailable     ||
        pSysInfo->m_bIsDMusicDebugRuntimeAvailable      ||
        pSysInfo->m_bIsDDrawDebugRuntime                ||
        pSysInfo->m_bIsDSoundDebugRuntime               ||
        pSysInfo->m_bIsDPlayDebugRuntime                ||
        pSysInfo->m_nD3DDebugLevel > 0                  ||
        pSysInfo->m_nDDrawDebugLevel > 0                ||
        pSysInfo->m_nDIDebugLevel > 0                   ||
        pSysInfo->m_nDMusicDebugLevel > 0               ||
        pSysInfo->m_nDPlayDebugLevel > 0                ||
        pSysInfo->m_nDSoundDebugLevel > 0 )
    {
        _ftprintf(pFile, TEXT("--------------------\n"));
        _ftprintf(pFile, TEXT("DirectX Debug Levels\n"));
        _ftprintf(pFile, TEXT("--------------------\n"));

        _stprintf(sz, TEXT("Direct3D:    %d/4 (%s)\n"), pSysInfo->m_nD3DDebugLevel, pSysInfo->m_bIsD3D8DebugRuntimeAvailable ? (pSysInfo->m_bIsD3DDebugRuntime ? TEXT("debug") : TEXT("retail") ) : TEXT("n/a") );
        _ftprintf(pFile, sz);
        _stprintf(sz, TEXT("DirectDraw:  %d/4 (%s)\n"), pSysInfo->m_nDDrawDebugLevel, pSysInfo->m_bIsDDrawDebugRuntime ? TEXT("debug") : TEXT("retail") );
        _ftprintf(pFile, sz);
        _stprintf(sz, TEXT("DirectInput: %d/5 (%s)\n"), pSysInfo->m_nDIDebugLevel, pSysInfo->m_bIsDInput8DebugRuntimeAvailable ? (pSysInfo->m_bIsDInput8DebugRuntime ? TEXT("debug") : TEXT("retail") ) : TEXT("n/a") );
        _ftprintf(pFile, sz);
        _stprintf(sz, TEXT("DirectMusic: %d/5 (%s)\n"), pSysInfo->m_nDMusicDebugLevel, pSysInfo->m_bIsDMusicDebugRuntimeAvailable ? (pSysInfo->m_bIsDMusicDebugRuntime ? TEXT("debug") : TEXT("retail") ) : TEXT("n/a") );
        _ftprintf(pFile, sz);
        _stprintf(sz, TEXT("DirectPlay:  %d/9 (%s)\n"), pSysInfo->m_nDPlayDebugLevel, pSysInfo->m_bIsDPlayDebugRuntime ? TEXT("debug") : TEXT("retail") );
        _ftprintf(pFile, sz);
        _stprintf(sz, TEXT("DirectSound: %d/5 (%s)\n"), pSysInfo->m_nDSoundDebugLevel, pSysInfo->m_bIsDSoundDebugRuntime ? TEXT("debug") : TEXT("retail") );
        _ftprintf(pFile, sz);
//        fwrite( sz, sizeof( TCHAR ), lstrlen(sz), pFile );
//#pragma prefast(suppress:69, _ftprintf works and fwrite doesnt)
        
        _ftprintf(pFile, TEXT("\n"));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\save.h ===
/****************************************************************************
 *
 *    File: save.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Save gathered information to a file in text or CSV format
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef SAVE_H
#define SAVE_H

struct BugInfo
{
	TCHAR m_szName[100];
	TCHAR m_szEmail[100];
	TCHAR m_szCompany[100];
	TCHAR m_szPhone[100];
	TCHAR m_szCityState[100];
	TCHAR m_szCountry[100];
	TCHAR m_szBugDescription[300];
	TCHAR m_szReproSteps[300];
	TCHAR m_szSwHw[300];
};

HRESULT SaveAllInfo(TCHAR* pszFile, SysInfo* pSysInfo, 
	FileInfo* pFileInfoWinComponentsFirst, FileInfo* pFileInfoComponentsFirst, 
	DisplayInfo* pDisplayInfoFirst, SoundInfo* pSoundInfoFirst,
	MusicInfo* pMusicInfo, InputInfo* pInputInfo, 
	NetInfo* pNetInfo, ShowInfo* pShowInfo, BugInfo* pBugInfo = NULL);

HRESULT SaveAllInfoCsv(TCHAR* pszFile, SysInfo* pSysInfo, 
	FileInfo* pFileInfoComponentsFirst, 
	DisplayInfo* pDisplayInfoFirst, SoundInfo* pSoundInfoFirst,
	InputInfo* pInputInfo);

#endif // SAVEINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\showinfo.cpp ===
/****************************************************************************
 *
 *    File: showinfo.cpp 
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about DirectShow on this machine
 *
 * (C) Copyright 2001 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/
#include <windows.h>
#include <stdio.h>
#include <strmif.h>     // Generated IDL header file for streams interfaces
#include <uuids.h>      // declaration of type GUIDs and well-known clsids
#include <assert.h>
#include <tchar.h>
#include "sysinfo.h"
#include "fileinfo.h"   // for GetFileVersion
#include "showinfo.h"


/****************************************************************************
 *
 *  Helper IAMFilterData - cut and paste from dshow\h\fil_data.c
 *
 ****************************************************************************/
/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fil_data_h__
#define __fil_data_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IAMFilterData_FWD_DEFINED__
#define __IAMFilterData_FWD_DEFINED__
typedef interface IAMFilterData IAMFilterData;
#endif  /* __IAMFilterData_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "strmif.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_fil_data_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_fil_data_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fil_data_0000_v0_0_s_ifspec;

#ifndef __IAMFilterData_INTERFACE_DEFINED__
#define __IAMFilterData_INTERFACE_DEFINED__

/* interface IAMFilterData */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMFilterData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97f7c4d4-547b-4a5f-8332-536430ad2e4d")
    IAMFilterData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseFilterData( 
            /* [size_is][in] */ BYTE __RPC_FAR *rgbFilterData,
            /* [in] */ ULONG cb,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbRegFilter2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFilterData( 
            /* [in] */ REGFILTER2 __RPC_FAR *prf2,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbFilterData,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IAMFilterDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAMFilterData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAMFilterData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAMFilterData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseFilterData )( 
            IAMFilterData __RPC_FAR * This,
            /* [size_is][in] */ BYTE __RPC_FAR *rgbFilterData,
            /* [in] */ ULONG cb,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbRegFilter2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateFilterData )( 
            IAMFilterData __RPC_FAR * This,
            /* [in] */ REGFILTER2 __RPC_FAR *prf2,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbFilterData,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        END_INTERFACE
    } IAMFilterDataVtbl;

    interface IAMFilterData
    {
        CONST_VTBL struct IAMFilterDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMFilterData_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMFilterData_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IAMFilterData_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IAMFilterData_ParseFilterData(This,rgbFilterData,cb,prgbRegFilter2) \
    (This)->lpVtbl -> ParseFilterData(This,rgbFilterData,cb,prgbRegFilter2)

#define IAMFilterData_CreateFilterData(This,prf2,prgbFilterData,pcb)    \
    (This)->lpVtbl -> CreateFilterData(This,prf2,prgbFilterData,pcb)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IAMFilterData_ParseFilterData_Proxy( 
    IAMFilterData __RPC_FAR * This,
    /* [size_is][in] */ BYTE __RPC_FAR *rgbFilterData,
    /* [in] */ ULONG cb,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbRegFilter2);


void __RPC_STUB IAMFilterData_ParseFilterData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMFilterData_CreateFilterData_Proxy( 
    IAMFilterData __RPC_FAR * This,
    /* [in] */ REGFILTER2 __RPC_FAR *prf2,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbFilterData,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IAMFilterData_CreateFilterData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IAMFilterData_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif


/****************************************************************************
 *
 *  Helper IAMFilterData - cut and paste from dshow\h\fil_data_i.c
 *
 ****************************************************************************/
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IAMFilterData = {0x97f7c4d4,0x547b,0x4a5f,{0x83,0x32,0x53,0x64,0x30,0xad,0x2e,0x4d}};


#ifdef __cplusplus
}
#endif



/****************************************************************************
 *
 *  Forward declaration
 *
 ****************************************************************************/
HRESULT GenerateFilterList(ShowInfo* pShowInfo);
HRESULT EnumerateFilterPerCategory(ShowInfo* pShowInfo, CLSID* clsid, WCHAR* wszCatName);
HRESULT GetFilterInfo(IMoniker* pMon, IAMFilterData* pFD, FilterInfo* pFilterInfo);


/****************************************************************************
 *
 *  GetBasicShowInfo - Get minimal info on DirectShow
 *
 ****************************************************************************/
HRESULT GetBasicShowInfo(ShowInfo** ppShowInfo)
{
    ShowInfo* pShowInfoNew;
    
    pShowInfoNew = new ShowInfo;
    if (pShowInfoNew == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(pShowInfoNew, sizeof(ShowInfo));
    *ppShowInfo = pShowInfoNew;

    return GenerateFilterList(pShowInfoNew);
}

/****************************************************************************
 *
 *  DestroyShowInfo
 *
 ****************************************************************************/
VOID DestroyShowInfo(ShowInfo* pShowInfo)
{
    if (!pShowInfo) return;

    if (pShowInfo->m_dwFilters)
    {
        FilterInfo* pFilterInfo;
        FilterInfo* pFilterInfoNext;

        pFilterInfo = pShowInfo->m_pFilters;
        while(pFilterInfo)
        {
            pFilterInfoNext = pFilterInfo->m_pFilterInfoNext;
            delete pFilterInfo;
            pFilterInfo = pFilterInfoNext;
        }
    }
    delete pShowInfo;
}

HRESULT GenerateFilterList(ShowInfo* pShowInfo)
{
    HRESULT hr;
    ICreateDevEnum* pSysDevEnum = NULL;
    IEnumMoniker*   pMonEnum = NULL;
    IMoniker*       pMon = NULL;
    ULONG cFetched;

    pShowInfo->m_dwFilters = 0;
    hr = CoCreateInstance(CLSID_SystemDeviceEnum,
                          NULL,
                          CLSCTX_INPROC,
                          IID_ICreateDevEnum,
                          (void **)&pSysDevEnum);
    if FAILED(hr)
    {
        return hr;
    }

    // Use the meta-category that contains a list of all categories.
    // This emulates the behavior of Graphedit.
    hr = pSysDevEnum->CreateClassEnumerator(CLSID_ActiveMovieCategories, &pMonEnum, 0);
    pSysDevEnum->Release();
    if FAILED(hr)
    {
        return hr;
    }

    // Enumerate over every category
    while (hr = pMonEnum->Next(1, &pMon, &cFetched), hr == S_OK)
    {
        IPropertyBag *pPropBag;

        // Associate moniker with a file
        hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
        if (SUCCEEDED(hr))
        {
            WCHAR wszCatName[1024] = L"";
            CLSID clsidCategory;
            VARIANT var;
            var.vt = VT_BSTR;

            // Get friendly name
            hr = pPropBag->Read(L"FriendlyName", &var, 0);
            if(SUCCEEDED(hr))
            {
                wcsncpy(wszCatName, var.bstrVal, 1024);
                wszCatName[1023]=0;
                SysFreeString(var.bstrVal);
            }
            // Get CLSID string from property bag
            hr = pPropBag->Read(L"CLSID", &var, 0);
            if (SUCCEEDED(hr))
            {
                if (CLSIDFromString(var.bstrVal, &clsidCategory) == S_OK)
                {
                    if (TEXT('\0') == wszCatName[0])
                    {
                        wcsncpy(wszCatName, var.bstrVal, 1024);
                        wszCatName[1023]=0;
                    }
                }
                SysFreeString(var.bstrVal);
            }

            pPropBag->Release();

            // Start to enumerate the filters for this one category
            hr = EnumerateFilterPerCategory(pShowInfo, &clsidCategory, wszCatName);
        }

        pMon->Release();
    }

    pMonEnum->Release();
    return hr;
}



HRESULT EnumerateFilterPerCategory(ShowInfo* pShowInfo, CLSID* clsid, WCHAR* wszCatName)
{
    HRESULT hr;
    ICreateDevEnum* pSysDevEnum = NULL;
    IEnumMoniker *pMonEnum = NULL;
    IMoniker *pMon = NULL;
    ULONG cFetched;

#ifdef RUNNING_VC    
    // WMP bug 29936: Voxware codec corrupt:  MSMS001 : corrupted heap
    // This causes this call int3 when inside a debugger so skip
    const CLSID clsidACMClassManager = {0x33d9a761,0x90c8,0x11d0,{0xbd,0x43,0x00,0xa0,0xc9,0x11,0xce,0x86}};
    if( *clsid == clsidACMClassManager )
        return S_OK;
#endif

    hr = CoCreateInstance(CLSID_SystemDeviceEnum,
                          NULL,
                          CLSCTX_INPROC,
                          IID_ICreateDevEnum,
                          (void **)&pSysDevEnum);
    if FAILED(hr)
    {
        return hr;
    }

    hr = pSysDevEnum->CreateClassEnumerator(*clsid, &pMonEnum, 0);
    pSysDevEnum->Release();
    if FAILED(hr)
    {
        return hr;
    }

    // If there are no filters of a requested category, don't do anything.
    if(NULL == pMonEnum)
    {
        // could added a string to denote an empty category
        return S_FALSE;
    }


    FilterInfo** ppFilterInfo;
    FilterInfo* pFilterInfoNew;

    ppFilterInfo = &(pShowInfo->m_pFilters);
    while (NULL != *ppFilterInfo)
        ppFilterInfo = &((*ppFilterInfo)->m_pFilterInfoNext);


    // Enumerate all items associated with the moniker
    while(pMonEnum->Next(1, &pMon, &cFetched) == S_OK)
    {
        // get a new record for FilterInfo
        pFilterInfoNew = new FilterInfo;
        if (pFilterInfoNew == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        ZeroMemory(pFilterInfoNew, sizeof(FilterInfo));
        *ppFilterInfo = pFilterInfoNew;
        ppFilterInfo = &(pFilterInfoNew->m_pFilterInfoNext);
        pShowInfo->m_dwFilters++;

        // set category clsid and friendly name
        pFilterInfoNew->m_ClsidCat = *clsid;
#ifdef _UNICODE
        wcsncpy(pFilterInfoNew->m_szCatName, wszCatName, 1024);
        pFilterInfoNew->m_szCatName[1023]=0;
#else
        WideCharToMultiByte(CP_ACP,
                            0,
                            wszCatName,
                            -1,
                            pFilterInfoNew->m_szCatName,
                            sizeof(pFilterInfoNew->m_szCatName),
                            0,
                            0);
        wszCatName[1023]=0;
#endif

        IPropertyBag *pPropBag;

        // associate moniker with a file
        hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            var.vt = VT_BSTR;

            // get filter's friendly name
            hr = pPropBag->Read(L"FriendlyName", &var, 0);
            if (SUCCEEDED(hr))
            {
#ifdef _UNICODE
                wcsncpy(pFilterInfoNew->m_szName, var.bstrVal, 1024);
                pFilterInfoNew->m_szName[1023]=0;
#else
                WideCharToMultiByte(CP_ACP,
                                    0,
                                    var.bstrVal,
                                    -1,
                                    pFilterInfoNew->m_szName,
                                    sizeof(pFilterInfoNew->m_szName),
                                    0,
                                    0);
                pFilterInfoNew->m_szName[1023]=0;
#endif
                SysFreeString(var.bstrVal);
            }

            // get filter's CLSID
            hr = pPropBag->Read(L"CLSID", &var, 0);
            if(SUCCEEDED(hr))
            {
                if(CLSIDFromString(var.bstrVal, &(pFilterInfoNew->m_ClsidFilter)) == S_OK)
                {
                    // use the guid if we can't get the friendly name
                    if (TEXT('\0') == pFilterInfoNew->m_szName[0])
                    {
#ifdef _UNICODE
                        wcsncpy(pFilterInfoNew->m_szName, var.bstrVal, 1024);
                        pFilterInfoNew->m_szName[1023]=0;
#else
                        WideCharToMultiByte(CP_ACP,
                                            0,
                                            var.bstrVal,
                                            -1,
                                            pFilterInfoNew->m_szName,
                                            sizeof(pFilterInfoNew->m_szName),
                                            0,
                                            0);
                        pFilterInfoNew->m_szName[1023]=0;
#endif
                    }
                }
                SysFreeString(var.bstrVal);
            }
            pPropBag->Release();
        }


        // start grabbing filter info
        IAMFilterData *pFD;
        hr = CoCreateInstance(CLSID_FilterMapper,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IAMFilterData,
                              (void **)&pFD);
        if(SUCCEEDED(hr))
        {
            hr = GetFilterInfo(pMon, pFD, pFilterInfoNew);
            pFD->Release();
        }
        else
        {
            // Must not be on DX8 or above...
        }

        pMon->Release();
    }

    pMonEnum->Release();
    return hr;
}


HRESULT GetFilterInfo(IMoniker* pMon, IAMFilterData* pFD, FilterInfo* pFilterInfo)
{
    HRESULT hr;

    IPropertyBag *pPropBag;
    hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
    if(SUCCEEDED(hr))
    {
        VARIANT varFilData;
        varFilData.vt = VT_UI1 | VT_ARRAY;
        varFilData.parray = 0; // docs say zero this

        BYTE *pbFilterData = NULL; 
        DWORD dwcbFilterDAta = 0; // 0 if not read
        hr = pPropBag->Read(L"FilterData", &varFilData, 0);
        if(SUCCEEDED(hr))
        {
            if( varFilData.vt == (VT_UI1 | VT_ARRAY) )
            {
                dwcbFilterDAta = varFilData.parray->rgsabound[0].cElements;
                if( SUCCEEDED( SafeArrayAccessData(varFilData.parray, (void **)&pbFilterData) ) )
                {
                    BYTE *pb = NULL;
                    hr = pFD->ParseFilterData(pbFilterData, dwcbFilterDAta, &pb);
                    if(SUCCEEDED(hr))
                    {
                        REGFILTER2** ppRegFilter = (REGFILTER2**)pb;
                        REGFILTER2* pFil = NULL;
                        pFil = *ppRegFilter;
    
                        if( pFil != NULL && pFil->dwVersion == 2 )
                        {
                            pFilterInfo->m_dwMerit = pFil->dwMerit;                             // set merit
                            wsprintf(pFilterInfo->m_szVersion, TEXT("v%d"), pFil->dwVersion);   // set version
    
                            //
                            // Display the filter's filename
                            //            
                            // Read filter's CLSID from property bag.  This CLSID string will be
                            // used to find the filter's filename in the registry.
                            VARIANT varFilterClsid;
                            varFilterClsid.vt = VT_BSTR;
    
                            hr = pPropBag->Read(L"CLSID", &varFilterClsid, 0);
                            if(SUCCEEDED(hr))
                            {
                                TCHAR szKey[2048];
    
                                // Convert BSTR to string
                                WCHAR *wszFilterClsid;
                                TCHAR szFilterClsid[1024];
                                wszFilterClsid = varFilterClsid.bstrVal;
    
            #ifdef _UNICODE
                                wcsncpy(szFilterClsid, wszFilterClsid, 1024);
                                szFilterClsid[1023]=0;
            #else
                                WideCharToMultiByte(CP_ACP,
                                                    0,
                                                    wszFilterClsid,
                                                    -1,
                                                    szFilterClsid,
                                                    sizeof(szFilterClsid),
                                                    0,
                                                    0);
                                szFilterClsid[1023]=0;
            #endif
    
                                // Create key name for reading filename registry
                                _sntprintf(szKey, 2048, TEXT("Software\\Classes\\CLSID\\%s\\InprocServer32\0"),
                                         szFilterClsid);
                                szKey[2047]=0;
    
                                // Variables needed for registry query
                                HKEY hkeyFilter=0;
                                DWORD dwSize=MAX_PATH;
                                TCHAR szFilename[MAX_PATH];
                                int rc=0;
    
                                // Open the CLSID key that contains information about the filter
                                rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hkeyFilter);
                                if (rc == ERROR_SUCCESS)
                                {
                                    rc = RegQueryValueEx(hkeyFilter, NULL,  // Read (Default) value
                                                         NULL, NULL, (BYTE*)szFilename, &dwSize);
    
                                    if (rc == ERROR_SUCCESS)
                                    {
                                        _tcsncpy( pFilterInfo->m_szFileName, szFilename, MAX_PATH );    // set file name & version
                                        pFilterInfo->m_szFileName[MAX_PATH-1]=0;
                                        GetFileVersion(pFilterInfo->m_szFileName, pFilterInfo->m_szFileVersion, NULL, NULL, NULL, NULL);
                                    }
    
                                    rc = RegCloseKey(hkeyFilter);
                                }

                                SysFreeString(varFilterClsid.bstrVal);
                            }
           
                            int iPinsInput = 0;
                            int iPinsOutput = 0;
    
                            for(UINT iPin = 0; iPin < pFil->cPins; iPin++)
                            {
                                if(pFil->rgPins2[iPin].dwFlags & REG_PINFLAG_B_OUTPUT)
                                {
                                    iPinsOutput++;
                                }
                                else
                                {
                                    iPinsInput++;
                                }
                            }
    
                            pFilterInfo->m_dwInputs = iPinsInput;                           // set input
                            pFilterInfo->m_dwOutputs = iPinsOutput;                         // set output
    
                        }
    
                        CoTaskMemFree( (BYTE*) pFil );
                    }
            
                    SafeArrayUnaccessData(varFilData.parray);
                }
            }

            VariantClear(&varFilData);
        }

        pPropBag->Release();
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\sndinfo.h ===
/****************************************************************************
 *
 *    File: sndinfo.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about sound devices on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef SNDINFO_H
#define SNDINFO_H

// DXD_IN_DS_VALUE is the name of a value stored under the registry key 
// HKLM\DXD_IN_DS_KEY that indicates that DxDiag is using
// DirectSound.  If DxDiag starts up and this value exists, DxDiag 
// probably crashed in DirectSound and DxDiag should offer to run without
// using DirectSound.
#define DXD_IN_DS_KEY TEXT("Software\\Microsoft\\DirectX Diagnostic Tool")
#define DXD_IN_DS_VALUE TEXT("DxDiag In DirectSound")

struct SoundInfo
{
    GUID m_guid;
    DWORD m_dwDevnode;
    TCHAR m_szDeviceID[200];
    TCHAR m_szRegKey[200];
    TCHAR m_szManufacturerID[100];
    TCHAR m_szProductID[100];
    TCHAR m_szDescription[200];
    TCHAR m_szDriverName[200];
    TCHAR m_szDriverPath[500];
    TCHAR m_szDriverVersion[100];
    TCHAR m_szDriverLanguage[100];
    TCHAR m_szDriverLanguageLocal[100];
    TCHAR m_szDriverAttributes[100];
    TCHAR m_szDriverDate[60];
    TCHAR m_szDriverDateLocal[60];
    TCHAR m_szOtherDrivers[200];
    TCHAR m_szProvider[200];
    TCHAR m_szType[100]; // Emulated / vxd / wdm
    LONG m_numBytes;
    BOOL m_bDriverBeta;
    BOOL m_bDriverDebug;
    BOOL m_bDriverSigned;
    BOOL m_bDriverSignedValid;
    LONG m_lwAccelerationLevel;

    RegError* m_pRegErrorFirst;
    TCHAR m_szNotes[3000]; 
    TCHAR m_szNotesEnglish[3000]; 

    TestResult m_testResultSnd; // This is filled in by testsnd.cpp

    SoundInfo* m_pSoundInfoNext;
};

HRESULT GetBasicSoundInfo(SoundInfo** ppSoundInfoFirst);
HRESULT GetExtraSoundInfo(SoundInfo* pSoundInfoFirst);
HRESULT GetDSSoundInfo(SoundInfo* pSoundInfoFirst);
VOID DestroySoundInfo(SoundInfo* pSoundInfoFirst);
HRESULT ChangeAccelerationLevel(SoundInfo* pSoundInfo, LONG lwLevel);
VOID DiagnoseSound(SoundInfo* pSoundInfoFirst);


#endif // DISPINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\sndinfo.cpp ===
/****************************************************************************
 *
 *    File: sndinfo.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about sound devices on this machine
 *
 * (C) Copyright 1998-1999 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#define DIRECTSOUND_VERSION  0x0600
#include <tchar.h>
#include <Windows.h>
#include <mmsystem.h>
#include <d3dtypes.h>
#include <dsound.h>
#include <stdio.h>
#include "mmddk.h" // for DRV_QUERYDEVNODE
#include "dsprv.h"
#include "dsprvobj.h"
#include "reginfo.h"
#include "sysinfo.h" // for BIsPlatformNT
#include "dispinfo.h"
#include "sndinfo.h"
#include "fileinfo.h" // for GetFileVersion, FileIsSigned
#include "resource.h"

// This function is defined in sndinfo7.cpp:
HRESULT GetRegKey(LPKSPROPERTYSET pKSPS7, REFGUID guidDeviceID, TCHAR* pszRegKey);

typedef HRESULT (WINAPI* LPDIRECTSOUNDENUMERATE)(LPDSENUMCALLBACK lpDSEnumCallback,
    LPVOID lpContext);
typedef HRESULT (WINAPI* LPDIRECTSOUNDCREATE)(LPGUID lpGUID, LPDIRECTSOUND* ppDS, 
    LPUNKNOWN pUnkOuter);

static BOOL CALLBACK DSEnumCallback(LPGUID pGuid, TCHAR* pszDescription, 
                                    TCHAR* pszModule, LPVOID lpContext);
static VOID GetRegSoundInfo9x(SoundInfo* pSoundInfo);
static VOID GetRegSoundInfoNT(SoundInfo* pSoundInfo);
static HRESULT GetDirectSoundInfo(LPDIRECTSOUNDCREATE pDSCreate, SoundInfo* pSoundInfo);
static HRESULT CheckRegistry(RegError** ppRegErrorFirst);

static LPKSPROPERTYSET s_pKSPS = NULL;
static DWORD s_dwWaveIDDefault = 0;

/****************************************************************************
 *
 *  GetBasicSoundInfo
 *
 ****************************************************************************/
HRESULT GetBasicSoundInfo(SoundInfo** ppSoundInfoFirst)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];
    HINSTANCE hInstDSound = NULL;
    LPDIRECTSOUNDENUMERATE pdse;

    lstrcpy( szPath, TEXT("") );
    
    // Find which waveout device is the default, the one that would
    // be used by DirectSoundCreate(NULL).  If the following code
    // fails, assume it's device 0.
    DWORD dwParam2 = 0;
    waveOutMessage( (HWAVEOUT)IntToPtr(WAVE_MAPPER), DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &s_dwWaveIDDefault, (DWORD_PTR) &dwParam2 );
    if( s_dwWaveIDDefault == -1 )
        s_dwWaveIDDefault = 0;

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dsound.dll"));
    hInstDSound = LoadLibrary(szPath);
    if (hInstDSound == NULL)
        goto LEnd;
    // Get Private DirectSound object:
    if (FAILED(hr = DirectSoundPrivateCreate(&s_pKSPS)))
    {
        // note: no error.  This will always fail on Win95.
    }

    // Get DirectSoundEnumerate and call it:
    pdse = (LPDIRECTSOUNDENUMERATE)GetProcAddress(hInstDSound, 
#ifdef UNICODE
        "DirectSoundEnumerateW"
#else
        "DirectSoundEnumerateA"
#endif
        );
    if (pdse == NULL)
        goto LEnd;

    if (FAILED(hr = pdse((LPDSENUMCALLBACK)DSEnumCallback, ppSoundInfoFirst)))
        goto LEnd;

LEnd:
    if (s_pKSPS != NULL)
    {
        s_pKSPS->Release();
        s_pKSPS = NULL;
    }
    if (hInstDSound != NULL)
        FreeLibrary(hInstDSound);
    return hr;
}


/****************************************************************************
 *
 *  DSEnumCallback
 *
 ****************************************************************************/
BOOL CALLBACK DSEnumCallback(LPGUID pGuid, TCHAR* pszDescription, 
                             TCHAR* pszModule, LPVOID lpContext)
{
    SoundInfo** ppSoundInfoFirst = (SoundInfo**)lpContext;
    SoundInfo* pSoundInfoNew;
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pdsdData = NULL;

    if (pGuid == NULL)
        return TRUE; // skip this guy

    // We decided to only report on the default, primary DSound device for
    // now.  Remove the next few lines to show a page per device.
    // Use private interface to get bonus information:
    if (*ppSoundInfoFirst != NULL)
        return FALSE; // We got our device, so stop enumerating
    if (s_pKSPS != NULL)
    {
        if (FAILED(PrvGetDeviceDescription(s_pKSPS, *pGuid, &pdsdData)))
            return TRUE; // error on this device--keep enumerating
        if (pdsdData->WaveDeviceId != s_dwWaveIDDefault)
            return TRUE; // not default device--keep enumerating
    }
    // Note: on Win95, where s_pKSPS is NULL, we can't get the device ID,
    // so we don't know which DSound device is the default one.  So just
    // use the first one that comes up in the enumeration after the one
    // with NULL pGuid.

    pSoundInfoNew = new SoundInfo;
    if (pSoundInfoNew == NULL)
        return FALSE;
    ZeroMemory(pSoundInfoNew, sizeof(SoundInfo));
    if (*ppSoundInfoFirst == NULL)
    {
        *ppSoundInfoFirst = pSoundInfoNew;
    }
    else
    {
        SoundInfo* pSoundInfo;
        for (pSoundInfo = *ppSoundInfoFirst; 
            pSoundInfo->m_pSoundInfoNext != NULL; 
            pSoundInfo = pSoundInfo->m_pSoundInfoNext)
            {
            }
        pSoundInfo->m_pSoundInfoNext = pSoundInfoNew;
    }
    pSoundInfoNew->m_guid = *pGuid;
    _tcsncpy(pSoundInfoNew->m_szDescription, pszDescription, 200);
    pSoundInfoNew->m_szDescription[199] = 0;

    if (s_pKSPS == NULL)
    {
        // Without the DSound private interface, we can't use it to get
        // waveout device ID or devnode.  Assume device ID is 0, and use
        // waveOutMessage(DRV_QUERYDEVNODE) to get dev node.
        waveOutMessage((HWAVEOUT)0, DRV_QUERYDEVNODE, (DWORD_PTR)&pSoundInfoNew->m_dwDevnode, 0);
        pSoundInfoNew->m_lwAccelerationLevel = -1;
    }
    else
    {
        pSoundInfoNew->m_dwDevnode = pdsdData->Devnode;
        if (pdsdData->Type == 0)
            LoadString(NULL, IDS_EMULATED, pSoundInfoNew->m_szType, 100);
        else if (pdsdData->Type == 1)
            LoadString(NULL, IDS_VXD, pSoundInfoNew->m_szType, 100);
        else if (pdsdData->Type == 2)
            LoadString(NULL, IDS_WDM, pSoundInfoNew->m_szType, 100);
        DIRECTSOUNDBASICACCELERATION_LEVEL accelLevel;
        if (FAILED(PrvGetBasicAcceleration(s_pKSPS, *pGuid, &accelLevel)))
            pSoundInfoNew->m_lwAccelerationLevel = -1;
        else
            pSoundInfoNew->m_lwAccelerationLevel = (LONG)accelLevel;

        // This will only work on DX7 and beyond
        GetRegKey(s_pKSPS, *pGuid, pSoundInfoNew->m_szRegKey);
    }

    WAVEOUTCAPS waveoutcaps;
    LONG devID;
    if (pdsdData == NULL)
        devID = 0;
    else
        devID = pdsdData->WaveDeviceId;
    if (MMSYSERR_NOERROR == waveOutGetDevCaps(devID, &waveoutcaps, sizeof(waveoutcaps)))
    {
        // May want to use mmreg.h to add strings for manufacturer/product names here
        wsprintf(pSoundInfoNew->m_szManufacturerID, TEXT("%d"), waveoutcaps.wMid);
        wsprintf(pSoundInfoNew->m_szProductID, TEXT("%d"), waveoutcaps.wPid);
    }

    // Sometimes, pszModule is the full path.  Sometimes it's just the leaf.
    // Sometimes, it's something inbetween.  Separate the leaf, and look
    // in a few different places.
    TCHAR* pszLeaf;
    pszLeaf = _tcsrchr(pszModule, TEXT('\\'));
    if (pszLeaf == NULL)
    {
        lstrcpy(pSoundInfoNew->m_szDriverName, pszModule);
    }
    else
    {
        lstrcpy(pSoundInfoNew->m_szDriverName, (pszLeaf + 1));
    }
    // Try just module string
    int nLenMod = lstrlen(pszModule);

    _tcsncpy(pSoundInfoNew->m_szDriverPath, pszModule, 500);
    pSoundInfoNew->m_szDriverPath[499]=0;
    if (pszLeaf == NULL || GetFileAttributes(pSoundInfoNew->m_szDriverPath) == 0xFFFFFFFF)
    {
        // Try windows dir + module string
        if( GetWindowsDirectory(pSoundInfoNew->m_szDriverPath, MAX_PATH) != 0 )
        {
            lstrcat(pSoundInfoNew->m_szDriverPath, TEXT("\\"));
            if( lstrlen(pSoundInfoNew->m_szDriverPath) + nLenMod < 500 )
                lstrcat(pSoundInfoNew->m_szDriverPath, pszModule);
            if (GetFileAttributes(pSoundInfoNew->m_szDriverPath) == 0xFFFFFFFF)
            {
                // Try system dir + module string
                if( GetSystemDirectory(pSoundInfoNew->m_szDriverPath, MAX_PATH) != 0 )
                {
                    lstrcat(pSoundInfoNew->m_szDriverPath, TEXT("\\"));
                    if( lstrlen(pSoundInfoNew->m_szDriverPath) + nLenMod < 500 )
                        lstrcat(pSoundInfoNew->m_szDriverPath, pszModule);
                    if (GetFileAttributes(pSoundInfoNew->m_szDriverPath) == 0xFFFFFFFF)
                    {
                        // Try windows dir + \system32\drivers\ + module string
                        if( GetWindowsDirectory(pSoundInfoNew->m_szDriverPath, MAX_PATH) != 0 )
                        {
                            lstrcat(pSoundInfoNew->m_szDriverPath, TEXT("\\System32\\Drivers\\"));
                            if( lstrlen(pSoundInfoNew->m_szDriverPath) + nLenMod < 500 )
                                lstrcat(pSoundInfoNew->m_szDriverPath, pszModule);
                        }
                    }
                }
            }
        }
    }

    PrvReleaseDeviceDescription( pdsdData );

    return TRUE;
}



/****************************************************************************
 *
 *  GetExtraSoundInfo
 *
 ****************************************************************************/
HRESULT GetExtraSoundInfo(SoundInfo* pSoundInfoFirst)
{
    SoundInfo* pSoundInfo;
    BOOL bNT = BIsPlatformNT();

    for (pSoundInfo = pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfo->m_pSoundInfoNext)
    {
        CheckRegistry(&pSoundInfo->m_pRegErrorFirst);

        if (bNT)
            GetRegSoundInfoNT(pSoundInfo);
        else
            GetRegSoundInfo9x(pSoundInfo);

        // Bug 18245: Try to distinguish between the various IBM MWave cards
        if (_tcsstr(pSoundInfo->m_szDeviceID, TEXT("MWAVEAUDIO_0460")) != NULL)
            lstrcat(pSoundInfo->m_szDescription, TEXT(" (Stingray)"));
        else if (_tcsstr(pSoundInfo->m_szDeviceID, TEXT("MWAVEAUDIO_0465")) != NULL)
            lstrcat(pSoundInfo->m_szDescription, TEXT(" (Marlin)"));
        else 
        {
            TCHAR szBoard[100];
            lstrcpy( szBoard, TEXT("") );            
            GetPrivateProfileString(TEXT("Mwave,Board"), TEXT("board"), TEXT(""),
                szBoard, 100, TEXT("MWave.ini"));
            if (lstrcmp(szBoard, TEXT("MWAT-046")) == 0)
                lstrcat(pSoundInfo->m_szDescription, TEXT(" (Dolphin)"));
            else if (lstrcmp(szBoard, TEXT("MWAT-043")) == 0)
                lstrcat(pSoundInfo->m_szDescription, TEXT(" (Whale)"));
        }

        // Sometimes, like when a sound driver is emulated, the driver
        // will be reported as something like "WaveOut 0".  In this case,
        // just blank out the file-related fields.
        if (_tcsstr(pSoundInfo->m_szDriverName, TEXT(".")) == NULL)
        {
            lstrcpy(pSoundInfo->m_szDriverName, TEXT(""));
            lstrcpy(pSoundInfo->m_szDriverPath, TEXT(""));
        }
        else
        {
            GetFileVersion(pSoundInfo->m_szDriverPath, pSoundInfo->m_szDriverVersion, 
                pSoundInfo->m_szDriverAttributes, pSoundInfo->m_szDriverLanguageLocal, pSoundInfo->m_szDriverLanguage,
                &pSoundInfo->m_bDriverBeta, &pSoundInfo->m_bDriverDebug);

            FileIsSigned(pSoundInfo->m_szDriverPath, &pSoundInfo->m_bDriverSigned, &pSoundInfo->m_bDriverSignedValid);

            GetFileDateAndSize(pSoundInfo->m_szDriverPath, 
                pSoundInfo->m_szDriverDateLocal, pSoundInfo->m_szDriverDate, &pSoundInfo->m_numBytes);
        }
    }

    return S_OK;
}


/****************************************************************************
 *
 *  GetRegSoundInfo9x
 *
 ****************************************************************************/
VOID GetRegSoundInfo9x(SoundInfo* pSoundInfo)
{
    HKEY hkey = NULL;
    DWORD iKey = 0;
    TCHAR szSubKey[200];
    DWORD dwSubKeySize;
    TCHAR szClass[100];
    DWORD dwClassSize;
    HKEY hkeySub = NULL;
    DWORD dwDevnode;
    DWORD cb;
    DWORD dwType;
    HKEY hkeyOther = NULL;

    // We have the DevNode, so find the device in the registry with the 
    // matching DevNode and gather more info there.
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\control\\MediaResources\\wave"),
        0, KEY_READ, &hkey))
    {
        while (TRUE)
        {
            dwSubKeySize = sizeof(szSubKey);
            dwClassSize = sizeof(szClass);
            if (ERROR_SUCCESS != RegEnumKeyEx(hkey, iKey, szSubKey, &dwSubKeySize, NULL, szClass, &dwClassSize, NULL))
                break;
            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szSubKey, 0, KEY_READ, &hkeySub))
            {
                cb = sizeof(dwDevnode);
                if (ERROR_SUCCESS == RegQueryValueEx(hkeySub, TEXT("DevNode"), NULL, &dwType, (BYTE*)&dwDevnode, &cb))
                {
                    if (dwDevnode == pSoundInfo->m_dwDevnode)
                    {
                        // Found match...gather yummy info
                        cb = sizeof(pSoundInfo->m_szDeviceID);
                        RegQueryValueEx(hkeySub, TEXT("DeviceID"), NULL, &dwType, (BYTE*)pSoundInfo->m_szDeviceID, &cb);

                        // Occasionally the driver name that DirectSoundEnumerate spits out
                        // is garbage (as with my Crystal SoundFusion).  If that's the case,
                        // use the driver name listed here instead.
                        if (lstrlen(pSoundInfo->m_szDriverName) < 4)
                        {
                            cb = sizeof(pSoundInfo->m_szDriverName);
                            RegQueryValueEx(hkeySub, TEXT("Driver"), NULL, &dwType, (BYTE*)pSoundInfo->m_szDriverName, &cb);
                            GetSystemDirectory(pSoundInfo->m_szDriverPath, MAX_PATH);
                            lstrcat(pSoundInfo->m_szDriverPath, TEXT("\\"));
                            if( lstrlen(pSoundInfo->m_szDriverPath) + lstrlen(pSoundInfo->m_szDriverName) < 500 )
                                lstrcat(pSoundInfo->m_szDriverPath, pSoundInfo->m_szDriverName);
                        }
                        TCHAR szOtherKey[300];
                        cb = sizeof(szOtherKey);
                        RegQueryValueEx(hkeySub, TEXT("SOFTWAREKEY"), NULL, &dwType, (BYTE*)szOtherKey, &cb);
                        if (lstrlen(szOtherKey) > 0)
                        {
                            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOtherKey, 0, KEY_READ, &hkeyOther))
                            {
                                cb = sizeof(pSoundInfo->m_szOtherDrivers);
                                RegQueryValueEx(hkeyOther, TEXT("Driver"), NULL, &dwType, (BYTE*)pSoundInfo->m_szOtherDrivers, &cb);
                                cb = sizeof(pSoundInfo->m_szProvider);
                                RegQueryValueEx(hkeyOther, TEXT("ProviderName"), NULL, &dwType, (BYTE*)pSoundInfo->m_szProvider, &cb);
                                RegCloseKey(hkeyOther);
                            }
                        }
                    }
                }
                RegCloseKey(hkeySub);
            }
            iKey++;
        }
        RegCloseKey(hkey);
    }
}


/****************************************************************************
 *
 *  GetRegSoundInfoNT
 *
 ****************************************************************************/
VOID GetRegSoundInfoNT(SoundInfo* pSoundInfo)
{
    TCHAR szFullKey[300];
    HKEY hkey;
    DWORD cbData;
    DWORD dwType;
    TCHAR szDriverKey[300];
    TCHAR szOtherFullKey[300];

    lstrcpy(szFullKey, TEXT("System\\CurrentControlSet\\Enum\\"));
    lstrcat(szFullKey, pSoundInfo->m_szRegKey);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szFullKey, 0, KEY_READ, &hkey))
    {
        cbData = sizeof(pSoundInfo->m_szDeviceID);
        RegQueryValueEx(hkey, TEXT("HardwareID"), 0, &dwType, (LPBYTE)pSoundInfo->m_szDeviceID, &cbData);

        cbData = sizeof(szDriverKey);
        RegQueryValueEx(hkey, TEXT("Driver"), 0, &dwType, (LPBYTE)szDriverKey, &cbData);
        
        RegCloseKey(hkey);
    }

    lstrcpy(szOtherFullKey, TEXT("System\\CurrentControlSet\\Control\\Class\\"));
    lstrcat(szOtherFullKey, szDriverKey);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szOtherFullKey, 0, KEY_READ, &hkey))
    {
        cbData = sizeof(pSoundInfo->m_szProvider);
        RegQueryValueEx(hkey, TEXT("ProviderName"), 0, &dwType, (LPBYTE)pSoundInfo->m_szProvider, &cbData);

        RegCloseKey(hkey);
    }
}


/****************************************************************************
 *
 *  GetDSSoundInfo
 *
 ****************************************************************************/
HRESULT GetDSSoundInfo(SoundInfo* pSoundInfoFirst)
{
    HRESULT hr;
    HRESULT hrRet = S_OK;
    SoundInfo* pSoundInfo;
    TCHAR szPath[MAX_PATH];
    HINSTANCE hInstDSound;
    LPDIRECTSOUNDCREATE pDSCreate;

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dsound.dll"));
    hInstDSound = LoadLibrary(szPath);
    if (hInstDSound == NULL)
        return E_FAIL;
    pDSCreate = (LPDIRECTSOUNDCREATE)GetProcAddress(hInstDSound, "DirectSoundCreate");
    if (pDSCreate == NULL)
    {
        FreeLibrary(hInstDSound);
        return E_FAIL;
    }
        
    for (pSoundInfo = pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfo->m_pSoundInfoNext)
    {
        if (FAILED(hr = GetDirectSoundInfo(pDSCreate, pSoundInfo)))
            hrRet = hr; // but keep going
    }
    FreeLibrary(hInstDSound);

    return hrRet;
}


/****************************************************************************
 *
 *  IsDriverWDM
 *
 ****************************************************************************/
BOOL IsDriverWDM( TCHAR* szDriverName )
{
    if( _tcsstr( szDriverName, TEXT(".sys") ) == NULL )
        return FALSE;
    else
        return TRUE;
}


/****************************************************************************
 *
 *  GetDirectSoundInfo
 *
 ****************************************************************************/
HRESULT GetDirectSoundInfo(LPDIRECTSOUNDCREATE pDSCreate, SoundInfo* pSoundInfo)
{
    HRESULT hr;
    LPDIRECTSOUND pds = NULL;
    GUID* pGUID;
    DSCAPS dscaps;

    // Right now, this function only calls DSCreate/GetCaps to determine if
    // the driver is signed.  If we have already determined that it is by 
    // other means, don't bother with this test.
    if (pSoundInfo->m_bDriverSigned)
        return S_OK;

    // Bug 29918: If this is a WDM driver, then don't call GetCaps() since
    // on DX7.1+ GetCaps() will always return DSCAPS_CERTIFIED on WDM drivers
    if( IsDriverWDM( pSoundInfo->m_szDriverName ) )
        return S_OK;

    if (pSoundInfo->m_guid == GUID_NULL)
        pGUID = NULL;
    else
        pGUID = &pSoundInfo->m_guid;

    if (FAILED(hr = pDSCreate(pGUID, &pds, NULL)))
        goto LFail;

    dscaps.dwSize = sizeof(dscaps);
    if (FAILED(hr = pds->GetCaps(&dscaps)))
        goto LFail;

    pSoundInfo->m_bDriverSignedValid = TRUE;
    if (dscaps.dwFlags & DSCAPS_CERTIFIED)
        pSoundInfo->m_bDriverSigned = TRUE;
    
    pds->Release();
    return S_OK;
LFail:
    if (pds != NULL)
        pds->Release();
    return hr;
}


/****************************************************************************
 *
 *  ChangeAccelerationLevel
 *
 ****************************************************************************/
HRESULT ChangeAccelerationLevel(SoundInfo* pSoundInfo, LONG lwLevel)
{
    HRESULT hr = S_OK;
    DIRECTSOUNDBASICACCELERATION_LEVEL level = (DIRECTSOUNDBASICACCELERATION_LEVEL)lwLevel;
    LPKSPROPERTYSET pksps = NULL;
    TCHAR szPath[MAX_PATH];
    HINSTANCE hInstDSound = NULL;

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dsound.dll"));
    hInstDSound = LoadLibrary(szPath);
    if (hInstDSound == NULL)
    {
        hr = DDERR_NOTFOUND;
        goto LEnd;
    }

    if (FAILED(hr = DirectSoundPrivateCreate(&pksps)))
        goto LEnd;

    if (FAILED(hr = PrvSetBasicAcceleration(pksps, pSoundInfo->m_guid, level)))
        goto LEnd;

LEnd:
    if (pksps != NULL)
        pksps->Release();
    if (hInstDSound != NULL)
        FreeLibrary(hInstDSound);
    pSoundInfo->m_lwAccelerationLevel = lwLevel;
    return hr;
}


/****************************************************************************
 *
 *  CheckRegistry
 *
 ****************************************************************************/
HRESULT CheckRegistry(RegError** ppRegErrorFirst)
{
    HRESULT hr;
    HKEY HKCR = HKEY_CLASSES_ROOT;

    TCHAR szVersion[100];
    HKEY hkey;
    DWORD cbData;
    ULONG ulType;

    DWORD dwMajor = 0;
    DWORD dwMinor = 0;
    DWORD dwRevision = 0;
    DWORD dwBuild = 0;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectX"),
        0, KEY_READ, &hkey))
    {
        cbData = 100;
        RegQueryValueEx(hkey, TEXT("Version"), 0, &ulType, (LPBYTE)szVersion, &cbData);
        RegCloseKey(hkey);
        if (lstrlen(szVersion) > 6 && 
            lstrlen(szVersion) < 20)
        {
            if( _stscanf(szVersion, TEXT("%d.%d.%d.%d"), &dwMajor, &dwMinor, &dwRevision, &dwBuild) != 4 )
            {
                dwMajor = 0;
                dwMinor = 0;
                dwRevision = 0;
                dwBuild = 0;
            }
        }
    }

    // No registry checking on DX versions before DX7
    if (dwMinor < 7)
        return S_OK;

    // From dsound.inf:
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("DirectSound"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("DirectSound\\CLSID"), TEXT(""), TEXT("{47D4D946-62E8-11cf-93BC-444553540000}"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{47D4D946-62E8-11cf-93BC-444553540000}"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{47D4D946-62E8-11cf-93BC-444553540000}\\InprocServer32"), TEXT(""), TEXT("dsound.dll"), CRF_LEAF)))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{47D4D946-62E8-11cf-93BC-444553540000}\\InprocServer32"), TEXT("ThreadingModel"), TEXT("Both"))))
        return hr;

    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("DirectSoundCapture"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("DirectSoundCapture\\CLSID"), TEXT(""), TEXT("{B0210780-89CD-11d0-AF08-00A0C925CD16}"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{B0210780-89CD-11d0-AF08-00A0C925CD16}"), TEXT(""), TEXT("*"))))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{B0210780-89CD-11d0-AF08-00A0C925CD16}\\InprocServer32"), TEXT(""), TEXT("dsound.dll"), CRF_LEAF)))
        return hr;
    if (FAILED(hr = CheckRegString(ppRegErrorFirst, HKCR, TEXT("CLSID\\{B0210780-89CD-11d0-AF08-00A0C925CD16}\\InprocServer32"), TEXT("ThreadingModel"), TEXT("Both"))))
        return hr;

    return S_OK;
}


/****************************************************************************
 *
 *  DestroySoundInfo
 *
 ****************************************************************************/
VOID DestroySoundInfo(SoundInfo* pSoundInfoFirst)
{
    SoundInfo* pSoundInfo;
    SoundInfo* pSoundInfoNext;

    for (pSoundInfo = pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfoNext)
    {
        DestroyReg( &pSoundInfo->m_pRegErrorFirst );

        pSoundInfoNext = pSoundInfo->m_pSoundInfoNext;
        delete pSoundInfo;
    }
}


/****************************************************************************
 *
 *  DiagnoseSound
 *
 ****************************************************************************/
VOID DiagnoseSound(SoundInfo* pSoundInfoFirst)
{
    SoundInfo* pSoundInfo;
    TCHAR sz[500];
    TCHAR szFmt[500];

    for (pSoundInfo = pSoundInfoFirst; pSoundInfo != NULL; 
        pSoundInfo = pSoundInfo->m_pSoundInfoNext)
    {
        _tcscpy( pSoundInfo->m_szNotes, TEXT("") );
        _tcscpy( pSoundInfo->m_szNotesEnglish, TEXT("") );

         // Report any problems:
        BOOL bProblem = FALSE;
        if ( pSoundInfo->m_bDriverSignedValid && 
             !pSoundInfo->m_bDriverSigned && 
             lstrlen(pSoundInfo->m_szDriverName) > 0)
        {
            LoadString(NULL, IDS_UNSIGNEDDRIVERFMT1, szFmt, 300);
            wsprintf(sz, szFmt, pSoundInfo->m_szDriverName);
            _tcscat( pSoundInfo->m_szNotes, sz );

            LoadString(NULL, IDS_UNSIGNEDDRIVERFMT1_ENGLISH, szFmt, 300);
            wsprintf(sz, szFmt, pSoundInfo->m_szDriverName);
            _tcscat( pSoundInfo->m_szNotesEnglish, sz );

            bProblem = TRUE;
        }

        if (pSoundInfo->m_pRegErrorFirst != NULL)
        {
            LoadString(NULL, IDS_REGISTRYPROBLEM, sz, 500);
            _tcscat( pSoundInfo->m_szNotes, sz );

            LoadString(NULL, IDS_REGISTRYPROBLEM_ENGLISH, sz, 500);
            _tcscat( pSoundInfo->m_szNotesEnglish, sz );

            bProblem = TRUE;
        }

        // Report any DSound test results:
        if (pSoundInfo->m_testResultSnd.m_bStarted &&
            !pSoundInfo->m_testResultSnd.m_bCancelled)
        {
            LoadString(NULL, IDS_DSRESULTS, sz, 500);
            _tcscat( pSoundInfo->m_szNotes, sz );
            _tcscat( pSoundInfo->m_szNotes, pSoundInfo->m_testResultSnd.m_szDescription );
            _tcscat( pSoundInfo->m_szNotes, TEXT("\r\n") );

            LoadString(NULL, IDS_DSRESULTS_ENGLISH, sz, 500);
            _tcscat( pSoundInfo->m_szNotesEnglish, sz );
            _tcscat( pSoundInfo->m_szNotesEnglish, pSoundInfo->m_testResultSnd.m_szDescriptionEnglish );
            _tcscat( pSoundInfo->m_szNotesEnglish, TEXT("\r\n") );

            bProblem = TRUE;
        }
        else
        {
            LoadString(NULL, IDS_DSINSTRUCTIONS, sz, 500);
            _tcscat( pSoundInfo->m_szNotes, sz );

            LoadString(NULL, IDS_DSINSTRUCTIONS_ENGLISH, sz, 500);
            _tcscat( pSoundInfo->m_szNotesEnglish, sz );
        }

        if (!bProblem)
        {
            LoadString(NULL, IDS_NOPROBLEM, sz, 500);
            _tcscat( pSoundInfo->m_szNotes, sz );

            LoadString(NULL, IDS_NOPROBLEM_ENGLISH, sz, 500);
            _tcscat( pSoundInfo->m_szNotesEnglish, sz );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\showinfo.h ===
/****************************************************************************
 *
 *    File: showinfo.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather information about DirectShow
 *
 * (C) Copyright 2001 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef SHOWINFO_H
#define SHOWINFO_H

struct FilterInfo
{
    TCHAR   m_szName[1024];             // friendly name
    TCHAR   m_szVersion[32];            // version
    CLSID   m_ClsidFilter;              // guid
    TCHAR   m_szFileName[MAX_PATH];     // file name
    TCHAR   m_szFileVersion[32];        // file version
    TCHAR   m_szCatName[1024];          // category name
    CLSID   m_ClsidCat;                 // category guid
    DWORD   m_dwInputs;                 // number input pins
    DWORD   m_dwOutputs;                // number output pins
    DWORD   m_dwMerit;                  // merit - in hex
    FilterInfo* m_pFilterInfoNext;
};

struct ShowInfo
{
    FilterInfo*     m_pFilters;
    DWORD           m_dwFilters;
};

HRESULT GetBasicShowInfo(ShowInfo** ppShowInfo);
VOID DestroyShowInfo(ShowInfo* pShowInfo);



#endif // SHOWINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DxDiag.rc
//
#define IDS_FIRSTDDTESTERROR            2
#define IDS_STRING3                     3
#define IDS_STRING4                     4
#define IDS_STRING5                     5
#define IDS_STRING6                     6
#define IDS_STRING7                     7
#define IDS_STRING8                     8
#define IDS_STRING9                     9
#define IDS_STRING10                    10
#define IDS_STRING11                    11
#define IDS_STRING12                    12
#define IDS_STRING13                    13
#define IDS_STRING14                    14
#define IDS_STRING15                    15
#define IDS_STRING16                    16
#define IDS_STRING17                    17
#define IDS_STRING18                    18
#define IDS_STRING19                    19
#define IDS_STRING20                    20
#define IDS_STRING21                    21
#define IDS_STRING22                    22
#define IDS_FIRSTD3DTESTERROR           30
#define IDS_STRING31                    31
#define IDS_STRING32                    32
#define IDS_STRING33                    33
#define IDS_STRING34                    34
#define IDS_STRING35                    35
#define IDS_STRING36                    36
#define IDS_STRING37                    37
#define IDS_STRING38                    38
#define IDS_STRING39                    39
#define IDS_STRING40                    40
#define IDS_STRING41                    41
#define IDS_STRING42                    42
#define IDS_STRING43                    43
#define IDS_STRING44                    44
#define IDS_STRING45                    45
#define IDS_STRING46                    46
#define IDS_STRING47                    47
#define IDS_STRING48                    48
#define IDS_STRING49                    49
#define IDS_STRING50                    50
#define IDS_STRING51                    51
#define IDS_STRING52                    52
#define IDS_STRING53                    53
#define IDS_STRING54                    54
#define IDS_STRING55                    55
#define IDS_STRING56                    56
#define IDS_STRING57                    57
#define IDS_STRING58                    58
#define IDS_STRING59                    59
#define IDS_STRING60                    60
#define IDS_STRING61                    61
#define IDS_STRING62                    62
#define IDS_STRING63                    63
#define IDS_STRING64                    64
#define IDS_STRING65                    65
#define IDS_STRING66                    66
#define IDS_STRING67                    67
#define IDS_STRING68                    68
#define IDS_STRING69                    69
#define IDS_STRING70                    70
#define IDS_STRING71                    71
#define IDS_STRING72                    72
#define IDS_STRING73                    73
#define IDS_STRING74                    74
#define IDS_STRING75                    75
#define IDS_STRING76                    76
#define IDS_FIRSTDSOUNDTESTERROR        80
#define IDS_STRING81                    81
#define IDS_STRING82                    82
#define IDS_STRING83                    83
#define IDS_STRING84                    84
#define IDS_STRING85                    85
#define IDS_STRING86                    86
#define IDS_STRING87                    87
#define IDS_STRING88                    88
#define IDS_STRING89                    89
#define IDS_STRING90                    90
#define IDS_STRING91                    91
#define IDS_STRING92                    92
#define IDS_STRING93                    93
#define IDS_STRING94                    94
#define IDS_STRING95                    95
#define IDS_STRING96                    96
#define IDS_STRING97                    97
#define IDS_STRING98                    98
#define IDS_STRING99                    99
#define IDS_OLDWINDOWSVERSION           100
#define IDD_MAINDIALOG                  101
#define IDS_NOBASICDISPLAYINFO          101
#define IDD_HELPPAGE                    102
#define IDS_NOBASICSOUNDINFO            102
#define IDD_DXFILESPAGE                 103
#define IDS_PROBLEMSAVING               103
#define IDI_APP                         104
#define IDS_NORICHED32                  104
#define IDI_CAUTION                     105
#define IDS_NOIMAGELIST                 105
#define IDD_DISPLAYPAGE                 106
#define IDS_NOICON                      106
#define IDD_STILLSTUCKPAGE              107
#define IDS_NOTROUBLESHOOTER            107
#define IDD_SOUNDPAGE                   108
#define IDS_NOMSINFO                    108
#define IDD_INPUTPAGE                   109
#define IDS_COMPONENTFILESPROBLEM       109
#define IDD_BUGINFO                     110
#define IDS_DRIVERFILESPROBLEM          110
#define IDS_NOEXTRADISPLAYINFO          111
#define IDS_NOEXTRASOUNDINFO            112
#define IDR_WAVTST                      113
#define IDS_NOINPUTINFO                 113
#define IDS_NOINPUTDRIVERINFO           114
#define IDS_HELPDIRLEAF                 115
#define IDS_HELPEXE                     116
#define IDD_MUSICPAGE                   117
#define IDS_HELPTAB                     118
#define IDR_TSTSGMT                     118
#define IDS_DXFILESTAB                  119
#define IDR_TSTSTYL                     119
#define IDS_ONEDISPLAYTAB               121
#define IDD_TESTNETSETUP                121
#define IDS_MULTIDISPLAYTAB             122
#define IDD_TESTNETSESSIONS             122
#define IDS_ONESOUNDTAB                 123
#define IDD_TESTNETCHAT                 123
#define IDS_MULTISOUNDTAB               124
#define IDD_GHOST                       124
#define IDS_INPUTTAB                    125
#define IDS_STILLSTUCKTAB               126
#define IDS_COPYRIGHTFMT                127
#define IDS_ERRORFMT1                   128
#define IDD_SPLASH                      128
#define IDS_ERRORFMT2                   129
#define IDS_ERRORTITLE                  130
#define IDS_LISTCONTINUER               131
#define IDS_LISTETC                     132
#define IDS_OBSOLETEFMT1                133
#define IDS_OBSOLETEFMT2                134
#define IDS_OLDFMT1                     135
#define IDS_OLDFMT2                     136
#define IDS_BETAFMT1                    137
#define IDS_BETAFMT2                    138
#define IDS_DEBUGFMT1                   139
#define IDS_DEBUGFMT2                   140
#define IDS_NOPROBLEM                   141
#define IDS_BETADRIVERFMT1              142
#define IDS_BETADRIVERFMT2              143
#define IDS_DEBUGDRIVERFMT1             144
#define IDS_DEBUGDRIVERFMT2             145
#define IDS_ACCELENABLED                146
#define IDS_ACCELDISABLED               147
#define IDS_ACCELUNAVAIL                148
#define IDS_ENABLE                      149
#define IDS_DISABLE                     150
#define IDS_NODRIVERPROBLEM             151
#define IDS_DDRESULTS                   152
#define IDS_DDINSTRUCTIONS              153
#define IDS_DSRESULTS                   154
#define IDS_DSINSTRUCTIONS              155
#define IDS_NOINPUT                     156
#define IDS_DEVICENAME                  157
#define IDS_USAGE                       158
#define IDS_DRIVERNAME                  159
#define IDS_VERSION                     160
#define IDS_ATTRIBUTES                  161
#define IDS_SIGNED                      162
#define IDS_LANGUAGE                    163
#define IDS_DATE                        164
#define IDS_SIZE                        165
#define IDS_YES                         166
#define IDS_NO                          167
#define IDS_REGISTRYKEY                 168
#define IDS_ACTIVE                      169
#define IDS_DEVICEID                    170
#define IDS_MATCHINGDEVID               171
#define IDS_DRIVER16                    172
#define IDS_DRIVER32                    173
#define IDS_NAME                        174
#define IDS_DISABLEDDWARNING            175
#define IDS_ENABLEDDWARNING             176
#define IDS_APPFULLNAME                 177
#define IDS_DISABLED3DWARNING           178
#define IDS_ENABLED3DWARNING            179
#define IDS_SENDBUGINSTRUCTIONS         180
#define IDS_EDITOR                      181
#define IDS_DXFBUGS                     182
#define IDS_EMAILERRORFMT               183
#define IDS_D3DRESULTS                  184
#define IDS_D3DINSTRUCTIONS             185
#define IDS_FILTER                      187
#define IDS_DEFAULTFILENAME             188
#define IDS_DEFAULTEXT                  189
#define IDS_UNSIGNEDDRIVERFMT1          190
#define IDS_UNSIGNEDDRIVERFMT2          191
#define IDS_NA                          192
#define IDS_STARTDDTEST                 193
#define IDS_SKIPWINDOWED                194
#define IDS_DDTEST1                     195
#define IDS_CONFIRMDDTEST1              196
#define IDS_DDTEST2                     197
#define IDS_CONFIRMDDTEST2              198
#define IDS_DDTEST3                     199
#define IDS_CONFIRMDDTEST3              200
#define IDS_ENDDDTESTS                  201
#define IDS_TESTSCANCELLED              202
#define IDS_TESTSSUCCESSFUL             203
#define IDS_UNKNOWNERROR                204
#define IDS_FAILUREFMT                  205
#define IDS_STARTD3DTEST                206
#define IDS_D3DTEST1                    207
#define IDS_CONFIRMD3DTEST              208
#define IDS_YOUCANCELLED                209
#define IDS_D3DTEST2                    210
#define IDS_MODIFYAPPFMT1               211
#define IDS_MODIFYAPPFMT2               212
#define IDS_COULDNTMODIFYAPPSETTINGS    213
#define IDS_BADREFRESHVALUE             214
#define IDS_MISSINGFMT1                 215
#define IDS_MISSINGFMT2                 216
#define IDS_HELPFILE                    217
#define IDS_NOHELP                      218
#define IDS_SETDISPLAYMODEFAILED        220
#define IDS_NOBASICMUSICINFO            221
#define IDS_MUSICTAB                    222
#define IDS_NOEXTRAMUSICINFO            223
#define IDS_DESCRIPTION                 224
#define IDS_TYPE                        225
#define IDS_DLS                         226
#define IDS_DEFAULTPORT                 227
#define IDS_NOPORTS                     228
#define IDS_NOGMDLS                     229
#define IDS_GMDLSFILEMISSING            230
#define IDS_INOUT                       231
#define IDS_STARTDMUSICTEST             232
#define IDS_FIRSTDMUSICTESTERROR        233
#define IDS_STRING234                   234
#define IDS_STRING235                   235
#define IDS_STRING236                   236
#define IDS_STRING237                   237
#define IDS_STRING238                   238
#define IDS_STRING239                   239
#define IDS_STRING240                   240
#define IDS_STRING241                   241
#define IDS_STRING242                   242
#define IDS_STRING243                   243
#define IDS_STRING244                   244
#define IDS_STRING245                   245
#define IDS_MUSICPLAYING                246
#define IDS_DMUSICINSTRUCTIONS          247
#define IDS_DMUSICRESULTS               248
#define IDS_OUTPUT                      249
#define IDS_INPUT                       250
#define IDS_SOFTWARE                    251
#define IDS_HARDWARE                    252
#define IDS_FILEMISSING                 253
#define IDS_GMFILEFMT                   254
#define IDS_SKIP                        255
#define IDS_INWINDOWSFMT1               256
#define IDS_INWINDOWSFMT2               257
#define IDS_STARTDSOUNDTEST             258
#define IDS_NOHARDWAREBUFFERING         259
#define IDS_THATSOUNDWAS                260
#define IDS_3D                          261
#define IDS_MONO                        262
#define IDS_STEREO                      263
#define IDS_MULTICHANNEL                264
#define IDS_EMULATED                    265
#define IDS_VXD                         266
#define IDS_WDM                         267
#define IDS_INVALIDARG                  268
#define IDS_FAIL                        269
#define IDS_UNEXPECTED                  270
#define IDS_NOTIMPL                     271
#define IDS_OUTOFMEMORY                 272
#define IDS_NOINTERFACE                 273
#define IDS_INVALIDMODE                 274
#define IDS_INVALIDPIXELFORMAT          275
#define IDS_CANTCREATEDC                276
#define IDS_NOTFOUND                    277
#define IDS_NODIRECTDRAWSUPPORT         278
#define IDS_NO3D                        279
#define IDS_INVALID_DEVICE              280
#define IDS_INITFAILED                  281
#define IDS_MATERIAL_CREATE_FAILED      282
#define IDS_LIGHT_SET_FAILED            283
#define IDS_CONTROLUNAVAIL              284
#define IDS_BADFORMAT                   285
#define IDS_BUFFERLOST                  286
#define IDS_NODRIVER                    287
#define IDS_DRIVER_FAILED               288
#define IDS_PORTS_OPEN                  289
#define IDS_DEVICE_IN_USE               290
#define IDS_INSUFFICIENTBUFFER          291
#define IDS_CHUNKNOTFOUND               292
#define IDS_BADINSTRUMENT               293
#define IDS_CANNOTREAD                  294
#define IDS_LOADER_BADPATH              295
#define IDS_LOADER_FAILEDOPEN           296
#define IDS_LOADER_FORMATNOTSUPPORTED   297
#define IDS_OBJECTNOTFOUND              298
#define IDS_ALLOCATED                   299
#define IDS_NOTUSED2                    300
#define IDS_NOTUSED3                    301
#define IDS_NOTUSED4                    302
#define IDS_NOTUSED5                    303
#define IDS_ENABLEDD                    304
#define IDS_DISABLEDD                   305
#define IDS_ENABLED3D                   306
#define IDS_DISABLED3D                  307
#define IDS_NO16BITWARNING              308
#define IDS_NOMACHINENAME               309
#define IDS_NECPC98                     310
#define IDS_WINVERFMT                   311
#define IDS_DEBUG                       312
#define IDS_LANGUAGEFMT                 313
#define IDS_PAGEFILEFMT                 314
#define IDS_FINAL                       315
#define IDS_BETA                        316
#define IDS_RETAIL                      317
#define IDS_JOYSTICKPRESENT             318
#define IDS_DEFAULT                     319
#define IDS_EXTERNAL                    320
#define IDS_EXTERNALMUSICPLAYING        321
#define IDS_UNICODE                     322
#define IDS_DEFAULTREFRESH              323
#define IDS_OPTIMALREFRESH              324
#define IDS_NUMPROCFMT                  325
#define IDS_NODXSETUP                   326
#define IDS_UNICODEREQUIRESNT           327
#define IDS_OLDFMT1_NT                  328
#define IDS_OLDFMT2_NT                  329
#define IDS_BETAFMT1_NT                 330
#define IDS_BETAFMT2_NT                 331
#define IDS_DEBUGFMT1_NT                332
#define IDS_DEBUGFMT2_NT                333
#define IDS_MISSINGFMT1_NT              334
#define IDS_MISSINGFMT2_NT              335
#define IDS_KERNELMODE                  336
#define IDS_NETWORKTAB                  337
#define IDS_SPREGISTRYERRORFMT          338
#define IDS_SPFILEMISSINGFMT            339
#define IDS_APPREGISTRYERRORFMT         340
#define IDS_APPFILEMISSINGFMT           341
#define IDS_DPLAYRESULTS                342
#define IDS_DPLAYINSTRUCTIONS           343
#define IDS_REGISTRY                    344
#define IDS_FILE                        345
#define IDS_GUID                        346
#define IDS_OK                          347
#define IDS_ERROR                       348
#define IDS_NONETINFO                   349
#define IDS_DEFAULTUSERNAME             350
#define IDS_DEFAULTSESSIONNAME          351
#define IDS_JOINMSGFMT                  352
#define IDS_LEAVEMSGFMT                 353
#define IDS_FIRSTDPLAYTESTERROR         354
#define IDS_STRING355                   355
#define IDS_STRING356                   356
#define IDS_STRING357                   357
#define IDS_STRING358                   358
#define IDS_STRING359                   359
#define IDS_STRING360                   360
#define IDS_STRING361                   361
#define IDS_STRING362                   362
#define IDS_STRING363                   363
#define IDS_NOSNDACCELERATION           366
#define IDS_BASICSNDACCELERATION        367
#define IDS_STANDARDSNDACCELERATION     368
#define IDS_FULLSNDACCELERATION         369
#define IDS_DPERR_ACCESSDENIED          370
#define IDS_DPERR_CANTADDPLAYER         371
#define IDS_DPERR_CANTCREATESESSION     372
#define IDS_DPERR_EXCEPTION             373
#define IDS_DPERR_INVALIDOBJECT         374
#define IDS_DPERR_NOCONNECTION          375
#define IDS_DPERR_TIMEOUT               376
#define IDS_DPERR_BUSY                  377
#define IDS_DPERR_CONNECTIONLOST        378
#define IDS_DPERR_NOSERVICEPROVIDER     379
#define IDS_DPERR_UNAVAILABLE           380
#define IDS_REGDB_E_CLASSNOTREG         381
#define IDS_TESTNEEDSDX8                383
#define IDS_INITCONNECTIONFAILED        384
#define IDS_DXMBUGS                     385
#define IDS_JOY_HW_NONE                 387
#define IDS_JOY_HW_CUSTOM               388
#define IDS_JOY_HW_2A_2B_GENERIC        389
#define IDS_JOY_HW_2A_4B_GENERIC        390
#define IDS_JOY_HW_2B_GAMEPAD           391
#define IDS_JOY_HW_2B_FLIGHTYOKE        392
#define IDS_JOY_HW_2B_FLIGHTYOKETHROTTLE 393
#define IDS_JOY_HW_3A_2B_GENERIC        394
#define IDS_JOY_HW_3A_4B_GENERIC        395
#define IDS_JOY_HW_4B_GAMEPAD           396
#define IDS_JOY_HW_4B_FLIGHTYOKE        397
#define IDS_JOY_HW_4B_FLIGHTYOKETHROTTLE 398
#define IDS_JOY_UNKNOWN                 399
#define IDS_ATTRIBCOMBINE               400
#define IDS_NT4SAVEONLY                 406
#define IDS_SAVEDONE                    407
#define IDS_HELPNEEDSIE5                412
#define IDS_ENABLEAGP                   413
#define IDS_DISABLEAGP                  414
#define IDS_ENABLEAGPWARNING            415
#define IDS_DISABLEAGPWARNING           416
#define IDS_DXDIAGISOLDFMT              417
#define IDS_NOSOUNDDRIVER               418
#define IDS_NEEDUSERNAME                419
#define IDS_NEEDSESSIONNAME             420
#define IDS_DATEFMT                     421
#define IDS_SESSIONLISTERROR            422
#define IDS_ENABLEDM                    423
#define IDS_DISABLEDM                   424
#define IDS_DISABLEDMWARNING            425
#define IDS_ENABLEDMWARNING             426
#define IDS_REGISTRYPROBLEM             427
#define IDS_PROVIDER                    428
#define IDS_STATUS                      429
#define IDS_PORTNAME                    430
#define IDS_PORTPROVIDER                431
#define IDS_PORTID                      432
#define IDS_PORTSTATUS                  433
#define IDS_INPUTDEVPROBLEMFMT          434
#define IDS_INPUTPORTPROBLEMFMT         435
#define IDS_REPLACEGHOST                436
#define IDS_DATACENTERSERVER            437
#define IDS_ADVANCEDSERVER              438
#define IDS_SERVER                      439
#define IDS_PROFESSIONAL                440
#define IDS_REINSTALL_DX                445
#define IDS_LOOKINGFORSESSIONS          446
#define IDS_PERSONAL                    447
#define IDS_CONNECTING			        448
#define IDS_CONNECTED			        449
#define IDS_OUT_OF_VIDEO_MEMORY		    450
#define IDS_DD                  	    451
#define IDS_DS                  	    452
#define IDS_DM                  	    453
#define IDS_DI                  	    454
#define IDS_DP                  	    455
#define IDS_SI                  	    456
#define IDS_D3DERR_NOTAVAILABLE         457
#define IDS_WINSOCK_WARN                458
#define IDS_NETMEETINGWARN              459
#define IDS_NO_DMUSIC                   460
#define IDS_WEBSERVER                   461
#define IDS_FIRSTDDTESTERROR_ENGLISH    500
#define IDS_STRING501                   501
#define IDS_STRING502                   502
#define IDS_STRING503                   503
#define IDS_STRING504                   504
#define IDS_STRING505                   505
#define IDS_STRING506                   506
#define IDS_STRING507                   507
#define IDS_STRING508                   508
#define IDS_STRING509                   509
#define IDS_STRING510                   510
#define IDS_STRING511                   511
#define IDS_STRING512                   512
#define IDS_STRING513                   513
#define IDS_STRING514                   514
#define IDS_STRING515                   515
#define IDS_STRING516                   516
#define IDS_STRING517                   517
#define IDS_STRING518                   518
#define IDS_STRING519                   519
#define IDS_STRING520                   520
#define IDS_FIRSTD3DTESTERROR_ENGLISH   530
#define IDS_STRING531                   531
#define IDS_STRING532                   532
#define IDS_STRING533                   533
#define IDS_STRING534                   534
#define IDS_STRING535                   535
#define IDS_STRING536                   536
#define IDS_STRING537                   537
#define IDS_STRING538                   538
#define IDS_STRING539                   539
#define IDS_STRING540                   540
#define IDS_STRING541                   541
#define IDS_STRING542                   542
#define IDS_STRING543                   543
#define IDS_STRING544                   544
#define IDS_STRING545                   545
#define IDS_STRING546                   546
#define IDS_STRING547                   547
#define IDS_STRING548                   548
#define IDS_STRING549                   549
#define IDS_STRING550                   550
#define IDS_STRING551                   551
#define IDS_STRING552                   552
#define IDS_STRING553                   553
#define IDS_STRING554                   554
#define IDS_STRING555                   555
#define IDS_STRING556                   556
#define IDS_STRING557                   557
#define IDS_STRING558                   558
#define IDS_STRING559                   559
#define IDS_STRING560                   560
#define IDS_STRING561                   561
#define IDS_STRING562                   562
#define IDS_STRING563                   563
#define IDS_STRING564                   564
#define IDS_STRING565                   565
#define IDS_STRING566                   566
#define IDS_STRING567                   567
#define IDS_STRING568                   568
#define IDS_STRING569                   569
#define IDS_STRING570                   570
#define IDS_STRING571                   571
#define IDS_STRING572                   572
#define IDS_STRING573                   573
#define IDS_STRING574                   574
#define IDS_STRING575                   575
#define IDS_STRING576                   576
#define IDS_FIRSTDSOUNDTESTERROR_ENGLISH 580
#define IDS_STRING581                   581
#define IDS_STRING582                   582
#define IDS_STRING583                   583
#define IDS_STRING584                   584
#define IDS_STRING585                   585
#define IDS_STRING586                   586
#define IDS_STRING587                   587
#define IDS_STRING588                   588
#define IDS_STRING589                   589
#define IDS_STRING590                   590
#define IDS_STRING591                   591
#define IDS_STRING592                   592
#define IDS_STRING593                   593
#define IDS_STRING594                   594
#define IDS_STRING595                   595
#define IDS_STRING596                   596
#define IDS_STRING597                   597
#define IDS_STRING598                   598
#define IDS_STRING599                   599
#define IDS_FIRSTDMUSICTESTERROR_ENGLISH 610
#define IDS_STRING611                   611
#define IDS_STRING612                   612
#define IDS_STRING613                   613
#define IDS_STRING614                   614
#define IDS_STRING615                   615
#define IDS_STRING616                   616
#define IDS_STRING617                   617
#define IDS_STRING618                   618
#define IDS_STRING619                   619
#define IDS_STRING620                   620
#define IDS_STRING621                   621
#define IDS_STRING622                   622
#define IDS_UNKNOWNERROR_ENGLISH        630
#define IDS_FAILUREFMT_ENGLISH          631
#define IDS_INVALIDARG_ENGLISH          640
#define IDS_FAIL_ENGLISH                641
#define IDS_UNEXPECTED_ENGLISH          642
#define IDS_NOTIMPL_ENGLISH             643
#define IDS_OUTOFMEMORY_ENGLISH         644
#define IDS_NOINTERFACE_ENGLISH         645
#define IDS_INVALIDMODE_ENGLISH         646
#define IDS_INVALIDPIXELFORMAT_ENGLISH  647
#define IDS_CANTCREATEDC_ENGLISH        648
#define IDS_NOTFOUND_ENGLISH            649
#define IDS_NODIRECTDRAWSUPPORT_ENGLISH 650
#define IDS_NO3D_ENGLISH                651
#define IDS_INVALID_DEVICE_ENGLISH      652
#define IDS_INITFAILED_ENGLISH          653
#define IDS_MATERIAL_CREATE_FAILED_ENGLISH 654
#define IDS_LIGHT_SET_FAILED_ENGLISH    655
#define IDS_CONTROLUNAVAIL_ENGLISH      656
#define IDS_BADFORMAT_ENGLISH           657
#define IDS_BUFFERLOST_ENGLISH          658
#define IDS_NODRIVER_ENGLISH            659
#define IDS_DRIVER_FAILED_ENGLISH       660
#define IDS_PORTS_OPEN_ENGLISH          661
#define IDS_DEVICE_IN_USE_ENGLISH       662
#define IDS_INSUFFICIENTBUFFER_ENGLISH  663
#define IDS_CHUNKNOTFOUND_ENGLISH       664
#define IDS_BADINSTRUMENT_ENGLISH       665
#define IDS_CANNOTREAD_ENGLISH          666
#define IDS_LOADER_BADPATH_ENGLISH      667
#define IDS_LOADER_FAILEDOPEN_ENGLISH   668
#define IDS_LOADER_FORMATNOTSUPPORTED_ENGLISH 669
#define IDS_OBJECTNOTFOUND_ENGLISH      670
#define IDS_ALLOCATED_ENGLISH           671
#define IDS_NOTUSED2_ENGLISH            672
#define IDS_NOTUSED3_ENGLISH            673
#define IDS_NOTUSED4_ENGLISH            674
#define IDS_NOTUSED5_ENGLISH            675
#define IDS_FIRSTDPLAYTESTERROR_ENGLISH 676
#define IDS_STRING677                   677
#define IDS_STRING678                   678
#define IDS_STRING679                   679
#define IDS_STRING680                   680
#define IDS_STRING681                   681
#define IDS_STRING682                   682
#define IDS_STRING683                   683
#define IDS_STRING684                   684
#define IDS_STRING685                   685
#define IDS_DPERR_ACCESSDENIED_ENGLISH  686
#define IDS_DPERR_CANTADDPLAYER_ENGLISH 687
#define IDS_DPERR_CANTCREATESESSION_ENGLISH 688
#define IDS_DPERR_EXCEPTION_ENGLISH     689
#define IDS_DPERR_INVALIDOBJECT_ENGLISH 690
#define IDS_DPERR_NOCONNECTION_ENGLISH  691
#define IDS_DPERR_TIMEOUT_ENGLISH       692
#define IDS_DPERR_BUSY_ENGLISH          693
#define IDS_DPERR_CONNECTIONLOST_ENGLISH 694
#define IDS_DPERR_NOSERVICEPROVIDER_ENGLISH 695
#define IDS_DPERR_UNAVAILABLE_ENGLISH   697
#define IDS_REGDB_E_CLASSNOTREG_ENGLISH 698
#define IDS_TESTSCANCELLED_ENGLISH      699
#define IDS_TESTSSUCCESSFUL_ENGLISH     700
#define IDS_PAGEFILEFMT_ENGLISH         701
#define IDS_LANGUAGEFMT_ENGLISH         702
#define IDS_DEFAULTREFRESH_ENGLISH      703
#define IDS_OPTIMALREFRESH_ENGLISH      704
#define IDS_FILEMISSING_ENGLISH         705
#define IDS_UNSIGNEDDRIVERFMT1_ENGLISH 706
#define IDS_REGISTRYPROBLEM_ENGLISH     707
#define IDS_NOPROBLEM_ENGLISH           708
#define IDS_DDRESULTS_ENGLISH           709
#define IDS_DDINSTRUCTIONS_ENGLISH      710
#define IDS_D3DRESULTS_ENGLISH          711
#define IDS_D3DINSTRUCTIONS_ENGLISH     712
#define IDS_INWINDOWSFMT1_ENGLISH       715
#define IDS_INWINDOWSFMT2_ENGLISH       716
#define IDS_MISSINGFMT1_ENGLISH         717
#define IDS_MISSINGFMT2_ENGLISH         718
#define IDS_OLDFMT1_ENGLISH             719
#define IDS_OLDFMT2_ENGLISH             720
#define IDS_BETAFMT1_ENGLISH            721
#define IDS_BETAFMT2_ENGLISH            722
#define IDS_DEBUGFMT1_ENGLISH           723
#define IDS_DEBUGFMT2_ENGLISH           724
#define IDS_REINSTALL_DX_ENGLISH        725
#define IDS_DSRESULTS_ENGLISH           726
#define IDS_INPUTDEVPROBLEMFMT_ENGLISH  727
#define IDS_INPUTPORTPROBLEMFMT_ENGLISH 728
#define IDS_DSINSTRUCTIONS_ENGLISH      729
#define IDS_BETADRIVERFMT1_ENGLISH      730
#define IDS_BETADRIVERFMT2_ENGLISH      731
#define IDS_DEBUGDRIVERFMT1_ENGLISH     732
#define IDS_DEBUGDRIVERFMT2_ENGLISH     733
#define IDS_NOINPUT_ENGLISH             734
#define IDS_NOPORTS_ENGLISH             735
#define IDS_NOGMDLS_ENGLISH             736
#define IDS_GMDLSFILEMISSING_ENGLISH    737
#define IDS_SPREGISTRYERRORFMT_ENGLISH  738
#define IDS_SPFILEMISSINGFMT_ENGLISH    739
#define IDS_APPREGISTRYERRORFMT_ENGLISH 740
#define IDS_DPLAYRESULTS_ENGLISH        741
#define IDS_DPLAYINSTRUCTIONS_ENGLISH   742
#define IDS_ACCELUNAVAIL_ENGLISH        743
#define IDS_ACCELENABLED_ENGLISH        744
#define IDS_ACCELDISABLED_ENGLISH       745
#define IDS_DMUSICRESULTS_ENGLISH       746
#define IDS_DMUSICINSTRUCTIONS_ENGLISH  747
#define IDS_OUT_OF_VIDEO_MEMORY_ENGLISH 748
#define IDS_D3DERR_NOTAVAILABLE_ENGLISH 749
#define IDS_WINSOCK_WARN_ENGLISH        750
#define IDS_NETMEETINGWARN_ENGLISH      751
#define IDS_NO_DMUSIC_ENGLISH           752
#define IDS_TROUBLESHOOTER_WIN98        800
#define IDS_SOUNDTROUBLESHOOTER_WIN98   801
#define IDS_TROUBLESHOOTER_WIN98SE      802
#define IDS_TROUBLESHOOTER_WINME        803
#define IDS_TROUBLESHOOTER_WIN2K        804
#define IDS_TSSUBINFO_WIN98SE           805
#define IDS_TSSUBINFO_WINME_HCP         806
#define IDS_TSSUBINFO_WIN2K             807
#define IDS_TSSOUNDSUBINFO_WIN98SE      808
#define IDS_TSSOUNDSUBINFO_WINME_HCP    809
#define IDS_TSSOUNDSUBINFO_WIN2K        810
#define IDS_TROUBLESHOOTER_WINME_HCP    811
#define IDS_DXGRAPHICS_COMPONENTFILES   812
#define IDS_DPLAY_COMPONENTFILES        813
#define IDS_DINPUT_COMPONENTFILES       814
#define IDS_DXAUDIO_COMPONENTFILES      815
#define IDS_DXMISC_COMPONENTFILES       816
#define IDS_DXMEDIA_COMPONENTFILES      817
#define IDS_DXSETUP_COMPONENTFILES      818
#define IDS_BDA_COMPONENTFILES          819
#define IDNEXT                          1000
#define IDSAVE                          1001
#define IDC_TAB                         1002
#define IDC_LIST                        1003
#define IDC_DRIVERLIST                  1004
#define IDC_NOTES                       1008
#define IDC_TROUBLESHOOT                1010
#define IDC_TESTDD                      1011
#define IDC_TROUBLESHOOTSOUND           1012
#define IDC_TESTSND                     1013
#define IDC_ADAPTER                     1015
#define IDC_MANUFACTURER                1016
#define IDC_CHIPTYPE                    1017
#define IDC_DACTYPE                     1018
#define IDC_DISPLAYMEMORY               1019
#define IDC_DISPLAYMODE                 1022
#define IDC_DDSTATUS                    1024
#define IDC_D3DSTATUS                   1025
#define IDC_DISABLEDD                   1029
#define IDC_DATE                        1030
#define IDC_COMPUTERNAME                1031
#define IDC_OS                          1032
#define IDC_PROCESSOR                   1033
#define IDC_MEMORY                      1034
#define IDC_PAGEFILE                    1035
#define IDC_LANGUAGE                    1036
#define IDC_DISABLED3D                  1037
#define IDC_DIRECTXVERSION              1037
#define IDC_TESTD3D                     1038
#define IDC_VDD                         1039
#define IDC_MINIVDD                     1040
#define IDC_DRIVERVERSION               1041
#define IDC_DRIVERNAME                  1042
#define IDC_TESTAGP                     1043
#define IDC_DESCRIPTION                 1044
#define IDC_REPORTBUG                   1054
#define IDEXIT                          1055
#define IDC_COPYRIGHT                   1056
#define IDC_TROUBLESHOOTTEXT            1057
#define IDC_MSINFO                      1058
#define IDC_MSINFOTEXT                  1059
#define IDC_DRIVERSIGNED                1060
#define IDC_DEFAULTREFRESH              1080
#define IDC_OVERRIDEREFRESH             1081
#define IDC_OVERRIDEREFRESHVALUE        1082
#define IDD_OVERRIDEDD                  1083
#define IDC_OVERRIDE                    1084
#define IDD_NETWORKPAGE                 1084
#define IDC_APPHELP                     1085
#define IDC_REPORTBUGTEXT               1086
#define IDC_GMPATH                      1087
#define IDC_GHOSTTEXT                   1087
#define IDC_TESTMUSIC                   1088
#define IDC_PORTLISTCOMBO               1091
#define IDC_MONITOR                     1092
#define IDC_DEVICEID                    1093
#define IDC_DEVICETYPE                  1094
#define IDC_MANUFACTURERID              1095
#define IDC_PRODUCTID                   1096
#define IDC_OTHERFILES                  1097
#define IDC_PROVIDER                    1098
#define IDC_RESTOREDRIVERS              1099
#define IDC_RESTOREDRIVERSTEXT          1100
#define IDC_DPSPLIST                    1104
#define IDC_DPALIST                     1105
#define IDC_TESTPLAY                    1106
#define IDC_PLAYERNAME                  1107
#define IDC_SPLIST                      1108
#define IDC_CREATESESSION               1109
#define IDC_JOINSESSION                 1110
#define IDC_SESSIONLIST                 1111
#define IDC_CHATOUTPUT                  1112
#define IDC_CHATINPUT                   1113
#define IDC_SEND                        1114
#define IDC_SESSIONNAME                 1115
#define IDC_SNDACCELSLIDER              1116
#define IDC_SNDACCELDESC                1117
#define IDC_SNDACCELLABEL               1118
#define IDC_TROUBLESHOOTSOUNDTEXT       1119
#define IDC_DISABLEAGP                  1120
#define IDC_AGPSTATUS                   1121
#define IDC_DISABLEDM                   1122
#define IDC_DMSTATUS                    1123
#define IDC_GHOST                       1124
#define IDC_BACKUP                      1127
#define IDC_RESTORE                     1128
#define IDC_BACKEDUPLIST                1129
#define IDC_RESTOREDLIST                1130
#define IDC_NEXT_TAB                    1131
#define IDC_PREV_TAB                    1132
#define IDC_BROWSE                      1137
#define IDC_PATH                        1138
#define IDC_PORT                        1139
#define IDC_PORT_TEXT                   1140
#define IDC_LOAD_PROGRESS               1141
#define IDC_LOADING                     1142

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1144
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MAJORCOMP=
MINORCOMP=

TARGETNAME=dxdiag
TARGETPATH=obj
TARGETTYPE=PROGRAM
UMENTRY=winmain
UMTYPE=windows
UMAPPL=
UMLIBS=

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
            $(SDK_LIB_PATH)\comctl32.lib    \
            $(SDK_LIB_PATH)\winmm.lib       \
            $(SDK_LIB_PATH)\comdlg32.lib    \
            $(SDK_LIB_PATH)\version.lib     \
            $(SDK_LIB_PATH)\shell32.lib     \
            $(SDK_LIB_PATH)\ole32.lib       \
            $(SDK_LIB_PATH)\uuid.lib        \
            $(SDK_LIB_PATH)\oleaut32.lib    \
            $(SDK_LIB_PATH)\dplayx.lib      \
            $(SDK_LIB_PATH)\d3dx8.lib       \
            $(SDK_LIB_PATH)\wbemuuid.lib    \
            $(SDK_LIB_PATH)\strmbase.lib    \

INCLUDES=$(DXROOT)\inc; \
         $(SDK_INC_PATH); \
         $(SDK_INC_PATH)\mfc42;

SOURCES=..\dispinfo.cpp \
        ..\dispinfo8.cpp \
        ..\fileinfo.cpp \
        ..\inptinfo.cpp \
        ..\netinfo.cpp \
        ..\ghost.cpp \
        ..\guids.cpp \
        ..\main.cpp \
        ..\save.cpp \
        ..\dsprvobj.cpp \
        ..\sndinfo.cpp \
        ..\sndinfo7.cpp \
        ..\musinfo.cpp \
        ..\showinfo.cpp \
        ..\sysinfo.cpp \
        ..\reginfo.cpp \
        ..\testdd.cpp \
        ..\testagp.cpp \
        ..\testd3d8.cpp \
        ..\testsnd.cpp \
        ..\testmus.cpp \
        ..\testnet.cpp \
        ..\$(TARGETNAME).rc 

MISCFILES=..\dxdiag.chm

USE_LIBCMT=1

# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.DxDiag
SXS_ASSEMBLY_VERSION=1.0 
#uncomment one of these lines, or put in a similar line
SXS_ASSEMBLY_LANGUAGE=en-us
#SXS_ASSEMBLY_LANGUAGE=en
#SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=DxDiag.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\sndinfo7.cpp ===
/****************************************************************************
 *
 *    File: sndinfo7.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather DX7-specific sound information
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#define DIRECTSOUND_VERSION  0x0700 // <-- note difference from sndinfo.cpp
#include <tchar.h>
#include <Windows.h>
#include <mmsystem.h>
#include <dsound.h>
#include "dsprv.h"

static HRESULT PrvGetDeviceDescription7
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA *ppData
);

static HRESULT PrvReleaseDeviceDescription7
( 
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pData 
);


/****************************************************************************
 *
 *  GetRegKey
 *
 ****************************************************************************/
HRESULT GetRegKey(LPKSPROPERTYSET pKSPS7, REFGUID guidDeviceID, TCHAR* pszRegKey)
{
    HRESULT hr;
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pdsddd;
    TCHAR szInterface[200];
    TCHAR* pchSrc;
    TCHAR* pchDest;

    if (FAILED(hr = PrvGetDeviceDescription7(pKSPS7, guidDeviceID, &pdsddd)))
        return hr;

    if (pdsddd->Interface == NULL) // This seems to always be the case on Win9x
    {
        lstrcpy(pszRegKey, TEXT(""));
        PrvReleaseDeviceDescription7( pdsddd );
        return E_FAIL;
    }

    lstrcpy(szInterface, pdsddd->Interface);

    PrvReleaseDeviceDescription7( pdsddd );
    pdsddd = NULL;

    if( lstrlen(szInterface) > 5 && 
        lstrlen(szInterface) < 200 )
    {
        pchSrc = szInterface + 4; // skip "\\?\"
        pchDest = pszRegKey;
        while (TRUE)
        {
            *pchDest = *pchSrc;
            if (*pchDest == TEXT('#')) // Convert "#" to "\"
                *pchDest = TEXT('\\');
            if (*pchDest == TEXT('{')) // End if "{" found
                *pchDest = TEXT('\0');
            if (*pchDest == TEXT('\0'))
                break;
            pchDest++;
            pchSrc++;
        }

        if( lstrlen(pszRegKey) > 1 )
        {
            if (*(pchDest-1) == TEXT('\\')) // Remove final "\"
                *(pchDest-1) = TEXT('\0');
        }
    }

    return S_OK;
}

// The following function is identical to the one defined in dsprvobj.cpp,
// except it is defined with DIRECTSOUND_VERSION at 0x0700, so you get more
// description data (namely the Interface string).
/***************************************************************************
 *
 *  PrvGetDeviceDescription7
 *
 *  Description:
 *      Gets the extended description for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device id.
 *      PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA [out]: receives
 *                                                            description.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

static HRESULT PrvGetDeviceDescription7
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA *ppData
)
{
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA  pData = NULL;
    ULONG                                           cbData;
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA   Basic;
    HRESULT                                         hr;

    Basic.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
            NULL,
            0,
            &Basic,
            sizeof(Basic),
            &cbData
        );

    if(SUCCEEDED(hr))
    {
        pData = (PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA)new BYTE [cbData];

        if(!pData)
        {
            hr = DSERR_OUTOFMEMORY;
        }
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(pData, cbData);

        pData->DeviceId = guidDeviceId;
        
        hr =
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundDevice,
                DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
                NULL,
                0,
                pData,
                cbData,
                NULL
            );
    }

    if(SUCCEEDED(hr))
    {
        *ppData = pData;
    }
    else if(pData)
    {
        delete[] pData;
    }

    return hr;
}




/***************************************************************************
 *
 *  PrvReleaseDeviceDescription7
 *
 ***************************************************************************/
HRESULT PrvReleaseDeviceDescription7( PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pData )
{
    delete[] pData;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\sysinfo.h ===
/****************************************************************************
 *
 *    File: sysinfo.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Gather system information (OS, hardware, name, etc.) on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef SYSINFO_H
#define SYSINFO_H

// DXD_IN_SI_VALUE is the name of a value stored under the registry key 
// HKLM\DXD_IN_SI_KEY that indicates that DxDiag is using
// sysinfo.  If DxDiag starts up and this value exists, DxDiag 
// probably crashed in sysinfo and DxDiag should offer to run without
// using sysinfo.
#define DXD_IN_SI_KEY TEXT("Software\\Microsoft\\DirectX Diagnostic Tool")
#define DXD_IN_SI_VALUE TEXT("DxDiag In SystemInfo")

struct SysInfo
{
    SYSTEMTIME m_time;
    TCHAR m_szTimeLocal[100];  // Date/time, localized for UI
    TCHAR m_szTime[100]; // Date/time, dd/mm/yyyy hh:mm:ss for saved report
    TCHAR m_szMachine[200];
    DWORD m_dwMajorVersion;
    DWORD m_dwMinorVersion;
    DWORD m_dwBuildNumber;
    TCHAR m_szBuildLab[100];
    DWORD m_dwPlatformID;
    TCHAR m_szCSDVersion[200];
    TCHAR m_szDirectXVersion[100];
    TCHAR m_szDirectXVersionLong[100];
    DWORD m_dwDirectXVersionMajor;
    DWORD m_dwDirectXVersionMinor;
    TCHAR m_cDirectXVersionLetter;
    TCHAR m_szDxDiagVersion[100];
    DWORD m_dwSetupParam;
    TCHAR m_szSetupParam[100];
    BOOL m_bDebug;
    BOOL m_bNECPC98;
    TCHAR m_szOS[100]; // Formatted version of platform
    TCHAR m_szOSEx[100]; // Formatted version of platform, version, build num
    TCHAR m_szOSExLong[300]; // Formatted version of platform, version, build num, patch, lab
    TCHAR m_szProcessor[200];
    TCHAR m_szSystemManufacturerEnglish[200];
    TCHAR m_szSystemModelEnglish[200];
    TCHAR m_szBIOSEnglish[200];
    TCHAR m_szLanguages[200]; // Formatted version of m_szLanguage, m_szLanguageRegional
    TCHAR m_szLanguagesLocal[200]; // m_szLanguages, in local language
    DWORDLONG m_ullPhysicalMemory;
    TCHAR m_szPhysicalMemory[100]; // Formatted version of physical memory
    DWORDLONG m_ullUsedPageFile;
    DWORDLONG m_ullAvailPageFile;
    TCHAR m_szPageFile[100]; // Formatted version of pagefile
    TCHAR m_szPageFileEnglish[100]; // Formatted version of pagefile
    TCHAR m_szD3D8CacheFileSystem[MAX_PATH];
    BOOL  m_bNetMeetingRunning;

    TCHAR m_szDXFileNotes[3000]; 
    TCHAR m_szMusicNotes[3000]; 
    TCHAR m_szInputNotes[3000]; 
    TCHAR m_szNetworkNotes[3000]; 

    TCHAR m_szDXFileNotesEnglish[3000]; 
    TCHAR m_szMusicNotesEnglish[3000]; 
    TCHAR m_szInputNotesEnglish[3000]; 
    TCHAR m_szNetworkNotesEnglish[3000]; 

    BOOL m_bIsD3D8DebugRuntimeAvailable;
    BOOL m_bIsD3DDebugRuntime;
    BOOL m_bIsDInput8DebugRuntimeAvailable;
    BOOL m_bIsDInput8DebugRuntime;
    BOOL m_bIsDMusicDebugRuntimeAvailable;
    BOOL m_bIsDMusicDebugRuntime;
    BOOL m_bIsDDrawDebugRuntime;
    BOOL m_bIsDPlayDebugRuntime;
    BOOL m_bIsDSoundDebugRuntime;

    int m_nD3DDebugLevel;
    int m_nDDrawDebugLevel;
    int m_nDIDebugLevel;
    int m_nDMusicDebugLevel;
    int m_nDPlayDebugLevel;
    int m_nDSoundDebugLevel;

};

BOOL BIsPlatformNT(VOID);  // Is this a NT codebase?
BOOL BIsPlatform9x(VOID);  // Is this a Win9x codebase?

BOOL BIsWinNT(VOID);  // Is this WinNT v4 (or less)
BOOL BIsWin2k(VOID);  // Is this Win2k?
BOOL BIsWinME(VOID);  // Is this WinME?
BOOL BIsWhistler(VOID);  // Is this Whistler?
BOOL BIsWin98(VOID);  // Is this Win98?
BOOL BIsWin95(VOID);  // Is this Win95?
BOOL BIsWin3x(VOID);  // Is this Win3.x?
BOOL BIsIA64(VOID);   // Is this IA64?

BOOL BIsDxDiag64Bit(VOID); // Is this DxDiag.exe 64bit?

VOID GetSystemInfo(SysInfo* pSysInfo);
VOID GetDXDebugLevel(SysInfo* pSysInfo);

int DXUtil_strcmpi( TCHAR* str1, TCHAR* str2 );

#endif // SYSINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\testagp.h ===
/****************************************************************************
 *
 *    File: testagp.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Jason Sandlin (jasonsa@microsoft.com)
 * Purpose: Test AGP Texturing functionality on this machine
 *
 * (C) Copyright 2000 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef TESTAGP_H
#define TESTAGP_H

VOID TestD3Dv7(BOOL bUseTexture, HWND hwndMain, DisplayInfo* pDisplayInfo);


#endif // TESTAGP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\sysinfo.cpp ===
/****************************************************************************
 *
 *    File: sysinfo.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 *          CPU type detection code by Rich Granshaw
 *          CPU speed code by Michael Lyons
 * Purpose: Gather system information (OS, hardware, name, etc.) on this machine
 *
 *          \Multimedia\Testsrc\Tools\ShowCPUID\ can be used to debug CPUID problems.
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <tchar.h>
#include <Windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <wbemidl.h>
#include <objbase.h>
#include <shfolder.h>
#include <dsound.h>
#include "dsprv.h"
#include "dsprvobj.h"
#include "sysinfo.h"
#include "fileinfo.h" // for GetLanguageFromFile
#include "resource.h"


#define REGSTR_PATH_D3D                     TEXT("Software\\Microsoft\\Direct3D")
#define REGSTR_VAL_DDRAW_LOADDEBUGRUNTIME   TEXT("LoadDebugRuntime")
#define REGSTR_DINPUT_DLL                   TEXT("CLSID\\{25E609E4-B259-11CF-BFC7-444553540000}\\InProcServer32")
#define REGSTR_DMUSIC_DLL                   TEXT("CLSID\\{480FF4B0-28B2-11D1-BEF7-00C04FBF8FEF}\\InProcServer32")

struct PROCESSOR_ID_NUMBERS
{
    DWORD dwType;         // Intel: 0 = standard, 1 = Overdrive, 2 = dual processor.
    DWORD dwFamily;       
    DWORD dwModel;
    DWORD dwSteppingID;
};

extern IWbemServices* g_pIWbemServices;
typedef INT (WINAPI* LPDXSETUPGETVERSION)(DWORD* pdwVersion, DWORD* pdwRevision);
static VOID GetProcessorDescription(BOOL bNT, SYSTEM_INFO* psi, TCHAR* pszDesc, BOOL* pbNoCPUSpeed);
static VOID GetProcessorVendorNameAndType(OSVERSIONINFO& OSVersionInfo, 
    SYSTEM_INFO& SystemInfo, TCHAR* pszProcessor, BOOL* pbNoCPUSpeed);
static VOID GetVendorNameAndCaps(TCHAR* pszVendorName, TCHAR* pszIDTLongName, 
    PROCESSOR_ID_NUMBERS& ProcessorIdNumbers, BOOL* pbIsMMX, BOOL* pbIs3DNow, BOOL* pbIsKatmai, /*Pentium III/Streaming SIMD Instrucs*/
    LPDWORD pdwKBytesLevel2Cache, LPDWORD pdwIntelBrandIndex, BOOL* pbNoCPUSpeed);
#ifdef _X86_
static INT GetCPUSpeed(VOID);
static INT GetCPUSpeedViaWMI(VOID);
#endif
static VOID GetComputerSystemInfo(TCHAR* szSystemManufacturerEnglish, TCHAR* szSystemModelEnglish);
static VOID GetBIOSInfo(TCHAR* szBIOSEnglish);
static VOID GetFileSystemStoringD3D8Cache( TCHAR* strFileSystemBuffer );

static VOID GetDXDebugLevels(SysInfo* pSysInfo);
static int  GetDSDebugLevel();
static BOOL IsDMusicDebugRuntime();
static BOOL IsDMusicDebugRuntimeAvailable();
static int  GetDMDebugLevel();
static BOOL IsDInput8DebugRuntime();
static BOOL IsDInput8DebugRuntimeAvailable();
static int  GetDIDebugLevel();
static BOOL IsD3DDebugRuntime();
static BOOL IsD3D8DebugRuntimeAvailable();
static BOOL IsDDrawDebugRuntime();
static BOOL IsDPlayDebugRuntime();
static BOOL IsDSoundDebugRuntime();
static BOOL IsNetMeetingRunning();




/****************************************************************************
 *
 *  BIsPlatformNT
 *
 ****************************************************************************/
BOOL BIsPlatformNT(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
}


/****************************************************************************
 *
 *  BIsPlatform9x
 *
 ****************************************************************************/
BOOL BIsPlatform9x(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
}


/****************************************************************************
 *
 *  BIsWin2k
 *
 ****************************************************************************/
BOOL BIsWin2k(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return ( OSVersionInfo.dwPlatformId   == VER_PLATFORM_WIN32_NT && 
             OSVersionInfo.dwMajorVersion == 5 &&
             OSVersionInfo.dwMinorVersion == 0 ); // should be 05.00.xxxx
}


/****************************************************************************
 *
 *  BIsWhistler
 *
 ****************************************************************************/
BOOL BIsWhistler(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return ( OSVersionInfo.dwPlatformId   == VER_PLATFORM_WIN32_NT && 
             OSVersionInfo.dwMajorVersion == 5 &&
             ( OSVersionInfo.dwMinorVersion == 1 || OSVersionInfo.dwMinorVersion == 2 ) ); 
            // should be 05.01.xxxx (for WinXP) or 05.02.xxxx (for .NET server)
}


/****************************************************************************
 *
 *  BIsWinNT
 *
 ****************************************************************************/
BOOL BIsWinNT(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return ( OSVersionInfo.dwPlatformId   == VER_PLATFORM_WIN32_NT && 
             OSVersionInfo.dwMajorVersion <= 4 ); 
}


/****************************************************************************
 *
 *  BIsWinME
 *
 ****************************************************************************/
BOOL BIsWinME(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return( OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && 
            OSVersionInfo.dwMajorVersion >= 4 && 
            OSVersionInfo.dwMinorVersion >= 90 ); // should be 4.90.xxxx
}


/****************************************************************************
 *
 *  BIsWin98 - from http://kbinternal/kb/articles/q189/2/49.htm
 *
 ****************************************************************************/
BOOL BIsWin98(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return( OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && 
            OSVersionInfo.dwMajorVersion == 4 && 
            OSVersionInfo.dwMinorVersion == 10 ); // should be 4.10.xxxx
}


/****************************************************************************
 *
 *  BIsWin95 - from http://kbinternal/kb/articles/q189/2/49.htm
 *
 ****************************************************************************/
BOOL BIsWin95(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return( OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && 
            OSVersionInfo.dwMajorVersion == 4 && 
            OSVersionInfo.dwMinorVersion < 10 ); // should be 4.00.0950
}


/****************************************************************************
 *
 *  BIsWin3x 
 *
 ****************************************************************************/
BOOL BIsWin3x(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    return( OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && 
            OSVersionInfo.dwMajorVersion < 4 ); // should be 3.xx.xxxx
}


/****************************************************************************
 *
 *  BIsIA64 
 *
 ****************************************************************************/
BOOL BIsIA64(VOID)
{
    OSVERSIONINFO OSVersionInfo;
    SYSTEM_INFO SystemInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    GetSystemInfo(&SystemInfo);

    return( OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT && 
            SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 );
}


/****************************************************************************
 *
 *  GetSystemInfo
 *
 ****************************************************************************/
VOID GetSystemInfo(SysInfo* pSysInfo)
{
    TCHAR szSystemPath[MAX_PATH];
    HKEY hKey = NULL;
    HKEY hSubKey = NULL;
    ULONG ulType;
    OSVERSIONINFO OSVersionInfo;
    SYSTEM_INFO SystemInfo;
    DWORD cbData;
    LCID lcid;
    DWORD dwKeyboardSubType;
    WORD wLanguage;
    TCHAR sz[200];
    TCHAR szDebug[100];

    // Get current time
    TCHAR szDate[100];
    TCHAR szTime[100];
    GetLocalTime(&pSysInfo->m_time);
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE, NULL, NULL, szDate, 100);
    wsprintf(szTime, TEXT("%02d:%02d:%02d"), pSysInfo->m_time.wHour, 
        pSysInfo->m_time.wMinute, pSysInfo->m_time.wSecond);
    wsprintf(pSysInfo->m_szTimeLocal, TEXT("%s, %s"), szDate, szTime);

    wsprintf(szDate, TEXT("%d/%d/%d"), pSysInfo->m_time.wMonth, pSysInfo->m_time.wDay, pSysInfo->m_time.wYear);
    wsprintf(pSysInfo->m_szTime, TEXT("%s, %s"), szDate, szTime);

    // Get the computer network name
    cbData = sizeof(pSysInfo->m_szMachine) - 1;
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"), 0, KEY_READ, &hKey)
        && !RegQueryValueEx(hKey, TEXT("ComputerName"), 0, &ulType, (LPBYTE)pSysInfo->m_szMachine, &cbData)
        && ulType == REG_SZ)
    {
        // Got data OK.
    }
    else
    {
        LoadString(NULL, IDS_NOMACHINENAME, pSysInfo->m_szMachine, 200);
    }
    if (hKey)
    {
        RegCloseKey(hKey);
        hKey = 0;
    }

    // Check for NEC PC-98
    pSysInfo->m_bNECPC98 = FALSE;
    lcid = GetSystemDefaultLCID();
    if (lcid == 0x0411)                         // Windows 95 J 
    {
        dwKeyboardSubType = GetKeyboardType(1);
        if (HIBYTE(dwKeyboardSubType) == 0x0D)  // NEC PC-98 series
        {
            pSysInfo->m_bNECPC98 = TRUE;
            LoadString(NULL, IDS_NECPC98, sz, 200);
            lstrcat(pSysInfo->m_szMachine, sz);
        }
    }

    // Get Windows version
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    pSysInfo->m_dwMajorVersion = OSVersionInfo.dwMajorVersion;
    pSysInfo->m_dwMinorVersion = OSVersionInfo.dwMinorVersion;
    pSysInfo->m_dwBuildNumber = OSVersionInfo.dwBuildNumber;
    pSysInfo->m_dwPlatformID = OSVersionInfo.dwPlatformId;
    lstrcpy(pSysInfo->m_szCSDVersion, OSVersionInfo.szCSDVersion);
    pSysInfo->m_bDebug = (GetSystemMetrics(SM_DEBUG) > 0);

    // Get OS Name
    TCHAR* pszWindowsKey;
    if (pSysInfo->m_dwPlatformID == VER_PLATFORM_WIN32_NT)
        pszWindowsKey = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion");
    else
        pszWindowsKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion");
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszWindowsKey, 0, KEY_READ, &hKey))
    {
        cbData = 100;
        RegQueryValueEx(hKey, TEXT("ProductName"), 0, &ulType, (LPBYTE)pSysInfo->m_szOS, &cbData);
        cbData = 100;
        RegQueryValueEx(hKey, TEXT("BuildLab"), 0, &ulType, (LPBYTE)pSysInfo->m_szBuildLab, &cbData);
        RegCloseKey(hKey);
    }
    if (lstrlen(pSysInfo->m_szOS) == 0)
    {
        // it is very strange for ProductName registry info 
        // (see above) to be missing.
        lstrcpy(pSysInfo->m_szOS, TEXT("Windows"));
    }
    if (pSysInfo->m_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        // 25598: Append product type (professional, server, etc)
        OSVERSIONINFOEX osve;
        ZeroMemory(&osve, sizeof(osve));
        osve.dwOSVersionInfoSize = sizeof(osve);
        GetVersionEx((OSVERSIONINFO*)&osve);
        if (osve.wProductType == VER_NT_SERVER && osve.wSuiteMask & VER_SUITE_DATACENTER)
        {
            lstrcat(pSysInfo->m_szOS, TEXT(" "));
            LoadString(NULL, IDS_DATACENTERSERVER, sz, 200);
            lstrcat(pSysInfo->m_szOS, sz);
        }
        else if (osve.wProductType == VER_NT_SERVER && osve.wSuiteMask & VER_SUITE_ENTERPRISE)
        {
            lstrcat(pSysInfo->m_szOS, TEXT(" "));
            LoadString(NULL, IDS_ADVANCEDSERVER, sz, 200);
            lstrcat(pSysInfo->m_szOS, sz);
        }
        else if (osve.wProductType == VER_NT_SERVER && osve.wSuiteMask & VER_SUITE_BLADE)
        {
            lstrcat(pSysInfo->m_szOS, TEXT(" "));
            LoadString(NULL, IDS_WEBSERVER, sz, 200);
            lstrcat(pSysInfo->m_szOS, sz);
        }
        else if (osve.wProductType == VER_NT_SERVER)
        {
            lstrcat(pSysInfo->m_szOS, TEXT(" "));
            LoadString(NULL, IDS_SERVER, sz, 200);
            lstrcat(pSysInfo->m_szOS, sz);
        }
        else if (osve.wProductType == VER_NT_WORKSTATION && (osve.wSuiteMask & VER_SUITE_PERSONAL))
        {
            lstrcat(pSysInfo->m_szOS, TEXT(" "));
            LoadString(NULL, IDS_PERSONAL, sz, 200);
            lstrcat(pSysInfo->m_szOS, sz);
        }
        else if (osve.wProductType == VER_NT_WORKSTATION)
        {
            lstrcat(pSysInfo->m_szOS, TEXT(" "));
            LoadString(NULL, IDS_PROFESSIONAL, sz, 200);
            lstrcat(pSysInfo->m_szOS, sz);
        }
    }

    // Format Windows version
    LoadString(NULL, IDS_WINVERFMT, sz, 200);
    LoadString(NULL, IDS_DEBUG, szDebug, 100);
    lstrcat(szDebug, TEXT(" "));
    wsprintf(pSysInfo->m_szOSEx, sz, 
        pSysInfo->m_bDebug ? szDebug : TEXT(""),
        pSysInfo->m_szOS, pSysInfo->m_dwMajorVersion, pSysInfo->m_dwMinorVersion, 
        LOWORD(pSysInfo->m_dwBuildNumber));

    TCHAR szOSTmp[200];
    if( _tcslen( pSysInfo->m_szCSDVersion) )
        wsprintf( szOSTmp, TEXT("%s %s"), pSysInfo->m_szOSEx, pSysInfo->m_szCSDVersion );
    else
        lstrcpy( szOSTmp, pSysInfo->m_szOSEx );

    if( _tcslen( pSysInfo->m_szBuildLab ) )
        wsprintf( pSysInfo->m_szOSExLong, TEXT("%s (%s)"), szOSTmp, pSysInfo->m_szBuildLab );
    else
        lstrcpy( pSysInfo->m_szOSExLong, szOSTmp );

    // Get the original language. 
    GetSystemDirectory(szSystemPath, MAX_PATH);
    if (wLanguage = GetLanguageFromFile(TEXT("user.exe"), szSystemPath))
    {
        lcid = MAKELCID(wLanguage, SORT_DEFAULT);
    }
    // Get the language and regional setting and store them (in English) for saved file:
    TCHAR szLanguage[200];
    TCHAR szLanguageRegional[200];
    if ((!GetLocaleInfo(lcid, LOCALE_SENGLANGUAGE, szLanguage, 200)))
        szLanguage[0] = '\0';                  
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SENGLANGUAGE, szLanguageRegional, 200))
        szLanguageRegional[0] = '\0';                  
    LoadString(NULL, IDS_LANGUAGEFMT_ENGLISH, sz, 200);
    wsprintf(pSysInfo->m_szLanguages, sz, szLanguage, szLanguageRegional);

    // Now get same info in local language for display:
    if ((!GetLocaleInfo(lcid, LOCALE_SNATIVELANGNAME, szLanguage, 200)))
        szLanguage[0] = '\0';                  
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SNATIVELANGNAME, szLanguageRegional, 200))
        szLanguageRegional[0] = '\0';                  
    LoadString(NULL, IDS_LANGUAGEFMT, sz, 200);
    wsprintf(pSysInfo->m_szLanguagesLocal, sz, szLanguage, szLanguageRegional);

    // Get info about processor manufacturer and type
    BOOL  bNoCPUSpeed = TRUE;
    
    GetSystemInfo(&SystemInfo);
    GetProcessorDescription(pSysInfo->m_dwPlatformID == VER_PLATFORM_WIN32_NT, 
        &SystemInfo, pSysInfo->m_szProcessor, &bNoCPUSpeed);
    GetComputerSystemInfo(pSysInfo->m_szSystemManufacturerEnglish, pSysInfo->m_szSystemModelEnglish);
    GetBIOSInfo(pSysInfo->m_szBIOSEnglish);

#ifdef _X86_
    // Append processor speed, if it can be computed
    if ( bNoCPUSpeed )
    {
        INT iMhz = GetCPUSpeed();
        if (iMhz > 0)
        {
            TCHAR szSpeed[50];
            wsprintf(szSpeed, TEXT(", ~%dMHz"), iMhz);
            lstrcat(pSysInfo->m_szProcessor, szSpeed);
        }
    }
#endif
    
    BOOL bGotMem = FALSE;

    // Get system memory information
    if( BIsPlatformNT() )
    {
        TCHAR szPath[MAX_PATH];
        GetSystemDirectory(szPath, MAX_PATH);
        lstrcat(szPath, TEXT("\\kernel32.dll"));
        HINSTANCE hKernel32 = LoadLibrary(szPath);
        if( hKernel32 != NULL )
        {
            typedef BOOL (WINAPI* PGlobalMemoryStatusEx)(OUT LPMEMORYSTATUSEX lpBuffer);
            PGlobalMemoryStatusEx pGlobalMemoryStatusEx = (PGlobalMemoryStatusEx)GetProcAddress(hKernel32, "GlobalMemoryStatusEx");
            if( pGlobalMemoryStatusEx != NULL )
            {
                MEMORYSTATUSEX MemoryStatus;
                MemoryStatus.dwLength = sizeof(MEMORYSTATUSEX);
                pGlobalMemoryStatusEx(&MemoryStatus);
                pSysInfo->m_ullPhysicalMemory = MemoryStatus.ullTotalPhys;
                pSysInfo->m_ullUsedPageFile = MemoryStatus.ullTotalPageFile - MemoryStatus.ullAvailPageFile;
                pSysInfo->m_ullAvailPageFile = MemoryStatus.ullAvailPageFile;
                bGotMem = TRUE;
            }
            FreeLibrary(hKernel32);
        }
    }

    if( !bGotMem ) // Win9x or LoadLib failed
    {
        MEMORYSTATUS MemoryStatus;
        MemoryStatus.dwLength = sizeof MemoryStatus;
        GlobalMemoryStatus(&MemoryStatus);
        pSysInfo->m_ullPhysicalMemory = MemoryStatus.dwTotalPhys;
        pSysInfo->m_ullUsedPageFile = MemoryStatus.dwTotalPageFile - MemoryStatus.dwAvailPageFile;
        pSysInfo->m_ullAvailPageFile = MemoryStatus.dwAvailPageFile;
    }

    // Format memory information:
    DWORDLONG dwMB = (DWORDLONG)(pSysInfo->m_ullPhysicalMemory >> 20);
    dwMB += dwMB % 2; // round up to even number
    _stprintf(pSysInfo->m_szPhysicalMemory, TEXT("%I64dMB RAM"), dwMB);
    
    DWORDLONG dwUsedMB  = (pSysInfo->m_ullUsedPageFile >> 20);
    DWORDLONG dwAvailMB = (pSysInfo->m_ullAvailPageFile >> 20);

    LoadString(NULL, IDS_PAGEFILEFMT, sz, 200);
    _stprintf(pSysInfo->m_szPageFile, sz, dwUsedMB, dwAvailMB);

    LoadString(NULL, IDS_PAGEFILEFMT_ENGLISH, sz, 200);
    _stprintf(pSysInfo->m_szPageFileEnglish, sz, dwUsedMB, dwAvailMB);

    // Get DxDiag version:
    TCHAR szFile[MAX_PATH];
    if (0 != GetModuleFileName(NULL, szFile, MAX_PATH))
        GetFileVersion(szFile, pSysInfo->m_szDxDiagVersion, NULL, NULL, NULL, NULL);
    
    // Get DirectX Version using dsetup.dll
    TCHAR szSetupPath[MAX_PATH];
    HINSTANCE hInstDSetup;
    LPDXSETUPGETVERSION pDXSGetVersion;
    BOOL bFound = FALSE;
    LoadString(NULL, IDS_NOTFOUND, pSysInfo->m_szDirectXVersionLong, 100);

    if (!BIsPlatformNT() && GetDxSetupFolder(szSetupPath))
    {
        lstrcat(szSetupPath, TEXT("\\dsetup.dll"));
        hInstDSetup = LoadLibrary(szSetupPath);
        if (hInstDSetup != NULL)
        {
            pDXSGetVersion = (LPDXSETUPGETVERSION)GetProcAddress(hInstDSetup, 
                "DirectXSetupGetVersion");
            if (pDXSGetVersion != NULL)
            {
                DWORD dwVersion = 0;
                DWORD dwRevision = 0;
                if (pDXSGetVersion(&dwVersion, &dwRevision) != 0)
                {
                    wsprintf(pSysInfo->m_szDirectXVersion, TEXT("%d.%02d.%02d.%04d"),
                        HIWORD(dwVersion), LOWORD(dwVersion),
                        HIWORD(dwRevision), LOWORD(dwRevision));
                    bFound = TRUE;
                }
            }
            FreeLibrary(hInstDSetup);
        }
    }
    if (!bFound)
    {
        // Look in registry for DX version instead
        HKEY hkey;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectX"),
            0, KEY_READ, &hkey))
        {
            cbData = 100;
            RegQueryValueEx(hkey, TEXT("Version"), 0, &ulType, (LPBYTE)pSysInfo->m_szDirectXVersion, &cbData);
            RegCloseKey(hkey);
            if (lstrlen(pSysInfo->m_szDirectXVersion) > 6 && 
                lstrlen(pSysInfo->m_szDirectXVersion) < 20)
            {
                bFound = TRUE;
            }
        }
    }
    if (!bFound && !BIsPlatformNT())
    {
        // Report ddraw.dll version instead 
        // (except on Win2000, where ddraw.dll version is way different from DX version)
        TCHAR szDDrawPath[MAX_PATH];
        GetSystemDirectory(szDDrawPath, MAX_PATH);
        lstrcat(szDDrawPath, TEXT("\\ddraw.dll"));
        GetFileVersion(szDDrawPath, pSysInfo->m_szDirectXVersion, NULL, NULL, NULL);
    }
    if (lstrlen(pSysInfo->m_szDirectXVersion) > 0)
    {
        // Bug 18501: Add "friendly" version of version name
        DWORD dwMajor;
        DWORD dwMinor;
        DWORD dwRevision;
        DWORD dwBuild;
        TCHAR szFriendly[100];
        lstrcpy(szFriendly, TEXT(""));
        if( _stscanf(pSysInfo->m_szDirectXVersion, TEXT("%d.%d.%d.%d"), &dwMajor, &dwMinor, &dwRevision, &dwBuild) != 4 )
        {
            dwMajor = 0;
            dwMinor = 0;
            dwRevision = 0;
            dwBuild = 0;
        }
        wsprintf(pSysInfo->m_szDirectXVersion, TEXT("%d.%02d.%02d.%04d"), dwMajor, dwMinor, dwRevision, dwBuild);
        // According to http://xevious/directx/versions.htm:
        // 4.02.xx.xxxx is DX1
        // 4.03.xx.xxxx is DX2
        // 4.04.xx.xxxx is DX3
        // 4.05.xx.xxxx is DX5
        // 4.06.00.xxxx is DX6
        // 4.06.02.xxxx is DX6.1
        // 4.06.03.xxxx is DX6.1A
        // 4.07.00.xxxx is DX7.0
        // 4.07.01.xxxx is DX7.1
        // Beyond that, who knows...
        pSysInfo->m_dwDirectXVersionMajor = 0;
        pSysInfo->m_dwDirectXVersionMinor = 0;
        pSysInfo->m_cDirectXVersionLetter = TEXT(' ');
        if (dwMajor == 4 && dwMinor == 2)
        {
            lstrcpy(szFriendly, TEXT("DirectX 1"));
            pSysInfo->m_dwDirectXVersionMajor = 1;
        }
        if (dwMajor == 4 && dwMinor == 3)
        {
            lstrcpy(szFriendly, TEXT("DirectX 2"));
            pSysInfo->m_dwDirectXVersionMajor = 2;
        }
        if (dwMajor == 4 && dwMinor == 4)
        {
            lstrcpy(szFriendly, TEXT("DirectX 3"));
            pSysInfo->m_dwDirectXVersionMajor = 3;
        }
        if (dwMajor == 4 && dwMinor == 5)
        {
            lstrcpy(szFriendly, TEXT("DirectX 5"));
            pSysInfo->m_dwDirectXVersionMajor = 5;
        }
        else if (dwMajor == 4 && dwMinor == 6 && dwRevision == 0)
        {
            lstrcpy(szFriendly, TEXT("DirectX 6"));
            pSysInfo->m_dwDirectXVersionMajor = 6;
        }
        else if (dwMajor == 4 && dwMinor == 6 && dwRevision == 2)
        {
            lstrcpy(szFriendly, TEXT("DirectX 6.1"));
            pSysInfo->m_dwDirectXVersionMajor = 6;
            pSysInfo->m_dwDirectXVersionMinor = 1;
        }
        else if (dwMajor == 4 && dwMinor == 6 && dwRevision == 3)
        {
            lstrcpy(szFriendly, TEXT("DirectX 6.1a"));
            pSysInfo->m_dwDirectXVersionMajor = 6;
            pSysInfo->m_dwDirectXVersionMinor = 1;
            pSysInfo->m_cDirectXVersionLetter = TEXT('a');
        }
        else if (dwMajor == 4 && dwMinor == 7 && dwRevision == 0 && dwBuild == 716)
        {
            lstrcpy(szFriendly, TEXT("DirectX 7.0a"));
            pSysInfo->m_dwDirectXVersionMajor = 7;
            pSysInfo->m_cDirectXVersionLetter = TEXT('a');
        }
        else if (dwMajor == 4 && dwMinor == 7 && dwRevision == 0)
        {
            lstrcpy(szFriendly, TEXT("DirectX 7.0"));
            pSysInfo->m_dwDirectXVersionMajor = 7;
        }
        else if (dwMajor == 4 && dwMinor == 7 && dwRevision == 1)
        {
            lstrcpy(szFriendly, TEXT("DirectX 7.1"));
            pSysInfo->m_dwDirectXVersionMajor = 7;
            pSysInfo->m_dwDirectXVersionMinor = 1;
        }
        else if (dwMajor == 4 && dwMinor == 8 && dwRevision == 0 )
        {
            lstrcpy(szFriendly, TEXT("DirectX 8.0"));
            pSysInfo->m_dwDirectXVersionMajor = 8;
        }
        else if (dwMajor == 4 && dwMinor == 8 && dwRevision == 1 )
        {
            lstrcpy(szFriendly, TEXT("DirectX 8.1"));
            pSysInfo->m_dwDirectXVersionMajor = 8;
            pSysInfo->m_dwDirectXVersionMinor = 1;
        }
        else if (dwMajor == 4 && dwMinor == 9 )
        {
            lstrcpy(szFriendly, TEXT("DirectX 9.0"));
            pSysInfo->m_dwDirectXVersionMajor = 9;
            pSysInfo->m_dwDirectXVersionMinor = 0;
        }
        else
        {
            pSysInfo->m_dwDirectXVersionMajor = dwMinor;
            pSysInfo->m_dwDirectXVersionMinor = dwRevision;
        }

        if (lstrlen(szFriendly) > 0)
            wsprintf(pSysInfo->m_szDirectXVersionLong, TEXT("%s (%s)"), szFriendly, pSysInfo->m_szDirectXVersion);
        else
            lstrcpy(pSysInfo->m_szDirectXVersionLong, pSysInfo->m_szDirectXVersion);
    }

    // 24169: Detect setup switches
    pSysInfo->m_dwSetupParam = 0xffffffff;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\DirectX"), 0, KEY_READ, &hKey))
    {
        cbData = sizeof(DWORD);
        RegQueryValueEx(hKey, TEXT("Command"), NULL, &ulType, (BYTE*)&(pSysInfo->m_dwSetupParam), &cbData);
        RegCloseKey(hKey);
    }

    // 48330: add debug level in txt file
    GetDXDebugLevels( pSysInfo );

    switch (pSysInfo->m_dwSetupParam)
    {
    case 0xffffffff: lstrcpy(pSysInfo->m_szSetupParam, TEXT("Not found"));       break;
    case 0:          lstrcpy(pSysInfo->m_szSetupParam, TEXT("None"));            break;
    case 1:          lstrcpy(pSysInfo->m_szSetupParam, TEXT("/Silent"));         break;
    case 2:          lstrcpy(pSysInfo->m_szSetupParam, TEXT("/WindowsUpdate"));  break;
    case 3:          lstrcpy(pSysInfo->m_szSetupParam, TEXT("/PackageInstall")); break;
    case 4:          lstrcpy(pSysInfo->m_szSetupParam, TEXT("/Silent /Reboot")); break;
    case 5:          lstrcpy(pSysInfo->m_szSetupParam, TEXT("/Reboot"));         break;
    default:
        wsprintf(pSysInfo->m_szSetupParam, TEXT("Unknown Switch (%d)"), pSysInfo->m_dwSetupParam);
        break;
    }

    GetFileSystemStoringD3D8Cache( pSysInfo->m_szD3D8CacheFileSystem );

    pSysInfo->m_bNetMeetingRunning = IsNetMeetingRunning();
}


/****************************************************************************
 *
 *  GetProcessorDescription
 *
 ****************************************************************************/
VOID GetProcessorDescription(BOOL bNT, SYSTEM_INFO* psi, TCHAR* pszDesc, BOOL* pbNoCPUSpeed)
{
    OSVERSIONINFO OSVersionInfo;
    SYSTEM_INFO SystemInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof OSVersionInfo;
    GetVersionEx(&OSVersionInfo);
    GetSystemInfo(&SystemInfo);
    GetProcessorVendorNameAndType(OSVersionInfo, SystemInfo, pszDesc, pbNoCPUSpeed);
    if (SystemInfo.dwNumberOfProcessors > 1)
    {
        TCHAR szFmt[100];
        TCHAR szNumProc[100];
        LoadString(NULL, IDS_NUMPROCFMT, szFmt, 100);
        wsprintf(szNumProc, szFmt, SystemInfo.dwNumberOfProcessors);
        lstrcat(pszDesc, szNumProc);
    }
}


/****************************************************************************
 *
 *  GetProcessorVendorNameAndType
 *
 ****************************************************************************/
VOID GetProcessorVendorNameAndType(OSVERSIONINFO& OSVersionInfo, 
    SYSTEM_INFO& SystemInfo, TCHAR* pszProcessor, BOOL* pbNoCPUSpeed)
{
    TCHAR                   szVendorName[50];
    TCHAR                   szLongName[50];
    TCHAR                   szDesc[100];
    BOOL                    bIsMMX = FALSE;
    BOOL                    bIs3DNow = FALSE;
// 10/27/98(RichGr): Intel's Katmai New Instructions (KNI).
    BOOL                    bIsKatmai = FALSE;  /* 2/04/99(RichGr): Pentium III/Streaming SIMD Instrucs*/ 
    PROCESSOR_ID_NUMBERS    ProcessorIdNumbers;
    DWORD                   dwKBytesLevel2Cache;
    DWORD                   dwIntelBrandIndex;

    memset(&szVendorName[0], 0, sizeof szVendorName);
    memset(&szLongName[0], 0, sizeof szLongName);
    memset(&ProcessorIdNumbers, 0, sizeof ProcessorIdNumbers);

//  6/21/99(RichGr): On the Intel, we can now interpret a 1-byte descriptor to give us
//     the size of the Level 2 cache, if present.   
    dwKBytesLevel2Cache = 0;
//  4/26/01(RichGr): On the Intel, we have a new 1-byte index that specifies the brand.
    dwIntelBrandIndex = 0;

    if (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS    // Win9x
        || (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT     // WinNT
            && SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL))
    {
        GetVendorNameAndCaps(szVendorName, szLongName, ProcessorIdNumbers, &bIsMMX, &bIs3DNow,
                             &bIsKatmai, &dwKBytesLevel2Cache, &dwIntelBrandIndex, pbNoCPUSpeed);

        if (szLongName[0])  // Use this if there's anything there.
            lstrcpy(pszProcessor, szLongName);
        else
        {
            lstrcpy(pszProcessor, szVendorName);
            lstrcat(pszProcessor, TEXT(" "));

            if ( !lstrcmp(szVendorName, TEXT("Intel")))
            {
                if (SystemInfo.dwProcessorType == PROCESSOR_INTEL_386)
                    lstrcat(pszProcessor, TEXT("80386"));
                else
                if (SystemInfo.dwProcessorType == PROCESSOR_INTEL_486)
                    lstrcat(pszProcessor, TEXT("80486"));
                else
                if (SystemInfo.dwProcessorType == PROCESSOR_INTEL_PENTIUM)
                {
//  6/21/99(RichGr): A lot of this code is now derived from \\muroc\slm\proj\win\src\shell\cpls\system\sysset.c.
                    switch ( ProcessorIdNumbers.dwFamily )
                    {
// We should, of course, never hit these - they've been dealt with above. 
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            lstrcat(pszProcessor, TEXT("80486"));
                            break;

                        case 5:
                            lstrcat(pszProcessor, TEXT("Pentium"));

                            if ( ProcessorIdNumbers.dwModel == 3 )
                                lstrcat(pszProcessor, TEXT(" Overdrive"));

                            break;

                        case 6:
                            switch ( ProcessorIdNumbers.dwModel )
                            {
                                //
                                //Model 1 and 2 are Pentium Pro
                                //
                                case 0:
                                case 1:
                                case 2:
                                    lstrcat(pszProcessor, TEXT("Pentium Pro"));
                                    break;

                                //
                                //Model 3 and 4 are Pentium II
                                //
                                case 3:
                                case 4:
                                    lstrcat(pszProcessor, TEXT("Pentium II"));
                                    break;

                                //
                                //Model 5 is either Pentium II or Celeron (depending on if the chip
                                //has L2 cache or not)
                                //
                                case 5:
                                    if ( dwKBytesLevel2Cache == 0 )    
                                        //
                                        //No L2 cache so it is a Celeron
                                        //
                                        lstrcat(pszProcessor, TEXT("Celeron"));
                                    else
                                        //
                                        //L2 cache so it is at least a Pentium II.  
                                        //
                                        if ( bIsKatmai )
                                            lstrcat(pszProcessor, TEXT("Pentium III"));
                                        else
                                            lstrcat(pszProcessor, TEXT("Pentium II"));

                                    break;

                                case 6:
                                    if ( dwKBytesLevel2Cache > 128 )    
                                        //
                                        //L2 cache > 128K so it is at least a Pentium II
                                        //
                                        if ( bIsKatmai )
                                            lstrcat(pszProcessor, TEXT("Pentium III"));
                                        else
                                            lstrcat(pszProcessor, TEXT("Pentium II"));
                                    else
                                        //
                                        //L2 cache <= 128K so it is a Celeron
                                        //                                                               
                                        lstrcat(pszProcessor, TEXT("Celeron"));

                                    break;

                                case 7:
                                    lstrcat(pszProcessor, TEXT("Pentium III"));
                                    break;

                                default:
                                    if ( bIsKatmai )
                                    {
                                        //  4/26/01(RichGr): Pentium III Xeons and later have a one-byte Brand Index that we can use.
                                        //     More recent machines have a Brand String as well.
                                        //     see ftp://download.intel.com/design/Pentium4/manuals/24547103.pdf
                                        if (dwIntelBrandIndex == 1)
                                            lstrcat(pszProcessor, TEXT("Celeron"));
                                        else
                                        if (dwIntelBrandIndex == 0 || dwIntelBrandIndex == 2)
                                            lstrcat(pszProcessor, TEXT("Pentium III"));
                                        else
                                        if (dwIntelBrandIndex == 3)
                                            lstrcat(pszProcessor, TEXT("Pentium III Xeon"));
                                        else
                                        if (dwIntelBrandIndex == 8)
                                            lstrcat(pszProcessor, TEXT("Pentium 4"));
                                        else
                                            lstrcat(pszProcessor, TEXT("Pentium"));
                                    }
                                    else
                                        lstrcat(pszProcessor, TEXT("Pentium II"));

                                    break;
                            }

                            break;

                        default:
                            wsprintf( szDesc, TEXT("x86 Family %u Model %u Stepping %u"), ProcessorIdNumbers.dwFamily, ProcessorIdNumbers.dwModel,
                                        ProcessorIdNumbers.dwSteppingID );
                            lstrcat(pszProcessor, szDesc);
                            break;
                    }
                }
            }
            else
            if ( !lstrcmp(szVendorName, TEXT("AMD")))
            {
                if (SystemInfo.dwProcessorType == PROCESSOR_INTEL_486)
                    lstrcat(pszProcessor, TEXT("Am486 or Am5X86"));
                else
                if (SystemInfo.dwProcessorType == PROCESSOR_INTEL_PENTIUM)
                {
                    if (ProcessorIdNumbers.dwFamily == 5)
                    {
                        if (ProcessorIdNumbers.dwModel < 6)
                        {
                            wsprintf(szDesc, TEXT("K5 (Model %d)"), ProcessorIdNumbers.dwModel);
                            lstrcat(pszProcessor, szDesc);
                        }
                        else
                        {
                            lstrcat(pszProcessor, TEXT("K6"));
                        }
                    }
                    else
                    {
                        wsprintf(szDesc, TEXT("K%d (Model %d)"), ProcessorIdNumbers.dwFamily, ProcessorIdNumbers.dwModel);
                        lstrcat(pszProcessor, szDesc);
                    }
                }
            }
            else
            if ( !lstrcmp(szVendorName, TEXT("Cyrix")))
            {
                if (ProcessorIdNumbers.dwFamily == 4)
                {
                    if (ProcessorIdNumbers.dwModel == 4)
                        lstrcat(pszProcessor, TEXT("MediaGX"));
                }
                else
                if (ProcessorIdNumbers.dwFamily == 5)
                {
                    if (ProcessorIdNumbers.dwModel == 2)
                        lstrcat(pszProcessor, TEXT("6x86"));
                    else
                    if (ProcessorIdNumbers.dwModel == 4)
                        lstrcat(pszProcessor, TEXT("GXm"));
                }
                else
                if (ProcessorIdNumbers.dwFamily == 6)
                {
                    lstrcat(pszProcessor, TEXT("6x86MX"));
                }
            }
            else
            if ( !lstrcmp(szVendorName, TEXT("IDT")))
            {
    // 4/21/98(RichGr): There's only 1 chip available at present. 
    // 7/07/98(RichGr): Now there are two chips.
    //    Note: Although the C6 is MMX-compatible, Intel does not allow IDT to display the word "MMX"
    //    in association with the name IDT, so we'll skip that.
    //    See http://www.winchip.com/ for more info. 
                if (ProcessorIdNumbers.dwFamily == 5)
                {
                    if (ProcessorIdNumbers.dwModel == 4)
                        lstrcat(pszProcessor, TEXT("WinChip C6"));
                    else
                    if (ProcessorIdNumbers.dwModel >= 8)   // 7/07/98(RichGr): Assume later models have the same feature.
                        lstrcat(pszProcessor, TEXT("WinChip 2"));
                }
                else
                    lstrcat(pszProcessor, TEXT("WinChip"));
            }
            else
            {
                if (SystemInfo.dwProcessorType == PROCESSOR_INTEL_486)
                    lstrcat(pszProcessor, TEXT("486"));
                else
                if (SystemInfo.dwProcessorType == PROCESSOR_INTEL_PENTIUM)
                {
                    if (ProcessorIdNumbers.dwFamily == 5)
                        lstrcat(pszProcessor, TEXT("P5"));
                    else
                    if (ProcessorIdNumbers.dwFamily == 6)
                        lstrcat(pszProcessor, TEXT("P6"));
                    else
                        lstrcat(pszProcessor, TEXT("P5"));
                }
            }
        }

        if (bIsKatmai
            && !lstrcmp(szVendorName, TEXT("Intel")))
            ;
        else
        {
            if (bIsMMX || bIs3DNow)
                lstrcat(pszProcessor, TEXT(", "));

            if (bIsMMX)
                lstrcat(pszProcessor, TEXT(" MMX"));

            if (bIs3DNow)
            {
                if (bIsMMX)
                    lstrcat(pszProcessor, TEXT(", "));

                lstrcat(pszProcessor, TEXT(" 3DNow"));
            }
        }
    }
    else
    if (OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)        // WinNT
    {
        if (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)
        {
            lstrcpy(pszProcessor, TEXT("IA64 "));
        }
        else
        if (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
        {
            lstrcpy(pszProcessor, TEXT("AMD64 "));
        }
        else
            lstrcpy(pszProcessor, TEXT("Unknown "));
    }
}


/****************************************************************************
 *
 *  GetVendorNameAndCaps
 *
 ****************************************************************************/
VOID GetVendorNameAndCaps(TCHAR* pszVendorName, TCHAR* pszLongName, 
    PROCESSOR_ID_NUMBERS& ProcessorIdNumbers, BOOL* pbIsMMX, BOOL* pbIs3DNow, BOOL* pbIsKatmai, /*Pentium III/Streaming SIMD Instrucs*/
    LPDWORD pdwKBytesLevel2Cache, LPDWORD pdwIntelBrandIndex, BOOL* pbNoCPUSpeed)
{
    CHAR        szVendorLabel[13];
    CHAR        szLongName[50];
    DWORD       dwFamilyModelStep;
    BOOL        bCPUID_works;
    DWORD       dwFeaturesFlags;
    BYTE        byteCacheDescriptors[4] = {0,0,0,0};
    DWORD       dwIntelBrandIndex;
    PCHAR       psz;

    memset(&szVendorLabel[0], 0, sizeof szVendorLabel);
    memset(&szLongName[0], 0, sizeof szLongName);
    dwFamilyModelStep = 0;
    dwFeaturesFlags = 0;
    *pbIsMMX = FALSE;
    *pbIs3DNow = FALSE;
    *pbIsKatmai = FALSE;    /* 2/04/99(RichGr): Pentium III/Streaming SIMD Instrucs*/
    bCPUID_works = FALSE;
    *pdwKBytesLevel2Cache = 0;
    dwIntelBrandIndex = 0;

#ifdef _X86_
// Determine whether CPUID instruction can be executed. 
    __asm
    {
// CPUID trashes lots - save everything.  Also, Retail build makes assumptions about reg values.
        pushad                      

// Load value of flags register into eax.   
        pushfd
        pop     eax

// Save original flags register value in ebx.   
        mov     ebx, eax

// Alter bit 21 and write new value into flags register.    
        xor     eax, 0x00200000
        push    eax
        popfd

// Retrieve the new value of the flags register.    
        pushfd
        pop     eax

// Compare with the original value. 
        xor     eax, ebx

// If the new value is the same as the old, the CPUID instruction cannot    
// be executed.  Most 486s and all Pentium-class processors should be able
// to execute CPUID.
// 4/21/98(RichGr): One Cyrix 6x86 machine in the Apps Lab (AP_LAREDO) can't execute
// CPUID in ring 3, for no apparent reason.  Another similar machine works fine.
        je      done1

        mov     bCPUID_works, 1    // bCPUID_works = TRUE

// Execute CPUID with eax = 0 to get Vendor Label.  
        xor     eax, eax 
        _emit   0x0F                // CPUID
        _emit   0xA2

// Move Vendor Label from regs to string.
        mov     dword ptr[szVendorLabel + 0], ebx
        mov     dword ptr[szVendorLabel + 4], edx
        mov     dword ptr[szVendorLabel + 8], ecx

// Execute CPUID with eax = 1 to pick up Family, Model and Stepping ID, and to check for MMX support.   
        mov     eax, 1 
        _emit   0x0F                // CPUID
        _emit   0xA2

// Save Family/Model/Stepping ID.
        mov     dwFamilyModelStep, eax

//  4/26/01(RichGr): Save Brand Index (new for PIII Xeons and after).  This is the low byte only.
        mov     dwIntelBrandIndex, ebx

//  2/04/99(RichGr): Save Features Flags.
        mov     dwFeaturesFlags, edx

//  6/21/99(RichGr): Execute CPUID with eax == 2 to pick up descriptor for size of Level 2 cache.
        mov     eax, 2 
        _emit   0x0F                // CPUID
        _emit   0xA2

// Save Level 2 cache size descriptor in byte 0, together with 3 other cache descriptors in bytes 1 - 3.
// See \\muroc\slm\proj\win\src\shell\cpls\system\sysset.c and cpuid.asm,
// and Intel Architecture Software Developer's Manual (1997), volume 2, p. 105.
        mov     dword ptr[byteCacheDescriptors], edx

done1:
// Restore everything.
        popad         
    }
#endif  // _X86_

    
    dwIntelBrandIndex &= 0xFF;  
    *pdwIntelBrandIndex = dwIntelBrandIndex;

//  6/21/99(RichGr): The following values were helpfully provided by David Penley(Intel):
/* 40H No L2 Cache
   41H L2 Unified cache: 128K Bytes, 4-way set associative, 32 byte line size
   42H L2 Unified cache: 256K Bytes, 4-way set associative, 32 byte line size
   43H L2 Unified cache: 512K Bytes, 4-way set associative, 32 byte line size
   44H L2 Unified cache: 1M Byte, 4-way set associative, 32 byte line size
   45H L2 Unified cache: 2M Byte, 4-way set associative, 32 byte line size

Updated manuals can be had at... http://developer.intel.com/design/pentiumiii/xeon/manuals/
*/

    if (szVendorLabel[0])
    {
        if ( !strcmp(&szVendorLabel[0], "GenuineIntel"))
        { 
           lstrcpy(pszVendorName, TEXT("Intel"));

            // 4/29/01: This doesn't cover the Pentium 4, but we don't need cache size
            //    for it at present.
            if ( byteCacheDescriptors[0] == 0x40 )
                *pdwKBytesLevel2Cache = 0;
            else
            if ( byteCacheDescriptors[0] == 0x41 )
                *pdwKBytesLevel2Cache = 128;
            else
            if ( byteCacheDescriptors[0] == 0x42 )
                *pdwKBytesLevel2Cache = 256;
            else
            if ( byteCacheDescriptors[0] == 0x43 )
                *pdwKBytesLevel2Cache = 512;
            else
            if ( byteCacheDescriptors[0] == 0x44 )
                *pdwKBytesLevel2Cache = 1024;
            else
            if ( byteCacheDescriptors[0] == 0x45 )
                *pdwKBytesLevel2Cache = 2048;
        }
        else
        if ( !strcmp(&szVendorLabel[0], "AuthenticAMD"))
            lstrcpy(pszVendorName, TEXT("AMD"));
        else
        if ( !strcmp(&szVendorLabel[0], "CyrixInstead"))
            lstrcpy(pszVendorName, TEXT("Cyrix"));
        else
        if ( !strcmp(&szVendorLabel[0], "CentaurHauls"))
            lstrcpy(pszVendorName, TEXT("IDT"));
        else
        {
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0, szVendorLabel, -1, pszVendorName, 50);
#else
            lstrcpy(pszVendorName, szVendorLabel);
#endif
        }
    }
    else
        lstrcpy(pszVendorName, TEXT("Intel"));

    if (dwFamilyModelStep)
    {
        ProcessorIdNumbers.dwType        = (dwFamilyModelStep & 0x00003000) >> 12;        
        ProcessorIdNumbers.dwFamily      = (dwFamilyModelStep & 0x00000F00) >> 8;        
        ProcessorIdNumbers.dwModel       = (dwFamilyModelStep & 0x000000F0) >> 4;        
        ProcessorIdNumbers.dwSteppingID  =  dwFamilyModelStep & 0x0000000F;        
    }

    if (dwFeaturesFlags)
    {
// Check whether MMX is supported.
        if (dwFeaturesFlags & 0x00800000)
            *pbIsMMX = TRUE;

// 2/04/99(RichGr): Check whether Katmai is supported (aka Pentium III/Streaming SIMD Instrucs).
        if ((dwFeaturesFlags & 0x02000000)
            && !lstrcmp(pszVendorName, TEXT("Intel")))
            *pbIsKatmai = TRUE;
    }

// 7/07/98(RichGr): Added for IDT's Long Name feature.
// 9/10/98(RichGr): Attempt this on all processors, and skip if there's nothing there.
#ifdef _X86_
    if (bCPUID_works)
    {
    __asm
      {
// CPUID trashes lots - save everything.  Also, Retail build makes assumptions about reg values.
        pushad                      


// 9/10/98(RichGr): Check for extended CPUID support.
        mov     eax, 0x80000000
        _emit   0x0F                // CPUID
        _emit   0xA2
        cmp     eax, 0x80000001     // Jump if no extended CPUID.
        jb      done2

// Check for AMD's 3DNow feature.  Note: They believe this may be added to other non-AMD CPUs as well.
// Adapted from one of AMD's webpages at: http://www.amd.com/3dsdk/library/macros/amddcpu.html
        mov     eax, 0x80000001 
        _emit   0x0F                // CPUID
        _emit   0xA2
        test    edx, 0x80000000     // Check for 3DNow flag.    
        jz      LongName
        mov     eax, pbIs3DNow
        mov     dword ptr[eax], 1    // bIs3DNow = TRUE

// Execute CPUID with eax = 0x80000002 thru 0x80000004 to get 48-byte Long Name (for instance: "IDT WinChip 2-3D"). 
LongName:
        mov     esi, 0x80000001
        xor     edi, edi
NameLoop:
        inc     esi
        mov     eax,esi
        cmp     eax, 0x80000004
        jg      done2

        _emit   0x0F                // CPUID
        _emit   0xA2

// 9/10/98(RichGr): The first time thru, check that there's valid alphanumeric data.
        cmp     esi, 0x80000002     // First time?
        jg      Move                // If not, skip this test.
        cmp     al, 0x20            // If first character < ' ', skip.
        jl      done2
        cmp     al, 0x7a            // If first character > 'z', skip.
        jg      done2
 
// Move Long Name from regs to string.
Move:
        mov     dword ptr[szLongName + edi + 0x0], eax
        mov     dword ptr[szLongName + edi + 0x4], ebx
        mov     dword ptr[szLongName + edi + 0x8], ecx
        mov     dword ptr[szLongName + edi + 0x0c], edx
        add     edi, 0x10
        jmp     NameLoop

done2:
// Restore everything.
        popad         
      }

      if ( szLongName[0] )
      {
        // Move beyond Intel's leading spaces. 
        for (psz = &szLongName[0]; *psz ==  ' '; psz++);

        if (*psz)
        {
#ifdef UNICODE
          MultiByteToWideChar(CP_ACP, 0, psz, -1, pszLongName, 50);
#else
          strcpy(pszLongName, psz);
#endif
          //  4/29/01(RichGr): Intel Brand Strings show the maximum rated CPU Speed, no need for further detection.
          if ( !lstrcmp(pszVendorName, TEXT("Intel")))
            *pbNoCPUSpeed = FALSE;  
        }
      }
    }
#endif  // _X86_
}


#ifdef _X86_

// Some static variables used by GetCPUSpeed
static int s_milliseconds;
static __int64 s_ticks;

/****************************************************************************
 *
 *  fabs
 *
 ****************************************************************************/
FLOAT inline fabs(FLOAT a)
{
    if (a < 0.0f)
        return -a;
    else
        return a;
}


/****************************************************************************
 *
 *  StartTimingCPU
 *
 ****************************************************************************/
int StartTimingCPU( HANDLE& hProcess, DWORD& oldclass )
{
    //
    // detect ability to get info
    //

    //  4/03/2000(RichGr): The RDTSC instruction is crashing on some older Cyrix machines,
    //     so wrap a __try/__except around everything.
    __try
    { 
        __asm
        {
            pushfd                          ; push extended flags
            pop     eax                     ; store eflags into eax
            mov     ebx, eax                ; save EBX for testing later
            xor     eax, (1<<21)            ; switch bit 21
            push    eax                     ; push eflags
            popfd                           ; pop them again
            pushfd                          ; push extended flags
            pop     eax                     ; store eflags into eax
            cmp     eax, ebx                ; see if bit 21 has changed
            jz      no_cpuid                ; make sure it's now on
        }

        //
        // start timing
        //
        // 10/31/99(RichGr): Bump up the priority to real-time, drawing from ToddLa's code.
        //     See  file:\\pyrex\user\toddla\speed.c
        hProcess = GetCurrentProcess();
        oldclass = GetPriorityClass(hProcess);
        SetPriorityClass(hProcess, REALTIME_PRIORITY_CLASS);
        Sleep(10);

        s_milliseconds = -(int)timeGetTime();

        __asm
        {
            lea     ecx, s_ticks            ; get the offset
            mov     dword ptr [ecx], 0      ; zero the memory
            mov     dword ptr [ecx+4], 0    ;
    //      rdtsc                           ; read time-stamp counter
            __emit 0fh 
            __emit 031h
            sub     [ecx], eax              ; store the negative
            sbb     [ecx+4], edx            ; in the variable
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto no_cpuid;
    }

    return 0;

no_cpuid:
// 10/31/99(RichGr): In case someone changes the code, make sure that the priority is restored
//     to normal if there is an error return.
    if ( hProcess && oldclass )
        SetPriorityClass( hProcess, oldclass );

    return -1;
}


/****************************************************************************
 *
 *  StopTimingCPU
 *
 ****************************************************************************/
void StopTimingCPU( HANDLE& hProcess, DWORD& oldclass )
{
    s_milliseconds      += (int)timeGetTime();

    __asm
    {
        lea     ecx, s_ticks            ; get the offset
//      rdtsc                           ; read time-stamp counter
        __emit 0fh 
        __emit 031h
        add     [ecx], eax              ; add the tick count
        adc     [ecx+4], edx            ;
    }

// 10/31/99(RichGr): Restore the priority to normal.
    if ( hProcess && oldclass )
        SetPriorityClass( hProcess, oldclass );

    return;
}


/****************************************************************************
 *
 *  CalcCPUSpeed
 *
 ****************************************************************************/
INT CalcCPUSpeed(VOID)
{
    //
    // get the actual cpu speed in MHz, and
    // then find the one in the CPU speed list
    // that is closest
    //
    const struct tagCPUSPEEDS
    {
        float   fSpeed;
        int     iSpeed;
    } cpu_speeds[] =
    {
        //
        // valid CPU speeds that are not integrally divisible by
        // 16.67 MHz
        //
        {  60.00f,   60 },
        {  75.00f,   75 },
        {  90.00f,   90 },
        { 120.00f,  120 },
        { 180.00f,  180 },
    };

    //
    // find the closest one
    //
    float   fSpeed=((float)s_ticks)/((float)s_milliseconds*1000.0f);
    int     iSpeed=cpu_speeds[0].iSpeed;
    float   fDiff=(float)fabs(fSpeed-cpu_speeds[0].fSpeed);

    for (int i=1 ; i<sizeof(cpu_speeds)/sizeof(cpu_speeds[0]) ; i++)
    {
        float fTmpDiff = (float)fabs(fSpeed-cpu_speeds[i].fSpeed);

        if (fTmpDiff < fDiff)
        {
            iSpeed=cpu_speeds[i].iSpeed;
            fDiff=fTmpDiff;
        }
    }

    //
    // now, calculate the nearest multiple of fIncr
    // speed
    //


    //
    // now, if the closest one is not within one incr, calculate
    // the nearest multiple of fIncr speed and see if that's
    // closer
    //
    const float fIncr=16.66666666666666666666667f;
    const int iIncr=4267; // fIncr << 8

    //if (fDiff > fIncr)
    {
        //
        // get the number of fIncr quantums the speed is
        //
        int     iQuantums       = (int)((fSpeed / fIncr) + 0.5f);
        float   fQuantumSpeed   = (float)iQuantums * fIncr;
        float   fTmpDiff        = (float)fabs(fQuantumSpeed - fSpeed);

        if (fTmpDiff < fDiff)
        {
            iSpeed = (iQuantums * iIncr) >> 8;
            fDiff=fTmpDiff;
        }
    }

    return iSpeed;
}


/****************************************************************************
 *
 *  GetCPUSpeed
 *
 ****************************************************************************/
INT GetCPUSpeed(VOID)
{   
    INT nCPUSpeed;

    // Try first using WMI - may not work on Win9x
    nCPUSpeed = GetCPUSpeedViaWMI();
    if( nCPUSpeed != -1 )
        return nCPUSpeed;
  
    // If WMI fails, then fall back on brute force cpu detection.
#undef  MAX_SAMPLES  
#define MAX_SAMPLES  10

    int     nSpeed = 0, nSpeeds[MAX_SAMPLES] = {0};
    int     nCount = 0, nCounts[MAX_SAMPLES] = {0};
    int     i, j;
    HANDLE  hProcess = NULL;
    DWORD   oldclass = 0;

    // 10/12/99(RichGr): Pick up the most frequently occurring speed in a number of short samples,
    //     instead of waiting once for a whole second (see DxDiag).
    for ( i = 0; i < MAX_SAMPLES; i++ )    
    {
        if ( !StartTimingCPU( hProcess, oldclass ))
        {
            // 10/21/99(RichGr): Sleep() time is important.  On a 266 MHz running Win98 under the kernel
            //     debugger, the original value of Sleep(10) sometimes gave a speed of 283 MHz.
            //     Sleep(5) to Sleep(30) were also unreliable.  Sleep(40) and Sleep(50) looked good,
            //     and I picked (50) for a little margin. 
            Sleep(50);       
            StopTimingCPU( hProcess, oldclass );
            nSpeed = CalcCPUSpeed();

            for ( j = 0; j < MAX_SAMPLES; j++ )
            {    
                if ( nSpeeds[j] == 0 || nSpeed == nSpeeds[j] )  // If the speed matches, increment the count.
                {
                    nSpeeds[j] = nSpeed;
                    nCounts[j]++;
                    break;
                }
            }
        }
    }

    // Find the speed with the biggest count.
    for ( i = j = 0, nCount = 0; i < MAX_SAMPLES; i++ )
    {
        if ( nCounts[i] > nCount )
        {
            nCount = nCounts[i];
            j = i;
        }
    }

    return nSpeeds[j];
}


/****************************************************************************
 *
 *  GetCPUSpeedViaWMI
 *
 ****************************************************************************/
INT GetCPUSpeedViaWMI(VOID)
{
    HRESULT hr;
    INT     nCPUSpeed = -1;

    IEnumWbemClassObject*   pEnumProcessorDevs  = NULL;
    IWbemClassObject*       pProcessorDev       = NULL;
    BSTR                    pClassName          = NULL;
    BSTR                    pPropName           = NULL;
    VARIANT                 var;
    DWORD                   uReturned           = 0;

    ZeroMemory( &var, sizeof(VARIANT) );
    VariantClear( &var );

    if( NULL == g_pIWbemServices )
        return -1;

    pClassName = SysAllocString( L"Win32_Processor" );
    hr = g_pIWbemServices->CreateInstanceEnum( pClassName, 0, NULL,
                                                             &pEnumProcessorDevs ); 
    if( FAILED(hr) || pEnumProcessorDevs == NULL )
        goto LCleanup;

    // Get the first one in the list
    hr = pEnumProcessorDevs->Next( 1000,             // timeout in two seconds
                                   1,                // return just one storage device
                                   &pProcessorDev,   // pointer to storage device
                                   &uReturned );     // number obtained: one or zero
    if( FAILED(hr) || uReturned == 0 || pProcessorDev == NULL )
        goto LCleanup;

    // 298510: MaxClockSpeed on WMI on Whistler & beyond works
    if( BIsWhistler() )
        pPropName = SysAllocString( L"MaxClockSpeed" );
    else
        pPropName = SysAllocString( L"CurrentClockSpeed" );

    hr = pProcessorDev->Get( pPropName, 0L, &var, NULL, NULL );
    if( FAILED(hr) )
        goto LCleanup;

    // Success - record VT_I4 value in nCPUSpeed
    nCPUSpeed = var.lVal;

LCleanup:
    VariantClear( &var );

    if(pPropName)
        SysFreeString(pPropName);
    if(pClassName)
        SysFreeString(pClassName);

    if(pProcessorDev)
        pProcessorDev->Release(); 
    if(pEnumProcessorDevs)
        pEnumProcessorDevs->Release(); 

    // Return either -1 or the CPU speed we found.
    return nCPUSpeed;
}

#endif  // _X86_


/****************************************************************************
 *
 *  GetComputerSystemInfo
 *
 ****************************************************************************/
VOID GetComputerSystemInfo(TCHAR* szSystemManufacturerEnglish, TCHAR* szSystemModelEnglish)
{
    HRESULT hr;

    IEnumWbemClassObject*   pEnumDevices = NULL;
    IWbemClassObject*       pDevice      = NULL;
    BSTR                    pClassName   = NULL;
    BSTR                    pPropName    = NULL;
    DWORD                   uReturned    = 0;
    VARIANT                 var;

    ZeroMemory( &var, sizeof(VARIANT) );
    VariantClear( &var );

    if( NULL == g_pIWbemServices )
        goto LCleanup;

    pClassName = SysAllocString( L"Win32_ComputerSystem" );
    hr = g_pIWbemServices->CreateInstanceEnum( pClassName, 0, NULL,
                                               &pEnumDevices ); 
    if( FAILED(hr) || pEnumDevices == NULL )
        goto LCleanup;

    // Get the first one in the list
    hr = pEnumDevices->Next( 1000,             // timeout in two seconds
                            1,                // return just one storage device
                            &pDevice,          // pointer to storage device
                            &uReturned );     // number obtained: one or zero
    if( FAILED(hr) || uReturned == 0 || pDevice == NULL )
        goto LCleanup;

    pPropName = SysAllocString( L"Manufacturer" );
    hr = pDevice->Get( pPropName, 0L, &var, NULL, NULL );
    if( FAILED(hr) )
        goto LCleanup;
    if(pPropName)
    {
        SysFreeString(pPropName);
        pPropName = NULL;
    }
    if( var.bstrVal != NULL )
    {
#ifdef UNICODE
        _tcsncpy(szSystemManufacturerEnglish, var.bstrVal, 200);
        szSystemManufacturerEnglish[199]=0;
#else
        WideCharToMultiByte(CP_ACP, 0, var.bstrVal, SysStringLen(var.bstrVal), szSystemManufacturerEnglish, 199, NULL, NULL);
#endif
    }
  
    VariantClear( &var );

    pPropName = SysAllocString( L"Model" );
    hr = pDevice->Get( pPropName, 0L, &var, NULL, NULL );
    if( FAILED(hr) )
        goto LCleanup;
    if(pPropName)
    {
        SysFreeString(pPropName);
        pPropName = NULL;
    }
    if( var.bstrVal != NULL )
    {
#ifdef UNICODE
        _tcsncpy(szSystemModelEnglish, var.bstrVal, 200);
        szSystemModelEnglish[199]=0;
#else
        WideCharToMultiByte(CP_ACP, 0, var.bstrVal, SysStringLen(var.bstrVal), szSystemModelEnglish, 199, NULL, NULL);
#endif
    }

    VariantClear( &var );

LCleanup:

    if( lstrlen(szSystemModelEnglish) == 0 )
        lstrcpy( szSystemModelEnglish, TEXT("n/a") );
    if( lstrlen(szSystemManufacturerEnglish) == 0 )
        lstrcpy( szSystemManufacturerEnglish, TEXT("n/a") );

    if(pPropName)
        SysFreeString(pPropName);
    if(pClassName)
        SysFreeString(pClassName);

    if(pDevice)
        pDevice->Release(); 
    if(pEnumDevices)
        pEnumDevices->Release(); 

    return;
}




/****************************************************************************
 *
 *  GetBIOSInfo
 *
 ****************************************************************************/
VOID GetBIOSInfo(TCHAR* szBIOSEnglish)
{
    HRESULT hr;

    IEnumWbemClassObject*   pEnumDevices = NULL;
    IWbemClassObject*       pDevice      = NULL;
    BSTR                    pClassName   = NULL;
    BSTR                    pPropName    = NULL;
    DWORD                   uReturned    = 0;
    VARIANT                 var;

    ZeroMemory( &var, sizeof(VARIANT) );
    VariantClear( &var );

    if( NULL == g_pIWbemServices )
        goto LCleanup;

    pClassName = SysAllocString( L"Win32_BIOS" );
    hr = g_pIWbemServices->CreateInstanceEnum( pClassName, 0, NULL,
                                               &pEnumDevices ); 
    if( FAILED(hr) || pEnumDevices == NULL )
        goto LCleanup;

    // Get the first one in the list
    hr = pEnumDevices->Next( 1000,             // timeout in two seconds
                            1,                // return just one storage device
                            &pDevice,          // pointer to storage device
                            &uReturned );     // number obtained: one or zero
    if( FAILED(hr) || uReturned == 0 || pDevice == NULL )
        goto LCleanup;

    pPropName = SysAllocString( L"Version" );
    hr = pDevice->Get( pPropName, 0L, &var, NULL, NULL );
    if( FAILED(hr) )
        goto LCleanup;
    if( var.bstrVal != NULL )
    {
#ifdef UNICODE
        _tcsncpy(szBIOSEnglish, var.bstrVal, 200);
        szBIOSEnglish[199]=0;
#else
        WideCharToMultiByte(CP_ACP, 0, var.bstrVal, SysStringLen(var.bstrVal), szBIOSEnglish, 199, NULL, NULL);
#endif
    }

    VariantClear( &var );

LCleanup:

    if( lstrlen(szBIOSEnglish) == 0 )
        lstrcpy( szBIOSEnglish, TEXT("n/a") );
 
    if(pPropName)
        SysFreeString(pPropName);
    if(pClassName)
        SysFreeString(pClassName);

    if(pDevice)
        pDevice->Release(); 
    if(pEnumDevices)
        pEnumDevices->Release(); 

    return;
}




/****************************************************************************
 *
 *  GetDXDebugLevels
 *
 ****************************************************************************/
VOID GetDXDebugLevels(SysInfo* pSysInfo)
{
    pSysInfo->m_bIsD3D8DebugRuntimeAvailable      = IsD3D8DebugRuntimeAvailable();
    pSysInfo->m_bIsD3DDebugRuntime                = IsD3DDebugRuntime();
    pSysInfo->m_bIsDInput8DebugRuntimeAvailable   = IsDInput8DebugRuntimeAvailable();
    pSysInfo->m_bIsDInput8DebugRuntime            = IsDInput8DebugRuntime();
    pSysInfo->m_bIsDMusicDebugRuntimeAvailable    = IsDMusicDebugRuntimeAvailable();
    pSysInfo->m_bIsDMusicDebugRuntime             = IsDMusicDebugRuntime();
    pSysInfo->m_bIsDDrawDebugRuntime              = IsDDrawDebugRuntime();
    pSysInfo->m_bIsDPlayDebugRuntime              = IsDPlayDebugRuntime();
    pSysInfo->m_bIsDSoundDebugRuntime             = IsDSoundDebugRuntime();

    pSysInfo->m_nD3DDebugLevel                    = (int) GetProfileInt(TEXT("Direct3D"), TEXT("debug"), 0);
    pSysInfo->m_nDDrawDebugLevel                  = (int) GetProfileInt(TEXT("DirectDraw"),TEXT("debug"), 0);
    pSysInfo->m_nDIDebugLevel                     = GetDIDebugLevel();
    pSysInfo->m_nDMusicDebugLevel                 = GetDMDebugLevel();
    pSysInfo->m_nDPlayDebugLevel                  = (int) GetProfileInt(TEXT("DirectPlay"), TEXT("Debug"), 0);
    pSysInfo->m_nDSoundDebugLevel                 = GetDSDebugLevel();
}




/****************************************************************************
 *
 *  IsD3D8DebugRuntimeAvailable
 *
 ****************************************************************************/
BOOL IsD3D8DebugRuntimeAvailable()
{
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\d3d8d.dll"));

    if (GetFileAttributes(szPath) != -1)
        return TRUE;
    else 
        return FALSE;
}




/****************************************************************************
 *
 *  IsD3DDebugRuntime
 *
 ****************************************************************************/
BOOL IsD3DDebugRuntime()
{
    DWORD   size;
    DWORD   type;
    DWORD   lData;
    HKEY    hkey;
    BOOL    rc;

    rc = FALSE;
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_D3D, 0, KEY_READ, &hkey))
    {
        size = sizeof(DWORD);
        if (!RegQueryValueEx(hkey, REGSTR_VAL_DDRAW_LOADDEBUGRUNTIME, NULL, &type, (LPBYTE)&lData, &size))
            if (lData)
                rc = TRUE;
        RegCloseKey(hkey);
    }
    return rc;
}




/****************************************************************************
 *
 *  GetDIDebugLevel
 *
 ****************************************************************************/
int GetDIDebugLevel()
{
    DWORD dwDebugBits;
    DWORD dwDebugBitsMax;
    LONG iGenerator;

    dwDebugBitsMax = 0;
    dwDebugBits = GetProfileInt(TEXT("Debug"), TEXT("dinput"), 0);
    if (dwDebugBits > dwDebugBitsMax)
        dwDebugBitsMax = dwDebugBits;

    enum 
    {
        GENERATOR_KBD = 0,    
        GENERATOR_MOUSE,
        GENERATOR_JOY,    
        GENERATOR_HID,    
        GENERATOR_MAX
    };

    static TCHAR* szGeneratorNames[] = 
    {
        TEXT("DInput.06"),
        TEXT("DInput.04"),
        TEXT("DInput.08"),
        TEXT("DInput.17"),
    };

    static BOOL bGeneratorArray[4];

    for (iGenerator = 0; iGenerator < GENERATOR_MAX; iGenerator++)
    {
        dwDebugBits = GetProfileInt(TEXT("Debug"), szGeneratorNames[iGenerator], 0);
        bGeneratorArray[iGenerator] = (dwDebugBits > 0);
        if (dwDebugBits > dwDebugBitsMax)
            dwDebugBitsMax = dwDebugBits;
    }

    if (dwDebugBitsMax & 0x20) // verbose
        return 5;
    if (dwDebugBitsMax & 0x02) // function entry
        return 4;
    if (dwDebugBitsMax & 0x01) // trace
        return 3;
    if (dwDebugBitsMax & 0x08) // benign
        return 2;
    if (dwDebugBitsMax & 0x10) // severe
        return 1;
    return 0;
}




/****************************************************************************
 *
 *  IsDInput8DebugRuntimeAvailable
 *
 ****************************************************************************/
BOOL IsDInput8DebugRuntimeAvailable()
{
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dinput8d.dll"));

    if (GetFileAttributes(szPath) != -1)
        return TRUE;
    else 
        return FALSE;
}




/****************************************************************************
 *
 *  IsDInput8DebugRuntime
 *
 ****************************************************************************/
BOOL IsDInput8DebugRuntime()
{
    DWORD   size;
    DWORD   type;
    TCHAR   szData[MAX_PATH];
    HKEY    hkey;
    BOOL    rc;

    rc = FALSE;
    if (!RegOpenKeyEx(HKEY_CLASSES_ROOT, REGSTR_DINPUT_DLL, 0, KEY_READ, &hkey))
    {
        size = sizeof(szData);
        if (!RegQueryValueEx(hkey, NULL, NULL, &type, (LPBYTE)szData, &size))
        {
            if (_tcsstr(szData, TEXT("dinput8d.dll")))
                rc = TRUE;
        }
        RegCloseKey(hkey);
    }
    return rc;
}




/****************************************************************************
 *
 *  GetDMDebugLevel
 *
 ****************************************************************************/
int GetDMDebugLevel()
{
    DWORD dwDMusicDebugLevel = 0;
    DWORD dw;

    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMBAND"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMCOMPOS"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMIME"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMLOADER"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMUSIC"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMUSIC16"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMUSIC32"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMSTYLE"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMSYNTH"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DMSCRIPT"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;
    if ((dw = GetProfileInt( TEXT("Debug"), TEXT("DSWAVE"), 0)) > dwDMusicDebugLevel)
        dwDMusicDebugLevel = dw;

    return dwDMusicDebugLevel;
}




/****************************************************************************
 *
 *  IsDMusicDebugRuntimeAvailable
 *
 ****************************************************************************/
BOOL IsDMusicDebugRuntimeAvailable()
{
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dmusicd.dll"));

    if (GetFileAttributes(szPath) != -1)
        return TRUE;
    else 
        return FALSE;
}




/****************************************************************************
 *
 *  IsDMusicDebugRuntime
 *
 ****************************************************************************/
BOOL IsDMusicDebugRuntime()
{
    DWORD   size;
    DWORD   type;
    TCHAR   szData[MAX_PATH];
    HKEY    hkey;
    BOOL    rc;

    rc = FALSE;
    if (!RegOpenKeyEx(HKEY_CLASSES_ROOT, REGSTR_DMUSIC_DLL, 0, KEY_READ, &hkey))
    {
        size = sizeof(szData);
        if (!RegQueryValueEx(hkey, NULL, NULL, &type, (LPBYTE)szData, &size))
        {
            if (_tcsstr(szData, TEXT("dmusicd.dll")) ||
                _tcsstr(szData, TEXT("DMUSICD.DLL")))
            {
                rc = TRUE;
            }
        }
        RegCloseKey(hkey);
    }
    return rc;
}




/****************************************************************************
 *
 *  GetDSDebugLevel
 *
 ****************************************************************************/
int GetDSDebugLevel()
{
    DWORD dwSoundLevel = 0;

    // Pick up the DMusic DLL debug settings that are controlled on the
    // DSound page
    HRESULT hr;
    HINSTANCE hinst;
    LPKSPROPERTYSET pksps = NULL;
    hinst = LoadLibrary( TEXT("dsound.dll") );
    if (hinst != NULL)
    {
        if (SUCCEEDED(hr = DirectSoundPrivateCreate(&pksps)))
        {
            hr = PrvGetDebugInformation(pksps, NULL, &dwSoundLevel, NULL, NULL);
            pksps->Release();
        }
        FreeLibrary(hinst);
    }

    return dwSoundLevel;
}



/****************************************************************************
 *
 *  IsFileDebug
 *
 ****************************************************************************/
BOOL IsFileDebug( TCHAR* szPath )
{
    UINT cb;
    DWORD dwHandle;
    BYTE FileVersionBuffer[4096];
    VS_FIXEDFILEINFO* pVersion = NULL;

    cb = GetFileVersionInfoSize(szPath, &dwHandle/*ignored*/);
    if (cb > 0)
    {
        if (cb > sizeof(FileVersionBuffer))
            cb = sizeof(FileVersionBuffer);

        if(GetFileVersionInfo(szPath, 0, cb, FileVersionBuffer))
        {
            if(VerQueryValue(FileVersionBuffer, TEXT("\\"), (VOID**)&pVersion, &cb))
            {
                if( pVersion )
                {
                    if( pVersion->dwFileFlags & VS_FF_DEBUG )
                        return TRUE;
                    else 
                        return FALSE;
                }
            }
        }
    }

    return FALSE;
}



/****************************************************************************
 *
 *  IsDDrawDebugRuntime
 *
 ****************************************************************************/
BOOL IsDDrawDebugRuntime()
{
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\ddraw.dll"));

    return IsFileDebug(szPath);
}



/****************************************************************************
 *
 *  IsDPlayDebugRuntime
 *
 ****************************************************************************/
BOOL IsDPlayDebugRuntime()
{
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dpnet.dll"));

    return IsFileDebug(szPath);
}



/****************************************************************************
 *
 *  IsDSoundDebugRuntime
 *
 ****************************************************************************/
BOOL IsDSoundDebugRuntime()
{
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dsound.dll"));

    return IsFileDebug(szPath);
}



/****************************************************************************
 *
 *  BIsDxDiag64Bit
 *
 ****************************************************************************/
BOOL BIsDxDiag64Bit(VOID)
{
#ifdef _WIN64
    return TRUE;
#else
    return FALSE;
#endif
}



/****************************************************************************
 *
 *  GetFileSystemStoringD3D8Cache
 *
 ****************************************************************************/
VOID GetFileSystemStoringD3D8Cache( TCHAR* strFileSystemBuffer )
{
    TCHAR strPath[MAX_PATH + 16];
    BOOL bFound = FALSE;
    
    GetSystemDirectory( strPath, MAX_PATH);   
    lstrcat( strPath, TEXT("\\d3d8caps.dat") );
    
    if (GetFileAttributes(strPath) != 0xffffffff)
        bFound = TRUE;

    if( !bFound && BIsPlatformNT() )
    {
        // stolen from \dxg\d3d8\fw\fcache.cpp, OpenCacheFile().
        HMODULE hShlwapi = NULL;
        typedef HRESULT (WINAPI * PSHGETSPECIALFOLDERPATH) (HWND, LPTSTR, int, BOOL);
        PSHGETSPECIALFOLDERPATH pSHGetSpecialFolderPath = NULL;
        
        hShlwapi = LoadLibrary( TEXT("SHELL32.DLL") );
        if( NULL != hShlwapi )
        {
#ifdef UNICODE
            pSHGetSpecialFolderPath = (PSHGETSPECIALFOLDERPATH) 
                GetProcAddress(hShlwapi,"SHGetSpecialFolderPathW");
#else
            pSHGetSpecialFolderPath = (PSHGETSPECIALFOLDERPATH) 
                GetProcAddress(hShlwapi,"SHGetSpecialFolderPathA");
#endif
            
            if(pSHGetSpecialFolderPath)
            {
                HRESULT hr;

                // <user name>\Local Settings\Applicaiton Data (non roaming)
                hr = pSHGetSpecialFolderPath( NULL, strPath,
                                              CSIDL_LOCAL_APPDATA,          
                                              FALSE );
                if( SUCCEEDED(hr) )
                {
                    lstrcat( strPath, TEXT("\\d3d8caps.dat") );

                    if (GetFileAttributes(strPath) != 0xffffffff)
                        bFound = TRUE;
                }
            }
            FreeLibrary(hShlwapi);
        }
    }

    if( bFound )
    {
        DWORD dwVolumeSerialNumber;
        DWORD dwMaxComponentLength;
        DWORD dwFileSystemFlags;

        // Trim to root dir -- "x:\"
        strPath[3] = 0;

        BOOL bSuccess = GetVolumeInformation( strPath, NULL, 0, &dwVolumeSerialNumber, 
                              &dwMaxComponentLength, &dwFileSystemFlags, 
                              strFileSystemBuffer, MAX_PATH );
        if( !bSuccess )
            lstrcpy( strFileSystemBuffer, TEXT("Unknown") );
    }
    else
    {
        lstrcpy( strFileSystemBuffer, TEXT("n/a") );
    }
    
    return;
}



/****************************************************************************
 *
 *  IsNetMeetingRunning
 *
 ****************************************************************************/
BOOL IsNetMeetingRunning()
{
    HWND hNetMeeting = FindWindow( TEXT("MPWClass"), NULL );

    return( hNetMeeting != NULL );
}




//-----------------------------------------------------------------------------
// Name: DXUtil_strcmpi()
// Desc: compares 2 strings
//-----------------------------------------------------------------------------
int DXUtil_strcmpi( TCHAR* str1, TCHAR* str2 )
{
    int nResult = CompareString( LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, str1, -1, str2, -1 );
    
    if( nResult == CSTR_EQUAL )
        return 0;
    if( nResult == CSTR_LESS_THAN )
        return -1;
    else 
        return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\testd3d8.h ===
/****************************************************************************
 *
 *    File: testd3d8.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Jason Sandlin (jasonsa@microsoft.com)
 * Purpose: Test D3D8/AGP Texturing functionality on this machine
 *
 * (C) Copyright 2000 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef TESTD3D8_H
#define TESTD3D8_H

VOID TestD3Dv8(BOOL bUseTexture, HWND hwndMain, DisplayInfo* pDisplayInfo);


#endif // TESTD3D8_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\testagp.cpp ===
/****************************************************************************
 *
 *    File: testagp.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Jason Sandlin (jasonsa@microsoft.com)
 * Purpose: Test AGP Texturing functionality on this machine
 *
 * (C) Copyright 2000 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <Windows.h>
#define DIRECTDRAW_VERSION 0x0700 // run on DX7 and later versions
#include <ddraw.h>
#define DIRECT3D_VERSION 0x0700 // run on DX7 and later versions
#define D3D_OVERLOADS
#include <d3d.h>
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h"
#include "testagp.h"
#include "resource.h"

#ifndef ReleasePpo
    #define ReleasePpo(ppo) \
        if (*(ppo) != NULL) \
        { \
            (*(ppo))->Release(); \
            *(ppo) = NULL; \
        } \
        else (VOID)0
#endif

enum TESTID
{
    TESTID_LOAD_D3D8_DLL=1,
    TESTID_GET_D3DCREATE8,
    TESTID_D3DCREATE8,
    TESTID_ENUMADAPTERMODES,
    TESTID_GETDEVICECAPS,
    TESTID_NOMODEFOUND,
    TESTID_CREATE_TEST_WINDOW,
    TESTID_CREATE_DEVICE,
    TESTID_GETBACKBUFFER,
    TESTID_GETDESC,
    TESTID_CREATE_VERTEX_BUFFER,
    TESTID_CREATE_INDEX_BUFFER,
    TESTID_LOCK,
    TESTID_UNLOCK,
    TESTID_SETLIGHT,
    TESTID_LIGHTENABLE,
    TESTID_SETTRANSFORM,
    TESTID_SETRENDERSTATE,
    TESTID_CREATETEXTURE,
    TESTID_SETTEXTURESTAGESTATE,
    TESTID_SETTEXTURE,
    TESTID_SETVERTEXSHADER,
    TESTID_USER_CANCELLED,
    TESTID_VIEWPORT_CLEAR,
    TESTID_BEGINSCENE,
    TESTID_SETMATERIAL,
    TESTID_SETSTREAMSOURCE,
    TESTID_SETINDICES,
    TESTID_DRAW_INDEXED_PRIMITIVE,
    TESTID_ENDSCENE,
    TESTID_PRESENT,
    TESTID_USER_VERIFY_D3D7_RENDERING,
    TESTID_USER_VERIFY_D3D8_RENDERING,
    TESTID_LOAD_DDRAW_DLL,
    TESTID_GET_DIRECTDRAWCREATE,
    TESTID_DIRECTDRAWCREATE,
    TESTID_SETCOOPERATIVELEVEL_FULLSCREEN,
    TESTID_SETCOOPERATIVELEVEL_NORMAL,
    TESTID_SETDISPLAYMODE,
    TESTID_CREATEPRIMARYSURFACE_FLIP_ONEBACK,
    TESTID_GETATTACHEDSURFACE,
    TESTID_QUERY_D3D,
    TESTID_SETVIEWPORT,
    TESTID_ENUMTEXTUREFORMATS,
    TESTID_CREATESURFACE,
    TESTID_GETDC,
    TESTID_RELEASEDC,
};

BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish = FALSE); // from main.cpp (yuck)

typedef HRESULT (WINAPI* LPDIRECTDRAWCREATEEX)(GUID FAR * lpGuid, LPVOID *lplpDD, REFIID iid,IUnknown FAR *pUnkOuter );

static HRESULT Test3D(BOOL bUseTexture, HWND hwndMain, LPDIRECTDRAW7 pdd, GUID guid3DDevice, LONG* piStepThatFailed);
static HRESULT CreateTestWindow(HWND hwndMain, HWND* phwnd);
static HRESULT D3DUtil_SetProjectionMatrix( D3DMATRIX& mat, FLOAT fFOV, FLOAT fAspect, FLOAT fNearPlane, FLOAT fFarPlane );

static HRESULT CreateTexture( LPDIRECTDRAWSURFACE7* ppdds, LPDIRECTDRAW7 pdd, LPDIRECT3DDEVICE7 pd3dDevice, TCHAR* strName, LONG* piStepThatFailed);
static HRESULT CALLBACK TextureSearchCallback( DDPIXELFORMAT* pddpf, VOID* param );

/****************************************************************************
 *
 *  TestAGP
 *
 ****************************************************************************/
VOID TestD3Dv7(BOOL bUseTexture, HWND hwndMain, DisplayInfo* pDisplayInfo)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];
    HINSTANCE hInstDDraw = NULL;
    LPDIRECTDRAWCREATEEX pDDCreateEx = NULL;
    LPDIRECTDRAW7 pdd = NULL;
    BOOL bTestHardwareRendering = FALSE;
    TCHAR sz[300];
    TCHAR szTitle[300];

    if( pDisplayInfo == NULL )
        return;

    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);

    // Load ddraw.dll
    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\ddraw.dll"));
    hInstDDraw = LoadLibrary(szPath);
    if (hInstDDraw == NULL)
    {
        pDisplayInfo->m_testResultD3D7.m_iStepThatFailed = TESTID_LOAD_DDRAW_DLL;
        pDisplayInfo->m_testResultD3D7.m_hr = DDERR_NOTFOUND;
        goto LEnd;
    }

    // Get DirectDrawCreate entry point
    pDDCreateEx = (LPDIRECTDRAWCREATEEX)GetProcAddress(hInstDDraw, "DirectDrawCreateEx");
    if (pDDCreateEx == NULL)
    {
        pDisplayInfo->m_testResultD3D7.m_iStepThatFailed = TESTID_GET_DIRECTDRAWCREATE;
        pDisplayInfo->m_testResultD3D7.m_hr = DDERR_NOTFOUND;
        goto LEnd;
    }
        
    // Call DirectDrawCreateEx
    if (FAILED(hr = pDDCreateEx(&pDisplayInfo->m_guid, (void**)&pdd, IID_IDirectDraw7, NULL)))
    {
        pDisplayInfo->m_testResultD3D7.m_iStepThatFailed = TESTID_DIRECTDRAWCREATE;
        pDisplayInfo->m_testResultD3D7.m_hr = hr;
        goto LEnd;
    }

    // Get DirectDraw caps
    DDCAPS ddcapsHAL;
    DDCAPS ddcapsHEL;
    ddcapsHAL.dwSize = sizeof(ddcapsHAL);
    ddcapsHEL.dwSize = sizeof(ddcapsHEL);
    if (FAILED(hr = pdd->GetCaps(&ddcapsHAL, &ddcapsHEL)))
    {
        pDisplayInfo->m_testResultD3D7.m_iStepThatFailed = TESTID_GETDEVICECAPS;
        pDisplayInfo->m_testResultD3D7.m_hr = hr;
        goto LEnd;
    }

    POINT ptMouse;
    GetCursorPos(&ptMouse);
    if (FAILED(hr = Test3D(bUseTexture, hwndMain, pdd, IID_IDirect3DHALDevice, &pDisplayInfo->m_testResultD3D7.m_iStepThatFailed)))
    {
        pDisplayInfo->m_testResultD3D7.m_hr = hr;
        goto LEnd;
    }
    SetCursorPos( ptMouse.x, ptMouse.y );
    ReleasePpo(&pdd);

    if (pDisplayInfo->m_testResultD3D7.m_iStepThatFailed == TESTID_USER_CANCELLED)
    {
        LoadString(NULL, IDS_YOUCANCELLED, sz, 300);
        MessageBox(hwndMain, sz, szTitle, MB_OK);
        pDisplayInfo->m_testResultD3D7.m_bCancelled = TRUE;
        goto LEnd;
    }

    LoadString(NULL, IDS_CONFIRMD3DTEST, sz, 300);
    if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
    {
        pDisplayInfo->m_testResultD3D7.m_iStepThatFailed = TESTID_USER_VERIFY_D3D7_RENDERING;
        pDisplayInfo->m_testResultD3D7.m_hr = S_OK;
        goto LEnd;
    }

LEnd:
    ReleasePpo(&pdd);
    if (hInstDDraw != NULL)
        FreeLibrary(hInstDDraw);
}



/****************************************************************************
 *
 *  Test3D - Generate a spinning 3D cube
 *
 ****************************************************************************/
HRESULT Test3D(BOOL bUseTexture, HWND hwndMain, LPDIRECTDRAW7 pdd, GUID guid3DDevice, LONG* piStepThatFailed)
{
    HRESULT                 hr;
    HWND                    hwnd                    = NULL;
    LPDIRECTDRAWSURFACE7    pddsFront               = NULL;
    LPDIRECTDRAWSURFACE7    pddsBack                = NULL;
    LPDIRECT3D7             pd3d                    = NULL;
    LPDIRECT3DDEVICE7       pd3ddev                 = NULL;
    LPDIRECT3DLIGHT         pLight                  = NULL;
    LPDIRECTDRAWSURFACE7    pddsTexture             = NULL;
    BOOL                    bCooperativeLevelSet    = FALSE;
    BOOL                    bDisplayModeSet         = FALSE;
    DDSURFACEDESC2          ddsd;
    D3DDEVICEDESC7          ddDesc;
    DDSCAPS2                ddscaps;
    D3DVIEWPORT7            vp;
    D3DLIGHT7               lightdata;
    D3DMATRIX               mat;
    D3DMATRIX               matRotY;
    D3DMATRIX               matRotX;
    RECT                    rcBack;
    DWORD                   dwWidth;
    DWORD                   dwHeight;
    FLOAT                   fRotY;
    FLOAT                   fRotX;
    INT                     i;

    static const D3DVERTEX vertexArrayFront[] = 
    {
        D3DVERTEX(D3DVECTOR(-1.0, -1.0, -1.0), D3DVECTOR(0.0, 0.0, -1.0),   1.0f, 0.0f),
        D3DVERTEX(D3DVECTOR( 1.0, -1.0, -1.0), D3DVECTOR(0.0, 0.0, -1.0),   0.0f, 0.0f),
        D3DVERTEX(D3DVECTOR(-1.0,  1.0, -1.0), D3DVECTOR(0.0, 0.0, -1.0),   1.0f, 1.0f),
        D3DVERTEX(D3DVECTOR( 1.0,  1.0, -1.0), D3DVECTOR(0.0, 0.0, -1.0),   0.0f, 1.0f),
    };
    static const WORD indexArrayFront[] = 
    {
        0, 2, 1,
        2, 3, 1,
    };

    static const D3DVERTEX vertexArrayBack[] = 
    {
        D3DVERTEX(D3DVECTOR(-1.0, -1.0, 1.0),  D3DVECTOR(0.0, 0.0, 1.0),   0.0f, 0.0f),
        D3DVERTEX(D3DVECTOR( 1.0, -1.0, 1.0),  D3DVECTOR(0.0, 0.0, 1.0),   1.0f, 0.0f),
        D3DVERTEX(D3DVECTOR(-1.0,  1.0, 1.0),  D3DVECTOR(0.0, 0.0, 1.0),   0.0f, 1.0f),
        D3DVERTEX(D3DVECTOR( 1.0,  1.0, 1.0),  D3DVECTOR(0.0, 0.0, 1.0),   1.0f, 1.0f),
    };
    static const WORD indexArrayBack[] = 
    {
        0, 1, 2,
        2, 1, 3,
    };

    static const D3DVERTEX vertexArrayLeft[] = 
    {
        D3DVERTEX(D3DVECTOR(-1.0, -1.0, -1.0),  D3DVECTOR(-1.0, 0.0, 0.0),   0.0f, 0.0f),
        D3DVERTEX(D3DVECTOR(-1.0, -1.0,  1.0),  D3DVECTOR(-1.0, 0.0, 0.0),   1.0f, 0.0f),
        D3DVERTEX(D3DVECTOR(-1.0,  1.0, -1.0),  D3DVECTOR(-1.0, 0.0, 0.0),   0.0f, 1.0f),
        D3DVERTEX(D3DVECTOR(-1.0,  1.0,  1.0),  D3DVECTOR(-1.0, 0.0, 0.0),   1.0f, 1.0f),
    };
    static const WORD indexArrayLeft[] = 
    {
        0, 1, 2,
        2, 1, 3,
    };

    static const D3DVERTEX vertexArrayRight[] = 
    {
        D3DVERTEX(D3DVECTOR(1.0, -1.0, -1.0),  D3DVECTOR(1.0, 0.0, 0.0),   1.0f, 0.0f),
        D3DVERTEX(D3DVECTOR(1.0, -1.0,  1.0),  D3DVECTOR(1.0, 0.0, 0.0),   0.0f, 0.0f),
        D3DVERTEX(D3DVECTOR(1.0,  1.0, -1.0),  D3DVECTOR(1.0, 0.0, 0.0),   1.0f, 1.0f),
        D3DVERTEX(D3DVECTOR(1.0,  1.0,  1.0),  D3DVECTOR(1.0, 0.0, 0.0),   0.0f, 1.0f),
    };
    static const WORD indexArrayRight[] = 
    {
        0, 2, 1,
        2, 3, 1,
    };

    static const D3DVERTEX vertexArrayTop[] = 
    {
        D3DVERTEX(D3DVECTOR(-1.0, 1.0, -1.0),  D3DVECTOR(0.0, 1.0, 0.0),   0.0f, 1.0f),
        D3DVERTEX(D3DVECTOR( 1.0, 1.0, -1.0),  D3DVECTOR(0.0, 1.0, 0.0),   1.0f, 1.0f),
        D3DVERTEX(D3DVECTOR(-1.0, 1.0,  1.0),  D3DVECTOR(0.0, 1.0, 0.0),   0.0f, 0.0f),
        D3DVERTEX(D3DVECTOR( 1.0, 1.0,  1.0),  D3DVECTOR(0.0, 1.0, 0.0),   1.0f, 0.0f),
    };
    static const WORD indexArrayTop[] = 
    {
        0, 2, 1,
        2, 3, 1,
    };

    static const D3DVERTEX vertexArrayBottom[] = 
    {
        D3DVERTEX(D3DVECTOR(-1.0, -1.0, -1.0),  D3DVECTOR(0.0, -1.0, 0.0),   1.0f, 1.0f),
        D3DVERTEX(D3DVECTOR( 1.0, -1.0, -1.0),  D3DVECTOR(0.0, -1.0, 0.0),   0.0f, 1.0f),
        D3DVERTEX(D3DVECTOR(-1.0, -1.0,  1.0),  D3DVECTOR(0.0, -1.0, 0.0),   1.0f, 0.0f),
        D3DVERTEX(D3DVECTOR( 1.0, -1.0,  1.0),  D3DVECTOR(0.0, -1.0, 0.0),   0.0f, 0.0f),
    };
    static const WORD indexArrayBottom[] = 
    {
        0, 1, 2,
        2, 1, 3,
    };

    D3DMATERIAL7 mtrlRed;
    ZeroMemory( &mtrlRed, sizeof(D3DMATERIAL7) );
    mtrlRed.dcvDiffuse.r = mtrlRed.dcvAmbient.r = 1.0f;
    mtrlRed.dcvDiffuse.g = mtrlRed.dcvAmbient.g = 0.0f;
    mtrlRed.dcvDiffuse.b = mtrlRed.dcvAmbient.b = 0.0f;
    mtrlRed.dcvDiffuse.a = mtrlRed.dcvAmbient.a = 1.0f;

    D3DMATERIAL7 mtrlGreen;
    ZeroMemory( &mtrlGreen, sizeof(D3DMATERIAL7) );
    mtrlGreen.dcvDiffuse.r = mtrlGreen.dcvAmbient.r = 0.0f;
    mtrlGreen.dcvDiffuse.g = mtrlGreen.dcvAmbient.g = 1.0f;
    mtrlGreen.dcvDiffuse.b = mtrlGreen.dcvAmbient.b = 0.0f;
    mtrlGreen.dcvDiffuse.a = mtrlGreen.dcvAmbient.a = 1.0f;

    D3DMATERIAL7 mtrlBlue;
    ZeroMemory( &mtrlBlue, sizeof(D3DMATERIAL7) );
    mtrlBlue.dcvDiffuse.r = mtrlBlue.dcvAmbient.r = 0.0f;
    mtrlBlue.dcvDiffuse.g = mtrlBlue.dcvAmbient.g = 0.0f;
    mtrlBlue.dcvDiffuse.b = mtrlBlue.dcvAmbient.b = 1.0f;
    mtrlBlue.dcvDiffuse.a = mtrlBlue.dcvAmbient.a = 1.0f;

    ShowCursor(FALSE);

    // Create test window
    if (FAILED(hr = CreateTestWindow(hwndMain, &hwnd)))
    {
        *piStepThatFailed = TESTID_CREATE_TEST_WINDOW;
        goto LEnd;
    }

    // Set cooperative level
    if (FAILED(hr = pdd->SetCooperativeLevel(hwnd, 
        DDSCL_ALLOWREBOOT | DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN)))
    {
        *piStepThatFailed = TESTID_SETCOOPERATIVELEVEL_FULLSCREEN;
        goto LEnd;
    }
    bCooperativeLevelSet = TRUE;

    // Set display mode
    if (FAILED(hr = pdd->SetDisplayMode(640, 480, 16, 0, 0)))
    {
        TCHAR szMessage[300];
        TCHAR szTitle[100];
        pdd->SetCooperativeLevel(hwnd, DDSCL_NORMAL);
        bCooperativeLevelSet = FALSE;
        SendMessage(hwnd, WM_CLOSE, 0, 0);
        hwnd = NULL;
        LoadString(NULL, IDS_SETDISPLAYMODEFAILED, szMessage, 300);
        LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);
        MessageBox(hwndMain, szMessage, szTitle, MB_OK);
        *piStepThatFailed = TESTID_SETDISPLAYMODE;
        goto LEnd;
    }
    bDisplayModeSet = TRUE;

    // Create front/back buffers
    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP | 
                          DDSCAPS_COMPLEX | DDSCAPS_3DDEVICE;
    ddsd.dwBackBufferCount = 1;
    if (FAILED(hr = pdd->CreateSurface(&ddsd, &pddsFront, NULL)))
    {
        *piStepThatFailed = TESTID_CREATEPRIMARYSURFACE_FLIP_ONEBACK;
        goto LEnd;
    }
    if( NULL == pddsFront )
    {
        *piStepThatFailed = TESTID_CREATEPRIMARYSURFACE_FLIP_ONEBACK;
        goto LEnd;
    }

    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT;
    if (FAILED(hr = pddsFront->GetSurfaceDesc(&ddsd)))
    {
        *piStepThatFailed = TESTID_GETDESC;
        goto LEnd;
    }
    dwWidth  = ddsd.dwWidth;
    dwHeight = ddsd.dwHeight;
    SetRect(&rcBack, 0, 0, dwWidth, dwHeight);

    // Get ptr to back buffer
    ZeroMemory( &ddscaps, sizeof(ddscaps) ); 
    ddscaps.dwCaps = DDSCAPS_BACKBUFFER;
    if (FAILED(hr = pddsFront->GetAttachedSurface(&ddscaps, &pddsBack)))
    {
        *piStepThatFailed = TESTID_GETATTACHEDSURFACE;
        goto LEnd;
    }
    if( NULL == pddsBack )
    {
        *piStepThatFailed = TESTID_GETATTACHEDSURFACE;
        goto LEnd;
    }

    // Note: no Z-buffer is created...backface culling works for this test
    
    // Get D3D ptr
    if (FAILED(hr = pdd->QueryInterface(IID_IDirect3D7, (VOID**)&pd3d)))
    {
        *piStepThatFailed = TESTID_QUERY_D3D;
        goto LEnd;
    }
    if( NULL == pd3d )
    {
        *piStepThatFailed = TESTID_QUERY_D3D;
        goto LEnd;
    }

    // Create device
    if (FAILED(hr = pd3d->CreateDevice(guid3DDevice, pddsBack, &pd3ddev)))
    {
        *piStepThatFailed = TESTID_CREATE_DEVICE;
        goto LEnd;
    }
    if( NULL == pd3ddev )
    {
        *piStepThatFailed = TESTID_CREATE_DEVICE;
        goto LEnd;
    }

    // Set the viewport
    vp.dwX      = 0;
    vp.dwY      = 0;
    vp.dwWidth  = dwWidth;
    vp.dwHeight = dwHeight;
    vp.dvMinZ   = 0.0f;
    vp.dvMaxZ   = 1.0f;
    if (FAILED(hr = pd3ddev->SetViewport(&vp)))
    {
        *piStepThatFailed = TESTID_SETVIEWPORT;
        goto LEnd;
    }

    // Add a light
    ZeroMemory(&lightdata, sizeof(lightdata));
    lightdata.dltType = D3DLIGHT_DIRECTIONAL;
    lightdata.dcvDiffuse.r = 1.0f;
    lightdata.dcvDiffuse.g = 1.0f;
    lightdata.dcvDiffuse.b = 1.0f;
    lightdata.dvDirection.x = 0.0f;
    lightdata.dvDirection.y = 0.0f;
    lightdata.dvDirection.z = 1.0f;
    if (FAILED(hr = pd3ddev->SetLight( 0, &lightdata)))
    {
        *piStepThatFailed = TESTID_SETLIGHT;
        goto LEnd;
    }
    if (FAILED(hr = pd3ddev->LightEnable(0, TRUE)))
    {
        *piStepThatFailed = TESTID_LIGHTENABLE; 
        goto LEnd;
    }

    // Set up matrices
    mat = D3DMATRIX(1.0f, 0.0f, 0.0f, 0.0f,
                    0.0f, 1.0f, 0.0f, 0.0f,
                    0.0f, 0.0f, 1.0f, 0.0f,
                    0.0f, 0.0f, 0.0f, 1.0f);
    if (FAILED(hr = pd3ddev->SetTransform(D3DTRANSFORMSTATE_WORLD, &mat)))
    {
        *piStepThatFailed = TESTID_SETTRANSFORM;
        goto LEnd;
    }

    mat = D3DMATRIX(1.0f, 0.0f, 0.0f, 0.0f,
                      0.0f, 1.0f, 0.0f, 0.0f,
                      0.0f, 0.0f, 1.0f, 0.0f,
                      0.0f,  0.0f,  5.0f,  1.0f);
    if (FAILED(hr = pd3ddev->SetTransform(D3DTRANSFORMSTATE_VIEW, &mat)))
    {
        *piStepThatFailed = TESTID_SETTRANSFORM;
        goto LEnd;
    }

    D3DUtil_SetProjectionMatrix( mat, 60.0f * 3.14159f / 180.0f, (float) dwHeight / (float) dwWidth, 1.0f, 1000.0f );
    if (FAILED(hr = pd3ddev->SetTransform(D3DTRANSFORMSTATE_PROJECTION, &mat)))
    {
        *piStepThatFailed = TESTID_SETTRANSFORM;
        goto LEnd;
    }

    fRotY = 3.14f;
    fRotX = 0.0f;

    if (FAILED(hr = pd3ddev->SetRenderState(D3DRENDERSTATE_DITHERENABLE, TRUE)))
    {
        *piStepThatFailed = TESTID_SETRENDERSTATE;
        goto LEnd;
    }
    if (FAILED(hr = pd3ddev->SetRenderState( D3DRENDERSTATE_AMBIENT, 0x40404040 )))
    {
        *piStepThatFailed = TESTID_SETRENDERSTATE; 
        goto LEnd;
    }

    if( bUseTexture )
    {
        D3DMATERIAL7 mtrl;
        ZeroMemory( &mtrl, sizeof(D3DMATERIAL7) );
        mtrl.dcvDiffuse.r = mtrl.dcvAmbient.r = 1.0f;
        mtrl.dcvDiffuse.g = mtrl.dcvAmbient.g = 1.0f;
        mtrl.dcvDiffuse.b = mtrl.dcvAmbient.b = 1.0f;
        mtrl.dcvDiffuse.a = mtrl.dcvAmbient.a = 1.0f;
        if (FAILED(hr = pd3ddev->SetMaterial( &mtrl )))
        {
            *piStepThatFailed = TESTID_SETRENDERSTATE; 
            goto LEnd;
        }

        if (FAILED(hr = CreateTexture( &pddsTexture, pdd, pd3ddev, TEXT("DIRECTX"), piStepThatFailed)))
            goto LEnd;

        if( FAILED( hr = pd3ddev->GetCaps( &ddDesc ) ) )
        {
            *piStepThatFailed = TESTID_GETDEVICECAPS; 
            goto LEnd;
        }   

        if( ddDesc.dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MINFLINEAR )
        {
            if (FAILED(hr = pd3ddev->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTFN_LINEAR )))
            {
                *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
                goto LEnd;
            }
	    }
        if( ddDesc.dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MAGFPOINT )
        {
            if (FAILED(hr = pd3ddev->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTFN_LINEAR )))
            {
                *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
                goto LEnd;
            }
        }

        if (FAILED(hr = pd3ddev->SetTexture( 0, pddsTexture )))
        {
            *piStepThatFailed = TESTID_SETTEXTURE; 
            goto LEnd;
        }
    }

    // Here's the draw loop:
    MSG msg;
    for (i = 0; i < 600; i++)
    {
        if (PeekMessage(&msg, hwnd, WM_KEYDOWN, WM_KEYDOWN, PM_REMOVE))
        {
            *piStepThatFailed = TESTID_USER_CANCELLED;
            goto LEnd;
        }
        matRotY = D3DMATRIX((FLOAT)cos(fRotY),  0.0f, (FLOAT)sin(fRotY), 0.0f,
                            0.0f,               1.0f, 0.0f,              0.0f,
                            (FLOAT)-sin(fRotY), 0.0f, (FLOAT)cos(fRotY), 0.0f,
                            0.0f,               0.0f, 0.0f,              1.0f);

        matRotX = D3DMATRIX(1.0f, 0.0f,               0.0f,              0.0f,
                            0.0f, (FLOAT)cos(fRotX),  (FLOAT)sin(fRotX), 0.0f,
                            0.0f, (FLOAT)-sin(fRotX), (FLOAT)cos(fRotX), 0.0f,
                            0.0f, 0.0f,               0.0f,              1.0f);
        mat = matRotY * matRotX;
        if (FAILED(hr = pd3ddev->SetTransform(D3DTRANSFORMSTATE_WORLD, &mat)))
        {
            *piStepThatFailed = TESTID_SETTRANSFORM;
            goto LEnd;
        }
        if (FAILED(hr = pd3ddev->Clear( 0, NULL, D3DCLEAR_TARGET,
                                        0x00000000, 1.0f, 0L )))
        {
            *piStepThatFailed = TESTID_VIEWPORT_CLEAR;
            goto LEnd;
        }
        if (FAILED(hr = pd3ddev->BeginScene()))
        {
            if( hr == DDERR_SURFACELOST )
            {
                *piStepThatFailed = TESTID_USER_CANCELLED; 
                hr = S_OK;
            }
            else
                *piStepThatFailed = TESTID_BEGINSCENE;
            goto LEnd;
        }

        if( !bUseTexture )
        {
            if (FAILED(hr = pd3ddev->SetMaterial( &mtrlGreen )))
            {
                *piStepThatFailed = TESTID_SETRENDERSTATE; 
                goto LEnd;
            }
        }

        if (FAILED(hr = pd3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
            D3DFVF_VERTEX, (VOID*)vertexArrayFront, 4, (WORD*)indexArrayFront, 6, 0)))
        {
            *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE;
            goto LEnd;
        }
        if (FAILED(hr = pd3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
            D3DFVF_VERTEX, (VOID*)vertexArrayBack, 4, (WORD*)indexArrayBack, 6, 0)))
        {
            *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE;
            goto LEnd;
        }

        if( !bUseTexture )
        {
            if (FAILED(hr = pd3ddev->SetMaterial( &mtrlRed )))
            {
                *piStepThatFailed = TESTID_SETRENDERSTATE; 
                goto LEnd;
            }
        }

        if (FAILED(hr = pd3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
            D3DFVF_VERTEX, (VOID*)vertexArrayLeft, 4, (WORD*)indexArrayLeft, 6, 0)))
        {
            *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE;
            goto LEnd;
        }
        if (FAILED(hr = pd3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
            D3DFVF_VERTEX, (VOID*)vertexArrayRight, 4, (WORD*)indexArrayRight, 6, 0)))
        {
            *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE;
            goto LEnd;
        }
        
        if( !bUseTexture )
        {
            if (FAILED(hr = pd3ddev->SetMaterial( &mtrlBlue )))
            {
                *piStepThatFailed = TESTID_SETRENDERSTATE; 
                goto LEnd;
            }
        }

        if (FAILED(hr = pd3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
            D3DFVF_VERTEX, (VOID*)vertexArrayTop, 4, (WORD*)indexArrayTop, 6, 0)))
        {
            *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE;
            goto LEnd;
        }
        if (FAILED(hr = pd3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
            D3DFVF_VERTEX, (VOID*)vertexArrayBottom, 4, (WORD*)indexArrayBottom, 6, 0)))
        {
            *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE;
            goto LEnd;
        }

        if (FAILED(hr = pd3ddev->EndScene()))
        {
            *piStepThatFailed = TESTID_ENDSCENE;
            goto LEnd;
        }
        if (FAILED(hr = pddsFront->Flip(NULL, DDFLIP_WAIT)))
        {
            *piStepThatFailed = TESTID_PRESENT;
            goto LEnd;
        }
        fRotY += 0.05f;
        fRotX += 0.02f;
        Sleep(10);
    }

LEnd:
    ShowCursor(TRUE);
    ReleasePpo(&pddsTexture);
    ReleasePpo(&pd3ddev);
    ReleasePpo(&pd3d);
    ReleasePpo(&pddsBack);
    ReleasePpo(&pddsFront);
    if (bCooperativeLevelSet)
    {
        if (FAILED(hr))
        {
            // Something has already failed, so report that failure
            // rather than any failure of SetCooperativeLevel
            pdd->SetCooperativeLevel(hwnd, DDSCL_NORMAL);
        }
        else
        {
            if (FAILED(hr = pdd->SetCooperativeLevel(hwnd, DDSCL_NORMAL)))
            {
                *piStepThatFailed = TESTID_SETCOOPERATIVELEVEL_NORMAL;
            }
        }
    }
    if (hwnd != NULL)
        SendMessage(hwnd, WM_CLOSE, 0, 0);
    if (bDisplayModeSet)
    {
        if (FAILED(hr))
        {
            // Something has already failed, so report that failure
            // rather than any failure of RestoreDisplayMode
            pdd->RestoreDisplayMode();
        }
        else
        {
            // Nothing has failed yet, so report any failure of RestoreDisplayMode
            if (FAILED(hr = pdd->RestoreDisplayMode()))
                return hr;
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateTestWindow
 *
 ****************************************************************************/
HRESULT CreateTestWindow(HWND hwndMain, HWND* phwnd)
{
    static BOOL bClassRegistered = FALSE;
    WNDCLASS wndClass;
    TCHAR* pszClass = TEXT("DxDiag AGP7 Test Window"); // Don't need to localize
    HINSTANCE hInst = (HINSTANCE)GetWindowLongPtr(hwndMain, GWLP_HINSTANCE);
    TCHAR szTitle[200];

    if (!bClassRegistered)
    {
        ZeroMemory(&wndClass, sizeof(wndClass));
        wndClass.style = CS_HREDRAW | CS_VREDRAW;
        wndClass.lpfnWndProc = DefWindowProc;
        wndClass.cbClsExtra = 0;
        wndClass.cbWndExtra = 0;
        wndClass.hInstance = hInst;
        wndClass.hIcon = NULL;
        wndClass.hCursor = NULL;
        wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wndClass.lpszMenuName = NULL;
        wndClass.lpszClassName = pszClass;
        if (NULL == RegisterClass(&wndClass))
            return E_FAIL;
        bClassRegistered = TRUE;
    }

    LoadString(NULL, IDS_APPFULLNAME, szTitle, 200);
    *phwnd = CreateWindow(pszClass, szTitle, WS_OVERLAPPED, 
        0, 0, 0, 0, hwndMain, NULL, hInst, NULL);
    if (*phwnd == NULL)
        return E_FAIL;

    ShowWindow(*phwnd, SW_SHOW);

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: D3DUtil_SetProjectionMatrix()
// Desc: Sets the passed in 4x4 matrix to a perpsective projection matrix built
//       from the field-of-view (fov, in y), aspect ratio, near plane (D),
//       and far plane (F). Note that the projection matrix is normalized for
//       element [3][4] to be 1.0. This is performed so that W-based range fog
//       will work correctly.
//-----------------------------------------------------------------------------
HRESULT D3DUtil_SetProjectionMatrix( D3DMATRIX& mat, FLOAT fFOV, FLOAT fAspect,
                                     FLOAT fNearPlane, FLOAT fFarPlane )
{
    if( fabs(fFarPlane-fNearPlane) < 0.01f )
        return E_INVALIDARG;
    if( fabs(sin(fFOV/2)) < 0.01f )
        return E_INVALIDARG;

    FLOAT w = fAspect * ( cosf(fFOV/2)/sinf(fFOV/2) );
    FLOAT h =   1.0f  * ( cosf(fFOV/2)/sinf(fFOV/2) );
    FLOAT Q = fFarPlane / ( fFarPlane - fNearPlane );

    ZeroMemory( &mat, sizeof(D3DMATRIX) );
    mat._11 = w;
    mat._22 = h;
    mat._33 = Q;
    mat._34 = 1.0f;
    mat._43 = -Q*fNearPlane;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: TextureSearchCallback()
// Desc: Enumeration callback routine to find a 16-bit texture format. This
//       function is invoked by the ID3DDevice::EnumTextureFormats() function
//       to sort through all the available texture formats for a given device.
//       The pixel format of each enumerated texture format is passed into the
//       "pddpf" parameter. The 2nd parameter is to be used however the app
//       sees fit. In this case, we are using it as an output parameter to 
//       return a normal 16-bit texture format.
//-----------------------------------------------------------------------------
static HRESULT CALLBACK TextureSearchCallback( DDPIXELFORMAT* pddpf, VOID* param )
{
    // Note: Return with DDENUMRET_OK to continue enumerating more formats.

    // Skip any funky modes
    if( pddpf->dwFlags & (DDPF_LUMINANCE|DDPF_BUMPLUMINANCE|DDPF_BUMPDUDV) )
        return DDENUMRET_OK;
    
    // Skip any FourCC formats
    if( pddpf->dwFourCC != 0 )
        return DDENUMRET_OK;

    // Skip alpha modes
    if( pddpf->dwFlags&DDPF_ALPHAPIXELS )
        return DDENUMRET_OK;

    // We only want certain format, so skip all others
    if( pddpf->dwRGBBitCount == 32 && ((DDPIXELFORMAT*)param)->dwRGBBitCount == 0 || 
    	pddpf->dwRGBBitCount == 16 )
	{
	    // We found a good match. Copy the current pixel format to our output
	    // parameter
	    memcpy( (DDPIXELFORMAT*)param, pddpf, sizeof(DDPIXELFORMAT) );
	}

	// Have we found the best match?	
    if( pddpf->dwRGBBitCount == 16 )
	    return DDENUMRET_CANCEL;

	// Keep looking.	
    return DDENUMRET_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateTexture()
// Desc: Is passed a filename and creates a local Bitmap from that file. Some
//       logic and file parsing code could go here to support other image
//       file formats.
//-----------------------------------------------------------------------------
HRESULT CreateTexture( LPDIRECTDRAWSURFACE7* ppdds, 
                       LPDIRECTDRAW7 pdd, LPDIRECT3DDEVICE7 pd3dDevice, 
                       TCHAR* strName, LONG* piStepThatFailed)
{
    HRESULT              hr;
    LPDIRECTDRAWSURFACE7 pddsTexture    = NULL;
    HBITMAP              hbm            = NULL;
    D3DDEVICEDESC7       ddDesc;
    BITMAP               bm;
    DWORD                dwWidth;
    DWORD                dwHeight;
    DDSURFACEDESC2       ddsd;
    LPDIRECTDRAWSURFACE7 pddsRender     = NULL;
    HDC                  hdcTexture     = NULL;
    HDC                  hdcBitmap      = NULL;

    //////////////////////////////////////////////
    // Verify args
    //////////////////////////////////////////////
    if( NULL == ppdds        || 
        NULL == pdd          || 
        NULL == pd3dDevice   || 
        NULL == strName      || 
        NULL == piStepThatFailed )
    {
        // Unknown error - shouldn't happen, but this prevent crashs
        *piStepThatFailed = 0xFFFF; 
        return E_FAIL;
    }

    //////////////////////////////////////////////
    // Load image 
    //////////////////////////////////////////////
    hbm = (HBITMAP)LoadImage( GetModuleHandle(NULL), strName, 
                              IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );
    if( NULL == hbm )
    {
        *piStepThatFailed = TESTID_CREATETEXTURE; 
        hr = E_FAIL;
        goto LEnd;
    }

    //////////////////////////////////////////////
    // Get caps on device and hbm
    //////////////////////////////////////////////
    if( FAILED( hr = pd3dDevice->GetCaps( &ddDesc ) ) )
    {
        *piStepThatFailed = TESTID_GETDEVICECAPS; 
        goto LEnd;
    }
    
    if( 0 == GetObject( hbm, sizeof(BITMAP), &bm ) ) 
    {
        *piStepThatFailed = TESTID_CREATETEXTURE; 
        hr = E_FAIL;
        goto LEnd;
    }

    dwWidth  = (DWORD)bm.bmWidth;
    dwHeight = (DWORD)bm.bmHeight;

    //////////////////////////////////////////////
    // Setup the new surface desc for the texture. 
    //////////////////////////////////////////////
    ZeroMemory( &ddsd, sizeof(DDSURFACEDESC2) );
    ddsd.dwSize          = sizeof(DDSURFACEDESC2);
    ddsd.dwFlags         = DDSD_CAPS|DDSD_HEIGHT|DDSD_WIDTH|
                           DDSD_PIXELFORMAT|DDSD_TEXTURESTAGE;
    ddsd.ddsCaps.dwCaps  = DDSCAPS_TEXTURE|DDSCAPS_VIDEOMEMORY|DDSCAPS_NONLOCALVIDMEM;
    ddsd.dwWidth         = dwWidth;
    ddsd.dwHeight        = dwHeight;
    
    // Adjust width and height, if the driver requires it
    if( ddDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_POW2 )
    {
        for( ddsd.dwWidth=1;  dwWidth>ddsd.dwWidth;   ddsd.dwWidth<<=1 );
        for( ddsd.dwHeight=1; dwHeight>ddsd.dwHeight; ddsd.dwHeight<<=1 );
    }
    if( ddDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_SQUAREONLY )
    {
        if( ddsd.dwWidth > ddsd.dwHeight ) 
            ddsd.dwHeight = ddsd.dwWidth;
        else                               
            ddsd.dwWidth  = ddsd.dwHeight;
    }

    // Look for a 16-bit texture format
    if( FAILED( hr = pd3dDevice->EnumTextureFormats( TextureSearchCallback, 
                                                     &ddsd.ddpfPixelFormat ) ) )
    {
        *piStepThatFailed = TESTID_ENUMTEXTUREFORMATS; 
        goto LEnd;
    }
    if( 0L == ddsd.ddpfPixelFormat.dwRGBBitCount )
    {
        *piStepThatFailed = TESTID_ENUMTEXTUREFORMATS; 
        goto LEnd;
    }

    //////////////////////////////////////////////
    // Create a new surface for the texture
    //////////////////////////////////////////////
    if( FAILED( hr = pdd->CreateSurface( &ddsd, &pddsTexture, NULL ) ) )
    {
        ddsd.ddsCaps.dwCaps  = DDSCAPS_TEXTURE;
        if( FAILED( hr = pdd->CreateSurface( &ddsd, &pddsTexture, NULL ) ) )
        {
                *piStepThatFailed = TESTID_CREATESURFACE; 
                goto LEnd;
        }
    }
    if( NULL == pddsTexture )
    {
        *piStepThatFailed = TESTID_CREATESURFACE; 
        hr = E_FAIL;
        goto LEnd;
    }

    //////////////////////////////////////////////
    // Get DCs from bitmap and surface
    //////////////////////////////////////////////
    hdcBitmap = CreateCompatibleDC( NULL );
    if( NULL == hdcBitmap )
    {
        *piStepThatFailed = TESTID_CREATETEXTURE; 
        hr = E_FAIL;
        goto LEnd;
    }

    if( NULL == SelectObject( hdcBitmap, hbm ) )
    {
        *piStepThatFailed = TESTID_CREATETEXTURE; 
        hr = E_FAIL;
        goto LEnd;
    }

    // Get a DC for the surface
    if( FAILED( hr = pddsTexture->GetDC( &hdcTexture ) ) )
    {
        *piStepThatFailed = TESTID_GETDC; 
        goto LEnd;
    }
    if( NULL == hdcTexture )
    {
        *piStepThatFailed = TESTID_GETDC; 
        goto LEnd;
    }

    //////////////////////////////////////////////
    // Copy the bitmap image to the surface.
    //////////////////////////////////////////////
    if( 0 == BitBlt( hdcTexture, 0, 0, bm.bmWidth, bm.bmHeight, hdcBitmap,
                     0, 0, SRCCOPY ) )
    {
        if( pddsTexture )
        {
            // Try to release the DC first
            pddsTexture->ReleaseDC( hdcTexture );
        }

        *piStepThatFailed = TESTID_CREATETEXTURE; 
        hr = E_FAIL;
        goto LEnd;
    }

    //////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////
    if( FAILED( hr = pddsTexture->ReleaseDC( hdcTexture ) ) )
    {
        *piStepThatFailed = TESTID_RELEASEDC; 
        goto LEnd;
    }


LEnd:
    if( hdcBitmap )
        DeleteDC( hdcBitmap );
    if( hbm )
        DeleteObject( hbm );

    // Return the newly created texture
    // pddsTexture will be cleaned up in parent fn.
    *ppdds = pddsTexture;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\testd3d8.cpp ===
/****************************************************************************
 *
 *    File: testd3d8.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Jason Sandlin (jasonsa@microsoft.com)
 * Purpose: Test D3D8/AGP Texturing functionality on this machine
 *
 * (C) Copyright 2000 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <Windows.h>
#define DIRECT3D_VERSION 0x0800 // file uses DX8 
#include <d3d8.h>
#include <d3dx8.h>
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h"
#include "testagp.h"
#include "resource.h"

#ifndef ReleasePpo
    #define ReleasePpo(ppo) \
        if (*(ppo) != NULL) \
        { \
            (*(ppo))->Release(); \
            *(ppo) = NULL; \
        } \
        else (VOID)0
#endif

typedef IDirect3D8* (WINAPI* LPDIRECT3DCREATE8)(UINT SDKVersion);

#define D3DFVF_VERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)

#define MAX_FORMATS             64
#define MAX_MODES               256
#define MAX_CONFIRMED_MODES     256

struct D3DVERTEX
{
    D3DXVECTOR3 p;
    D3DXVECTOR3 n;
    FLOAT       tu, tv;

    D3DVERTEX() {};
    D3DVERTEX( D3DXVECTOR3 vp, D3DXVECTOR3 vn, FLOAT fTu, FLOAT fTv ) : p(vp), n(vn), tu(fTu), tv(fTv) {}
};

struct D3DModeInfo
{
    DWORD      Width;      // Screen width in this mode
    DWORD      Height;     // Screen height in this mode
    D3DFORMAT  Format;     // Pixel format in this mode
    DWORD      dwBehavior; // Hardware / Software / Mixed vertex processing
};

enum TESTID
{
    TESTID_LOAD_D3D8_DLL=1,
    TESTID_GET_D3DCREATE8,
    TESTID_D3DCREATE8,
    TESTID_ENUMADAPTERMODES,
    TESTID_GETDEVICECAPS,
    TESTID_NOMODEFOUND,
    TESTID_CREATE_TEST_WINDOW,
    TESTID_CREATE_DEVICE,
    TESTID_GETBACKBUFFER,
    TESTID_GETDESC,
    TESTID_CREATE_VERTEX_BUFFER,
    TESTID_CREATE_INDEX_BUFFER,
    TESTID_LOCK,
    TESTID_UNLOCK,
    TESTID_SETLIGHT,
    TESTID_LIGHTENABLE,
    TESTID_SETTRANSFORM,
    TESTID_SETRENDERSTATE,
    TESTID_CREATETEXTURE,
    TESTID_SETTEXTURESTAGESTATE,
    TESTID_SETTEXTURE,
    TESTID_SETVERTEXSHADER,
    TESTID_USER_CANCELLED,
    TESTID_VIEWPORT_CLEAR,
    TESTID_BEGINSCENE,
    TESTID_SETMATERIAL,
    TESTID_SETSTREAMSOURCE,
    TESTID_SETINDICES,
    TESTID_DRAW_INDEXED_PRIMITIVE,
    TESTID_ENDSCENE,
    TESTID_PRESENT,
    TESTID_USER_VERIFY_D3D7_RENDERING,
    TESTID_USER_VERIFY_D3D8_RENDERING,
    TESTID_LOAD_DDRAW_DLL,
    TESTID_GET_DIRECTDRAWCREATE,
    TESTID_DIRECTDRAWCREATE,
    TESTID_SETCOOPERATIVELEVEL_FULLSCREEN,
    TESTID_SETCOOPERATIVELEVEL_NORMAL,
    TESTID_SETDISPLAYMODE,
    TESTID_CREATEPRIMARYSURFACE_FLIP_ONEBACK,
    TESTID_GETATTACHEDSURFACE,
    TESTID_QUERY_D3D,
    TESTID_SETVIEWPORT,
    TESTID_ENUMTEXTUREFORMATS,
    TESTID_CREATESURFACE,
    TESTID_GETDC,
    TESTID_RELEASEDC,
};

BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish = FALSE); // from main.cpp 
static HRESULT SelectModeAndFormat( DisplayInfo* pDisplayInfo, IDirect3D8* pD3D8, D3DModeInfo* pSelectedMode, D3DDEVTYPE* pSelectedDeviceType );
static HRESULT Test3D( BOOL bUseTexture, IDirect3D8* pD3D8, HWND hwndMain, DWORD iAdapter, D3DModeInfo selectedMode, D3DDEVTYPE selectedDeviceType, LONG* piStepThatFailed );
static HRESULT CreateTestWindow(HWND hwndMain, HWND* phwnd);
static HRESULT InitVertexBuffer( IDirect3DDevice8* pd3dDevice, const D3DVERTEX* vertexArray, DWORD dwNumVertices, LPDIRECT3DVERTEXBUFFER8* ppVB, LONG* piStepThatFailed );
static HRESULT InitIndexBuffer( IDirect3DDevice8* pd3dDevice, const WORD* wIndexArray, DWORD dwNumIndices, LPDIRECT3DINDEXBUFFER8* ppIB, LONG* piStepThatFailed );
static HRESULT DrawTwoSides( BOOL bUseTexture, IDirect3DDevice8* pd3dDevice, D3DMATERIAL8* pMtrl, LPDIRECT3DVERTEXBUFFER8 pVB1, LPDIRECT3DINDEXBUFFER8 pIB1, LPDIRECT3DVERTEXBUFFER8 pVB2, LPDIRECT3DINDEXBUFFER8 pIB2, LONG* piStepThatFailed );




//-----------------------------------------------------------------------------
// Name: TestD3Dv8()
// Desc: 
//-----------------------------------------------------------------------------
VOID TestD3Dv8( BOOL bUseTexture, HWND hwndMain, DisplayInfo* pDisplayInfo)
{
    HRESULT             hr             = S_OK;
    TCHAR               sz[MAX_PATH];
    TCHAR               szTitle[MAX_PATH];
    HINSTANCE           hInstD3D8      = NULL;
    IDirect3D8*         pD3D8          = NULL;
    HWND                hwnd           = NULL;
    D3DModeInfo         selectedMode;
    D3DDEVTYPE          selectedDeviceType;
  
    if( pDisplayInfo == NULL )
        return;

    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);

    LPDIRECT3DCREATE8 pD3DCreate8 = NULL;
    TCHAR szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\d3d8.dll"));

    // This may fail if DX8 isn't on the system
    hInstD3D8 = LoadLibrary(szPath);
    if (hInstD3D8 == NULL)
    {
        pDisplayInfo->m_testResultD3D8.m_iStepThatFailed = TESTID_LOAD_D3D8_DLL;
        pDisplayInfo->m_testResultD3D8.m_hr = E_FAIL;
        goto LEnd;
    }

    pD3DCreate8 = (LPDIRECT3DCREATE8)GetProcAddress(hInstD3D8, "Direct3DCreate8");
    if (pD3DCreate8 == NULL)
    {
        FreeLibrary(hInstD3D8);
        hInstD3D8 = NULL;

        pDisplayInfo->m_testResultD3D8.m_iStepThatFailed = TESTID_GET_D3DCREATE8;
        pDisplayInfo->m_testResultD3D8.m_hr = E_POINTER;
        goto LEnd;
    }

    pD3D8 = pD3DCreate8(D3D_SDK_VERSION);
    if( pD3D8 == NULL )
    {
        // We have the wrong headers since d3d8.dll loaded but D3DCreate8() failed.
        pDisplayInfo->m_testResultD3D8.m_iStepThatFailed = TESTID_D3DCREATE8;
        pDisplayInfo->m_testResultD3D8.m_hr = E_FAIL;
        goto LEnd;
    }

    // Enum and select a support mode and format and device type
    if( FAILED( SelectModeAndFormat( pDisplayInfo, pD3D8, 
                                     &selectedMode, &selectedDeviceType ) ) )
        goto LEnd;

    // Save the cursor
    POINT ptMouse;
    GetCursorPos(&ptMouse);

    // Run the test
    if (FAILED(hr = Test3D( bUseTexture, pD3D8, hwndMain, pDisplayInfo->m_iAdapter, selectedMode, 
                            selectedDeviceType, &pDisplayInfo->m_testResultD3D8.m_iStepThatFailed)))
    {
        pDisplayInfo->m_testResultD3D8.m_hr = hr;
        goto LEnd;
    }

    // Restore the cursor position
    SetCursorPos( ptMouse.x, ptMouse.y );    

    // Tell the user if they canceled
    if (pDisplayInfo->m_testResultD3D8.m_iStepThatFailed == TESTID_USER_CANCELLED)
    {
        LoadString(NULL, IDS_YOUCANCELLED, sz, MAX_PATH);
        MessageBox(hwndMain, sz, szTitle, MB_OK);
        pDisplayInfo->m_testResultD3D8.m_bCancelled = TRUE;
        goto LEnd;
    }

    // Confirm the test succeeded
    LoadString(NULL, IDS_CONFIRMD3DTEST, sz, MAX_PATH);
    if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
    {
        pDisplayInfo->m_testResultD3D8.m_iStepThatFailed = TESTID_USER_VERIFY_D3D8_RENDERING;
        pDisplayInfo->m_testResultD3D8.m_hr = S_OK;
        goto LEnd;
    }

LEnd:
    ReleasePpo( &pD3D8 );
    if( hInstD3D8 )
    {
        FreeLibrary(hInstD3D8);
        hInstD3D8 = NULL;
    }
}




//-----------------------------------------------------------------------------
// Name: Test3D()
// Desc: Generate a spinning 3D cube
//-----------------------------------------------------------------------------
HRESULT Test3D( BOOL bUseTexture, IDirect3D8* pD3D8, HWND hwndMain, DWORD iAdapter, 
                D3DModeInfo selectedMode, D3DDEVTYPE selectedDeviceType, 
                LONG* piStepThatFailed )
{
    LPDIRECT3DDEVICE8       pd3dDevice    = NULL;
    LPDIRECT3DTEXTURE8      pTexture      = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVBFront      = NULL;
    LPDIRECT3DINDEXBUFFER8  pIBFront      = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVBBack       = NULL;
    LPDIRECT3DINDEXBUFFER8  pIBBack       = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVBLeft       = NULL;
    LPDIRECT3DINDEXBUFFER8  pIBLeft       = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVBRight      = NULL;
    LPDIRECT3DINDEXBUFFER8  pIBRight      = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVBTop        = NULL;
    LPDIRECT3DINDEXBUFFER8  pIBTop        = NULL;
    LPDIRECT3DVERTEXBUFFER8 pVBBottom     = NULL;
    LPDIRECT3DINDEXBUFFER8  pIBBottom     = NULL;
    LPDIRECT3DSURFACE8      pBackBuffer   = NULL;   
    D3DMATERIAL8            mtrlWhite;
    D3DMATERIAL8            mtrlRed;
    D3DMATERIAL8            mtrlBlue;
    D3DMATERIAL8            mtrlGreen;
    D3DXMATRIX              matRotY;
    D3DXMATRIX              matRotX;
    D3DXMATRIX              mat;
    D3DSURFACE_DESC         d3dsdBackBuffer;   
    FLOAT                   fRotY;
    FLOAT                   fRotX;
    HRESULT                 hr;
    HWND                    hwnd;
    MSG                     msg;
    DWORD                   i;

    static const D3DVERTEX vertexArrayFront[] = 
    {
        D3DVERTEX(D3DXVECTOR3(-1.0, -1.0, -1.0), D3DXVECTOR3(0.0, 0.0, -1.0),   1.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0, -1.0, -1.0), D3DXVECTOR3(0.0, 0.0, -1.0),   0.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3(-1.0,  1.0, -1.0), D3DXVECTOR3(0.0, 0.0, -1.0),   1.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0,  1.0, -1.0), D3DXVECTOR3(0.0, 0.0, -1.0),   0.0f, 1.0f),
    };
    static const WORD indexArrayFront[] = 
    {
        0, 2, 1,
        2, 3, 1,
    };

    static const D3DVERTEX vertexArrayBack[] = 
    {
        D3DVERTEX(D3DXVECTOR3(-1.0, -1.0, 1.0),  D3DXVECTOR3(0.0, 0.0, 1.0),   0.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0, -1.0, 1.0),  D3DXVECTOR3(0.0, 0.0, 1.0),   1.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3(-1.0,  1.0, 1.0),  D3DXVECTOR3(0.0, 0.0, 1.0),   0.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0,  1.0, 1.0),  D3DXVECTOR3(0.0, 0.0, 1.0),   1.0f, 1.0f),
    };
    static const WORD indexArrayBack[] = 
    {
        0, 1, 2,
        2, 1, 3,
    };

    static const D3DVERTEX vertexArrayLeft[] = 
    {
        D3DVERTEX(D3DXVECTOR3(-1.0, -1.0, -1.0),  D3DXVECTOR3(-1.0, 0.0, 0.0),   0.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3(-1.0, -1.0,  1.0),  D3DXVECTOR3(-1.0, 0.0, 0.0),   1.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3(-1.0,  1.0, -1.0),  D3DXVECTOR3(-1.0, 0.0, 0.0),   0.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3(-1.0,  1.0,  1.0),  D3DXVECTOR3(-1.0, 0.0, 0.0),   1.0f, 1.0f),
    };
    static const WORD indexArrayLeft[] = 
    {
        0, 1, 2,
        2, 1, 3,
    };

    static const D3DVERTEX vertexArrayRight[] = 
    {
        D3DVERTEX(D3DXVECTOR3(1.0, -1.0, -1.0),  D3DXVECTOR3(1.0, 0.0, 0.0),   1.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3(1.0, -1.0,  1.0),  D3DXVECTOR3(1.0, 0.0, 0.0),   0.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3(1.0,  1.0, -1.0),  D3DXVECTOR3(1.0, 0.0, 0.0),   1.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3(1.0,  1.0,  1.0),  D3DXVECTOR3(1.0, 0.0, 0.0),   0.0f, 1.0f),
    };
    static const WORD indexArrayRight[] = 
    {
        0, 2, 1,
        2, 3, 1,
    };

    static const D3DVERTEX vertexArrayTop[] = 
    {
        D3DVERTEX(D3DXVECTOR3(-1.0, 1.0, -1.0),  D3DXVECTOR3(0.0, 1.0, 0.0),   0.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0, 1.0, -1.0),  D3DXVECTOR3(0.0, 1.0, 0.0),   1.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3(-1.0, 1.0,  1.0),  D3DXVECTOR3(0.0, 1.0, 0.0),   0.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0, 1.0,  1.0),  D3DXVECTOR3(0.0, 1.0, 0.0),   1.0f, 0.0f),
    };
    static const WORD indexArrayTop[] = 
    {
        0, 2, 1,
        2, 3, 1,
    };

    static const D3DVERTEX vertexArrayBottom[] = 
    {
        D3DVERTEX(D3DXVECTOR3(-1.0, -1.0, -1.0),  D3DXVECTOR3(0.0, -1.0, 0.0),   1.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0, -1.0, -1.0),  D3DXVECTOR3(0.0, -1.0, 0.0),   0.0f, 1.0f),
        D3DVERTEX(D3DXVECTOR3(-1.0, -1.0,  1.0),  D3DXVECTOR3(0.0, -1.0, 0.0),   1.0f, 0.0f),
        D3DVERTEX(D3DXVECTOR3( 1.0, -1.0,  1.0),  D3DXVECTOR3(0.0, -1.0, 0.0),   0.0f, 0.0f),
    };
    static const WORD indexArrayBottom[] = 
    {
        0, 1, 2,
        2, 1, 3,
    };

    ShowCursor(FALSE);
    // Create test window
    if (FAILED(hr = CreateTestWindow(hwndMain, &hwnd)))
    {
        *piStepThatFailed = TESTID_CREATE_TEST_WINDOW;
        goto LEnd;
    }

    // Set up the presentation parameters
    D3DPRESENT_PARAMETERS d3dpp;         
    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.Windowed                          = FALSE;
    d3dpp.BackBufferCount                   = 1;
    d3dpp.MultiSampleType                   = D3DMULTISAMPLE_NONE;
    d3dpp.SwapEffect                        = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil            = FALSE;
    d3dpp.FullScreen_RefreshRateInHz        = D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval   = D3DPRESENT_INTERVAL_ONE;
    d3dpp.hDeviceWindow                     = hwnd;
    d3dpp.BackBufferWidth                   = selectedMode.Width;
    d3dpp.BackBufferHeight                  = selectedMode.Height;
    d3dpp.BackBufferFormat                  = selectedMode.Format;

    // Create the device
    if( FAILED( hr = pD3D8->CreateDevice( iAdapter, selectedDeviceType,
                                          hwnd, selectedMode.dwBehavior, &d3dpp,
                                          &pd3dDevice ) ) )
    {
        *piStepThatFailed  = TESTID_CREATE_DEVICE;
        goto LEnd;
    }
    if( pd3dDevice == NULL )
    {
        *piStepThatFailed  = TESTID_CREATE_DEVICE;
        hr = E_POINTER;
        goto LEnd;
    }

    // Get the desc of the backbuffer
    if( FAILED( hr = pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer ) ) )
    {
        *piStepThatFailed  = TESTID_GETBACKBUFFER;
        goto LEnd;
    }
    if( pBackBuffer == NULL )
    {
        *piStepThatFailed  = TESTID_GETBACKBUFFER;
        hr = E_POINTER;
        goto LEnd;
    }

    if( FAILED( hr = pBackBuffer->GetDesc( &d3dsdBackBuffer ) ) )
    {
        *piStepThatFailed  = TESTID_GETDESC;
        goto LEnd;
    }
    ReleasePpo(&pBackBuffer);

    // Init the vertex/index buffer for the Front 
    if( FAILED( hr = InitVertexBuffer( pd3dDevice, vertexArrayFront, sizeof(vertexArrayFront)/sizeof(D3DVERTEX), &pVBFront, piStepThatFailed ) ) )
        goto LEnd;
    if( FAILED( hr = InitIndexBuffer( pd3dDevice, indexArrayFront, sizeof(indexArrayFront)/sizeof(WORD), &pIBFront, piStepThatFailed ) ) )
        goto LEnd;

    // Init the vertex/index buffer for the Back
    if( FAILED( hr = InitVertexBuffer( pd3dDevice, vertexArrayBack, sizeof(vertexArrayBack)/sizeof(D3DVERTEX), &pVBBack, piStepThatFailed ) ) )
        goto LEnd;
    if( FAILED( hr = InitIndexBuffer( pd3dDevice, indexArrayBack, sizeof(indexArrayBack)/sizeof(WORD), &pIBBack, piStepThatFailed ) ) )
        goto LEnd;

    // Init the vertex/index buffer for the Left
    if( FAILED( hr = InitVertexBuffer( pd3dDevice, vertexArrayLeft, sizeof(vertexArrayLeft)/sizeof(D3DVERTEX), &pVBLeft, piStepThatFailed ) ) )
        goto LEnd;
    if( FAILED( hr = InitIndexBuffer( pd3dDevice, indexArrayLeft, sizeof(indexArrayLeft)/sizeof(WORD), &pIBLeft, piStepThatFailed ) ) )
        goto LEnd;

    // Init the vertex/index buffer for the Right
    if( FAILED( hr = InitVertexBuffer( pd3dDevice, vertexArrayRight, sizeof(vertexArrayRight)/sizeof(D3DVERTEX), &pVBRight, piStepThatFailed ) ) )
        goto LEnd;
    if( FAILED( hr = InitIndexBuffer( pd3dDevice, indexArrayRight, sizeof(indexArrayRight)/sizeof(WORD), &pIBRight, piStepThatFailed ) ) )
        goto LEnd;

    // Init the vertex/index buffer for the Top
    if( FAILED( hr = InitVertexBuffer( pd3dDevice, vertexArrayTop, sizeof(vertexArrayTop)/sizeof(D3DVERTEX), &pVBTop, piStepThatFailed ) ) )
        goto LEnd;
    if( FAILED( hr = InitIndexBuffer( pd3dDevice, indexArrayTop, sizeof(indexArrayTop)/sizeof(WORD), &pIBTop, piStepThatFailed ) ) )
        goto LEnd;
    
    // Init the vertex/index buffer for the Bottom
    if( FAILED( hr = InitVertexBuffer( pd3dDevice, vertexArrayBottom, sizeof(vertexArrayBottom)/sizeof(D3DVERTEX), &pVBBottom, piStepThatFailed ) ) )
        goto LEnd;
    if( FAILED( hr = InitIndexBuffer( pd3dDevice, indexArrayBottom, sizeof(indexArrayBottom)/sizeof(WORD), &pIBBottom, piStepThatFailed ) ) )
        goto LEnd;

    // Add a light
    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type        = D3DLIGHT_DIRECTIONAL;
    light.Diffuse.r   = 1.0f;
    light.Diffuse.g   = 1.0f;
    light.Diffuse.b   = 1.0f;
    light.Direction.x = 0.0f;
    light.Direction.y = 0.0f;
    light.Direction.z = 1.0f;

    if( FAILED( hr = pd3dDevice->SetLight( 0, &light ) ) )
    {
        *piStepThatFailed = TESTID_SETLIGHT;
        goto LEnd;
    }
    if( FAILED( hr = pd3dDevice->LightEnable( 0, TRUE ) ) )
    {
        *piStepThatFailed = TESTID_LIGHTENABLE; 
        goto LEnd;
    }

    // Set up matrices
    mat = D3DXMATRIX(1.0f, 0.0f, 0.0f, 0.0f,
                     0.0f, 1.0f, 0.0f, 0.0f,
                     0.0f, 0.0f, 1.0f, 0.0f,
                     0.0f, 0.0f, 0.0f, 1.0f);
    if( FAILED( hr = pd3dDevice->SetTransform( D3DTS_WORLD, &mat ) ) )
    {
        *piStepThatFailed = TESTID_SETTRANSFORM;
        goto LEnd;
    }

    mat = D3DXMATRIX(1.0f, 0.0f, 0.0f, 0.0f,
                     0.0f, 1.0f, 0.0f, 0.0f,
                     0.0f, 0.0f, 1.0f, 0.0f,
                     0.0f, 0.0f, 5.0f, 1.0f);
    if( FAILED( hr = pd3dDevice->SetTransform( D3DTS_VIEW, &mat ) ) )
    {
        *piStepThatFailed = TESTID_SETTRANSFORM;
        goto LEnd;
    }

    D3DXMatrixPerspectiveFovLH( &mat, D3DXToRadian(60.0f), 
                                (float) d3dsdBackBuffer.Width / (float) d3dsdBackBuffer.Height, 
                                1.0f, 1000.0f );
    if( FAILED( hr = pd3dDevice->SetTransform( D3DTS_PROJECTION, &mat ) ) )
    {
        *piStepThatFailed = TESTID_SETTRANSFORM;
        goto LEnd;
    }

    fRotY = 3.14f;
    fRotX = 0.0f;

    if( FAILED( hr = pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, TRUE ) ) )
    {
        *piStepThatFailed = TESTID_SETRENDERSTATE;
        goto LEnd;
    }
    if( FAILED( hr = pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0x40404040 ) ) )
    {
        *piStepThatFailed = TESTID_SETRENDERSTATE; 
        goto LEnd;
    }

    ZeroMemory( &mtrlWhite, sizeof(D3DMATERIAL8) );
    mtrlWhite.Diffuse.r = mtrlWhite.Ambient.r = 1.0f;
    mtrlWhite.Diffuse.g = mtrlWhite.Ambient.g = 1.0f;
    mtrlWhite.Diffuse.b = mtrlWhite.Ambient.b = 1.0f;
    mtrlWhite.Diffuse.a = mtrlWhite.Ambient.a = 0.0f;

    ZeroMemory( &mtrlRed, sizeof(D3DMATERIAL8) );
    mtrlRed.Diffuse.r = mtrlRed.Ambient.r = 1.0f;
    mtrlRed.Diffuse.g = mtrlRed.Ambient.g = 0.0f;
    mtrlRed.Diffuse.b = mtrlRed.Ambient.b = 0.0f;
    mtrlRed.Diffuse.a = mtrlRed.Ambient.a = 0.0f;

    ZeroMemory( &mtrlGreen, sizeof(D3DMATERIAL8) );
    mtrlGreen.Diffuse.r = mtrlGreen.Ambient.r = 0.0f;
    mtrlGreen.Diffuse.g = mtrlGreen.Ambient.g = 1.0f;
    mtrlGreen.Diffuse.b = mtrlGreen.Ambient.b = 0.0f;
    mtrlGreen.Diffuse.a = mtrlGreen.Ambient.a = 0.0f;

    ZeroMemory( &mtrlBlue, sizeof(D3DMATERIAL8) );
    mtrlBlue.Diffuse.r = mtrlBlue.Ambient.r = 0.0f;
    mtrlBlue.Diffuse.g = mtrlBlue.Ambient.g = 0.0f;
    mtrlBlue.Diffuse.b = mtrlBlue.Ambient.b = 1.0f;
    mtrlBlue.Diffuse.a = mtrlBlue.Ambient.a = 0.0f;

    if( bUseTexture )
    {
        D3DCAPS8 d3dCaps;         

        // Load default texture in resource anDefaultTextureResource[i]
        if( FAILED( hr = D3DXCreateTextureFromResourceEx( pd3dDevice, NULL, TEXT("DIRECTX"), 
                                D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, d3dsdBackBuffer.Format, 
                                D3DPOOL_DEFAULT, D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 
                                D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 0, NULL, NULL, &pTexture ) ) )
        {
            *piStepThatFailed  = TESTID_CREATETEXTURE;
            goto LEnd;
        }

        if( FAILED( hr = pd3dDevice->GetDeviceCaps( &d3dCaps ) ) )
        {
            *piStepThatFailed  = TESTID_GETDEVICECAPS;
            goto LEnd;
        }

        if( d3dCaps.TextureFilterCaps & D3DPTFILTERCAPS_MINFLINEAR )
        {
            if (FAILED(hr = pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR )))
            {
                *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
                goto LEnd;
            }
	    }
    
        if( d3dCaps.TextureFilterCaps & D3DPTFILTERCAPS_MAGFLINEAR )
        {
            if (FAILED(hr = pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR )))
            {
                *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
                goto LEnd;
            }
        }

        if (FAILED( hr = pd3dDevice->SetTexture( 0, pTexture ) ) )
        {
            *piStepThatFailed = TESTID_SETTEXTURE; 
            goto LEnd;
        }

        if (FAILED(hr = pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP ) ) )
        {
            *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
            goto LEnd;
        }

        if (FAILED(hr = pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP ) ) )
        {
            *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
            goto LEnd;
        }

        if (FAILED(hr = pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE ) ) )
        {
            *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
            goto LEnd;
        }

        if (FAILED(hr = pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE ) ) )
        {
            *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
            goto LEnd;
        }

        if (FAILED(hr = pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE ) ) )
        {
            *piStepThatFailed = TESTID_SETTEXTURESTAGESTATE; 
            goto LEnd;
        }

        // Set color
        if( FAILED( hr = pd3dDevice->SetMaterial( &mtrlWhite ) ) )
        {
            *piStepThatFailed = TESTID_SETMATERIAL; 
            goto LEnd;
        }
    }

    if( FAILED( hr = pd3dDevice->SetVertexShader( D3DFVF_VERTEX ) ) )
    {
        *piStepThatFailed = TESTID_SETVERTEXSHADER; 
        goto LEnd;
    }

    // Here's the draw loop:
    for (i = 0; i < 600; i++)
    {
        if (PeekMessage(&msg, hwnd, WM_KEYDOWN, WM_KEYDOWN, PM_REMOVE))
        {
            *piStepThatFailed = TESTID_USER_CANCELLED;
            goto LEnd;
        }

        if( FAILED( hr = pd3dDevice->TestCooperativeLevel() ) )
        {
            *piStepThatFailed = TESTID_USER_CANCELLED;
            goto LEnd;
        }

        // Build world matrix
        D3DXMatrixRotationY( &matRotY, fRotY );
        D3DXMatrixRotationX( &matRotX, fRotX );
        D3DXMatrixMultiply( &mat, &matRotY, &matRotX );

        if( FAILED( hr = pd3dDevice->SetTransform( D3DTS_WORLD, &mat ) ) )
        {
            *piStepThatFailed = TESTID_SETTRANSFORM;
            goto LEnd;
        }

        // Clear the backbuffer
        if (FAILED(hr = pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET,
                                           0x00000000, 1.0f, 0L )))
        {
            *piStepThatFailed = TESTID_VIEWPORT_CLEAR;
            goto LEnd;
        }

        // Begin the scene
        if( FAILED(hr = pd3dDevice->BeginScene() ) )
        {
            *piStepThatFailed = TESTID_BEGINSCENE;
            goto LEnd;
        }

        // Green, Front/Back
        if( FAILED( hr = DrawTwoSides( bUseTexture, pd3dDevice, &mtrlGreen, 
                                       pVBFront, pIBFront, pVBBack, pIBBack, 
                                       piStepThatFailed ) ) ) 
            goto LEnd;


        // Red, Left/Right
        if( FAILED( hr = DrawTwoSides( bUseTexture, pd3dDevice, &mtrlRed, 
                                       pVBLeft, pIBLeft, pVBRight, pIBRight, 
                                       piStepThatFailed ) ) ) 
            goto LEnd;

        // Blue, Top/Bottom
        if( FAILED( hr = DrawTwoSides( bUseTexture, pd3dDevice, &mtrlBlue, 
                                       pVBTop, pIBTop, pVBBottom, pIBBottom, 
                                       piStepThatFailed ) ) ) 
            goto LEnd;

        // End the scene.
        if (FAILED(hr = pd3dDevice->EndScene()))
        {
            *piStepThatFailed = TESTID_ENDSCENE;
            goto LEnd;
        }

        if (FAILED(hr = pd3dDevice->Present( NULL, NULL, NULL, NULL ) ) )
        {
            *piStepThatFailed = TESTID_PRESENT;
            goto LEnd;
        }

        fRotY += 0.05f;
        fRotX += 0.02f;

        Sleep(10);
    }

LEnd:
    ShowCursor(TRUE);
    ReleasePpo(&pTexture);
    ReleasePpo(&pVBFront);
    ReleasePpo(&pIBFront);
    ReleasePpo(&pVBBack);
    ReleasePpo(&pIBBack);
    ReleasePpo(&pVBLeft);
    ReleasePpo(&pIBLeft);
    ReleasePpo(&pVBRight);
    ReleasePpo(&pIBRight);
    ReleasePpo(&pVBTop);
    ReleasePpo(&pIBTop);
    ReleasePpo(&pVBBottom);
    ReleasePpo(&pIBBottom);
    ReleasePpo(&pBackBuffer);
    ReleasePpo(&pd3dDevice);
    if (hwnd != NULL)
        SendMessage(hwnd, WM_CLOSE, 0, 0);

    return hr;
}




//-----------------------------------------------------------------------------
// Name: CreateTestWindow()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CreateTestWindow(HWND hwndMain, HWND* phwnd)
{
    static BOOL bClassRegistered = FALSE;
    WNDCLASS wndClass;
    TCHAR* pszClass = TEXT("DxDiag D3D8 Test Window"); // Don't need to localize
    HINSTANCE hInst = (HINSTANCE)GetWindowLongPtr(hwndMain, GWLP_HINSTANCE);
    TCHAR szTitle[MAX_PATH];

    if (!bClassRegistered)
    {
        ZeroMemory(&wndClass, sizeof(wndClass));
        wndClass.style = CS_HREDRAW | CS_VREDRAW;
        wndClass.lpfnWndProc = DefWindowProc;
        wndClass.cbClsExtra = 0;
        wndClass.cbWndExtra = 0;
        wndClass.hInstance = hInst;
        wndClass.hIcon = NULL;
        wndClass.hCursor = NULL;
        wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wndClass.lpszMenuName = NULL;
        wndClass.lpszClassName = pszClass;
        if (NULL == RegisterClass(&wndClass))
            return E_FAIL;
        bClassRegistered = TRUE;
    }

    LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
    *phwnd = CreateWindow( pszClass, szTitle, WS_OVERLAPPED, 
                           0, 0, 0, 0, hwndMain, NULL, hInst, NULL);
    if (*phwnd == NULL)
        return E_FAIL;

    ShowWindow(*phwnd, SW_SHOW);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SortModesCallback()
// Desc: Callback function for sorting display modes (used by BuildDeviceList).
//-----------------------------------------------------------------------------
static int SortModesCallback( const VOID* arg1, const VOID* arg2 )
{
    D3DDISPLAYMODE* p1 = (D3DDISPLAYMODE*)arg1;
    D3DDISPLAYMODE* p2 = (D3DDISPLAYMODE*)arg2;

    if( p1->Format > p2->Format )   return -1;
    if( p1->Format < p2->Format )   return +1;
    if( p1->Width  < p2->Width )    return -1;
    if( p1->Width  > p2->Width )    return +1;
    if( p1->Height < p2->Height )   return -1;
    if( p1->Height > p2->Height )   return +1;

    return 0;
}




//-----------------------------------------------------------------------------
// Name: SelectModeAndFormat()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT SelectModeAndFormat( DisplayInfo* pDisplayInfo, IDirect3D8* pD3D8, 
                             D3DModeInfo* pSelectedMode, D3DDEVTYPE* pSelectedDeviceType )
{
    // Enumerate all display modes on this adapter
    HRESULT        hr;
    D3DDISPLAYMODE modes[MAX_MODES];
    D3DFORMAT      formats[MAX_FORMATS];
    DWORD          dwBehavior[MAX_FORMATS];
    D3DModeInfo    confirmedModes[MAX_CONFIRMED_MODES];   

    ZeroMemory( pSelectedMode, sizeof(D3DModeInfo) );

    DWORD dwNumConfirmedModes   = 0;   
    DWORD dwNumFormats          = 0;
    DWORD dwNumModes            = 0;
    DWORD dwNumAdapterModes     = pD3D8->GetAdapterModeCount( pDisplayInfo->m_iAdapter );
    DWORD dwBestMatchMode       = 0;

    for( UINT iMode = 0; iMode < dwNumAdapterModes; iMode++ )
    {
        // Get the display mode attributes
        D3DDISPLAYMODE DisplayMode;
        if( FAILED( hr = pD3D8->EnumAdapterModes( pDisplayInfo->m_iAdapter, iMode, &DisplayMode ) ) )
        {
            pDisplayInfo->m_testResultD3D8.m_iStepThatFailed = TESTID_ENUMADAPTERMODES;
            pDisplayInfo->m_testResultD3D8.m_hr = hr;
            return hr;
        }

        // Check if the mode already exists (to filter out refresh rates)
        for( DWORD m=0L; m<dwNumModes; m++ )
        {
            if( ( modes[m].Width  == DisplayMode.Width  ) &&
                ( modes[m].Height == DisplayMode.Height ) &&
                ( modes[m].Format == DisplayMode.Format ) )
                break;
        }

        // If we found a new mode, add it to the list of modes
        if( m == dwNumModes )
        {
            modes[dwNumModes].Width       = DisplayMode.Width;
            modes[dwNumModes].Height      = DisplayMode.Height;
            modes[dwNumModes].Format      = DisplayMode.Format;
            modes[dwNumModes].RefreshRate = 0;
            dwNumModes++;

            // Check if the mode's format already exists
            for( DWORD f=0; f<dwNumFormats; f++ )
            {
                if( DisplayMode.Format == formats[f] )
                    break;
            }

            // If the format is new, add it to the list
            if( f== dwNumFormats )
                formats[dwNumFormats++] = DisplayMode.Format;
        }

        if( dwNumFormats == MAX_FORMATS || dwNumModes == MAX_MODES )
            break;
    }

    // Sort the list of display modes (by format, then width, then height)
    qsort( modes, dwNumModes, sizeof(D3DDISPLAYMODE), SortModesCallback );

    const DWORD dwNumDeviceTypes = 2;
    const D3DDEVTYPE DeviceTypes[] = { D3DDEVTYPE_HAL, D3DDEVTYPE_SW };

    // Add devices to adapter
    for( UINT iDevice = 0; iDevice < dwNumDeviceTypes; iDevice++ )
    {
        // Fill in device info
        D3DCAPS8 d3dCaps;         
        if( FAILED( hr = pD3D8->GetDeviceCaps( pDisplayInfo->m_iAdapter, DeviceTypes[iDevice], &d3dCaps ) ) )
        {
            pDisplayInfo->m_testResultD3D8.m_iStepThatFailed = TESTID_GETDEVICECAPS;
            pDisplayInfo->m_testResultD3D8.m_hr = hr;
            return hr;
        }

        // Examine each format supported by the adapter 
        for( DWORD f=0; f<dwNumFormats; f++ )
        {
            // Skip formats that cannot be used as render targets on this device
            if( FAILED( pD3D8->CheckDeviceType( pDisplayInfo->m_iAdapter, DeviceTypes[iDevice],
                                                formats[f], formats[f], FALSE ) ) )
                continue;

            // Figure out the behavior
            if( d3dCaps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT )
            {
                if( d3dCaps.DevCaps & D3DDEVCAPS_PUREDEVICE )
                {
                    dwBehavior[f] = D3DCREATE_HARDWARE_VERTEXPROCESSING |
                                    D3DCREATE_PUREDEVICE;
                }
                else
                {
                    dwBehavior[f] = D3DCREATE_HARDWARE_VERTEXPROCESSING;
                }
            }
            else
            {
                dwBehavior[f] = D3DCREATE_SOFTWARE_VERTEXPROCESSING;
            }
        }

        // Add all enumerated display modes with confirmed formats to the
        // device's list of valid modes
        for( DWORD m=0L; m<dwNumModes; m++ )
        {
            for( DWORD f=0; f<dwNumFormats; f++ )
            {
                if( modes[m].Format == formats[f] )
                {
                    // Add this mode to the device's list of valid modes
                    confirmedModes[dwNumConfirmedModes].Width      = modes[m].Width;
                    confirmedModes[dwNumConfirmedModes].Height     = modes[m].Height;
                    confirmedModes[dwNumConfirmedModes].Format     = modes[m].Format;
                    confirmedModes[dwNumConfirmedModes].dwBehavior = dwBehavior[f];
                    dwNumConfirmedModes++;
                }
            }
        }

        // Select any 640x480 mode for default (but prefer a 16-bit mode)
        for( m=0; m<dwNumConfirmedModes; m++ )
        {
            if( confirmedModes[m].Width==640 && confirmedModes[m].Height==480 )
            {
                dwBestMatchMode = m;
                if( confirmedModes[m].Format == D3DFMT_R5G6B5 ||
                    confirmedModes[m].Format == D3DFMT_X1R5G5B5 ||
                    confirmedModes[m].Format == D3DFMT_A1R5G5B5 )
                {
                    break;
                }
            }
        }

        // If valid modes were found then stop and use this device
        if( dwNumConfirmedModes > 0 )
            break;
    }

    if( dwNumConfirmedModes > 0 )
    {
        *pSelectedDeviceType = DeviceTypes[iDevice];
        *pSelectedMode = confirmedModes[dwBestMatchMode];
        return S_OK;
    }
    else
    {
        pDisplayInfo->m_testResultD3D8.m_iStepThatFailed = TESTID_NOMODEFOUND;
        pDisplayInfo->m_testResultD3D8.m_hr = E_FAIL;
        return E_FAIL;
    }
}




//-----------------------------------------------------------------------------
// Name: InitVertexBuffer()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT InitVertexBuffer( IDirect3DDevice8* pd3dDevice, const D3DVERTEX* vertexArray, 
                          DWORD dwNumVertices, LPDIRECT3DVERTEXBUFFER8* ppVB, 
                          LONG* piStepThatFailed )
{
    HRESULT hr = S_OK;
    DWORD   i;
    D3DVERTEX* vVertex = NULL;

    if( FAILED( hr = pd3dDevice->CreateVertexBuffer( dwNumVertices*sizeof(D3DVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_VERTEX,
                                                  D3DPOOL_MANAGED, ppVB ) ) )
    {
        *piStepThatFailed  = TESTID_CREATE_VERTEX_BUFFER;
        goto LEnd;
    }
    if( *ppVB == NULL )
    {
        *piStepThatFailed  = TESTID_CREATE_VERTEX_BUFFER;
        hr = E_POINTER;
        goto LEnd;
    }

    if( FAILED( hr = (*ppVB)->Lock( 0, 0, (BYTE**)&vVertex, 0 ) ) )
    {
        *piStepThatFailed  = TESTID_LOCK;
        goto LEnd;
    }
    if( vVertex == NULL )
    {
        *piStepThatFailed  = TESTID_LOCK;
        goto LEnd;
    }

    for( i=0; i<dwNumVertices; i++ )
        vVertex[i] = vertexArray[i];

    if( FAILED( hr = (*ppVB)->Unlock() ) )
    {
        *piStepThatFailed = TESTID_UNLOCK;
        goto LEnd;
    }

LEnd:
    return hr;
}




//-----------------------------------------------------------------------------
// Name: InitIndexBuffer()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT InitIndexBuffer( IDirect3DDevice8* pd3dDevice, const WORD* wIndexArray, 
                         DWORD dwNumIndices, LPDIRECT3DINDEXBUFFER8* ppIB, 
                         LONG* piStepThatFailed )
{
    HRESULT hr = S_OK;
    DWORD   i;
    WORD*   pwIndices = NULL;

    if( FAILED( hr = pd3dDevice->CreateIndexBuffer( dwNumIndices*sizeof(WORD),
                                                    D3DUSAGE_WRITEONLY, D3DFMT_INDEX16,
                                                    D3DPOOL_MANAGED, ppIB ) ) )
    {
        *piStepThatFailed  = TESTID_CREATE_INDEX_BUFFER;
        goto LEnd;
    }
    if( *ppIB == NULL )
    {
        *piStepThatFailed  = TESTID_CREATE_INDEX_BUFFER;
        hr = E_POINTER;
        goto LEnd;
    }

    if( FAILED( hr = (*ppIB)->Lock( 0, dwNumIndices*sizeof(WORD), (BYTE**) &pwIndices, 0 ) ) )
    {
        *piStepThatFailed  = TESTID_LOCK;
        goto LEnd;
    }
    if( pwIndices == NULL )
    {
        *piStepThatFailed  = TESTID_LOCK;
        goto LEnd;
    }

    for( i=0; i<dwNumIndices; i++ )
        *pwIndices++ = wIndexArray[i];

    if( FAILED( hr = (*ppIB)->Unlock() ) )
    {
        *piStepThatFailed = TESTID_UNLOCK;
        goto LEnd;
    }

LEnd:
    return hr;
}




//-----------------------------------------------------------------------------
// Name: DrawTwoSides()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DrawTwoSides( BOOL bUseTexture, IDirect3DDevice8* pd3dDevice, D3DMATERIAL8* pMtrl, 
                      LPDIRECT3DVERTEXBUFFER8 pVB1, LPDIRECT3DINDEXBUFFER8 pIB1, 
                      LPDIRECT3DVERTEXBUFFER8 pVB2, LPDIRECT3DINDEXBUFFER8 pIB2, 
                      LONG* piStepThatFailed )
{   
    HRESULT hr;

    if( !bUseTexture )
    {
        // Set color
        if( FAILED( hr = pd3dDevice->SetMaterial( pMtrl ) ) )
        {
            *piStepThatFailed = TESTID_SETMATERIAL; 
            goto LEnd;
        }
    }

    // #1
    if( FAILED( hr = pd3dDevice->SetStreamSource( 0, pVB1, sizeof(D3DVERTEX) ) ) )
    {
        *piStepThatFailed = TESTID_SETSTREAMSOURCE; 
        goto LEnd;
    }

    if( FAILED( hr = pd3dDevice->SetIndices( pIB1, 0 ) ) )
    {
        *piStepThatFailed = TESTID_SETINDICES; 
        goto LEnd;
    }

    if( FAILED( hr = pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, 4, 0, 2 ) ) )
    {
        *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE; 
        goto LEnd;
    }

    // #2
    if( FAILED( hr = pd3dDevice->SetStreamSource( 0, pVB2, sizeof(D3DVERTEX) ) ) ) 
    {
        *piStepThatFailed = TESTID_SETSTREAMSOURCE; 
        goto LEnd;
    }

    if( FAILED( hr = pd3dDevice->SetIndices( pIB2, 0 ) ) )
    {
        *piStepThatFailed = TESTID_SETINDICES; 
        goto LEnd;
    }

    if( FAILED( hr = pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, 4, 0, 2 ) ) )
    {
        *piStepThatFailed = TESTID_DRAW_INDEXED_PRIMITIVE; 
        goto LEnd;
    }

LEnd:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\testdd.cpp ===
/****************************************************************************
 *
 *    File: testdd.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Test DirectDraw functionality on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <Windows.h>
#define DIRECTDRAW_VERSION 5 // run on DX5 and later versions
#include <ddraw.h>
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h"
#include "testdd.h"
#include "resource.h"

#ifndef ReleasePpo
    #define ReleasePpo(ppo) \
        if (*(ppo) != NULL) \
        { \
            (*(ppo))->Release(); \
            *(ppo) = NULL; \
        } \
        else (VOID)0
#endif

enum TESTID
{
    TESTID_LOAD_DDRAW_DLL= 1,
    TESTID_GET_DIRECTDRAWCREATE,
    TESTID_DIRECTDRAWCREATE,
    TESTID_GETCAPS,
    TESTID_USER_VERIFY_RECTANGLES,
    TESTID_USER_VERIFY_WINDOW_BOUNCE,
    TESTID_USER_VERIFY_FULLSCREEN_BOUNCE,
    TESTID_SETCOOPERATIVELEVEL_NORMAL,
    TESTID_CREATEPRIMARYSURFACE,
    TESTID_GETPRIMARYSURFACEDESC,
    TESTID_COLORFILL_BLT_TO_PRIMARY,
    TESTID_CREATE_OFFSCREENPLAIN_SURFACE,
    TESTID_COLORFILL_BLT_TO_OFFSCREENPLAIN,
    TESTID_BLT_OFFSCREENPLAIN_TO_FRONT,
    TESTID_CREATE_TEST_WINDOW,
    TESTID_SETCOOPERATIVELEVEL_FULLSCREEN,
    TESTID_SETDISPLAYMODE,
    TESTID_CREATEPRIMARYSURFACE_FLIP_ONEBACK,
    TESTID_GETATTACHEDSURFACE,
    TESTID_COLORFILL_TO_BACKBUFFER,
    TESTID_FLIP,
};

typedef HRESULT (WINAPI* LPDIRECTDRAWCREATE)(GUID FAR *lpGUID,
    LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter);


BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish = FALSE); // from main.cpp (yuck)


static HRESULT TestPrimary(HWND hwndMain, LPDIRECTDRAW pdd, LONG* piStepThatFailed);
static HRESULT TestPrimaryBlt(HWND hwndMain, LPDIRECTDRAW pdd, LONG* piStepThatFailed);
static HRESULT TestFullscreen(HWND hwndMain, LPDIRECTDRAW pdd, LONG* piStepThatFailed);
static HRESULT CreateTestWindow(HWND hwndMain, HWND* phwnd);


/****************************************************************************
 *
 *  TestDD
 *
 ****************************************************************************/
VOID TestDD(HWND hwndMain, DisplayInfo* pDisplayInfo)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];
    HINSTANCE hInstDDraw = NULL;
    LPDIRECTDRAWCREATE pDDCreate;
    LPDIRECTDRAW pdd = NULL;
    TCHAR sz[300];
    TCHAR szTitle[100];

    LoadString(NULL, IDS_STARTDDTEST, sz, 300);
    LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);

    if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
        return;

    // Remove info from any previous test:
    ZeroMemory(&pDisplayInfo->m_testResultDD, sizeof(TestResult));

    pDisplayInfo->m_testResultDD.m_bStarted = TRUE;

    // Load ddraw.dll
    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\ddraw.dll"));
    hInstDDraw = LoadLibrary(szPath);
    if (hInstDDraw == NULL)
    {
        pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_LOAD_DDRAW_DLL;
        pDisplayInfo->m_testResultDD.m_hr = DDERR_NOTFOUND;
        goto LEnd;
    }

    // Get DirectDrawCreate entry point
    pDDCreate = (LPDIRECTDRAWCREATE)GetProcAddress(hInstDDraw, "DirectDrawCreate");
    if (pDDCreate == NULL)
    {
        pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_GET_DIRECTDRAWCREATE;
        pDisplayInfo->m_testResultDD.m_hr = DDERR_NOTFOUND;
        goto LEnd;
    }
        
    // Call DirectDrawCreate
    if (FAILED(hr = pDDCreate(&pDisplayInfo->m_guid, &pdd, NULL)))
    {
        pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_DIRECTDRAWCREATE;
        pDisplayInfo->m_testResultDD.m_hr = hr;
        goto LEnd;
    }

    // Get DirectDraw caps
    DDCAPS ddcaps;
    DDCAPS ddcaps2;
    ddcaps.dwSize = sizeof(ddcaps);
    ddcaps2.dwSize = sizeof(ddcaps2);
    if (FAILED(hr = pdd->GetCaps(&ddcaps, &ddcaps2)))
    {
        pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_GETCAPS;
        pDisplayInfo->m_testResultDD.m_hr = hr;
        goto LEnd;
    }
    ReleasePpo(&pdd);

    if (!pDisplayInfo->m_bCanRenderWindow)
    {
        LoadString(NULL, IDS_SKIPWINDOWED, sz, 300);
        MessageBox(hwndMain, sz, szTitle, MB_OK);
    }
    else
    {
        // First test
        LoadString(NULL, IDS_DDTEST1, sz, 300);
        if (IDCANCEL == MessageBox(hwndMain, sz, szTitle, MB_OKCANCEL))
        {
            pDisplayInfo->m_testResultDD.m_bCancelled = TRUE;
            goto LEnd;
        }
        if (FAILED(hr = pDDCreate(&pDisplayInfo->m_guid, &pdd, NULL)))
        {
            pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_DIRECTDRAWCREATE;
            pDisplayInfo->m_testResultDD.m_hr = hr;
            goto LEnd;
        }
        if (FAILED(hr = TestPrimary(hwndMain, pdd, &pDisplayInfo->m_testResultDD.m_iStepThatFailed)))
        {
            pDisplayInfo->m_testResultDD.m_hr = hr;
            goto LEnd;
        }
        ReleasePpo(&pdd);
        LoadString(NULL, IDS_CONFIRMDDTEST1, sz, 300);
        if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
        {
            pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_USER_VERIFY_RECTANGLES;
            pDisplayInfo->m_testResultDD.m_hr = S_OK;
            goto LEnd;
        }

        // Second test
        LoadString(NULL, IDS_DDTEST2, sz, 300);
        if (IDCANCEL == MessageBox(hwndMain, sz, szTitle, MB_OKCANCEL))
        {
            pDisplayInfo->m_testResultDD.m_bCancelled = TRUE;
            goto LEnd;
        }
        if (FAILED(hr = pDDCreate(&pDisplayInfo->m_guid, &pdd, NULL)))
        {
            pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_DIRECTDRAWCREATE;
            pDisplayInfo->m_testResultDD.m_hr = hr;
            goto LEnd;
        }
        if (FAILED(hr = TestPrimaryBlt(hwndMain, pdd, &pDisplayInfo->m_testResultDD.m_iStepThatFailed)))
        {
            pDisplayInfo->m_testResultDD.m_hr = hr;
            goto LEnd;
        }
        ReleasePpo(&pdd);
        LoadString(NULL, IDS_CONFIRMDDTEST2, sz, 300);
        if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
        {
            pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_USER_VERIFY_WINDOW_BOUNCE;
            pDisplayInfo->m_testResultDD.m_hr = S_OK;
        }
    }

    // Third test
    LoadString(NULL, IDS_DDTEST3, sz, 300);
    if (IDCANCEL == MessageBox(hwndMain, sz, szTitle, MB_OKCANCEL))
    {
        pDisplayInfo->m_testResultDD.m_bCancelled = TRUE;
        goto LEnd;
    }
    if (FAILED(hr = pDDCreate(&pDisplayInfo->m_guid, &pdd, NULL)))
    {
        pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_DIRECTDRAWCREATE;
        pDisplayInfo->m_testResultDD.m_hr = hr;
        goto LEnd;
    }
    POINT ptMouse;
    GetCursorPos(&ptMouse);
    if (FAILED(hr = TestFullscreen(hwndMain, pdd, &pDisplayInfo->m_testResultDD.m_iStepThatFailed)))
    {
        pDisplayInfo->m_testResultDD.m_hr = hr;
        goto LEnd;
    }
    SetCursorPos( ptMouse.x, ptMouse.y );
    ReleasePpo(&pdd);
    LoadString(NULL, IDS_CONFIRMDDTEST3, sz, 300);
    if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
    {
        pDisplayInfo->m_testResultDD.m_iStepThatFailed = TESTID_USER_VERIFY_FULLSCREEN_BOUNCE;
        pDisplayInfo->m_testResultDD.m_hr = S_OK;
        goto LEnd;
    }

    LoadString(NULL, IDS_ENDDDTESTS, sz, 300);
    MessageBox(hwndMain, sz, szTitle, MB_OK);

LEnd:
    ReleasePpo(&pdd);
    if (hInstDDraw != NULL)
        FreeLibrary(hInstDDraw);
    if (pDisplayInfo->m_testResultDD.m_bCancelled)
    {
        LoadString(NULL, IDS_TESTSCANCELLED, sz, 300);
        lstrcpy(pDisplayInfo->m_testResultDD.m_szDescription, sz);

        LoadString(NULL, IDS_TESTSCANCELLED_ENGLISH, sz, 300);
        lstrcpy(pDisplayInfo->m_testResultDD.m_szDescription, sz);
    }
    else
    {
        if (pDisplayInfo->m_testResultDD.m_iStepThatFailed == 0)
        {
            LoadString(NULL, IDS_TESTSSUCCESSFUL, sz, 300);
            lstrcpy(pDisplayInfo->m_testResultDD.m_szDescription, sz);

            LoadString(NULL, IDS_TESTSSUCCESSFUL_ENGLISH, sz, 300);
            lstrcpy(pDisplayInfo->m_testResultDD.m_szDescriptionEnglish, sz);
        }
        else
        {
            TCHAR szDesc[300];
            TCHAR szError[300];
            if (0 == LoadString(NULL, IDS_FIRSTDDTESTERROR + pDisplayInfo->m_testResultDD.m_iStepThatFailed - 1,
                szDesc, 300))
            {
                LoadString(NULL, IDS_UNKNOWNERROR, sz, 300);
                lstrcpy(szDesc, sz);
            }
            LoadString(NULL, IDS_FAILUREFMT, sz, 300);
            BTranslateError(pDisplayInfo->m_testResultDD.m_hr, szError);
            wsprintf(pDisplayInfo->m_testResultDD.m_szDescription, sz,
                pDisplayInfo->m_testResultDD.m_iStepThatFailed,
                szDesc, pDisplayInfo->m_testResultDD.m_hr, szError);

            // Nonlocalized version:
            if (0 == LoadString(NULL, IDS_FIRSTDDTESTERROR_ENGLISH + pDisplayInfo->m_testResultDD.m_iStepThatFailed - 1,
                szDesc, 300))
            {
                LoadString(NULL, IDS_UNKNOWNERROR_ENGLISH, sz, 300);
                lstrcpy(szDesc, sz);
            }
            LoadString(NULL, IDS_FAILUREFMT_ENGLISH, sz, 300);
            BTranslateError(pDisplayInfo->m_testResultDD.m_hr, szError, TRUE);
            wsprintf(pDisplayInfo->m_testResultDD.m_szDescriptionEnglish, sz,
                pDisplayInfo->m_testResultDD.m_iStepThatFailed,
                szDesc, pDisplayInfo->m_testResultDD.m_hr, szError);
        }
    }
}


/****************************************************************************
 *
 *  TestPrimary
 *
 ****************************************************************************/
HRESULT TestPrimary(HWND hwndMain, LPDIRECTDRAW pdd, LONG* piStepThatFailed)
{
    HRESULT hr = S_OK;
    DDSURFACEDESC ddsd;
    LPDIRECTDRAWSURFACE pdds = NULL;
    RECT rc;

    if (FAILED(hr = pdd->SetCooperativeLevel(NULL, DDSCL_NORMAL)))
    {
        *piStepThatFailed = TESTID_SETCOOPERATIVELEVEL_NORMAL;
        goto LEnd;
    }

    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
    if (FAILED(hr = pdd->CreateSurface(&ddsd, &pdds, NULL)))
    {
        *piStepThatFailed = TESTID_CREATEPRIMARYSURFACE;
        goto LEnd;
    }
    ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
    if (FAILED(hr = pdds->GetSurfaceDesc(&ddsd)))
    {
        *piStepThatFailed = TESTID_GETPRIMARYSURFACEDESC;
        goto LEnd;
    }
    SetRect(&rc, 0, 0, ddsd.dwWidth, ddsd.dwHeight);
    InflateRect(&rc, -64, -64);

    DDBLTFX ddbltfx;
    ZeroMemory(&ddbltfx, sizeof(ddbltfx));
    ddbltfx.dwSize = sizeof(ddbltfx);
    while (rc.right > rc.left + 2 && rc.bottom > rc.top + 2)
    {
        ddbltfx.dwFillColor = ~ddbltfx.dwFillColor;
        if (FAILED(hr = pdds->Blt(&rc, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
        {
            *piStepThatFailed = TESTID_COLORFILL_BLT_TO_PRIMARY;
            goto LEnd;
        }
        InflateRect(&rc, -4, -4);
    }

    // Give the user a moment to verify the test pattern
    Sleep(2000);

    // Clean up affected screen area in case this display isn't part of the desktop:
    ddbltfx.dwFillColor = 0;
    if (FAILED(hr = pdds->Blt(NULL, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
    {
        *piStepThatFailed = TESTID_COLORFILL_BLT_TO_PRIMARY;
        goto LEnd;
    }

LEnd:
    ReleasePpo(&pdds);
    InvalidateRect(NULL, NULL, FALSE); // repaint desktop
    return hr;
}


/****************************************************************************
 *
 *  TestPrimaryBlt
 *
 ****************************************************************************/
HRESULT TestPrimaryBlt(HWND hwndMain, LPDIRECTDRAW pdd, LONG* piStepThatFailed)
{
    HRESULT hr = S_OK;
    DDSURFACEDESC ddsd;
    LPDIRECTDRAWSURFACE pddsFront = NULL;
    LPDIRECTDRAWSURFACE pddsBack = NULL;
    RECT rc;
    RECT rcDest;
    RECT rcScreen;
    DDBLTFX ddbltfx;
    INT i;
    LONG xv = 1;
    LONG yv = 2;

    if (FAILED(hr = pdd->SetCooperativeLevel(NULL, DDSCL_NORMAL)))
    {
        *piStepThatFailed = TESTID_SETCOOPERATIVELEVEL_NORMAL;
        goto LEnd;
    }

    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
    if (FAILED(hr = pdd->CreateSurface(&ddsd, &pddsFront, NULL)))
    {
        *piStepThatFailed = TESTID_CREATEPRIMARYSURFACE;
        goto LEnd;
    }
    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT;
    if (FAILED(hr = pddsFront->GetSurfaceDesc(&ddsd)))
    {
        *piStepThatFailed = TESTID_GETPRIMARYSURFACEDESC;
        goto LEnd;
    }
    SetRect(&rcScreen, 0, 0, ddsd.dwWidth, ddsd.dwHeight);

    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
    ddsd.dwWidth = 200;
    ddsd.dwHeight = 200;
    if (FAILED(hr = pdd->CreateSurface(&ddsd, &pddsBack, NULL)))
    {
        *piStepThatFailed = TESTID_CREATE_OFFSCREENPLAIN_SURFACE;
        goto LEnd;
    }

    SetRect(&rc, 0, 0, 32, 32);
    OffsetRect(&rc, 10, 35);

    ZeroMemory(&ddbltfx, sizeof(ddbltfx));
    ddbltfx.dwSize = sizeof(ddbltfx);
    for (i = 0; i < 200; i++)
    {
        ddbltfx.dwFillColor = 0;
        if (FAILED(hr = pddsBack->Blt(NULL, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
        {
            *piStepThatFailed = TESTID_COLORFILL_BLT_TO_OFFSCREENPLAIN;
            goto LEnd;
        }
        OffsetRect(&rc, xv, yv);
        if (rc.left < 2 && xv < 0 || rc.right > 198 && xv > 0)
            xv = -xv;
        if (rc.top < 2 && yv < 0 || rc.bottom > 198 && yv > 0)
            yv = -yv;
        ddbltfx.dwFillColor = 0xffffffff;
        if (FAILED(hr = pddsBack->Blt(&rc, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
        {
            *piStepThatFailed = TESTID_COLORFILL_BLT_TO_OFFSCREENPLAIN;
            goto LEnd;
        }
        SetRect(&rcDest, 0, 0, 200, 200);
        OffsetRect(&rcDest, (rcScreen.right - 200) / 2, (rcScreen.bottom - 200) / 2);
        if (FAILED(hr = pddsFront->Blt(&rcDest, pddsBack, NULL, DDBLT_WAIT, NULL)))
        {
            *piStepThatFailed = TESTID_BLT_OFFSCREENPLAIN_TO_FRONT;
            goto LEnd;
        }
        Sleep(2);
    }

    // Clean up affected screen area in case this display isn't part of the desktop:
    ddbltfx.dwFillColor = 0;
    if (FAILED(hr = pddsFront->Blt(&rc, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
    {
        *piStepThatFailed = TESTID_COLORFILL_BLT_TO_PRIMARY;
        goto LEnd;
    }

LEnd:
    InvalidateRect(NULL, NULL, FALSE); // repaint desktop
    ReleasePpo(&pddsBack);
    ReleasePpo(&pddsFront);
    return hr;
}


/****************************************************************************
 *
 *  TestFullscreen
 *
 ****************************************************************************/
HRESULT TestFullscreen(HWND hwndMain, LPDIRECTDRAW pdd, LONG* piStepThatFailed)
{
    HRESULT hr;
    HWND hwnd = NULL;
    DDSURFACEDESC ddsd;
    LPDIRECTDRAWSURFACE pddsFront = NULL;
    LPDIRECTDRAWSURFACE pddsBack = NULL;
    RECT rc;
    RECT rcScreen;
    DDBLTFX ddbltfx;
    BOOL bDisplayModeSet = FALSE;
    INT i;
    LONG xv = 1;
    LONG yv = 2;

    ShowCursor(FALSE);

    if (FAILED(hr = CreateTestWindow(hwndMain, &hwnd)))
    {
        *piStepThatFailed = TESTID_CREATE_TEST_WINDOW;
        goto LEnd;
    }

    if (FAILED(hr = pdd->SetCooperativeLevel(hwnd, 
        DDSCL_ALLOWREBOOT | DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN)))
    {
        *piStepThatFailed = TESTID_SETCOOPERATIVELEVEL_FULLSCREEN;
        goto LEnd;
    }

    if (FAILED(hr = pdd->SetDisplayMode(640, 480, 16)))
    {
        TCHAR szMessage[300];
        TCHAR szTitle[100];
        pdd->SetCooperativeLevel(hwnd, DDSCL_NORMAL);
        SendMessage(hwnd, WM_CLOSE, 0, 0);
        LoadString(NULL, IDS_SETDISPLAYMODEFAILED, szMessage, 300);
        LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);
        MessageBox(hwndMain, szMessage, szTitle, MB_OK);
        *piStepThatFailed = TESTID_SETDISPLAYMODE;
        goto LEnd;
    }
    bDisplayModeSet = TRUE;

    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS | DDSD_BACKBUFFERCOUNT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_FLIP | DDSCAPS_COMPLEX;
    ddsd.dwBackBufferCount = 1;
    if (FAILED(hr = pdd->CreateSurface(&ddsd, &pddsFront, NULL)))
    {
        *piStepThatFailed = TESTID_CREATEPRIMARYSURFACE_FLIP_ONEBACK;
        goto LEnd;
    }
    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT;
    if (FAILED(hr = pddsFront->GetSurfaceDesc(&ddsd)))
    {
        *piStepThatFailed = TESTID_GETPRIMARYSURFACEDESC;
        goto LEnd;
    }
    SetRect(&rcScreen, 0, 0, ddsd.dwWidth, ddsd.dwHeight);

    ZeroMemory(&ddbltfx, sizeof(ddbltfx));
    ddbltfx.dwSize = sizeof(ddbltfx);

    DDSCAPS ddscaps;
    ddscaps.dwCaps = DDSCAPS_BACKBUFFER;
    if (FAILED(hr = pddsFront->GetAttachedSurface(&ddscaps, &pddsBack)))
    {
        *piStepThatFailed = TESTID_GETATTACHEDSURFACE;
        goto LEnd;
    }

    SetRect(&rc, 0, 0, 32, 32);
    OffsetRect(&rc, 10, 35);

    ZeroMemory(&ddbltfx, sizeof(ddbltfx));
    ddbltfx.dwSize = sizeof(ddbltfx);
    for (i = 0; i < 200; i++)
    {
        ddbltfx.dwFillColor = 0;
        if (FAILED(hr = pddsBack->Blt(NULL, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
        {
            *piStepThatFailed = TESTID_COLORFILL_TO_BACKBUFFER;
            goto LEnd;
        }
        OffsetRect(&rc, xv, yv);
        if (rc.left < 2 && xv < 0 || rc.right > 198 && xv > 0)
            xv = -xv;
        if (rc.top < 2 && yv < 0 || rc.bottom > 198 && yv > 0)
            yv = -yv;
        OffsetRect(&rc, (rcScreen.right - 200) / 2, (rcScreen.bottom - 200) / 2);
        ddbltfx.dwFillColor = 0xffffffff;
        if (FAILED(hr = pddsBack->Blt(&rc, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
        {
            *piStepThatFailed = TESTID_COLORFILL_TO_BACKBUFFER;
            goto LEnd;
        }
        OffsetRect(&rc, -(rcScreen.right - 200) / 2, -(rcScreen.bottom - 200) / 2);
        if (FAILED(hr = pddsFront->Flip(NULL, DDFLIP_WAIT)))
        {
            *piStepThatFailed = TESTID_FLIP;
            goto LEnd;
        }
        Sleep(2);
    }

    ddbltfx.dwFillColor = 0;
    if (FAILED(hr = pddsFront->Blt(&rc, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx)))
    {
        *piStepThatFailed = TESTID_COLORFILL_BLT_TO_PRIMARY;
        goto LEnd;
    }

LEnd:
    ShowCursor(TRUE);
    ReleasePpo(&pddsBack);
    ReleasePpo(&pddsFront);
    if (FAILED(hr))
    {
        // Something has already failed, so report that failure
        // rather than any failure of SetCooperativeLevel
        pdd->SetCooperativeLevel(hwnd, DDSCL_NORMAL);
    }
    else
    {
        if (FAILED(hr = pdd->SetCooperativeLevel(hwnd, DDSCL_NORMAL)))
        {
            *piStepThatFailed = TESTID_SETCOOPERATIVELEVEL_NORMAL;
        }
    }
    if (hwnd != NULL)
        SendMessage(hwnd, WM_CLOSE, 0, 0);
    if (bDisplayModeSet)
    {
        if (FAILED(hr))
        {
            // Something has already failed, so report that failure
            // rather than any failure of RestoreDisplayMode
            pdd->RestoreDisplayMode();
        }
        else
        {
            // Nothing has failed yet, so report any failure of RestoreDisplayMode
            if (FAILED(hr = pdd->RestoreDisplayMode()))
                return hr;
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateTestWindow
 *
 ****************************************************************************/
HRESULT CreateTestWindow(HWND hwndMain, HWND* phwnd)
{
    static BOOL bClassRegistered = FALSE;
    WNDCLASS wndClass;
    TCHAR* pszClass = TEXT("DxDiag Test Window"); // Don't need to localize
    HINSTANCE hInst = (HINSTANCE)GetWindowLongPtr(hwndMain, GWLP_HINSTANCE);
    TCHAR szTitle[200];

    if (!bClassRegistered)
    {
        ZeroMemory(&wndClass, sizeof(wndClass));
        wndClass.style = CS_HREDRAW | CS_VREDRAW;
        wndClass.lpfnWndProc = DefWindowProc;
        wndClass.cbClsExtra = 0;
        wndClass.cbWndExtra = 0;
        wndClass.hInstance = hInst;
        wndClass.hIcon = NULL;
        wndClass.hCursor = NULL;
        wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wndClass.lpszMenuName = NULL;
        wndClass.lpszClassName = pszClass;
        if (NULL == RegisterClass(&wndClass))
            return E_FAIL;
        bClassRegistered = TRUE;
    }

    LoadString(NULL, IDS_APPFULLNAME, szTitle, 200);
    *phwnd = CreateWindow(pszClass, szTitle, WS_OVERLAPPED, 
        0, 0, 0, 0, hwndMain, NULL, hInst, NULL);
    if (*phwnd == NULL)
        return E_FAIL;

    ShowWindow(*phwnd, SW_SHOW);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\testdd.h ===
/****************************************************************************
 *
 *    File: testdd.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Test DirectDraw functionality on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef TESTDD_H
#define TESTDD_H

VOID TestDD(HWND hwndMain, DisplayInfo* pDisplayInfo);


#endif // TESTDD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\testmus.h ===
/****************************************************************************
 *
 *    File: testmus.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Test DMusic functionality on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef TESTMUS_H
#define TESTMUS_H

VOID TestMusic(HWND hwndMain, MusicInfo* pMusicInfo);


#endif // TESTMUS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\testmus.cpp ===
/****************************************************************************
 *
 *    File: testmus.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Test DMusic functionality on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#include <Windows.h>
#include <multimon.h>
#include <dmusicc.h>
#include <dmusici.h>
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h"
#include "musinfo.h"
#include "testmus.h"
#include "resource.h"

#ifndef ReleasePpo
    #define ReleasePpo(ppo) \
        if (*(ppo) != NULL) \
        { \
            (*(ppo))->Release(); \
            *(ppo) = NULL; \
        } \
        else (VOID)0
#endif

enum TESTID
{
    TESTID_COINITIALIZE = 1,
    TESTID_CREATEDMLOADER,
    TESTID_CREATEDMPERF,
    TESTID_INITPERF,
    TESTID_CREATEPORT,
    TESTID_ACTIVATEPORT,
    TESTID_SETAUTODOWNLOAD,
    TESTID_ADDPORT,
    TESTID_ASSIGNPCHANNELBLOCK,
    TESTID_SPEWRESOURCETOFILE,
    TESTID_SETSEARCHDIRECTORY,
    TESTID_LOADERGETOBJECT,
    TESTID_PLAYSEGMENT,
};

BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish = FALSE); // from main.cpp (yuck)

static HRESULT SpewResourceToFile(TCHAR* pszResType, LONG idRes, TCHAR* pszFileName);
static HRESULT LoadSegment( BOOL fUseCWD );
static VOID DeleteTempFile(TCHAR* pszFileName);


/****************************************************************************
 *
 *  TestMusic
 *
 ****************************************************************************/
VOID TestMusic(HWND hwndMain, MusicInfo* pMusicInfo)
{
    HRESULT hr;
    MusicPort* pMusicPort = NULL;
    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicPerformance* pPerformance = NULL;
    IDirectMusic* pdm = NULL;
    IDirectMusicPort* pPort = NULL;
    IDirectMusicSegment* pSegment = NULL;
    BOOL bComInitialized = FALSE;
    TCHAR szFmt[300];
    TCHAR sz[300];
    TCHAR szTitle[100];

    if (pMusicInfo == NULL)
        return;

    // Determine pMusicPort of port to test:
    for (pMusicPort = pMusicInfo->m_pMusicPortFirst; pMusicPort != NULL; pMusicPort = pMusicPort->m_pMusicPortNext)
    {
        if (pMusicPort->m_guid == pMusicInfo->m_guidMusicPortTest)
            break;
    }
    if (pMusicPort == NULL)
        return;

    LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);
    LoadString(NULL, IDS_STARTDMUSICTEST, szFmt, 300);
    wsprintf(sz, szFmt, pMusicPort->m_szDescription);
    if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
        return;

    // Remove info from any previous test:
    ZeroMemory(&pMusicInfo->m_testResult, sizeof(TestResult));

    pMusicInfo->m_testResult.m_bStarted = TRUE;

    // Initialize COM
    if (FAILED(hr = CoInitialize(NULL)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_COINITIALIZE;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }
    bComInitialized = TRUE;

    // Create performance object
    if (FAILED(hr = CoCreateInstance(CLSID_DirectMusicPerformance, NULL,
        CLSCTX_INPROC, IID_IDirectMusicPerformance, (VOID**)&pPerformance)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_CREATEDMPERF;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Initialize the performance -- also creates DirectMusic object
    if (FAILED(hr = pPerformance->Init(&pdm, NULL, hwndMain)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_INITPERF;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Create a port using the user-specified GUID
    DMUS_PORTPARAMS portParams;
    ZeroMemory(&portParams, sizeof(portParams));
    portParams.dwSize = sizeof(portParams);
    portParams.dwValidParams = DMUS_PORTPARAMS_EFFECTS | DMUS_PORTPARAMS_CHANNELGROUPS | 
        DMUS_PORTPARAMS_AUDIOCHANNELS;
    portParams.dwEffectFlags = DMUS_EFFECT_REVERB;
    portParams.dwChannelGroups = pMusicPort->m_dwMaxChannelGroups;
    portParams.dwAudioChannels = pMusicPort->m_dwMaxAudioChannels;
    if (FAILED(hr = pdm->CreatePort(pMusicPort->m_guid, &portParams, &pPort, NULL)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_CREATEPORT;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Activate the port
    if (FAILED(hr = pPort->Activate(TRUE)))
    {
        // Bug 21677: catch case where user has no sound card
        if (hr == DSERR_NODRIVER && !pMusicPort->m_bExternal)
        {
            LoadString(NULL, IDS_NOSOUNDDRIVER, sz, 300);
            MessageBox(hwndMain, sz, szTitle, MB_OK);
        }
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_ACTIVATEPORT;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Set autodownloading to be on
    BOOL fAutoDownload;
    fAutoDownload = TRUE;
    if (FAILED(hr = pPerformance->SetGlobalParam(GUID_PerfAutoDownload, 
        &fAutoDownload, sizeof(BOOL))))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_SETAUTODOWNLOAD;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Add the port to the performance
    if (FAILED(hr = pPerformance->AddPort(pPort)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_ADDPORT;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    if (FAILED(hr = pPerformance->AssignPChannelBlock(0, pPort, 1)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_ASSIGNPCHANNELBLOCK;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    if (FAILED(hr = SpewResourceToFile(TEXT("SGMT"), IDR_TSTSGMT, TEXT("Edge.sgt"))))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_SPEWRESOURCETOFILE;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    if (FAILED(hr = SpewResourceToFile(TEXT("STYL"), IDR_TSTSTYL, TEXT("Edge.sty"))))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_SPEWRESOURCETOFILE;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Create loader object
    if (FAILED(hr = CoCreateInstance(CLSID_DirectMusicLoader, NULL, 
        CLSCTX_INPROC, IID_IDirectMusicLoader, (VOID**)&pLoader)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_CREATEDMLOADER;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Set search path to temp dir to find segment and style:
    WCHAR wszDir[MAX_PATH];
    TCHAR szTempPath[MAX_PATH];
    GetTempPath(MAX_PATH, szTempPath);
    if( lstrlen(szTempPath) > 0 )
        szTempPath[lstrlen(szTempPath) - 1] = '\0';
#ifdef UNICODE
    lstrcpy(wszDir, szTempPath);
#else
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szTempPath, -1, wszDir, MAX_PATH);
#endif
    if (FAILED(hr = pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, wszDir, FALSE)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_SETSEARCHDIRECTORY;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Load the segment
    // now load the segment file.
    // sections load as type Segment, as do MIDI files, for example.
    DMUS_OBJECTDESC objDesc; // Object descriptor for pLoader->GetObject()
    objDesc.guidClass = CLSID_DirectMusicSegment;
    objDesc.dwSize = sizeof(DMUS_OBJECTDESC);
    wcscpy(objDesc.wszFileName, L"edge.sgt");
    objDesc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME;
    if (FAILED(hr = pLoader->GetObject(&objDesc, IID_IDirectMusicSegment, (VOID**)&pSegment)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_LOADERGETOBJECT;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    // Play the segment and wait. The DMUS_SEGF_BEAT indicates to play on the 
    // next beat if there is a segment currently playing. The first 0 indicates 
    // to play (on the next beat from) now.
    // The final NULL means do not return an IDirectMusicSegmentState* in
    // the last parameter.
    if (FAILED(hr = pPerformance->PlaySegment(pSegment, DMUS_SEGF_BEAT, 0, NULL)))
    {
        pMusicInfo->m_testResult.m_iStepThatFailed = TESTID_PLAYSEGMENT;
        pMusicInfo->m_testResult.m_hr = hr;
        goto LEnd;
    }

    if (pMusicPort->m_bExternal)
        LoadString(NULL, IDS_EXTERNALMUSICPLAYING, sz, 300);
    else
        LoadString(NULL, IDS_MUSICPLAYING, sz, 300);
    MessageBox(hwndMain, sz, szTitle, MB_OK);

    pPerformance->Stop(pSegment, NULL, 0, 0);

LEnd:
    DeleteTempFile(TEXT("Edge.sgt"));
    DeleteTempFile(TEXT("Edge.sty"));

    ReleasePpo(&pdm);
    ReleasePpo(&pPort);
    if (pPerformance != NULL)
        pPerformance->CloseDown();
    ReleasePpo(&pPerformance);
    ReleasePpo(&pLoader);

    if (bComInitialized)
    {
        // Release COM
        CoUninitialize();
    }

    if (pMusicInfo->m_testResult.m_iStepThatFailed == 0)
    {
        LoadString(NULL, IDS_TESTSSUCCESSFUL, sz, 300);
        lstrcpy(pMusicInfo->m_testResult.m_szDescription, sz);

        LoadString(NULL, IDS_TESTSSUCCESSFUL_ENGLISH, sz, 300);
        lstrcpy(pMusicInfo->m_testResult.m_szDescriptionEnglish, sz);
    }
    else
    {
        TCHAR szDesc[300];
        TCHAR szError[300];
        if (0 == LoadString(NULL, IDS_FIRSTDMUSICTESTERROR + 
            pMusicInfo->m_testResult.m_iStepThatFailed - 1, szDesc, 200))
        {
            LoadString(NULL, IDS_UNKNOWNERROR, sz, 300);
            lstrcpy(szDesc, sz);
        }
        LoadString(NULL, IDS_FAILUREFMT, sz, 300);
        BTranslateError(pMusicInfo->m_testResult.m_hr, szError);
        wsprintf(pMusicInfo->m_testResult.m_szDescription, sz, 
            pMusicInfo->m_testResult.m_iStepThatFailed,
            szDesc, pMusicInfo->m_testResult.m_hr, szError);

        // Nonlocalized version:
        if (0 == LoadString(NULL, IDS_FIRSTDMUSICTESTERROR_ENGLISH + 
            pMusicInfo->m_testResult.m_iStepThatFailed - 1, szDesc, 200))
        {
            LoadString(NULL, IDS_UNKNOWNERROR_ENGLISH, sz, 300);
            lstrcpy(szDesc, sz);
        }
        LoadString(NULL, IDS_FAILUREFMT_ENGLISH, sz, 300);
        BTranslateError(pMusicInfo->m_testResult.m_hr, szError, TRUE);
        wsprintf(pMusicInfo->m_testResult.m_szDescriptionEnglish, sz, 
            pMusicInfo->m_testResult.m_iStepThatFailed,
            szDesc, pMusicInfo->m_testResult.m_hr, szError);
    }
}


/****************************************************************************
 *
 *  SpewResourceToFile
 *
 ****************************************************************************/
HRESULT SpewResourceToFile(TCHAR* pszResType, LONG idRes, TCHAR* pszFileName)
{
    TCHAR szTempPath[MAX_PATH];
    HRSRC hResInfo = NULL;
    HGLOBAL hResData = NULL;
    BYTE* pbData = NULL;
    HANDLE hfile;
    DWORD numBytes;
    DWORD numBytesWritten;

    GetTempPath(MAX_PATH, szTempPath);
    if( lstrlen(szTempPath) + lstrlen(pszFileName) < MAX_PATH )
        lstrcat(szTempPath, pszFileName);
    szTempPath[MAX_PATH-1]=0;
    if (NULL == (hResInfo = FindResource(NULL, MAKEINTRESOURCE(idRes), pszResType)))
        return E_FAIL;
    numBytes = SizeofResource(NULL, hResInfo);
    if (NULL == (hResData = LoadResource(NULL, hResInfo)))
        return E_FAIL;
    if (NULL == (pbData = (BYTE*)LockResource(hResData)))
        return E_FAIL;

    hfile = CreateFile(szTempPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
        FILE_ATTRIBUTE_TEMPORARY, NULL);
    if (hfile == INVALID_HANDLE_VALUE)
        return E_FAIL;
    WriteFile(hfile, pbData, numBytes, &numBytesWritten, NULL);
    CloseHandle(hfile);

    return S_OK;
}


/****************************************************************************
 *
 *  DeleteTempFile
 *
 ****************************************************************************/
VOID DeleteTempFile(TCHAR* pszFileName)
{
    TCHAR szTempPath[MAX_PATH];

    GetTempPath(MAX_PATH, szTempPath);
    if( lstrlen(szTempPath) + lstrlen(pszFileName) < MAX_PATH )
        lstrcat(szTempPath, pszFileName);
    szTempPath[MAX_PATH-1]=0;
    DeleteFile(szTempPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\testnet.h ===
/****************************************************************************
 *
 *    File: testnet.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Mike Anderson (manders@microsoft.com)
 * Purpose: Test DPlay functionality on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef TESTNET_H
#define TESTNET_H

VOID TestNetwork(HWND hwndMain, NetInfo* pNetInfo);


#endif // TESTNet_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\testnet.cpp ===
/****************************************************************************
 *
 *    File: testnet.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Jason Sandlin (jasonsa@microsoft.com) 
 * Purpose: Test DPlay8 functionality on this machine
 *
 * (C) Copyright 2000-2001 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/
#define INITGUID
#include <Windows.h>
#include <multimon.h>
#include <dplay8.h>
#include <tchar.h>
#include <wchar.h>
#include <dplobby.h>
#include <mmsystem.h>
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h"
#include "netinfo.h"
#include "testnet.h"
#include "resource.h"

#ifndef ReleasePpo
    #define ReleasePpo(ppo) \
        if (*(ppo) != NULL) \
        { \
            (*(ppo))->Release(); \
            *(ppo) = NULL; \
        } \
        else (VOID)0
#endif

#define TIMER_WAIT_CONNECT_COMPLETE 0
#define TIMER_UPDATE_SESSION_LIST   1

enum TESTID
{
    TESTID_COINITIALIZE = 1,
    TESTID_CREATEDPLAY,
    TESTID_ADDRESSING,
    TESTID_ENUMSESSIONS,
    TESTID_ENUMPLAYERS,
    TESTID_SENDCHATMESSAGE,
    TESTID_RECEIVE,
    TESTID_SETPEERINFO,
    TESTID_CREATESESSION,
    TESTID_JOINSESSION,  
};

struct DPHostEnumInfo
{
    DPN_APPLICATION_DESC*   pAppDesc;
    IDirectPlay8Address*    pHostAddr;
    IDirectPlay8Address*    pDeviceAddr;
    TCHAR                   szSession[MAX_PATH];
    DWORD                   dwLastPollTime;
    BOOL                    bValid;
    DPHostEnumInfo*         pNext;
};

#define MAX_CHAT_STRING_LENGTH  200
#define MAX_PLAYER_NAME         MAX_PATH
#define MAX_CHAT_STRING         (MAX_PLAYER_NAME + MAX_CHAT_STRING_LENGTH + 32)

struct APP_PLAYER_INFO
{
    LONG  lRefCount;                        // Ref count so we can cleanup when all threads 
                                            // are done w/ this object
    DPNID dpnidPlayer;                      // DPNID of player
    WCHAR strPlayerName[MAX_PLAYER_NAME];   // Player name
};

#define GAME_MSGID_CHAT    1

// Change compiler pack alignment to be BYTE aligned, and pop the current value
#pragma pack( push, 1 )

UNALIGNED struct GAMEMSG_GENERIC
{
    WORD nType;
};

UNALIGNED struct GAMEMSG_CHAT : public GAMEMSG_GENERIC
{
    WCHAR strChatString[MAX_CHAT_STRING_LENGTH];
};

// Pop the old pack alignment
#pragma pack( pop )

struct APP_QUEUE_CHAT_MSG
{
    WCHAR strChatBuffer[MAX_CHAT_STRING];
};

struct APP_PLAYER_MSG 
{
    WCHAR strPlayerName[MAX_PATH];          // Player name
};

#define WM_APP_CHAT             (WM_APP + 1)
#define WM_APP_LEAVE            (WM_APP + 2)
#define WM_APP_JOIN             (WM_APP + 3)
#define WM_APP_CONNECTING       (WM_APP + 4)
#define WM_APP_CONNECTED        (WM_APP + 5)

BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish = FALSE); // from main.cpp (yuck)

static INT_PTR CALLBACK SetupDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static BOOL FAR PASCAL EnumConnectionsCallback(LPCGUID lpguidSP, VOID* pvConnection, 
    DWORD dwConnectionSize, LPCDPNAME pName, DWORD dwFlags, VOID* pvContext);
static INT_PTR CALLBACK SessionsDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static VOID SessionsDlgInitListbox( HWND hDlg );
static VOID SessionsDlgNoteEnumResponse( PDPNMSG_ENUM_HOSTS_RESPONSE pEnumHostsResponseMsg );
static VOID SessionsDlgUpdateSessionList(HWND hDlg);
static VOID SessionsDlgEnumListCleanup();

static HRESULT InitDirectPlay( BOOL* pbCoInitializeDone );
static HRESULT InitDirectPlayAddresses();
static HRESULT InitSession();
static VOID LoadStringWide( int nID, WCHAR* szWide );

static BOOL FAR PASCAL EnumSessionsCallback(LPCDPSESSIONDESC2 pdpsd, 
    DWORD* pdwTimeout, DWORD dwFlags, VOID* pvContext);
static INT_PTR CALLBACK ChatDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static VOID ShowTextString(HWND hDlg, WCHAR* sz );
static HRESULT SendChatMessage( TCHAR* szMessage );
static HRESULT WINAPI DirectPlayMessageHandler( PVOID pvUserContext, DWORD dwMessageId, PVOID pMsgBuffer );
static BOOL ConvertStringToGUID(const TCHAR* strBuffer, GUID* lpguid);
static VOID ConvertGenericStringToWide( WCHAR* wstrDestination, const TCHAR* tstrSource, int cchDestChar = -1 );
static VOID ConvertWideStringToGeneric( TCHAR* tstrDestination, const WCHAR* wstrSource, int cchDestChar );
static VOID ConvertWideStringToAnsi( CHAR* strDestination, const WCHAR* wstrSource, int cchDestChar );

static const GUID s_guidDPTest = // {61EF80DA-691B-4247-9ADD-1C7BED2BC13E}
{ 0x61ef80da, 0x691b, 0x4247, { 0x9a, 0xdd, 0x1c, 0x7b, 0xed, 0x2b, 0xc1, 0x3e } };

static NetInfo* s_pNetInfo = NULL;
static IDirectPlay8Peer* s_pDP = NULL;
static TCHAR s_szPlayerName[100];
static TCHAR s_szSessionName[100];
static DWORD s_dwPort = 0;
static NetSP* s_pNetSP = NULL;
static BOOL s_bCreateSession = FALSE;
static DPHostEnumInfo* s_pSelectedSession = NULL;
static DPHostEnumInfo s_DPHostEnumHead;
static IDirectPlay8Address* s_pDeviceAddress = NULL;
static IDirectPlay8Address* s_pHostAddress   = NULL;
static DPNHANDLE s_hEnumAsyncOp = NULL;
static DWORD s_dwEnumHostExpireInterval      = 0;
static BOOL s_bEnumListChanged = FALSE;
static BOOL s_bConnecting = FALSE;
static DPHostEnumInfo* s_pDPHostEnumSelected = NULL;
static CRITICAL_SECTION s_csHostEnum;
static DPNID s_dpnidLocalPlayer = 0;
static LONG s_lNumberOfActivePlayers = 0;
static HWND s_hDlg = NULL;
static HWND s_hwndSessionDlg = NULL;
static DPNHANDLE s_hConnectAsyncOp = NULL;
static HRESULT s_hrConnectComplete = S_OK;
static HANDLE s_hConnectCompleteEvent = NULL;


static CRITICAL_SECTION s_csPlayerContext;
#define PLAYER_LOCK()                   EnterCriticalSection( &s_csPlayerContext ); 
#define PLAYER_ADDREF( pPlayerInfo )    if( pPlayerInfo ) pPlayerInfo->lRefCount++;
#define PLAYER_RELEASE( pPlayerInfo )   if( pPlayerInfo ) { pPlayerInfo->lRefCount--; if( pPlayerInfo->lRefCount <= 0 ) delete pPlayerInfo; } pPlayerInfo = NULL;
#define PLAYER_UNLOCK()                 LeaveCriticalSection( &s_csPlayerContext );


/****************************************************************************
 *
 *  TestNetwork
 *
 ****************************************************************************/
VOID TestNetwork(HWND hwndMain, NetInfo* pNetInfo)
{
    BOOL                        bCoInitializeDone = FALSE;
    TCHAR                       sz[300];
    HINSTANCE                   hinst       = (HINSTANCE)GetWindowLongPtr(hwndMain, GWLP_HINSTANCE);

    s_pNetInfo = pNetInfo;
    
    // Remove info from any previous test:
    ZeroMemory(&s_pNetInfo->m_testResult, sizeof(TestResult));
    s_pNetInfo->m_testResult.m_bStarted = TRUE;

    // Setup the s_DPHostEnumHead circular linked list
    ZeroMemory( &s_DPHostEnumHead, sizeof( DPHostEnumInfo ) );
    s_DPHostEnumHead.pNext = &s_DPHostEnumHead;

    InitializeCriticalSection( &s_csHostEnum );
    InitializeCriticalSection( &s_csPlayerContext );
    s_hConnectCompleteEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    // Setup s_pDP, and mark installed SP's
    if( FAILED( InitDirectPlay( &bCoInitializeDone ) ) )
        goto LEnd;

    // Show setup dialog.  This will tell us:
    // - service provider
    // - player name
    // - either create or join
    // - game name (if creating)
    // - port (if SP=TCP/IP)
    DialogBox(hinst, MAKEINTRESOURCE(IDD_TESTNETSETUP), hwndMain, SetupDialogProc);

    if (s_pNetSP == NULL)
    {
        // Something weird happened...no service provider chosen
        goto LEnd;
    }

    // At this point s_szPlayerName, s_szSessionName, s_pNetSP, s_dwPort,
    // and s_bCreateSession have been initialized

    // Setup s_dwEnumHostExpireInterval, s_pDeviceAddress, and s_pHostAddress
    if( FAILED( InitDirectPlayAddresses() ) )
        goto LEnd;

    // Now s_dwEnumHostExpireInterval, s_pDeviceAddress, and s_pHostAddress
    // have been initialized

    // Session list window (if joining session)
    if( !s_bCreateSession )
    {
        // Open a dialog to choose which host to connect to
        DialogBox(hinst, MAKEINTRESOURCE(IDD_TESTNETSESSIONS), hwndMain, SessionsDialogProc);
        // Now s_pDPHostEnumSelected will be NULL or valid

        if( FAILED(s_pNetInfo->m_testResult.m_hr) || s_pDPHostEnumSelected == NULL )
            goto LEnd;

        // Now s_pDPHostEnumSelected is valid
    }

    // Launch chat window and host or join session
    DialogBox(hinst, MAKEINTRESOURCE(IDD_TESTNETCHAT), hwndMain, ChatDialogProc);

LEnd:
    s_pNetSP = NULL;
    ReleasePpo( &s_pDeviceAddress );
    ReleasePpo( &s_pHostAddress );
    if( s_hEnumAsyncOp )
        s_pDP->CancelAsyncOperation( s_hEnumAsyncOp, 0 );
    ReleasePpo(&s_pDP);
    if (bCoInitializeDone)
        CoUninitialize(); // Release COM
    DeleteCriticalSection( &s_csHostEnum );
    DeleteCriticalSection( &s_csPlayerContext );
    CloseHandle( s_hConnectCompleteEvent );

    if (s_pNetInfo->m_testResult.m_bCancelled)
    {
        LoadString(NULL, IDS_TESTSCANCELLED, sz, 300);
        lstrcpy(s_pNetInfo->m_testResult.m_szDescription, sz);

        LoadString(NULL, IDS_TESTSCANCELLED_ENGLISH, sz, 300);
        lstrcpy(s_pNetInfo->m_testResult.m_szDescriptionEnglish, sz);
    }
    else if (s_pNetInfo->m_testResult.m_iStepThatFailed == 0)
    {
        LoadString(NULL, IDS_TESTSSUCCESSFUL, sz, 300);
        lstrcpy(s_pNetInfo->m_testResult.m_szDescription, sz);

        LoadString(NULL, IDS_TESTSSUCCESSFUL_ENGLISH, sz, 300);
        lstrcpy(s_pNetInfo->m_testResult.m_szDescriptionEnglish, sz);
    }
    else
    {
        TCHAR szDesc[300];
        TCHAR szError[300];
        if (0 == LoadString(NULL, IDS_FIRSTDPLAYTESTERROR + 
            s_pNetInfo->m_testResult.m_iStepThatFailed - 1, szDesc, 200))
        {
            LoadString(NULL, IDS_UNKNOWNERROR, sz, 300);
            lstrcpy(szDesc, sz);
        }
        LoadString(NULL, IDS_FAILUREFMT, sz, 300);
        BTranslateError(s_pNetInfo->m_testResult.m_hr, szError);
        wsprintf(s_pNetInfo->m_testResult.m_szDescription, sz, 
            s_pNetInfo->m_testResult.m_iStepThatFailed,
            szDesc, s_pNetInfo->m_testResult.m_hr, szError);

        // Nonlocalized version:
        if (0 == LoadString(NULL, IDS_FIRSTDPLAYTESTERROR_ENGLISH + 
            s_pNetInfo->m_testResult.m_iStepThatFailed - 1, szDesc, 200))
        {
            LoadString(NULL, IDS_UNKNOWNERROR_ENGLISH, sz, 300);
            lstrcpy(szDesc, sz);
        }
        LoadString(NULL, IDS_FAILUREFMT_ENGLISH, sz, 300);
        BTranslateError(s_pNetInfo->m_testResult.m_hr, szError, TRUE);
        wsprintf(s_pNetInfo->m_testResult.m_szDescriptionEnglish, sz, 
            s_pNetInfo->m_testResult.m_iStepThatFailed,
            szDesc, s_pNetInfo->m_testResult.m_hr, szError);
    }
}


/****************************************************************************
 *
 *  InitDirectPlay
 *
 ****************************************************************************/
HRESULT InitDirectPlay( BOOL* pbCoInitializeDone )
{
    HRESULT hr;
    DWORD                       dwItems     = 0;
    DWORD                       dwSize      = 0;
    DPN_SERVICE_PROVIDER_INFO*  pdnSPInfoEnum = NULL;
    DPN_SERVICE_PROVIDER_INFO*  pdnSPInfo     = NULL;
    DWORD                       i;

    // Initialize COM
    if (FAILED(hr = CoInitialize(NULL)))
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_COINITIALIZE;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }
    *pbCoInitializeDone = TRUE;

    // Create DirectPlay object
    if( FAILED( hr = CoCreateInstance( CLSID_DirectPlay8Peer, NULL, 
                                       CLSCTX_INPROC_SERVER,
                                       IID_IDirectPlay8Peer, 
                                       (LPVOID*) &s_pDP ) ) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_CREATEDPLAY;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }

    // Init IDirectPlay8Peer
    if( FAILED( hr = s_pDP->Initialize( NULL, DirectPlayMessageHandler, 0 ) ) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_CREATEDPLAY;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }

    // Enumerate all DirectPlay service providers 
    // to figure out which are installed
    hr = s_pDP->EnumServiceProviders( NULL, NULL, pdnSPInfo, &dwSize,
                                      &dwItems, 0 );
    if( hr != DPNERR_BUFFERTOOSMALL && FAILED(hr) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }
    pdnSPInfo = (DPN_SERVICE_PROVIDER_INFO*) new BYTE[dwSize];
    if( FAILED( hr = s_pDP->EnumServiceProviders( NULL, NULL, pdnSPInfo,
                                                  &dwSize, &dwItems, 0 ) ) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
        s_pNetInfo->m_testResult.m_hr = hr;
        if( pdnSPInfo )
            delete[] pdnSPInfo;
        return hr;
    }

    // Mark installed SP's as such
    pdnSPInfoEnum = pdnSPInfo;
    for ( i = 0; i < dwItems; i++ )
    {
        NetSP* pNetSP;
        for (pNetSP = s_pNetInfo->m_pNetSPFirst; pNetSP != NULL;
             pNetSP = pNetSP->m_pNetSPNext)
        {
            if( pNetSP->m_guid == pdnSPInfoEnum->guid ) 
            {
                pNetSP->m_bInstalled = TRUE;
                break;
            }
        }
        pdnSPInfoEnum++;
    }

    if( pdnSPInfo )
        delete[] pdnSPInfo;

    return S_OK;
}


/****************************************************************************
 *
 *  SetupDialogProc
 *
 ****************************************************************************/
INT_PTR CALLBACK SetupDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            NetSP* pNetSP;
            TCHAR sz[MAX_PATH];
            HWND hwndList = GetDlgItem(hDlg, IDC_SPLIST);
            LONG iItem;
            LONG iSelect = LB_ERR;

            for (pNetSP = s_pNetInfo->m_pNetSPFirst; pNetSP != NULL;
                 pNetSP = pNetSP->m_pNetSPNext)
            {
                if( pNetSP->m_dwDXVer == 8 && pNetSP->m_bInstalled ) 
                {
                    iItem = (LONG)SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)pNetSP->m_szName);
                    if ((LRESULT)iItem != LB_ERR)
                    {
                        SendMessage(hwndList, LB_SETITEMDATA, iItem, (LPARAM)pNetSP);

                        // Try to select TCP/IP by default
                        if( DXUtil_strcmpi(pNetSP->m_szGuid,  TEXT("{EBFE7BA0-628D-11D2-AE0F-006097B01411}")) == 0)
                            iSelect = iItem;
                    }
                }
            }

            // Try to select the default preferred provider
            if( iSelect != LB_ERR )
                SendMessage( hwndList, LB_SETCURSEL, iSelect, 0 );
            else
                SendMessage( hwndList, LB_SETCURSEL, 0, 0 );

            SendMessage(hDlg, WM_COMMAND, IDC_SPLIST, 0);
            LoadString(NULL, IDS_DEFAULTUSERNAME, sz, MAX_PATH);
            SetWindowText(GetDlgItem(hDlg, IDC_PLAYERNAME), sz);
            LoadString(NULL, IDS_DEFAULTSESSIONNAME, sz, MAX_PATH);
            SetWindowText(GetDlgItem(hDlg, IDC_SESSIONNAME), sz);
            CheckRadioButton(hDlg, IDC_CREATESESSION, IDC_JOINSESSION, IDC_CREATESESSION);
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDC_CREATESESSION:
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_SESSIONNAME), TRUE);
                    break;
                }

                case IDC_JOINSESSION:
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_SESSIONNAME), FALSE);
                    break;
                }

                case IDC_SPLIST:
                {
                    HWND hwndList;
                    hwndList = GetDlgItem(hDlg, IDC_SPLIST);
                    LONG iItem;
                    iItem = (LONG)SendMessage(hwndList, LB_GETCURSEL, 0, 0);
                    NetSP* pNetSP = (NetSP*)SendMessage(hwndList, LB_GETITEMDATA, iItem, 0);

                    // Only enable the port if the selected SP == TCP/IP
                    if( pNetSP && lstrcmp( pNetSP->m_szGuid, TEXT("{EBFE7BA0-628D-11D2-AE0F-006097B01411}") ) == 0 )
                    {
                        EnableWindow( GetDlgItem(hDlg, IDC_PORT), TRUE );
                        EnableWindow( GetDlgItem(hDlg, IDC_PORT_TEXT), TRUE );
                    }
                    else
                    {
                        EnableWindow( GetDlgItem(hDlg, IDC_PORT), FALSE );
                        EnableWindow( GetDlgItem(hDlg, IDC_PORT_TEXT), FALSE );
                    }                 
                    break;
                }

                case IDOK:
                {
                    // Set create/join option
                    if (IsDlgButtonChecked(hDlg, IDC_CREATESESSION))
                        s_bCreateSession = TRUE;
                    else
                        s_bCreateSession = FALSE;

                    // Get player name
                    GetWindowText(GetDlgItem(hDlg, IDC_PLAYERNAME), s_szPlayerName, 100);
                    if (lstrlen(s_szPlayerName) == 0)
                    {
                        TCHAR szMsg[MAX_PATH];
                        TCHAR szTitle[MAX_PATH];
                        LoadString(NULL, IDS_NEEDUSERNAME, szMsg, MAX_PATH);
                        LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
                        MessageBox(hDlg, szMsg, szTitle, MB_OK);
                        break;
                    }

                    // Get port
                    TCHAR szPort[MAX_PATH];
                    GetDlgItemText( hDlg, IDC_PORT, szPort, MAX_PATH);
                    s_dwPort = _ttoi( szPort );

                    // Get session name
                    GetWindowText(GetDlgItem(hDlg, IDC_SESSIONNAME), s_szSessionName, 100);
                    if (s_bCreateSession && lstrlen(s_szSessionName) == 0)
                    {
                        TCHAR szMsg[MAX_PATH];
                        TCHAR szTitle[MAX_PATH];
                        LoadString(NULL, IDS_NEEDSESSIONNAME, szMsg, MAX_PATH);
                        LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
                        MessageBox(hDlg, szMsg, szTitle, MB_OK);
                        break;
                    }

                    // Get sp
                    HWND hwndList;
                    hwndList = GetDlgItem(hDlg, IDC_SPLIST);
                    LONG iItem;
                    iItem = (LONG)SendMessage(hwndList, LB_GETCURSEL, 0, 0);
                    if ((LPARAM)iItem == LB_ERR)
                    {
                        s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                        EndDialog(hDlg, 0);
                        return FALSE;
                    }
                    else
                    {
                        s_pNetSP = (NetSP*)SendMessage(hwndList, LB_GETITEMDATA, iItem, 0);
                    }
                    EndDialog(hDlg, 1);
                    break;
                }

                case IDCANCEL:
                {
                    EndDialog(hDlg, 0);
                    s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                    break;
                }
            }
        }
    }

    return FALSE;
}


/****************************************************************************
 *
 *  InitDirectPlayAddresses
 *
 ****************************************************************************/
HRESULT InitDirectPlayAddresses()
{
    HRESULT hr;

    // Query for the enum host timeout for this SP
    DPN_SP_CAPS dpspCaps;
    ZeroMemory( &dpspCaps, sizeof(DPN_SP_CAPS) );
    dpspCaps.dwSize = sizeof(DPN_SP_CAPS);
    if( FAILED( hr = s_pDP->GetSPCaps( &s_pNetSP->m_guid, &dpspCaps, 0 ) ) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }

    // Set the host expire time to around 3 times
    // length of the dwDefaultEnumRetryInterval
    s_dwEnumHostExpireInterval = dpspCaps.dwDefaultEnumRetryInterval * 3;

    // Create a device address
    ReleasePpo( &s_pDeviceAddress );
    hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL,CLSCTX_INPROC_SERVER,
                           IID_IDirectPlay8Address, (LPVOID*) &s_pDeviceAddress );
    if( FAILED(hr) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }

    if( FAILED( hr = s_pDeviceAddress->SetSP( &s_pNetSP->m_guid ) ) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }

    // Create a host address
    ReleasePpo( &s_pHostAddress );
    hr = CoCreateInstance( CLSID_DirectPlay8Address, NULL,CLSCTX_INPROC_SERVER,
                           IID_IDirectPlay8Address, (LPVOID*) &s_pHostAddress );
    if( FAILED(hr) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }

    // Set the SP
    if( FAILED( hr = s_pHostAddress->SetSP( &s_pNetSP->m_guid ) ) )
    {
        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
        s_pNetInfo->m_testResult.m_hr = hr;
        return hr;
    }

    // If TCP/IP then set the port if its non-zero
    if( s_pNetSP->m_guid == CLSID_DP8SP_TCPIP )
    {
        if( s_bCreateSession )
        {
            if( s_dwPort > 0 )
            {
                // Add the port to pDeviceAddress
                if( FAILED( hr = s_pDeviceAddress->AddComponent( DPNA_KEY_PORT, 
                                                               &s_dwPort, sizeof(s_dwPort),
                                                               DPNA_DATATYPE_DWORD ) ) )
                {
                    s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
                    s_pNetInfo->m_testResult.m_hr = hr;
                    return hr;
                }
            }
        }
        else
        {
            if( s_dwPort > 0 )
            {
                // Add the port to pHostAddress
                if( FAILED( hr = s_pHostAddress->AddComponent( DPNA_KEY_PORT, 
                                                             &s_dwPort, sizeof(s_dwPort),
                                                             DPNA_DATATYPE_DWORD ) ) )
                {
                    s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ADDRESSING;
                    s_pNetInfo->m_testResult.m_hr = hr;
                    return hr;
                }
            }
        }
    }

    return S_OK;
}


/****************************************************************************
 *
 *  SessionsDialogProc
 *
 ****************************************************************************/
INT_PTR CALLBACK SessionsDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            HRESULT     hr;

            s_hwndSessionDlg = hDlg;
            s_bEnumListChanged = TRUE;

            // Enumerate hosts
            DPN_APPLICATION_DESC    dnAppDesc;
            ZeroMemory( &dnAppDesc, sizeof(DPN_APPLICATION_DESC) );
            dnAppDesc.dwSize          = sizeof(DPN_APPLICATION_DESC);
            dnAppDesc.guidApplication = s_guidDPTest;

            // Enumerate all the active DirectPlay games on the selected connection
            hr = s_pDP->EnumHosts( &dnAppDesc,                            // application description
                                   s_pHostAddress,                        // host address
                                   s_pDeviceAddress,                      // device address
                                   NULL,                                  // pointer to user data
                                   0,                                     // user data size
                                   INFINITE,                              // retry count (forever)
                                   0,                                     // retry interval (0=default)
                                   INFINITE,                              // time out (forever)
                                   NULL,                                  // user context
                                   &s_hEnumAsyncOp,                       // async handle
                                   DPNENUMHOSTS_OKTOQUERYFORADDRESSING    // flags
                                   );
            if( FAILED(hr) )
            {
                s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ENUMSESSIONS;
                s_pNetInfo->m_testResult.m_hr = hr;
                EndDialog(hDlg, 0);
                return TRUE;
            }

            SessionsDlgInitListbox(hDlg);
            SetTimer(hDlg, TIMER_UPDATE_SESSION_LIST, 250, NULL);
            return TRUE;
        }

        case WM_TIMER:
        {
            if( wParam == TIMER_UPDATE_SESSION_LIST )
                SessionsDlgUpdateSessionList(hDlg);
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDOK:
                {
                    HWND hwndList = GetDlgItem(hDlg, IDC_SESSIONLIST);

                    LONG iSelCur = (LONG)SendMessage(hwndList, LB_GETCURSEL, 0, 0);
                    if( iSelCur != LB_ERR )
                    {
                        // This will prevent s_pDPHostEnumSelected from being 
                        // deleting due to SessionsDlgUpdateSessionList()
                        EnterCriticalSection( &s_csHostEnum );
                        s_pDPHostEnumSelected = (DPHostEnumInfo*)SendMessage( hwndList, LB_GETITEMDATA, 
                                                                              iSelCur, 0 );

                        if ( (LRESULT)s_pDPHostEnumSelected != LB_ERR && 
                             s_pDPHostEnumSelected != NULL )
                        {
                            // We keep the CS until we are done with s_pDPHostEnumSelected,
                            // otherwise it might change out from under us.
                            EndDialog(hDlg, 1);
                            break;
                        }

                        s_pDPHostEnumSelected = NULL;
                        LeaveCriticalSection( &s_csHostEnum );
                    }

                    s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                    EndDialog(hDlg, 0);
                    break;
                }

                case IDCANCEL:
                {
                    s_pDPHostEnumSelected = NULL;
                    s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                    EndDialog(hDlg, 0);
                    break;
                }
            }
        }

        case WM_DESTROY:
        {
            KillTimer( hDlg, TIMER_UPDATE_SESSION_LIST );
            s_hwndSessionDlg = NULL;
            break;
        }
    }

    return FALSE;
}


/****************************************************************************
 *
 *  SessionsDlgInitListbox
 *
 ****************************************************************************/
VOID SessionsDlgInitListbox( HWND hDlg )
{
    HWND hWndListBox = GetDlgItem( hDlg, IDC_SESSIONLIST );

    LONG numChars;
    TCHAR szFmt[200];   

    LoadString(NULL, IDS_LOOKINGFORSESSIONS, szFmt, 200);
    numChars = (LONG)SendMessage(GetDlgItem(hDlg, IDC_CHATOUTPUT), WM_GETTEXTLENGTH, 0, 0);
    SendMessage(GetDlgItem(hDlg, IDC_CHATOUTPUT), EM_SETSEL, numChars, numChars);
    SendMessage(GetDlgItem(hDlg, IDC_CHATOUTPUT), EM_REPLACESEL, 
        FALSE, (LPARAM)szFmt);

    // Clear the contents from the list box, and
    // display "Looking for sessions" text in listbox
    SendMessage( hWndListBox, LB_RESETCONTENT, 0, 0 );
    SendMessage( hWndListBox, LB_SETITEMDATA,  0, NULL );
    SendMessage( hWndListBox, LB_SETCURSEL,    0, 0 );

    // Disable the join button until sessions are found
    EnableWindow( GetDlgItem( hDlg, IDOK ), FALSE );
}


/****************************************************************************
 *
 *  SessionsDlgNoteEnumResponse
 *
 ****************************************************************************/
VOID SessionsDlgNoteEnumResponse( PDPNMSG_ENUM_HOSTS_RESPONSE pEnumHostsResponseMsg )
{
    HRESULT hr = S_OK;
    BOOL    bFound;

    // This function is called from the DirectPlay message handler so it could be
    // called simultaneously from multiple threads, so enter a critical section
    // to assure that it we don't get race conditions.  
    EnterCriticalSection( &s_csHostEnum );

    DPHostEnumInfo* pDPHostEnum          = s_DPHostEnumHead.pNext;
    DPHostEnumInfo* pDPHostEnumNext      = NULL;
    const DPN_APPLICATION_DESC* pResponseMsgAppDesc =
                            pEnumHostsResponseMsg->pApplicationDescription;

    // Look for a matching session instance GUID.
    bFound = FALSE;
    while ( pDPHostEnum != &s_DPHostEnumHead )
    {
        if( pResponseMsgAppDesc->guidInstance == pDPHostEnum->pAppDesc->guidInstance )
        {
            bFound = TRUE;
            break;
        }

        pDPHostEnumNext = pDPHostEnum;
        pDPHostEnum = pDPHostEnum->pNext;
    }

    if( !bFound )
    {
        s_bEnumListChanged = TRUE;

        // If there's no match, then look for invalid session and use it
        pDPHostEnum = s_DPHostEnumHead.pNext;
        while ( pDPHostEnum != &s_DPHostEnumHead )
        {
            if( !pDPHostEnum->bValid )
                break;

            pDPHostEnum = pDPHostEnum->pNext;
        }

        // If no invalid sessions are found then make a new one
        if( pDPHostEnum == &s_DPHostEnumHead )
        {
            // Found a new session, so create a new node
            pDPHostEnum = new DPHostEnumInfo;
            if( NULL == pDPHostEnum )
            {
                hr = E_OUTOFMEMORY;
                goto LCleanup;
            }

            ZeroMemory( pDPHostEnum, sizeof(DPHostEnumInfo) );

            // Add pDPHostEnum to the circular linked list, m_DPHostEnumHead
            pDPHostEnum->pNext = s_DPHostEnumHead.pNext;
            s_DPHostEnumHead.pNext = pDPHostEnum;
        }
    }

    // Update the pDPHostEnum with new information
    TCHAR strName[MAX_PATH];
    if( pResponseMsgAppDesc->pwszSessionName )
        ConvertWideStringToGeneric( strName, pResponseMsgAppDesc->pwszSessionName, MAX_PATH );
    else
        lstrcpy( strName, TEXT("???") );

    // Cleanup any old enum
    if( pDPHostEnum->pAppDesc )
    {
        delete[] pDPHostEnum->pAppDesc->pwszSessionName;
        delete[] pDPHostEnum->pAppDesc;
    }
    ReleasePpo( &pDPHostEnum->pHostAddr );
    ReleasePpo( &pDPHostEnum->pDeviceAddr );
    pDPHostEnum->bValid = FALSE;

    //
    // Duplicate pEnumHostsResponseMsg->pAddressSender in pDPHostEnum->pHostAddr.
    // Duplicate pEnumHostsResponseMsg->pAddressDevice in pDPHostEnum->pDeviceAddr.
    //
    if( FAILED( hr = pEnumHostsResponseMsg->pAddressSender->Duplicate( &pDPHostEnum->pHostAddr ) ) )
    {
        goto LCleanup;
    }

    if( FAILED( hr = pEnumHostsResponseMsg->pAddressDevice->Duplicate( &pDPHostEnum->pDeviceAddr ) ) )
    {
        goto LCleanup;
    }

    // Deep copy the DPN_APPLICATION_DESC from
    pDPHostEnum->pAppDesc = new DPN_APPLICATION_DESC;
    ZeroMemory( pDPHostEnum->pAppDesc, sizeof(DPN_APPLICATION_DESC) );
    memcpy( pDPHostEnum->pAppDesc, pResponseMsgAppDesc, sizeof(DPN_APPLICATION_DESC) );
    if( pResponseMsgAppDesc->pwszSessionName )
    {
        pDPHostEnum->pAppDesc->pwszSessionName = new WCHAR[ wcslen(pResponseMsgAppDesc->pwszSessionName)+1 ];
        wcscpy( pDPHostEnum->pAppDesc->pwszSessionName,
                pResponseMsgAppDesc->pwszSessionName );
    }

    // Update the time this was done, so that we can expire this host
    // if it doesn't refresh w/in a certain amount of time
    pDPHostEnum->dwLastPollTime = timeGetTime();

    // if this node was previously invalidated, or the session name is now
    // different the session list in the dialog needs to be updated
    if( ( pDPHostEnum->bValid == FALSE ) ||
        ( _tcscmp( pDPHostEnum->szSession, strName ) != 0 ) )
    {
        s_bEnumListChanged = TRUE;
    }
    _tcscpy( pDPHostEnum->szSession, strName );

    // This host is now valid
    pDPHostEnum->bValid = TRUE;

LCleanup:
    LeaveCriticalSection( &s_csHostEnum );
}


/****************************************************************************
 *
 *  SessionsDlgUpdateSessionList
 *
 ****************************************************************************/
VOID SessionsDlgUpdateSessionList( HWND hDlg )
{
    HWND            hWndListBox = GetDlgItem(hDlg, IDC_SESSIONLIST);
    DPHostEnumInfo* pDPHostEnum = NULL;
    DPHostEnumInfo* pDPHostEnumSelected = NULL;
    GUID            guidSelectedInstance;
    BOOL            bFindSelectedGUID;
    BOOL            bFoundSelectedGUID;
    int             nItemSelected;

    DWORD dwCurrentTime = timeGetTime();

    // This is called from the dialog UI thread, NoteEnumResponse()
    // is called from the DirectPlay message handler threads so
    // they may also be inside it at this time, so we need to go into the
    // critical section first
    EnterCriticalSection( &s_csHostEnum );

    // Expire old host enums
    pDPHostEnum = s_DPHostEnumHead.pNext;
    while ( pDPHostEnum != &s_DPHostEnumHead )
    {
        // Check the poll time to expire stale entries.  Also check to see if
        // the entry is already invalid.  If so, don't note that the enum list
        // changed because that causes the list in the dialog to constantly redraw.
        if( ( pDPHostEnum->bValid != FALSE ) &&
            ( pDPHostEnum->dwLastPollTime < dwCurrentTime - s_dwEnumHostExpireInterval ) )
        {
            // This node has expired, so invalidate it.
            pDPHostEnum->bValid = FALSE;
            s_bEnumListChanged  = TRUE;
        }

        pDPHostEnum = pDPHostEnum->pNext;
    }

    // Only update the display list if it has changed since last time
    if( !s_bEnumListChanged )
    {
        LeaveCriticalSection( &s_csHostEnum );
        return;
    }

    s_bEnumListChanged = FALSE;

    bFindSelectedGUID  = FALSE;
    bFoundSelectedGUID = FALSE;

    // Try to keep the same session selected unless it goes away or
    // there is no real session currently selected
    nItemSelected = (int)SendMessage( hWndListBox, LB_GETCURSEL, 0, 0 );
    if( nItemSelected != LB_ERR )
    {
        pDPHostEnumSelected = (DPHostEnumInfo*) SendMessage( hWndListBox, LB_GETITEMDATA,
                                                             nItemSelected, 0 );
        if( pDPHostEnumSelected != NULL && pDPHostEnumSelected->bValid )
        {
            guidSelectedInstance = pDPHostEnumSelected->pAppDesc->guidInstance;
            bFindSelectedGUID = TRUE;
        }
    }

    // Tell listbox not to redraw itself since the contents are going to change
    SendMessage( hWndListBox, WM_SETREDRAW, FALSE, 0 );

    // Test to see if any sessions exist in the linked list
    pDPHostEnum = s_DPHostEnumHead.pNext;
    while ( pDPHostEnum != &s_DPHostEnumHead )
    {
        if( pDPHostEnum->bValid )
            break;
        pDPHostEnum = pDPHostEnum->pNext;
    }

    // If there are any sessions in list,
    // then add them to the listbox
    if( pDPHostEnum != &s_DPHostEnumHead )
    {
        // Clear the contents from the list box and enable the join button
        SendMessage( hWndListBox, LB_RESETCONTENT, 0, 0 );

        EnableWindow( GetDlgItem( hDlg, IDOK ), TRUE );

        pDPHostEnum = s_DPHostEnumHead.pNext;
        while ( pDPHostEnum != &s_DPHostEnumHead )
        {
            // Add host to list box if it is valid
            if( pDPHostEnum->bValid )
            {
                int nIndex = (int)SendMessage( hWndListBox, LB_ADDSTRING, 0,
                                               (LPARAM)pDPHostEnum->szSession );
                SendMessage( hWndListBox, LB_SETITEMDATA, nIndex, (LPARAM)pDPHostEnum );

                if( bFindSelectedGUID )
                {
                    // Look for the session the was selected before
                    if( pDPHostEnum->pAppDesc->guidInstance == guidSelectedInstance )
                    {
                        SendMessage( hWndListBox, LB_SETCURSEL, nIndex, 0 );
                        bFoundSelectedGUID = TRUE;
                    }
                }
            }

            pDPHostEnum = pDPHostEnum->pNext;
        }

        if( !bFindSelectedGUID || !bFoundSelectedGUID )
            SendMessage( hWndListBox, LB_SETCURSEL, 0, 0 );
    }
    else
    {
        // There are no active session, so just reset the listbox
        SessionsDlgInitListbox( hDlg );
    }

    // Tell listbox to redraw itself now since the contents have changed
    SendMessage( hWndListBox, WM_SETREDRAW, TRUE, 0 );
    InvalidateRect( hWndListBox, NULL, FALSE );

    LeaveCriticalSection( &s_csHostEnum );

    return;
}


/****************************************************************************
 *
 *  SessionsDlgEnumListCleanup
 *
 ****************************************************************************/
VOID SessionsDlgEnumListCleanup()
{
    DPHostEnumInfo* pDPHostEnum = s_DPHostEnumHead.pNext;
    DPHostEnumInfo* pDPHostEnumDelete;

    while ( pDPHostEnum != &s_DPHostEnumHead )
    {
        pDPHostEnumDelete = pDPHostEnum;
        pDPHostEnum = pDPHostEnum->pNext;

        if( pDPHostEnumDelete->pAppDesc )
        {
            delete[] pDPHostEnumDelete->pAppDesc->pwszSessionName;
            delete[] pDPHostEnumDelete->pAppDesc;
        }

        // Changed from array delete to Release
        ReleasePpo( &pDPHostEnumDelete->pHostAddr );
        ReleasePpo( &pDPHostEnumDelete->pDeviceAddr );
        delete pDPHostEnumDelete;
    }

    // Re-link the s_DPHostEnumHead circular linked list
    s_DPHostEnumHead.pNext = &s_DPHostEnumHead;
}


/****************************************************************************
 *
 *  ChatDialogProc
 *
 ****************************************************************************/
INT_PTR CALLBACK ChatDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            s_hDlg = hDlg;

            // Join or host the session
            if( FAILED( InitSession() ) )
            {
                EndDialog(hDlg, 0);
            }

            return TRUE;
        }
        
        case WM_TIMER:
        {
            if( wParam == TIMER_WAIT_CONNECT_COMPLETE )
            {
                // Check for connect complete
                if( WAIT_OBJECT_0 == WaitForSingleObject( s_hConnectCompleteEvent, 0 ) )
                {
                    s_bConnecting = FALSE;

                    if( FAILED( s_hrConnectComplete ) )
                    {
                        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_JOINSESSION;
                        s_pNetInfo->m_testResult.m_hr = s_hrConnectComplete;
                        EndDialog(hDlg, 0);
                    }
                    else
                    {
                        // DirectPlay connect successful
                        PostMessage( s_hDlg, WM_APP_CONNECTED, 0, 0 );
                        EnableWindow( GetDlgItem( s_hDlg, IDC_SEND), TRUE );
                    }

                    KillTimer( s_hDlg, TIMER_WAIT_CONNECT_COMPLETE );
                }
            }

            break;
        }

        case WM_APP_CONNECTING:
        {
            WCHAR sz[MAX_PATH];
            LoadStringWide(IDS_CONNECTING, sz);
            ShowTextString( hDlg, sz );
            break;
        }

        case WM_APP_CONNECTED:
        {
            WCHAR sz[MAX_PATH];
            LoadStringWide(IDS_CONNECTED, sz);
            ShowTextString( hDlg, sz );
            break;
        }

        case WM_APP_JOIN:
        {
            APP_PLAYER_MSG* pPlayerMsg = (APP_PLAYER_MSG*) lParam;

            WCHAR szFmt[MAX_PATH];
            WCHAR szSuperMessage[MAX_PATH];

            LoadStringWide(IDS_JOINMSGFMT, szFmt);
            swprintf(szSuperMessage, szFmt, pPlayerMsg->strPlayerName);
            ShowTextString( hDlg, szSuperMessage );

            delete pPlayerMsg;
            break;
        }

        case WM_APP_CHAT:
        {
            APP_QUEUE_CHAT_MSG* pQueuedChat = (APP_QUEUE_CHAT_MSG*) lParam;

            ShowTextString( hDlg, pQueuedChat->strChatBuffer );

            delete pQueuedChat;
            break;
        }

        case WM_APP_LEAVE:
        {
            APP_PLAYER_MSG* pPlayerMsg = (APP_PLAYER_MSG*) lParam;

            WCHAR szSuperMessage[MAX_PATH];
            WCHAR szFmt[MAX_PATH];
            LoadStringWide(IDS_LEAVEMSGFMT, szFmt);
            swprintf(szSuperMessage, szFmt, pPlayerMsg->strPlayerName );
            ShowTextString( hDlg, szSuperMessage );

            delete pPlayerMsg;
            break;
        }

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDC_SEND:
                {
                    HRESULT hr;
                    TCHAR szMessage[MAX_PATH];
                    GetWindowText(GetDlgItem(hDlg, IDC_CHATINPUT), szMessage, MAX_PATH);
                    SendMessage(GetDlgItem(hDlg, IDC_CHATINPUT), EM_SETSEL, 0, -1);
                    SendMessage(GetDlgItem(hDlg, IDC_CHATINPUT), EM_REPLACESEL, FALSE, (LPARAM)"");

                    hr = SendChatMessage( szMessage );
                    if (FAILED(hr))
                    {
                        s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_SENDCHATMESSAGE;
                        s_pNetInfo->m_testResult.m_hr = hr;
                        EndDialog(hDlg, 1);
                    }
                }
                break;

            case IDOK:
                EndDialog(hDlg, 1);
                break;

            case IDCANCEL:
                EndDialog(hDlg, 0);
                break;
            }
            return TRUE;
        }

        case WM_DESTROY:
        {
            s_hDlg = NULL;
            break;
        }
    }

    return FALSE;
}


/****************************************************************************
 *
 *  InitSession
 *
 ****************************************************************************/
HRESULT InitSession()
{
    HRESULT hr;

    if( s_bCreateSession )
    {
        // Set peer info name
        WCHAR wszPeerName[MAX_PLAYER_NAME];
        ConvertGenericStringToWide( wszPeerName, s_szPlayerName, MAX_PLAYER_NAME );

        DPN_PLAYER_INFO dpPlayerInfo;
        ZeroMemory( &dpPlayerInfo, sizeof(DPN_PLAYER_INFO) );
        dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
        dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
        dpPlayerInfo.pwszName = wszPeerName;

        // Set the peer info, and use the DPNOP_SYNC since by default this
        // is an async call.  If it is not DPNOP_SYNC, then the peer info may not
        // be set by the time we call Host() below.
        if( FAILED( hr = s_pDP->SetPeerInfo( &dpPlayerInfo, NULL, NULL, DPNOP_SYNC ) ) )
        {
            s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_SETPEERINFO;
            s_pNetInfo->m_testResult.m_hr = hr;
            return hr;
        }

        WCHAR wszSessionName[MAX_PATH];
        ConvertGenericStringToWide( wszSessionName, s_szSessionName );

        // Setup the application desc
        DPN_APPLICATION_DESC dnAppDesc;
        ZeroMemory( &dnAppDesc, sizeof(DPN_APPLICATION_DESC) );
        dnAppDesc.dwSize          = sizeof(DPN_APPLICATION_DESC);
        dnAppDesc.guidApplication = s_guidDPTest;
        dnAppDesc.pwszSessionName = wszSessionName;
        dnAppDesc.dwFlags         = DPNSESSION_MIGRATE_HOST;

        // Host a game on m_pDeviceAddress as described by dnAppDesc
        // DPNHOST_OKTOQUERYFORADDRESSING allows DirectPlay to prompt the user
        // using a dialog box for any device address information that is missing
        if( FAILED( hr = s_pDP->Host( &dnAppDesc,               // the application desc
                                      &s_pDeviceAddress,        // array of addresses of the local devices used to connect to the host
                                      1,                        // number in array
                                      NULL, NULL,               // DPN_SECURITY_DESC, DPN_SECURITY_CREDENTIALS
                                      NULL,                     // player context
                                      DPNHOST_OKTOQUERYFORADDRESSING ) ) ) // flags
        {
            if (hr == DPNERR_USERCANCEL || hr == DPNERR_INVALIDDEVICEADDRESS)
            {
                s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                return hr;
            }
            s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_CREATESESSION;
            s_pNetInfo->m_testResult.m_hr = hr;
            return hr;
        }
    }
    else
    {
        // Set the peer info
        WCHAR wszPeerName[MAX_PLAYER_NAME];
        ConvertGenericStringToWide( wszPeerName, s_szPlayerName, MAX_PLAYER_NAME );

        DPN_PLAYER_INFO dpPlayerInfo;
        ZeroMemory( &dpPlayerInfo, sizeof(DPN_PLAYER_INFO) );
        dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
        dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
        dpPlayerInfo.pwszName = wszPeerName;

        // Set the peer info, and use the DPNOP_SYNC since by default this
        // is an async call.  If it is not DPNOP_SYNC, then the peer info may not
        // be set by the time we call Connect() below.
        if( FAILED( hr = s_pDP->SetPeerInfo( &dpPlayerInfo, NULL, NULL, DPNOP_SYNC ) ) )
        {
            s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_SETPEERINFO;
            s_pNetInfo->m_testResult.m_hr = hr;
            LeaveCriticalSection( &s_csHostEnum );
            return hr;
        }

        ResetEvent( s_hConnectCompleteEvent );
        s_bConnecting = TRUE;

        // Connect to an existing session. DPNCONNECT_OKTOQUERYFORADDRESSING allows
        // DirectPlay to prompt the user using a dialog box for any device address
        // or host address information that is missing
        // We also pass in copies of the app desc and host addr, since pDPHostEnumSelected
        // might be deleted from another thread that calls SessionsDlgExpireOldHostEnums().
        // This process could also be done using reference counting instead.
        hr = s_pDP->Connect( s_pDPHostEnumSelected->pAppDesc,       // the application desc
                             s_pDPHostEnumSelected->pHostAddr,      // address of the host of the session
                             s_pDPHostEnumSelected->pDeviceAddr,    // address of the local device the enum responses were received on
                             NULL, NULL,                          // DPN_SECURITY_DESC, DPN_SECURITY_CREDENTIALS
                             NULL, 0,                             // user data, user data size
                             NULL,                                // player context,
                             NULL, &s_hConnectAsyncOp,            // async context, async handle,
                             DPNCONNECT_OKTOQUERYFORADDRESSING ); // flags

        LeaveCriticalSection( &s_csHostEnum );

        if( hr != E_PENDING && FAILED(hr) )
        {
            if (hr == DPNERR_USERCANCEL)
            {
                s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                return hr;
            }
            s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_JOINSESSION;
            s_pNetInfo->m_testResult.m_hr = hr;
            return hr;
        }

        // Set a timer to wait for m_hConnectCompleteEvent to be signaled.
        // This will tell us when DPN_MSGID_CONNECT_COMPLETE has been processed
        // which lets us know if the connect was successful or not.
        PostMessage( s_hDlg, WM_APP_CONNECTING, 0, 0 );
        SetTimer( s_hDlg, TIMER_WAIT_CONNECT_COMPLETE, 100, NULL );
        EnableWindow( GetDlgItem( s_hDlg, IDC_SEND), FALSE );
    }

    return S_OK;
}


/****************************************************************************
 *
 *  LoadStringWide
 *
 ****************************************************************************/
VOID LoadStringWide( int nID, WCHAR* szWide )
{
    TCHAR sz[MAX_PATH];
    LoadString(NULL, nID, sz, MAX_PATH);
    ConvertGenericStringToWide( szWide, sz, MAX_PATH );
}


/****************************************************************************
 *
 *  ShowTextString
 *
 ****************************************************************************/
VOID ShowTextString( HWND hDlg, WCHAR* sz )
{
    TCHAR szT[MAX_CHAT_STRING];
    ConvertWideStringToGeneric( szT, sz, MAX_CHAT_STRING );

    LONG numChars = (LONG)SendMessage(GetDlgItem(hDlg, IDC_CHATOUTPUT), WM_GETTEXTLENGTH, 0, 0);
    SendMessage(GetDlgItem(hDlg, IDC_CHATOUTPUT), EM_SETSEL, numChars, numChars);
    SendMessage(GetDlgItem(hDlg, IDC_CHATOUTPUT), EM_REPLACESEL, FALSE, (LPARAM)szT);
}


/****************************************************************************
 *
 *  SendChatMessage
 *
 ****************************************************************************/
HRESULT SendChatMessage( TCHAR* szMessage )
{
    // Send a message to all of the players
    GAMEMSG_CHAT msgChat;
    msgChat.nType = GAME_MSGID_CHAT;
    ConvertGenericStringToWide( msgChat.strChatString, szMessage, MAX_CHAT_STRING_LENGTH-1 );
    msgChat.strChatString[MAX_CHAT_STRING_LENGTH-1] = 0;

    DPN_BUFFER_DESC bufferDesc;
    bufferDesc.dwBufferSize = sizeof(GAMEMSG_CHAT);
    bufferDesc.pBufferData  = (BYTE*) &msgChat;

    DPNHANDLE hAsync;
    s_pDP->SendTo( DPNID_ALL_PLAYERS_GROUP, &bufferDesc, 1,
                   0, NULL, &hAsync, 0 );

    return S_OK;
}


/****************************************************************************
 *
 *  DirectPlayMessageHandler
 *
 ****************************************************************************/
HRESULT WINAPI DirectPlayMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer )
{
    switch( dwMessageId )
    {
        case DPN_MSGID_CONNECT_COMPLETE:
        {
            PDPNMSG_CONNECT_COMPLETE pConnectCompleteMsg;
            pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE)pMsgBuffer;

            // Set m_hrConnectComplete, then set an event letting
            // everyone know that the DPN_MSGID_CONNECT_COMPLETE msg
            // has been handled
            s_hrConnectComplete = pConnectCompleteMsg->hResultCode;
            SetEvent( s_hConnectCompleteEvent );
            break;
        }

        case DPN_MSGID_ENUM_HOSTS_RESPONSE:
        {
            PDPNMSG_ENUM_HOSTS_RESPONSE pEnumHostsResponseMsg;
            pEnumHostsResponseMsg = (PDPNMSG_ENUM_HOSTS_RESPONSE)pMsgBuffer;

            // Take note of the host response
            SessionsDlgNoteEnumResponse( pEnumHostsResponseMsg );
            break;
        }

        case DPN_MSGID_ASYNC_OP_COMPLETE:
        {
            PDPNMSG_ASYNC_OP_COMPLETE pAsyncOpCompleteMsg;
            pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE)pMsgBuffer;

            if( pAsyncOpCompleteMsg->hAsyncOp == s_hEnumAsyncOp )
            {
                SessionsDlgEnumListCleanup();
                s_hEnumAsyncOp = NULL;

                // Ignore errors if we are connecting already or something else failed
                if( !s_bConnecting && s_pNetInfo->m_testResult.m_iStepThatFailed == 0 )
                {
                    if( FAILED(pAsyncOpCompleteMsg->hResultCode) )
                    {
                        if( pAsyncOpCompleteMsg->hResultCode == DPNERR_USERCANCEL )
                        {
                            s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ENUMSESSIONS;
                            s_pNetInfo->m_testResult.m_hr = pAsyncOpCompleteMsg->hResultCode;
                            s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                        }
                        else if( pAsyncOpCompleteMsg->hResultCode == DPNERR_ADDRESSING )
                        {
                            TCHAR szTitle[MAX_PATH];
                            TCHAR szMessage[MAX_PATH];
                            LoadString(NULL, IDS_APPFULLNAME, szTitle, MAX_PATH);
                            LoadString(NULL, IDS_SESSIONLISTERROR, szMessage, MAX_PATH);
                            MessageBox(s_hwndSessionDlg, szMessage, szTitle, MB_OK);

                            s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ENUMSESSIONS;
                            s_pNetInfo->m_testResult.m_hr = pAsyncOpCompleteMsg->hResultCode;
                            s_pNetInfo->m_testResult.m_bCancelled = TRUE;
                        }
                        else
                        {
                            s_pNetInfo->m_testResult.m_iStepThatFailed = TESTID_ENUMSESSIONS;
                            s_pNetInfo->m_testResult.m_hr = pAsyncOpCompleteMsg->hResultCode;
                        }

                        EndDialog(s_hwndSessionDlg, 1);
                    }
                }
            }
            break;
        }

        case DPN_MSGID_TERMINATE_SESSION:
        {
            PDPNMSG_TERMINATE_SESSION pTerminateSessionMsg;
            pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION)pMsgBuffer;

            EndDialog(s_hDlg,0);
            break;
        }

        case DPN_MSGID_CREATE_PLAYER:
        {
            HRESULT hr;
            PDPNMSG_CREATE_PLAYER pCreatePlayerMsg;
            pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER)pMsgBuffer;

            // Get the peer info and extract its name
            DWORD dwSize = 0;
            DPN_PLAYER_INFO* pdpPlayerInfo = NULL;
            // Create a new and fill in a APP_PLAYER_INFO
            APP_PLAYER_INFO* pPlayerInfo = new APP_PLAYER_INFO;
            ZeroMemory( pPlayerInfo, sizeof(APP_PLAYER_INFO) );
            pPlayerInfo->dpnidPlayer = pCreatePlayerMsg->dpnidPlayer;
            wcscpy( pPlayerInfo->strPlayerName, L"???" );
            pPlayerInfo->lRefCount   = 1;

            hr = s_pDP->GetPeerInfo( pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0 );
            if( SUCCEEDED(hr) || hr == DPNERR_BUFFERTOOSMALL )
            {
                pdpPlayerInfo = (DPN_PLAYER_INFO*) new BYTE[ dwSize ];
                ZeroMemory( pdpPlayerInfo, dwSize );
                pdpPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);

                hr = s_pDP->GetPeerInfo( pCreatePlayerMsg->dpnidPlayer, pdpPlayerInfo, &dwSize, 0 );
                if( SUCCEEDED(hr) ) 
                {
                    // This stores a extra TCHAR copy of the player name for 
                    // easier access.  This will be redundent copy since DPlay 
                    // also keeps a copy of the player name in GetPeerInfo()
                    wcsncpy( pPlayerInfo->strPlayerName, 
                             pdpPlayerInfo->pwszName, MAX_PLAYER_NAME );
                    pPlayerInfo->strPlayerName[MAX_PLAYER_NAME-1] = 0;
                }
            }

            if( pdpPlayerInfo->dwPlayerFlags & DPNPLAYER_LOCAL )
                s_dpnidLocalPlayer = pCreatePlayerMsg->dpnidPlayer;

            delete[] pdpPlayerInfo;
            pdpPlayerInfo = NULL;

            if( s_hDlg )
            {
                // Record the buffer handle so the buffer can be returned later 
                APP_PLAYER_MSG* pPlayerMsg = new APP_PLAYER_MSG;
                wcscpy( pPlayerMsg->strPlayerName, pPlayerInfo->strPlayerName );

                // Pass the APP_PLAYER_MSG to the main dialog thread, so it can
                // process it.  It will also cleanup the struct
                PostMessage( s_hDlg, WM_APP_JOIN, pPlayerInfo->dpnidPlayer, (LPARAM) pPlayerMsg );
            }

            // Tell DirectPlay to store this pPlayerInfo 
            // pointer in the pvPlayerContext.
            pCreatePlayerMsg->pvPlayerContext = pPlayerInfo;

            // Update the number of active players, and 
            // post a message to the dialog thread to update the 
            // UI.  This keeps the DirectPlay message handler 
            // from blocking
            InterlockedIncrement( &s_lNumberOfActivePlayers );

            break;
        }

        case DPN_MSGID_DESTROY_PLAYER:
        {
            PDPNMSG_DESTROY_PLAYER pDestroyPlayerMsg;
            pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER)pMsgBuffer;
            APP_PLAYER_INFO* pPlayerInfo = (APP_PLAYER_INFO*) pDestroyPlayerMsg->pvPlayerContext;

            if( s_hDlg )
            {
                // Record the buffer handle so the buffer can be returned later 
                APP_PLAYER_MSG* pPlayerMsg = new APP_PLAYER_MSG;
                wcscpy( pPlayerMsg->strPlayerName, pPlayerInfo->strPlayerName );

                // Pass the APP_PLAYER_MSG to the main dialog thread, so it can
                // process it.  It will also cleanup the struct
                PostMessage( s_hDlg, WM_APP_LEAVE, pPlayerInfo->dpnidPlayer, (LPARAM) pPlayerMsg );
            }

            PLAYER_LOCK();                  // enter player context CS
            PLAYER_RELEASE( pPlayerInfo );  // Release player and cleanup if needed
            PLAYER_UNLOCK();                // leave player context CS

            // Update the number of active players, and 
            // post a message to the dialog thread to update the 
            // UI.  This keeps the DirectPlay message handler 
            // from blocking
            InterlockedDecrement( &s_lNumberOfActivePlayers );
            break;
        }

        case DPN_MSGID_RECEIVE:
        {
            PDPNMSG_RECEIVE pReceiveMsg;
            pReceiveMsg = (PDPNMSG_RECEIVE)pMsgBuffer;
            APP_PLAYER_INFO* pPlayerInfo = (APP_PLAYER_INFO*) pReceiveMsg->pvPlayerContext;

            GAMEMSG_GENERIC* pMsg = (GAMEMSG_GENERIC*) pReceiveMsg->pReceiveData;
            
            if( pReceiveMsg->dwReceiveDataSize == sizeof(GAMEMSG_CHAT) &&
                pMsg->nType == GAME_MSGID_CHAT )
            {
                // This message is sent when a player has send a chat message to us, so 
                // post a message to the dialog thread to update the UI.  
                // This keeps the DirectPlay threads from blocking, and also
                // serializes the recieves since DirectPlayMessageHandler can
                // be called simultaneously from a pool of DirectPlay threads.
                GAMEMSG_CHAT* pChatMessage = (GAMEMSG_CHAT*) pMsg;

                // Record the buffer handle so the buffer can be returned later 
                APP_QUEUE_CHAT_MSG* pQueuedChat = new APP_QUEUE_CHAT_MSG;
                _snwprintf( pQueuedChat->strChatBuffer, MAX_CHAT_STRING, L"<%s> %s\r\n", 
                                pPlayerInfo->strPlayerName, 
                                pChatMessage->strChatString );
                pQueuedChat->strChatBuffer[MAX_CHAT_STRING-1]=0;

                // Pass the APP_QUEUE_CHAT_MSG to the main dialog thread, so it can
                // process it.  It will also cleanup the struct
                PostMessage( s_hDlg, WM_APP_CHAT, pPlayerInfo->dpnidPlayer, (LPARAM) pQueuedChat );
            }
            break;
        }
    }
    
    return S_OK;
}


/****************************************************************************
 *
 *  ConvertAnsiStringToWide
 *
 ****************************************************************************/
VOID ConvertAnsiStringToWide( WCHAR* wstrDestination, const CHAR* strSource, 
                                     int cchDestChar )
{
    if( wstrDestination==NULL || strSource==NULL )
        return;

    if( cchDestChar == -1 )
        cchDestChar = strlen(strSource)+1;

    MultiByteToWideChar( CP_ACP, 0, strSource, -1, 
                         wstrDestination, cchDestChar-1 );

    wstrDestination[cchDestChar-1] = 0;
}


/****************************************************************************
 *
 *  ConvertGenericStringToWide
 *
 ****************************************************************************/
VOID ConvertGenericStringToWide( WCHAR* wstrDestination, const TCHAR* tstrSource, int cchDestChar )
{
    if( wstrDestination==NULL || tstrSource==NULL )
        return;

#ifdef _UNICODE
    if( cchDestChar == -1 )
        wcscpy( wstrDestination, tstrSource );
    else
    {
        wcsncpy( wstrDestination, tstrSource, cchDestChar );
        wstrDestination[cchDestChar-1] = 0;
    }
#else
    ConvertAnsiStringToWide( wstrDestination, tstrSource, cchDestChar );
#endif
}


/****************************************************************************
 *
 *  ConvertWideStringToGeneric
 *
 ****************************************************************************/
VOID ConvertWideStringToGeneric( TCHAR* tstrDestination, const WCHAR* wstrSource, int cchDestChar )
{
    if( tstrDestination==NULL || wstrSource==NULL )
        return;

#ifdef _UNICODE
    if( cchDestChar == -1 )
        wcscpy( tstrDestination, wstrSource );
    else
    {
        wcsncpy( tstrDestination, wstrSource, cchDestChar );
        tstrDestination[cchDestChar-1] = 0;
    }

#else
    ConvertWideStringToAnsi( tstrDestination, wstrSource, cchDestChar );
#endif
}


/****************************************************************************
 *
 *  ConvertWideStringToAnsi
 *
 ****************************************************************************/
VOID ConvertWideStringToAnsi( CHAR* strDestination, const WCHAR* wstrSource, int cchDestChar )
{
    if( strDestination==NULL || wstrSource==NULL )
        return;

    if( cchDestChar == -1 )
        cchDestChar = wcslen(wstrSource)+1;

    WideCharToMultiByte( CP_ACP, 0, wstrSource, -1, strDestination, 
                         cchDestChar-1, NULL, NULL );

    strDestination[cchDestChar-1] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\testsnd.cpp ===
/****************************************************************************
 *
 *    File: testsnd.cpp
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Kerim Erden (a-kerime@microsoft.com)
 * Purpose: Test DSound functionality on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#define DIRECTSOUND_VERSION  0x0600
#include <Windows.h>
#include <mmsystem.h>
#include <d3dtypes.h>
#include <dsound.h>
#include "resource.h"
#include "reginfo.h"
#include "sysinfo.h"
#include "dispinfo.h"
#include "sndinfo.h"
#include "testsnd.h"

struct WAVE
{
    WAVEFORMATEX* psHeader;
    LPBYTE pData;
    DWORD dwSize;
};

typedef HRESULT (WINAPI* LPDIRECTSOUNDCREATE)(GUID* pGUID, LPDIRECTSOUND* ppDS, 
                                              IUnknown* pUnkOuter);

enum TESTID
{
    TESTID_LOAD_DSOUND_DLL = 1,
    TESTID_GET_DIRECTSOUNDCREATE,
    TESTID_DIRECTSOUNDCREATE,
    TESTID_SETCOOP,
    TESTID_GETCAPS,
    TESTID_LOADWAVDATA,
    TESTID_EMULDRIVER,
    TESTID_PRIMBUF,
    TESTID_NOFREEHWBUF,
    TESTID_SECBUF,
    TESTID_SETPOS,
    TESTID_NOSAMPLE,
    TESTID_CREATEEVENT,
    TESTID_SETNOTIF,
    TESTID_LOCKFAIL,
    TESTID_UNLOCKFAIL,
    TESTID_PLAY,
    TESTID_GETCURPOS,
    TESTID_USER_VERIFY_SOFTWARE,
    TESTID_USER_VERIFY_HARDWARE
};

BOOL BTranslateError(HRESULT hr, TCHAR* psz, BOOL bEnglish = FALSE); // from main.cpp (yuck)

static BOOL TestDSInit(HWND hwndMain, LPDIRECTSOUND* ppDS, HINSTANCE* phInstDS, 
    SoundInfo* pSoundInfo);
static BOOL TestDSPlay(HWND hWndMain, DSCAPS* pDSCaps, LPDIRECTSOUND pDS, 
    SoundInfo* pSoundInfo, WAVE* pWave, BOOL bHardware, BOOL b3D);
static BOOL PlayDSound(HWND hWndMain, DSCAPS* pDSCaps, LPDIRECTSOUNDBUFFER pPrim, 
    LPDIRECTSOUNDBUFFER pSec, WAVEFORMATEX* pPrimFmt, DWORD dwBufSize, 
    SoundInfo* pSoundInfo, WAVE* pWave, BOOL bHardware, BOOL b3D);
static BOOL LoadTestData(WAVE* pWave);
static VOID FillFormat(WAVEFORMATEX* pWFM);
static VOID TestDSTerm(LPDIRECTSOUND* ppDS, HINSTANCE* phInstDS, SoundInfo* pSoundInfo);
static VOID TestDSReport(SoundInfo* pSoundInfo);

static BOOL s_b16BitWarningGiven = FALSE;


/****************************************************************************
 *
 *  TestSnd
 *
 ****************************************************************************/
VOID TestSnd(HWND hwndMain, SoundInfo* pSoundInfo)
{
    HINSTANCE hInstDS = NULL;
    LPDIRECTSOUND pDS = NULL;
    DSCAPS sDSCaps;
    HRESULT hr = S_OK;
    WAVE sWaveTest;
    TCHAR sz[300];
    TCHAR szTitle[100];

    // Remove info from any previous test:
    ZeroMemory(&pSoundInfo->m_testResultSnd, sizeof(TestResult));
    s_b16BitWarningGiven = FALSE;

    LoadString(NULL, IDS_STARTDSOUNDTEST, sz, 300);
    LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);
    if (IDNO == MessageBox(hwndMain, sz, szTitle, MB_YESNO))
    {
        pSoundInfo->m_testResultSnd.m_bCancelled = TRUE;
        TestDSReport(pSoundInfo);
        return;
    }

    // Remove info from any previous test:
    ZeroMemory(&pSoundInfo->m_testResultSnd, sizeof(TestResult));

    pSoundInfo->m_testResultSnd.m_bStarted = TRUE;

    if (!TestDSInit(hwndMain, &pDS, &hInstDS, pSoundInfo))
        goto LEnd;

    // Get Caps
    ZeroMemory(&sDSCaps, sizeof(sDSCaps));
    sDSCaps.dwSize = sizeof(sDSCaps);
    if (FAILED(hr = pDS->GetCaps(&sDSCaps)))
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_GETCAPS;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        goto LEnd;
    }

    if (!LoadTestData(&sWaveTest))
    {
        // report cannot load wave data
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_LOADWAVDATA;
        pSoundInfo->m_testResultSnd.m_hr = E_FAIL;
        goto LEnd;
    }

    // Check 2D, software buffers
    if (!TestDSPlay(hwndMain, &sDSCaps, pDS, pSoundInfo, &sWaveTest, FALSE, FALSE))
        goto LEnd;

    // Check 3D, software buffers
    if (!TestDSPlay(hwndMain, &sDSCaps, pDS, pSoundInfo, &sWaveTest, FALSE, TRUE))
        goto LEnd;

    if (sDSCaps.dwFlags & DSCAPS_EMULDRIVER || 
       (sDSCaps.dwFreeHw3DStaticBuffers == 0 && sDSCaps.dwFreeHwMixingStaticBuffers == 0) )
    {
        LoadString(NULL, IDS_NOHARDWAREBUFFERING, sz, 300);
        MessageBox(hwndMain, sz, szTitle, MB_OK);
        goto LEnd;
    }

    // Check 2D, hardware buffers
    if (!TestDSPlay(hwndMain, &sDSCaps, pDS, pSoundInfo, &sWaveTest, TRUE, FALSE))
        goto LEnd;

    // Check 3D, hardware buffers
    if (!TestDSPlay(hwndMain, &sDSCaps, pDS, pSoundInfo, &sWaveTest, TRUE, TRUE))
        goto LEnd;

LEnd:
    TestDSTerm(&pDS, &hInstDS, pSoundInfo);
    TestDSReport(pSoundInfo);
}


/****************************************************************************
 *
 *  TestDSInit
 *
 ****************************************************************************/
BOOL TestDSInit(HWND hwndMain, LPDIRECTSOUND* ppDS, HINSTANCE* phInstDS, 
                SoundInfo* pSoundInfo)
{
    LPDIRECTSOUNDCREATE pDSCreate = NULL;
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];
    
    // Load dsound.dll
    GetSystemDirectory(szPath, MAX_PATH);
    lstrcat(szPath, TEXT("\\dsound.dll"));
    *phInstDS = LoadLibrary(szPath);
    if (NULL == *phInstDS)
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_LOAD_DSOUND_DLL;
        pSoundInfo->m_testResultSnd.m_hr = DDERR_NOTFOUND;
        return FALSE;
    }

    // Get DirectSoundCreate entry point
    pDSCreate = (LPDIRECTSOUNDCREATE)GetProcAddress(*phInstDS, "DirectSoundCreate");
    if (NULL == pDSCreate)
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_GET_DIRECTSOUNDCREATE;
        pSoundInfo->m_testResultSnd.m_hr = DDERR_NOTFOUND;
        return FALSE;
    }

    // Call DirectSoundCreate
    if (FAILED(hr = pDSCreate(NULL, ppDS, NULL)))
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_DIRECTSOUNDCREATE;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        return FALSE;
    }

    // Set cooperative level
    if (FAILED(hr = (*ppDS)->SetCooperativeLevel(hwndMain, DSSCL_EXCLUSIVE)))
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_SETCOOP;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  TestDSPlay
 *
 ****************************************************************************/
BOOL TestDSPlay(HWND hWndMain, DSCAPS* pDSCaps, LPDIRECTSOUND pDS, 
    SoundInfo* pSoundInfo, WAVE* pWave, BOOL bHardware, BOOL b3D)
{
    BOOL bRet = TRUE;
    DSBUFFERDESC sBufDesc;
    LPDIRECTSOUNDBUFFER pPrimBuf = NULL;
    LPDIRECTSOUNDBUFFER pDSBuf = NULL;
    HRESULT hr = S_OK;
    WAVEFORMATEX sWaveFmt;
    LPDIRECTSOUND3DBUFFER pBuf3D = NULL;

    // Create the Primary Buffer
    ZeroMemory(&sBufDesc, sizeof(sBufDesc));
    sBufDesc.dwSize = sizeof(sBufDesc);
    sBufDesc.dwFlags = DSBCAPS_PRIMARYBUFFER;
    if (b3D)
        sBufDesc.dwFlags |= DSBCAPS_CTRL3D;
    if (FAILED(hr = pDS->CreateSoundBuffer(&sBufDesc, &pPrimBuf, NULL)))
    {
        // Report: Cannot create primary buffer
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_PRIMBUF;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        bRet = FALSE;
        goto LEnd;
    }

    // Create a secondary static buffer
    ZeroMemory(&sBufDesc, sizeof(sBufDesc));
    sBufDesc.dwSize = sizeof(sBufDesc);
    sBufDesc.lpwfxFormat = pWave->psHeader;
    sBufDesc.dwFlags = DSBCAPS_CTRLPOSITIONNOTIFY;
    if (b3D)
        sBufDesc.dwFlags |= DSBCAPS_CTRL3D;
    if (bHardware)
    {
        // Check Hardware free mem
        if ((1 <= (b3D ? pDSCaps->dwFreeHw3DStaticBuffers : pDSCaps->dwFreeHwMixingStaticBuffers)) )
        {
            // Hardware static buffer
            sBufDesc.dwFlags |= DSBCAPS_STATIC | DSBCAPS_LOCHARDWARE;
            sBufDesc.dwBufferBytes = pWave->dwSize;
        }
        else
        {
            // Can't do hardware testing, so exit silently
            goto LEnd;
        }
    }
    else
    {
        sBufDesc.dwFlags |= DSBCAPS_STATIC | DSBCAPS_LOCSOFTWARE;
        sBufDesc.dwBufferBytes = pWave->dwSize;
    }

    if (FAILED(hr = pDS->CreateSoundBuffer(&sBufDesc, &pDSBuf, NULL)))
    {
        if (DSERR_CONTROLUNAVAIL == hr || DSERR_INVALIDPARAM == hr)
        {
            // Driver does not support position notify, try without it
            sBufDesc.dwFlags &= ~DSBCAPS_CTRLPOSITIONNOTIFY;
            hr = pDS->CreateSoundBuffer(&sBufDesc, &pDSBuf, NULL);
        }
        if (FAILED(hr))
        {
            if (hr == DSERR_BADFORMAT || hr == DSERR_INVALIDPARAM)
            {
                // Can't do this test because the test sound's format is not
                // supported.  Skip this test quietly.
                goto LEnd;
            }
            else
            {
                // Report: Cannot create secondary buffer
                pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_SECBUF;
                pSoundInfo->m_testResultSnd.m_hr = hr;
                bRet = FALSE;
                goto LEnd;
            }
        }
    }

    if (b3D)
    {
        if (FAILED(hr = pDSBuf->QueryInterface(IID_IDirectSound3DBuffer, (LPVOID*)&pBuf3D)))
        {
            bRet = FALSE;
            goto LEnd;
        }

        if (FAILED(hr = pBuf3D->SetPosition(D3DVAL(0), D3DVAL(0), D3DVAL(0), DS3D_IMMEDIATE)))
        {
            pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_SETPOS;
            pSoundInfo->m_testResultSnd.m_hr = hr;
            bRet = FALSE;
            goto LEnd;
        }
    }

    // Loop through the formats
    // Check caps, and do not play any formats that are not supported.
    sWaveFmt.wFormatTag = WAVE_FORMAT_PCM;

    // 8 bit mono, 22Khz:
    if ((pDSCaps->dwFlags & DSCAPS_PRIMARY8BIT) && (pDSCaps->dwFlags & DSCAPS_PRIMARYMONO))
    {
        sWaveFmt.wBitsPerSample = 8;
        sWaveFmt.nChannels = 1;
        sWaveFmt.nSamplesPerSec = 22050;
        if (!(pDSCaps->dwFlags & DSCAPS_CONTINUOUSRATE) || 
            ((sWaveFmt.nSamplesPerSec > pDSCaps->dwMinSecondarySampleRate) && 
            (sWaveFmt.nSamplesPerSec < pDSCaps->dwMaxSecondarySampleRate)))
        {
            FillFormat(&sWaveFmt);
            pPrimBuf->SetFormat(&sWaveFmt);
            if (!PlayDSound(hWndMain, pDSCaps, pPrimBuf, pDSBuf, 
                &sWaveFmt, sBufDesc.dwBufferBytes, pSoundInfo, pWave, bHardware, b3D))
            {
                bRet = FALSE;
                goto LEnd;
            }
        }
    }

    // 8 bit stereo, 22Khz:
    if ((pDSCaps->dwFlags & DSCAPS_PRIMARY8BIT) && (pDSCaps->dwFlags & DSCAPS_PRIMARYSTEREO))
    {
        sWaveFmt.wBitsPerSample = 8;
        sWaveFmt.nChannels = 2;
        sWaveFmt.nSamplesPerSec = 22050;
        if (!(pDSCaps->dwFlags & DSCAPS_CONTINUOUSRATE) || 
            ((sWaveFmt.nSamplesPerSec > pDSCaps->dwMinSecondarySampleRate) && 
            (sWaveFmt.nSamplesPerSec < pDSCaps->dwMaxSecondarySampleRate)))
        {
            FillFormat(&sWaveFmt);
            pPrimBuf->SetFormat(&sWaveFmt);
            if (!PlayDSound(hWndMain, pDSCaps, pPrimBuf, pDSBuf, 
                &sWaveFmt, sBufDesc.dwBufferBytes, pSoundInfo, pWave, bHardware, b3D))
            {
                bRet = FALSE;
                goto LEnd;
            }
        }
    }

    // 16 bit mono, 22Khz:
    if ((pDSCaps->dwFlags & DSCAPS_PRIMARY16BIT) && (pDSCaps->dwFlags & DSCAPS_PRIMARYMONO))
    {
        sWaveFmt.wBitsPerSample = 16;
        sWaveFmt.nChannels = 1;
        sWaveFmt.nSamplesPerSec = 22050;
        if (!(pDSCaps->dwFlags & DSCAPS_CONTINUOUSRATE) || 
            ((sWaveFmt.nSamplesPerSec > pDSCaps->dwMinSecondarySampleRate) && 
            (sWaveFmt.nSamplesPerSec < pDSCaps->dwMaxSecondarySampleRate)))
        {
            FillFormat(&sWaveFmt);
            pPrimBuf->SetFormat(&sWaveFmt);
            if (!s_b16BitWarningGiven)
            {
                WAVEFORMATEX wavefmt;
                wavefmt.cbSize = sizeof(wavefmt);
                if (SUCCEEDED(pPrimBuf->GetFormat(&wavefmt, sizeof(wavefmt), NULL)) &&
                    wavefmt.wBitsPerSample != 16)
                {
                    TCHAR szTitle[100];
                    TCHAR szMessage[500];
                    LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);
                    LoadString(NULL, IDS_NO16BITWARNING, szMessage, 500);
                    MessageBox(hWndMain, szMessage, szTitle, MB_OK);
                    s_b16BitWarningGiven = TRUE;
                }
            }
            
            if (!PlayDSound(hWndMain, pDSCaps, pPrimBuf, pDSBuf, 
                &sWaveFmt, sBufDesc.dwBufferBytes, pSoundInfo, pWave, bHardware, b3D))
            {
                bRet = FALSE;
                goto LEnd;
            }
        }
    }

    // 16 bit stereo, 22Khz:
    if ((pDSCaps->dwFlags & DSCAPS_PRIMARY16BIT) && (pDSCaps->dwFlags & DSCAPS_PRIMARYSTEREO))
    {
        sWaveFmt.wBitsPerSample = 16;
        sWaveFmt.nChannels = 2;
        sWaveFmt.nSamplesPerSec = 22050;
        if (!(pDSCaps->dwFlags & DSCAPS_CONTINUOUSRATE) || 
            ((sWaveFmt.nSamplesPerSec > pDSCaps->dwMinSecondarySampleRate) && 
            (sWaveFmt.nSamplesPerSec < pDSCaps->dwMaxSecondarySampleRate)))
        {
            FillFormat(&sWaveFmt);
            pPrimBuf->SetFormat(&sWaveFmt);
            if (!PlayDSound(hWndMain, pDSCaps, pPrimBuf, pDSBuf, 
                &sWaveFmt, sBufDesc.dwBufferBytes, pSoundInfo, pWave, bHardware, b3D))
            {
                bRet = FALSE;
                goto LEnd;
            }
        }
    }

LEnd:
    if (NULL != pPrimBuf)
        pPrimBuf->Release();
    if (NULL != pBuf3D)
        pBuf3D->Release();
    if (NULL != pDSBuf)
        pDSBuf->Release();

    return bRet;
}


/****************************************************************************
 *
 *  PlayDSound
 *
 ****************************************************************************/
BOOL PlayDSound(HWND hWndMain, DSCAPS* pDSCaps, LPDIRECTSOUNDBUFFER pPrim, 
    LPDIRECTSOUNDBUFFER pSec, WAVEFORMATEX* pPrimFmt, DWORD dwBufSize, 
    SoundInfo* pSoundInfo, WAVE* pWave, BOOL bHardware, BOOL b3D)
{
    HRESULT hr;
    VOID* pData = NULL;
    DWORD dwSize;
    LPDIRECTSOUNDNOTIFY pDSNot = NULL;
    HANDLE hNotEvent = NULL;
    DSBPOSITIONNOTIFY sPosNot;
    TCHAR szOut[MAX_PATH];
    DWORD dwCur = 0;
    TCHAR sz[300];
    TCHAR szTitle[100];

    LoadString(NULL, IDS_APPFULLNAME, szTitle, 100);

    if (FAILED(hr = pSec->QueryInterface(IID_IDirectSoundNotify, (LPVOID*)&pDSNot)))
    {
        pDSNot = NULL;
    }

    hNotEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == hNotEvent)
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_CREATEEVENT;
        pSoundInfo->m_testResultSnd.m_hr = S_FALSE;
        return FALSE;
    }

    if (NULL != pDSNot)
    {
        sPosNot.dwOffset = DSBPN_OFFSETSTOP;
        sPosNot.hEventNotify = hNotEvent;
        if (FAILED(hr = pDSNot->SetNotificationPositions(1, &sPosNot)))
        {
            pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_SETNOTIF;
            pSoundInfo->m_testResultSnd.m_hr = hr;
            return FALSE;
        }
    }

    if (FAILED(hr = pSec->Lock(0, dwBufSize, &pData, &dwSize, NULL, 
        0, DSBLOCK_ENTIREBUFFER)))
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_LOCKFAIL;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        return FALSE;
    }

    memcpy(pData, pWave->pData, dwSize);

    if (FAILED(hr = pSec->Unlock(pData, dwSize, NULL, 0)))
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_UNLOCKFAIL;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        return FALSE;
    }

    // Play the buffer
    pSec->SetCurrentPosition(0);
    if (FAILED(hr = pSec->Play(0, 0, 0)))
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = TESTID_PLAY;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        return FALSE;
    }

    WaitForSingleObject(hNotEvent, (pWave->dwSize * 1000 / pWave->psHeader->nAvgBytesPerSec));

    pSec->Stop();
    CloseHandle(hNotEvent);
    if (NULL != pDSNot)
        pDSNot->Release();

    TCHAR sz3D[50];
    TCHAR szChannelDesc[50];
    TCHAR szHWSW[50];
    LoadString(NULL, IDS_THATSOUNDWAS, sz, 300);
    if (b3D)
    {
        LoadString(NULL, IDS_3D, sz3D, 50);
        lstrcat(sz3D, TEXT(" "));
    }
    else
    {
        lstrcpy(sz3D, TEXT(""));
    }

    if (pPrimFmt->nChannels == 1)
        LoadString(NULL, IDS_MONO, szChannelDesc, 50);
    else if (pPrimFmt->nChannels == 2)
        LoadString(NULL, IDS_STEREO, szChannelDesc, 50);
    else
        LoadString(NULL, IDS_MULTICHANNEL, szChannelDesc, 50);

    if (bHardware)
        LoadString(NULL, IDS_HARDWARE, szHWSW, 50);
    else
        LoadString(NULL, IDS_SOFTWARE, szHWSW, 50);

    wsprintf(szOut, sz, sz3D, szChannelDesc, pPrimFmt->wBitsPerSample,
        pPrimFmt->nSamplesPerSec / 1000, szHWSW);

    INT iReply;
    iReply = MessageBox(hWndMain, szOut, szTitle, MB_YESNOCANCEL);
    if (IDYES == iReply)
    {
        return TRUE;
    }
    else if (IDNO == iReply)
    {
        pSoundInfo->m_testResultSnd.m_iStepThatFailed = (TRUE == bHardware) ? 
            TESTID_USER_VERIFY_HARDWARE : TESTID_USER_VERIFY_SOFTWARE;
        pSoundInfo->m_testResultSnd.m_hr = hr;
        return FALSE;
    }
    else // IDCANCEL
    {
        pSoundInfo->m_testResultSnd.m_bCancelled = TRUE;
        return FALSE;
    }

}


/****************************************************************************
 *
 *  LoadTestData
 *
 ****************************************************************************/
BOOL LoadTestData(WAVE* pWave)
{
    DWORD dwRiff;
    DWORD dwType;
    DWORD dwLength;
    HRSRC hResInfo = NULL;
    HGLOBAL hResData = NULL;
    DWORD* pdw = NULL;
    DWORD* pdwEnd = NULL;
    VOID* pData = NULL;
    WAVEFORMATEX** ppWaveHeader = &pWave->psHeader;
    LPBYTE* ppbWaveData = &pWave->pData;
    DWORD* pcbWaveSize = &pWave->dwSize;

    if (NULL == pWave)
        return FALSE;

    if (NULL == (hResInfo = FindResource(NULL, MAKEINTRESOURCE(IDR_WAVTST), TEXT("WAVE"))))
        return FALSE;
    if (NULL == (hResData = LoadResource(NULL, hResInfo)))
        return FALSE;
    if (NULL == (pData = LockResource(hResData)))
        return FALSE;

    pWave->psHeader = NULL;
    pWave->pData = NULL;
    pWave->dwSize = 0;

    pdw = (DWORD *)pData;
    dwRiff = *pdw++;
    dwLength = *pdw++;
    dwType = *pdw++;

    if (dwRiff != mmioFOURCC('R', 'I', 'F', 'F'))
        return FALSE;

    if (dwType != mmioFOURCC('W', 'A', 'V', 'E'))
        return FALSE;

    pdwEnd = (DWORD*)((BYTE*)pdw + dwLength - 4);

    while (pdw < pdwEnd)
    {
        dwType = *pdw++;
        dwLength = *pdw++;

        switch (dwType)
        {
            case mmioFOURCC('f', 'm', 't', ' '):
                if (ppWaveHeader && !*ppWaveHeader)
                {
                    if (dwLength < sizeof(WAVEFORMAT))
                        return FALSE;

                    *ppWaveHeader = (WAVEFORMATEX*)pdw;

                    if ((!ppbWaveData || *ppbWaveData) && (!pcbWaveSize || *pcbWaveSize))
                        return TRUE;
                }
                break;

            case mmioFOURCC('d', 'a', 't', 'a'):
                if ((ppbWaveData && !*ppbWaveData) || (pcbWaveSize && !*pcbWaveSize))
                {
                    if (ppbWaveData)
                        *ppbWaveData = (LPBYTE)pdw;

                    if (pcbWaveSize)
                        *pcbWaveSize = dwLength;

                    if (!ppWaveHeader || *ppWaveHeader)
                        return TRUE;
                }
                break;
        }

        pdw = (DWORD*)((BYTE*)pdw + ((dwLength + 1) & ~1));
    }
    return FALSE;
}


/****************************************************************************
 *
 *  FillFormat
 *
 ****************************************************************************/
VOID FillFormat(WAVEFORMATEX* pWFM)
{ 
    pWFM->nBlockAlign = (pWFM->nChannels * pWFM->wBitsPerSample) / 8;
    pWFM->nAvgBytesPerSec = pWFM->nSamplesPerSec * pWFM->nBlockAlign;
}


/****************************************************************************
 *
 *  TestDSTerm
 *
 ****************************************************************************/
VOID TestDSTerm(LPDIRECTSOUND* ppDS, HINSTANCE* phInstDS, SoundInfo* pSoundInfo)
{
    if (NULL != *ppDS)
    {
        (*ppDS)->Release();
        *ppDS = NULL;
    }

    if (NULL != *phInstDS)
        FreeLibrary(*phInstDS);
}


/****************************************************************************
 *
 *  TestDSReport
 *
 ****************************************************************************/
VOID TestDSReport(SoundInfo* pSoundInfo)
{
    if (pSoundInfo->m_testResultSnd.m_bCancelled)
    {
        LoadString(NULL, IDS_TESTSCANCELLED, pSoundInfo->m_testResultSnd.m_szDescription, 300);
        LoadString(NULL, IDS_TESTSCANCELLED_ENGLISH, pSoundInfo->m_testResultSnd.m_szDescriptionEnglish, 300);
    }
    else
    {
        if (pSoundInfo->m_testResultSnd.m_iStepThatFailed == 0)
        {
            LoadString(NULL, IDS_TESTSSUCCESSFUL, pSoundInfo->m_testResultSnd.m_szDescription, 300);
            LoadString(NULL, IDS_TESTSSUCCESSFUL_ENGLISH, pSoundInfo->m_testResultSnd.m_szDescriptionEnglish, 300);
        }
        else
        {
            TCHAR szDesc[200];
            TCHAR szError[200];
            TCHAR sz[300];
            if (0 == LoadString(NULL, IDS_FIRSTDSOUNDTESTERROR + pSoundInfo->m_testResultSnd.m_iStepThatFailed - 1,
                szDesc, 200))
            {
                LoadString(NULL, IDS_UNKNOWNERROR, szDesc, 200);
            }
            LoadString(NULL, IDS_FAILUREFMT, sz, 300);
            BTranslateError(pSoundInfo->m_testResultSnd.m_hr, szError);
            wsprintf(pSoundInfo->m_testResultSnd.m_szDescription, sz,
                pSoundInfo->m_testResultSnd.m_iStepThatFailed,
                szDesc, pSoundInfo->m_testResultSnd.m_hr, szError);

            // Nonlocalized version:
            if (0 == LoadString(NULL, IDS_FIRSTDSOUNDTESTERROR_ENGLISH + pSoundInfo->m_testResultSnd.m_iStepThatFailed - 1,
                szDesc, 200))
            {
                LoadString(NULL, IDS_UNKNOWNERROR_ENGLISH, szDesc, 200);
            }
            LoadString(NULL, IDS_FAILUREFMT_ENGLISH, sz, 300);
            BTranslateError(pSoundInfo->m_testResultSnd.m_hr, szError, TRUE);
            wsprintf(pSoundInfo->m_testResultSnd.m_szDescriptionEnglish, sz,
                pSoundInfo->m_testResultSnd.m_iStepThatFailed,
                szDesc, pSoundInfo->m_testResultSnd.m_hr, szError);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3d\sources.inc ===
MAJORCOMP=d3dim
MINORCOMP=d3dim
TARGETNAME=d3dim
TARGETPATH=obj

TARGETTYPE=DYNLINK
DLLDEF=$O\$(TARGETNAME).def

!IFDEF NTBBT
X3DLIB=x3dbbt.lib
INTELLIB=ipsgpbbt.lib
INTELKLIB=ikpsgpbbt.lib
!ELSE
X3DLIB=x3d.lib
INTELLIB=ipsgp.lib
INTELKLIB=ikpsgp.lib
!ENDIF

SYNCHRONIZE_DRAIN = 1

INCLUDES=$(DXROOT)\inc;$(INCLUDES)

TARGETLIBS = \
        $(BASEDIR)\public\sdk\lib\*\gdi32.lib\
        $(BASEDIR)\public\sdk\lib\*\user32.lib\
        $(BASEDIR)\public\sdk\lib\*\advapi32.lib\
        $(BASEDIR)\public\sdk\lib\*\uuid.lib

!if !($(AMD64) || $(IA64))
TARGETLIBS=$(TARGETLIBS) \
           $(D3DDX6)\lib\$(PLAT_DIR)\*\$(X3DLIB) \
           $(D3DDX6)\lib\$(PLAT_DIR)\*\$(INTELLIB) \
           $(D3DDX6)\lib\$(PLAT_DIR)\*\$(INTELKLIB)
!endif

LINKLIBS = \
        $(D3DDX6)\d3dutil\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dutil.lib \
        $(D3DDX6)\pipeln\$(PLAT_DIR)\$(_OBJ_DIR)\*\pipeln.lib \
        $(D3DDX6)\d3dim\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dim.lib \
        $(D3DDX6)\rast\mmxemul\$(PLAT_DIR)\$(_OBJ_DIR)\*\mmxemul.lib \
        $(D3DDX6)\rast\cspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rcspan.lib \
        $(D3DDX6)\rast\rampspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rrmpspan.lib \
        $(D3DDX6)\rast\rampmat\$(PLAT_DIR)\$(_OBJ_DIR)\*\rrampmat.lib \
        $(D3DDX6)\rast\mlspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rmlspan.lib \
        $(D3DDX6)\rast\spaninit\$(PLAT_DIR)\$(_OBJ_DIR)\*\rspanini.lib \
        $(D3DDX6)\rast\setup\$(PLAT_DIR)\$(_OBJ_DIR)\*\rsetup.lib \
        $(D3DDX6)\rast\d3dif\$(PLAT_DIR)\$(_OBJ_DIR)\*\rd3dif.lib

!if !($(AMD64) || $(IA64))
LINKLIBS=$(LINKLIBS) \
         $(D3DDX6)\rast\mmxspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rmmxspan.lib
!endif

DLLENTRY = _DllMainCRTStartup

SOURCES = ..\d3dim.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\beginend.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       beginend.c
 *  Content:    Begin/End implementation
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "drawprim.hpp"
#include "d3dfei.h"

// This should be moved with other DP flags so that no one uses this bit
#define __NON_FVF_INPUT         0x80000000

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "MoveData"

_inline void MoveData(LPVOID lpData, DWORD destOffset, DWORD srcOffset,
                      DWORD size)
{
    memcpy((char*)lpData + destOffset, (char*)lpData + srcOffset, size);
}
//---------------------------------------------------------------------
void CleanupBeginEnd(LPDIRECT3DDEVICEI lpDevI)
{
    lpDevI->lpVertexIndices = NULL;
    lpDevI->lpvVertexData = NULL;
    lpDevI->dwBENumVertices = 0;
    lpDevI->dwBENumIndices = 0;
    lpDevI->dwHintFlags &= ~D3DDEVBOOL_HINTFLAGS_INBEGIN_ALL;
}
//---------------------------------------------------------------------
HRESULT
DoFlushBeginEnd(LPDIRECT3DDEVICEI lpDevI)
{
    HRESULT ret;

    lpDevI->lpwIndices = NULL;
    lpDevI->dwNumIndices = 0;
    lpDevI->lpClipFlags = (D3DFE_CLIPCODE*)lpDevI->HVbuf.GetAddress();
    lpDevI->position.lpvData = lpDevI->lpvVertexData;

    ret = lpDevI->ProcessPrimitive();
    return ret;
}
//---------------------------------------------------------------------
__inline void Dereference(LPDIRECT3DDEVICEI lpDevI, DWORD indexStart, DWORD numVer)
{
    char *dst_vptr = (char*)lpDevI->lpvVertexBatch;
    char *src_vptr = (char*)lpDevI->lpvVertexData;
    WORD *iptr = &lpDevI->lpVertexIndices[indexStart];
    DWORD size = lpDevI->position.dwStride;
    for (DWORD i=0; i < numVer; i++)
    {
        memcpy(dst_vptr, &src_vptr[iptr[i]*size], size);
        dst_vptr += size;
    }
}
//---------------------------------------------------------------------
HRESULT
DoFlushBeginIndexedEnd(LPDIRECT3DDEVICEI lpDevI)
{
    HRESULT             ret;
    DWORD               i;
    static BOOL         offScreen;  // all vertices are off screen

    lpDevI->dwNumVertices = lpDevI->dwBENumVertices;
    lpDevI->lpwIndices = lpDevI->lpVertexIndices;
    lpDevI->lpClipFlags = (D3DFE_CLIPCODE*)lpDevI->HVbuf.GetAddress();
    lpDevI->position.lpvData = lpDevI->lpvVertexData;

    if ( (lpDevI->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN) &&
         (!(lpDevI->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN_FIRST_FLUSH)) )
    {      // if this is the first flush
        lpDevI->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_INBEGIN_FIRST_FLUSH;
        offScreen = 0;
        if (lpDevI->dwBENumIndices < lpDevI->dwMaxIndexCount)
        {   // single flush case
            /*
              If the user is using a large vertex array for relatively few prims
              we need to dereference the indexed prims into another array.  Otherwise
              we waste too much time transforming and lighting vertices that we never use.

              Since BeginIndexed requires that the user pass in an array of vertices we
              know that this->lpvVertexBatch is not being used.  So derefernce into it.
              We know it's there because the index space gets created at the same time.

              Also note that since the max size fo the index array is bigger than
              the vertex array we may have to do this in several small batches.
              */

            if (!FVF_TRANSFORMED(lpDevI->dwVIDIn))
            {
                if (lpDevI->dwBENumIndices*INDEX_BATCH_SCALE < lpDevI->dwBENumVertices)
                {
                    WORD  *iptr;
                    DWORD indexStart = 0;
                    DWORD numPrims;
                    DWORD numIndices = lpDevI->dwBENumIndices;

                    switch (lpDevI->primType)
                    {
                    case D3DPT_LINELIST :
                    {
                        do
                        {
                            numPrims = min(numIndices/2, lpDevI->dwMaxVertexCount/2);
                            DWORD numVer = numPrims << 1;

                            Dereference(lpDevI, indexStart, numVer);

                            lpDevI->dwNumVertices = numVer;
                            lpDevI->dwNumPrimitives = numPrims;
                            lpDevI->position.lpvData = lpDevI->lpvVertexBatch;

                            ret = lpDevI->ProcessPrimitive();
                            if (ret != D3D_OK)
                            {
                                return ret;
                            }
                            indexStart += numVer;
                            numIndices -= numVer;
                        } while (numIndices > 1);
                        break;
                    }
                    case D3DPT_LINESTRIP :
                        do
                        {
                            numPrims = min(numIndices-1, lpDevI->dwMaxVertexCount-1);
                            DWORD numVer = numPrims + 1;

                            Dereference(lpDevI, indexStart, numVer);

                            lpDevI->dwNumVertices = numPrims+1;
                            lpDevI->dwNumPrimitives = numPrims;
                            lpDevI->position.lpvData = lpDevI->lpvVertexBatch;

                            ret = lpDevI->ProcessPrimitive();
                            if (ret != D3D_OK)
                            {
                                return ret;
                            }
                            indexStart += numPrims;
                            numIndices -= numPrims;
                        } while (numIndices > 1);
                        break;
                    case D3DPT_TRIANGLELIST :
                        do
                        {
                            numPrims = min(numIndices/3, lpDevI->dwMaxVertexCount/3);
                            DWORD numVer = numPrims*3;

                            Dereference(lpDevI, indexStart, numVer);

                            lpDevI->dwNumVertices = numVer;
                            lpDevI->dwNumPrimitives = numPrims;
                            lpDevI->position.lpvData = lpDevI->lpvVertexBatch;

                            ret = lpDevI->ProcessPrimitive();
                            if (ret != D3D_OK)
                            {
                                return ret;
                            }
                            indexStart += numVer;
                            numIndices -= numVer;
                        } while (numIndices > 2);
                        break;
                    case D3DPT_TRIANGLESTRIP :
                        do
                        {
                            numPrims = min(numIndices-2, lpDevI->dwMaxVertexCount-2);
                            DWORD numVer = numPrims + 2;

                            Dereference(lpDevI, indexStart, numVer);

                            lpDevI->dwNumVertices = numVer;
                            lpDevI->dwNumPrimitives = numPrims;
                            lpDevI->position.lpvData = lpDevI->lpvVertexBatch;

                            ret = lpDevI->ProcessPrimitive();
                            if (ret != D3D_OK)
                            {
                                return ret;
                            }
                            indexStart += numPrims;
                            numIndices -= numPrims;
                        } while (numIndices > 2);
                        break;
                    case D3DPT_TRIANGLEFAN :
                        // lock in center of fan
                        char *tmp = (char*)lpDevI->lpvVertexBatch;
                        char *src = (char*)lpDevI->lpvVertexData;
                        DWORD size = lpDevI->position.dwStride;
                        memcpy(lpDevI->lpvVertexBatch,
                               &src[lpDevI->lpVertexIndices[0]*size], size);
                        lpDevI->lpvVertexBatch = tmp + size;
                        indexStart = 1;
                        do
                        {
                            numPrims = min(numIndices-2, lpDevI->dwMaxVertexCount-2);

                            Dereference(lpDevI, indexStart, numPrims + 1);

                            lpDevI->dwNumVertices = numPrims+2;
                            lpDevI->dwNumPrimitives = numPrims;
                            lpDevI->position.lpvData = tmp;

                            ret = lpDevI->ProcessPrimitive();
                            if (ret != D3D_OK)
                            {
                                return ret;
                            }
                            indexStart += numPrims;
                            numIndices -= numPrims;
                        } while (numIndices > 2);
                        lpDevI->lpvVertexBatch = tmp; // Restore
                        break;
                    }   // end of prim type switch

                    return D3D_OK;
                }
                // else fall through to the no batching case
            }

            // no batching case
            ret = lpDevI->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);

            return ret;
        }
        else
        {
            // this is the first of n possible batches so t&l all vertices just once
            ret = lpDevI->ProcessPrimitive(__PROCPRIMOP_PROCVERONLY);
            if (ret != D3D_OK)
            {
                return ret;
            }
            // This flag is cleared in CleanupBeginEnd
            lpDevI->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_INBEGIN_BIG_PRIM;
            if (lpDevI->dwClipIntersection)
            {
                // all vertices are off screen so we can just bail
                offScreen = 1;  // so we can early out next flush
                return D3D_OK;
            }
        }
    }   // end if if first flush

    // for secondary flushes don't bother to draw if we don't need to
    if (!offScreen)
        ret = DoDrawIndexedPrimitive(lpDevI);

    return ret;
}   // end of DoFlushBeginIndexedEnd()
//---------------------------------------------------------------------
// Computes the number of primitives
// Input:  lpDevI->primType
//         dwNumVertices
// Output: lpDevI->dwNumPrimitives
//         lpDevI->D3DStats
//         return value = "Real" number of vertices (indices)
#undef DPF_MODNAME
#define DPF_MODNAME "GetNumPrimBE"

inline DWORD GetNumPrimBE(LPDIRECT3DDEVICEI lpDevI, DWORD dwNumVertices)
{
    lpDevI->dwNumPrimitives = 0;
    switch (lpDevI->primType)
    {
    case D3DPT_POINTLIST:
        lpDevI->D3DStats.dwPointsDrawn += dwNumVertices;
        lpDevI->dwNumPrimitives = dwNumVertices;
        return dwNumVertices;
    case D3DPT_LINELIST:
        lpDevI->dwNumPrimitives = dwNumVertices >> 1;
        lpDevI->D3DStats.dwLinesDrawn += lpDevI->dwNumPrimitives;
        return lpDevI->dwNumPrimitives << 1;
    case D3DPT_LINESTRIP:
        if (dwNumVertices < 2)
            return 0;
        lpDevI->dwNumPrimitives = dwNumVertices - 1;
        lpDevI->D3DStats.dwLinesDrawn += lpDevI->dwNumPrimitives;
        return dwNumVertices;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (dwNumVertices < 3)
            return 0;        
        lpDevI->dwNumPrimitives = dwNumVertices - 2;
        lpDevI->D3DStats.dwTrianglesDrawn += lpDevI->dwNumPrimitives;
        return dwNumVertices;
    case D3DPT_TRIANGLELIST:
        lpDevI->dwNumPrimitives = dwNumVertices / 3;
        lpDevI->D3DStats.dwTrianglesDrawn += lpDevI->dwNumPrimitives;
        return lpDevI->dwNumPrimitives * 3;
    }
    return 0;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "BeginEnd"

HRESULT FlushBeginEndBatch(LPDIRECT3DDEVICEI lpDevI, BOOL leaving)
{
    HRESULT ret;
#ifdef _X86_
    unsigned short fpsave, fptemp;
#endif

    if (lpDevI->dwBENumIndices == 0xFFFFFFFF)
        lpDevI->dwNumVertices = GetNumPrimBE(lpDevI, lpDevI->dwBENumVertices);
    else
        lpDevI->dwNumIndices = GetNumPrimBE(lpDevI, lpDevI->dwBENumIndices);

    if (lpDevI->dwNumPrimitives < 1)
    {
        return DDERR_INVALIDPARAMS;
    }

    ret = (*lpDevI->pfnDoFlushBeginEnd)(lpDevI);

    /*
     * ReInit the device Begin/End states
     */
    if (!leaving)
        /*
         * Figure out how many and which vertices to keep for next batch.
         */
    {
        DWORD *dataCountPtr;
        DWORD vertexSize;       // size in bytes
        DWORD offset;           // start offset

        lpDevI->wFlushed = TRUE;

        if (lpDevI->lpVertexIndices)
        {
            dataCountPtr = &(lpDevI->dwBENumIndices);
            lpDevI->lpcCurrentPtr = (char*)lpDevI->lpVertexIndices;
            vertexSize = 2;
            offset = lpDevI->dwBENumIndices * 2;
        }
        else
        {
            dataCountPtr = &(lpDevI->dwBENumVertices);
            lpDevI->lpcCurrentPtr = (char*)lpDevI->lpvVertexData;
            vertexSize = lpDevI->position.dwStride;
            offset = lpDevI->dwBENumVertices * lpDevI->position.dwStride;
        }
        switch (lpDevI->primType)
        {
        case D3DPT_LINELIST:
            if (*dataCountPtr & 1)
            {
                MoveData(lpDevI->lpcCurrentPtr, 0, offset - vertexSize,
                         vertexSize);
                *dataCountPtr = 1;
                lpDevI->lpcCurrentPtr += vertexSize;
            } else
                *dataCountPtr = 0;
            break;
        case D3DPT_LINESTRIP:
            MoveData(lpDevI->lpcCurrentPtr, 0, offset - vertexSize, vertexSize);
            *dataCountPtr = 1;
            lpDevI->lpcCurrentPtr += vertexSize;
            break;
        case D3DPT_TRIANGLEFAN:
            MoveData(lpDevI->lpcCurrentPtr, vertexSize, offset - vertexSize,
                     vertexSize);
            *dataCountPtr = 2;
            lpDevI->lpcCurrentPtr += (vertexSize << 1);
            break;
        case D3DPT_TRIANGLESTRIP:
        {
            DWORD size = vertexSize << 1;
            MoveData(lpDevI->lpcCurrentPtr, 0, offset - size, size);
            *dataCountPtr = 2;
            lpDevI->lpcCurrentPtr += size;
            break;
        }
        case D3DPT_POINTLIST:
            *dataCountPtr = 0;
            break;
        case D3DPT_TRIANGLELIST:
        {
            DWORD rem = (*dataCountPtr % 3);
            if ( rem != 0 )
            {
                DWORD size = rem * vertexSize;
                MoveData(lpDevI->lpcCurrentPtr, 0, offset - size, size);
            }
            *dataCountPtr = rem;
            lpDevI->lpcCurrentPtr += rem * vertexSize;
        }
        break;
        default:
            D3D_ERR( "Unknown or unsupported primitive type requested in BeginEnd" );
            ret = D3DERR_INVALIDPRIMITIVETYPE;
        }
    }

    return ret;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CheckBegin"

HRESULT CheckBegin(LPDIRECT3DDEVICEI lpDevI,
                          D3DPRIMITIVETYPE ptPrimitiveType,
                          DWORD dwVertexType,
                          DWORD dwFlags)
{
    lpDevI->dwFlags = 0;
#if DBG
    switch (ptPrimitiveType)
    {
    case D3DPT_POINTLIST:
    case D3DPT_LINELIST:
    case D3DPT_LINESTRIP:
    case D3DPT_TRIANGLELIST:
    case D3DPT_TRIANGLESTRIP:
    case D3DPT_TRIANGLEFAN:
        break;
    default:
        D3D_ERR( "Invalid primitive type given to Begin" );
        return DDERR_INVALIDPARAMS;
    }

    if (dwFlags & __NON_FVF_INPUT)
    {
        switch ((D3DVERTEXTYPE)dwVertexType)
        {
        case D3DVT_TLVERTEX:
        case D3DVT_LVERTEX:
        case D3DVT_VERTEX:
            break;
        default:
            D3D_ERR( "Invalid vertex type given to Begin" );
            return DDERR_INVALIDPARAMS;
        }
        if (!IsDPFlagsValid(dwFlags & ~__NON_FVF_INPUT))
            return DDERR_INVALIDPARAMS;
        lpDevI->dwVIDIn = d3dVertexToFVF[dwVertexType];
        dwFlags &= ~__NON_FVF_INPUT;
    }
    else
    {
        if (ValidateFVF(dwVertexType) != D3D_OK)
            return DDERR_INVALIDPARAMS;
        lpDevI->dwVIDIn = dwVertexType;
    }

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(lpDevI))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

#else
    lpDevI->dwVIDIn = dwVertexType;
#endif
    HRESULT err = CheckDeviceSettings(lpDevI);
    if (err != D3D_OK)
        return err;
    err = CheckVertexBatch(lpDevI);
    if (err != D3D_OK)
        return err;

    // acts as boolean
    lpDevI->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_INBEGIN;
    // indicates first flush
    lpDevI->dwHintFlags &= ~D3DDEVBOOL_HINTFLAGS_INBEGIN_FIRST_FLUSH;
    lpDevI->primType = ptPrimitiveType;
    lpDevI->position.dwStride = GetVertexSizeFVF(lpDevI->dwVIDIn);
    lpDevI->dwBENumVertices = 0;
    ComputeOutputFVF(lpDevI);

    // dwMaxVertexCount should be even to properly break a primitive when
    // flushing
    lpDevI->dwMaxVertexCount = (BEGIN_DATA_BLOCK_MEM_SIZE /
                                lpDevI->position.dwStride) & ~1;
    lpDevI->dwMaxIndexCount = BEGIN_DATA_BLOCK_SIZE * 16;
    lpDevI->dwBENumIndices = 0;
    lpDevI->lpvVertexData = NULL;
    lpDevI->lpVertexIndices = NULL;
    lpDevI->dwFlags |= dwFlags;
    lpDevI->wFlushed = FALSE;
    if (lpDevI->dwVIDIn & D3DFVF_NORMAL)
        lpDevI->dwFlags |= D3DPV_LIGHTING;
    return D3D_OK;
}
//*********************************************************************
//                     API calls
//*********************************************************************
#undef DPF_MODNAME
#define DPF_MODNAME "Begin"

HRESULT D3DAPI
DIRECT3DDEVICEI::Begin(D3DPRIMITIVETYPE ptPrimitiveType,
                       DWORD dwVertexType,
                       DWORD dwFlags)
{
    HRESULT ret;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                            // Release in the destructor

    /*
     * Check/validate parameters, initialize related fields in the device.
     */
    if ((ret = CheckBegin(this, ptPrimitiveType, dwVertexType, dwFlags)) != D3D_OK)
    {
        return ret;
    }
    Profile(PROF_BEGIN,ptPrimitiveType,dwVertexType);
    this->dwBENumIndices = 0xffffffff;    // mark as being in Begin rather
                                        // than BeginIndexed

    lpvVertexData = lpvVertexBatch;
    lpcCurrentPtr = (char*)lpvVertexBatch;

    pfnDoFlushBeginEnd = DoFlushBeginEnd;

    if ( IS_MT_DEVICE(this) )
        EnterCriticalSection(&BeginEndCSect);

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "BeginIndexed"

HRESULT D3DAPI
DIRECT3DDEVICEI::BeginIndexed(D3DPRIMITIVETYPE ptPrimitiveType,
                              DWORD vtVertexType,
                              LPVOID lpvVertices,
                              DWORD dwNumVertices,
                              DWORD dwFlags)
{
    HRESULT ret;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                            // Release in the destructor
#if DBG
    if (ptPrimitiveType == D3DPT_POINTLIST)
    {
        D3D_ERR( "BeginIndexed does not support D3DPT_POINTLIST" );
        return DDERR_INVALIDPARAMS;
    }

    /*
     * validate lpvVertices & dwNumVertices
     */
    if ( dwNumVertices > 65535ul )
    {
        D3D_ERR( "BeginIndexed vertex array > 64K" );
        return DDERR_INVALIDPARAMS;
    }
    if ( dwNumVertices == 0ul )
    {
        D3D_ERR( "Number of vertices for BeginIndexed is zero" );
        return DDERR_INVALIDPARAMS;
    }
    TRY
    {
        if (!VALID_PTR(lpvVertices, sizeof(D3DVERTEX)*dwNumVertices))
        {
            D3D_ERR( "Invalid vertex pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    /*
     * Check/validate parameters, initialize related fields in the device.
     */
    if ((ret = CheckBegin(this, ptPrimitiveType, vtVertexType, dwFlags)) != D3D_OK)
        return ret;
    
    Profile(PROF_BEGININDEXED,ptPrimitiveType,vtVertexType);

    this->dwBENumVertices = dwNumVertices;
    this->lpvVertexData = lpvVertices;
    this->pfnDoFlushBeginEnd = DoFlushBeginIndexedEnd;
    this->lpVertexIndices = this->lpIndexBatch;
    this->lpcCurrentPtr = (char*)this->lpIndexBatch;

    if ( IS_MT_DEVICE(this) )
        EnterCriticalSection(&this->BeginEndCSect);

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Begin(D3DVERTEXTYPE)"

HRESULT D3DAPI
DIRECT3DDEVICEI::Begin(D3DPRIMITIVETYPE ptPrimitiveType,
                       D3DVERTEXTYPE vertexType,
                       DWORD dwFlags)
{
#if DBG
    dwFlags |= __NON_FVF_INPUT;
    return Begin(ptPrimitiveType, (DWORD)vertexType, dwFlags);
#else
    return Begin(ptPrimitiveType, (DWORD)d3dVertexToFVF[vertexType], dwFlags);
#endif
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "BeginIndexed(D3DVERTEXTYPE)"

HRESULT D3DAPI
DIRECT3DDEVICEI::BeginIndexed(D3DPRIMITIVETYPE ptPrimitiveType,
                              D3DVERTEXTYPE  vertexType,
                              LPVOID lpvVertices,
                              DWORD dwNumVertices,
                              DWORD dwFlags)
{
#if DBG
    dwFlags |= __NON_FVF_INPUT;
    return BeginIndexed(ptPrimitiveType, (DWORD) vertexType, lpvVertices,
                        dwNumVertices, dwFlags);
#else
    return BeginIndexed(ptPrimitiveType, (DWORD) d3dVertexToFVF[vertexType], lpvVertices,
                        dwNumVertices, dwFlags);
#endif
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Vertex"

HRESULT D3DAPI
DIRECT3DDEVICEI::Vertex(LPVOID lpVertex)
{
    D3DVERTEX       *dataPtr;
    HRESULT         ret = D3D_OK;
#if DBG
    // validate parms
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer in Vertex" );
            return DDERR_INVALIDOBJECT;
        }
        if (lpVertex == NULL || (! VALID_PTR(lpVertex, 32)) )
        {
            D3D_ERR( "Invalid vertex pointer in Vertex" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in Vertex" );
        CleanupBeginEnd(this);
        return DDERR_INVALIDPARAMS;
    }

    if (!(this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN))
    {
        D3D_ERR( "Vertex call not in Begin" );
        CleanupBeginEnd(this);
        return D3DERR_NOTINBEGIN;
    }
#endif
    // store the data
    if (dwBENumVertices >= dwMaxVertexCount)
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                                // Release in the destructor
        if ((ret = FlushBeginEndBatch(this, FALSE)) != D3D_OK)
        {
            CleanupBeginEnd(this);
            return ret;
        }
    }
    memcpy(lpcCurrentPtr, lpVertex, this->position.dwStride);
    lpcCurrentPtr += this->position.dwStride;
    dwBENumVertices++;

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Index"

HRESULT D3DAPI
DIRECT3DDEVICEI::Index(WORD dwIndex)
{
    WORD    *dataPtr;
    DWORD   *dataCountPtr;
    HRESULT ret = D3D_OK;
#if DBG
    // validate parms
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer in Index" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in Index" );
        CleanupBeginEnd(this);
        return DDERR_INVALIDPARAMS;
    }

    if (!(this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN))
    {
        D3D_ERR( "Index call not in Begin" );
        CleanupBeginEnd(this);
        return D3DERR_NOTINBEGIN;
    }

    // check if data valid
    if (this->dwBENumVertices < dwIndex)
    {
        D3D_ERR( "Invalid index value passed to Index" );
        CleanupBeginEnd(this);
        return DDERR_INVALIDPARAMS;
    }
#endif
    // store the data
    if (dwBENumIndices >= dwMaxIndexCount)
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                                // Release in the destructor
        if ((ret = FlushBeginEndBatch(this, FALSE)) != D3D_OK)
        {
            CleanupBeginEnd(this);
            return ret;
        }
    }
    *(WORD*)lpcCurrentPtr = dwIndex;
    dwBENumIndices++;
    lpcCurrentPtr += 2;

    return D3D_OK;
}   // end of D3DDev2_Index()
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "End"

HRESULT D3DAPI
DIRECT3DDEVICEI::End(DWORD dwFlags)
{
    HRESULT ret;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                            // Release in the destructor
#if DBG
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if ( !(this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN))
    {
        D3D_ERR( "End not in Begin/BeginIndex" );
        return D3DERR_NOTINBEGIN;
    }
#endif
    if ( IS_MT_DEVICE(this) )
        LeaveCriticalSection(&this->BeginEndCSect);

    /*
     * Draw the primitives
     */
    ret = FlushBeginEndBatch(this, TRUE);

    if (IS_DP2HAL_DEVICE(this) && 
        this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN_BIG_PRIM)
    {
        CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
        ret = dev->EndPrim(this->dwNumVertices * this->dwOutputSize);
    }
    CleanupBeginEnd(this);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxdiag\testsnd.h ===
/****************************************************************************
 *
 *    File: testsnd.h
 * Project: DxDiag (DirectX Diagnostic Tool)
 *  Author: Kerim Erden (a-kerime@microsoft.com)
 * Purpose: Test DSound functionality on this machine
 *
 * (C) Copyright 1998 Microsoft Corp.  All rights reserved.
 *
 ****************************************************************************/

#ifndef TESTSND_H
#define TESTSND_H

VOID TestSnd(HWND hwndMain, SoundInfo* pSoundInfo);

#endif // TESTSND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\bufiunk.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   bufiunk.c
 *  Content:    Direct3DExecuteBuffer IUnknown implementation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * D3DBuf_QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::QueryInterface"

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{

    /*
     * validate parms
     */
    TRY
        {
            if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
                D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
                return DDERR_INVALIDOBJECT;
            }
            if (!VALID_OUTPTR(ppvObj)) {
                D3D_ERR( "Invalid object pointer" );
                return DDERR_INVALIDPARAMS;
            }
        }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
            D3D_ERR( "Exception encountered validating parameters" );
            return DDERR_INVALIDPARAMS;
        }

    *ppvObj = NULL;

    if( IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IDirect3DExecuteBuffer) )
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPUNKNOWN>(this));

        return (D3D_OK);
    }
    return (E_NOINTERFACE);

} /* D3DBuf_QueryInterface */

/*
 * D3DBuf_AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::AddRef"

ULONG D3DAPI DIRECT3DEXECUTEBUFFERI::AddRef()
{
    DWORD       rcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
        {
            if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
                D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
                return 0;
            }
        }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
            D3D_ERR( "Exception encountered validating parameters" );
            return 0;
        }

    this->refCnt++;
    rcnt = this->refCnt;

    return (rcnt);

} /* D3DBuf_AddRef */

/*
 * D3DBuf_Release
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::Release"

ULONG D3DAPI DIRECT3DEXECUTEBUFFERI::Release()
{
    DWORD           lastrefcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
        {
            if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
                D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
                return 0;
            }
        }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
            D3D_ERR( "Exception encountered validating parameters" );
            return 0;
        }

    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    lastrefcnt = this->refCnt;

    if( lastrefcnt == 0 )
    {
        delete this;
        return 0;
    }

    return lastrefcnt;

} /* D3DBuf_Release */

DIRECT3DEXECUTEBUFFERI::~DIRECT3DEXECUTEBUFFERI()
{
    if (this->locked) 
        Unlock();

    /* remove us from the Direct3DDevice object list of execute buffers */
    LIST_DELETE(this, list);

    if (this->hBuf) 
    {
        D3DHAL_DeallocateBuffer(this->lpDevI, this->hBuf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\d3dcreat.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3di.h
 *  Content:    Direct3D HAL include file
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   09/11/95   stevela Initial rev with this header.
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *                      Validate args.
 *   17/04/96   colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *   29/04/96   colinmc Bug 19954: Must query for Direct3D before texture
 *                      or device
 *   27/08/96   stevela Ifdefed out definition of ghEvent as we're using
 *                      DirectDraw's critical section.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Create an api for the Direct3D object
 */

// Remove DDraw's type unsafe definition and replace with our C++ friendly def
#ifdef VALIDEX_CODE_PTR
#undef VALIDEX_CODE_PTR
#endif
#define VALIDEX_CODE_PTR( ptr ) \
(!IsBadCodePtr( (FARPROC) ptr ) )

LPCRITICAL_SECTION      lpD3DCSect;

#if DBG
    int     iD3DCSCnt;
#endif

HRESULT D3DAPI DIRECT3DI::Initialize(REFCLSID riid)
{
    return DDERR_ALREADYINITIALIZED;
}
//---------------------------------------------------------------------
// for use by fns that take a GUID param before device is created
BOOL IsValidD3DDeviceGuid(REFCLSID riid) {

    if (IsBadReadPtr(&riid, sizeof(CLSID))) {
        return FALSE;
    }
    if( IsEqualIID(riid, IID_IDirect3DRampDevice) ||
        IsEqualIID(riid, IID_IDirect3DRGBDevice)  ||
        IsEqualIID(riid, IID_IDirect3DMMXDevice)  ||
        IsEqualIID(riid, IID_IDirect3DHALDevice)  ||
        IsEqualIID(riid, IID_IDirect3DRefDevice)  ||
        IsEqualIID(riid, IID_IDirect3DNullDevice) ||
        IsEqualIID(riid, IID_IDirect3DNewRGBDevice)) {
       return TRUE;
    } else {
        return FALSE;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DCreate"

DIRECT3DI::DIRECT3DI(IUnknown* pUnkOuter, LPDDRAWI_DIRECTDRAW_INT pDDrawInt)
{
    // HACK.  D3D needs a DD1 DDRAWI interface because it uses CreateSurface1 internally
    // for exebufs, among other things.  Because pDDrawInt could be any DDRAWI type,
    // we need to QI to find a DD1 interface.  But the D3DI object cannot keep a reference
    // to its parent DD object because it is aggegrated with the DD obj, so that would constitute
    // a circular reference that would prevent deletion. So we QI for DD1 interface, copy it into D3DI
    // and release it, then point lpDD at the copy. (disgusting)

    // another HACK alert: dont know which DDRAWI type pDDrawInt is, but a cast to LPDIRECTDRAW should
    // work because QI is in the same place in all the DDRAWI vtables and is the same fn for all
    HRESULT ret;

    ret = ((LPDIRECTDRAW)pDDrawInt)->QueryInterface(IID_IDirectDraw, (LPVOID*)&lpDD);
    if(FAILED(ret)) {
      lpDD=NULL;  //signal failure
      D3D_ERR( "QueryInterface for IDDraw failed" );
      return;
    }
    memcpy(&DDInt_DD1,lpDD,sizeof(DDInt_DD1));
    lpDD->Release();
    lpDD=(LPDIRECTDRAW)&DDInt_DD1;

    ret = ((LPDIRECTDRAW)pDDrawInt)->QueryInterface(IID_IDirectDraw4, (LPVOID*)&lpDD4);
    if(FAILED(ret))
    {
        lpDD4=NULL;  //signal failure
        D3D_WARN(1,"QueryInterface for IDDraw4 failed" );
    }
    else
    {
        memcpy(&DDInt_DD4,lpDD4,sizeof(DDInt_DD4));
        lpDD4->Release();
        lpDD4=(LPDIRECTDRAW4)&DDInt_DD4;
        D3D_INFO(4,"QueryInterface for IDDraw4 succeeded" );
    }

    numDevs =
        numViewports =
        numLights =
        numMaterials = 0;
    mD3DUnk.pD3DI = this;
    mD3DUnk.refCnt = 1;


    LIST_INITIALIZE(&devices);
    LIST_INITIALIZE(&viewports);
    LIST_INITIALIZE(&lights);
    LIST_INITIALIZE(&materials);

    v_next = 1;
    lpFreeList=NULL;    /* nothing is allocated initially */
    lpBufferList=NULL;
    lpTextureManager=new TextureCacheManager(this);


    /*
     * Are we really being aggregated?
     */
    if (pUnkOuter != NULL)
    {
        /*
         * Yup - we are being aggregated. Store the supplied
         * IUnknown so we can punt to that.
         * NOTE: We explicitly DO NOT AddRef here.
         */
        this->lpOwningIUnknown = pUnkOuter;
        /*
         * Store away the interface pointer
         */
    }
    else
    {
        /*
         * Nope - but we pretend we are anyway by storing our
         * own IUnknown as the parent IUnknown. This makes the
         * code much neater.
         */
        this->lpOwningIUnknown = static_cast<LPUNKNOWN>(&this->mD3DUnk);
    }
}



extern "C" HRESULT WINAPI Direct3DCreate(LPCRITICAL_SECTION lpDDCSect,
                                         LPUNKNOWN*         lplpDirect3D,
                                         IUnknown*          pUnkOuter)
{
    LPDIRECT3DI pd3d;

    DPFINIT();

    /*
     * No need to validate params as DirectDraw is giving them to us.
     */

    /*
     * Is another thread coming in and is this the first time?
     */

    /*
     * We can let every invocation of this function assign
     * the critical section as we know its always going to
     * be the same value (for a D3D session).
     */
    lpD3DCSect = lpDDCSect;
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    *lplpDirect3D = NULL;

    // We do not support non aggregated Direct3D object yet
    if (!pUnkOuter)
        return DDERR_INVALIDPARAMS;

    if (!(pd3d = static_cast<LPDIRECT3DI>(new DIRECT3DI(pUnkOuter, (LPDDRAWI_DIRECTDRAW_INT)pUnkOuter))))
    {
        return (DDERR_OUTOFMEMORY);
    }

    if(pd3d->lpDD==NULL) {  //QI failed
       delete pd3d;
       return E_NOINTERFACE;
    }

    /*
     * NOTE: The special IUnknown is returned and not the actual
     * Direct3D interface so you can't use this to drive Direct3D.
     * You must query off this interface for the Direct3D interface.
     */
    *lplpDirect3D = static_cast<LPUNKNOWN>(&(pd3d->mD3DUnk));

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::EnumDevices"

extern BOOL isMMXprocessor(void);

typedef struct _D3DI_DeviceType {
    CONST GUID *pGuid;
    char name[256];
    char description[512];
} D3DI_DeviceType;

// Static definitions for various enumerable devices
static D3DI_DeviceType RampDevice =
{
    &IID_IDirect3DRampDevice, "Ramp Emulation",
    "Microsoft Direct3D Mono(Ramp) Software Emulation"
};
static D3DI_DeviceType RGBDevice =
{
    &IID_IDirect3DRGBDevice, "RGB Emulation",
    "Microsoft Direct3D RGB Software Emulation"
};
static D3DI_DeviceType HALDevice =
{
    &IID_IDirect3DHALDevice, "Direct3D HAL",
    "Microsoft Direct3D Hardware acceleration through Direct3D HAL"
};
static D3DI_DeviceType MMXDevice =
{
    &IID_IDirect3DMMXDevice, "MMX Emulation",
    "Microsoft Direct3D MMX Software Emulation"
};
static D3DI_DeviceType RefDevice =
{
    &IID_IDirect3DRefDevice, "Reference Rasterizer",
    "Microsoft Reference Rasterizer"
};
static D3DI_DeviceType NullDevice =
{
    &IID_IDirect3DNullDevice, "Null device",
    "Microsoft Null Device"
};

static D3DI_DeviceType *AllDevices[] =
{
    &RampDevice, &RGBDevice, &HALDevice, &MMXDevice, &RefDevice, &NullDevice, NULL
};

HRESULT
DIRECT3DI::EnumDevices(LPD3DENUMDEVICESCALLBACK lpEnumCallback,
                       LPVOID lpContext, DWORD dwSize, DWORD dwVer)
{
    HRESULT err, userRet;
    HKEY hKey;
    LONG result;
    int i;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALIDEX_CODE_PTR((FARPROC)lpEnumCallback)) {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    BOOL bSoftwareOnly = FALSE;
    DWORD dwEnumReference = 0;
    BOOL bEnumNullDevice = FALSE;
    BOOL bEnumSeparateMMX = FALSE;

    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RESPATH, 0, KEY_READ, &hKey);
    if (result == ERROR_SUCCESS)
    {
        DWORD dwData, dwType;
        DWORD dwDataSize;

        // Enumerate software rasterizers only ?
        dwDataSize = sizeof(dwData);
        result = RegQueryValueEx(hKey, "SoftwareOnly", NULL,
                                 &dwType, (BYTE *) &dwData, &dwDataSize);
        if ( result == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            bSoftwareOnly = ( dwData != 0 );
        }

        // Enumerate Reference Rasterizer ?
        dwDataSize = sizeof(dwData);
        result = RegQueryValueEx(hKey, "EnumReference", NULL,
                                 &dwType, (BYTE *)&dwData, &dwDataSize);
        if (result == ERROR_SUCCESS &&
            dwType == REG_DWORD &&
            dwDataSize == sizeof(dwData))
        {
            dwEnumReference = dwData;
        }

        if (dwVer >= 3)
        {
            // Enumerate MMX Rasterizer separately for DX6?
            dwDataSize = sizeof(dwData);
            result = RegQueryValueEx(hKey, "EnumSeparateMMX", NULL,
                                     &dwType, (BYTE *)&dwData, &dwDataSize);
            if (result == ERROR_SUCCESS &&
                dwType == REG_DWORD &&
                dwDataSize == sizeof(dwData))
            {
                bEnumSeparateMMX = (BOOL)dwData;
            }
        }
        else
        {
            // Enumerate MMX Rasterizer separately for DX5
            // MMX is not enumerated for DX3 and older later
            bEnumSeparateMMX = TRUE;
        }

        // Enumerate Null Device ?
        dwDataSize = sizeof(dwData);
        result = RegQueryValueEx(hKey, "EnumNullDevice", NULL,
                                 &dwType, (BYTE *)&dwData, &dwDataSize);
        if (result == ERROR_SUCCESS &&
            dwType == REG_DWORD &&
            dwDataSize == sizeof(dwData))
        {
            bEnumNullDevice = (BOOL)dwData;
        }


        RegCloseKey( hKey );
    }

    D3DI_DeviceType **lpDevices = AllDevices;

    userRet = D3DENUMRET_OK;
    for (i = 0; lpDevices[i] && userRet == D3DENUMRET_OK; i++)
    {
        LPSTR drvName = lpDevices[i]->name;
        LPSTR drvDesc = lpDevices[i]->description;
        REFCLSID riid = *lpDevices[i]->pGuid;
        D3DDEVICEDESC HWDesc;
        D3DDEVICEDESC HELDesc;
        LPDDRAWI_DIRECTDRAW_GBL lpDDGbl;
        IHalProvider *pHalProv;
        HINSTANCE hDll;

        if ( (dwVer < 2 || !isMMXprocessor()) &&
             IsEqualIID(riid, IID_IDirect3DMMXDevice ) )
        {
            // Not Device2, not on MMX machine, or DisableMMX is set.
            // Don't enumerate the MMX device.
            continue;
        }

        if ( !bEnumSeparateMMX &&
             IsEqualIID(riid, IID_IDirect3DMMXDevice ) )
        {
            // Not enumerating MMX separate from RGB.
            continue;
        }

        if ( IsEqualIID(riid, IID_IDirect3DRefDevice) &&
             !(dwEnumReference == 1) &&                     // enumerate for all devices if value == 1
             !( (dwVer >= 3) && (dwEnumReference == 2) ) )  // enumerate for Device3+ if value == 2
        {
            // Not enumerating the reference.
            continue;
        }

        if (!bEnumNullDevice &&
            IsEqualIID(riid, IID_IDirect3DNullDevice))
        {
            // Not enumerating the Null device.
            continue;
        }

#ifndef _X86_
        if (IsEqualIID(riid, IID_IDirect3DRampDevice))
        {
            // Not enumerating ramp for non-x86 (alpha) platforms.
            continue;
        }
#endif

        if((dwVer>=3) && IsEqualIID(riid, IID_IDirect3DRampDevice)) {
            // Ramp not available in Device3.  No more old-style texture handles.
            continue;
        }

        // By COM definition, our owning IUnknown is a pointer to the
        // DirectDraw object that was used to create us.
        // Check this for the existence of a Direct3D HAL.
        lpDDGbl = ((LPDDRAWI_DIRECTDRAW_INT)this->lpDD)->lpLcl->lpGbl;

        // See if this is a software driver.
        err = GetSwHalProvider(riid, &pHalProv, &hDll);
        if (err == S_OK)
        {
            // Successfully got a software driver.
        }
        else if (err == E_NOINTERFACE &&
                 ! bSoftwareOnly &&
                 GetHwHalProvider(riid, &pHalProv, &hDll, lpDDGbl) == S_OK)
        {
            // Successfully got a hardware driver.
        }
        else
        {
            // Unrecognized driver.
            continue;
        }

        err = pHalProv->GetCaps(lpDDGbl, &HWDesc, &HELDesc, dwVer);

        pHalProv->Release();
        if (hDll != NULL)
        {
            FreeLibrary(hDll);
        }

        if (err != S_OK)
        {
            continue;
        }

        HWDesc.dwSize = dwSize;
        HELDesc.dwSize = dwSize;

        userRet = (*lpEnumCallback)((GUID *) lpDevices[i]->pGuid, drvDesc, drvName,
                                    &HWDesc, &HELDesc, lpContext);
    }

    return D3D_OK;
}

HRESULT D3DAPI CDirect3D::EnumDevices(LPD3DENUMDEVICESCALLBACK lpEnumCallback,
                                      LPVOID lpContext)
{
    return EnumDevices(lpEnumCallback, lpContext, D3DDEVICEDESCSIZE_V1, 1);
}

HRESULT D3DAPI CDirect3D2::EnumDevices(LPD3DENUMDEVICESCALLBACK lpEnumCallback,
                                       LPVOID lpContext)
{
    return EnumDevices(lpEnumCallback, lpContext, D3DDEVICEDESCSIZE_V2, 2);
}

HRESULT D3DAPI CDirect3D3::EnumDevices(LPD3DENUMDEVICESCALLBACK lpEnumCallback,
                                       LPVOID lpContext)
{
    return EnumDevices(lpEnumCallback, lpContext, D3DDEVICEDESCSIZE, 3);
}

#define MATCH(cap)      ((matchCaps->cap & primCaps->cap) == matchCaps->cap)

static BOOL MatchCaps(DWORD dwFlags,
                      LPD3DPRIMCAPS matchCaps,
                      LPD3DPRIMCAPS primCaps)
{
    if (dwFlags & D3DFDS_MISCCAPS) {
        if (!MATCH(dwMiscCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_RASTERCAPS) {
        if (!MATCH(dwRasterCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_ZCMPCAPS) {
        if (!MATCH(dwZCmpCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_ALPHACMPCAPS) {
        if (!MATCH(dwAlphaCmpCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_SRCBLENDCAPS) {
        if (!MATCH(dwSrcBlendCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_DSTBLENDCAPS) {
        if (!MATCH(dwDestBlendCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_SHADECAPS) {
        if (!MATCH(dwShadeCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_TEXTURECAPS) {
        if (!MATCH(dwTextureCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_TEXTUREFILTERCAPS) {
        if (!MATCH(dwTextureFilterCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_TEXTUREBLENDCAPS) {
        if (!MATCH(dwTextureBlendCaps))
            return FALSE;
    }
    if (dwFlags & D3DFDS_TEXTUREADDRESSCAPS) {
        if (!MATCH(dwTextureAddressCaps))
            return FALSE;
    }
    return TRUE;
}

#undef MATCH

typedef struct _enumArgs {
    D3DFINDDEVICESEARCH search;

    int                 foundHardware;
    int                 foundSoftware;
    D3DFINDDEVICERESULT result;
} enumArgs;

HRESULT WINAPI enumFunc(LPGUID lpGuid,
                        LPSTR lpDeviceDescription,
                        LPSTR lpDeviceName,
                        LPD3DDEVICEDESC lpHWDesc,
                        LPD3DDEVICEDESC lpHELDesc,
                        LPVOID lpContext)
{
    enumArgs* lpArgs = (enumArgs*)lpContext;
    BOOL bHardware = (lpHWDesc->dcmColorModel != 0);

    if (lpArgs->search.dwFlags & D3DFDS_GUID) {
        if (!IsEqualGUID(lpArgs->search.guid, *lpGuid))
            return D3DENUMRET_OK;
    }

    if (lpArgs->search.dwFlags & D3DFDS_HARDWARE) {
        if (lpArgs->search.bHardware != bHardware)
            return D3DENUMRET_OK;
    }

    if (lpArgs->search.dwFlags & D3DFDS_COLORMODEL) {
        if ((lpHWDesc->dcmColorModel & lpArgs->search.dcmColorModel) == 0
            && (lpHELDesc->dcmColorModel & lpArgs->search.dcmColorModel) == 0) {
            return D3DENUMRET_OK;
        }
    }

    if (lpArgs->search.dwFlags & D3DFDS_TRIANGLES) {
        if (!MatchCaps(lpArgs->search.dwFlags,
                       &lpArgs->search.dpcPrimCaps, &lpHWDesc->dpcTriCaps)
            && !MatchCaps(lpArgs->search.dwFlags,
                          &lpArgs->search.dpcPrimCaps, &lpHELDesc->dpcTriCaps))
            return D3DENUMRET_OK;
    }

    if (lpArgs->search.dwFlags & D3DFDS_LINES) {
        if (!MatchCaps(lpArgs->search.dwFlags,
                       &lpArgs->search.dpcPrimCaps, &lpHWDesc->dpcLineCaps)
            && !MatchCaps(lpArgs->search.dwFlags,
                          &lpArgs->search.dpcPrimCaps, &lpHELDesc->dpcLineCaps))
            return D3DENUMRET_OK;
    }

    if (lpArgs->foundHardware && !bHardware)
        return D3DENUMRET_OK;

    if (bHardware)
        lpArgs->foundHardware = TRUE;
    else
        lpArgs->foundSoftware = TRUE;

    lpArgs->result.guid = *lpGuid;

    lpArgs->result.ddHwDesc = *lpHWDesc;
    lpArgs->result.ddSwDesc = *lpHELDesc;

    return D3DENUMRET_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::FindDevice"


HRESULT D3DAPI CDirect3D::FindDevice(LPD3DFINDDEVICESEARCH lpSearch, LPD3DFINDDEVICERESULT lpResult)
{
    return FindDevice(lpSearch,lpResult,1);
}

HRESULT D3DAPI CDirect3D2::FindDevice(LPD3DFINDDEVICESEARCH lpSearch, LPD3DFINDDEVICERESULT lpResult)
{
    return FindDevice(lpSearch,lpResult,2);
}

HRESULT D3DAPI CDirect3D3::FindDevice(LPD3DFINDDEVICESEARCH lpSearch, LPD3DFINDDEVICERESULT lpResult)
{
    return FindDevice(lpSearch,lpResult,3);
}

HRESULT
DIRECT3DI::FindDevice(LPD3DFINDDEVICESEARCH lpSearch,
                      LPD3DFINDDEVICERESULT lpResult, DWORD dwVer)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    TRY
    {
        if (!VALID_D3DFINDDEVICESEARCH_PTR(lpSearch)) {
            D3D_ERR( "Invalid search pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_D3DFINDDEVICERESULT_PTR(lpResult)) {
            D3D_ERR( "Invalid result pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    enumArgs args;
    memset(&args, 0, sizeof args);
    args.result.dwSize = sizeof(args.result);
    args.search = *lpSearch;

    switch(dwVer) {
        case 1: CDirect3D::EnumDevices(enumFunc, &args);  break;
        case 2: CDirect3D2::EnumDevices(enumFunc, &args);  break;
        case 3: CDirect3D3::EnumDevices(enumFunc, &args);  break;
    }

    if (args.foundHardware || args.foundSoftware) {
        DWORD dwSize = lpResult->dwSize;
        if (dwSize == sizeof( D3DFINDDEVICERESULT ) )
        {
            // The app is using DX6
            D3D_INFO(4, "New D3DFINDDEVICERESULT size");
            memcpy(lpResult, &args.result, lpResult->dwSize);
        }
        else
        {
            // The app is pre DX6
            DWORD dwSize = lpResult->dwSize;
            DWORD dDescSize = (dwSize - (sizeof(DWORD) + sizeof(GUID)))/2;
            D3D_INFO(4, "Old D3DFINDDEVICERESULT size");

            // Copy the header
            memcpy(lpResult, &args.result, sizeof(DWORD)+sizeof(GUID));

            //restore the size
            lpResult->dwSize = dwSize;

            // Copy and convert the embedded D3DDEVICEDESC's
            // DDescSize = (lpResult->dwSize - (sizeof(DWORD) + sizeof(GUID)))/2
            // This calculation assumes that the structure of
            // LPD3DFINDDEVICERESULT is the same as in DX6, DX5, if it is changed
            // This computation needs to be updated

            memcpy((LPVOID) (&lpResult->ddHwDesc),
                   &args.result.ddHwDesc,
                   dDescSize);
            memcpy((LPVOID) ((ULONG_PTR)&lpResult->ddHwDesc + dDescSize),
                   &args.result.ddSwDesc,
                   dDescSize);

        }
        return D3D_OK;
    }
    else
    {
        return DDERR_NOTFOUND;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DI::EnumZBufferFormats"

HRESULT D3DAPI DIRECT3DI::EnumZBufferFormats(REFCLSID riid,
                                             LPD3DENUMPIXELFORMATSCALLBACK lpEnumCallback,
                                             LPVOID lpContext)
{
    HRESULT ret, userRet;
    LPDDPIXELFORMAT lpTmpPixFmts;
    DWORD i,cPixFmts;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    ret = D3D_OK;

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3D3_PTR(this)) {
            D3D_ERR( "Invalid Direct3D3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALIDEX_CODE_PTR(lpEnumCallback)) {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }

        if(!IsValidD3DDeviceGuid(riid)) {
            D3D_ERR( "Invalid D3D Device GUID" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if(IsEqualIID(riid, IID_IDirect3DHALDevice)) {
        LPDDRAWI_DIRECTDRAW_GBL pDdGbl=((LPDDRAWI_DIRECTDRAW_INT)this->lpDD)->lpLcl->lpGbl;
        LPD3DHAL_GLOBALDRIVERDATA lpD3DHALGlobalDriverData=pDdGbl->lpD3DGlobalDriverData;
        DWORD dwHW_ZBitDepthFlags;
        if (NULL == lpD3DHALGlobalDriverData)
        {
            D3D_ERR("No HAL Support ZBufferBitDepths!");
            return (DDERR_NOZBUFFERHW);
        }
        cPixFmts=pDdGbl->dwNumZPixelFormats;
        if (cPixFmts==0) {
            // driver is pre-dx6, so it doesn't support stencil buffer pix fmts or this callback.
            // we can fake support using DD_BD bits in dwZBufferBitDepth in D3DDEVICEDESC
            D3D_WARN(6,"EnumZBufferFormats not supported directly by driver, faking it using dwDeviceZBufferBitDepth DD_BD bits");

            dwHW_ZBitDepthFlags=lpD3DHALGlobalDriverData->hwCaps.dwDeviceZBufferBitDepth;

            if(!(dwHW_ZBitDepthFlags & (DDBD_8|DDBD_16|DDBD_24|DDBD_32))) {
                    D3D_ERR("No Supported ZBufferBitDepths!");
                    return (DDERR_NOZBUFFERHW);
            }

            // malloc space for 4 DDPIXELFORMATs, since that the most there could be (DDBD_8,16,24,32)
            if (D3DMalloc((void**)&lpTmpPixFmts, 4*sizeof(DDPIXELFORMAT)) != D3D_OK) {
                    D3D_ERR("failed to alloc space for return descriptions");
                    return (DDERR_OUTOFMEMORY);
            }

            DWORD zdepthflags[4]= {DDBD_8,DDBD_16,DDBD_24,DDBD_32};
            DWORD zbitdepths[4]= {8,16,24,32};
            DWORD zbitmasks[4]= {0xff,0xffff,0xffffff,0xffffffff};

            memset(lpTmpPixFmts,0,sizeof(4*sizeof(DDPIXELFORMAT)));

            // create some DDPIXELFORMATs the app can look at
            for(i=0;i<4;i++) {
                if(dwHW_ZBitDepthFlags & zdepthflags[i]) {
                    lpTmpPixFmts[cPixFmts].dwSize=sizeof(DDPIXELFORMAT);
                    lpTmpPixFmts[cPixFmts].dwFlags=DDPF_ZBUFFER;
                    lpTmpPixFmts[cPixFmts].dwZBufferBitDepth=zbitdepths[i];
                    lpTmpPixFmts[cPixFmts].dwZBitMask= zbitmasks[i];
                    cPixFmts++;
                }
            }
        } else {
            // only show the app a temp copy of DDraw's real records

            if (D3DMalloc((void**)&lpTmpPixFmts, cPixFmts*sizeof(DDPIXELFORMAT)) != D3D_OK) {
                D3D_ERR("Out of memory allocating space for return descriptions");
                return (DDERR_OUTOFMEMORY);
            }
            memcpy(lpTmpPixFmts, pDdGbl->lpZPixelFormats, cPixFmts*sizeof(DDPIXELFORMAT));
        }
    } else {
        // Handle SW rasterizers
        DDPIXELFORMAT  *pDDPF;

        // malloc space for 10 DDPIXELFORMAT's, which is currently more than enough for the SW rasterizers
        if (D3DMalloc((void**)&lpTmpPixFmts, 10*sizeof(DDPIXELFORMAT)) != D3D_OK) {
                D3D_ERR("Out of memory allocating space for return descriptions");
                return (DDERR_OUTOFMEMORY);
        }

        cPixFmts=GetSwZBufferFormats(riid,&pDDPF);
        memcpy(lpTmpPixFmts, pDDPF, cPixFmts*sizeof(DDPIXELFORMAT));
    }

    userRet = D3DENUMRET_OK;
    for (i = 0; (i < cPixFmts) && (userRet == D3DENUMRET_OK); i++) {
        userRet = (*lpEnumCallback)(&lpTmpPixFmts[i], lpContext);
    }

    D3DFree(lpTmpPixFmts);

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::EnumOptTextureFormats"

HRESULT D3DAPI DIRECT3DI::EnumOptTextureFormats(REFCLSID riid, LPD3DENUMOPTTEXTUREFORMATSCALLBACK lpEnumCallback, LPVOID lpContext)
{
    HRESULT ret, userRet;
    LPDDSURFACEDESC lpDescs;
    LPDDSURFACEDESC2 lpRetDescs;
    LPDDOPTSURFACEDESC lpRetOptDescs;
    LPD3DHAL_GLOBALDRIVERDATA lpD3DHALGlobalDriverData;
    DWORD num_descs;
    DWORD i;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    ret = D3D_OK;
    //
    // Validation
    //

    TRY
    {
        if (!VALID_DIRECT3D3_PTR(this)) {
            D3D_ERR( "Invalid Direct3D pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALIDEX_CODE_PTR(lpEnumCallback)) {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if(!IsValidD3DDeviceGuid(riid)) {
            D3D_ERR( "Invalid D3D Device GUID" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if(IsEqualIID(riid, IID_IDirect3DHALDevice)) {

        lpD3DHALGlobalDriverData=((LPDDRAWI_DIRECTDRAW_INT)this->lpDD)->lpLcl->lpGbl->lpD3DGlobalDriverData;

        num_descs = lpD3DHALGlobalDriverData->dwNumTextureFormats;
        lpDescs = lpD3DHALGlobalDriverData->lpTextureFormats;
    } else {
        num_descs = GetSwTextureFormats(riid,&lpDescs,3/*enum for Device3*/);
    }

    if (!num_descs)
    {
        D3D_ERR("no texture formats supported");
        return (D3DERR_TEXTURE_NO_SUPPORT);
    }

    //
    // Make a local copy of these formats
    //
    if (D3DMalloc((void**)&lpRetDescs, sizeof(DDSURFACEDESC2) * num_descs)
        != D3D_OK)
    {
        D3D_ERR("Out of memory allocating space for return descriptions");
        return (DDERR_OUTOFMEMORY);
    }
    for (i=0; i<num_descs; i++)
    {
        // We can copy only the subset of the data
        memcpy(&lpRetDescs[i], &lpDescs[i], sizeof(DDSURFACEDESC));
    }
    userRet = D3DENUMRET_OK;

    //
    // First return the unoptimized formats......
    //
    for (i = 0; i < num_descs && userRet == D3DENUMRET_OK; i++)
    {
        userRet = (*lpEnumCallback)(&lpRetDescs[i], NULL, lpContext);
    }

    //
    // ......Now return the formats capable of being optimized
    //
    for (i = 0; i < num_descs && userRet == D3DENUMRET_OK; i++)
    {
        userRet = (*lpEnumCallback)(&lpRetDescs[i], NULL, lpContext);
    }

    D3DFree(lpRetDescs);

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3D::EvictManagedTextures"
HRESULT D3DAPI
DIRECT3DI::EvictManagedTextures()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    if (!VALID_DIRECT3D_PTR(this))
    {
        D3D_ERR( "Invalid Direct3D3 pointer" );
        return DDERR_INVALIDOBJECT;
    }
    lpTextureManager->EvictTextures();
    return  D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3D::FlushDevicesExcept"

HRESULT DIRECT3DI::FlushDevicesExcept(LPDIRECT3DDEVICEI pDev)
{
    LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&this->devices);
    while (lpDevI)
    {
        if(lpDevI != pDev)
        {
            HRESULT hr = lpDevI->FlushStates();
            if(hr != D3D_OK)
            {
                DPF_ERR("Error flushing device in FlushDevicesExcept");
                return hr;
            }
        }
        lpDevI = LIST_NEXT(lpDevI,list);
    }
    return D3D_OK;
}

extern "C" void WINAPI PaletteUpdateNotify(
    LPVOID pD3DIUnknown,
    DWORD dwPaletteHandle,
    DWORD dwStartIndex,
    DWORD dwNumberOfIndices,
    LPPALETTEENTRY pFirstIndex)
{
    LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pD3DIUnknown)->pD3DI;
    DDASSERT(lpD3D);
    LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
    while (lpDevI)
    {
        D3D_INFO(4,"PaletteUpdateNotify lpDevI(%x) %08lx %08lx %08lx %08lx",
            lpDevI,dwPaletteHandle,dwStartIndex,dwNumberOfIndices,*(DWORD*)&pFirstIndex[10]);
        if (IS_DX7HAL_DEVICE(lpDevI))
        {
            if(lpD3D->numDevs > 1)
                lpD3D->FlushDevicesExcept(lpDevI);
            static_cast<CDirect3DDeviceIDP2*>(lpDevI)->UpdatePalette(dwPaletteHandle,dwStartIndex,dwNumberOfIndices,pFirstIndex);
            if(lpD3D->numDevs > 1)
                lpDevI->FlushStates();
            break;
        }
        lpDevI = LIST_NEXT(lpDevI,list);
    }
}

extern "C" void WINAPI PaletteAssociateNotify(
    LPVOID pD3DIUnknown,
    DWORD dwPaletteHandle,
    DWORD dwPaletteFlags,
    DWORD dwSurfaceHandle )
{
    LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pD3DIUnknown)->pD3DI;
    DDASSERT(lpD3D);
    LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
    while (lpDevI)
    {
        D3D_INFO(4,"PaletteAssociateNotify lpDevI(%x) %08lx %08lx",
            lpDevI,dwPaletteHandle, dwSurfaceHandle);
        if (IS_DX7HAL_DEVICE(lpDevI))
        {
            if(lpD3D->numDevs > 1)
                lpD3D->FlushDevicesExcept(lpDevI);
            static_cast<CDirect3DDeviceIDP2*>(lpDevI)->SetPalette(dwPaletteHandle,dwPaletteFlags,dwSurfaceHandle);
            if(lpD3D->numDevs > 1)
                lpDevI->FlushStates();
            break;
        }
        lpDevI = LIST_NEXT(lpDevI,list);
    }
}

extern "C" void WINAPI SurfaceFlipNotify(LPVOID pD3DIUnknown)
{
    LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pD3DIUnknown)->pD3DI;
    DDASSERT(lpD3D);
    LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
    D3D_INFO(4,"SurfaceFlipNotify");
    while (lpDevI)
    {
        if (IS_DX7HAL_DEVICE(lpDevI))
        {
#ifndef WIN95
            if(lpDevI->hSurfaceTarget != ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface)
            {
                static_cast<CDirect3DDeviceIDP2*>(lpDevI)->SetRenderTargetI(lpDevI->lpDDSTarget,lpDevI->lpDDSZBuffer);
                lpDevI->hSurfaceTarget=((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface;
            }
#else
            if(lpDevI->hSurfaceTarget != ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->lpSurfMore->dwSurfaceHandle)
            {
                static_cast<CDirect3DDeviceIDP2*>(lpDevI)->SetRenderTargetI(lpDevI->lpDDSTarget,lpDevI->lpDDSZBuffer);
                lpDevI->hSurfaceTarget=((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->lpSurfMore->dwSurfaceHandle;
            }
#endif
        }
        lpDevI = LIST_NEXT(lpDevI,list);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "FlushD3DDevices"

extern "C" HRESULT WINAPI FlushD3DDevices(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
{
    LPD3DBUCKET list = reinterpret_cast<LPD3DBUCKET>(surf_lcl->lpSurfMore->lpD3DDevIList);
    while(list)
    {
        LPD3DBUCKET temp = list->next;
        reinterpret_cast<LPDIRECT3DDEVICEI>(list->lpD3DDevI)->FlushStates();
        list = temp;
    }
    return DD_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FlushD3DDevices2"

extern "C" HRESULT WINAPI FlushD3DDevices2(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
{
    LPD3DBUCKET list = reinterpret_cast<LPD3DBUCKET>(surf_lcl->lpSurfMore->lpD3DDevIList);
    while(list)
    {
        LPD3DBUCKET temp = list->next;
        if (list->lplpDDSZBuffer)   
            *list->lplpDDSZBuffer = 0; // detached
        reinterpret_cast<LPDIRECT3DDEVICEI>(list->lpD3DDevI)->FlushStates();
        list = temp;
    }
    return DD_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\d3ddev.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3ddev.cpp
 *  Content:    Direct3D device implementation
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: device.c,v 1.26 1995/12/04 11:29:47 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *   11/11/95   stevela Light code changed.
 *   23/11/95   colinmc Modifications to support aggregatable interfaces
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *   18/12/95   stevela Added GetMatrix, GetState.
 *   15/07/96   andyhird Initialise Render state on devices
 *   13/08/96   andyhird Check surface and device are compatible
 *   18/08/96   colinmc Fixed z-buffer leak
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Create an api for the Direct3DDevice object
 */
extern "C" {
#define this _this
#include "ddrawpr.h"
#undef this
}
#include "commdrv.hpp"
#include "drawprim.hpp"

//#ifdef DEBUG_PIPELINE
#include "testprov.h"
//#endif //DEBUG_PIPELINE

// Remove DDraw's type unsafe definition and replace with our C++ friendly def
#ifdef VALIDEX_CODE_PTR
#undef VALIDEX_CODE_PTR
#endif
#define VALIDEX_CODE_PTR( ptr ) \
(!IsBadCodePtr( (FARPROC) ptr ) )

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice"

extern BOOL isMMXprocessor(void);
extern HRESULT GenGetPickRecords(LPDIRECT3DDEVICEI, D3DI_PICKDATA *);
extern BOOL IsValidD3DDeviceGuid(REFCLSID riid);

BOOL D3DI_isHALValid(LPD3DHAL_CALLBACKS halTable)
{
    if(halTable==NULL) {
        D3D_WARN(0, "HAL callbacks is NULL. HAL will not be enumerated.");
        return FALSE;
    }

    if (halTable->dwSize != D3DHAL_SIZE_V1) {
        D3D_WARN(0, "HAL callbacks invalid - size = %d, wanted %d. HAL will not be enumerated.",
            halTable->dwSize, D3DHAL_SIZE_V1);
        return FALSE;
    }
    if (halTable->dwReserved  ||
        halTable->dwReserved0 ||
        halTable->dwReserved1 ||
        halTable->dwReserved2 ||
        halTable->dwReserved3 ||
        halTable->dwReserved4 ||
        halTable->dwReserved5 ||
        halTable->dwReserved6 ||
        halTable->dwReserved7 ||
        halTable->dwReserved8 ||
        halTable->dwReserved9 ||
        halTable->lpReserved10 ||
        halTable->lpReserved11 ||
        halTable->lpReserved12 ||
        halTable->lpReserved13 ||
        halTable->lpReserved14 ||
        halTable->lpReserved15 ||
        halTable->lpReserved16 ||
        halTable->lpReserved17 ||
        halTable->lpReserved18 ||
        halTable->lpReserved19 ||
        halTable->lpReserved20 ||
        halTable->lpReserved21) {
        D3D_WARN(0, "HAL callbacks invalid - has non-zero reserved fields, HAL will not be enumerated.");
        return FALSE;
    }

    return TRUE;
}

HRESULT DIRECT3DDEVICEI::stateInitialize(BOOL bZEnable)
{
    D3DDEVICEDESC hwDesc, helDesc;
    D3DLINEPATTERN defLPat;
    HRESULT ret;
    float tmpval;
    BOOL ckeyenable = FALSE;

    /* Get the device caps for MONOENABLE */
    memset(&hwDesc, 0, sizeof(D3DDEVICEDESC));
    hwDesc.dwSize = sizeof(D3DDEVICEDESC);
    memset(&helDesc, 0, sizeof(D3DDEVICEDESC));
    helDesc.dwSize = sizeof(D3DDEVICEDESC);

    ret = GetCapsI(&hwDesc, &helDesc);
    if (FAILED(ret)) {
        D3D_ERR("stateInitialise: GetCaps failed");
        return(ret);
    }

    /* If we run on (HAL OR RefRast) AND this is a DX3 app
       then we need to initialize colorkey to TRUE so that the old HW driver (except s3 virge) behavior
       is exhibited. */
    if ( (this->dwVersion < 2) &&
         ( (IS_HW_DEVICE(this)) || (IsEqualIID(this->guid, IID_IDirect3DRefDevice)) ) )
    {
        ckeyenable = TRUE;
    }

    // Obviate SetRenderState filtering 'redundant' render state settings
    // since this is the init step.
    memset( this->rstates, 0xff, sizeof(DWORD)*D3DHAL_MAX_RSTATES );
    this->rstates[D3DRENDERSTATE_PLANEMASK] = 0;
    this->rstates[D3DRENDERSTATE_STENCILMASK] = 0;
    this->rstates[D3DRENDERSTATE_STENCILWRITEMASK] = 0;
    this->rstates[D3DRENDERSTATE_PLANEMASK] = 0;

    SetRenderState( D3DRENDERSTATE_TEXTUREHANDLE, (DWORD)NULL);
    SetRenderState( D3DRENDERSTATE_ANTIALIAS, FALSE);
    SetRenderState( D3DRENDERSTATE_TEXTUREADDRESS, D3DTADDRESS_WRAP);
    if (this->dwVersion <= 2)
    {
        SetRenderState( D3DRENDERSTATE_TEXTUREPERSPECTIVE, FALSE);
        SetRenderState( D3DRENDERSTATE_SPECULARENABLE, TRUE);
    }
    else
    {
        // perspective enabled by default for Device3 and later
        SetRenderState( D3DRENDERSTATE_TEXTUREPERSPECTIVE, TRUE);
        // specular disabled by default for Device3 and later
        SetRenderState( D3DRENDERSTATE_SPECULARENABLE, FALSE);
    }
    SetRenderState( D3DRENDERSTATE_WRAPU, FALSE);
    SetRenderState( D3DRENDERSTATE_WRAPV, FALSE);
    SetRenderState( D3DRENDERSTATE_ZENABLE, bZEnable);
    SetRenderState( D3DRENDERSTATE_FILLMODE, D3DFILL_SOLID);
    SetRenderState( D3DRENDERSTATE_SHADEMODE, D3DSHADE_GOURAUD);

    defLPat.wRepeatFactor = 0;
    defLPat.wLinePattern = 0;

    SetRenderState( D3DRENDERSTATE_LINEPATTERN, *((LPDWORD)&defLPat)); /* 10 */
    /*
      ((LPD3DSTATE)lpPointer)->drstRenderStateType =
      (D3DRENDERSTATETYPE)D3DRENDERSTATE_LINEPATTERN;
      memcpy(&(((LPD3DSTATE)lpPointer)->dwArg[0]), &defLPat, sizeof(DWORD));
      lpPointer = (void *)(((LPD3DSTATE)lpPointer) + 1);*/

    SetRenderState( D3DRENDERSTATE_ROP2, R2_COPYPEN);
    SetRenderState( D3DRENDERSTATE_PLANEMASK, (DWORD)~0);
    SetRenderState( D3DRENDERSTATE_ZWRITEENABLE, TRUE);
    SetRenderState( D3DRENDERSTATE_ALPHATESTENABLE, FALSE);
    SetRenderState( D3DRENDERSTATE_LASTPIXEL, TRUE);
    SetRenderState( D3DRENDERSTATE_SRCBLEND, D3DBLEND_ONE);
    SetRenderState( D3DRENDERSTATE_DESTBLEND, D3DBLEND_ZERO);
    SetRenderState( D3DRENDERSTATE_CULLMODE, D3DCULL_CCW); /* 21 */
    SetRenderState( D3DRENDERSTATE_ZFUNC, D3DCMP_LESSEQUAL);
    SetRenderState( D3DRENDERSTATE_ALPHAREF, 0);
    SetRenderState( D3DRENDERSTATE_ALPHAFUNC, D3DCMP_ALWAYS);
    SetRenderState( D3DRENDERSTATE_DITHERENABLE, FALSE);
    SetRenderState( D3DRENDERSTATE_BLENDENABLE, FALSE);
    SetRenderState( D3DRENDERSTATE_FOGENABLE, FALSE);
    SetRenderState( D3DRENDERSTATE_ZVISIBLE, FALSE);
    SetRenderState( D3DRENDERSTATE_SUBPIXEL, FALSE); /* 30 */
    SetRenderState( D3DRENDERSTATE_SUBPIXELX, FALSE);
    SetRenderState( D3DRENDERSTATE_STIPPLEDALPHA, FALSE);
    SetRenderState( D3DRENDERSTATE_FOGCOLOR, 0);
    SetRenderState( D3DRENDERSTATE_FOGTABLEMODE, D3DFOG_NONE);

    /* Initialise these - although they may not need doing */
    tmpval = 0.0f;
    SetRenderState( D3DRENDERSTATE_FOGTABLESTART, *((DWORD *)&tmpval));
    tmpval = 1.0f;
    SetRenderState( D3DRENDERSTATE_FOGTABLEEND, *((DWORD *)&tmpval));
    tmpval = 1.0f;
    SetRenderState( D3DRENDERSTATE_FOGTABLEDENSITY, *((DWORD *)&tmpval));
    SetRenderState( D3DRENDERSTATE_STIPPLEENABLE, FALSE);
    SetRenderState( D3DRENDERSTATE_EDGEANTIALIAS, FALSE);
    SetRenderState( D3DRENDERSTATE_COLORKEYENABLE, ckeyenable);
    SetRenderState( D3DRENDERSTATE_ALPHABLENDENABLE, FALSE);
    SetRenderState( D3DRENDERSTATE_BORDERCOLOR, 0);
    SetRenderState( D3DRENDERSTATE_TEXTUREADDRESSU, D3DTADDRESS_WRAP);
    SetRenderState( D3DRENDERSTATE_TEXTUREADDRESSV, D3DTADDRESS_WRAP);
    SetRenderState( D3DRENDERSTATE_MIPMAPLODBIAS, 0);
    SetRenderState( D3DRENDERSTATE_ZBIAS, 0);
    SetRenderState( D3DRENDERSTATE_RANGEFOGENABLE, FALSE);
    SetRenderState( D3DRENDERSTATE_ANISOTROPY, 1);

    /* Again - all these probably don't need doing */
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN00, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN01, 0); /* 40 */
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN02, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN03, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN04, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN05, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN06, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN07, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN08, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN09, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN10, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN11, 0); /* 50 */
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN12, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN13, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN14, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN15, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN16, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN17, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN18, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN19, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN20, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN21, 0); /* 60 */
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN22, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN23, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN24, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN25, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN26, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN27, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN28, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN29, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN30, 0);
    SetRenderState( D3DRENDERSTATE_STIPPLEPATTERN31, 0); /* 70 */

     // init stencil states to something reasonable
     // stencil enable is OFF by default since stenciling rasterizers will be
     // faster with it disabled, even if stencil states are benign
    SetRenderState( D3DRENDERSTATE_STENCILENABLE,   FALSE);
    SetRenderState( D3DRENDERSTATE_STENCILFAIL,     D3DSTENCILOP_KEEP);
    SetRenderState( D3DRENDERSTATE_STENCILZFAIL,    D3DSTENCILOP_KEEP);
    SetRenderState( D3DRENDERSTATE_STENCILPASS,     D3DSTENCILOP_KEEP);
    SetRenderState( D3DRENDERSTATE_STENCILFUNC,     D3DCMP_ALWAYS);
    SetRenderState( D3DRENDERSTATE_STENCILREF,      0);
    SetRenderState( D3DRENDERSTATE_STENCILMASK,     0xFFFFFFFF);
    SetRenderState( D3DRENDERSTATE_STENCILWRITEMASK,0xFFFFFFFF);

    // don't forget about texturefactor (like we did in DX6.0...)
    SetRenderState( D3DRENDERSTATE_TEXTUREFACTOR,   0xFFFFFFFF);

    /* Check to see if the driver can do RGB - if not set MONOENABLE to
       true otherwise false (ie. RGB) by default */
    if (hwDesc.dwFlags & D3DDD_COLORMODEL) {
        if ((hwDesc.dcmColorModel & D3DCOLOR_RGB)) {
            D3D_INFO(3, "hw and RGB. MONOENABLE = FALSE");
            SetRenderState( D3DRENDERSTATE_MONOENABLE, FALSE);
        } else {
            D3D_INFO(3, "hw and !RGB. MONOENABLE = TRUE");
            SetRenderState( D3DRENDERSTATE_MONOENABLE, TRUE);
        }
    } else if (helDesc.dwFlags & D3DDD_COLORMODEL) {
        if ((helDesc.dcmColorModel & D3DCOLOR_RGB)) {
            D3D_INFO(3, "hel and RGB. MONOENABLE = FALSE");
            SetRenderState( D3DRENDERSTATE_MONOENABLE, FALSE);
        } else {
            D3D_INFO(3, "hel and !RGB. MONOENABLE = TRUE");
            SetRenderState( D3DRENDERSTATE_MONOENABLE, TRUE);
        }
    } else {
        /* Hmm, something bad has happened if we get here! */
        D3D_ERR("stateInitialise: neither hw or hel caps set");
        return(DDERR_GENERIC);
    }

    for (unsigned i = 0; i < 8; i++)
    {
        SetRenderState( (D3DRENDERSTATETYPE)
                        (D3DRENDERSTATE_WRAPBIAS + i), FALSE );
    }
    for (i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        lpD3DMappedTexI[i] = NULL;
        lpD3DMappedBlock[i] = NULL;
    }
    SetLightState( D3DLIGHTSTATE_COLORVERTEX, TRUE);

    // Obviate SetTextureStageState/Settexture filtering 'redundant' render state
    // settings since this is the init step.
    memset( this->tsstates, 0xff, sizeof(DWORD)*D3DHAL_TSS_MAXSTAGES*D3DHAL_TSS_STATESPERSTAGE );
    for (i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        SetTexture(i, NULL);
        if(i == 0)
            SetTextureStageState(i, D3DTSS_COLOROP, D3DTOP_MODULATE);
        else
            SetTextureStageState(i, D3DTSS_COLOROP, D3DTOP_DISABLE);
        SetTextureStageState(i, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        SetTextureStageState(i, D3DTSS_COLORARG2, D3DTA_CURRENT);
        if(i == 0)
            SetTextureStageState(i, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
        else
            SetTextureStageState(i, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
        SetTextureStageState(i, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        SetTextureStageState(i, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT00, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT01, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT10, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT11, 0);
        SetTextureStageState(i, D3DTSS_TEXCOORDINDEX, 0);
        SetTextureStageState(i, D3DTSS_ADDRESS, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_BORDERCOLOR, 0x00000000);
        SetTextureStageState(i, D3DTSS_MAGFILTER, D3DTFG_POINT);
        SetTextureStageState(i, D3DTSS_MINFILTER, D3DTFN_POINT);
        SetTextureStageState(i, D3DTSS_MIPFILTER, D3DTFP_NONE);
        SetTextureStageState(i, D3DTSS_MIPMAPLODBIAS, 0);
        SetTextureStageState(i, D3DTSS_MAXMIPLEVEL, 0);
        SetTextureStageState(i, D3DTSS_MAXANISOTROPY, 1);
        SetTextureStageState(i, D3DTSS_BUMPENVLSCALE, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVLOFFSET, 0);
    }

    // need to set legacy blend and filtering states after per-stage initialization
    //  to properly set defaults in device
    SetRenderState( D3DRENDERSTATE_TEXTUREMAG, D3DFILTER_NEAREST);
    SetRenderState( D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_NEAREST);
    SetRenderState( D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATE);

    // Reset request bit as legacy renderstates have been already initialized
    // and no mapping is needed
    this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS;

    return(D3D_OK);
}

DWORD BitDepthToDDBD(int bpp)
{
    switch(bpp)
    {
    case 1:
        return DDBD_1;
    case 2:
        return DDBD_2;
    case 4:
        return DDBD_4;
    case 8:
        return DDBD_8;
    case 16:
        return DDBD_16;
    case 24:
        return DDBD_24;
    case 32:
        return DDBD_32;
    default:
        D3D_ERR("Invalid bit depth");
        return 0;
    }
}

HRESULT DIRECT3DDEVICEI::checkDeviceSurface(LPDIRECTDRAWSURFACE lpDDS, LPDIRECTDRAWSURFACE lpZbuffer, LPGUID pGuid)
{
    D3DDEVICEDESC hwDesc, helDesc;
    DDPIXELFORMAT surfPF;
    DDSCAPS surfCaps;
    HRESULT ret;
    DWORD bpp;

    /* Get caps bits - check whether device and surface are:
       - video/system memory and depth compatible */

    if (FAILED(ret = lpDDS->GetCaps(&surfCaps))) {
        D3D_ERR("Failed to get render-target surface caps");
        return(ret);
    }

    memset(&surfPF, 0, sizeof(DDPIXELFORMAT));
    surfPF.dwSize = sizeof(DDPIXELFORMAT);

    if (FAILED(ret = lpDDS->GetPixelFormat(&surfPF))) {
        D3D_ERR("Failed to get render-target surface pixel format");
        return(ret);
    }

    memset(&hwDesc, 0, sizeof(D3DDEVICEDESC));
    hwDesc.dwSize = sizeof(D3DDEVICEDESC);
    memset(&helDesc, 0, sizeof(D3DDEVICEDESC));
    helDesc.dwSize = sizeof(D3DDEVICEDESC);

    // ATTENTION - Why doesn't this just look at the DEVICEI fields?
    ret = GetCapsI(&hwDesc, &helDesc);
    if (FAILED(ret)) {
        D3D_ERR("GetCaps failed");
        return(ret);
    }

    if (hwDesc.dwFlags) {
        /* I'm taking this as evidence that its running on hardware - therefore
           the surface should be in video memory */
        D3D_INFO(3, "Hardware device being used");

        if (!(surfCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
            D3D_ERR("Render-target surface not in video memory for hw device");
            return(D3DERR_SURFACENOTINVIDMEM);
        }
    }

    /* A surface can only have one bit depth - whereas a device can support
       multiple bit depths */
    if (surfPF.dwFlags & DDPF_RGB) {
        D3D_INFO(3, "Render-target surface is RGB");

        bpp = BitDepthToDDBD(surfPF.dwRGBBitCount);
        if (!bpp) {
            D3D_ERR("Bogus render-target surface pixel depth");
            return(DDERR_INVALIDPIXELFORMAT);
       }

       if((surfPF.dwRGBBitCount<16) && (IsEqualIID(*pGuid, IID_IDirect3DRefDevice) || IsEqualIID(*pGuid, IID_IDirect3DNullDevice))) {
           // this is actually subsumed by the following test, but whatever
            D3D_ERR("Reference rasterizer and null device dont support render targets with bitdepth < 16");
            return(DDERR_INVALIDPIXELFORMAT);
       }

        if (!(bpp & helDesc.dwDeviceRenderBitDepth) &&
            !(bpp & hwDesc.dwDeviceRenderBitDepth)) {
            D3D_ERR("Render-target surface bitdepth is not supported by HEL or HW for this device");
            return(DDERR_INVALIDPIXELFORMAT);
        }
    }

    if(lpZbuffer==NULL)
      return D3D_OK;

    memset(&surfPF, 0, sizeof(DDPIXELFORMAT));
    surfPF.dwSize = sizeof(DDPIXELFORMAT);

    if (FAILED(ret = lpZbuffer->GetPixelFormat(&surfPF))) {
        D3D_ERR("Failed to get zbuffer pixel format");
        return(ret);
    }

    if (FAILED(ret = lpZbuffer->GetCaps(&surfCaps))) {
        D3D_ERR("Failed to get Zbuffer caps");
        return(ret);
    }

    if (hwDesc.dwFlags) {
        if (!(surfCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
            D3D_ERR("Zbuffer not in video memory for hw device");
            return(D3DERR_ZBUFF_NEEDS_VIDEOMEMORY);
        }
        D3D_INFO(3, "Hw device, zbuffer in video memory");
    } else if (helDesc.dwFlags) {
        if (!(surfCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)) {
            D3D_ERR("Zbuffer not in system memory for HEL device");
            return(D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY);
        }
        D3D_INFO(3, "Hel device, zbuffer in system memory");

         // have to hack in a check to make sure ramp isn't used with stencil zbuffer
         // cant do this validation until device creation time (instead of at zbuffer creation in
         // ddhel.c) because rgb vs. ramp isn't known until now
         if(IsEqualIID(*pGuid, IID_IDirect3DRampDevice)) {
            if(surfPF.dwFlags & DDPF_STENCILBUFFER) {
                D3D_ERR("Z-Buffer with stencil is invalid with RAMP software rasterizer");
                return DDERR_INVALIDPARAMS;
            }
         }
    }

    if (surfPF.dwFlags & DDPF_ZBUFFER) {
        bpp = BitDepthToDDBD(surfPF.dwZBufferBitDepth);
        if (!bpp) {
            D3D_ERR("Bogus Zbuffer surface pixel depth");
            return(DDERR_INVALIDPIXELFORMAT);
        }
    }

    return(D3D_OK);
}


/*
 * Initialisation - class part and device part
 */

/*
 * Generic class part initialisation
 */
HRESULT InitDeviceI(LPDIRECT3DDEVICEI lpDevI, LPDIRECT3DI lpD3DI)
{
    LPDDRAWI_DIRECTDRAW_GBL lpDDI;
    HRESULT error;

    lpDDI = ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl;

    //
    // Retrieve HAL information from provider.
    //

    error = lpDevI->pHalProv->GetCaps(lpDDI,
                                      &lpDevI->d3dHWDevDesc,
                                      &lpDevI->d3dHELDevDesc,
                                      lpDevI->dwVersion);
    if (error != S_OK)
    {
        return (error);
    }
    D3DHALPROVIDER_INTERFACEDATA HalProviderIData;
    memset(&HalProviderIData,0,sizeof(HalProviderIData));
    HalProviderIData.dwSize = sizeof(HalProviderIData);
    if ((error = lpDevI->pHalProv->GetInterface(lpDDI,
                                                &HalProviderIData,
                                                lpDevI->dwVersion)) != S_OK)
    {
        return error;
    }
    //  interface data for <=DX5 HAL
    lpDevI->lpD3DHALGlobalDriverData = HalProviderIData.pGlobalData;
    lpDevI->lpD3DExtendedCaps        = HalProviderIData.pExtCaps;
    lpDevI->lpD3DHALCallbacks        = HalProviderIData.pCallbacks;
    lpDevI->lpD3DHALCallbacks2       = HalProviderIData.pCallbacks2;
    //  interface data for DX6 HAL
    lpDevI->lpD3DHALCallbacks3       = HalProviderIData.pCallbacks3;

    lpDevI->pfnRampService = HalProviderIData.pfnRampService;
    lpDevI->pfnRastService = HalProviderIData.pfnRastService;
    lpDevI->dwHintFlags = 0;

    // Zero out 8 bpp render target caps for real hardware.
    if (lpDevI->d3dHWDevDesc.dwFlags != 0)
    {
        lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwDeviceRenderBitDepth &=
            (~DDBD_8);
    }

    if (!D3DI_isHALValid(lpDevI->lpD3DHALCallbacks))
    {
        return D3DERR_INITFAILED;
    }

    if (lpDevI->lpD3DExtendedCaps && lpDevI->lpD3DExtendedCaps->dwFVFCaps)
    {
        lpDevI->dwMaxTextureIndices =
            lpDevI->lpD3DExtendedCaps->dwFVFCaps & D3DFVFCAPS_TEXCOORDCOUNTMASK;
        lpDevI->dwMaxTextureBlendStages =
            lpDevI->lpD3DExtendedCaps->wMaxTextureBlendStages;
        lpDevI->dwDeviceFlags |= D3DDEV_FVF;
        if (lpDevI->lpD3DExtendedCaps->dwFVFCaps & D3DFVFCAPS_DONOTSTRIPELEMENTS)
            lpDevI->dwDeviceFlags |= D3DDEV_DONOTSTRIPELEMENTS;

        DWORD value;
        if ((lpDevI->dwDebugFlags & D3DDEBUG_DISABLEDP ||
            lpDevI->dwDebugFlags & D3DDEBUG_DISABLEDP2 ||
            (GetD3DRegValue(REG_DWORD, "DisableFVF", &value, 4) &&
            value != 0)) &&
            FVF_DRIVERSUPPORTED(lpDevI))
        {
            lpDevI->dwMaxTextureIndices = 1;
            lpDevI->dwMaxTextureBlendStages = 1;
            lpDevI->dwDeviceFlags &= ~D3DDEV_FVF;
            lpDevI->dwDebugFlags |= D3DDEBUG_DISABLEFVF;
        }
        if ((GetD3DRegValue(REG_DWORD, "DisableStripFVF", &value, 4) &&
            value != 0))
        {
            lpDevI->dwDeviceFlags |= D3DDEV_DONOTSTRIPELEMENTS;
        }
    }
    else
    {
        lpDevI->dwMaxTextureIndices = 1;
        lpDevI->dwMaxTextureBlendStages = 1;
    }

    lpDevI->pfnDrawPrim = &DIRECT3DDEVICEI::DrawPrim;
    lpDevI->pfnDrawIndexedPrim = &DIRECT3DDEVICEI::DrawIndexPrim;
#if DBG
    lpDevI->dwCaller=0;
    memset(lpDevI->dwPrimitiveType,0,sizeof(lpDevI->dwPrimitiveType));
    memset(lpDevI->dwVertexType1,0,sizeof(lpDevI->dwVertexType1));
    memset(lpDevI->dwVertexType2,0,sizeof(lpDevI->dwVertexType2));
#endif
    return D3D_OK;
}

HRESULT D3DMallocBucket(LPDIRECT3DI lpD3DI, LPD3DBUCKET *lplpBucket)
{
    if (lpD3DI->lpFreeList == NULL ){
      lpD3DI->lpTextureManager->cleanup();  //free unused nodes it may have
      if (lpD3DI->lpFreeList == NULL )
      {
        LPD3DBUCKET   lpBufferList;
        LPVOID  lpBuffer;
        int i;
        *lplpBucket=NULL;
        if (D3DMalloc(&lpBuffer, D3DBUCKETBUFFERSIZE*sizeof(D3DBUCKET)) != D3D_OK)
            return  DDERR_OUTOFMEMORY;
        D3D_INFO(9, "D3DMallocBucket %d Bytes allocated for %d free Buckets",
            D3DBUCKETBUFFERSIZE*sizeof(D3DBUCKET),D3DBUCKETBUFFERSIZE-1);
        lpBufferList=(LPD3DBUCKET)lpBuffer;
        for (i=0;i<D3DBUCKETBUFFERSIZE-2;i++)
            lpBufferList[i].next=&lpBufferList[i+1];
        lpBufferList[D3DBUCKETBUFFERSIZE-2].next=NULL;
        lpD3DI->lpFreeList=(LPD3DBUCKET)lpBuffer; //new free list
        lpBufferList[D3DBUCKETBUFFERSIZE-1].next=lpD3DI->lpBufferList;//add to lpBufferList
        lpBufferList[D3DBUCKETBUFFERSIZE-1].lpBuffer=lpBuffer;
        lpD3DI->lpBufferList=&lpBufferList[D3DBUCKETBUFFERSIZE-1];
      }
    }
    *lplpBucket=lpD3DI->lpFreeList;
    lpD3DI->lpFreeList=lpD3DI->lpFreeList->next;
    return  D3D_OK;
}

void    D3DFreeBucket(LPDIRECT3DI lpD3DI, LPD3DBUCKET lpBucket)
{
    lpBucket->next=lpD3DI->lpFreeList;
    lpD3DI->lpFreeList=lpBucket;
}

/*
 * Generic device part destroy
 */
void DIRECT3DDEVICEI::DestroyDevice()
{
    LPDIRECT3DVIEWPORTI lpViewI;
    LPDIRECTDRAWSURFACE lpDDS=NULL, lpDDSZ=NULL;
    LPDIRECTDRAWSURFACE4 lpDDS_DDS4=NULL;
    LPDIRECTDRAWPALETTE lpDDPal=NULL;
    BOOL bIsDX3Device;

    /* Clear flags that could prohibit cleanup */
    this->dwHintFlags &=  ~(D3DDEVBOOL_HINTFLAGS_INBEGIN_ALL | D3DDEVBOOL_HINTFLAGS_INSCENE);

    /*
     * Remove all viewports attached to this device.
     */
    while ((lpViewI = CIRCLE_QUEUE_FIRST(&this->viewports)) &&
           (lpViewI != (LPDIRECT3DVIEWPORTI)&this->viewports)) {
        DeleteViewport((LPDIRECT3DVIEWPORT3)lpViewI);
    }

    /*
     * free up all textures created by this object - this also frees up Textures
     * We need to do this backwards because we cannot have a texture bound to
     * stage i + 1 when there is a texture bound to stage i.
     */
    for (int i = D3DHAL_TSS_MAXSTAGES - 1; i >= 0; --i)
    {
        if (lpD3DMappedTexI[i])
        {
            lpD3DMappedTexI[i]->Release();
            lpD3DMappedTexI[i] = NULL;
            lpD3DMappedBlock[i] = NULL;
        }
    }
    // The following code can result in D3DHAL_TextureDestroy() being called.
    // This BATCHES NEW INSTRUCTIONS in the instruction stream. So we must
    // make sure that at this point, the device is still able to accept
    // instructions.
    while (LIST_FIRST(&this->texBlocks)) {
        LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&this->texBlocks);
        D3DI_RemoveTextureHandle(tBlock);
        // Remove from device
        LIST_DELETE(tBlock, devList);
        // Remove from texture
        LIST_DELETE(tBlock, list);
        D3DFree(tBlock);
    }

    /*
     * free up all execute buffers created by this object
     */
    while (LIST_FIRST(&this->buffers)) {
        LPDIRECT3DEXECUTEBUFFERI lpBufI =
            LIST_FIRST(&this->buffers);
        lpBufI->Release();
    }

    /*
     * All materials associated with this device must be disassocited
     */
    while (LIST_FIRST(&this->matBlocks)) {
        LPD3DI_MATERIALBLOCK mBlock =
            LIST_FIRST(&this->matBlocks);
        D3DI_RemoveMaterialBlock(mBlock);
    }

    // In DX3, d3d device is aggregated and doesnt keep references to
    // rendertarget surfaces, so they shouldnt be "released"

    bIsDX3Device=(this->lpDDSTarget == (LPDIRECTDRAWSURFACE)(this->lpOwningIUnknown));

    if(!bIsDX3Device)
    {
        // Hold pointers into ddraw object for release after driver is destroyed
        lpDDSZ = this->lpDDSZBuffer;
        lpDDPal = this->lpDDPalTarget;
        if (this->dwVersion == 2)
            lpDDS = this->lpDDSTarget;
        else
            lpDDS_DDS4 = this->lpDDSTarget_DDS4;
    }

    //Unhook so that DDRAW surfaces won't try to flush the dead device
    if (this->lpDDSTarget)
        UnHookD3DDeviceFromSurface(this,((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl);
    if (this->lpDDSZBuffer)
        UnHookD3DDeviceFromSurface(this,((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl);

    if (pGeometryFuncs != &GeometryFuncsGuaranteed)
        delete pGeometryFuncs;

    D3DFE_Destroy(this);

    if (this->lpDirect3DI)
        unhookDeviceFromD3D();

    if (this->wTriIndex)
        D3DFree(this->wTriIndex);

    // Free the rstates that was allocated
    if(!(IS_HW_DEVICE(this) && IS_DP2HAL_DEVICE(this)))
    {
        delete rstates;
    }

    if (this->lpwDPBufferAlloced)
        D3DFree(this->lpwDPBufferAlloced);
    if (this->lpvVertexBatch)
        D3DFree(this->lpvVertexBatch);
    if (this->lpIndexBatch)
        D3DFree(this->lpIndexBatch);
    if (this->lpHWCounts)
        D3DFree(this->lpHWCounts);
    if (this->lpHWTris)
        D3DFree(this->lpHWTris);
    DeleteCriticalSection(&this->BeginEndCSect);

    if (this->pHalProv != NULL)
    {
        this->pHalProv->Release();
    }
    if (this->hDllProv != NULL)
    {
        FreeLibrary(this->hDllProv);
    }

    /* Now that the class has been destroyed, we should be able to release
       any DDraw object that might need to be released */

    if(!bIsDX3Device) {
        if (lpDDS)
            lpDDS->Release();
        if (lpDDSZ)
            lpDDSZ->Release();
        if (lpDDPal)
            lpDDPal->Release();
        if (lpDDS_DDS4)
            lpDDS_DDS4->Release();
    }
}

HRESULT DIRECT3DDEVICEI::hookDeviceToD3D(LPDIRECT3DI lpD3DI)
{

    LIST_INSERT_ROOT(&lpD3DI->devices, this, list);
    this->lpDirect3DI = lpD3DI;

    lpD3DI->numDevs++;

    return (D3D_OK);
}

HRESULT DIRECT3DDEVICEI::unhookDeviceFromD3D()
{
    LIST_DELETE(this, list);
    this->lpDirect3DI->numDevs--;
    this->lpDirect3DI = NULL;

    return (D3D_OK);
}

HRESULT D3DAPI DIRECT3DDEVICEI::Initialize(LPDIRECT3D lpD3D, LPGUID lpGuid, LPD3DDEVICEDESC lpD3Ddd)
{
    return DDERR_ALREADYINITIALIZED;
}


HRESULT HookD3DDeviceToSurface( LPDIRECT3DDEVICEI pd3ddev,
                                LPDDRAWI_DDRAWSURFACE_LCL lpLcl)
{
    LPD3DBUCKET lpD3DDevIList;
    LPDDRAWI_DDRAWSURFACE_MORE  this_more;
    // we only batch with DRAWPRIMITIVE aware HAL, so don't bother otherwise
    if (!lpLcl)     return  DDERR_ALREADYINITIALIZED;
    this_more = lpLcl->lpSurfMore;
    for(lpD3DDevIList=(LPD3DBUCKET)this_more->lpD3DDevIList;
        lpD3DDevIList;lpD3DDevIList=lpD3DDevIList->next) {
        if ((LPDIRECT3DDEVICEI)lpD3DDevIList->lpD3DDevI==pd3ddev)
            return DDERR_ALREADYINITIALIZED;  // this device is already hooked to the surface
    }
    if (D3DMallocBucket(pd3ddev->lpDirect3DI,&lpD3DDevIList) != D3D_OK) {
        D3D_ERR("HookD3DDeviceToSurface: Out of memory");
        return DDERR_OUTOFMEMORY;
    }
    D3D_INFO(8,"adding lpd3ddev=%08lx to surface %08lx",pd3ddev,lpLcl);
    //Link a node to the DDRAW surface
    lpD3DDevIList->lpD3DDevI=(LPVOID)pd3ddev;
    lpD3DDevIList->next=(LPD3DBUCKET)this_more->lpD3DDevIList;
    this_more->lpD3DDevIList=lpD3DDevIList;
    if (DDSCAPS_ZBUFFER & lpLcl->ddsCaps.dwCaps)
    {
        if (pd3ddev->dwVersion==1)
        {
            lpD3DDevIList->lplpDDSZBuffer=(LPDIRECTDRAWSURFACE*)&pd3ddev->lpDDSZBuffer_DDS4;
        }
        else
        {
            lpD3DDevIList->lplpDDSZBuffer=NULL;
        }
    }
    return D3D_OK;
}

void UnHookD3DDeviceFromSurface( LPDIRECT3DDEVICEI pd3ddev,
                                    LPDDRAWI_DDRAWSURFACE_LCL lpLcl)
{
    LPD3DBUCKET last,current,temp;
    LPDDRAWI_DDRAWSURFACE_MORE  this_more;
    // we only batch with DRAWPRIMITIVE aware HAL, so don't bother otherwise
    if (!lpLcl) return;
    this_more = lpLcl->lpSurfMore;

    last=NULL;
    current=(LPD3DBUCKET)this_more->lpD3DDevIList;
    while(current){
        if ((LPDIRECT3DDEVICEI)current->lpD3DDevI==pd3ddev){
            temp=current;
            current=current->next;
            if (last)
                last->next=current;
            else
                this_more->lpD3DDevIList=current;
            D3DFreeBucket(pd3ddev->lpDirect3DI,temp);
            D3D_INFO(8,"removed lpd3ddev=%08lx from surface %08lx",pd3ddev,lpLcl);
            return; // end of search as this is only one pd3ddev in the list
        }
        else{
            last=current;
            current=current->next;
        }
    }
    return;
}

HRESULT D3DFlushStates(LPDIRECT3DDEVICEI lpDevI)
{
    return lpDevI->FlushStates();
}

/*
 * Create a device.
 *
 * NOTE: Radical modifications to support the aggregatable device
 * interface (so devices can be queried off DirectDraw surfaces):
 *
 * 1) This call is no longer a member of the Direct3D device interface.
 *    It is now an API function exported from the Direct3D DLL. Its
 *    a hidden API function - only DirectDraw will ever invoke it.
 *
 * 2) This call is, in effect, the class factory for Direct3DDevice
 *    objects. This function will be invoked to create the aggregated
 *    device object hanging off the DirectDraw surface.
 *
 * NOTE: So the Direct3DDevice knows which DirectDraw surface is
 * its rendering target this function is passed an interface pointer
 * for that DirectDraw surface. I suspect this blows a nice big
 * hole in the COM model as the DirectDraw surface is also the
 * owning interface of the device and I don't think aggregated
 * objects should know about thier owning interfaces. However, to
 * make this thing work this is what we have to do.
 *
 * EXTRA BIG NOTE: Because of the above don't take a reference to
 * the DirectDraw surface passed in. If you do you will get a circular
 * reference and the bloody thing will never die. When aggregated
 * the device interface's lifetime is entirely defined by the
 * lifetime of its owning interface (the DirectDraw surface) so the
 * DirectDraw surface can never go away before the texture.
 *
 * EXTRA EXTRA BIG NOTE: No device description is passed in any more.
 * The only things that can get passed in are things that DirectDraw
 * knows about (which does not include stuff like dither and color
 * model). Therefore, any input parameters must come in via a
 * different IID for the device. The data returned by the device
 * description must now be retrieved by another call.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DCreateDevice"

HRESULT WINAPI Direct3DCreateDevice(REFCLSID            riid,
                                    LPUNKNOWN           lpDirect3D,
                                    LPDIRECTDRAWSURFACE lpDDSTarget,
                                    LPUNKNOWN*          lplpD3DDevice,
                                    IUnknown*           pUnkOuter,
                                    DWORD               dwVersion)
{
    LPDIRECT3DI       lpD3DI;
    LPDIRECT3DDEVICEI     pd3ddev;
    D3DCOLORMODEL     cm = D3DCOLOR_MONO;
    HRESULT ret = D3D_OK;
    HKEY                  hKey = (HKEY) NULL;
    bool                  bDisableDP = false;
    bool                  bDisableST = false;
    bool                  bDisableDP2 = false;
#if _D3D_FORCEDOUBLE
    bool    bForceDouble = true;
#endif  //_D3D_FORCEDOUBLE
    /* No need to validate params as they are passed to us by DirectDraw */

    /* CreateDevice member of IDirect3D2 will cause this function to be called
     * from within Direct3D. The parameters from the application level must be
     * validated. Need a way to validate the surface pointer from outside DDraw.
     */

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    TRY
    {
        if( ! VALID_PTR_PTR( lplpD3DDevice) )
        {
            D3D_ERR( "Invalid ptr to device pointer in Direct3DCreateDevice" );
            return DDERR_INVALIDPARAMS;
        }

        if(!IsValidD3DDeviceGuid(riid)) {
            D3D_ERR( "Unrecognized Device GUID!");
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in Direct3DCreateDevice" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpD3DDevice = NULL;

    // Might be safer to use dynamic_cast<> if RTTI is enabled
    lpD3DI = reinterpret_cast<CDirect3DUnk*>(lpDirect3D)->pD3DI;

#ifndef _X86_
    if(IsEqualIID(riid, IID_IDirect3DRampDevice)) {
         // quietly fail if trying to create a RampDevice on a non-x86 platform
         return DDERR_INVALIDPARAMS;
    }
#endif

    if((dwVersion>=3) && IsEqualIID(riid, IID_IDirect3DRampDevice)) {
         // Ramp not available in Device3.  No more old-style texture handles.
         D3D_ERR( "RAMP Device is incompatible with IDirect3DDevice3 and so cannot be created from IDirect3D3");
         return DDERR_INVALIDPARAMS;
    }

    if (IsEqualIID(riid, IID_IDirect3DMMXDevice) && !isMMXprocessor()) {
      D3D_ERR("Can't create MMX Device on non-MMX machine");
      return DDERR_INVALIDPARAMS;
    }

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey) )
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;
#ifdef WIN95
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "DisableDP", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            bDisableDP = true;
            bDisableDP2 = true;
        }
#endif //WIN95
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "DisableST", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            bDisableST = true;
        }
#ifdef WIN95
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "DisableDP2", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            bDisableDP2 = true;
        }
#endif //WIN95

        D3D_INFO(2,"EnableDP2: %d",!bDisableDP2);
#if _D3D_FORCEDOUBLE
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "ForceDouble", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD &&
             dwValue == 0)
        {
            bForceDouble = false;
        }
        D3D_INFO(2,"ForceDouble: %d",bForceDouble);
#endif  //_D3D_FORCEDOUBLE
        RegCloseKey( hKey );
    }
    LPD3DHAL_GLOBALDRIVERDATA lpD3DHALGlobalDriverData=((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl->lpD3DGlobalDriverData;
#ifdef WIN95
    /* Test for presence of CB HAL */
    if (IsEqualIID(riid, IID_IDirect3DHALDevice) )
    {
        /* Test for presence of DP2 DDI */
        if ((lpD3DHALGlobalDriverData)
            && (lpD3DHALGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_DRAWPRIMITIVES2EX)
           )
        {
            pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP2());
            if (pd3ddev) pd3ddev->deviceType = D3DDEVTYPE_DX7HAL;
        }
        else if ((!bDisableDP2) &&
            ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl->lpD3DHALCallbacks3 &&
            ((LPD3DHAL_CALLBACKS3)((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl->lpD3DHALCallbacks3)->DrawPrimitives2)
        {
            pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP2());
        }
        /* Test for presence DP HAL */
        else if ((!bDisableDP) &&
                ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl->lpD3DHALCallbacks2 &&
                ((LPD3DHAL_CALLBACKS2)((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl->lpD3DHALCallbacks2)->DrawOnePrimitive)
        {
            pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP());
        }
        else
        {
            pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIHW());
        }
    }
    else // all software rasterizers are DP-enabled
#endif // WIN95
    if (!bDisableDP2)
    {
        if ((lpD3DHALGlobalDriverData)
            && (IsEqualIID(riid, IID_IDirect3DHALDevice) )
            && (lpD3DHALGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_DRAWPRIMITIVES2EX)
           )
        {
            pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP2());
            if (pd3ddev) pd3ddev->deviceType = D3DDEVTYPE_DX7HAL;
        }
        else
        {
            pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP2());
        }
    }
    else if (!bDisableDP)
        pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP());
    else
        pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIHW());

    if (!pd3ddev) {
        D3D_ERR("Failed to allocate space for D3DDevice. Quitting.");
        return (DDERR_OUTOFMEMORY);
    }

    // If we have lost managed textures, we need to cleanup
    // since CheckSurfaces() would fail which would cause
    // FlushStates() to fail, which would result in the
    // current batch being abandoned (along with any device initialization)
    if(lpD3DI->lpTextureManager->CheckIfLost())
    {
        D3D_INFO(2, "Found lost managed textures. Evicting...");
        lpD3DI->lpTextureManager->EvictTextures();
    }

    if (bDisableDP)
        pd3ddev->dwDebugFlags |= D3DDEBUG_DISABLEDP;
    if (bDisableDP2)
        pd3ddev->dwDebugFlags |= D3DDEBUG_DISABLEDP2;

    ret = pd3ddev->Init(riid, lpD3DI, lpDDSTarget, pUnkOuter, lplpD3DDevice, dwVersion);
    if (ret!=D3D_OK)
    {
        delete pd3ddev;
        D3D_ERR("Failed to intilialize D3DDevice");
        return ret;
    }

    if (bDisableST)
        pd3ddev->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_MULTITHREADED;

#ifdef _X86_
    if (((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->dwLocalFlags & DDRAWILCL_FPUSETUP &&
        IS_DP2HAL_DEVICE(pd3ddev))
    {
        WORD wSave, wTemp;
        __asm {
            fstcw wSave
            mov ax, wSave
            and ax, not 300h    ;; single mode
            or  ax, 3fh         ;; disable all exceptions
            and ax, not 0C00h   ;; round to nearest mode
            mov wTemp, ax
            fldcw   wTemp
        }
    }
#if _D3D_FORCEDOUBLE
    if (bForceDouble && (pd3ddev->deviceType <= D3DDEVTYPE_DPHAL))
    {
        pd3ddev->dwDebugFlags |= D3DDEBUG_FORCEDOUBLE;
    }
    else
    {
        pd3ddev->dwDebugFlags &= ~D3DDEBUG_FORCEDOUBLE;
    }
#endif  //_D3D_FORCEDOUBLE
#endif

    return (ret);
}

HRESULT DIRECT3DDEVICEI::Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                              IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice, DWORD dwVersion)
{
    DDSCAPS               ddscaps;
    DDSURFACEDESC     ddsd;
    HRESULT       ret, ddrval;
    LPDIRECTDRAWSURFACE lpDDSZ=NULL;
    LPDIRECTDRAWPALETTE lpDDPal=NULL;
    LPGUID              pGuid;
    BOOL          bIsDX3Device;
    DDSCAPS surfCaps;

    this->dwFVFLastIn = this->dwFVFLastOut = 0;
    this->mDevUnk.refCnt             = 1;
    this->dwVersion          = dwVersion;
    this->mDevUnk.pDevI = this;
    pD3DMappedTexI = (LPVOID*)(this->lpD3DMappedTexI);
    pfnFlushStates = D3DFlushStates;
    this->dwFEFlags |= D3DFE_TSSINDEX_DIRTY;

    /* Single threaded or Multi threaded app ? */
    if (((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->dwLocalFlags & DDRAWILCL_MULTITHREADED)
        this->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_MULTITHREADED;

    /*
     * Are we really being aggregated?
     */

    bIsDX3Device=(pUnkOuter!=NULL);

    if (bIsDX3Device)
    {
        /*
         * Yup - we are being aggregated. Store the supplied
         * IUnknown so we can punt to that.
         * NOTE: We explicitly DO NOT AddRef here.
         */
        this->lpOwningIUnknown = pUnkOuter;
        DDASSERT(dwVersion==1);
    }
    else
    {
        /*
         * Nope - but we pretend we are anyway by storing our
         * own IUnknown as the parent IUnknown. This makes the
         * code much neater.
         */
        this->lpOwningIUnknown = (LPUNKNOWN)&this->mDevUnk;
    }

    // create the begin/end critical section
    InitializeCriticalSection(&this->BeginEndCSect);

    /*
     * Initialise textures
     */
    LIST_INITIALIZE(&this->texBlocks);

    /*
     * Initialise buffers
     */
    LIST_INITIALIZE(&this->buffers);

    /*
     * Initialise viewports
     */
    CIRCLE_QUEUE_INITIALIZE(&this->viewports, DIRECT3DVIEWPORTI);

    this->lpCurrentViewport = NULL;
    this->v_id = 0;

    /*
     * Initialise materials
     */
    LIST_INITIALIZE(&this->matBlocks);

    this->lpvVertexBatch = this->lpIndexBatch = NULL;
    this->dwHWNumCounts = 0;
    this->dwHWOffset = 0;
    this->dwHWTriIndex = 0;
    this->lpTextureBatched = NULL;
    this->dwVertexBase = 0;
    pGeometryFuncs = &GeometryFuncsGuaranteed;

    /*-----------------------------------------------------------------------------------------
     * Up till now we have done the easy part of the initialization. This is the stuff that
     * cannot fail. It initializes the object so that the destructor can be safely called if
     * any of the further initialization does not succeed.
     *---------------------------------------------------------------------------------------*/

    /*
     * Ensure the riid is one we understand.
     *
     * Query the registry.
     */
    pGuid = (GUID *)&riid;

#if DBG
    if (IsEqualIID(*pGuid, IID_IDirect3DRampDevice))
    {
        D3D_INFO(1, "======================= Ramp device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DRGBDevice))
    {
        D3D_INFO(1, "======================= RGB device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DMMXDevice))
    {
        D3D_INFO(1, "======================= RGB(MMX) device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DHALDevice))
    {
        D3D_INFO(1, "======================= HAL device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DRefDevice))
    {
        D3D_INFO(1, "======================= Reference Rasterizer device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DNullDevice))
    {
        D3D_INFO(1, "======================= Null device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DNewRGBDevice))
    {
        D3D_INFO(1, "======================= New RGB device selected");
    }
    D3D_INFO(1,"with HAL deviceType=%d",deviceType);
#endif

    // set up flag to use MMX when requested RGB
    BOOL bUseMMXAsRGBDevice = FALSE;
    if (IsEqualIID(*pGuid, IID_IDirect3DRGBDevice) && isMMXprocessor())
    {
        bUseMMXAsRGBDevice = TRUE;
        // read reg key to override use of MMX for RGB
        HKEY    hKey = (HKEY) NULL;
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH, &hKey) )
        {
            DWORD dwType;
            DWORD dwValue;
            DWORD dwSize = 4;

            if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "UseMMXForRGB", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
                 dwType == REG_DWORD &&
                 dwValue == 0)
            {
                bUseMMXAsRGBDevice = FALSE;
            }
            RegCloseKey( hKey );
        }
        if (bUseMMXAsRGBDevice)
        {
            D3D_INFO(1, "  using MMX in RGB device");
        }
    }

    BOOL bIsRamp = FALSE;
    if (IsEqualIID(*pGuid, IID_IDirect3DRampDevice))
    {
        bIsRamp = TRUE;
    }

    if (IsEqualIID(*pGuid, IID_IDirect3DRGBDevice) &&
        isMMXprocessor())
    {
        // Check for whether this app is one of the Intel ones
        // that want the MMX rasterizer
        LPDDRAWI_DIRECTDRAW_LCL lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl;

        // 0x4 corresponds to the "Intel app that wants MMX"
        // flag defined in ddrawpr.h
        if ( lpDDLcl->dwAppHackFlags & 0x4 )
        {
            pGuid = (GUID *)&IID_IDirect3DMMXDevice;
        }
    }

    /*
     * Check if the 3D cap is set on the surface.
     */
    memset(&ddsd, 0, sizeof ddsd);
    ddsd.dwSize = sizeof ddsd;
    ddrval = lpDDS->GetSurfaceDesc(&ddsd);
    if (ddrval != DD_OK) {
        D3D_ERR("Failed to get surface description of device's surface.");
        return (ddrval);
    }

    if (!(ddsd.ddsCaps.dwCaps & DDSCAPS_3DDEVICE)) {
        D3D_ERR("**** The DDSCAPS_3DDEVICE is not set on this surface.");
        D3D_ERR("**** You need to add DDSCAPS_3DDEVICE to ddsCaps.dwCaps");
        D3D_ERR("**** when creating the surface.");
        return (DDERR_INVALIDCAPS);
    }

    if (ddsd.ddsCaps.dwCaps & DDSCAPS_ZBUFFER) {
        D3D_ERR("**** DDSCAPS_ZBUFFER is set on this surface.");
        D3D_ERR("**** Rendering into Z buffer surfaces is not");
        D3D_ERR("**** currently supported by Direct3D.");
        return (DDERR_INVALIDCAPS);
    }

    if (ddsd.dwWidth > 2048 || ddsd.dwHeight > 2048)
    {
        D3D_ERR("**** Surface too large - must be <= 2048 in width & height.");
        return (DDERR_INVALIDOBJECT);
    }

    /* Check for palette... */
    ret = lpDDS->GetPalette(&lpDDPal);
    if ((ret != DD_OK) && (ret != DDERR_NOPALETTEATTACHED))
    {
        /*
         * NOTE: Again, not an error (yet) if there is no palette attached.
         * But if there is palette and we can't get at it for some reason
         * - fail.
         */
        D3D_ERR("Supplied DirectDraw Palette is invalid - can't create device");
        return (DDERR_INVALIDPARAMS);
    }

    /*
     * We're going to check now whether we should have got a palette.
     */
    if (ret == DDERR_NOPALETTEATTACHED) {
        if (ddsd.ddpfPixelFormat.dwRGBBitCount < 16) {
            D3D_ERR("No palette supplied for palettized surface - can't create device");
            return (DDERR_NOPALETTEATTACHED);
        }
    }

    // For DX3, we must not keep references to Palette and ZBuffer to avoid
    // circular references in the aggregation model.  But for DX5+, we want
    // to keep references to both to ensure they dont disappear.

    if(bIsDX3Device && (lpDDPal != NULL))
       lpDDPal->Release();  // release the reference GetPalette created
    this->lpDDPalTarget = lpDDPal;

    // Check for ZBuffer

    memset(&surfCaps, 0, sizeof(DDSCAPS));
    surfCaps.dwCaps = DDSCAPS_ZBUFFER;

    if (FAILED(ret = lpDDS->GetAttachedSurface(&surfCaps, &lpDDSZ))) {
        if (ret != DDERR_NOTFOUND) {
           D3D_ERR("Failed GetAttachedSurface for ZBuffer");
           goto handle_err;
        }
        D3D_INFO(2, "No zbuffer is attached to rendertarget surface (which is OK)");
    }

    if(bIsDX3Device && (lpDDSZ != NULL))
       lpDDSZ->Release();   // release the reference GetAttachedSurface created
    this->lpDDSZBuffer = lpDDSZ;

    this->guid = *pGuid;

    // Try to get a HAL provider for this driver (may need to use MMX guid if
    // using MMX for RGB requested device)
    ret = GetSwHalProvider(
        bUseMMXAsRGBDevice ? IID_IDirect3DMMXAsRGBDevice : riid,
        &this->pHalProv, &this->hDllProv);

    if (ret == S_OK)
    {
        // Got a software provider.
    }
    else if (ret == E_NOINTERFACE &&
             ((ret = GetHwHalProvider(riid, &this->pHalProv,
                                     &this->hDllProv,
                                     ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl)) == S_OK))
    {
        // Got a hardware provider.
    }
    else
    {
        if(IsEqualIID(riid, IID_IDirect3DHALDevice)) {
            D3D_ERR("Requested HAL Device non-existent or invalid");
        } else {
            D3D_ERR("Unable to get D3D Device provider for requested GUID");
        }
        goto handle_err;
    }

    {
        // Initialize test HAL provider to drop HAL calls (sort of a Null device)
        //
        DWORD value = 0;
        if (GetD3DRegValue(REG_DWORD, "DisableRendering", &value, sizeof(DWORD)) &&
            value != 0)
        {
            ret = GetTestHalProvider(
                    riid, ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl,
                    &this->pHalProv, this->pHalProv, 0);
            if (ret != D3D_OK)
            {
                D3D_ERR("Unable to set up 'DisableRendering' mode");
                goto handle_err;
            }
        }
    }

    // Initialise general DEVICEI information.
    if ((ret = InitDeviceI(this, lpD3DI)) != D3D_OK)
    {
        D3D_ERR("Failed to initialise device");
        goto handle_err;
    }

    // Check the surface and device to see if they're compatible
    if (FAILED(ret = checkDeviceSurface(lpDDS,lpDDSZ,pGuid))) {
        D3D_ERR("Device and surface aren't compatible");
        goto handle_err;
    }

    // Create front-end support structures.
    // ATTENTION - We probably want to avoid doing this if the driver
    // does its own front end.  Software fallbacks complicate the issue,
    // though.
    ret = D3DFE_Create(this, lpD3DI->lpDD, lpDDS, lpDDSZ, lpDDPal);
    if (ret != D3D_OK)
    {
        D3D_ERR("Failed to create front-end data-structures.");
        goto handle_err;
    }

    // Figure out place for rstates
    if (IS_HW_DEVICE(this) && IS_DP2HAL_DEVICE(this))
    {
        // In case of HW DP2 HAL we reuse the kernel allocated
        // memory for RStates since we need the driver to update
        // it
        rstates = (LPDWORD)lpwDPBuffer;
    }
    else
    {
        // In all other cases we simply allocate memory for rstates
        rstates = new DWORD[D3DHAL_MAX_RSTATES];
    }
    D3DFE_PROCESSVERTICES::lpdwRStates = this->rstates;

    // Check if we have a processor specific implementation available
    //  only use if DisablePSGP is not in registry or set to zero
    DWORD value;
    if (!GetD3DRegValue(REG_DWORD, "DisablePSGP", &value, sizeof(DWORD)))
    {
        value = 0;
    }

#ifdef _X86_
extern HRESULT D3DAPI pii_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
    if (pfnFEContextCreate == pii_FEContextCreate)
    {
        // here if this is PentiumII PSGP

        // regkey disable for PII PSGP - default is ENABLED
        DWORD dwValue2;  // disable if this is TRUE
        if (!GetD3DRegValue(REG_DWORD, "DisablePIIPSGP", &dwValue2, sizeof(DWORD)))
        {
            dwValue2 = 0;
        }
        else
        {
            D3D_INFO(2, "DisablePIIPSGP %d",dwValue2);
        }

        // do disable
        if ( dwValue2 )
        {
            pfnFEContextCreate = NULL;
        }
    }
#endif

    if (pfnFEContextCreate && ( value == 0) && (!bIsRamp) )
    {
        D3D_INFO(2, "PSGP enabled for device");
        // Ask the PV implementation to create a device specific "context"
        LPD3DFE_PVFUNCS pOptGeoFuncs = pGeometryFuncs;
        ret = pfnFEContextCreate(dwDeviceFlags, &pOptGeoFuncs);
        if ((ret == D3D_OK) && pOptGeoFuncs)
        {
            D3D_INFO(2, "using PSGP");
            pGeometryFuncs = pOptGeoFuncs;
        }
    }

    /*
     * put this device in the list of those owned by the Direct3D object
     */
    ret = hookDeviceToD3D(lpD3DI);
    if (ret != D3D_OK)
    {
        D3D_ERR("Failed to associate device with Direct3D");
        goto handle_err;
    }
    {
        if(lpD3DHALGlobalDriverData->hwCaps.dwMaxVertexCount == 0)
        {
            lpD3DHALGlobalDriverData->hwCaps.dwMaxVertexCount = __INIT_VERTEX_NUMBER;
        }
        if (TLVbuf.Grow(this, (__INIT_VERTEX_NUMBER*2)*sizeof(D3DTLVERTEX)) != DD_OK)
        {
            D3D_ERR( "Out of memory in DeviceCreate (TLVbuf)" );
            ret = DDERR_OUTOFMEMORY;
            goto handle_err;
        }
        if (HVbuf.Grow((__INIT_VERTEX_NUMBER*2)*sizeof(D3DFE_CLIPCODE)) != DD_OK)
        {
            D3D_ERR( "Out of memory in DeviceCreate (HVBuf)" );
            ret = DDERR_OUTOFMEMORY;
            goto handle_err;
        }
        ret = this->ClipperState.clipBuf.Grow
                (this, MAX_CLIP_VERTICES*__MAX_VERTEX_SIZE);
        if (ret != D3D_OK)
        {
            D3D_ERR( "Out of memory in DeviceCreate (ClipBuf)" );
            ret = DDERR_OUTOFMEMORY;
            goto handle_err;
        }
        ret = this->ClipperState.clipBufPrim.Grow
                (this, MAX_CLIP_TRIANGLES*sizeof(D3DTRIANGLE));
        if (ret != D3D_OK)
        {
            D3D_ERR( "Out of memory in DeviceCreate (ClipBufPrim)" );
            ret = DDERR_OUTOFMEMORY;
            goto handle_err;
        }

    }
    /*
     * IDirect3DDevice2 specific initialization
     */
    if (D3DMalloc((void**)&this->wTriIndex, dwD3DTriBatchSize*4*sizeof(WORD)) != DD_OK) {
        D3D_ERR( "Out of memory in DeviceCreate (wTriIndex)" );
        ret = DDERR_OUTOFMEMORY;
        goto handle_err;
    }

    if (D3DMalloc((void**)&this->lpHWCounts, dwHWBufferSize*sizeof(D3DI_HWCOUNTS)/32 ) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate (HWCounts)" );
        ret = DDERR_OUTOFMEMORY;
        goto handle_err;
    }
    memset(this->lpHWCounts, 0, sizeof(D3DI_HWCOUNTS) );
    this->lpHWVertices = (LPD3DTLVERTEX) this->lpwDPBuffer;
    if (D3DMalloc((void**)&this->lpHWTris, dwHWMaxTris*sizeof(D3DTRIANGLE) ) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate (HWVertices)" );
        ret = DDERR_OUTOFMEMORY;
        goto handle_err;
    }

    if (DDERR_OUTOFMEMORY == (ret=HookD3DDeviceToSurface(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl)))
        goto handle_err;
    if (lpDDSZ && (DDERR_OUTOFMEMORY == (ret=HookD3DDeviceToSurface(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpDDSZ)->lpLcl))))
    {
        UnHookD3DDeviceFromSurface(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl);
        goto handle_err;
    }

    /* Set the initial render state of the device */
    if (FAILED(ret = stateInitialize(lpDDSZ!=NULL))) {
        D3D_ERR("Failed to set initial state for device");
        goto handle_err;
    }

    /*
     * NOTE: We don't return the actual device interface. We
     * return the device's special IUnknown interface which
     * will be used in a QueryInterface to get the actual
     * Direct3D device interface.
     */
    *lplpD3DDevice = static_cast<LPUNKNOWN>(&(this->mDevUnk));


    return (D3D_OK);
handle_err:
    // might be able to simplify if this fn and not D3DFE_Create sets this->lpDDSZBuffer/this->lpDDPalette
    if(lpDDSZ!=NULL) {
       if(!bIsDX3Device) {
           lpDDSZ->Release();    // release the reference GetAttachedSurface created
       }
       this->lpDDSZBuffer=NULL;  // make sure the device destructor doesn't try to re-release this
                                 // I'd let device destructor handle this, but errors can occur before D3DFE_Create is called
    }

    if(lpDDPal!=NULL) {
      if(!bIsDX3Device) {
        lpDDPal->Release();      // release the reference GetPalette created
      }
      this->lpDDPalTarget=NULL;  // make sure the device destructor doesn't try to re-release this
    }

    D3D_ERR("Device creation failed!!");
    return(ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetStats"

HRESULT D3DAPI DIRECT3DDEVICEI::GetStats(LPD3DSTATS lpStats)
{
    // not implemented for Device3 (and newer) interfaces
    if (this->dwVersion >= 3)
    {
        D3D_INFO(3, "GetStats not implemented for Device3 interface");
        return E_NOTIMPL;
    }

    D3DSTATS    stats;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_D3DSTATS_PTR(lpStats)) {
            D3D_ERR( "Invalid D3DSTATS pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in GetStats" );
        return DDERR_INVALIDPARAMS;
    }

    stats = this->D3DStats;

    *lpStats = stats;
    lpStats->dwSize = sizeof(D3DSTATS);

    return DD_OK;
}

/**
 ** Viewport Management
 **/
HRESULT DIRECT3DDEVICEI::hookViewportToDevice(LPDIRECT3DVIEWPORTI lpD3DView)
{

    CIRCLE_QUEUE_INSERT_END(&this->viewports, DIRECT3DVIEWPORTI,
                            lpD3DView, vw_list);
    lpD3DView->lpDevI = this;

    this->numViewports++;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::AddViewport"

HRESULT D3DAPI DIRECT3DDEVICEI::AddViewport(LPDIRECT3DVIEWPORT lpD3DView)
{
    return AddViewport((LPDIRECT3DVIEWPORT3)lpD3DView);
}

HRESULT D3DAPI DIRECT3DDEVICEI::AddViewport(LPDIRECT3DVIEWPORT2 lpD3DView)
{
    return AddViewport((LPDIRECT3DVIEWPORT3)lpD3DView);
}

HRESULT D3DAPI DIRECT3DDEVICEI::AddViewport(LPDIRECT3DVIEWPORT3 lpD3DView)
{
    LPDIRECT3DVIEWPORTI lpViewI;
    HRESULT err = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    lpViewI = (LPDIRECT3DVIEWPORTI)lpD3DView;

    if (lpViewI->lpDevI) {
        D3D_ERR("viewport already associated with a device");
        return (DDERR_INVALIDPARAMS);
    }

    err = hookViewportToDevice(lpViewI);

    /*
     * AddRef the viewport.
     */
    lpD3DView->AddRef();

    return (err);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::DeleteViewport"

HRESULT D3DAPI DIRECT3DDEVICEI::DeleteViewport(LPDIRECT3DVIEWPORT lpD3DView)
{
    return DeleteViewport((LPDIRECT3DVIEWPORT3)lpD3DView);
}

HRESULT D3DAPI DIRECT3DDEVICEI::DeleteViewport(LPDIRECT3DVIEWPORT2 lpD3DView)
{
    return DeleteViewport((LPDIRECT3DVIEWPORT3)lpD3DView);
}

HRESULT D3DAPI DIRECT3DDEVICEI::DeleteViewport(LPDIRECT3DVIEWPORT3 lpD3DView)
{
    LPDIRECT3DVIEWPORTI lpViewI;
    HRESULT err = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(lpD3DView)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in DeleteViewport" );
        return DDERR_INVALIDPARAMS;
    }
    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "DeleteViewport in Begin" );
        return D3DERR_INBEGIN;
    }
    lpViewI = (LPDIRECT3DVIEWPORTI)lpD3DView;

    if (lpViewI->lpDevI != this) {
        D3D_ERR("This Viewport is not associated with this device");
        return (DDERR_INVALIDPARAMS);
    }

    /*
     * Remove this viewport from the device.
     */
    CIRCLE_QUEUE_DELETE(&this->viewports, lpViewI, vw_list);
    this->numViewports--;

    lpViewI->lpDevI = NULL;
    if (lpViewI == lpCurrentViewport)
    {
        // AnanKan (6/10/98):
        // Apparently this release needs to be done for proper COM
        // implementation, since we do lpCurrentViewport->AddRef() when
        // we make a viewport the current viewport of the device. But this
        // breaks some old apps (pplane.exe)
        if(!(this->dwDeviceFlags & D3DDEV_PREDX6DEVICE))
            lpCurrentViewport->Release();
        lpCurrentViewport = NULL;
        v_id = 0;
    }

    /*
     * Release the viewport.
     */
    lpD3DView->Release();

    return (err);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::NextViewport"

HRESULT D3DAPI DIRECT3DDEVICEI::NextViewport(LPDIRECT3DVIEWPORT lpD3DView,
                                   LPDIRECT3DVIEWPORT* lplpView,
                                   DWORD dwFlags)
{
    return NextViewport((LPDIRECT3DVIEWPORT3)lpD3DView,
                               (LPDIRECT3DVIEWPORT3*)lplpView, dwFlags);
}

HRESULT D3DAPI DIRECT3DDEVICEI::NextViewport(LPDIRECT3DVIEWPORT2 lpD3DView,
                                    LPDIRECT3DVIEWPORT2* lplpView,
                                    DWORD dwFlags)
{
    return NextViewport((LPDIRECT3DVIEWPORT3)lpD3DView,
                               (LPDIRECT3DVIEWPORT3*)lplpView, dwFlags);
}

HRESULT D3DAPI DIRECT3DDEVICEI::NextViewport(LPDIRECT3DVIEWPORT3 lpD3DView,
                                    LPDIRECT3DVIEWPORT3* lplpView,
                                    DWORD dwFlags)
{
    LPDIRECT3DVIEWPORTI lpViewI;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_OUTPTR(lplpView)) {
            D3D_ERR( "Invalid pointer to viewport object pointer" );
            return DDERR_INVALIDPARAMS;
        }

        *lplpView = NULL;

        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (dwFlags == D3DNEXT_NEXT) {
            if (!VALID_DIRECT3DVIEWPORT3_PTR(lpD3DView)) {
                D3D_ERR( "Invalid Direct3DViewport pointer" );
                return DDERR_INVALIDPARAMS;
            }
            lpViewI = (LPDIRECT3DVIEWPORTI)lpD3DView;
            if (lpViewI->lpDevI != this) {
                D3D_ERR("This Viewport is not associated with this device");
                return (DDERR_INVALIDPARAMS);
            }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR("Exception encountered validating parameters in NextViewport");
        return DDERR_INVALIDPARAMS;
    }

    if (this->numViewports <= 0) {
        D3D_ERR( "No viewport has been added to the device yet." );
        return D3DERR_NOVIEWPORTS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "NextViewport called in Begin" );
        return D3DERR_INBEGIN;
    }
    switch (dwFlags) {
    case D3DNEXT_NEXT:
        *lplpView = (LPDIRECT3DVIEWPORT3)
            CIRCLE_QUEUE_NEXT(&this->viewports,lpViewI,vw_list);
        break;
    case D3DNEXT_HEAD:
        *lplpView = (LPDIRECT3DVIEWPORT3)
            CIRCLE_QUEUE_FIRST(&this->viewports);
        break;
    case D3DNEXT_TAIL:
        *lplpView = (LPDIRECT3DVIEWPORT3)
            CIRCLE_QUEUE_LAST(&this->viewports);
        break;
    default:
        D3D_ERR("invalid dwFlags in NextViewport");
        return (DDERR_INVALIDPARAMS);
    }
    if (*lplpView == (LPDIRECT3DVIEWPORT3)&this->viewports) {
        *lplpView = NULL;
    }

    /*
     * Must AddRef the returned object
     */
    if (*lplpView) {
        (*lplpView)->AddRef();
    }

    return (D3D_OK);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::Execute"

HRESULT D3DAPI DIRECT3DDEVICEI::Execute(LPDIRECT3DEXECUTEBUFFER lpBuffer,
                              LPDIRECT3DVIEWPORT lpD3DView,
                              DWORD dwInpFlags)
{
    HRESULT ret;
    LPDIRECT3DVIEWPORTI lpD3DViewI;
    LPDIRECT3DVIEWPORTI lpD3DOldViewI;
    BOOL viewportChanged;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(lpBuffer))
        {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (lpD3DView && (!VALID_DIRECT3DVIEWPORT_PTR(lpD3DView)) )
        {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in Execute" );
        return DDERR_INVALIDPARAMS;
    }
    lpD3DOldViewI = lpCurrentViewport;
    if (lpD3DView)
        lpD3DViewI = (LPDIRECT3DVIEWPORTI)lpD3DView;
    else
        lpD3DViewI = lpCurrentViewport;

    // The viewport must be associated with lpDev device
    //
    if (lpD3DViewI->lpDevI != this)
    {
        return (DDERR_INVALIDPARAMS);
    }

    lpCurrentViewport = lpD3DViewI;

    ret = CheckDeviceSettings(this);
    if (ret != D3D_OK)
    {
        lpCurrentViewport = lpD3DOldViewI;
        D3D_ERR("Bad Device settings");
        return (ret);
    }

    /*
     * Save existing fp state and then disable divide-by-zero exceptions.
     * XXX need a better way for non-intel platforms.
     */

    LPDIRECT3DEXECUTEBUFFERI lpBufferI;
    D3DI_EXECUTEDATA exData;

    lpBufferI = (LPDIRECT3DEXECUTEBUFFERI)lpBuffer;

    /* Make sure this buffer is associated with the correct device */
    if (lpBufferI->lpDevI != this)
    {
        D3D_ERR("Exe-buffer not associated with this device");
        return (DDERR_INVALIDPARAMS);
    }

    if (lpBufferI->locked)
    {
        D3D_ERR("Exe-buffer is locked");
        return (D3DERR_EXECUTE_LOCKED);
    }

    /* Apply any cached render states */
    if ((ret=this->FlushStates()) != D3D_OK)
    {
        D3D_ERR("Error trying to flush batched commands");
        return ret;
    }
    /*
     * Create an execute data structure
     */
    memset(&exData, 0, sizeof(exData));
    exData.dwSize = sizeof(D3DI_EXECUTEDATA);
    exData.dwHandle = lpBufferI->hBuf;
    exData.dwVertexOffset = lpBufferI->exData.dwVertexOffset;
    exData.dwVertexCount = lpBufferI->exData.dwVertexCount;
    exData.dwInstructionOffset = lpBufferI->exData.dwInstructionOffset;
    exData.dwInstructionLength = lpBufferI->exData.dwInstructionLength;
    exData.dwHVertexOffset = lpBufferI->exData.dwHVertexOffset;

#if DBG
// Validation
    if (exData.dwVertexOffset > exData.dwInstructionOffset ||
        (exData.dwVertexCount * sizeof(D3DVERTEX) + exData.dwVertexOffset) >
        exData.dwInstructionOffset)
    {
        D3D_WARN(1, "Execute: Instruction and vertex areas overlap");
    }

#endif

    this->dwFlags = D3DPV_INSIDEEXECUTE;
    this->dwVIDOut = D3DFVF_TLVERTEX;

    ret = this->ExecuteI(&exData, dwInpFlags);
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to Execute");
        return ret;
    }

    this->dwFEFlags &= ~D3DFE_TLVERTEX;    // This flag could be set inside
    // Flush immediately since we cannot batch across EB calls (for DP2)
    if ((ret=this->FlushStates()) != D3D_OK)
    {
        D3D_ERR("Error trying to flush batched commands");
        return ret;
    }
    lpBufferI->exData.dsStatus = exData.dsStatus;

    lpCurrentViewport = lpD3DOldViewI;

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetCaps"

HRESULT D3DAPI CDirect3DDevice::GetCaps(LPD3DDEVICEDESC lpD3DHWDevDesc,
                              LPD3DDEVICEDESC lpD3DHELDevDesc)
{
    HRESULT ret;

    ret = GetCapsI(lpD3DHWDevDesc, lpD3DHELDevDesc);
    if ((ret == D3D_OK) && IS_PRE_DX5_DEVICE(this))
    {
        lpD3DHELDevDesc->dpcLineCaps.dwTextureFilterCaps &= ~(D3DPTFILTERCAPS_MIPNEAREST |
                                                              D3DPTFILTERCAPS_MIPLINEAR |
                                                              D3DPTFILTERCAPS_LINEARMIPNEAREST);
        lpD3DHELDevDesc->dpcTriCaps.dwTextureFilterCaps &= ~(D3DPTFILTERCAPS_MIPNEAREST |
                                                             D3DPTFILTERCAPS_MIPLINEAR |
                                                             D3DPTFILTERCAPS_LINEARMIPNEAREST);
    }
    return ret;
}

HRESULT D3DAPI D3DAPI DIRECT3DDEVICEI::GetCaps(LPD3DDEVICEDESC lpD3DHWDevDesc,
                               LPD3DDEVICEDESC lpD3DHELDevDesc)
{
    return GetCapsI(lpD3DHWDevDesc, lpD3DHELDevDesc);
}

HRESULT DIRECT3DDEVICEI::GetCapsI(LPD3DDEVICEDESC lpD3DHWDevDesc,
                               LPD3DDEVICEDESC lpD3DHELDevDesc)
{
    HRESULT ret;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DDEVICEDESC_PTR(lpD3DHWDevDesc)) {
            D3D_ERR( "Invalid D3DDEVICEDESC pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_D3DDEVICEDESC_PTR(lpD3DHELDevDesc)) {
            D3D_ERR( "Invalid D3DDEVICEDESC pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in GetCaps" );
        return DDERR_INVALIDPARAMS;
    }

    memcpy(lpD3DHWDevDesc, &this->d3dHWDevDesc, lpD3DHWDevDesc->dwSize);
    memcpy(lpD3DHELDevDesc, &this->d3dHELDevDesc, lpD3DHELDevDesc->dwSize);
    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::Pick"

HRESULT D3DAPI DIRECT3DDEVICEI::Pick(LPDIRECT3DEXECUTEBUFFER lpD3DExBuf,
                           LPDIRECT3DVIEWPORT lpD3DView,
                           DWORD dwFlags,
                           LPD3DRECT lpRect)
{
    HRESULT ret;
    LPDIRECT3DVIEWPORTI lpD3DViewI;
    LPDIRECT3DVIEWPORTI lpD3DOldViewI;
    LPDIRECT3DEXECUTEBUFFERI lpBufferI;
    D3DI_PICKDATA pdata;
    D3DI_EXECUTEDATA exData;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(lpD3DExBuf)) {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DVIEWPORT_PTR(lpD3DView)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DRECT_PTR(lpRect)) {
            D3D_ERR( "Invalid D3DRECT pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    lpD3DViewI = (LPDIRECT3DVIEWPORTI)lpD3DView;

    /*
     * The viewport must be associated with this device
     */
    if (lpD3DViewI->lpDevI != this) {
        D3D_ERR("viewport not associated with this device");
        return (DDERR_INVALIDPARAMS);
    }

    lpBufferI = (LPDIRECT3DEXECUTEBUFFERI)lpD3DExBuf;

    /* Make sure this buffer is associated with the correct device */
    if (lpBufferI->lpDevI != this) {
        D3D_ERR("Exe-buffer not associated with this device");
        return (DDERR_INVALIDPARAMS);
    }

    if (lpBufferI->locked) {
        D3D_ERR("Exe-buffer is locked");
        return (D3DERR_EXECUTE_LOCKED);
    }

    lpD3DOldViewI = lpCurrentViewport;
    lpCurrentViewport = lpD3DViewI;

    ret = CheckDeviceSettings(this);
    if (ret != D3D_OK)
    {
        D3D_ERR("Bad Device settings");
        lpCurrentViewport = lpD3DOldViewI;
        return (ret);
    }

    /*
     * Create an execute data structure
     */
    memset(&exData, 0, sizeof(exData));
    exData.dwSize = sizeof(D3DI_EXECUTEDATA);
    exData.dwHandle = lpBufferI->hBuf;
    memcpy((LPBYTE)(&exData.dwVertexOffset), 
           (LPBYTE)(&lpBufferI->exData.dwVertexOffset),
           sizeof(D3DEXECUTEDATA) - sizeof(DWORD));
    pdata.exe = &exData;
    pdata.pick.x1 = lpRect->x1;
    pdata.pick.y1 = lpRect->y1;
    pdata.pick.x2 = lpRect->x2;
    pdata.pick.y2 = lpRect->y2;

    this->dwFlags = D3DPV_INSIDEEXECUTE;
    this->dwVIDOut = D3DFVF_TLVERTEX;

    D3DHAL_ExecutePick(this, &pdata);

    this->dwFEFlags &= ~D3DFE_TLVERTEX;    // This flag could be set inside
    lpCurrentViewport = lpD3DOldViewI;

    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetPickRecords"

HRESULT D3DAPI DIRECT3DDEVICEI::GetPickRecords(LPDWORD count,
                                     LPD3DPICKRECORD records)
{
    HRESULT     ret;
    D3DI_PICKDATA   pdata;
    D3DPICKRECORD*  tmpBuff;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DWORD_PTR(count)) {
            D3D_ERR( "Invalid DWORD pointer" );
            return DDERR_INVALIDPARAMS;
        }
#if DBG
        if (*count && records && IsBadWritePtr(records, *count * sizeof(D3DPICKRECORD))) {
            D3D_ERR( "Invalid D3DPICKRECORD pointer" );
            return DDERR_INVALIDPARAMS;
        }
#endif
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    pdata.records = NULL;
    GenGetPickRecords(this, &pdata);

    if (count && records && *count >= (unsigned long)pdata.pick_count)
    {
        int picked_size = pdata.pick_count * sizeof(D3DPICKRECORD);

        if (D3DMalloc((void**)&tmpBuff, picked_size) != DD_OK)
        {
            return (DDERR_OUTOFMEMORY);
        }
        pdata.records = tmpBuff;
        GenGetPickRecords(this, &pdata);
        memcpy((char*)records, (char*)tmpBuff, picked_size);
        D3DFree(tmpBuff);
    }

    *count = pdata.pick_count;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::EnumTextureFormats"


#define DEFINEPF(flags, fourcc, bpp, rMask, gMask, bMask, aMask) \
    { sizeof(DDPIXELFORMAT), (flags), (fourcc), (bpp), (rMask), (gMask), (bMask), (aMask) }

static DDPIXELFORMAT g_DX5TexEnumIncListStatic[] = {
DEFINEPF(DDPF_RGB,                      0UL, 16UL, 0x00007c00UL, 0x000003e0UL, 0x0000001fUL, 0x00000000), // 16bit 555
DEFINEPF(DDPF_RGB|DDPF_ALPHAPIXELS,     0UL, 16UL, 0x00007c00UL, 0x000003e0UL, 0x0000001fUL, 0x00008000), // 16bit 1555
DEFINEPF(DDPF_RGB,                      0UL, 16UL, 0x0000f800UL, 0x000007e0UL, 0x0000001fUL, 0x00000000), // 16bit 565
DEFINEPF(DDPF_RGB|DDPF_ALPHAPIXELS,     0UL, 16UL, 0x00000f00UL, 0x000000f0UL, 0x0000000fUL, 0x0000f000), // 16bit 4444
DEFINEPF(DDPF_RGB|DDPF_ALPHAPIXELS,     0UL, 32UL, 0x00ff0000UL, 0x0000ff00UL, 0x000000ffUL, 0xff000000), // 32bit 8888
DEFINEPF(DDPF_RGB,                      0UL, 32UL, 0x00ff0000UL, 0x0000ff00UL, 0x000000ffUL, 0x00000000), // 32bit 888
DEFINEPF(DDPF_RGB,                      0UL,  8UL, 0x000000e0UL, 0x0000001cUL, 0x00000003UL, 0x00000000), // 8bit  332
DEFINEPF(DDPF_RGB|DDPF_PALETTEINDEXED4, 0UL,  4UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000), // 4bit pal
DEFINEPF(DDPF_RGB|DDPF_PALETTEINDEXED8, 0UL,  8UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000), // 8bit pal
};
DWORD g_cDX5TexEnumIncListStatic = sizeof(g_DX5TexEnumIncListStatic)/sizeof(DDPIXELFORMAT);

BOOL
MatchDDPIXELFORMAT( DDPIXELFORMAT* pddpfA, DDPIXELFORMAT* pddpfB )
{
    if ( pddpfA->dwFlags != pddpfB->dwFlags ) return FALSE;
    if ( pddpfA->dwRGBBitCount != pddpfB->dwRGBBitCount ) return FALSE;
    if ( pddpfA->dwRBitMask != pddpfB->dwRBitMask ) return FALSE;
    if ( pddpfA->dwGBitMask != pddpfB->dwGBitMask ) return FALSE;
    if ( pddpfA->dwBBitMask != pddpfB->dwBBitMask ) return FALSE;
    if ( pddpfA->dwRGBAlphaBitMask != pddpfB->dwRGBAlphaBitMask ) return FALSE;
    if ( pddpfA->dwFourCC != pddpfB->dwFourCC ) return FALSE;
    return TRUE;
}

void
LoadTexEnumInclList( char* pResPath, DDPIXELFORMAT*& pddpfInclList, DWORD& cInclList)
{
    HKEY hKey = (HKEY)NULL;
    if (ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE,
        pResPath, &hKey))
    {
        DWORD cSubKeys = 0;
        if ( ERROR_SUCCESS == RegQueryInfoKey ( hKey,
                NULL,NULL,NULL, &cSubKeys, NULL,
                NULL,NULL,NULL,NULL,NULL,NULL ) )
        {
            D3D_INFO(3,"LoadTexEnumInclList: cSubKeys = %d",cSubKeys);

            if (cSubKeys == 0) return;

            // allocate space for ddpf inclusion list
            cInclList = cSubKeys;
            if (D3DMalloc((void**)&pddpfInclList, cInclList*sizeof(DDPIXELFORMAT)) != D3D_OK) {
                D3D_ERR("malloc failed on texture enum inclusion list");
                pddpfInclList = NULL;
                cInclList = 0;
            }
            memset( pddpfInclList, 0, cInclList*sizeof(DDPIXELFORMAT) );

            for (DWORD i=0; i<cSubKeys; i++)
            {
                char pName[128] = "";
                DWORD cbName = 128;
                if (ERROR_SUCCESS == RegEnumKeyEx( hKey, i, pName, &cbName,
                        NULL,NULL,NULL,NULL ) )
                {
                    HKEY hTexKey = (HKEY)NULL;
                    if (ERROR_SUCCESS == RegOpenKey( hKey, pName, &hTexKey))
                    {
                        DWORD dwType; DWORD dwSize;

                        // get string of full ddpf
                        char pDDPFStr[128] = ""; DWORD cbDDPFStr = 128;
                        if (ERROR_SUCCESS == RegQueryValueEx(hTexKey, "ddpf",
                                NULL, &dwType, (LPBYTE)pDDPFStr, &cbDDPFStr) )
                        {
                            sscanf(pDDPFStr, "%x %x %d %x %x %x %x",
                                &pddpfInclList[i].dwFlags,&pddpfInclList[i].dwFourCC,&pddpfInclList[i].dwRGBBitCount,
                                &pddpfInclList[i].dwRBitMask,&pddpfInclList[i].dwGBitMask,&pddpfInclList[i].dwBBitMask,
                                &pddpfInclList[i].dwRGBAlphaBitMask);
                        }

                        D3D_INFO(3,"LoadTexEnumInclList: <%s> %08x %08x %2d %08x %08x %08x %08x",
                            pName,
                            pddpfInclList[i].dwFlags,
                            pddpfInclList[i].dwFourCC,
                            pddpfInclList[i].dwRGBBitCount,
                            pddpfInclList[i].dwRBitMask,
                            pddpfInclList[i].dwGBitMask,
                            pddpfInclList[i].dwBBitMask,
                            pddpfInclList[i].dwRGBAlphaBitMask);
                    }
                    else
                    {
                        D3D_INFO(3,"LoadTexEnumInclList: failed to open subkey %s",pName);
                    }
                }
                else
                {
                    D3D_INFO(3,"LoadTexEnumInclList: failed to enumerate subkey %d",i);
                }
            }
        }
    }
}

HRESULT
DoEnumTextureFormats(
    DIRECT3DDEVICEI* lpDevI,
    LPD3DENUMTEXTUREFORMATSCALLBACK lpEnumCallbackDX5, // DX5 version
    LPD3DENUMPIXELFORMATSCALLBACK lpEnumCallbackDX6,   // DX6 version
    LPVOID lpContext)
{
    HRESULT ret, userRet;
    LPDDSURFACEDESC lpDescs, lpRetDescs;
    DWORD num_descs;
    DWORD i;

    ret = D3D_OK;

    num_descs = lpDevI->lpD3DHALGlobalDriverData->dwNumTextureFormats;
    lpDescs = lpDevI->lpD3DHALGlobalDriverData->lpTextureFormats;
    if (!num_descs)
    {
        D3D_ERR("no texture formats supported");
        return (D3DERR_TEXTURE_NO_SUPPORT);
    }

    if (D3DMalloc((void**)&lpRetDescs, sizeof(DDSURFACEDESC) * num_descs) != D3D_OK)
    {
        D3D_ERR("failed to alloc space for return descriptions");
        return (DDERR_OUTOFMEMORY);
    }
    memcpy(lpRetDescs, lpDescs, sizeof(DDSURFACEDESC) * num_descs);

    // get apphack flags
    LPDDRAWI_DIRECTDRAW_LCL lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)(lpDevI->lpDD))->lpLcl;
    DWORD dwEnumInclAppHack =
        ((lpDDLcl->dwAppHackFlags & DDRAW_APPCOMPAT_TEXENUMINCL_0)?1:0) |
        ((lpDDLcl->dwAppHackFlags & DDRAW_APPCOMPAT_TEXENUMINCL_1)?2:0);
    // two bit field:
    //  0 - no apphack (default behavior)
    //  1 - use no inclusion list
    //  2 - use DX5 inclusion list
    //  3 - use DX6 inclusion list
    D3D_INFO(3, "APPCOMPAT_TEXENUMINCL: %d",dwEnumInclAppHack);

    // enumeration limit defaults true for <DX6 interfaces, and can be disabled by apphack
    BOOL bEnumLimit = (lpDevI->dwVersion < 3) ? TRUE : FALSE;
    if (lpDDLcl->dwAppHackFlags & DDRAW_APPCOMPAT_TEXENUMLIMIT) { bEnumLimit = FALSE; }
    D3D_INFO(3, "EnumTextureFormats: bEnumLimit %d",bEnumLimit);

#if DBG
    // debug capability to eliminate enumeration of any subset of first 32 textures
    DWORD dwEnumDisable = 0x0;
    GetD3DRegValue(REG_DWORD, "TextureEnumDisable", &dwEnumDisable, sizeof(DWORD));
    D3D_INFO(3, "TextureEnumDisable: %08x",dwEnumDisable);
#endif

    DDPIXELFORMAT* pDX5TexEnumIncList = NULL;
    DWORD cDX5TexEnumIncList = 0;
    // load DX5 inclusion list from registry
    LoadTexEnumInclList( RESPATH_D3D "\\DX5TextureEnumInclusionList",
        pDX5TexEnumIncList, cDX5TexEnumIncList );

    DDPIXELFORMAT* pDX6TexEnumIncList = NULL;
    DWORD cDX6TexEnumIncList = 0;
    // load DX6 list only for DX6 interface or apphack
    if ((lpDevI->dwVersion == 3) || (dwEnumInclAppHack >= 3))
    {
        LoadTexEnumInclList( RESPATH_D3D "\\DX6TextureEnumInclusionList",
            pDX6TexEnumIncList, cDX6TexEnumIncList );
    }

    userRet = D3DENUMRET_OK;
    int cEnumLimit = 0;
    for (i = 0; i < num_descs && userRet == D3DENUMRET_OK; i++)
    {

        D3D_INFO(3,"EnumTextureFormats: %2d %08x %08x %2d %08x %08x %08x %08x",i,
            lpRetDescs[i].ddpfPixelFormat.dwFlags,
            lpRetDescs[i].ddpfPixelFormat.dwFourCC,
            lpRetDescs[i].ddpfPixelFormat.dwRGBBitCount,
            lpRetDescs[i].ddpfPixelFormat.dwRBitMask,
            lpRetDescs[i].ddpfPixelFormat.dwGBitMask,
            lpRetDescs[i].ddpfPixelFormat.dwBBitMask,
            lpRetDescs[i].ddpfPixelFormat.dwRGBAlphaBitMask);

#if DBG
        if ( (i < 32) && (dwEnumDisable & (1<<i)) )
        {
            D3D_INFO(3, "EnumTextureFormats: filtering texture %d",i);
            continue;
        }
#endif

        // Filtering out texture formats which are not on inclusion list -
        if ( (dwEnumInclAppHack != 1) && // inclusion list not disabled by apphack
             !(lpRetDescs[i].ddpfPixelFormat.dwFlags == DDPF_FOURCC) ) // not FourCC
        {
            BOOL bMatched = FALSE;

            // match against DX5 base (static) inclusion list
            for (DWORD j=0; j<g_cDX5TexEnumIncListStatic; j++)
            {
                if (MatchDDPIXELFORMAT( &(g_DX5TexEnumIncListStatic[j]), &(lpRetDescs[i].ddpfPixelFormat)))
                {
                    bMatched = TRUE; break;
                }
            }
            // match against DX5 extended (regkey) inclusion list
            if (!bMatched && cDX5TexEnumIncList)
            {
                for (DWORD j=0; j<cDX5TexEnumIncList; j++)
                {
                    if (MatchDDPIXELFORMAT( &(pDX5TexEnumIncList[j]), &(lpRetDescs[i].ddpfPixelFormat)))
                    {
                        bMatched = TRUE; break;
                    }
                }
            }

            // match against DX6 regkey list for:
            //   (DX6 interface AND apphack not forcing DX5 inclusion list only) OR
            //   (apphack forcing DX6 inclusion list)
            if ( ((lpDevI->dwVersion == 3) && (dwEnumInclAppHack != 2)) ||
                 (dwEnumInclAppHack == 3) )
            {
                for (DWORD j=0; j<cDX6TexEnumIncList; j++)
                {
                    if (MatchDDPIXELFORMAT( &(pDX6TexEnumIncList[j]), &(lpRetDescs[i].ddpfPixelFormat)))
                    {
                        bMatched = TRUE; break;
                    }
                }
            }

            if (!bMatched) {
                D3D_INFO(3, "EnumTextureFormats: filtering non-included texture %d",i);
                continue;
            }
        }

        // exclude DXT1..5 for <DX6 interfaces
        if ( (lpDevI->dwVersion < 3) && (lpRetDescs[i].ddpfPixelFormat.dwFlags == DDPF_FOURCC) )
        {
            if ( (lpRetDescs[i].ddpfPixelFormat.dwFourCC == MAKEFOURCC('D', 'X', 'T', '1')) ||
                 (lpRetDescs[i].ddpfPixelFormat.dwFourCC == MAKEFOURCC('D', 'X', 'T', '2')) ||
                 (lpRetDescs[i].ddpfPixelFormat.dwFourCC == MAKEFOURCC('D', 'X', 'T', '3')) ||
                 (lpRetDescs[i].ddpfPixelFormat.dwFourCC == MAKEFOURCC('D', 'X', 'T', '4')) ||
                 (lpRetDescs[i].ddpfPixelFormat.dwFourCC == MAKEFOURCC('D', 'X', 'T', '5')) )
            {
                D3D_INFO(3, "EnumTextureFormats: filtering DXT1..5 format for DX3/5 interfaces");
                continue;
            }
        }

        // exclude all FourCC code formats for <DX6 interfaces on DX7 drivers
        if ( (lpDevI->dwVersion < 3) && IS_DX7HAL_DEVICE(lpDevI) &&
             (lpRetDescs[i].ddpfPixelFormat.dwFlags == DDPF_FOURCC) )
        {
            D3D_INFO(3, "EnumTextureFormats: filtering all FOURCC formats for DX3/5 interfaces on DX7 HALs");
            continue;
        }

        // do enumeration if not ('limit enabled' && 'limit exceeded')
        if ( !(bEnumLimit && (++cEnumLimit > 10)) )
        {
            if (lpEnumCallbackDX5)
            {
                userRet = (*lpEnumCallbackDX5)(&lpRetDescs[i], lpContext);
            }
            if (lpEnumCallbackDX6)
            {
                userRet = (*lpEnumCallbackDX6)(&(lpRetDescs[i].ddpfPixelFormat), lpContext);
            }
        }
        else
        {
            D3D_INFO(3, "EnumTextureFormats: enumeration limit exceeded");
        }
    }

    D3DFree(lpRetDescs);
    if (pDX5TexEnumIncList) D3DFree(pDX5TexEnumIncList);
    if (pDX6TexEnumIncList) D3DFree(pDX6TexEnumIncList);

    return (D3D_OK);
}


// Device/Device2 version
HRESULT D3DAPI DIRECT3DDEVICEI::EnumTextureFormats(
    LPD3DENUMTEXTUREFORMATSCALLBACK lpEnumCallback,
    LPVOID lpContext)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALIDEX_CODE_PTR(lpEnumCallback)) {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    return DoEnumTextureFormats(this, lpEnumCallback, NULL, lpContext);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::EnumTextureFormats"

// Device3 version
HRESULT D3DAPI DIRECT3DDEVICEI::EnumTextureFormats(
    LPD3DENUMPIXELFORMATSCALLBACK lpEnumCallback,
    LPVOID lpContext)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALIDEX_CODE_PTR(lpEnumCallback)) {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    return DoEnumTextureFormats(this, NULL, lpEnumCallback, lpContext);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SwapTextureHandles"

HRESULT D3DAPI DIRECT3DDEVICEI::SwapTextureHandles(LPDIRECT3DTEXTURE lpTex1,
                                         LPDIRECT3DTEXTURE lpTex2)
{
    LPDIRECT3DTEXTUREI lpTex1I;
    LPDIRECT3DTEXTUREI lpTex2I;
    HRESULT ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DTEXTURE_PTR(lpTex1)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DTEXTURE_PTR(lpTex2)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        lpTex1I = static_cast<LPDIRECT3DTEXTUREI>(lpTex1);
        lpTex2I = static_cast<LPDIRECT3DTEXTUREI>(lpTex2);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    ret = SwapTextureHandles((LPDIRECT3DTEXTURE2)lpTex1I,
                                     (LPDIRECT3DTEXTURE2)lpTex2I);
    return ret;
}

HRESULT D3DAPI DIRECT3DDEVICEI::SwapTextureHandles(LPDIRECT3DTEXTURE2 lpTex1,
                                          LPDIRECT3DTEXTURE2 lpTex2)
{
    LPDIRECT3DTEXTUREI lpTex1I;
    LPDIRECT3DTEXTUREI lpTex2I;
    HRESULT servRet;
    D3DTEXTUREHANDLE hTex;
    LPD3DI_TEXTUREBLOCK lptBlock1,lptBlock2;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DTEXTURE2_PTR(lpTex1)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DTEXTURE2_PTR(lpTex2)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        lpTex1I = static_cast<LPDIRECT3DTEXTUREI>(lpTex1);
        lpTex2I = static_cast<LPDIRECT3DTEXTUREI>(lpTex2);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    if (lpTex1I->lpDDSSys || lpTex2I->lpDDSSys)
    {
        D3D_ERR("Can't Swap Managed textures. Returning DDERR_INVALIDPARAMS");
        return  DDERR_INVALIDPARAMS;
    }
    if (!(lptBlock1=D3DI_FindTextureBlock(lpTex1I,this)))
    {
        D3D_ERR("lpTex1 is an invalid texture handle.");
        return  DDERR_INVALIDPARAMS;
    }
    if (!(lptBlock2=D3DI_FindTextureBlock(lpTex2I,this)))
    {
        D3D_ERR("lpTex2 is an invalid texture handle.");
        return  DDERR_INVALIDPARAMS;
    }
    if (D3D_OK != (servRet=FlushStates()))
    {
        D3D_ERR("Error trying to flush batched commands during TextureSwap");
        return  servRet;
    }

    if (IS_DX7HAL_DEVICE(this))
    {
        LPDDRAWI_DDRAWSURFACE_LCL surf1 = ((LPDDRAWI_DDRAWSURFACE_INT)lpTex1I->lpDDS)->lpLcl;
        LPDDRAWI_DDRAWSURFACE_LCL surf2 = ((LPDDRAWI_DDRAWSURFACE_INT)lpTex2I->lpDDS)->lpLcl;
        LPDDRAWI_DIRECTDRAW_LCL pDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)lpDirect3DI->lpDD)->lpLcl;
        DDASSERT(pDDLcl != NULL);

        // Update DDraw handle in driver GBL object.
        pDDLcl->lpGbl->hDD = pDDLcl->hDD;
        // Swap the handles stored in the surface locals
        surf1->lpSurfMore->dwSurfaceHandle = lptBlock2->hTex;
        surf2->lpSurfMore->dwSurfaceHandle = lptBlock1->hTex;
        // Swap the surface pointers stored in the handle table stored in
        // ddraw local
        SURFACEHANDLELIST(pDDLcl).dwList[lptBlock1->hTex].lpSurface = surf2;
        SURFACEHANDLELIST(pDDLcl).dwList[lptBlock2->hTex].lpSurface = surf1;

        // call the driver to switch the textures mapped to the handles in
        // the driver
        DDASSERT(NULL != pDDLcl->lpGbl->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx);
        DDHAL_CREATESURFACEEXDATA   csdex;
        DWORD   rc;
        csdex.ddRVal  = DDERR_GENERIC;
        csdex.dwFlags = 0;
        csdex.lpDDLcl = pDDLcl;
        csdex.lpDDSLcl = surf1;
        rc = pDDLcl->lpGbl->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx(&csdex);
        if(  DDHAL_DRIVER_HANDLED == rc && DD_OK != csdex.ddRVal)
        {
            // Driver call failed
            D3D_ERR("DdSwapTextureHandles failed!");
            return  D3DERR_TEXTURE_SWAP_FAILED;
        }
        csdex.lpDDSLcl = surf2;
        rc = pDDLcl->lpGbl->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx(&csdex);
        if(  DDHAL_DRIVER_HANDLED == rc && DD_OK != csdex.ddRVal)
        {
            // Driver call failed
            D3D_ERR("DdSwapTextureHandles failed!");
            return  D3DERR_TEXTURE_SWAP_FAILED;
        }
    }
    else
    {
        servRet=D3DHAL_TextureSwap(this,lptBlock1->hTex,lptBlock2->hTex);
        if (D3D_OK != servRet)
        {
            D3D_ERR("SwapTextureHandles HAL call failed");
            return  D3DERR_TEXTURE_SWAP_FAILED;
        }
    }
    hTex=lptBlock1->hTex;
    lptBlock1->hTex=lptBlock2->hTex;
    lptBlock2->hTex=hTex;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::CreateMatrix"

HRESULT D3DAPI DIRECT3DDEVICEI::CreateMatrix(LPD3DMATRIXHANDLE lphMatrix)
{
    HRESULT servRet;
    D3DMATRIXHANDLE hMat;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DMATRIXHANDLE_PTR(lphMatrix)) {
            D3D_ERR( "Invalid D3DMATRIXHANDLE pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *lphMatrix = 0;

    servRet = D3DHAL_MatrixCreate(this, &hMat);
    if (servRet != D3D_OK)
    {
        D3D_ERR("Could not create matrix.");
        return (DDERR_OUTOFMEMORY);
    }

    D3D_INFO(4, "CreateMatrix, Matrix created. handle = %d", hMat);
    *lphMatrix = hMat;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetMatrix"

HRESULT D3DAPI DIRECT3DDEVICEI::SetMatrix(D3DMATRIXHANDLE hMatrix,
                                const LPD3DMATRIX lpdmMatrix)
{
    HRESULT servRet;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DMATRIX_PTR(lpdmMatrix)) {
            D3D_ERR( "Invalid D3DMATRIX pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!hMatrix) {
        D3D_ERR("NULL hMatrix passed");
        return (DDERR_INVALIDPARAMS);
    }

    servRet = D3DHAL_MatrixSetData(this, hMatrix, lpdmMatrix);
    if (servRet != D3D_OK)
    {
        D3D_ERR("Could not set matrix");
        return (DDERR_INVALIDPARAMS);
    }

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetMatrix"

HRESULT D3DAPI DIRECT3DDEVICEI::GetMatrix(D3DMATRIXHANDLE hMatrix,
                                LPD3DMATRIX lpdmMatrix)
{
    HRESULT servRet;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DMATRIX_PTR(lpdmMatrix)) {
            D3D_ERR( "Invalid D3DMATRIX pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!hMatrix)
    {
        D3D_ERR("NULL hMatrix passed.");
        return (DDERR_INVALIDPARAMS);
    }

    memset(lpdmMatrix, 0, sizeof(D3DMATRIX));

    servRet = D3DHAL_MatrixGetData(this, hMatrix, lpdmMatrix);
    if (servRet != D3D_OK)
    {
        D3D_ERR("Could not get matrix");
        return (DDERR_INVALIDPARAMS);
    }

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::DeleteMatrix"

HRESULT D3DAPI DIRECT3DDEVICEI::DeleteMatrix(D3DMATRIXHANDLE hMatrix)
{
    HRESULT servRet;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!hMatrix) {
        D3D_ERR("invalid D3DMATRIXHANDLE");
        return DDERR_INVALIDPARAMS;
    }

    servRet = D3DHAL_MatrixDestroy(this, hMatrix);
    if (servRet != D3D_OK)
    {
        D3D_ERR("Could not delete matrix");
        return (DDERR_INVALIDPARAMS);
    }

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::BeginScene"

HRESULT D3DAPI DIRECT3DDEVICEI::BeginScene()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)
    {
        D3D_ERR("BeginScene, already in scene.");
        return (D3DERR_SCENE_IN_SCENE);
    }

    // Check if we lost surfaces or rtarget / zbuffer was locked
    HRESULT servRet = this->CheckSurfaces();
    if (servRet != D3D_OK)
    {
        // If we lost surfaces
        if (servRet == DDERR_SURFACELOST)
        {
            // Even if the app restores the rendertargets and z buffer, it
            // doesn't know anything about vidmem execute buffers or
            // managed texture surfaces in vidmem. So, we need to do
            // this on our own. We first check if it is safe to restore
            // surfaces. If not, we fail in the usual way. Else, we
            // do the restore. Note that we will fail *only* if the
            // app calls BeginScene at the wrong time.
            servRet = this->lpDirect3DI->lpDD4->TestCooperativeLevel();
            if (servRet == DD_OK)
            {
                // Everything must be evicted otherwise Restore might not work
                // as there might be new surface allocated, in fact, we should
                // post a flag in Device so that Texture manage stop calling
                // CreateSurface() if this flag is indicating TestCooperativeLevel()
                // failed, however, even we added those, the EvictTextures below
                // is still needed but not this critical--kanqiu
                this->lpDirect3DI->lpTextureManager->EvictTextures();
                servRet = this->lpDirect3DI->lpDD4->RestoreAllSurfaces();
                if (servRet != DD_OK)
                    return D3DERR_SCENE_BEGIN_FAILED;
            }
            else
                return DDERR_SURFACELOST;
        }
        else
        {
            // Render target and / or the z buffer was locked
            return servRet;
        }
    }
    servRet = D3DHAL_SceneCapture(this, TRUE);

    if (servRet != D3D_OK && servRet != DDERR_NOTFOUND)
    {
        D3D_ERR("Could not BeginScene.");
        return D3DERR_SCENE_BEGIN_FAILED;
    }

    this->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_INSCENE;
    if (lpD3DHALGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR)
    {
        lpDirect3DI->lpTextureManager->TimeStamp();
    }

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::EndScene"

HRESULT D3DAPI DIRECT3DDEVICEI::EndScene()
{
    HRESULT servRet;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!(this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)) {
        D3D_ERR("EndScene, not in scene.");
        return (D3DERR_SCENE_NOT_IN_SCENE);
    }

    this->dwHintFlags &= ~D3DDEVBOOL_HINTFLAGS_INSCENE;
    if (IS_DX7HAL_DEVICE(this))
    {
        // must set the token before FlushStates()
        SetRenderStateI((D3DRENDERSTATETYPE)D3DRENDERSTATE_SCENECAPTURE, FALSE);
    }

    servRet = FlushStates();    //time to flush DrawPrimitives
    if (servRet != D3D_OK)
    {
        D3D_ERR("Could not Flush commands in EndScene!");
        return (D3DERR_SCENE_END_FAILED);
    }
    if (!IS_DX7HAL_DEVICE(this))
    {
        servRet = D3DHAL_SceneCapture(this, FALSE);

        if (servRet != D3D_OK && servRet != DDERR_NOTFOUND)
        {
            DPF(0, "(ERROR) Direct3DDevice::EndScene: Could not EndScene. Returning %d", servRet);
            return (D3DERR_SCENE_END_FAILED);
        }
    }

    // Did we lose any surfaces during this scene ?
    if (this->dwFEFlags & D3DFE_LOSTSURFACES)
    {
        D3D_INFO(3, "reporting DDERR_SURFACELOST in EndScene");
        this->dwFEFlags &= ~D3DFE_LOSTSURFACES;
        return DDERR_SURFACELOST;
    }

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetDirect3D"

HRESULT D3DAPI DIRECT3DDEVICEI::GetDirect3D(LPDIRECT3D* lplpD3D)
{
    LPDIRECT3D3 lpD3D3;
    HRESULT ret;

    ret = GetDirect3D(&lpD3D3);
    if (ret == D3D_OK)
    {
    //  *lplpD3D = dynamic_cast<LPDIRECT3D>(lpD3D3); // This is possible using RTTI
        *lplpD3D = static_cast<LPDIRECT3D>(static_cast<LPDIRECT3DI>(lpD3D3)); // This is safe even using static_cast
    }
    return ret;
}

HRESULT D3DAPI DIRECT3DDEVICEI::GetDirect3D(LPDIRECT3D2* lplpD3D)
{
    LPDIRECT3D3 lpD3D3;
    HRESULT ret;

    ret = GetDirect3D(&lpD3D3);
    if (ret == D3D_OK)
    {
    //  *lplpD3D = dynamic_cast<LPDIRECT3D>(lpD3D3); // This is possible using RTTI
        *lplpD3D = static_cast<LPDIRECT3D2>(static_cast<LPDIRECT3DI>(lpD3D3)); // This is safe even using static_cast
    }
    return ret;
}

HRESULT D3DAPI DIRECT3DDEVICEI::GetDirect3D(LPDIRECT3D3* lplpD3D)
{

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(lplpD3D)) {
            D3D_ERR( "Invalid Direct3D pointer pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpD3D = (LPDIRECT3D3) this->lpDirect3DI;
    (*lplpD3D)->AddRef();

    return (D3D_OK);
}

void
D3DDeviceDescConvert(LPD3DDEVICEDESC lpOut,
                     LPD3DDEVICEDESC_V1 lpV1,
                     LPD3DHAL_D3DEXTENDEDCAPS lpExt)
{
    if(lpV1!=NULL)
       memcpy(lpOut, lpV1, D3DDEVICEDESCSIZE_V1);

    if (lpExt)
    {
        // DX5
        lpOut->dwSize = D3DDEVICEDESCSIZE;
        lpOut->dwMinTextureWidth = lpExt->dwMinTextureWidth;
        lpOut->dwMaxTextureWidth = lpExt->dwMaxTextureWidth;
        lpOut->dwMinTextureHeight = lpExt->dwMinTextureHeight;
        lpOut->dwMaxTextureHeight = lpExt->dwMaxTextureHeight;
        lpOut->dwMinStippleWidth = lpExt->dwMinStippleWidth;
        lpOut->dwMaxStippleWidth = lpExt->dwMaxStippleWidth;
        lpOut->dwMinStippleHeight = lpExt->dwMinStippleHeight;
        lpOut->dwMaxStippleHeight = lpExt->dwMaxStippleHeight;

        // DX6
        lpOut->dwMaxTextureRepeat = lpExt->dwMaxTextureRepeat;
        lpOut->dwMaxTextureAspectRatio = lpExt->dwMaxTextureAspectRatio;
        lpOut->dwMaxAnisotropy = lpExt->dwMaxAnisotropy;
        lpOut->dvGuardBandLeft = lpExt->dvGuardBandLeft;
        lpOut->dvGuardBandTop = lpExt->dvGuardBandTop;
        lpOut->dvGuardBandRight = lpExt->dvGuardBandRight;
        lpOut->dvGuardBandBottom = lpExt->dvGuardBandBottom;
        lpOut->dvExtentsAdjust = lpExt->dvExtentsAdjust;
        lpOut->dwStencilCaps = lpExt->dwStencilCaps;
        lpOut->dwFVFCaps = lpExt->dwFVFCaps;
        lpOut->dwTextureOpCaps = lpExt->dwTextureOpCaps;
        lpOut->wMaxTextureBlendStages = lpExt->wMaxTextureBlendStages;
        lpOut->wMaxSimultaneousTextures = lpExt->wMaxSimultaneousTextures;
    }
}

//---------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::CheckSurfaces"
HRESULT DIRECT3DDEVICEI::CheckSurfaces()
{
    if(this->lpDirect3DI->lpTextureManager->CheckIfLost())
    {
        D3D_ERR("Managed Textures lost");
        return DDERR_SURFACELOST;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->lpGbl->dwUsageCount ||
         (this->lpDDSZBuffer && ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->lpGbl->dwUsageCount) )
    {
        D3D_ERR("Render target or Z buffer locked");
        return DDERR_SURFACEBUSY;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->dwFlags & DDRAWISURF_INVALID )\
        {
            D3D_ERR("Render target buffer lost");
            return DDERR_SURFACELOST;
        }
    if ( this->lpDDSZBuffer && ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->dwFlags & DDRAWISURF_INVALID ) )
    {
        D3D_ERR("Z buffer lost");
        return DDERR_SURFACELOST;
    }
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\buffer.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   buffer.c
 *  Content:    Direct3DExecuteBuffer implementation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

HRESULT hookBufferToDevice(LPDIRECT3DDEVICEI lpDevI,
                                  LPDIRECT3DEXECUTEBUFFERI lpD3DBuf)
{

    LIST_INSERT_ROOT(&lpDevI->buffers, lpD3DBuf, list);
    lpD3DBuf->lpDevI = lpDevI;

    return (D3D_OK);
}

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::Initialize(LPDIRECT3DDEVICE lpD3DDevice, LPD3DEXECUTEBUFFERDESC lpDesc)
{
    return DDERR_ALREADYINITIALIZED;
}

/*
 * Create the Buffer
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::CreateExecuteBuffer"

HRESULT D3DAPI DIRECT3DDEVICEI::CreateExecuteBuffer(LPD3DEXECUTEBUFFERDESC lpDesc,
                                                    LPDIRECT3DEXECUTEBUFFER* lplpBuffer,
                                                    IUnknown* pUnkOuter)
{
    LPDIRECT3DEXECUTEBUFFERI    lpBuffer;
    HRESULT         ret;
    D3DEXECUTEBUFFERDESC    debDesc;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_D3DEXECUTEBUFFERDESC_PTR(lpDesc)) {
        D3D_ERR( "Invalid D3DEXECUTEBUFFERDESC pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (!VALID_OUTPTR(lplpBuffer)) {
        D3D_ERR( "Invalid ptr to the buffer pointer" );
        return DDERR_INVALIDPARAMS;
    }

    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    *lplpBuffer = NULL;
    ret = D3D_OK;

    debDesc = *lpDesc;

    /*
     * We need size of the buffer, and optionally some stuff indicating
     * where the app would like the memory to be - system or card.
     */
    if ((!debDesc.dwFlags) & D3DDEB_BUFSIZE) {
        D3D_ERR("D3DDEB_BUFSIZE flag not set");
        return (DDERR_INVALIDPARAMS);
    }

    /*
     * Zero is an invalid execute buffer size.
     */
    if (debDesc.dwBufferSize == 0) {
        D3D_ERR("dwBufferSize = 0, zero sized execute buffers are illegal");
        return (DDERR_INVALIDPARAMS);
    }

    /*
     * Check the requested size.
     * If it's larger than allowed, error.
     *
     * The HEL always has the correct maximum value.
     */
    if (this->d3dHELDevDesc.dwMaxBufferSize) {
        /* We have a size for maximum */
        if (debDesc.dwBufferSize > this->d3dHELDevDesc.dwMaxBufferSize) {
            DPF(0,"(ERROR) Direct3DDevice::CreateExecuteBuffer: requested size is too large. %d > %d",
                debDesc.dwBufferSize, this->d3dHELDevDesc.dwMaxBufferSize);
            return (DDERR_INVALIDPARAMS);
        }
    }

    lpBuffer = static_cast<LPDIRECT3DEXECUTEBUFFERI>(new DIRECT3DEXECUTEBUFFERI());
    if (!lpBuffer) {
        D3D_ERR("Out of memory allocating execute-buffer");
        return (DDERR_OUTOFMEMORY);
    }


    /*
     * Allocated memory for the buffer
     */
    {
        LPDIRECTDRAWSURFACE dummy;
        if ((ret = D3DHAL_AllocateBuffer(this, &lpBuffer->hBuf, 
                                         &debDesc,
                                         &dummy)) != DD_OK)
        {
            D3D_ERR("Out of memory allocating internal buffer description");
            delete lpBuffer;
            return ret;
        }
    }

    /*
     * Put this device in the list of those owned by the
     * Direct3DDevice object
     */
    ret = hookBufferToDevice(this, lpBuffer);
    if (ret != D3D_OK) {
        D3D_ERR("Failed to associate buffer with device");
        delete lpBuffer;
        return (ret);
    }

    *lplpBuffer = static_cast<LPDIRECT3DEXECUTEBUFFER>(lpBuffer);

    return (D3D_OK);
}

DIRECT3DEXECUTEBUFFERI::DIRECT3DEXECUTEBUFFERI()
{
    /*
     * setup the object
     */
    pid = 0;
    memset(&debDesc,0,sizeof(D3DEXECUTEBUFFERDESC));
    memset(&exData, 0, sizeof(D3DEXECUTEDATA));
    locked = false; 
    memset(&hBuf, 0, sizeof(D3DI_BUFFERHANDLE));
    refCnt = 1;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::Lock"

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::Lock(LPD3DEXECUTEBUFFERDESC lpDesc)
{
    D3DEXECUTEBUFFERDESC    debDesc;
    HRESULT         ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DEXECUTEBUFFERDESC_PTR(lpDesc)) {
            D3D_ERR( "Invalid D3DEXECUTEBUFFERDESC pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    ret = D3D_OK;

    if (this->locked) {
        D3D_ERR("buffer already locked");
        return (D3DERR_EXECUTE_LOCKED);
    }

    debDesc = *lpDesc;
    this->locked = 1;
    this->pid = GetCurrentProcessId();

    {
        LPDIRECTDRAWSURFACE dummy;
        if ((ret = D3DHAL_LockBuffer(this->lpDevI, this->hBuf, &debDesc, &dummy)) != DD_OK)
        {
            D3D_ERR("Failed to lock buffer");
            this->locked = 0;
            return ret;
        }
    }

    *lpDesc = debDesc;

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::Unlock"

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::Unlock()
{
    DWORD       pid;
    HRESULT     ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    ret = D3D_OK;

    if (!this->locked) 
    {
        D3D_ERR("buffer not locked");
        return (D3DERR_EXECUTE_NOT_LOCKED);
    }

#ifdef XWIN_SUPPORT
    pid = getpid();
#else
    pid = GetCurrentProcessId();
#endif
    if (pid != this->pid) 
    {
        /* Unlocking process didn't lock it */
        D3D_ERR("Unlocking process didn't lock it");
        return (DDERR_INVALIDPARAMS);
    }

    if ((ret = D3DHAL_UnlockBuffer(this->lpDevI, this->hBuf)) != DD_OK)
    {
        D3D_ERR("Failed to unlock buffer");
        this->locked = 0;
        return ret;
    }

    this->locked = 0;

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::SetExecuteData"

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::SetExecuteData(LPD3DEXECUTEDATA lpData)
{
    HRESULT     ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DEXECUTEDATA_PTR(lpData)) {
            D3D_ERR( "Invalid D3DEXECUTEDATA pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    ret = D3D_OK;

    this->exData = *lpData;

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::GetExecuteData"

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::GetExecuteData(LPD3DEXECUTEDATA lpData)
{
    HRESULT     ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!lpData) {
            D3D_ERR( "Null D3DExecuteData pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    ret = D3D_OK;

    *lpData = this->exData;

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::Validate"

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::Validate(LPDWORD lpdwOffset,
                                                LPD3DVALIDATECALLBACK lpFunc,
                                                LPVOID lpUserArg,
                                                DWORD dwFlags)
{

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DWORD_PTR(lpdwOffset)) {
            D3D_ERR( "Invalid offset pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    return (DDERR_UNSUPPORTED);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DExecuteBuffer::Optimize"

HRESULT D3DAPI DIRECT3DEXECUTEBUFFERI::Optimize(DWORD dwFlags)
{

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DEXECUTEBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DExecuteBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (dwFlags) {
        D3D_ERR( "Flags are non-zero" );
        return DDERR_INVALIDPARAMS;
    }

    return (DDERR_UNSUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\d3diunk.cpp ===
/*==========================================================================;
*
*  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
*  File:    d3diunk.c
*  Content: Direct3D IUnknown
*@@BEGIN_MSINTERNAL
* 
*  $Id$
*
*  History:
*   Date    By  Reason
*   ====    ==  ======
*   07/12/95    stevela Merged Colin's changes.
*   27/08/96   stevela Ifdefed out the Close of gHEvent.  We're using
*                      DirectDraw's critical section.
*@@END_MSINTERNAL
*
***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * If we are built with aggregation enabled then we actually need two
 * different Direct3D QueryInterface, AddRef and Releases. One which
 * does the right thing on the Direct3D object and one which simply
 * punts to the owning interface.
 */

/*
 * CDirect3DUnk::QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::QueryInterface"

HRESULT D3DAPI CDirect3DUnk::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if( !VALID_OUTPTR( ppvObj ) )
        {
            D3D_ERR( "Invalid obj ptr" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    
    *ppvObj = NULL;

    D3D_INFO(3, "Direct3D IUnknown QueryInterface");
    
    if(IsEqualIID(riid, IID_IUnknown))
    {
        /*
         * Asking for IUnknown and we are IUnknown so just bump the
         * reference count and return this interface.
         * NOTE: Must AddRef through the interface being returned.
         */
        pD3DI->AddRef();
        // explicit ::CDirect3D disambiguation required since there are multiple IUnknown DIRECT3DI inherits from
        *ppvObj = static_cast<LPVOID>(static_cast<LPUNKNOWN>(static_cast<CDirect3D*>(pD3DI)));
    }
    else if (IsEqualIID(riid, IID_IDirect3D))
    {
        /*
         * Asking for legacy interface - add ref and return old interface
         */
        pD3DI->AddRef();
        // No disambiguation required. Only one IDirect3D base for DIRECT3DI
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3D>(pD3DI));
    }
    else if (IsEqualIID(riid, IID_IDirect3D2))
    {
        /*
         * Asking for (second) legacy interface - add ref and return old interface
         */
        pD3DI->AddRef();
        // No disambiguation required. Only one IDirect3D2 base for DIRECT3DI
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3D2>(pD3DI));
    }
    else if (IsEqualIID(riid, IID_IDirect3D3))
    {
        pD3DI->AddRef();
        // No disambiguation required. Only one IDirect3D3 base for DIRECT3DI
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3D3>(pD3DI));
    }
    else
    {
        /*
         * Don't understand this interface. Fail.
         * NOTE: Used to return DDERR_GENERIC. Now return
         * E_NOINTERFACE.
         */
        return (E_NOINTERFACE);
    }
    
    return (D3D_OK);
    
} /* CDirect3DUnk::QueryInterface */

/*
 * CDirect3DUnk::AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DUnk::AddRef"

ULONG D3DAPI CDirect3DUnk::AddRef()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    refCnt++;
    D3D_INFO(3, "Direct3D IUnknown AddRef: Reference count = %d", refCnt);
    return (refCnt);
    
} /* CDirect3DUnk::AddRef */

/*
 * CDirect3DUnk::Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DUnk::Release"

ULONG D3DAPI CDirect3DUnk::Release()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    refCnt--;
    D3D_INFO(3, "Direct3D IUnknown Release: Reference count = %d", refCnt);
    
    if( refCnt == 0 )
    {
        delete pD3DI; // Delete Parent object
        return 0;
    }
    return refCnt;
    
} /* D3DIUnknown_Release */

DIRECT3DI::~DIRECT3DI()
{
    D3D_INFO(3, "Release Direct3D Object");
    
    /*
     * free up all viewports created by this object
     */
    while (LIST_FIRST(&this->viewports)) {
        LPDIRECT3DVIEWPORTI lpViewI = LIST_FIRST(&this->viewports);
        lpViewI->Release();
    }
    
    /*
     * free up all lights created by this object
     */
    while (LIST_FIRST(&this->lights)) {
        LPDIRECT3DLIGHTI lpLightI = LIST_FIRST(&this->lights);
        lpLightI->Release();
    }
    
    /*
     * free up all devices created by this object
     */
    while (LIST_FIRST(&this->devices)) {
        LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&this->devices);
        lpDevI->Release();
    }
    
    /*
     * free up all materials left around
     */
    while (LIST_FIRST(&this->materials)) {
        LPDIRECT3DMATERIALI lpMatI = LIST_FIRST(&this->materials);
        lpMatI->Release();
    }
    
    delete lpTextureManager;
    /*
     * free up all allocated Buckets
     */
#if DBG
    /* this->lpFreeList must have all the buckets that are allocated */
    if (this->lpFreeList || this->lpBufferList)
    {
        int i,j;
        LPD3DBUCKET   temp;
        for (i=0,temp=this->lpFreeList;temp;i++) temp=temp->next;
        for (j=0,temp=this->lpBufferList;temp;j++) temp=temp->next;
        D3D_INFO(4,"D3D Release: recovered %d buckets in lpFreeList in %d buffers",i,j);
        DDASSERT(j*(D3DBUCKETBUFFERSIZE-1)==i);
    }
#endif  //DBG
    while (this->lpBufferList)
    {
        LPD3DBUCKET   temp=this->lpBufferList;
        this->lpBufferList=temp->next;
        D3DFree(temp->lpBuffer);
        D3D_INFO(4,"D3D Release:lpBufferList %d bytes freed",D3DBUCKETBUFFERSIZE*sizeof(D3DBUCKET));
    }
    this->lpFreeList=NULL;
}
    
/*
  * DIRECT3DI::QueryInterface
  */
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::QueryInterface"
  
HRESULT D3DAPI DIRECT3DI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if( !VALID_OUTPTR( ppvObj ) )
        {
            D3D_ERR( "Invalid obj ptr" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    
    *ppvObj = NULL;

    ret = this->lpOwningIUnknown->QueryInterface(riid, ppvObj);
    return ret;
}

/*
 * DIRECT3DI::AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::AddRef"

ULONG D3DAPI DIRECT3DI::AddRef()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * Punt to the owning interface.
     */
    return  this->lpOwningIUnknown->AddRef();
}

/*
 * DIRECT3DI::Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::Release"

ULONG D3DAPI DIRECT3DI::Release()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * Punt to the owning interface.
     */
    return  this->lpOwningIUnknown->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\d3dtex.cpp ===
/*==========================================================================;
*
*  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
*  File:    texture.c
*  Content: Direct3DTexture interface
*@@BEGIN_MSINTERNAL
*
*  $Id$
*
*  History:
*   Date    By  Reason
*   ====    ==  ======
*   07/12/95   stevela  Merged Colin's changes.
*   10/12/95    stevela Removed AGGREGATE_D3D
*   17/04/96   colinmc Bug 12185: Debug output too aggresive
*   30/04/96   stevela Bug 18898: Wrong error returned on invalid GetHandle
*@@END_MSINTERNAL
*
***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
* Create an api for the Direct3DTexture object
*/

#undef  DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture"

/*
*  Routines to associate textures with the D3DDevice.
*
*  Note that the texture block structures support both the Texture/Texture2
*  interface and the Texture3 interface (the block struct has
*  pointers to both and one of the pointers must be NULL).  This
*  means that the 'hook' call for each must null out the pointer
*  for the other, and the GetTextureHandle must not return a valid
*  handle for the 'other' texture interface (return NULL).
*
*  The D3DI_RemoveTextureBlock is the only call made to cleanup
*  when devices go away.  In this case, it is called for both
*  Texture(2) and Texture3, so it checks the pointers and calls
*  the Texture3 version if appropriate.
*/
LPD3DI_TEXTUREBLOCK hookTextureToDevice(LPDIRECT3DDEVICEI lpDevI,
    LPDIRECT3DTEXTUREI lpD3DText)
{

    LPD3DI_TEXTUREBLOCK nBlock;

    if (D3DMalloc((void**)&nBlock, sizeof(D3DI_TEXTUREBLOCK)) != D3D_OK)
    {
        D3D_ERR("failed to allocate space for texture block");
        return NULL;
    }
    nBlock->lpDevI = lpDevI;
    nBlock->lpD3DTextureI = lpD3DText;
    nBlock->hTex = 0;              // initialized to be zero

    LIST_INSERT_ROOT(&lpD3DText->blocks, nBlock, list);
    LIST_INSERT_ROOT(&lpDevI->texBlocks, nBlock, devList);

    return nBlock;
}

void D3DI_RemoveTextureHandle(LPD3DI_TEXTUREBLOCK lpBlock)
{
    /*  check if this block refers to a Texture/Texture2 - this
     *   needs to handle both texture types for device cleanup
     */
    if (lpBlock->hTex)
    {
        //  block refers to a Texture/Texture2
        LPD3DI_MATERIALBLOCK mat;

        // Remove the texture from any materials which reference it.
        for (mat = LIST_FIRST(&lpBlock->lpDevI->matBlocks);
             mat; mat = LIST_NEXT(mat,devList)) {
            if (mat->lpD3DMaterialI->dmMaterial.hTexture == lpBlock->hTex) {
                D3DMATERIAL m = mat->lpD3DMaterialI->dmMaterial;
                LPDIRECT3DMATERIAL lpMat =
                    (LPDIRECT3DMATERIAL) mat->lpD3DMaterialI;
                m.hTexture = 0L;
                lpMat->SetMaterial(&m);
            }
        }
        D3DHAL_TextureDestroy(lpBlock);
    }
}

LPD3DI_TEXTUREBLOCK D3DI_FindTextureBlock(LPDIRECT3DTEXTUREI lpTex,
                                          LPDIRECT3DDEVICEI lpDev)
{
    LPD3DI_TEXTUREBLOCK tBlock;

    tBlock = LIST_FIRST(&lpTex->blocks);
    while (tBlock) {
        //  return match for Texture(2) only (not Texture3)
        if (tBlock->lpDevI == lpDev) {
            return tBlock;
        }
        tBlock = LIST_NEXT(tBlock,list);
    }
    return NULL;
}

HRESULT D3DAPI DIRECT3DTEXTUREI::Initialize(LPDIRECT3DDEVICE lpD3D, LPDIRECTDRAWSURFACE lpDDS)
{
    return DDERR_ALREADYINITIALIZED;
}

/*
* Create a texture.
*
* NOTE: Radical modifications to support the aggregatable texture
* interface (so textures can be queried off DirectDraw surfaces):
*
* 1) This call is no longer a member of the Direct3D device interface.
*    It is now an API function exported from the Direct3D DLL. Its
*    a hidden API function - only DirectDraw will ever invoke it.
*
* 2) This call no longer establishes the realtionship between a
*    texture and a device. That is performed by the GetHandle()
*    member of the Direct3DTexture interface.
*
* 3) This call is, in effect, the class factory for Direct3DTexture
*    objects. This function will be invoked to create the aggregated
*    texture object hanging off the DirectDraw surface.
*
* NOTE: So the Direct3DTexture knows which DirectDraw surface is
* supplying its bits this function is passed an interface pointer
* for that DirectDraw surface. I suspect this blows a nice big
* hole in the COM model as the DirectDraw surface is also the
* owning interface of the texture and I don't think aggregated
* objects should know about thier owning interfaces. However, to
* make this thing work this is what we have to do.
*
* EXTRA BIG NOTE: Because of the above don't take a reference to
* the DirectDraw surface passed in. If you do you will get a circular
* reference and the bloody thing will never die. When aggregated
* the texture interface's lifetime is entirely defined by the
* lifetime of its owning interface (the DirectDraw surface) so the
* DirectDraw surface can never go away before the texture.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DCreateTexture"
HRESULT D3DAPI Direct3DCreateTexture(REFIID              riid,
                                     LPDIRECTDRAWSURFACE lpDDS,
                                     LPUNKNOWN*          lplpD3DText,
                                     IUnknown*           pUnkOuter)
{
    LPDDRAWI_DDRAWSURFACE_LCL lpLcl;
    LPDDPIXELFORMAT lpPF;
    LPDIRECT3DTEXTUREI lpText;
    LPDIRECTDRAWPALETTE lpDDPal;
    HRESULT ddrval;
    DWORD   dwFlags;
    *lplpD3DText = NULL;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /* No need to validate params as they are passed to us by DirectDraw */

    if ((!IsEqualIID(riid, IID_IDirect3DTexture)) &&
        (!IsEqualIID(riid, IID_IDirect3DTexture2))) {
        /*
         * Not an error worth reporting by debug messages as this is
         * almost certainly just DirectDraw probing us with an
         * unknown IID.
         */
        return (E_NOINTERFACE);
    }

    lpText =  static_cast<LPDIRECT3DTEXTUREI>(new DIRECT3DTEXTUREI(pUnkOuter));

    if (!lpText) {
        D3D_ERR("failed to allocate space for texture object");
        return (DDERR_OUTOFMEMORY);
    }

    // QI lpDDS for lpDDS4 interface
    ddrval = lpDDS->QueryInterface(IID_IDirectDrawSurface4, (LPVOID*)&lpText->lpDDS);

    if(FAILED(ddrval))
    {
        D3D_ERR("QI for IID_IDirectDrawSurface4 failed");
        delete lpText;
        return ddrval;
    }

    memcpy(&lpText->DDSInt4,lpText->lpDDS,sizeof(DDRAWI_DDRAWSURFACE_INT));
    lpText->lpDDS->Release();

    lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl;
    if (DDSCAPS2_TEXTUREMANAGE & lpLcl->lpSurfMore->ddsCapsEx.dwCaps2)
    {
        lpText->lpDDSSys=(LPDIRECTDRAWSURFACE4)&lpText->DDSInt4;
        lpText->lpDDSSys1Tex=lpDDS; //save it for create texture handle to driver
        lpText->lpDDS=NULL;
        lpText->lpDDS1Tex=NULL;

        // Next, we need to loop thru and set pointers to the dirty
        // bit in the DDraw surfaces
        DDSCAPS2 ddscaps;
        LPDIRECTDRAWSURFACE4 lpDDSTmp, lpDDS = lpText->lpDDSSys;
        do
        {
            ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpSurfMore->lpbDirty = &(lpText->bDirty);
            memset(&ddscaps, 0, sizeof(ddscaps));
            ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
            ddrval = lpDDS->GetAttachedSurface(&ddscaps, &lpDDSTmp);
            if(lpDDS != lpText->lpDDSSys)
                lpDDS->Release();
            lpDDS = lpDDSTmp;
            if(ddrval != DD_OK && ddrval != DDERR_NOTFOUND)
            {
                D3D_ERR("GetAttachedSurface for obtaining mipmaps failed");
                delete lpText;
                return ddrval;
            }
        }
        while(ddrval == DD_OK);
    }
    else
    {
        lpText->lpDDSSys=NULL;
        lpText->lpDDSSys1Tex=NULL;
        lpText->lpDDS=(LPDIRECTDRAWSURFACE4)&lpText->DDSInt4;
        lpText->lpDDS1Tex=lpDDS;    //save it for create texture handle to driver
    }
    lpText->lpTMBucket=NULL;
    lpText->LogTexSize=0;
    lpText->bDirty = TRUE;

    /*
     * Are we palettized?
     */

    if (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
        lpPF = &lpLcl->lpGbl->ddpfSurface;
    else
        lpPF = &lpLcl->lpGbl->lpDD->vmiData.ddpfDisplay;

    if ( (lpPF->dwFlags & DDPF_PALETTEINDEXED1) ||
         (lpPF->dwFlags & DDPF_PALETTEINDEXED2) ||
         (lpPF->dwFlags & DDPF_PALETTEINDEXED4) ||
         (lpPF->dwFlags & DDPF_PALETTEINDEXED8) )
    {
        ddrval = lpDDS->GetPalette(&lpDDPal);
        if (ddrval != DD_OK) {
            if (ddrval != DDERR_NOPALETTEATTACHED) {
                delete lpText;
                D3D_ERR("No palette in a palettized texture");
                return ddrval;
            }
            D3D_INFO(3, "Texture is not palettized");
            lpText->bIsPalettized = false;
        } else {
            lpText->bIsPalettized = true;
            lpDDPal->Release();
            D3D_INFO(3, "Texture is palettized");
        }
    }

    /*
     * Note, we return the IUnknown rather than the texture
     * interface. So if you want to do anything real with
     * this baby you must query for the texture interface.
     */
    *lplpD3DText = static_cast<LPUNKNOWN>(&(lpText->mTexUnk));

    return (D3D_OK);
}

DIRECT3DTEXTUREI::DIRECT3DTEXTUREI(LPUNKNOWN pUnkOuter)
{
    /*
     * setup the object
     *
     * NOTE: Device and handle established when GetHandle() is called
     */
    mTexUnk.refCnt = 1;
    LIST_INITIALIZE(&blocks);
    mTexUnk.pTexI=this;

    /*
    * Are we really being aggregated?
    */
    if (pUnkOuter != NULL)
    {
        /*
         * Yup - we are being aggregated. Store the supplied
         * IUnknown so we can punt to that.
         * NOTE: We explicitly DO NOT AddRef here.
         */
        lpOwningIUnknown = pUnkOuter;
    }
    else
    {
        /*
         * Nope - but we pretend we are anyway by storing our
         * own IUnknown as the parent IUnknown. This makes the
         * code much neater.
        */
        lpOwningIUnknown = static_cast<LPUNKNOWN>(&(this->mTexUnk));
    }

    // Not currently in use
    bInUse = FALSE;
}

/*
* GetHandle
*
* NOTE: Now establishes relationship betwewn texture and device
* (which used to be done by CreateTexture) and generates the
* texture handle.
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::GetHandle"

HRESULT D3DAPI DIRECT3DTEXTUREI::GetHandle(LPDIRECT3DDEVICE   lpD3DDevice,
                                           LPD3DTEXTUREHANDLE lphTex)
{
    LPDIRECT3DDEVICEI   lpDev;
    LPD3DI_TEXTUREBLOCK lptBlock;
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DDEVICE_PTR(lpD3DDevice)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DTEXTUREHANDLE_PTR(lphTex)) {
            D3D_ERR( "Invalid D3DTEXTUREHANDLE pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (lpDDSSys)
    {
        D3D_ERR( "Handle is not available since the texture is managed" );
        return  DDERR_INVALIDOBJECT;    //managed texture has no handle
    }
    lpDev = static_cast<LPDIRECT3DDEVICEI>(lpD3DDevice);
    lptBlock = D3DI_FindTextureBlock(this, lpDev);
    *lphTex=0;

    if (NULL == lptBlock) {
    /*
     * NOTE: We used to do this in CreateTexture. Perhaps the service
     * name should be changed (as the texture is now already created
     * when this function is invoked).
     *
     * Indicate to driver that source is a DirectDraw surface, so it
     * can Lock() when required.
     */
        lptBlock = hookTextureToDevice(lpDev, this);
        if ( NULL == lptBlock) {
            D3D_ERR("failed to associate texture with device");
            return DDERR_OUTOFMEMORY;
        }
    }
    if (!lptBlock->hTex)
    {
        HRESULT ret;
        ret = D3DHAL_TextureCreate(lpDev, &lptBlock->hTex, lpDDS1Tex);
        if (ret != D3D_OK)
        {
            return  ret;
        }
        D3D_INFO(6,"lpTexI=%08lx lptBlock=%08lx hTex=%08lx",this,lptBlock,lptBlock->hTex);
    }
    *lphTex=lptBlock->hTex;
    DDASSERT(lptBlock->hTex);
    return D3D_OK;
}

HRESULT D3DAPI DIRECT3DTEXTUREI::GetHandle(LPDIRECT3DDEVICE2   lpD3DDevice,
                                           LPD3DTEXTUREHANDLE lphTex)
{
    LPDIRECT3DDEVICEI   lpDev;
    LPD3DI_TEXTUREBLOCK lptBlock;
    HRESULT ret;
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture2 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DDEVICE2_PTR(lpD3DDevice)) {
            D3D_ERR( "Invalid Direct3DDevice2 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DTEXTUREHANDLE_PTR(lphTex)) {
            D3D_ERR( "Invalid D3DTEXTUREHANDLE pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (lpDDSSys)
    {
        D3D_ERR( "Handle is not available since texture is managed" );
        return  DDERR_INVALIDOBJECT;    //managed texture has no handle
    }

    lpDev = static_cast<LPDIRECT3DDEVICEI>(lpD3DDevice);

    lptBlock = D3DI_FindTextureBlock(this, lpDev);
    /*
     * Do cap verification if we've not used this device before.
     */

    *lphTex=0;
    if (NULL == lptBlock) {
        ret=VerifyTextureCaps(lpDev, (LPDDRAWI_DDRAWSURFACE_INT)lpDDS);
        if (ret != D3D_OK)
        {
            return  ret;
        }

        /*
         * Put this device in the list of those owned by the
         * Direct3DDevice object
         */
        lptBlock = hookTextureToDevice(lpDev, this);
        if ( NULL == lptBlock) {
            D3D_ERR("failed to associate texture with device");
            return DDERR_OUTOFMEMORY;
        }
    }
    if (!lptBlock->hTex)
    {
        ret = D3DHAL_TextureCreate(lpDev, &lptBlock->hTex, lpDDS1Tex);
        if (ret != D3D_OK)
        {
            return  ret;
        }
        D3D_INFO(6,"lpTexI=%08lx lptBlock=%08lx hTex=%08lx",this,lptBlock,lptBlock->hTex);
    }
    *lphTex=lptBlock->hTex;
    DDASSERT(lptBlock->hTex);
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetTextureDDIHandle"

HRESULT
GetTextureDDIHandle(LPDIRECT3DTEXTUREI lpTexI,
                     LPDIRECT3DDEVICEI lpDevI,
                     LPD3DI_TEXTUREBLOCK* lplpBlock)
{
#ifdef __DD_OPT_SURFACE
    LPDDRAWI_DDRAWSURFACE_LCL pSurf_lcl = NULL;
#endif //__DD_OPT_SURFACE
    HRESULT ret;
    LPD3DI_TEXTUREBLOCK lpBlock=*lplpBlock; //in case has the pointer

#ifdef __DD_OPT_SURFACE
    // If the surface is Empty, return 0 handle
    if (lpTexI->lpDDS)
    {
        pSurf_lcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpTexI->lpDDS)->lpLcl;
    }
    else
    {
        pSurf_lcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpTexI->lpDDSSys)->lpLcl;
    }

    DDASSERT (pSurf_lcl);

    if (pSurf_lcl->dwFlags & DDRAWISURF_EMPTYSURFACE)
    {
        D3D_WARN(1, "Cannot get DDI handle to an empty surface, call load first");
        return  D3DERR_OPTTEX_CANNOTCOPY;
    }
#endif //__DD_OPT_SURFACE
    DDASSERT(lpTexI && lpDevI);
    /*
     * Find out if we've used this device before.
     */
    if (!lpBlock)
    {
        lpBlock = D3DI_FindTextureBlock(lpTexI, lpDevI);
        if (!lpBlock)
        {
            /*
             * Put this device in the list of those owned by the
             * Direct3DDevice object
             */
            lpBlock=hookTextureToDevice(lpDevI, lpTexI);
            if (!lpBlock)
            {
                D3D_ERR("failed to associate texture with device");
                return DDERR_OUTOFMEMORY;
            }
        }
        *lplpBlock = lpBlock;
    }
    if (!lpBlock->hTex)
    {
        LPDIRECTDRAWSURFACE lpDDS1Temp;
        if (!lpTexI->lpDDS)
        {
          if (lpDevI->dwFEFlags &  D3DFE_REALHAL)
          {
            // We need to make sure that we don't evict any mapped textures
            DWORD dwStage;
            for (dwStage=0;dwStage < lpDevI->dwMaxTextureBlendStages; dwStage++)
                if(lpDevI->lpD3DMappedTexI[dwStage])
                    lpDevI->lpD3DMappedTexI[dwStage]->bInUse = TRUE;

            ret=lpDevI->lpDirect3DI->lpTextureManager->allocNode(lpBlock);

            for (dwStage=0;dwStage < lpDevI->dwMaxTextureBlendStages; dwStage++)
                if(lpDevI->lpD3DMappedTexI[dwStage])
                    lpDevI->lpD3DMappedTexI[dwStage]->bInUse = FALSE;

            if (D3D_OK != ret)
            {
                D3D_ERR("Failed to create video memory surface");
                return ret;
            }
            if (!(lpDevI->lpD3DHALGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR))
                lpDevI->lpDirect3DI->lpTextureManager->TimeStamp(lpTexI->lpTMBucket);

            if (lpBlock->hTex)  return  D3D_OK; //this means Texmanager reused a texture handle

            // QI lpDDS4 for lpDDS interface
            if (DD_OK != (ret=lpTexI->lpDDS->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpDDS1Temp)))
            {
                D3D_ERR("QI IID_IDirectDrawSurface failed");
                lpTexI->lpTMBucket->lpD3DTexI=NULL; //clean up
                lpTexI->lpTMBucket=NULL;
                lpTexI->lpDDS->Release();
                lpTexI->lpDDS=NULL;
                return ret;
            }
            lpTexI->lpDDS1Tex = lpDDS1Temp;
          }
          else
          {
            lpDDS1Temp = lpTexI->lpDDSSys1Tex;
          }
        }
        else
            lpDDS1Temp = lpTexI->lpDDS1Tex;
        DDASSERT(NULL != lpDDS1Temp);
        {
            CLockD3DST lockObject(lpDevI, DPF_MODNAME, REMIND(""));
            if (D3D_OK != (ret=D3DHAL_TextureCreate(lpDevI, &lpBlock->hTex, lpDDS1Temp)))
                return ret;
        }
    }
    else
        if (lpTexI->lpTMBucket && !(lpDevI->lpD3DHALGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR))
            lpDevI->lpDirect3DI->lpTextureManager->TimeStamp(lpTexI->lpTMBucket);

    DDASSERT(lpBlock->hTex);
    return D3D_OK;
}

/*
* Load
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::Load"

#define HEL_BLT_ALPAHPIXELS_BROKEN

HRESULT D3DAPI DIRECT3DTEXTUREI::Load(LPDIRECT3DTEXTURE lpD3DSrc)
{
    LPDIRECT3DTEXTUREI  this_src;
    HRESULT ddrval;
    LPDIRECTDRAWSURFACE4 lpDDSSrc, lpDDSDst;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DTEXTURE_PTR(lpD3DSrc)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    this_src  = static_cast<LPDIRECT3DTEXTUREI>(lpD3DSrc);
    lpDDSSrc = this_src->lpDDSSys;
    if (!lpDDSSrc)
        lpDDSSrc = this_src->lpDDS;

    lpDDSDst = lpDDSSys;
    if (!lpDDSDst)
        lpDDSDst = lpDDS;
    ddrval = CopySurface(lpDDSDst, lpDDSSrc, NULL);
    return ddrval;
}

HRESULT D3DAPI DIRECT3DTEXTUREI::Load(LPDIRECT3DTEXTURE2 lpD3DSrc)
{
    LPDIRECT3DTEXTUREI  this_src;
    HRESULT     ddrval;
    LPDIRECTDRAWSURFACE4 lpDDSSrc, lpDDSDst;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        this_src = static_cast<LPDIRECT3DTEXTUREI>(lpD3DSrc);
        if (!VALID_DIRECT3DTEXTURE2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DTEXTURE2_PTR(this_src)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    lpDDSSrc = this_src->lpDDSSys;
    if (!lpDDSSrc)
        lpDDSSrc = this_src->lpDDS;

    lpDDSDst = lpDDSSys;
    if (!lpDDSDst)
        lpDDSDst = lpDDS;
    ddrval = CopySurface(lpDDSDst, lpDDSSrc, NULL);
    return ddrval;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CopySurface"

HRESULT CopySurface(LPDIRECTDRAWSURFACE4 lpDDSDst,
                    LPDIRECTDRAWSURFACE4 lpDDSSrc,
                    LPDIRECTDRAWCLIPPER  lpClipper)
{
    DDSURFACEDESC2   ddsd;
#ifdef __DD_OPT_SURFACE
    DDSURFACEDESC2   ddsdSrc;
    BOOL bDstIsOptimized, bSrcIsOptimized;
    LPDIRECTDRAWOPTSURFACE pOptSurfSrc = NULL;
    LPDIRECTDRAWOPTSURFACE pOptSurfDst = NULL;
#endif //__DD_OPT_SURFACE
    HRESULT     ddrval=DD_OK;
    PALETTEENTRY    ppe[256];
    LPDIRECTDRAWPALETTE lpDDPalSrc, lpDDPalDst;
    int psize;
    DDCOLORKEY ckey;

    if (!lpDDSSrc || !lpDDSDst) return  DD_OK;
    memset(&ddsd, 0, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddrval = lpDDSDst->GetSurfaceDesc(&ddsd);

#ifdef __DD_OPT_SURFACE
    memset(&ddsdSrc, 0, sizeof(ddsdSrc));
    ddsdSrc.dwSize = sizeof(ddsdSrc);
    ddrval = lpDDSSrc->GetSurfaceDesc(&ddsdSrc);

    if (bDstIsOptimized = (ddsd.ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
    {
        // Fetch the OptSurface Interface
        ddrval = lpDDSDst->QueryInterface (IID_IDirectDrawOptSurface,
                                           (LPVOID *)&pOptSurfDst);
        if (ddrval != DD_OK)
        {
            D3D_ERR( "QI failed for Opt Surfaces" );
            goto exit_copy_surf;
        }
    }

    if (bSrcIsOptimized = (ddsdSrc.ddsCaps.dwCaps & DDSCAPS_OPTIMIZED))
    {
        // Fetch the OptSurface Interface
        ddrval = lpDDSDst->QueryInterface (IID_IDirectDrawOptSurface,
                                           (LPVOID *)&pOptSurfSrc);
        if (ddrval != DD_OK)
        {
            D3D_ERR( "QI failed for Opt Surfaces" );
            goto exit_copy_surf;
        }
    }


    // Cases:
    //        Dst=Opt   Src=Opt  : Copy the surface
    //        Dst=Opt   Src=UnOpt: Optimize the surface
    //        Dst=UnOpt Src=Opt  : UnOptimize and load
    //        Dst=UnOpt Src=UnOpt: Normal operation
    //
    if (bDstIsOptimized && bSrcIsOptimized)
    {
        // Copy the surface
        ddrval = pOptSurfSrc->CopyOptimizedSurf (pOptSurfSrc);
        if (ddrval != DD_OK)
        {
            D3D_ERR ("CopyOptimizedSurf failed");
        }
        goto exit_copy_surf;
    }
    else if (bDstIsOptimized && !bSrcIsOptimized)
    {
        LPDIRECTDRAWSURFACE4 pDDS4 = NULL;

        // Optimize the surface
        ddrval = lpDDSDst->QueryInterface (IID_IDirectDrawSurface4,
                                           (LPVOID *)&pOptSurfSrc);
        if (ddrval != DD_OK)
        {
            D3D_ERR( "QI failed for IID_IDirectDrawSurface4" );
            goto exit_copy_surf;
        }

        ddrval = pOptSurfSrc->LoadUnoptimizedSurf (pDDS4);
        if (ddrval != DD_OK)
        {
            D3D_ERR ("CopyOptimizedSurf failed");
        }
        pDDS4->Release();
        goto exit_copy_surf;
    }
    else if (!bDstIsOptimized && bSrcIsOptimized)
    {
        LPDIRECTDRAWOPTSURFACE pDDS4 = NULL;

        // ATTENTION: Unoptimize the surface ??
        D3D_ERR ("CopyOptimizedSurf failed");
        ddrval = D3DERR_OPTTEX_CANNOTCOPY;
        goto exit_copy_surf;
    }
#endif //__DD_OPT_SURFACE

    if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8) {
        psize = 256;
    } else if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED4) {
        psize = 16;
    } else {
        psize = 0;
    }

    if (psize) {
        ddrval = lpDDSSrc->GetPalette(&lpDDPalSrc);
        if (ddrval != DD_OK) {
            if (ddrval != DDERR_NOPALETTEATTACHED) {
                D3D_ERR("Failed to get palette");
                return ddrval;
            }
        } else {
            ddrval = lpDDPalSrc->GetEntries(0, 0, psize, ppe);
            if (ddrval != DD_OK) {
                D3D_ERR("Failed to get palette entries");
                lpDDPalSrc->Release();
                return ddrval;
            }
            lpDDPalSrc->Release();
            ddrval = lpDDSDst->GetPalette(&lpDDPalDst);
            if (ddrval != DD_OK) {
                D3D_ERR("Failed to get palette");
                return ddrval;
            }
            ddrval = lpDDPalDst->SetEntries(0, 0, psize, ppe);
            if (ddrval != DD_OK) {
                D3D_ERR("Failed to set palette entries");
                lpDDPalDst->Release();
                return ddrval;
            }
            lpDDPalDst->Release();
        }
    }

    lpDDSSrc->AddRef();
    lpDDSDst->AddRef();
    do {
        DDSCAPS2 ddscaps;
        LPDIRECTDRAWSURFACE4 lpDDSTmp;

        LPREGIONLIST lpRegionList = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSrc)->lpLcl->lpSurfMore->lpRegionList;
        if(lpClipper)
        {
            if(lpRegionList)
            {
                if(lpRegionList->rdh.nCount &&
                    lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                {
                    if(lpClipper->SetClipList((LPRGNDATA)lpRegionList, 0) != DD_OK)
                    {
                        D3D_ERR("Failed to set clip list");
                    }
                    if(lpDDSDst->SetClipper(lpClipper) != DD_OK)
                    {
                        D3D_ERR("Failed to detach the clipper");
                    }
                }
            }
        }

        ddrval = lpDDSDst->Blt(NULL, lpDDSSrc,
                               NULL, DDBLT_WAIT, NULL);

        if(lpClipper)
        {
            if(lpRegionList)
            {
                if(lpRegionList->rdh.nCount)
                {
                    if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                    {
                        if(lpDDSDst->SetClipper(NULL) != DD_OK)
                        {
                            D3D_ERR("Failed to detach the clipper");
                        }
                    }
                    lpRegionList->rdh.nCount = 0;
                    lpRegionList->rdh.nRgnSize = 0;
                    lpRegionList->rdh.rcBound.left = LONG_MAX;
                    lpRegionList->rdh.rcBound.right = 0;
                    lpRegionList->rdh.rcBound.top = LONG_MAX;
                    lpRegionList->rdh.rcBound.bottom = 0;
                }
            }
        }

        if (ddrval == E_NOTIMPL && (psize == 16 || psize == 4 || psize == 2) ) {
            DDSURFACEDESC2 ddsd_s, ddsd_d;
            LPBYTE psrc, pdst;
            DWORD i;
            DWORD dwBytesPerLine;

            memset(&ddsd_s, 0, sizeof ddsd_s);
            memset(&ddsd_d, 0, sizeof ddsd_d);
            ddsd_s.dwSize = ddsd_d.dwSize = sizeof(ddsd_s);

            if ((ddrval = lpDDSSrc->Lock(NULL, &ddsd_s, DDLOCK_WAIT, NULL)) != DD_OK) {
                lpDDSSrc->Release();
                lpDDSDst->Release();
                D3D_ERR("Failed to lock src surface");
                return ddrval;
            }
            if ((ddrval = lpDDSDst->Lock(NULL, &ddsd_d, DDLOCK_WAIT, NULL)) != DD_OK) {
                lpDDSSrc->Unlock(NULL);
                lpDDSSrc->Release();
                lpDDSDst->Release();
                D3D_ERR("Failed to lock dst surface");
                return ddrval;
            }

            switch (psize)
            {
            case 16: dwBytesPerLine = (ddsd.dwWidth + 1) / 2; break;
            case 4: dwBytesPerLine = (ddsd.dwWidth + 3) / 4; break;
            case 2: dwBytesPerLine = (ddsd.dwWidth + 7) / 8; break;
            }

            psrc = (LPBYTE)ddsd_s.lpSurface;
            pdst = (LPBYTE)ddsd_d.lpSurface;
            for (i = 0; i < ddsd_s.dwHeight; i++) {
                memcpy( pdst, psrc, dwBytesPerLine );
                psrc += ddsd_s.lPitch;
                pdst += ddsd_d.lPitch;
            }

            lpDDSSrc->Unlock(NULL);
            lpDDSDst->Unlock(NULL);
            lpDDSSrc->Release();    //Offset the AddRefs before
            lpDDSDst->Release();

            return D3D_OK;

        }
        else if (ddrval != DD_OK)
        {
            lpDDSSrc->Release();    //Offset the AddRefs before
            lpDDSDst->Release();
            D3D_ERR("Blt failure");
            return ddrval;
        }
        /* Copy color keys */
        ddrval = lpDDSSrc->GetColorKey(DDCKEY_DESTBLT, &ckey);
        if (DD_OK == ddrval)
            lpDDSDst->SetColorKey(DDCKEY_DESTBLT, &ckey);
        ddrval = lpDDSSrc->GetColorKey(DDCKEY_SRCBLT, &ckey);
        if (DD_OK == ddrval)
            lpDDSDst->SetColorKey(DDCKEY_SRCBLT, &ckey);

        memset(&ddscaps, 0, sizeof(ddscaps));
        ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
        ddrval = lpDDSSrc->GetAttachedSurface(&ddscaps, &lpDDSTmp);
        lpDDSSrc->Release();
        lpDDSSrc = lpDDSTmp;
        if (ddrval == DDERR_NOTFOUND) {
            // no more surfaces in the chain
            lpDDSDst->Release();
            break;
        } else if (ddrval != DD_OK) {
            lpDDSDst->Release();
            D3D_ERR("GetAttachedSurface failed with something other than DDERR_NOTFOUND.");
            return ddrval;
        }
        memset(&ddscaps, 0, sizeof(ddscaps));
        ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
        ddrval = lpDDSDst->GetAttachedSurface(&ddscaps, &lpDDSTmp);
        lpDDSDst->Release();
        lpDDSDst = lpDDSTmp;
        if (ddrval == DDERR_NOTFOUND) {
            lpDDSSrc->Release();
            D3D_ERR("Destination texture has fewer attached mipmap surfaces than source.");
            return ddrval;
        } else if (ddrval != DD_OK) {
            lpDDSSrc->Release();
            D3D_ERR("GetAttachedSurface failed with something other than DDERR_NOTFOUND.");
            return ddrval;
        }
    } while (1);

    return D3D_OK;

#ifdef __DD_OPT_SURFACE
exit_copy_surf:
    // Job done, release any optimized surface interfaces
    if (pOptSurfSrc)
    {
        pOptSurfSrc->Release();
        pOptSurfSrc = NULL;
    }
    if (pOptSurfDst)
    {
        pOptSurfDst->Release();
        pOptSurfDst = NULL;
    }
    return  ddrval;
#endif //__DD_OPT_SURFACE
}

/*
* Unload
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::Unload"

HRESULT D3DAPI DIRECT3DTEXTUREI::Unload()
{
    HRESULT     ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    return (ret);
}

/*
* PaletteChanged
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::PaletteChanged"

HRESULT D3DAPI DIRECT3DTEXTUREI::PaletteChanged(DWORD dwStart, DWORD dwCount)
{
    HRESULT     ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    // if haven't mapped to a device yet, can ignore this call, since will
    // be creating the ramp palette from scratch anyway.
    LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&this->blocks);
    while (tBlock) {
        if (tBlock->hTex)
        {
            if(tBlock->lpDevI->pfnRampService!=NULL)
            {
                ret = CallRampService(tBlock->lpDevI, RAMP_SERVICE_PALETTE_CHANGED,tBlock->hTex,0);
            }
        }
        tBlock=LIST_NEXT(tBlock,list);
    }

    return (ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\deviunk.cpp ===
/*==========================================================================;
*
*  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
*  File:    deviunk.c
*  Content: Direct3DDevice IUnknown
*@@BEGIN_MSINTERNAL
* 
*  $Id$
*
*  History:
*   Date    By  Reason
*   ====    ==  ======
*   07/12/95    stevela Merged Colin's changes.
*   10/12/95    stevela Removed AGGREGATE_D3D.
*@@END_MSINTERNAL
*
***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
* If we are built with aggregation enabled then we actually need two
* different Direct3D QueryInterface, AddRef and Releases. One which
* does the right thing on the Direct3DTexture object and one which
* simply punts to the owning interface.
*/

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice"

/*
* D3DDevIUnknown_QueryInterface
*/
HRESULT D3DAPI CDirect3DDeviceUnk::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_OUTPTR(ppvObj)) {
            D3D_ERR( "Invalid pointer to object pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    
    D3D_INFO(3, "Direct3DDevice IUnknown QueryInterface");
    
    *ppvObj = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
    {
        /*
         * Asking for IUnknown and we are IUnknown.
         * NOTE: Must AddRef through the interface being returned.
         */
        pDevI->AddRef();
        *ppvObj = static_cast<LPVOID>(this);
    }
    else if (IS_DX5_COMPATIBLE_DEVICE(pDevI))
    { /* Non aggregated device, possible IIDs: Device, Device2, Device3 */
        if (IsEqualIID(riid, IID_IDirect3DDevice))
        {
            pDevI->AddRef();
            *ppvObj = static_cast<LPVOID>(static_cast<IDirect3DDevice*>(pDevI));
            pDevI->guid = IID_IDirect3DDevice;
        }
        else if (IsEqualIID(riid, IID_IDirect3DDevice2))
        {
            pDevI->AddRef();
            *ppvObj = static_cast<LPVOID>(static_cast<IDirect3DDevice2*>(pDevI));
            pDevI->guid = IID_IDirect3DDevice2;
        }
        else if (IsEqualIID(riid, IID_IDirect3DDevice3))
        {
            if(pDevI->dwVersion<3) {
                D3D_ERR("Cannot QueryInterface for Device3 from device created as Device2");
                return E_NOINTERFACE;
            }

            pDevI->AddRef();
            *ppvObj = static_cast<LPVOID>(static_cast<IDirect3DDevice3*>(pDevI));
            pDevI->guid = IID_IDirect3DDevice3;
        }
        else
        {
            D3D_ERR("unknown interface");
            return (E_NOINTERFACE);
        }
    }
    else if (IsEqualIID(riid, pDevI->guid))
    { /* DDraw Aggregated device, possible IIDs: RampDevice, RGBDevice, HALDevice */
        pDevI->AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<CDirect3DDevice*>(pDevI));
    }
    else
    {
        D3D_ERR("unknown interface");
        return (E_NOINTERFACE);
    }
    
    return (D3D_OK);
    
} /* D3DDevIUnknown_QueryInterface */

/*
  * D3DDevIUnknown_AddRef
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::AddRef"

ULONG D3DAPI CDirect3DDeviceUnk::AddRef()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    this->refCnt++;
    D3D_INFO(3, "Direct3DDevice IUnknown AddRef: Reference count = %d", this->refCnt);
    
    return (this->refCnt);
    
} /* D3DDevIUnknown_AddRef */

/*
  * D3DDevIUnknown_Release
  *
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::Release"

ULONG D3DAPI CDirect3DDeviceUnk::Release()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    
    D3D_INFO(3, "Direct3DDevice IUnknown Release: Reference count = %d", this->refCnt);
    
    if( this->refCnt == 0 )
    {
        delete pDevI; // Delete Parent object
        return 0;
    }
    return this->refCnt;
    
} /* D3DDevIUnknown_Release */

/*
  * D3DDev_QueryInterface
  */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::QueryInterface"
  
HRESULT D3DAPI DIRECT3DDEVICEI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     ,    */
    TRY
    {
        if( !VALID_OUTPTR( ppvObj ) )
        {
            D3D_ERR("Invalid obj ptr" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
     
    *ppvObj = NULL;
      
    /*
     * Punt to the owning interface.
     */
    ret = this->lpOwningIUnknown->QueryInterface(riid, ppvObj);
      
    return ret;
} /* D3DDev_QueryInterface */
/*
    * D3DDev_AddRef
  */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::AddRef"
  
ULONG D3DAPI DIRECT3DDEVICEI::AddRef()
{
    ULONG ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * Punt to owning interface.
     */
    ret = this->lpOwningIUnknown->AddRef();
      
    return ret;
} /* D3DDev_AddRef */

/*
 * D3DDev_Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::Release"
  
ULONG D3DAPI DIRECT3DDEVICEI::Release()
{
    ULONG ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * Punt to owning interface.
     */
    ret = this->lpOwningIUnknown->Release();
    
    return ret;
} /* D3DDev_Release */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\d3dmem.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dmem.c
 *  Content:    Direct3D mem allocation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

static D3DMALLOCFUNCTION malloc_function = (D3DMALLOCFUNCTION) MemAlloc;
static D3DREALLOCFUNCTION realloc_function = (D3DREALLOCFUNCTION) MemReAlloc;
static D3DFREEFUNCTION free_function = MemFree;

#undef DPF_MODNAME
#define DPF_MODNAME "D3DMalloc"

HRESULT D3DAPI D3DMalloc(LPVOID* p_return, size_t size)
{
    void* p;

    if (!VALID_OUTPTR(p_return)) {
        D3D_ERR("Bad pointer given");
        return DDERR_OUTOFMEMORY;
    }
    if (size > 0) {
        p = malloc_function(size);
        if (p == NULL)
            return (DDERR_OUTOFMEMORY);
    } else {
        p = NULL;
    }
    *p_return = p;
    
    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DRealloc"

HRESULT D3DAPI D3DRealloc(LPVOID* p_inout, size_t size)
{
    void* p = *p_inout;
    HRESULT err = D3D_OK;

    if (!VALID_OUTPTR(p_inout)) 
    {
        D3D_ERR("Bad pointer given");
        return DDERR_OUTOFMEMORY;
    }
    if (size > 0) 
    {
        if (p) 
        {
            p = realloc_function(p, size);
            if (p == NULL)
                return (DDERR_OUTOFMEMORY);
        } 
        else
            return D3DMalloc(p_inout, size);
    } 
    else 
    if (size == 0) 
    {
        D3DFree(p);
        p = NULL;
    } 
    else
        return (DDERR_INVALIDPARAMS);
    *p_inout = p;
    return (err);
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DFree"

VOID D3DAPI D3DFree(LPVOID p)
{
    if (p == NULL) return;

    if (!VALID_DWORD_PTR(p)) {
        D3D_ERR("invalid pointer");
        return;
    }
    if (p) {
        free_function(p);
    }
}

#define CACHE_LINE 32
HRESULT MallocAligned(void** p_return, size_t size)
{
    char* p;
    size_t offset;
    HRESULT error;

    if (!p_return)
	return DDERR_INVALIDPARAMS;

    if (size > 0) {
	if ((error = D3DMalloc((void**) &p, size + CACHE_LINE)) != DD_OK)
        {
            *p_return = NULL;
            return error;
        }
	offset = CACHE_LINE - (DWORD)((ULONG_PTR)p & (CACHE_LINE - 1));
	p += offset;
	((size_t*)p)[-1] = offset;
    } else
	p = NULL;
    *p_return = p;
    return DD_OK;
}

void FreeAligned(void* p)
{
    if (p) {
        size_t offset = ((size_t*)p)[-1];
	p = (void*) ((unsigned char*)p - offset);
    	D3DFree(p);
    }
}

HRESULT ReallocAligned(void** p_inout, size_t size)
{
    char* p = (char*)*p_inout;
    HRESULT error;

    if (!p_inout)
	return DDERR_INVALIDPARAMS;

    if (size > 0) {
	if (p) {
	    size_t old_offset = ((size_t*)p)[-1];
	    size_t new_offset;
	    
	    p -= old_offset;
	    if ((error = D3DRealloc((void**) &p, size + CACHE_LINE)) != DD_OK)
		return error;

	    new_offset = CACHE_LINE - (DWORD)((ULONG_PTR)p & (CACHE_LINE - 1));
	    if (old_offset != new_offset)
	    	memmove(p + new_offset, p + old_offset, size);
	    p += new_offset;
	    ((size_t*)p)[-1] = new_offset;
	} else
	    return MallocAligned(p_inout, size);
    } else if (size == 0) {
	FreeAligned(p);
	p = NULL;
    } else
	return DDERR_INVALIDPARAMS;
    *p_inout = p;
    return DD_OK;
}

//----------------------------------------------------------------------------
// Growing aligned buffer implementation.
//
HRESULT CAlignedBuffer32::Grow(DWORD growSize)
{
    if (allocatedBuf)
        D3DFree(allocatedBuf);
    size = growSize;
    if (D3DMalloc(&allocatedBuf, size + 31) != DD_OK)
    {
        allocatedBuf = 0;
        alignedBuf = 0;
        size = 0;
        return DDERR_OUTOFMEMORY;
    }
    alignedBuf = (LPVOID)(((ULONG_PTR)allocatedBuf + 31 ) & ~31);
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CBufferDDS::Grow"
//----------------------------------------------------------------------
// Growing buffer using DDS implementation.
//
HRESULT CBufferDDS::Grow(LPDIRECT3DDEVICEI lpDevI, DWORD growSize)
{
    DWORD dwRefCnt = 1;
    if (growSize <= size)
        return D3D_OK;
    if (allocatedBuf)
    {
        // Save reference count before deleting
        dwRefCnt = allocatedBuf->AddRef() - 1;
        // Release till gone!
        while (allocatedBuf->Release());
    }
    size = growSize;
    DDSURFACEDESC2 ddsd;
    memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
    ddsd.dwSize = sizeof(DDSURFACEDESC2);
    ddsd.dwFlags = DDSD_WIDTH | DDSD_CAPS;
    ddsd.dwWidth = size + 31; 
    ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER | DDSCAPS_SYSTEMMEMORY;
    LPDIRECTDRAWSURFACE4 lpDDS4;
    HRESULT ret = lpDevI->lpDirect3DI->lpDD4->CreateSurface(&ddsd, &lpDDS4, NULL);
    if (ret != DD_OK) 
    {
        D3D_ERR("Failed to allocate Vertex Buffer");
        size = 0;
        return ret;
    }
    ret = lpDDS4->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&allocatedBuf);
    if (ret != DD_OK) 
    {
        D3D_ERR("failed to QI for DDS1");
        allocatedBuf = 0;
        size = 0;
        return ret;
    }
    ret = lpDDS4->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_NOSYSLOCK, NULL);
    if (ret != DD_OK)
    {
        D3D_ERR("Could not lock system memory Vertex Buffer.");
        allocatedBuf = 0;
        size = 0;
        return ret;
    }
    lpDDS4->Release();
    alignedBuf = ddsd.lpSurface;
    // Restore reference count
    while (--dwRefCnt)
        allocatedBuf->AddRef();
    return D3D_OK;
}
//----------------------------------------------------------------------
// Growing aligned vertex buffer implementation.
//
HRESULT CBufferVB::Grow(LPDIRECT3DDEVICEI lpDevI, DWORD growSize)
{
    D3DVERTEXBUFFERDESC vbdesc = {sizeof(D3DVERTEXBUFFERDESC), 0, D3DFVF_TLVERTEX, 0};
    DWORD dwRefCnt = 1;
    // Note the assumption that base is not zero only for DP2 HAL
    if (IS_DP2HAL_DEVICE(lpDevI))
    {
        CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(lpDevI);
        HRESULT ret;
        ret = dev->FlushStates(growSize);
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in CBufferVB::Grow");
            return ret;
        }
        base = 0;
    }
    if (growSize <= size)
        return D3D_OK;
    if (allocatedBuf)
    {
        if (IS_DP2HAL_DEVICE(lpDevI))
        {
            CDirect3DDeviceIDP2 &dev = *static_cast<CDirect3DDeviceIDP2*>(lpDevI);
            if (dev.lpDP2CurrBatchVBI == allocatedBuf)
            {
                dev.lpDP2CurrBatchVBI->Release();
                dev.lpDP2CurrBatchVBI = NULL;
            }
        }
        // Save reference count before deleting
        dwRefCnt = allocatedBuf->AddRef() - 1;
        // Release till gone!
        while (allocatedBuf->Release());
    }
    vbdesc.dwNumVertices = (growSize + 31) / sizeof(D3DTLVERTEX);
    size = vbdesc.dwNumVertices * sizeof(D3DTLVERTEX);
    if (!IS_DP2HAL_DEVICE(lpDevI) || !IS_HW_DEVICE(lpDevI))
    {
        vbdesc.dwCaps = D3DVBCAPS_SYSTEMMEMORY;
    }
    if (lpDevI->lpDirect3DI->CreateVertexBufferI(&vbdesc, &allocatedBuf, D3DDP_DONOTCLIP | D3DVBFLAGS_CREATEMULTIBUFFER) != DD_OK)
    {
        allocatedBuf = 0;
        size = 0;
        return DDERR_OUTOFMEMORY;
    }
    // Restore reference count
    while (--dwRefCnt)
        allocatedBuf->AddRef();
    allocatedBuf->Lock(DDLOCK_WAIT, &alignedBuf, NULL);
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\devstate.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       devstate.c
 *  Content:    device state management
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "drawprim.hpp"

extern HRESULT checkDeviceSurface(LPDIRECT3DDEVICEI lpD3DDev,
                                  LPDIRECTDRAWSURFACE lpDDS);
extern HRESULT CalcDDSurfInfo(LPDIRECT3DDEVICEI lpDevI, BOOL bUpdateZBufferFields);
extern HRESULT downloadView(LPDIRECT3DVIEWPORTI lpViewI);

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetCurrentViewport"

HRESULT D3DAPI DIRECT3DDEVICEI::SetCurrentViewport(LPDIRECT3DVIEWPORT2 lpViewport)
{
    return SetCurrentViewport((LPDIRECT3DVIEWPORT3)lpViewport);
}

HRESULT D3DAPI DIRECT3DDEVICEI::SetCurrentViewport(LPDIRECT3DVIEWPORT3 lpViewport)
{
    LPDIRECT3DVIEWPORTI lpD3DViewI,lpOldViewportI;
    HRESULT err;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        lpD3DViewI = (LPDIRECT3DVIEWPORTI)lpViewport;
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DVIEWPORT3_PTR(lpViewport))
        {
            D3D_ERR( "Invalid viewport pointer passed to SetCurrentViewport" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in SetCurrentViewport" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "SetCurrentViewport in Begin" );
        return D3DERR_INBEGIN;
    }

    /*
     * The viewport must be associated with this device
     */
    if (lpD3DViewI->lpDevI != this)
    {
        D3D_ERR( "Viewport not associated with this device" );
        return (DDERR_INVALIDPARAMS);
    }

    lpOldViewportI=this->lpCurrentViewport;
    this->lpCurrentViewport = lpD3DViewI;

    if (lpD3DViewI->v_id != v_id && lpD3DViewI->v_data_is_set)
    {
        err = downloadView(lpD3DViewI);
        if (err != D3D_OK)
        {
            this->lpCurrentViewport = lpOldViewportI;
            return err;
        }
    }

    if(lpOldViewportI!=NULL)
      lpOldViewportI->Release();

    this->lpCurrentViewport->AddRef();

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetCurrentViewport"

HRESULT D3DAPI DIRECT3DDEVICEI::GetCurrentViewport(LPDIRECT3DVIEWPORT2 *lpViewport)
{
    return GetCurrentViewport((LPDIRECT3DVIEWPORT3*)lpViewport);
}

HRESULT D3DAPI DIRECT3DDEVICEI::GetCurrentViewport(LPDIRECT3DVIEWPORT3 *lpViewport)
{
    LPDIRECT3DVIEWPORTI lpD3DViewI;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        lpD3DViewI = (LPDIRECT3DVIEWPORTI)lpViewport;
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR_PTR(lpViewport))
        {
            D3D_ERR( "Invalid viewport pointer passed to GetCurrentViewport" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in GetCurrentViewport" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "GetCurrentViewport in Begin" );
        return D3DERR_INBEGIN;
    }

    if (VALID_DIRECT3DVIEWPORT3_PTR(this->lpCurrentViewport))
    {
        this->lpCurrentViewport->AddRef();
        *lpViewport = (LPDIRECT3DVIEWPORT3)this->lpCurrentViewport;
        return D3D_OK;
    }
    else
    {
        return D3DERR_NOCURRENTVIEWPORT;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetRenderState"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetRenderState(D3DRENDERSTATETYPE dwState, DWORD value)
{
    // Takes D3D lock (MT only).
    // Lock released in the destructor.
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

#if DBG

#ifdef DEBUG_PIPELINE
    extern void SetDebugRenderState(DWORD value);
    if (dwState == (D3DRENDERSTATETYPE)0xFFFFFFFF)
    {
        SetDebugRenderState(value);
        return D3D_OK;
    }
#endif
#endif  //DBG range check below is needed for backward comp with DX5

    if (dwState >= D3DHAL_MAX_RSTATES || dwState == 0)
    {
        D3D_ERR( "Invalid render state type" );
        return DDERR_INVALIDPARAMS;
    }

#if DBG
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in SetRenderState" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "SetRenderState in Begin" );
        return D3DERR_INBEGIN;
    }
#endif
    if (D3DRENDERSTATE_FLUSHBATCH == dwState)
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                        // Release in the destructor
        HRESULT ret;
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in SetRenderState");
            return ret;
        }

        return D3D_OK;
    }

    // map legacy renderstate into WRAP0 - needed for clipping if nothing else
    if ( (D3DRENDERSTATE_WRAPU == dwState) || (D3DRENDERSTATE_WRAPV == dwState) )
    {
        DWORD dwWRAP0State = this->rstates[D3DRENDERSTATE_WRAP0];
        DWORD dwWrapFlag = (D3DRENDERSTATE_WRAPU == dwState) ? (D3DWRAP_U) : (D3DWRAP_V);
        if (value) dwWRAP0State |= dwWrapFlag;
        else         dwWRAP0State &= ~dwWrapFlag;
        if ( dwWRAP0State != this->rstates[D3DRENDERSTATE_WRAP0] )
        {
            SetDeviceRenderState(this, D3DRENDERSTATE_WRAP0, dwWRAP0State);
            // send new RS's to DX6 aware drivers only
            if (IS_DP2HAL_DEVICE(this))
            {
                SetRenderStateI(D3DRENDERSTATE_WRAP0, dwWRAP0State);
            }
        }
    }

    // map WRAP0 into legacy renderstate
    if (D3DRENDERSTATE_WRAP0 == dwState)
    {
        if (!(IS_DP2HAL_DEVICE(this)))
        {
            BOOLEAN ustate = (value & D3DWRAP_U) ? TRUE : FALSE;
            BOOLEAN vstate = (value & D3DWRAP_V) ? TRUE : FALSE;
            if (this->rstates[D3DRENDERSTATE_WRAPU] == ustate &&
                this->rstates[D3DRENDERSTATE_WRAPV] == vstate)
            {
                D3D_WARN(4,"Ignoring redundant SetRenderState");
            }
            else
            {
                SetDeviceRenderState(this, D3DRENDERSTATE_WRAPU, ustate);
                SetRenderStateI(D3DRENDERSTATE_WRAPU, ustate);
                SetDeviceRenderState(this, D3DRENDERSTATE_WRAPV, vstate);
                SetRenderStateI(D3DRENDERSTATE_WRAPV, vstate);
            }
        }
    }

    if (this->rstates[dwState] == value && IS_DP2HAL_DEVICE(this))
    {
        D3D_WARN(4,"Ignoring redundant SetRenderState");
        return D3D_OK;
    }

    /* Save latest state for GetRenderState() */
    SetDeviceRenderState(this, dwState, value);

    return SetRenderStateI(dwState, value);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::SetRenderStateI"

HRESULT D3DAPI
CDirect3DDeviceIHW::SetRenderStateI(D3DRENDERSTATETYPE dwState, DWORD value)
{
    LPDWORD lpRS;
    if (dwState > D3DRENDERSTATE_STIPPLEPATTERN31)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwState);
        return D3D_OK;
    }
    if (dwState > D3DRENDERSTATE_FLUSHBATCH && dwState < D3DRENDERSTATE_STIPPLEPATTERN00)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwState);
        return D3D_OK;
    }
    if ( this->dwHWOffset + 8 >= dwHWBufferSize )
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                        // Release in the destructor
        HRESULT ret;
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in BeginIndexed");
            return ret;
        }
    }
    if (this->lpHWCounts[this->dwHWNumCounts].wNumVertices)
    {
        this->dwHWNumCounts += 1;
        memset(&this->lpHWCounts[this->dwHWNumCounts], 0, sizeof(D3DI_HWCOUNTS) );
    }

    lpRS = (LPDWORD) (((char *) this->lpHWVertices) + this->dwHWOffset);
    lpRS[0] = dwState;
    lpRS[1] = value;
    this->lpHWCounts[this->dwHWNumCounts].wNumStateChanges += 1;
    this->dwHWOffset += 8;

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetRenderState"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetRenderState(D3DRENDERSTATETYPE dwState, LPDWORD lpdwValue)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor

    if (dwState >= D3DHAL_MAX_RSTATES || dwState == 0) {
        D3D_ERR( "Invalid render state value" );
        return DDERR_INVALIDPARAMS;
    }

    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR(lpdwValue, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid DWORD pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *lpdwValue = this->rstates[dwState];
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetTexture"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetTexture(DWORD dwStage, LPDIRECT3DTEXTURE2 *lplpTex)
{
    // Takes D3D lock (MT only).
    // Lock released in the destructor.
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif

    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR(lplpTex, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid DWORD pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    // Don't bother to check for DX6 support, just return the
    // cached value.
    *lplpTex = lpD3DMappedTexI[dwStage];
    if (*lplpTex)   (*lplpTex)->AddRef();
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetTexture"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetTexture(DWORD dwStage, LPDIRECT3DTEXTURE2 lpTex)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }

    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
#endif

    if (lpD3DMappedTexI[dwStage] == (LPDIRECT3DTEXTUREI)lpTex)
    {
        return  D3D_OK;
    }

#if DBG
    if (lpTex)
    {
        LPDIRECT3DTEXTUREI  lpTexI= (LPDIRECT3DTEXTUREI)lpTex;
        HRESULT ret;
        if (
            (!lpTexI->lpDDSSys)
            && (lpTexI->DDSInt4.lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
            && (!(lpD3DHALGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_TEXTURESYSTEMMEMORY))
            )
        {
            D3D_ERR( "Device cannot render using texture surface from system memory" );
            return DDERR_INVALIDPARAMS;
        }
        ret=VerifyTextureCaps(this, &lpTexI->DDSInt4);
        if (D3D_OK != ret)
        {
            return  ret;
        }
    }
#endif

    LPDDRAWI_DDRAWSURFACE_INT   surf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   surf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   surf_gbl;
    // we are ssumeing lpTex->lpOwningIUnknown is always a LPDDRAWI_DDRAWSURFACE_INT
    // if in the future when texture is not aggregated on ddraw surface, change is needed here
    if (lpD3DMappedTexI[dwStage])
    {   //the following is a hack of Surface Release() for perf reason
        surf_int=(LPDDRAWI_DDRAWSURFACE_INT)lpD3DMappedTexI[dwStage]->lpOwningIUnknown;
        if (surf_int->dwIntRefCnt > 1)  // only do this short way when it's not going away
        {
            surf_lcl=surf_int->lpLcl;
            surf_gbl=surf_lcl->lpGbl;
            surf_gbl->dwRefCnt--;
            surf_lcl->dwLocalRefCnt--;
            surf_int->dwIntRefCnt--;
        }
        else
            lpD3DMappedTexI[dwStage]->Release();
    }

    lpD3DMappedTexI[dwStage] = (LPDIRECT3DTEXTUREI)lpTex;
    if (lpTex)
    {   //the following is a hack of lpTex->AddRef() for perf reason
        surf_int=(LPDDRAWI_DDRAWSURFACE_INT)((LPDIRECT3DTEXTUREI)lpTex)->lpOwningIUnknown;
        surf_lcl=surf_int->lpLcl;
        surf_gbl=surf_lcl->lpGbl;
        surf_gbl->dwRefCnt++;
        surf_lcl->dwLocalRefCnt++;
        surf_int->dwIntRefCnt++;
        lpD3DMappedBlock[dwStage] = NULL;
    }
    else
    {
        lpD3DMappedBlock[dwStage] = (LPD3DI_TEXTUREBLOCK)TRUE;  //indicate a dirty if lpTex==NULL
    }
    if (this->tsstates[dwStage][D3DTSS_COLOROP] != D3DTOP_DISABLE)
    {
        this->dwFVFLastIn = 0;  // Force to recompute outputVID
        this->dwFEFlags |= D3DFE_TSSINDEX_DIRTY;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetTextureStageState"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetTextureStageState(DWORD dwStage,
                                      D3DTEXTURESTAGESTATETYPE dwState,
                                      LPDWORD pdwValue)
{
    // Takes D3D lock (MT only).
    // Lock released in the destructor.
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES ||
        dwState == 0 || dwState >= D3DTSS_MAX)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif  //DBG

    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR(pdwValue, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid DWORD pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    // Don't bother to check for DX6 support, just return the
    // cached value.
    *pdwValue = tsstates[dwStage][dwState];
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::CreateDevice"

extern HRESULT WINAPI Direct3DCreateDevice(REFCLSID            riid,
                                           LPUNKNOWN           lpDirect3D,
                                           LPDIRECTDRAWSURFACE lpDDSTarget,
                                           LPUNKNOWN*          lplpD3DDevice,
                                           IUnknown*           pUnkOuter,
                                           DWORD               dwVersion);

HRESULT D3DAPI DIRECT3DI::CreateDevice(REFCLSID devType,
                                       LPDIRECTDRAWSURFACE4 lpDDS4,
                                       LPDIRECT3DDEVICE3 *lplpDirect3DDevice3,
                                       LPUNKNOWN pUnkOuter) {
    HRESULT ret;
    LPUNKNOWN lpUnkDevice;
    LPDIRECTDRAWSURFACE lpDDS;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    TRY
    {
        if (!VALID_DIRECT3D3_PTR(this)) {
            D3D_ERR( "Invalid Direct3D pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(lplpDirect3DDevice3)) {
            D3D_ERR( "Invalid pointer to Device object pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_D3D_DIRECTDRAWSURFACE4_PTR(((LPDDRAWI_DDRAWSURFACE_INT)lpDDS4)))
        {
            D3D_ERR( "Invalid DirectDrawSurface4 pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in CreateDevice" );
        return DDERR_INVALIDPARAMS;
    }

    if (pUnkOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    *lplpDirect3DDevice3=NULL;

    // QI lpDDS4 for lpDDS interface
    ret = lpDDS4->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpDDS);
    if (FAILED(ret))
        return ret;
    lpDDS->Release();

    ret = Direct3DCreateDevice(devType, &this->mD3DUnk, lpDDS, (LPUNKNOWN *) &lpUnkDevice, NULL, 3);

    if(FAILED(ret) || (lpUnkDevice==NULL))
      return ret;

    // QI device1 for a device3 interface
    ret = lpUnkDevice->QueryInterface(IID_IDirect3DDevice3, (LPVOID*)lplpDirect3DDevice3);

    lpUnkDevice->Release();  // release unneeded interface

    return ret;
}

HRESULT D3DAPI DIRECT3DI::CreateDevice(REFCLSID devType,
                                       LPDIRECTDRAWSURFACE lpDDS,
                                       LPDIRECT3DDEVICE2 *lplpDirect3DDevice2)
{
    HRESULT ret;
    LPUNKNOWN lpUnkDevice;
    ULONG refcnt;

    TRY
    {
        if (!VALID_DIRECT3D3_PTR(this)) {
            D3D_ERR( "Invalid Direct3D pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALID_OUTPTR(lplpDirect3DDevice2)) {
            D3D_ERR( "Invalid pointer to Device object pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_D3D_DIRECTDRAWSURFACE_PTR(((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)))
        {
            D3D_ERR( "Invalid DirectDrawSurface pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in CreateDevice" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpDirect3DDevice2=NULL;

    // Create a device3 object
    ret = Direct3DCreateDevice(devType, &this->mD3DUnk, lpDDS, (LPUNKNOWN *) &lpUnkDevice, NULL, 2);

    if(FAILED(ret) || (lpUnkDevice==NULL)) {
       return ret;
    }

    // QI it for a device2 interface
    ret = lpUnkDevice->QueryInterface(IID_IDirect3DDevice2, (LPVOID*)lplpDirect3DDevice2);

    lpUnkDevice->Release();  // releasing unneeded interface

    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetLightState"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetLightState(D3DLIGHTSTATETYPE dwState, DWORD value)
{
    HRESULT                         ret = D3D_OK;
    D3DSTATE                        state;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    state.dlstLightStateType = dwState;
    state.dwArg[0] = value;

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "SetLightState in Begin" );
        return D3DERR_INBEGIN;
    }

    return D3DHELInst_D3DOP_STATELIGHT(this, 1, &state);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetLightState"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetLightState(D3DLIGHTSTATETYPE dwState, LPDWORD lpValue)
{

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    float* lpfValue = (float*)lpValue;
#if DBG
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR(lpValue, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid DWORD pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in GetLightState" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "GetLightState in Begin" );
        return D3DERR_INBEGIN;
    }
#endif
    switch (dwState)
    {
    case D3DLIGHTSTATE_MATERIAL:
        *lpValue = (DWORD)this->lighting.hMat;
        break;
    case D3DLIGHTSTATE_AMBIENT:
        *lpValue = this->lighting.ambient_save;
        break;
    case D3DLIGHTSTATE_FOGMODE:
        *lpValue = this->lighting.fog_mode;
        break;
    case D3DLIGHTSTATE_FOGSTART:
        *lpfValue = this->lighting.fog_start;
        break;
    case D3DLIGHTSTATE_FOGEND:
        *lpfValue = this->lighting.fog_end;
        break;
    case D3DLIGHTSTATE_FOGDENSITY:
        *lpfValue = this->lighting.fog_density;
        break;
    case D3DLIGHTSTATE_COLORMODEL:
        *lpValue = this->lighting.color_model;
        break;
    case D3DLIGHTSTATE_COLORVERTEX:
        // return value for Device3 only
        if (dwVersion == 3)
        {
            *lpValue = (0x0 != (dwFEFlags & D3DFE_COLORVERTEX));
            break;
        }
        // else fall through to error return
    default:
        D3D_ERR( "Invalid state value passed to GetLightState" );
        return DDERR_INVALIDPARAMS; /* Do we return an error code or should we just ignore ? */
    }
    return D3D_OK;
}

/*
    transform matrix functions
*/

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetTransform"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetTransform(D3DTRANSFORMSTATETYPE dtsTransformState, LPD3DMATRIX lpMat)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor
    HRESULT ret = D3D_OK;
    D3DFE_TRANSFORM *lpHelTransform = &this->transform;
#if DBG
    if (!lpMat) {
        D3D_ERR( "NULL matrix pointer passed to SetTransform" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "SetTransform in Begin" );
        return D3DERR_INBEGIN;
    }
#endif
    switch (dtsTransformState)
    {
    case D3DTRANSFORMSTATE_WORLD      : D3DFE_SetMatrixWorld(this, lpMat); break;
    case D3DTRANSFORMSTATE_VIEW       : D3DFE_SetMatrixView(this, lpMat); break;
    case D3DTRANSFORMSTATE_PROJECTION :
        D3DFE_SetMatrixProj(this, lpMat);
        if ((ret = this->UpdateDrvWInfo()) != DD_OK)
        {
            return ret;
        }
        break;
    default :
        D3D_ERR( "Invalid state value passed to SetTransform" );
        ret = DDERR_INVALIDPARAMS; /* Work Item: Generate new meaningful return code */
        break;
    }

    return ret;
}       // end of D3DDev_SetTransform()


#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetTransform"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetTransform(D3DTRANSFORMSTATETYPE dtsTransformState, LPD3DMATRIX lpMat)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor
    HRESULT ret = D3D_OK;
    D3DFE_TRANSFORM *lpHelTransform;
#if DBG
    if (!lpMat) {
        D3D_ERR( "NULL matrix pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "GetTransform in Begin" );
        return D3DERR_INBEGIN;
    }
#endif
    lpHelTransform = &this->transform;
    switch (dtsTransformState) {
    case D3DTRANSFORMSTATE_WORLD :
        *lpMat = *(LPD3DMATRIX)&lpHelTransform->world._11;
        break;
    case D3DTRANSFORMSTATE_VIEW :
        *lpMat = *(LPD3DMATRIX)&lpHelTransform->view._11;
        break;
    case D3DTRANSFORMSTATE_PROJECTION :
        *lpMat = *(LPD3DMATRIX)&lpHelTransform->proj._11;
        break;
    default :
        D3D_ERR( "Invalid state value passed to GetTransform" );
        ret = DDERR_INVALIDPARAMS; /* Work Item: Generate new meaningful return code */
        break;
    }

    return ret;
}       // end of D3DDev2_GetTransform()


#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::MultiplyTransform"

/*
    MultiplyTransform -- this preconcatenates the new matrix to the specified transform matrix

        this really screams for overloaded matrix ops...
*/
HRESULT D3DAPI
DIRECT3DDEVICEI::MultiplyTransform(D3DTRANSFORMSTATETYPE dtsTransformState, LPD3DMATRIX lpMat)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor
    HRESULT         ret = D3D_OK;
    D3DFE_TRANSFORM *lpHelTransform;
#if DBG
    if (!lpMat) {
        D3D_ERR( "NULL matrix pointer passed to MultiplyTransform" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "MultiplyTransform in Begin" );
        return D3DERR_INBEGIN;
    }
#endif
    lpHelTransform = &this->transform;
    switch (dtsTransformState)
    {
    case D3DTRANSFORMSTATE_WORLD      : D3DFE_MultMatrixWorld(this, lpMat); break;
    case D3DTRANSFORMSTATE_VIEW       : D3DFE_MultMatrixView(this, lpMat); break;
    case D3DTRANSFORMSTATE_PROJECTION : D3DFE_MultMatrixProj(this, lpMat); break;
    default :
        D3D_ERR( "Invalid state value passed to MultiplyTransform" );
        ret = DDERR_INVALIDPARAMS; /* Work Item: Generate new meaningful return code */
        return ret;
    }
    return ret;
}       // end of D3DDev2_MultiplyTransform()

void InvalidateHandles(LPDIRECT3DDEVICEI lpDevI)
{
    /* free up all textures created by this object */
    LPD3DI_TEXTUREBLOCK tBlock=LIST_FIRST(&lpDevI->texBlocks);
    while (tBlock)
    {
        D3DI_RemoveTextureHandle(tBlock);
        tBlock=LIST_NEXT(tBlock,devList);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetRenderTarget"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetRenderTarget(LPDIRECTDRAWSURFACE lpDDS, DWORD dwFlags) {

  LPDIRECTDRAWSURFACE4 lpDDS4;
  HRESULT ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    TRY
    {
        if (!VALID_DIRECT3DDEVICE2_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice2 pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALID_D3D_DIRECTDRAWSURFACE_PTR((LPDDRAWI_DDRAWSURFACE_INT)lpDDS))
        {
            D3D_ERR( "Invalid DirectDrawSurface pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in SetRenderTarget" );
        return DDERR_INVALIDPARAMS;
    }

    /* Make sure this device was not aggregated from DDS (DX3-style) */
    if ((LPDIRECTDRAWSURFACE)this->lpOwningIUnknown==this->lpDDSTarget)
    {
        D3D_ERR("Cannot change render target on old device (those QI'ed from a ddraw-surface");
        return D3DERR_DEVICEAGGREGATED;
    }

    // QI lpDDS for lpDDS4 interface, which will be used internally by D3D
    ret = lpDDS->QueryInterface(IID_IDirectDrawSurface4, (LPVOID*)&lpDDS4);

    if(FAILED(ret))
      return ret;

    // SetRenderTarget AddRef'd the DDS4 interface, so it's safe to release it here and decrmt the refcnt
    lpDDS4->Release();

    ret=this->SetRenderTarget(lpDDS4,dwFlags);

    return ret;
}

HRESULT D3DAPI
DIRECT3DDEVICEI::SetRenderTarget(LPDIRECTDRAWSURFACE4 lpDDS4, DWORD dwFlags)
{
    DDSCAPS2 ddscaps;
    DDSURFACEDESC2 ddsd;
    HRESULT     ret, ddrval;
    LPDIRECTDRAWSURFACE lpZ=NULL,lpDDS=NULL;
    LPDIRECTDRAWSURFACE4 lpZ_DDS4=NULL;
    LPDIRECTDRAWPALETTE lpPal=NULL;
    DWORD i, j;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor

    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALID_D3D_DIRECTDRAWSURFACE4_PTR(((LPDDRAWI_DDRAWSURFACE_INT)lpDDS4)))
        {
            D3D_ERR( "Invalid DirectDrawSurface4 pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters in SetRenderTarget" );
        return DDERR_INVALIDPARAMS;
    }

    // Flush before switching RenderTarget..
    ret = FlushStates();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to FlushStates in SetRenderTarget");
        return ret;
    }

    /* Make sure this device was not aggregated from DDS (DX3-style) */
    if ((LPDIRECTDRAWSURFACE)this->lpOwningIUnknown==this->lpDDSTarget)
    {
        D3D_ERR("Cannot change render target on device QI'ed from DDS");
        return D3DERR_DEVICEAGGREGATED;
    }

    /*
     * Check if the 3D cap is set on the surface.
     */
    memset(&ddsd, 0, sizeof ddsd);
    ddsd.dwSize = sizeof ddsd;
    ddrval = lpDDS4->GetSurfaceDesc(&ddsd);
    if (ddrval != DD_OK)
    {
        D3D_ERR("Failed to get surface description of device's surface.");
        return (ddrval);
    }

    if (!(ddsd.ddsCaps.dwCaps & DDSCAPS_3DDEVICE))
    {
        D3D_ERR("**** The DDSCAPS_3DDEVICE is not set on this surface.");
        D3D_ERR("**** You need to add DDSCAPS_3DDEVICE to ddsCaps.dwCaps");
        D3D_ERR("**** when creating the surface.");
        return (DDERR_INVALIDCAPS);
    }
    if (!(this->lpD3DHALGlobalDriverData->hwCaps.dwDeviceRenderBitDepth & BitDepthToDDBD(ddsd.ddpfPixelFormat.dwRGBBitCount))) {
        D3D_ERR("Rendering surface's RGB bit count not supported by hardware device");
        return (DDERR_INVALIDCAPS);
    }
    if (ddsd.dwWidth > 2048 || ddsd.dwHeight > 2048)
    {
        D3D_ERR("Surface dimension > 2048");
        return DDERR_INVALIDPARAMS;
    }

    /* The z-buffer... */
    ddscaps.dwCaps = DDSCAPS_ZBUFFER;
    ret = lpDDS4->GetAttachedSurface(&ddscaps, &lpZ_DDS4);
    if ((ret != DD_OK) && (ret != DDERR_NOTFOUND))
    {
        /*
         * NOTE: Not an error if the z-buffer is not found. We will let the
         * dirver handle that (it might fail or create its own z-buffer).
         */
        D3D_ERR("Supplied DirectDraw Z-Buffer is invalid - can't set render target");
        ret=DDERR_INVALIDPARAMS;
        goto handle_error;
    }
    if (lpZ_DDS4)
        lpZ_DDS4->Release(); // We do not need to addref this one;

    // QI lpDDS4 for lpDDS interface, which will be used internally by D3D
    ret = lpDDS4->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpDDS);

    if(FAILED(ret))
      goto handle_error;

    /* The palette... */
    ret = lpDDS->GetPalette(&lpPal);
    if ((ret != DD_OK) && (ret != DDERR_NOPALETTEATTACHED))
    {
        /*
         * NOTE: Again, not an error (yet) if there is no palette attached.
         * But if there is palette and we can't get at it for some reason
         * - fail.
         */
        D3D_ERR("Supplied DirectDraw Palette is invalid - can't create device");
        ret=DDERR_INVALIDPARAMS;
        goto handle_error;
    }

    /*
     * We're going to check now whether we should have got a palette.
     */
    if (ret == DDERR_NOPALETTEATTACHED)
    {
        if (ddsd.ddpfPixelFormat.dwRGBBitCount < 16)
        {
            D3D_ERR("No palette supplied for palettized surface");
            ret=DDERR_NOPALETTEATTACHED;
            goto handle_error;
        }
    }

    /* Verify Z buffer */

    if (lpZ_DDS4!=NULL)
    {
        memset(&ddsd, 0, sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);
        if ((ret=lpZ_DDS4->GetSurfaceDesc(&ddsd)) != DD_OK)
        {
            D3D_ERR("Failed to getsurfacedesc on Z");
            goto handle_error;
        }

        // QI lpDDS4 for lpDDS interface, which will be used internally by D3D
        ret = lpZ_DDS4->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpZ);

        if(FAILED(ret))
          goto handle_error;
    }
    else
    {
        if (this->lpDDSZBuffer)
        {
            D3D_ERR("Current rendertarget contains ZBuffer, but new one does not!");
            ret=DDERR_INVALIDPARAMS;
            goto handle_error;
        }
    }
    if (IS_DX7HAL_DEVICE(this))
    {
        static_cast<CDirect3DDeviceIDP2*>(this)->SetRenderTargetI(lpDDS, lpZ);
    }
    else
    if (this->lpD3DHALCallbacks2->SetRenderTarget)
    {
        D3DHAL_SETRENDERTARGETDATA rtData;

        rtData.dwhContext = this->dwhContext;
#ifndef WIN95
        if (dwFEFlags & D3DFE_REALHAL)
        {
            if (lpDDS)
                rtData.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl;
            else
                rtData.lpDDSLcl = NULL;
            
            if (lpZ)
                rtData.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpZ)->lpLcl;
            else
                rtData.lpDDSZLcl = NULL;
        }
        else
#endif //WIN95
        {
            rtData.lpDDS = lpDDS;
            rtData.lpDDSZ = lpZ;
        }
        rtData.ddrval = 0;
        CALL_HAL2ONLY(ret, this, SetRenderTarget, &rtData);
        if ((ret != DDHAL_DRIVER_HANDLED) || (rtData.ddrval != DD_OK))
        {
            D3D_ERR( "Driver call failed in SetRenderTarget" );
            // Need sensible return value in this case,
            // currently we return whatever the driver stuck in here.
            ret = rtData.ddrval;
            goto handle_error;
        }
    }
    else
    {
        D3DHAL_CONTEXTCREATEDATA cdata;
        D3DHAL_CONTEXTDESTROYDATA ddata;

        /* Destroy old context */
        memset(&ddata, 0, sizeof(D3DHAL_CONTEXTDESTROYDATA));
        ddata.dwhContext = this->dwhContext;

        CALL_HALONLY(ret, this, ContextDestroy, &ddata);
        if (ret != DDHAL_DRIVER_HANDLED || ddata.ddrval != DD_OK)
        {
            DPF(0, "(ERROR) ContextDestroy. Failed. dwhContext = %d", ddata.dwhContext);
            // Need sensible return value in this case,
            // currently we return whatever the driver stuck in here.
            ret = ddata.ddrval;
            goto handle_error;
        }

        /* Create new context */
        memset(&cdata, 0, sizeof(D3DHAL_CONTEXTCREATEDATA));

#ifndef WIN95
        if (dwFEFlags & D3DFE_REALHAL)
        {
            if (this->lpDD)
                cdata.lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)(this->lpDD))->lpLcl; 
            else
                cdata.lpDDLcl = NULL;
            
            if (lpDDS)
                cdata.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl;
            else
                cdata.lpDDSLcl = NULL;
            
            if (lpZ)
                cdata.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpZ)->lpLcl;
            else
                cdata.lpDDSZLcl = NULL;
            
        }
        else
#endif //WIN95
        {
            cdata.lpDDGbl = this->lpDDGbl; 
            cdata.lpDDS = lpDDS;
            cdata.lpDDSZ = lpZ;
        }

        cdata.dwPID = GetCurrentProcessId();

        CALL_HALONLY(ret, this, ContextCreate, &cdata);
        if (ret != DDHAL_DRIVER_HANDLED || cdata.ddrval != DD_OK)
        {
            D3D_ERR("HAL call to ContextCreate failed in SetRenderTarget");
            // Need sensible return value in this case,
            // currently we return whatever the driver stuck in here.
            return cdata.ddrval;
        }
        this->dwhContext = cdata.dwhContext;
        D3D_INFO(9, "in halCreateContext. Succeeded. dwhContext = %d", cdata.dwhContext);

        /* Set up renderstates */
        // note we can't do a loop from 1 to D3DHAL_MAX_RSTATES(256) as some of rstates are not
        // valid states, passin them down to drivers(like voodoo2 DX6 driver) will crash.
        for (i= 1 ; i<  D3DRENDERSTATE_WRAPBIAS+8; ++i)
        {
            this->SetRenderStateI((D3DRENDERSTATETYPE)i, this->rstates[i]);
        }
        if ( IS_DP2HAL_DEVICE(this) ) {
            CDirect3DDeviceIDP2 *dp2dev = static_cast<CDirect3DDeviceIDP2 *>(this);
            for (i=0; i<dwMaxTextureBlendStages; ++i)
                for (j=0; j<D3DTSS_MAX; ++j)
                {
                    D3D_INFO(6,"Calling SetTSSI(%d,%d,%08lx)",i,j,this->tsstates[i][j]);
                    dp2dev->SetTSSI(i, (D3DTEXTURESTAGESTATETYPE)j, this->tsstates[i][j]);
                }
        }
    }

    if (this->lpDDSTarget)
    UnHookD3DDeviceFromSurface(this,((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSTarget)->lpLcl);  //unhook previous surfaces if any
    if (this->lpDDSZBuffer)
    UnHookD3DDeviceFromSurface(this,((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSZBuffer)->lpLcl); //unhook previous surfaces if any

    if (DDERR_OUTOFMEMORY == (ret=HookD3DDeviceToSurface(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS4)->lpLcl)))
    {
            goto handle_error;
    }
    if (lpZ_DDS4 && (DDERR_OUTOFMEMORY == (ret=HookD3DDeviceToSurface(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpZ_DDS4)->lpLcl))))
    {
        UnHookD3DDeviceFromSurface(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS4)->lpLcl);
        goto handle_error;
    }
    // release old device DDS/DDS4 interfaces and replace with the new ones,
    // which are mostly already AddRef'd (except for lpDDS4)

    /// DDSZBuffer ///
    if(this->lpDDSZBuffer)
      this->lpDDSZBuffer->Release();

    // lpZ AddRef'd by QI
    this->lpDDSZBuffer = lpZ;

    /// DDSZBuffer DDS4 ///
    this->lpDDSZBuffer_DDS4=lpZ_DDS4; // This needs no AddRef or Release

    ///  DDSTarget  ///
    if (this->dwVersion == 2)
    {
        this->lpDDSTarget->Release();
        // lpDDS AddRef'd by QI
        this->lpDDSTarget = lpDDS;
    }
    else
    {
        this->lpDDSTarget = lpDDS;
        // lpDDS AddRef'd by QI so release it
        this->lpDDSTarget->Release();
    }
#ifndef WIN95
    hSurfaceTarget = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl->hDDSurface;
    D3D_INFO(6,"in SetRenderTarget hSurfaceTarget=%08lx lpDDSTarget=%08lx",hSurfaceTarget,lpDDSTarget);
#else
    hSurfaceTarget = (unsigned long)((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl->lpSurfMore->dwSurfaceHandle;
    D3D_INFO(6,"in SetRenderTarget hSurfaceTarget=%08lx lpDDSTarget=%08lx",hSurfaceTarget,lpDDSTarget);
#endif
    ///  DDSTarget DDS4  ///
    if (this->dwVersion == 3)
    {
        this->lpDDSTarget_DDS4->Release();
        lpDDS4->AddRef();  // ensure lpDDS4 (which was an argument) doesnt disappear
    }
    this->lpDDSTarget_DDS4=lpDDS4;

    if (this->lpDDPalTarget)
      this->lpDDPalTarget->Release();

    // already AddRef'd by GetPalette()
    this->lpDDPalTarget = lpPal;

    InvalidateHandles(this);

    if( FAILED( ret=CalcDDSurfInfo(this,FALSE) ) )
        goto handle_error;
    
    return ret;

 handle_error:

    if(lpPal)
      lpPal->Release();
    if(lpZ)
      lpZ->Release();
    if(lpZ_DDS4)
      lpZ_DDS4->Release();
    if(lpDDS)
      lpDDS->Release();

    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetRenderTarget"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetRenderTarget(LPDIRECTDRAWSURFACE* lplpDDS) {

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    TRY
    {
        if (!VALID_DIRECT3DDEVICE2_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice2 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if ( !VALID_OUTPTR( lplpDDS ) )
        {
            D3D_ERR( "Invalid ptr to DDS ptr" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpDDS = this->lpDDSTarget;

    this->lpDDSTarget->AddRef();
    return D3D_OK;

}

HRESULT D3DAPI
DIRECT3DDEVICEI::GetRenderTarget(LPDIRECTDRAWSURFACE4* lplpDDS)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if ( !VALID_OUTPTR( lplpDDS ) )
        {
            D3D_ERR( "Invalid ptr to DDS ptr" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpDDS = this->lpDDSTarget_DDS4;

    this->lpDDSTarget_DDS4->AddRef();
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetClipStatus"

#define D3DSTATUS_VALID 0x80000000L /* Reserved Status flag to indicate SetClipStatus is called */

HRESULT D3DAPI DIRECT3DDEVICEI::SetClipStatus(LPD3DCLIPSTATUS status)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor
#if DBG
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (! VALID_PTR(status, sizeof(D3DCLIPSTATUS)) )
        {
            D3D_ERR( "Invalid status pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "SetClipStatus in Begin" );
        return D3DERR_INBEGIN;
    }
#endif
    // D3DCLIPSTATUS_EXTENTS3 not supported in Device3
    if (dwVersion == 3 && status->dwFlags & D3DCLIPSTATUS_EXTENTS3)
    {
        D3D_ERR( "D3DCLIPSTATUS_EXTENTS3 not supported for Device3" );
        return DDERR_INVALIDPARAMS;
    }
    if (status->dwFlags & D3DCLIPSTATUS_STATUS)
        this->iClipStatus = status->dwStatus;

    if (status->dwFlags & (D3DCLIPSTATUS_EXTENTS2 | D3DCLIPSTATUS_EXTENTS3))
    {
        this->rExtents.x1 = status->minx;
        this->rExtents.y1 = status->miny;
        this->rExtents.x2 = status->maxx;
        this->rExtents.y2 = status->maxy;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetClipStatus"

HRESULT D3DAPI DIRECT3DDEVICEI::GetClipStatus(LPD3DCLIPSTATUS status)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor
#if DBG
    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (! VALID_PTR(status, sizeof(D3DCLIPSTATUS)) )
        {
            D3D_ERR( "Invalid status pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    if (dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "GetClipStatus in Begin" );
        return D3DERR_INBEGIN;
    }
#endif
    status->dwStatus = iClipStatus;
    status->dwFlags = D3DCLIPSTATUS_EXTENTS2;
    status->minx = this->rExtents.x1;
    status->miny = this->rExtents.y1;
    status->maxx = this->rExtents.x2;
    status->maxy = this->rExtents.y2;
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::UpdateTextures"

HRESULT DIRECT3DDEVICEI::UpdateTextures()
{
    BOOL    bFlushed=FALSE;
    DWORD   dwStage;
    D3DTEXTUREHANDLE    dwDDIHandle;
    LPDIRECT3DTEXTUREI  lpTexI;
    LPD3DI_TEXTUREBLOCK lpBlock;
    for (dwStage=0;dwStage < this->dwMaxTextureBlendStages; dwStage++)
    {
        lpTexI=this->lpD3DMappedTexI[dwStage];
        lpBlock=this->lpD3DMappedBlock[dwStage];
        if(lpTexI)
        {
            if (lpTexI->lpTMBucket)
            {
                if (lpTexI->bDirty)
                {
                    FlushD3DStates(((LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDS))->lpLcl);
                    if (DD_OK != CopySurface(lpTexI->lpDDS,lpTexI->lpDDSSys,this->lpClipper))
                    {
                        D3D_ERR("Error copying surface while updating textures");
                    }
                    else
                    {
                        lpTexI->bDirty=FALSE;
                        D3D_INFO(4,"UpdateTextures: Dirty texture updated");
                    }
                }
            }
            if (lpBlock)
            {
                if (lpBlock->hTex)
                {
                    continue;   //nothing need to be done further
                }
            }

            GetTextureDDIHandle(lpTexI, this, &lpBlock);
            this->lpD3DMappedBlock[dwStage]=lpBlock;
            if (lpBlock)
            {
                dwDDIHandle = lpBlock->hTex;
                if (dwDDIHandle)
                {
                    if(lpTexI->lpDDS != NULL)
                    {
                        BatchTextureToDevice(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpTexI->lpDDS)->lpLcl);
                    }
                    else
                    {
                        BatchTextureToDevice(this, ((LPDDRAWI_DDRAWSURFACE_INT) lpTexI->lpDDSSys)->lpLcl);
                    }
                }
            }
            else
            {
                dwDDIHandle = 0;    //something is wrong we disable this texture
            }
        }
        else if (lpBlock)
        {
            this->lpD3DMappedBlock[dwStage]=NULL; //a SetTexture(Stage,NULL) issued
            dwDDIHandle = 0;    //tell driver to disable this texture
        }
        else
        {
            continue;   //both zero, no action needed
        }
        if (IS_DP2HAL_DEVICE(this))
        {
            CDirect3DDeviceIDP2 *dp2dev = static_cast<CDirect3DDeviceIDP2 *>(this);
            dp2dev->SetTSSI(dwStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, dwDDIHandle);
            // Update runtime copy of state.
            dp2dev->tsstates[dwStage][D3DTSS_TEXTUREMAP] = dwDDIHandle;
        }
        else
        {
            if(this->dwFEFlags & D3DFE_DISABLE_TEXTURES)
                break;
            CDirect3DDeviceIHW *dev = static_cast<CDirect3DDeviceIHW *>(this);
            (void)dev->SetRenderStateI(D3DRENDERSTATE_TEXTUREHANDLE, dwDDIHandle);
            // Update runtime copy of state.
            dev->rstates[D3DRENDERSTATE_TEXTUREHANDLE] = dwDDIHandle;
        }
    }
    return D3D_OK;
}

//---------------------------------------------------------------------
// This function is called from HALEXE.CPP, from device::SetRenderState and
// from device::SetTexture.
// Always use this function to update RSTATES.
//
HRESULT
SetDeviceRenderState(LPDIRECT3DDEVICEI lpDevI, D3DRENDERSTATETYPE type,
                     DWORD value)
{
    DWORD *rstates = lpDevI->rstates;
    switch (type)
    {
    case D3DRENDERSTATE_FOGENABLE:
        rstates[type] = value;      // set rstates BEFORE calling SetFogFlags
        SetFogFlags(lpDevI);
        break;
    case D3DRENDERSTATE_SPECULARENABLE:
            lpDevI->dwFEFlags |= D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY;
        lpDevI->dwFVFLastIn = 0; // Force re-computing of FVF id
        break;
    case D3DRENDERSTATE_TEXTUREHANDLE:
        if ((rstates[D3DRENDERSTATE_TEXTUREHANDLE] == 0) != (value == 0))
            lpDevI->dwFVFLastIn = 0;
        if (value)
            lpDevI->dwDeviceFlags |= D3DDEV_LEGACYTEXTURE;
        else
            lpDevI->dwDeviceFlags &= ~D3DDEV_LEGACYTEXTURE;


        break;
    }
    rstates[type] = value;      // set rstates for all other cases
    return D3D_OK;
}

#if DBG
static  char ProfileStr[PROF_DRAWINDEXEDPRIMITIVEVB+1][32]=
{
    "Execute",
    "Begin",
    "BeginIndexed",
    "DrawPrimitive(Device2)",
    "DrawIndexedPrimitive(Device2)",
    "DrawPrimitiveStrided",
    "DrawIndexedPrimitiveStrided",
    "DrawPrimitive(Device3)",
    "DrawIndexedPrimitive(Device3)",
    "DrawPrimitiveVB",
    "DrawIndexedPrimitiveVB",
};
static  char PrimitiveStr[D3DPT_TRIANGLEFAN][16]=
{
    "POINTLIST",
    "LINELIST",
    "LINESTRIP",
    "TRIANGLELIST",
    "TRIANGLESTRIP",
    "TRIANGLEFAN",
};
static  char VertexStr[D3DVT_TLVERTEX][16]=
{
    "D3DVERTEX",
    "D3DLVERTEX",
    "D3DTLVERTEX",
};
#define PROFILE_LEVEL 1

void    DIRECT3DDEVICEI::Profile(DWORD caller, D3DPRIMITIVETYPE dwPrimitive, DWORD dwVertex)
{
    DWORD   bitwisecaller= 1 << caller;
    DWORD   bitwisePrimitive = 1 << (DWORD)dwPrimitive;
    DWORD   bitwiseVertex1 = 1 << (dwVertex & 0x001F);
    DWORD   bitwiseVertex2 = 1 << ((dwVertex & 0x03E0) >> 5);
    char    str[256];
    DDASSERT(PROF_DRAWINDEXEDPRIMITIVEVB >= caller);
    DDASSERT(D3DPT_TRIANGLEFAN >= dwPrimitive && D3DPT_POINTLIST<= dwPrimitive);
    if (dwCaller & bitwisecaller)
    {
        if (dwPrimitiveType[caller] & bitwisePrimitive)
        {
            if ((dwVertexType1[caller] & bitwiseVertex1) &&
                (dwVertexType2[caller] & bitwiseVertex2))
            {
                return; //matching a previous api call, no spew, could count stat though
            }
            else
            {
                dwVertexType1[caller] |= bitwiseVertex1;
                dwVertexType2[caller] |= bitwiseVertex2;
            }
        }
        else
        {
            dwPrimitiveType[caller] |= bitwisePrimitive;
            dwVertexType1[caller] |= bitwiseVertex1;
            dwVertexType2[caller] |= bitwiseVertex2;
        }
    }
    else
    {
        this->dwCaller |= bitwisecaller;
        dwPrimitiveType[caller] |= bitwisePrimitive;
        dwVertexType1[caller] |= bitwiseVertex1;
        dwVertexType2[caller] |= bitwiseVertex2;
    }
    wsprintf( (LPSTR) str, ProfileStr[caller]);
    strcat(str,":");
    strcat(str,PrimitiveStr[dwPrimitive-1]);
    if (dwVertex > D3DVT_TLVERTEX)
    {
        if (dwVertex == D3DFVF_VERTEX)
        {
            dwVertex = D3DVT_VERTEX;
        }
        else
        if (dwVertex == D3DFVF_LVERTEX)
        {
            dwVertex = D3DVT_LVERTEX;
        }
        else
        if (dwVertex == D3DFVF_TLVERTEX)
        {
            dwVertex = D3DVT_TLVERTEX;
        }
        else
        {
            D3D_INFO(PROFILE_LEVEL,"Profile:%s FVFType=%08lx",str,dwVertex);
            return;
        }
    }
    else
    {
        DDASSERT(dwVertex >= D3DVT_VERTEX);
    }
    strcat(str,":");
    strcat(str,VertexStr[dwVertex-1]);
    D3D_INFO(PROFILE_LEVEL,"Profile:%s",str);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\dlld3d.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   dlld3d.cpp
 *  Content:    Direct3D startup
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *   21/11/95   colinmc Added Direct3D interface ID.
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *   02/03/96   colinmc Minor build fix.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Define the Direct3D IIDs.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D Startup"

DPF_DECLARE(Direct3D);

#ifdef WIN95
LPVOID lpWin16Lock;
#endif

DWORD dwD3DTriBatchSize, dwTriBatchSize, dwLineBatchSize;
DWORD dwHWBufferSize, dwHWMaxTris, dwHWFewVertices;
HINSTANCE hGeometryDLL = NULL;
LPD3DFE_CONTEXTCREATE pfnFEContextCreate;
char szCPUString[13];

DWORD dwCPUFamily, dwCPUFeatures;

#ifdef _X86_
extern HRESULT D3DAPI pii_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
extern HRESULT D3DAPI katmai_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
extern LPD3DFE_CONTEXTCREATE px3DContextCreate;
#endif

void SetMostRecentApp(void);

#ifdef _X86_
// --------------------------------------------------------------------------
// Here's a routine helps us determine if we should try MMX or not
// --------------------------------------------------------------------------
BOOL _asm_isMMX()
{
    DWORD retval;
    _asm
        {
            xor         eax,eax         ; Clear out eax for return value
            pushad              ; CPUID trashes lots - save everything
            mov     eax,1           ; Check for MMX support

            ;;; We need to upgrade our compiler
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2

            test    edx,00800000h   ; Set flags before restoring registers

            popad               ; Restore everything

            setnz    al             ; Set return value
            mov     retval, eax
        };
    return retval;
}
#endif

static int isMMX = -1;

BOOL
isMMXprocessor(void)
{
    HKEY hKey;
    if ( RegOpenKey( HKEY_LOCAL_MACHINE,
                     RESPATH_D3D,
                     &hKey) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;
        if ( RegQueryValueEx( hKey, "DisableMMX", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) == ERROR_SUCCESS &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            RegCloseKey( hKey );
            isMMX = 0;
            return FALSE;
        }
        RegCloseKey( hKey );
    }

    if (isMMX < 0)
    {
        isMMX = FALSE;
#ifdef _X86_
        D3D_WARN(1, "Executing processor detection code (benign first-chance exception possible)" );
#ifndef WIN95
        {
            // GetSystemInfo is not broken on WinNT.
            SYSTEM_INFO si;

            GetSystemInfo(&si);
            if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL &&
                si.wProcessorLevel >= 5)
            {
#endif
                __try
                    {
                        if( _asm_isMMX() )
                        {

                            // Emit an emms instruction.
                            // This file needs to compile for non-Pentium
                            // processors
                            // so we can't use use inline asm since we're in the
                            // wrong
                            // processor mode.
                            __asm __emit 0xf;
                            __asm __emit 0x77;
                            isMMX = TRUE;
                            D3D_INFO(1, "MMX detected");
                        }
                    }
                __except(GetExceptionCode() == STATUS_ILLEGAL_INSTRUCTION ?
                         EXCEPTION_EXECUTE_HANDLER :
                         EXCEPTION_CONTINUE_SEARCH)
                    {
                    }
#ifndef WIN95
            }

        }
#endif
#endif
    }
    return isMMX;
}

#ifdef _X86_

extern BOOL isX3Dprocessor(void);
//---------------------------------------------------------------------
// Detects PentiumII/Katmai processor
//
#pragma optimize("", off)
#define CPUID _asm _emit 0x0f _asm _emit 0xa2

BOOL IsPentiumIIProcessor(void)
{
    DWORD RegisterEAX;
        char VendorId[12];
        const char IntelId[13]="GenuineIntel";

        __try
        {
            _asm {
                xor         eax,eax
                CPUID
                mov             RegisterEAX, eax
                mov             dword ptr VendorId, ebx
                mov             dword ptr VendorId+4, edx
                mov             dword ptr VendorId+8, ecx
            }
        } __except (1)
        {
                return FALSE;
        }

        // make sure EAX is > 0 which means the chip
        // supports a value of 1 which is the chip info
        if (RegisterEAX == 0)
                return FALSE;

        // make sure chip is "GenuineIntel"
        for (int i=0; i<12; i++)
                if (VendorId[i] != IntelId[i])
                        return FALSE;

        __try
        {
            _asm {
                mov    eax, 1
                CPUID
                mov    RegisterEAX, eax
                }
        } __except (1)
        {
                return FALSE;
        }

        // EAX[3:0] = stepping id
        // EAX[7:4] = model = 0001 (Pentium Pro), 0011 and 0101 (Pentium II)
        // EAX[11:8] = family = 0110
        // EAX[13:12] = processor type = 00
        if ((RegisterEAX & 0x3F00) != 0x0600)   // test for processor type & family
                return FALSE;
        RegisterEAX = (RegisterEAX & 0xf0);     // test for model
        if (RegisterEAX >= 0x30)  // add RegisterEAX == 0x10 for Pentium Pro
                return TRUE;
        else
                return FALSE;
}

BOOL IsKatmaiProcessor(void)
{
        DWORD RegisterEAX;
        char VendorId[12];
        const char IntelId[13]="GenuineIntel";

        __try
        {
                _asm {
            xor         eax,eax
            CPUID
                mov             RegisterEAX, eax
                mov             dword ptr VendorId, ebx
                mov             dword ptr VendorId+4, edx
                mov             dword ptr VendorId+8, ecx
                }
        } __except (1)
        {
                return FALSE;
        }

        // make sure EAX is > 0 which means the chip
        // supports a value >=1. 1 = chip info
        if (RegisterEAX == 0)
                return FALSE;

        // make sure chip is "GenuineIntel"
        for (int i=0; i<12; i++)
                if (VendorId[i] != IntelId[i])
                        return FALSE;

        // this CPUID can't fail if the above test passed
        _asm {
            mov         eax, 1
            CPUID
                mov             RegisterEAX, eax
        }

        // EAX[3:0] = stepping id
        // EAX[7:4] = model = 0001 (Pentium Pro), 0011 and 0101 (Pentium II)
        // EAX[11:8] = family = 0110
        // EAX[13:12] = processor type = 00
        RegisterEAX = (RegisterEAX & 0x3FF0);   // test for model
        if (RegisterEAX >= 0x670)        // Katmai or newer
                return TRUE;
        else
                return FALSE;
}

#pragma optimize("", on)

#ifdef WIN95 // and Win98...
//---------------------------------------------------------------------
BOOL
IsWin95(void)
{
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx(&osvi))
    {
        D3D_INFO(1,"GetVersionEx failed - assuming Win95");
        return TRUE;
    }

    if ( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
    {

        if( ( osvi.dwMajorVersion > 4UL ) ||
            ( ( osvi.dwMajorVersion == 4UL ) &&
              ( osvi.dwMinorVersion >= 10UL ) &&
              ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
        {
            // is Win98
            D3D_INFO(2,"Detected Win98");
            return FALSE;
        }
        else
        {
            // is Win95
            D3D_INFO(2,"Detected Win95");
            return TRUE;
        }
    }
    else if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        D3D_INFO(2,"Detected WinNT");
        return FALSE;
    }
    D3D_INFO(2,"OS Detection failed");
    return TRUE;
}
#endif  // WIN95

//---------------------------------------------------------------------
//
//  void GetProcessorFamily(LPDWORD lpdwFamily);
//
//      Passes back 3, 4, 5, 6 for 386, 486, Pentium, PPro class machines
//
#pragma optimize("", off)
void
GetProcessorFamily(LPDWORD lpdwFamily, LPDWORD lpdwCPUFeatures)
{
    SYSTEM_INFO si;
    __int64     start, end, freq;
    int         flags,family;
    int         time;
    int         clocks;
    DWORD       oldclass;
    HANDLE      hprocess;

    // guilty until proven otherwise
    *lpdwCPUFeatures = D3DCPU_BLOCKINGREAD;

    if ( isMMXprocessor() )
    {
        *lpdwCPUFeatures |= D3DCPU_MMX;
    }

    ZeroMemory(&si, sizeof(si));
    GetSystemInfo(&si);

    //Set the family. If wProcessorLevel is not specified, dig it out of dwProcessorType
    //Because wProcessor level is not implemented on Win95
    if (si.wProcessorLevel)
    {
        *lpdwFamily=si.wProcessorLevel;
    }
    else
    {
        //Ok, we're on Win95
        switch (si.dwProcessorType)
        {
            case PROCESSOR_INTEL_386:
                *lpdwFamily=3;
                break;

            case PROCESSOR_INTEL_486:
                *lpdwFamily=4;
                break;
            default:
                *lpdwFamily=0;
                break;
        }
    }

    //
    // make sure this is a INTEL Pentium (or clone) or higher.
    //
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
        return;

    if (si.dwProcessorType < PROCESSOR_INTEL_PENTIUM)
        return;

    //
    // see if this chip supports rdtsc before using it.
    //
    __try
    {
        _asm
        {
            xor     eax,eax
            _emit   00fh    ;; CPUID
            _emit   0a2h
            mov     dword ptr szCPUString,ebx
            mov     dword ptr szCPUString+8,ecx
            mov     dword ptr szCPUString+4,edx
            mov     byte ptr szCPUString+12,0
            mov     eax,1
            _emit   00Fh     ;; CPUID
            _emit   0A2h
            mov     flags,edx
            mov     family,eax
        }
    }
    __except(1)
    {
        flags = 0;
    }

    //check for support of CPUID and fail
    if (!(flags & 0x10))
        return;

    // fcomi and FPU features both set
    if ( (flags&(1<<15)) && (flags & (1<<0)) )
    {
        D3D_INFO(2, "Pentium Pro CPU features (fcomi, cmov) detected");
        *lpdwCPUFeatures |= D3DCPU_FCOMICMOV;
    }

    //If we don't have a family, set it now
    //Family is bits 11:8 of eax from CPU, with eax=1
    if (!(*lpdwFamily))
    {
       *lpdwFamily=(family& 0x0F00) >> 8;
    }
    // not aware of any non-Intel processors w/non blocking reads
    if ( (! strcmp(szCPUString, "GenuineIntel")) &&
         *lpdwFamily > 5)
    {
        *lpdwCPUFeatures &= ~D3DCPU_BLOCKINGREAD;
    }

    if ( isX3Dprocessor() )
    {
        D3D_INFO(2, "X3D Processor detected for PSGP");
        *lpdwCPUFeatures |= D3DCPU_X3D;
    }

    if ( IsPentiumIIProcessor() )
    {
        D3D_INFO(2, "PentiumII Processor detected for PSGP");
        *lpdwCPUFeatures |= D3DCPU_PII;
    }

    if ( IsKatmaiProcessor() )
    {
        D3D_INFO(2, "Katmai Processor detected for PSGP");
        *lpdwCPUFeatures |= D3DCPU_KATMAI;
    }
    return;
}
#pragma optimize("", on)

#endif // _X86_

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwType, dwSize = sizeof(dwHWFewVertices);
    char filename[_MAX_PATH];

    switch( ul_reason_for_call ) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls( hModule );
        DPFINIT();
        MemInit();
#ifdef WIN95
        GetpWin16Lock(&lpWin16Lock);
#endif

#ifdef _X86_
        GetProcessorFamily(&dwCPUFamily, &dwCPUFeatures);
        D3D_INFO(3, "dwCPUFamily = %d, dwCPUFeatures = %d", dwCPUFamily, dwCPUFeatures);
        D3D_INFO(3, "szCPUString = %s", szCPUString);
#endif

#ifdef WIN95 // and Win98...
    // Katmai NI does not work on Win95, so see if we are on Win95 and disable
    //
    {
        BOOL bIsWin95 = IsWin95();
        if ((dwCPUFeatures & D3DCPU_KATMAI) && bIsWin95)
        {
            D3D_INFO(1,"Disabling KNI support on Win95");
            dwCPUFeatures &= ~D3DCPU_KATMAI;
        }
    }
#endif

#ifdef _X86_
    if ( dwCPUFeatures & D3DCPU_X3D )
       pfnFEContextCreate = px3DContextCreate;
    else if ( dwCPUFeatures & D3DCPU_KATMAI )
       pfnFEContextCreate = katmai_FEContextCreate;
    else if ( dwCPUFeatures & D3DCPU_PII )
       pfnFEContextCreate = pii_FEContextCreate;
#endif

        // Unfounded default value. 128*40 (vertex+D3DTRIANGLE struct)=5K
        // The assumption is that the primary cache hasn't got much better
        // to do than contain the vertex and index data.
        dwD3DTriBatchSize = 80;
        // Work item: do something more intelligent here than assume that
        // MMX-enabled processors have twice as much primary cache.
        if ( isMMXprocessor() )
            dwD3DTriBatchSize *= 2;
        dwTriBatchSize = (dwD3DTriBatchSize * 4) / 3;
        dwLineBatchSize = dwD3DTriBatchSize * 2;
        dwHWBufferSize = dwD3DTriBatchSize * (sizeof(D3DTLVERTEX) + sizeof(D3DTRIANGLE));
        dwHWMaxTris = dwD3DTriBatchSize;
        lRet = RegOpenKey( HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey );
        if ( lRet == ERROR_SUCCESS )
        {
            lRet = RegQueryValueEx(hKey,
                                   "FewVertices",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwHWFewVertices,
                                   &dwSize);
            if (lRet != ERROR_SUCCESS ||
                dwType != REG_DWORD ||
                dwHWFewVertices < 4 ||
                dwHWFewVertices > 128)

                dwHWFewVertices = 24;

// disabling 'GeometryDriver' DLL interface until it is less abusable...
#if 0
            dwSize = sizeof(filename);
            lRet = RegQueryValueEx(hKey,
                                   "GeometryDriver",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) filename,
                                   &dwSize);
            if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
            {
                hGeometryDLL = LoadLibrary(filename);
                if (hGeometryDLL)
                {
                    pfnFEContextCreate = (LPD3DFE_CONTEXTCREATE) GetProcAddress(hGeometryDLL, "FEContextCreate");
                }
            }
#endif
            RegCloseKey( hKey );
        }
        else
        {
            dwHWFewVertices = 24;
        }
        // Set the app name to reg.
        SetMostRecentApp();
        break;
    case DLL_PROCESS_DETACH:
        MemFini();
        if (NULL != hGeometryDLL)
            FreeLibrary(hGeometryDLL);
        break;
    default:
        ;
    }
    return TRUE;
}

// --------------------------------------------------------------------------
// This function is called at process attach time to put the name of current
// app to registry.
// --------------------------------------------------------------------------
void SetMostRecentApp(void)
{
    char    fname[_MAX_PATH];
    char    name[_MAX_PATH];
    int     i;
    HKEY    hKey;
    HANDLE  hFile;

    // Find out what process we are dealing with
    hFile =  GetModuleHandle( NULL );
    GetModuleFileName( (HINSTANCE)hFile, fname, sizeof( fname ) );
    DPF( 3, "full name  = %s", fname );
    i = strlen( fname )-1;
    while( i >=0 && fname[i] != '\\' )
    {
        i--;
    }
    i++;
    strcpy( name, &fname[i] );
    DPF( 3, "name       = %s", name );

    // Now write the name into some known place
        if( !RegCreateKey( HKEY_LOCAL_MACHINE,
             RESPATH_D3D "\\" REGSTR_KEY_LASTAPP, &hKey ) )
    {
        RegSetValueEx(hKey, REGSTR_VAL_DDRAW_NAME, 0, REG_SZ, (LPBYTE)name, strlen(name)+1);
        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\dphal.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphal.c
 *  Content:    DrawPrimitive implementation for DrawPrimitive HALs
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "drawprim.hpp"
#include "clipfunc.h"
#include "d3dfei.h"

extern const DWORD LOWVERTICESNUMBER = 20;

#if DBG
extern DWORD FaceCount;
DWORD FaceCount = 0;
DWORD StartFace = 0;
DWORD EndFace = 10000;
#endif

extern void SetDebugRenderState(DWORD value);

#define ALIGN32(x) x = ((DWORD)(x + 31)) & (~31);
//---------------------------------------------------------------------
// Array to map D3DVERTEXTYPE to FVF vertex type
//
DWORD d3dVertexToFVF[4] =
{
    0,
    D3DFVF_VERTEX,
    D3DFVF_LVERTEX,
    D3DFVF_TLVERTEX
};
//---------------------------------------------------------------------
// Handles strides and FVF
//
#undef DPF_MODNAME
#define DPF_MODNAME "D3DFE_updateExtents"

void D3DFE_updateExtents(LPDIRECT3DDEVICEI lpDevI)
{
    int i;
    D3DVECTOR *v = (D3DVECTOR*)lpDevI->position.lpvData;
    DWORD stride = lpDevI->position.dwStride;
    for (i = lpDevI->dwNumVertices; i; i--)
    {
        if (v->x < lpDevI->rExtents.x1)
            lpDevI->rExtents.x1 = v->x;
        if (v->x > lpDevI->rExtents.x2)
            lpDevI->rExtents.x2 = v->x;
        if (v->y < lpDevI->rExtents.y1)
            lpDevI->rExtents.y1 = v->y;
        if (v->y > lpDevI->rExtents.y2)
            lpDevI->rExtents.y2 = v->y;
        v = (D3DVECTOR*)((char*)v + stride);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "MapFVFtoTLVertex1"

inline void MapFVFtoTLVertex1(LPDIRECT3DDEVICEI lpDevI, D3DTLVERTEX *pOut,
                              DWORD *pIn)
{
// Copy position
    pOut->sx  = *(D3DVALUE*)pIn++;
    pOut->sy  = *(D3DVALUE*)pIn++;
    pOut->sz  = *(D3DVALUE*)pIn++;
    pOut->rhw = *(D3DVALUE*)pIn++;
// Other fields: diffuse, specular, texture
    if (lpDevI->dwVIDOut & D3DFVF_DIFFUSE)
        pOut->color = *pIn++;
    else
    {
        pOut->color = __DEFAULT_DIFFUSE;
    }
    if (lpDevI->dwVIDOut & D3DFVF_SPECULAR)
        pOut->specular = *pIn++;
    else
    {
        pOut->specular= __DEFAULT_SPECULAR;
    }
    if (lpDevI->nTexCoord)
    {
        pIn = &pIn[lpDevI->dwTextureIndexToCopy << 1];
        pOut->tu = *(D3DVALUE*)&pIn[0];
        pOut->tv = *(D3DVALUE*)&pIn[1];
    }
    else
    {
        pOut->tu = 0;
        pOut->tv = 0;
    }
}
//---------------------------------------------------------------------
// All vertices from lpDevI->lpVout are copied to the output buffer, expanding
// to D3DTLVERTEX.
// The output buffer is lpAddress if it is not NULL, otherwise it is TLVbuf
//
#undef DPF_MODNAME
#define DPF_MODNAME "MapFVFtoTLVertex"

HRESULT MapFVFtoTLVertex(LPDIRECT3DDEVICEI lpDevI, LPVOID lpAddress)
{
    int i;
    DWORD size = lpDevI->dwNumVertices * sizeof(D3DTLVERTEX);
    D3DTLVERTEX *pOut;
    if (lpAddress)
        pOut = (D3DTLVERTEX*)lpAddress;
    else
    {
    // See if TL buffer has sufficient space
        if (size > lpDevI->TLVbuf.GetSize())
        {
            if (lpDevI->TLVbuf.Grow(lpDevI, size) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
        }
        pOut = (D3DTLVERTEX*)lpDevI->TLVbuf.GetAddress();
    }
// Map vertices
    DWORD *pIn = (DWORD*)lpDevI->lpvOut;
    for (i=lpDevI->dwNumVertices; i; i--)
    {
        MapFVFtoTLVertex1(lpDevI, pOut, pIn);
        pOut++;
        pIn = (DWORD*)((char*)pIn + lpDevI->dwOutputSize);
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CheckDrawPrimitive"

HRESULT CheckDrawPrimitive(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_PROCESSVERTICES* data = lpDevI;
    HRESULT ret = CheckDeviceSettings(lpDevI);
    if (ret != D3D_OK)
        return ret;
    if (!data->dwNumVertices)
    {
        D3D_ERR( "Invalid dwNumVertices in DrawPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    if(data->position.lpvData==NULL) {
        D3D_ERR( "Invalid lpvVertices param in DrawPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    switch (data->primType)
    {
    case D3DPT_POINTLIST:
                break;
    case D3DPT_LINELIST:
        if (data->dwNumVertices & 1)
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_LINESTRIP:
        if (data->dwNumVertices == 1)
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (data->dwNumVertices < 3)
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLELIST:
        if ( (data->dwNumVertices % 3) != 0 )
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    default:
        D3D_ERR( "Unknown or unsupported primitive type requested of DrawPrimitive" );
        return D3DERR_INVALIDPRIMITIVETYPE;
    }

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CheckDrawIndexedPrimitive"

HRESULT
CheckDrawIndexedPrimitive(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_PROCESSVERTICES *data = lpDevI;
    DWORD i;

    HRESULT ret = CheckDeviceSettings(lpDevI);
    if (ret != D3D_OK)
        return ret;
    if (data->dwNumVertices <= 0 || data->dwNumIndices <= 0)
    {
        D3D_ERR( "Invalid dwNumVertices or dwNumIndices in DrawIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    if (data->dwNumVertices > 65535ul )
    {
        D3D_ERR( "DrawIndexedPrimitive vertex array > 64K" );
        return DDERR_INVALIDPARAMS;
    }

    if((data->lpwIndices==NULL) || IsBadReadPtr(data->lpwIndices,data->dwNumIndices*sizeof(WORD))) {
        D3D_ERR( "Invalid lpwIndices param in DrawIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    if(data->position.lpvData==NULL) {
        D3D_ERR( "Invalid lpvVertices param in DrawIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    switch (data->primType)
    {
    case D3DPT_LINELIST:
        if (data->dwNumIndices & 1)
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_LINESTRIP:
        if (data->dwNumIndices == 1)
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (data->dwNumIndices < 3)
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLELIST:
        if ( (data->dwNumIndices % 3) != 0 )
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    default:
        D3D_ERR( "Unknown or unsupported primitive type requested of DrawIndexedPrimitive" );
        return D3DERR_INVALIDPRIMITIVETYPE;
    }
    for (i=0; i < data->dwNumIndices; i++)
    {
        if (data->lpwIndices[i] >= data->dwNumVertices)
        {
            D3D_ERR( "Invalid index value in DrawIndexedPrimitive" );
            return DDERR_INVALIDPARAMS;
        }
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// Draws non-indexed primitives which do not require clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrim"

#define __DRAWPRIMFUNC
#include "dpgen.h"
//---------------------------------------------------------------------
// Draws indexed primitives which do not require clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrim"

#define __DRAWPRIMFUNC
#define __DRAWPRIMINDEX
#include "dpgen.h"
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "FlushStatesDP"

HRESULT
CDirect3DDeviceIDP::FlushStates()
{
    HRESULT dwRet=D3D_OK;
    FlushTextureFromDevice( this ); // delink all texture surfaces
    if (this->dwDPOffset>sizeof(D3DHAL_DRAWPRIMCOUNTS))
    {
        if ((dwRet=CheckSurfaces()) != D3D_OK)
        {
            this->dwDPOffset = sizeof(D3DHAL_DRAWPRIMCOUNTS);
            this->lpDPPrimCounts = (LPD3DHAL_DRAWPRIMCOUNTS)this->lpwDPBuffer;
            memset( (char *)this->lpwDPBuffer,0,sizeof(D3DHAL_DRAWPRIMCOUNTS)); //Clear header also
            if (dwRet == DDERR_SURFACELOST)
            {
                this->dwFEFlags |= D3DFE_LOSTSURFACES;
                return D3D_OK;
            }
            return dwRet;
        }

        D3DHAL_DRAWPRIMITIVESDATA dpData;
        DWORD   dwDPOffset;
        if (this->lpDPPrimCounts->wNumVertices)    //this->lpDPPrimCounts->wNumVertices==0 means the end
        {                      //force it if not
            memset(((LPBYTE)this->lpwDPBuffer+this->dwDPOffset),0,sizeof(D3DHAL_DRAWPRIMCOUNTS));
        }
        dpData.dwhContext = this->dwhContext;
        dpData.dwFlags =  0;
        dpData.lpvData = this->lpwDPBuffer;
        if (FVF_DRIVERSUPPORTED(this))
            dpData.dwFVFControl = this->dwCurrentBatchVID;
        else
        {
            if (this->dwDebugFlags & D3DDEBUG_DISABLEFVF)
                dpData.dwFVFControl = D3DFVF_TLVERTEX;
            else
                dpData.dwFVFControl = 0;    //always zero for non-FVF drivers
        }
        dpData.ddrval = 0;
        dwDPOffset=this->dwDPOffset;  //save it in case Flush returns prematurely
#if 0
        if (D3DRENDERSTATE_TEXTUREHANDLE==*((DWORD*)this->lpwDPBuffer+2))
        DPF(0,"Flushing dwDPOffset=%08lx ddihandle=%08lx",dwDPOffset,*((DWORD*)this->lpwDPBuffer+3));
#endif  //0
        //we clear this to break re-entering as SW rasterizer needs to lock DDRAWSURFACE
        this->dwDPOffset = sizeof(D3DHAL_DRAWPRIMCOUNTS);

        // Spin waiting on the driver if wait requested
#if _D3D_FORCEDOUBLE
        CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE
        do {
#ifndef WIN95
            if((dwRet = CheckContextSurface(this)) != D3D_OK)
            {
                this->dwDPOffset = dwDPOffset;
                return (dwRet);
            }
#endif //WIN95
            CALL_HAL2ONLY(dwRet, this, DrawPrimitives, &dpData);
            if (dwRet != DDHAL_DRIVER_HANDLED)
            {
                D3D_ERR ( "Driver call for DrawOnePrimitive failed" );
                // Need sensible return value in this case,
                // currently we return whatever the driver stuck in here.
            }
        } while (dpData.ddrval == DDERR_WASSTILLDRAWING);
        this->lpDPPrimCounts = (LPD3DHAL_DRAWPRIMCOUNTS)this->lpwDPBuffer;
        memset( (char *)this->lpwDPBuffer,0,sizeof(D3DHAL_DRAWPRIMCOUNTS));   //Clear header also
        dwRet= dpData.ddrval;
        this->dwCurrentBatchVID = this->dwVIDOut;
    }
    return dwRet;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DoDrawPrimitive"

HRESULT DoDrawPrimitive(LPD3DFE_PROCESSVERTICES pv)
{
    HRESULT ret;

    if (!CheckIfNeedClipping(pv))
        return pv->DrawPrim();

    // Preserve primitive type for large begin-end primitives
    // Primitive type could be changed by the clipper
    D3DPRIMITIVETYPE oldPrimType = pv->primType;
    switch (pv->primType)
    {
    case D3DPT_POINTLIST:
        ret = ProcessClippedPoints(pv);
        break;
    case D3DPT_LINELIST:
        ret = ProcessClippedLine(pv);
        break;
    case D3DPT_LINESTRIP:
        ret = ProcessClippedLine(pv);
        break;
    case D3DPT_TRIANGLELIST:
        ret = ProcessClippedTriangleList(pv);
        break;
    case D3DPT_TRIANGLESTRIP:
        ret = ProcessClippedTriangleStrip(pv);
        break;
    case D3DPT_TRIANGLEFAN:
        ret = ProcessClippedTriangleFan(pv);
        break;
    default:
        ret = DDERR_GENERIC;
        break;
    }
    ClampExtents(pv);
    pv->primType = oldPrimType;
    return ret;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DoDrawIndexedPrimitive"

HRESULT DoDrawIndexedPrimitive(LPD3DFE_PROCESSVERTICES pv)
{
    HRESULT ret;

    if (!CheckIfNeedClipping(pv))
        return pv->DrawIndexPrim();

    // Preserve primitive type for large begin-end primitives
    // Primitive type could be changed by the clipper
    D3DPRIMITIVETYPE oldPrimType = pv->primType;
    switch (pv->primType)
    {
    case D3DPT_LINELIST:
        ret = ProcessClippedIndexedLine(pv);
        break;
    case D3DPT_LINESTRIP:
        ret = ProcessClippedIndexedLine(pv);
        break;
    case D3DPT_TRIANGLELIST:
        ret = ProcessClippedIndexedTriangleList(pv);
            break;
    case D3DPT_TRIANGLEFAN:
        ret = ProcessClippedIndexedTriangleFan(pv);
        break;
    case D3DPT_TRIANGLESTRIP:
        ret = ProcessClippedIndexedTriangleStrip(pv);
        break;
    default:
        break;
    }
    ClampExtents(pv);
    pv->primType = oldPrimType;
    return ret;
}
//---------------------------------------------------------------------
// ProcessPrimitive processes indexed, non-indexed primitives or
// vertices only as defined by "op"
//
// op = __PROCPRIMOP_NONINDEXEDPRIM by default
//
HRESULT DIRECT3DDEVICEI::ProcessPrimitive(__PROCPRIMOP op)
{
    HRESULT ret=D3D_OK;
    DWORD vertexPoolSize;
    // Update vertex stats
    this->D3DStats.dwVerticesProcessed += this->dwNumVertices;
        DWORD dwCurrPrimVertices = this->dwNumVertices;

    // Need to call UpdateTextures()
    this->dwFEFlags |= D3DFE_NEED_TEXTURE_UPDATE;

    // Viewport ID could be different from Device->v_id, because during Execute call
    // Device->v_id is changed to whatever viewport is used as a parameter.
    // So we have to make sure that we use the right viewport.
    //
    LPDIRECT3DVIEWPORTI lpView = this->lpCurrentViewport;
    if (this->v_id != lpView->v_id)
    {
        HRESULT ret = downloadView(lpView);
        if (ret != D3D_OK)
            return ret;
    }

// We need to grow TL vertex buffer if
// 1. We have to transform vertices
// 2. We do not have to transform vertices and
//    2.1 Ramp mode is used, because we have to change vertex colors
//    2.2 DP2HAL is used and we have small number of vertices, so we need to
//        copy vertices into TL buffer
//
    vertexPoolSize = this->dwNumVertices * this->dwOutputSize;
    if ((!FVF_TRANSFORMED(this->dwVIDIn)) ||
        (this->dwDeviceFlags & D3DDEV_RAMP))
    {
        if (vertexPoolSize > this->TLVbuf.GetSize())
        {
            if (this->TLVbuf.Grow(this, vertexPoolSize) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
        }
        if (IS_DP2HAL_DEVICE(this))
        {
            CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
            ret = dev->StartPrimVB(this->TLVbuf.GetVBI(), 0);
            if (ret != D3D_OK)
                return ret;
        }
        this->lpvOut = this->TLVbuf.GetAddress();
    }

// Grow clip flags buffer if we need clipping
//
    if (!(this->dwFlags & D3DDP_DONOTCLIP))
    {
        DWORD size = this->dwNumVertices * sizeof(D3DFE_CLIPCODE);
        if (size > this->HVbuf.GetSize())
        {
            if (this->HVbuf.Grow(size) != D3D_OK)
            {
                D3D_ERR( "Could not grow clip buffer" );
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
        }
        this->lpClipFlags = (D3DFE_CLIPCODE*)this->HVbuf.GetAddress();
    }

    if (FVF_TRANSFORMED(this->dwVIDIn))
    {
        if (this->dwDeviceFlags & D3DDEV_RAMP)
        {
            ConvertColorsToRamp(this,
                                (D3DTLVERTEX*)this->position.lpvData,
                                (D3DTLVERTEX*)(this->lpvOut),
                                this->dwNumVertices);
        }
        else
        {
            // Pass vertices directly from the user memory
            this->dwVIDOut = this->dwVIDIn;
            this->dwOutputSize = this->position.dwStride;
            this->lpvOut = this->position.lpvData;
            vertexPoolSize = this->dwNumVertices * this->dwOutputSize;

            if (IS_DP2HAL_DEVICE(this))
            {
                CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
                dev->StartPrimUserMem(this->position.lpvData);
                if (ret != D3D_OK)
                    return ret;
            }
        }
        if (this->dwFlags & D3DDP_DONOTCLIP)
        {
            if (!(this->dwFlags & D3DDP_DONOTUPDATEEXTENTS))
                D3DFE_updateExtents(this);

            if (op == __PROCPRIMOP_INDEXEDPRIM)
            {
                ret = this->DrawIndexPrim();
            }
            else if (op == __PROCPRIMOP_NONINDEXEDPRIM)
            {
                ret = this->DrawPrim();
            }
            goto l_exit;
        }
        else
        {
            // Clear clip union and intersection flags
            this->dwClipIntersection = 0;
            this->dwClipUnion = 0;
            DWORD clip_intersect;
            clip_intersect = this->pGeometryFuncs->GenClipFlags(this);
            D3DFE_UpdateClipStatus(this);
            if (!clip_intersect)
            {
                this->dwFlags |= D3DPV_TLVCLIP;
                if (op == __PROCPRIMOP_INDEXEDPRIM)
                {
                    ret = DoDrawIndexedPrimitive(this);
                }
                else if (op == __PROCPRIMOP_NONINDEXEDPRIM)
                {
                    ret = DoDrawPrimitive(this);
                }
                goto l_exit;
            }
        }
    }
    else
    {
        // Clear clip union and intersection flags
        this->dwClipIntersection = 0;
        this->dwClipUnion = 0;

        // Update Lighting and related flags
        if ((ret = DoUpdateState(this)) != D3D_OK)
            return ret;

        // Call PSGP or our implementation
        if (op == __PROCPRIMOP_INDEXEDPRIM)
            ret = this->pGeometryFuncs->ProcessIndexedPrimitive(this);
        else if (op == __PROCPRIMOP_NONINDEXEDPRIM)
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
        else
            ret = this->pGeometryFuncs->ProcessVertices(this);

        D3DFE_UpdateClipStatus(this);
    }
l_exit:
    if (IS_DP2HAL_DEVICE(this))
    {
        CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
        if (op != __PROCPRIMOP_PROCVERONLY)
            ret = dev->EndPrim(vertexPoolSize);
    }
    return ret;
}
//---------------------------------------------------------------------
// This function is called when a number of indices in an indexed primitive
// is much less than a number of vertices. In this case we build non-indexed
// primitives.
HRESULT DereferenceIndexedPrim(LPDIRECT3DDEVICEI lpDevI)
{
    HRESULT ret = CheckVertexBatch(lpDevI);
    if (ret != D3D_OK)
        return ret;

    // Save original vertice and number of primitives
    D3DVERTEX *lpvVertices = (D3DVERTEX*)lpDevI->position.lpvData;
    DWORD dwNumPrimitivesOrg = lpDevI->dwNumPrimitives;
    WORD *lpwIndices = lpDevI->lpwIndices;
    // We will dereference here
        D3DVERTEX *lpVertex = (D3DVERTEX*)lpDevI->lpvVertexBatch;
    lpDevI->position.lpvData = lpVertex;
    lpDevI->lpwIndices = NULL;

    switch (lpDevI->primType)
    {
        case D3DPT_LINELIST:
        {
            for (DWORD j=0; j < dwNumPrimitivesOrg; j += BEGIN_DATA_BLOCK_SIZE/2)
            {
                lpDevI->dwNumPrimitives = min(dwNumPrimitivesOrg - j,
                                              (BEGIN_DATA_BLOCK_SIZE/2));
                lpDevI->dwNumVertices = lpDevI->dwNumPrimitives << 1;
                D3DVERTEX *lpTmp = lpVertex;
                for (DWORD i=lpDevI->dwNumVertices; i; i--)
                {
                    *lpTmp++ = lpvVertices[*lpwIndices++];
                }
                ret = lpDevI->ProcessPrimitive();
                if (ret != D3D_OK)
                    return ret;
            }
            break;
        }
        case D3DPT_LINESTRIP:
        {
                        for (DWORD j=0; j < dwNumPrimitivesOrg; j+= BEGIN_DATA_BLOCK_SIZE-1)
            {
                                lpDevI->dwNumPrimitives = min(dwNumPrimitivesOrg-j,
                                              (BEGIN_DATA_BLOCK_SIZE-1));
                lpDevI->dwNumVertices = lpDevI->dwNumPrimitives + 1;
                D3DVERTEX *lpTmp = lpVertex;
                                for (DWORD i=lpDevI->dwNumVertices; i; i--)
                {
                                        *lpTmp++ = lpvVertices[*lpwIndices++];
                                }
                                lpwIndices--;   // back off one so the next batch is connected
                                ret = lpDevI->ProcessPrimitive();
                                if (ret != D3D_OK)
                                        return ret;
                        }
                        break;
        }
        case D3DPT_TRIANGLEFAN:
        {
                lpVertex[0] = lpvVertices[*lpwIndices++];
                        for (DWORD j=0; j < dwNumPrimitivesOrg; j+= BEGIN_DATA_BLOCK_SIZE-2)
            {
                                lpDevI->dwNumPrimitives = min(dwNumPrimitivesOrg - j,
                                              (BEGIN_DATA_BLOCK_SIZE-2));
                lpDevI->dwNumVertices = lpDevI->dwNumPrimitives + 2;
                D3DVERTEX *lpTmp = &lpVertex[1];
                                for (DWORD i=lpDevI->dwNumVertices-1; i; i--)
                {
                                        *lpTmp++ = lpvVertices[*lpwIndices++];
                                }
                                lpwIndices--;   // back off one so the next batch is connected
                                ret = lpDevI->ProcessPrimitive();
                                if (ret != D3D_OK)
                                        return ret;
                        }
                        break;
        }
        case D3DPT_TRIANGLESTRIP:
        {
            for (DWORD j=0; j < dwNumPrimitivesOrg; j+= BEGIN_DATA_BLOCK_SIZE-2)
            {
                lpDevI->dwNumPrimitives = min(dwNumPrimitivesOrg-j,
                                              (BEGIN_DATA_BLOCK_SIZE-2));
                lpDevI->dwNumVertices = lpDevI->dwNumPrimitives + 2;
                D3DVERTEX *lpTmp = lpVertex;
                for (DWORD i=lpDevI->dwNumVertices; i; i--)
                {
                    *lpTmp++ = lpvVertices[*lpwIndices++];
                }
                lpwIndices-= 2; // back off so the next batch is connected
                ret = lpDevI->ProcessPrimitive();
                if (ret != D3D_OK)
                    return ret;
            }
            break;
        }
        case D3DPT_TRIANGLELIST:
        {
            for (DWORD j=0; j < dwNumPrimitivesOrg; j+= BEGIN_DATA_BLOCK_SIZE/3)
            {
                lpDevI->dwNumPrimitives = min(dwNumPrimitivesOrg-j,
                                              (BEGIN_DATA_BLOCK_SIZE/3));
                lpDevI->dwNumVertices = lpDevI->dwNumPrimitives * 3;
                D3DVERTEX *lpTmp = lpVertex;
                for (DWORD i=lpDevI->dwNumVertices; i; i--)
                {
                        *lpTmp++ = lpvVertices[*lpwIndices++];
                }
                ret = lpDevI->ProcessPrimitive();
                if (ret != D3D_OK)
                        return ret;
            }
            break;
        }
        }
        return D3D_OK;
}
//---------------------------------------------------------------------
//                              API calls
//---------------------------------------------------------------------

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveStrided"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawPrimitiveStrided(
                             D3DPRIMITIVETYPE PrimitiveType,
                             DWORD dwVertexType,
                             LPD3DDRAWPRIMITIVESTRIDEDDATA lpDrawData,
                             DWORD dwNumVertices,
                             DWORD dwFlags)
{
    HRESULT        ret = D3D_OK;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
    if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;
    Profile(PROF_DRAWPRIMITIVESTRIDED,PrimitiveType,dwVertexType);
#endif
    //note: this check should be done in retail as well as dbg build
    if((dwVertexType & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
        return D3DERR_INVALIDVERTEXTYPE;
    this->primType = PrimitiveType;
    this->dwVIDIn  = dwVertexType;
    this->position = lpDrawData->position;
    this->normal = lpDrawData->normal;
    this->diffuse = lpDrawData->diffuse;
    this->specular = lpDrawData->specular;
    ComputeOutputFVF(this);
    for (DWORD i=0; i < this->nTexCoord; i++)
        this->textures[i] = lpDrawData->textureCoords[i];
    this->dwNumVertices = dwNumVertices;
    this->lpwIndices = NULL;
    this->dwNumIndices = 0;
    this->lpClipFlags = (D3DFE_CLIPCODE*)HVbuf.GetAddress();
    this->dwFlags = dwFlags | D3DPV_STRIDE;
    if (this->dwVIDIn & D3DFVF_NORMAL)
        this->dwFlags |= D3DPV_LIGHTING;

    GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives and update stats

#if DBG
    if (this->dwNumVertices > MAX_DX6_VERTICES)
    {
        D3D_ERR("D3D for DX6 cannot handle greater than 64K vertices");
        return D3DERR_TOOMANYVERTICES;
    }
    ret = CheckDrawPrimitive(this);

    if (ret != D3D_OK)
    {
        return ret;
    }
#endif
    return this->ProcessPrimitive();
}   // end of DrawPrimitiveStrided()
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrimitiveStrided"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawIndexedPrimitiveStrided(
                                 D3DPRIMITIVETYPE PrimitiveType,
                                 DWORD dwVertexType,
                                 LPD3DDRAWPRIMITIVESTRIDEDDATA lpDrawData,
                                 DWORD dwNumVertices,
                                 LPWORD lpwIndices,
                                 DWORD dwNumIndices,
                                 DWORD dwFlags)
{
    HRESULT        ret = D3D_OK;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
    if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;
    Profile(PROF_DRAWINDEXEDPRIMITIVESTRIDED,PrimitiveType,dwVertexType);
#endif
    //note: this check should be done in retail as well as dbg build
    if((dwVertexType & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
        return D3DERR_INVALIDVERTEXTYPE;
    this->primType = PrimitiveType;
    this->dwVIDIn  = dwVertexType;
    this->position = lpDrawData->position;
    this->normal = lpDrawData->normal;
    this->diffuse = lpDrawData->diffuse;
    this->specular = lpDrawData->specular;
    ComputeOutputFVF(this);
    for (DWORD i=0; i < this->nTexCoord; i++)
        this->textures[i] = lpDrawData->textureCoords[i];
    this->dwNumVertices = dwNumVertices;
    this->lpwIndices = lpwIndices;
    this->dwNumIndices = dwNumIndices;
    this->lpClipFlags = (D3DFE_CLIPCODE*)HVbuf.GetAddress();
    this->dwFlags = dwFlags | D3DPV_STRIDE;
    if (this->dwVIDIn & D3DFVF_NORMAL)
        this->dwFlags |= D3DPV_LIGHTING;
    GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives and update stats

#if DBG
    if (this->dwNumPrimitives > MAX_DX6_PRIMCOUNT)
    {
        D3D_ERR("D3D for DX6 cannot handle greater than 64K sized primitives");
        return D3DERR_TOOMANYPRIMITIVES;
    }
    ret = CheckDrawIndexedPrimitive(this);
    if (ret != D3D_OK)
    {
        return ret;
    }
    if (this->dwNumIndices * INDEX_BATCH_SCALE < this->dwNumVertices &&
        !FVF_TRANSFORMED(this->dwVIDIn))
    {
        D3D_WARN(1, "The number of indices is much less than the number of vertices.");
        D3D_WARN(1, "This will likely be inefficient. Consider using vertex buffers.");
    }
#endif
    return this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
}   // end of DrawIndexedPrimitiveStrided()
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitive3"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                               DWORD dwVertexType,
                               LPVOID lpvVertices,
                               DWORD dwNumVertices,
                               DWORD dwFlags)
{
    HRESULT        ret = D3D_OK;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
    if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;
    Profile(PROF_DRAWPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif

    /* This stuff does not change from call to call */
    this->lpwIndices = NULL;
    this->dwNumIndices = 0;
    this->lpClipFlags = (D3DFE_CLIPCODE*)HVbuf.GetAddress();
    /* This stuff is mandatory for the call */
    this->primType = PrimitiveType;
    this->dwVIDIn  = dwVertexType;
    this->position.lpvData = lpvVertices;
    this->dwNumVertices = dwNumVertices;
    this->dwFlags = dwFlags;
    /* This stuff depends upon the vertex type */
    this->position.dwStride = GetVertexSizeFVF(this->dwVIDIn);
    if (this->dwVIDIn & D3DFVF_NORMAL)
        this->dwFlags |= D3DPV_LIGHTING;
    ComputeOutputFVF(this);
    GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives and update stats

#if DBG
    if (this->dwNumVertices > MAX_DX6_VERTICES)
    {
        D3D_ERR("D3D for DX6 cannot handle greater than 64K vertices");
        return D3DERR_TOOMANYVERTICES;
    }
    ret = CheckDrawPrimitive(this);
    if (ret != D3D_OK)
    {
        return ret;
    }
#endif
    return this->ProcessPrimitive();
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::DrawIndexedPrimitive"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawIndexedPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                                      DWORD  dwVertexType,
                                      LPVOID lpvVertices, DWORD dwNumVertices,
                                      LPWORD lpwIndices, DWORD dwNumIndices,
                                      DWORD dwFlags)
{
    HRESULT ret = D3D_OK;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
    if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;
    Profile(PROF_DRAWINDEXEDPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif
    // Static part
    this->lpClipFlags = (D3DFE_CLIPCODE*)HVbuf.GetAddress();
    // Mandatory part
    this->primType = PrimitiveType;
    this->dwVIDIn = dwVertexType;
    this->dwNumVertices = dwNumVertices;
    this->lpwIndices = lpwIndices;
    this->dwNumIndices = dwNumIndices;
    this->dwFlags = dwFlags;
    this->position.lpvData = lpvVertices;
    // Stuff that depends upon dwVIDIn
    this->position.dwStride = GetVertexSizeFVF(this->dwVIDIn);
    if (this->dwVIDIn & D3DFVF_NORMAL)
        this->dwFlags |= D3DPV_LIGHTING;
    ComputeOutputFVF(this);
    GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives and update stats

#if DBG
    if (this->dwNumPrimitives > MAX_DX6_PRIMCOUNT)
    {
        D3D_ERR("D3D for DX6 cannot handle greater than 64K sized primitives");
        return D3DERR_TOOMANYPRIMITIVES;
    }
    ret = CheckDrawIndexedPrimitive(this);
    if (ret != D3D_OK)
    {
        return ret;
    }
    if (this->dwNumIndices * INDEX_BATCH_SCALE < this->dwNumVertices &&
        !FVF_TRANSFORMED(this->dwVIDIn))
    {
        D3D_WARN(1, "The number of indices is much less than the number of vertices.");
        D3D_WARN(1, "This will likely be inefficient. Consider using vertex buffers.");
    }
#endif
    return this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitive"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                               D3DVERTEXTYPE VertexType,
                               LPVOID lpvVertices, DWORD dwNumVertices, DWORD dwFlags)
{
    HRESULT        ret = D3D_OK;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.
#if DBG
    if (!IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;

    if((VertexType<=0) || (VertexType>D3DVT_TLVERTEX)) {
        D3D_ERR("Invalid VertexType");
        return D3DERR_INVALIDVERTEXTYPE;
    }
    Profile(PROF_DRAWPRIMITIVEDEVICE2,PrimitiveType,VertexType);
#endif
    /* Static assignments */
    this->position.dwStride = sizeof(D3DVERTEX);
    this->lpwIndices = NULL;
    this->dwNumIndices = 0;
    this->lpClipFlags = (D3DFE_CLIPCODE*)HVbuf.GetAddress();
    this->nTexCoord = 1;
    /* Necessary work */
    this->primType = PrimitiveType;
    this->dwNumVertices = dwNumVertices;
    this->dwFlags = dwFlags;
    this->position.lpvData = lpvVertices;
    this->dwVIDIn = d3dVertexToFVF[VertexType];
    DWORD dwVertexSize = sizeof(D3DVERTEX);
    ComputeOutputFVF(this);
    if (this->dwVIDIn & D3DFVF_NORMAL)
        this->dwFlags |= D3DPV_LIGHTING;

    // AnanKan (6/22/98)
    // !! This is a hack for the crippled DP2 driver model which cannot accept
    // !! more that 64K vertices. In DX6 interfaces we fail rendering if we
    // !! encounter such large primitives for all DDI.
    // !! In the legacy (DX5) interfaces,
    // !! If the primitive size is greater than MAX_DX6_PRIMCOUNT and
    // !! the DDI cannot handle it, then we to break up the primitive into
    // !! manageable chunks.

    if ((this->dwNumVertices > MAX_DX6_VERTICES) &&
        (IS_DP2HAL_DEVICE(this)))
    {
        DWORD dwOrigNumVerts = this->dwNumVertices;
        WORD wChunkSize = MAX_DX6_VERTICES - 3; // Even and a multiple of 3
        BYTE TmpVertex[32], FirstVertex[32];
        DWORD dwStepPerChunk;

        switch(this->primType)
        {
        case D3DPT_POINTLIST:
        case D3DPT_LINELIST:
        case D3DPT_TRIANGLELIST:
            dwStepPerChunk = dwVertexSize*wChunkSize;
            break;
        case D3DPT_LINESTRIP:
            dwStepPerChunk = dwVertexSize*(wChunkSize - 1);
            break;
        case D3DPT_TRIANGLEFAN:
            // Save the first index
            memcpy(FirstVertex, this->position.lpvData, dwVertexSize);
            // Fall through
        case D3DPT_TRIANGLESTRIP:
            dwStepPerChunk = dwVertexSize*(wChunkSize - 2);
            break;
        }

        int numChunks = (int)(dwOrigNumVerts/(DWORD)wChunkSize);
        WORD wRemainingVerts = (WORD)(dwOrigNumVerts - wChunkSize*numChunks);
        this->dwNumVertices = wChunkSize;
        // Calculate dwNumPrimitives and update stats
        GetNumPrim(this, this->dwNumVertices);

        // 0th iteration
#if DBG
        ret = CheckDrawPrimitive(this);
        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        ret = this->ProcessPrimitive();
        if (ret != D3D_OK)
        {
            return ret;
        }

        for (int i=1; i<numChunks; i++)
        {
            this->position.lpvData = (LPVOID)((LPBYTE)this->position.lpvData +
                                              dwStepPerChunk);
            if (this->primType == D3DPT_TRIANGLEFAN)
            {
                // Save the vertex
                memcpy(TmpVertex, this->position.lpvData, dwVertexSize);
                // Copy in the first vertex
                memcpy(this->position.lpvData, FirstVertex, dwVertexSize);
            }

#if DBG
            ret = CheckDrawPrimitive(this);
            if (ret != D3D_OK)
            {
                return ret;
            }
#endif
            ret = this->ProcessPrimitive();

            // Write back the proper vertex in case something has been
            // switched
            if(this->primType == D3DPT_TRIANGLEFAN)
                memcpy(this->position.lpvData, TmpVertex, dwVertexSize);

            if (ret != D3D_OK)
            {
                return ret;
            }
        }

        // The last time around
        if (wRemainingVerts)
        {
            this->dwNumVertices = wRemainingVerts;
            // Calculate dwNumPrimitives and update stats
            GetNumPrim(this, this->dwNumVertices);
            this->position.lpvData = (LPVOID)((LPBYTE)this->position.lpvData +
                                              dwStepPerChunk);
            if (this->primType == D3DPT_TRIANGLEFAN)
            {
                memcpy(TmpVertex, this->position.lpvData, dwVertexSize);
                memcpy(this->position.lpvData, FirstVertex, dwVertexSize);
            }
#if DBG
            ret = CheckDrawPrimitive(this);
            if (ret != D3D_OK)
            {
                return ret;
            }
#endif
            ret = this->ProcessPrimitive();

            // Write back the proper vertex in case something has been
            // switched
            if(this->primType == D3DPT_TRIANGLEFAN)
                memcpy(this->position.lpvData, TmpVertex, dwVertexSize);

            if (ret != D3D_OK)
            {
                return ret;
            }
        }
    }
    else
    {
        // Calculate dwNumPrimitives and update stats
        GetNumPrim(this, dwNumVertices);
#if DBG
        ret = CheckDrawPrimitive(this);
        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        return this->ProcessPrimitive();
    }

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrimitive"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawIndexedPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                                      D3DVERTEXTYPE VertexType,
                                      LPVOID lpvVertices, DWORD dwNumVertices,
                                      LPWORD lpwIndices, DWORD dwNumIndices,
                                      DWORD dwFlags)
{
    HRESULT ret = D3D_OK;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
    if (!IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;
    Profile(PROF_DRAWINDEXEDPRIMITIVEDEVICE2,PrimitiveType,VertexType);
#endif
    this->primType = PrimitiveType;
    this->dwVIDIn = d3dVertexToFVF[VertexType];
    this->position.dwStride =  sizeof(D3DVERTEX);
    this->dwNumVertices = dwNumVertices;
    this->lpwIndices = lpwIndices;
    this->dwNumIndices = dwNumIndices;
    this->lpClipFlags = (D3DFE_CLIPCODE*)HVbuf.GetAddress();
    this->dwFlags = dwFlags;
    this->position.lpvData = lpvVertices;
    this->nTexCoord = 1;
    ComputeOutputFVF(this);
    if (this->dwVIDIn & D3DFVF_NORMAL)
        this->dwFlags |= D3DPV_LIGHTING;
    GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives and update stats

    // AnanKan (6/22/98)
    // !! This is a hack for the crippled DP2 driver model which cannot accept
    // !! more that 64K primitives (primcount is a WORD). In DX6 interfaces
    // !! we fail rendering if we encounter such large primitives.
    // !! We do this for all DDI.
    // !! In the legacy (DX5) interfaces,
    // !! If the primitive size is greater than MAX_DX6_PRIMCOUNT and
    // !! the DDI cannot handle it, then we to break up the primitive into
    // !! manageable chunks.

    if ((this->dwNumPrimitives > MAX_DX6_PRIMCOUNT) &&
        (IS_DP2HAL_DEVICE(this)))
    {
        WORD wFirstIndex, wTmpIndex;
        WORD wChunkSize = MAX_DX6_PRIMCOUNT;
        int numPrimChunks;
        DWORD dwResidualPrim;
        DWORD dwResidualIndices;
        DWORD dwStepPerChunk;
        DWORD dwOrigNumPrim = this->dwNumPrimitives;
        this->dwNumPrimitives = wChunkSize;
        numPrimChunks = (int)(dwOrigNumPrim/(DWORD)wChunkSize);
        dwResidualPrim = dwOrigNumPrim - wChunkSize*numPrimChunks;

        switch(this->primType)
        {
        case D3DPT_POINTLIST:
            this->dwNumIndices = this->dwNumPrimitives;
            dwStepPerChunk = this->dwNumIndices;
            dwResidualIndices = dwResidualPrim;
            break;
        case D3DPT_LINELIST:
            this->dwNumIndices = this->dwNumPrimitives<<1;
            dwStepPerChunk = this->dwNumIndices;
            dwResidualIndices = dwResidualPrim << 1;
            break;
        case D3DPT_LINESTRIP:
            this->dwNumIndices = this->dwNumPrimitives + 1;
            dwStepPerChunk = this->dwNumIndices - 1;
            dwResidualIndices = dwResidualPrim + 1;
            break;
        case D3DPT_TRIANGLEFAN:
            this->dwNumIndices = this->dwNumPrimitives + 2;
            dwStepPerChunk = this->dwNumIndices - 2;
            dwResidualIndices = dwResidualPrim + 2;
            // Save the first index
            wTmpIndex = wFirstIndex = this->lpwIndices[0];
            break;
        case D3DPT_TRIANGLESTRIP:
            wChunkSize = (MAX_DX6_PRIMCOUNT-1);
            this->dwNumPrimitives = wChunkSize;
            this->dwNumIndices = this->dwNumPrimitives + 2;
            dwStepPerChunk = this->dwNumIndices - 2;
            numPrimChunks = (int)(dwOrigNumPrim/(DWORD)wChunkSize);
            dwResidualPrim = dwOrigNumPrim - wChunkSize*numPrimChunks;
            dwResidualIndices = dwResidualPrim + 2;
            break;
        case D3DPT_TRIANGLELIST:
            this->dwNumIndices = this->dwNumPrimitives * 3;
            dwStepPerChunk = this->dwNumIndices;
            dwResidualIndices = dwResidualPrim * 3;
            break;
        }

        // 0th iteration
#if DBG
        ret = CheckDrawIndexedPrimitive(this);
        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        ret = this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
        if (ret != D3D_OK)
        {
            return ret;
        }

        // Remaining chunks
        for (int i=1; i<numPrimChunks; i++)
        {
            this->lpwIndices += dwStepPerChunk;

            if (this->primType == D3DPT_TRIANGLEFAN)
            {
                // Save the index
                wTmpIndex = this->lpwIndices[0];
                // Copy in the first vertex
                this->lpwIndices[0] = wFirstIndex;
            }

#if DBG
            ret = CheckDrawIndexedPrimitive(this);
            if (ret != D3D_OK)
            {
                return ret;
            }
#endif
            ret = this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);

            // Write back the proper index in case something has been
            // switched
            if(this->primType == D3DPT_TRIANGLEFAN)
                this->lpwIndices[0] = wTmpIndex;

            if (ret != D3D_OK)
            {
                return ret;
            }
        }

        // The last time around
        if (dwResidualPrim)
        {
            this->dwNumPrimitives = dwResidualPrim;
            this->dwNumIndices = dwResidualIndices;
            this->lpwIndices += dwStepPerChunk;
            if (this->primType == D3DPT_TRIANGLEFAN)
            {
                wTmpIndex = this->lpwIndices[0];
                this->lpwIndices[0] = wFirstIndex;
            }
#if DBG
            ret = CheckDrawIndexedPrimitive(this);
            if (ret != D3D_OK)
            {
                return ret;
            }
#endif
            ret = this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
            // Write back the proper index in case something has been
            // switched
            if(this->primType == D3DPT_TRIANGLEFAN)
                this->lpwIndices[0] = wTmpIndex;
            if (ret != D3D_OK)
            {
                return ret;
            }
        }
    }
    else
    {

#if DBG
        ret = CheckDrawIndexedPrimitive(this);
        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        // For an untransformed primitive, if a number of indices is much less
        // than number of vertices we rebuild the primitive to reduce number
        // of vertices to process.
        if (this->dwNumIndices * INDEX_BATCH_SCALE < this->dwNumVertices &&
            !FVF_TRANSFORMED(this->dwVIDIn))
            return DereferenceIndexedPrim(this);
        else
            return this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP::SetRenderStateI"

HRESULT D3DAPI
CDirect3DDeviceIDP::SetRenderStateI(D3DRENDERSTATETYPE dwStateType,
                                    DWORD value)
{
    LPD3DHAL_DRAWPRIMCOUNTS lpPC;
    LPDWORD lpStateChange;
    HRESULT ret;
    if (dwStateType > D3DRENDERSTATE_STIPPLEPATTERN31)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwStateType);
        return D3D_OK;
    }
    if (dwStateType > D3DRENDERSTATE_FLUSHBATCH && dwStateType < D3DRENDERSTATE_STIPPLEPATTERN00)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwStateType);
        return D3D_OK;
    }

    if (D3DRENDERSTATE_FLUSHBATCH == dwStateType)
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in SetRenderStateI");
        }
        return ret;
    }

    lpPC = this->lpDPPrimCounts;
    if (lpPC->wNumVertices) //Do we already have Vertices filled in for this count ?
    {               //Yes, then Increment count
        lpPC=this->lpDPPrimCounts=(LPD3DHAL_DRAWPRIMCOUNTS)((LPBYTE)this->lpwDPBuffer+this->dwDPOffset);
        memset( (char *)lpPC,0,sizeof(D3DHAL_DRAWPRIMCOUNTS));
        this->dwDPOffset += sizeof(D3DHAL_DRAWPRIMCOUNTS);
    }
    if (this->dwDPOffset + 2*sizeof(DWORD)  > this->dwDPMaxOffset )
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in SetRenderStateI");
            return ret;
        }
    }
    lpStateChange=(LPDWORD)((char *)this->lpwDPBuffer + this->dwDPOffset);
    *lpStateChange=dwStateType;
    lpStateChange ++;
    *lpStateChange=value;
    this->lpDPPrimCounts->wNumStateChanges ++;
    this->dwDPOffset += 2*sizeof(DWORD);
#if 0
    if (dwStateType == D3DRENDERSTATE_TEXTUREHANDLE && this->dwDPOffset== 0x10){
    DPF(0,"SRdwDPOffset=%08lx, dwStateType=%08lx value=%08lx ddihandle=%08lx lpStateChange=%08lx lpDPPrimCounts=%08lx",
    this->dwDPOffset,dwStateType,value,*lpStateChange,lpStateChange,this->lpDPPrimCounts);
        _asm int 3
    }
#endif //0

    return D3D_OK;
}
//---------------------------------------------------------------------
DWORD visResults[6][2] =
{
    D3DVIS_INTERSECT_LEFT   ,
    D3DVIS_OUTSIDE_LEFT     ,
    D3DVIS_INTERSECT_RIGHT  ,
    D3DVIS_OUTSIDE_RIGHT    ,
    D3DVIS_INTERSECT_TOP    ,
    D3DVIS_OUTSIDE_TOP      ,
    D3DVIS_INTERSECT_BOTTOM ,
    D3DVIS_OUTSIDE_BOTTOM   ,
    D3DVIS_INTERSECT_NEAR   ,
    D3DVIS_OUTSIDE_NEAR     ,
    D3DVIS_INTERSECT_FAR    ,
    D3DVIS_OUTSIDE_FAR
};
//---------------------------------------------------------------------
DWORD CheckSphere(LPDIRECT3DDEVICEI lpDevI, LPD3DVECTOR center, D3DVALUE radius)
{
    DWORD result = 0;
    for (int i=0; i < 6; i++)
    {
        // Compute a distance from the center to the plane
        D3DVALUE d = lpDevI->transform.frustum[i].x*center->x +
                     lpDevI->transform.frustum[i].y*center->y +
                     lpDevI->transform.frustum[i].z*center->z +
                     lpDevI->transform.frustum[i].w;
        if (d + radius < 0)
            result |= visResults[i][1];  // Outside
        else
        if (d - radius < 0.5f)  // 0.5 is chosen to offset precision errors
            result |= visResults[i][0];  // Intersect
    }
    if (result & (D3DVIS_OUTSIDE_LEFT   |
                  D3DVIS_OUTSIDE_RIGHT  |
                  D3DVIS_OUTSIDE_TOP    |
                  D3DVIS_OUTSIDE_BOTTOM |
                  D3DVIS_OUTSIDE_NEAR   |
                  D3DVIS_OUTSIDE_FAR))
    {
        result |= D3DVIS_OUTSIDE_FRUSTUM;
    }
    else
    if (result)
        result |= D3DVIS_INTERSECT_FRUSTUM;

    return result;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::ComputeSphereVisibility"

HRESULT D3DAPI
DIRECT3DDEVICEI::ComputeSphereVisibility(LPD3DVECTOR lpCenters,
                                         LPD3DVALUE lpRadii,
                                         DWORD dwNumSpheres,
                                         DWORD dwFlags,
                                         LPDWORD lpdwReturnValues)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
    TRY
    {
        if (dwFlags != 0 || dwNumSpheres == 0 ||
            IsBadWritePtr(lpdwReturnValues, dwNumSpheres * sizeof(DWORD)) ||
            IsBadWritePtr(lpRadii, dwNumSpheres * sizeof(D3DVALUE)) ||
            IsBadWritePtr(lpCenters, dwNumSpheres * sizeof(LPD3DVECTOR)))
        {
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
#endif

    this->dwFlags = 0;
    if (dwFEFlags & D3DFE_TRANSFORM_DIRTY)
    {
        updateTransform(this);
    }
    if (this->dwFEFlags & D3DFE_FRUSTUMPLANES_DIRTY)
    {
        this->dwFlags |= D3DPV_FRUSTUMPLANES_DIRTY;
        this->dwFEFlags &= ~D3DFE_FRUSTUMPLANES_DIRTY;
    }

    return this->pGeometryFuncs->ComputeSphereVisibility(this,
                                                         lpCenters,
                                                         lpRadii,
                                                         dwNumSpheres,
                                                         dwFlags,
                                                         lpdwReturnValues);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ID3DFE_PVFUNCS::ComputeSphereVisibility"

HRESULT
D3DFE_PVFUNCS::ComputeSphereVisibility(LPD3DFE_PROCESSVERTICES pv,
                                       LPD3DVECTOR lpCenters,
                                       LPD3DVALUE lpRadii,
                                       DWORD dwNumSpheres,
                                       DWORD dwFlags,
                                       LPDWORD lpdwReturnValues)
{
    LPDIRECT3DDEVICEI lpDevI = static_cast<LPDIRECT3DDEVICEI>(pv);
    HRESULT ret = D3DERR_INVALIDMATRIX;

#define transform lpDevI->transform

    if (pv->dwFlags & D3DPV_FRUSTUMPLANES_DIRTY)
    {
        transform.dwFlags &= ~D3DTRANS_VALIDFRUSTUM;
        if (Inverse4x4((D3DMATRIX*)&lpDevI->mCTM,
                       (D3DMATRIX*)&transform.mCTMI))
        {
            D3D_ERR("Cannot invert current (World X View) matrix.");
            return ret;
        }
        // Transform the following clipping volume points to the model space by
        // multiplying by inverse CTM
        //
        // v1 = { 0, 0, 0, 1};
        // v2 = { 1, 0, 0, 1};
        // v3 = { 1, 1, 0, 1};
        // v4 = { 0, 1, 0, 1};
        // v5 = { 0, 0, 1, 1};
        // v6 = { 1, 0, 1, 1};
        // v7 = { 0, 1, 1, 1};
        //
        // We do it manually to speed up
        //
        D3DVECTORH v1 = {transform.mCTMI._41,
                         transform.mCTMI._42,
                         transform.mCTMI._43,
                         transform.mCTMI._44};
        D3DVECTORH v2 = {transform.mCTMI._11 + transform.mCTMI._41,
                         transform.mCTMI._12 + transform.mCTMI._42,
                         transform.mCTMI._13 + transform.mCTMI._43,
                         transform.mCTMI._14 + transform.mCTMI._44};
        D3DVECTORH v3 = {transform.mCTMI._11 + transform.mCTMI._21 + transform.mCTMI._41,
                         transform.mCTMI._12 + transform.mCTMI._22 + transform.mCTMI._42,
                         transform.mCTMI._13 + transform.mCTMI._23 + transform.mCTMI._43,
                         transform.mCTMI._14 + transform.mCTMI._24 + transform.mCTMI._44};
        D3DVECTORH v4 = {transform.mCTMI._21 + transform.mCTMI._41,
                         transform.mCTMI._22 + transform.mCTMI._42,
                         transform.mCTMI._23 + transform.mCTMI._43,
                         transform.mCTMI._24 + transform.mCTMI._44};
        D3DVECTORH v5 = {transform.mCTMI._31 + transform.mCTMI._41,
                         transform.mCTMI._32 + transform.mCTMI._42,
                         transform.mCTMI._33 + transform.mCTMI._43,
                         transform.mCTMI._34 + transform.mCTMI._44};
        D3DVECTORH v6 = {transform.mCTMI._11 + transform.mCTMI._31 + transform.mCTMI._41,
                         transform.mCTMI._12 + transform.mCTMI._32 + transform.mCTMI._42,
                         transform.mCTMI._13 + transform.mCTMI._33 + transform.mCTMI._43,
                         transform.mCTMI._14 + transform.mCTMI._34 + transform.mCTMI._44};
        D3DVECTORH v7 = {transform.mCTMI._21 + transform.mCTMI._31 + transform.mCTMI._41,
                         transform.mCTMI._22 + transform.mCTMI._32 + transform.mCTMI._42,
                         transform.mCTMI._23 + transform.mCTMI._33 + transform.mCTMI._43,
                         transform.mCTMI._24 + transform.mCTMI._34 + transform.mCTMI._44};

        // Convert vectors from homogeneous to 3D
        if (Vector4to3D(&v1))
            goto exit;
        if (Vector4to3D(&v2))
            goto exit;
        if (Vector4to3D(&v3))
            goto exit;
        if (Vector4to3D(&v4))
            goto exit;
        if (Vector4to3D(&v5))
            goto exit;
        if (Vector4to3D(&v6))
            goto exit;
        if (Vector4to3D(&v7))
            goto exit;
        // Build frustum planes
        // Left
        if (MakePlane((D3DVECTOR*)&v1, (D3DVECTOR*)&v4, (D3DVECTOR*)&v5, &transform.frustum[0]))
            goto exit;
        // Right
        if (MakePlane((D3DVECTOR*)&v2, (D3DVECTOR*)&v6, (D3DVECTOR*)&v3, &transform.frustum[1]))
            goto exit;
        // Top
        if (MakePlane((D3DVECTOR*)&v4, (D3DVECTOR*)&v3, (D3DVECTOR*)&v7, &transform.frustum[2]))
            goto exit;
        // Bottom
        if (MakePlane((D3DVECTOR*)&v1, (D3DVECTOR*)&v5, (D3DVECTOR*)&v2, &transform.frustum[3]))
            goto exit;
        // Near
        if (MakePlane((D3DVECTOR*)&v1, (D3DVECTOR*)&v2, (D3DVECTOR*)&v3, &transform.frustum[4]))
            goto exit;
        // Far
        if (MakePlane((D3DVECTOR*)&v6, (D3DVECTOR*)&v5, (D3DVECTOR*)&v7, &transform.frustum[5]))
            goto exit;

        transform.dwFlags |= D3DTRANS_VALIDFRUSTUM;
    }

    if (transform.dwFlags & D3DTRANS_VALIDFRUSTUM)
    {
        // Now we can check the spheres against the clipping planes

        for (DWORD i=0; i < dwNumSpheres; i++)
        {
            lpdwReturnValues[i] = CheckSphere(lpDevI, &lpCenters[i], lpRadii[i]);
        }
        return D3D_OK;
    }

exit:
    D3D_ERR("Non-orthogonal (world X view) matrix");
    return ret;
#undef transform
}
//---------------------------------------------------------------------
DWORD
D3DFE_PVFUNCS::GenClipFlags(D3DFE_PROCESSVERTICES *pv)
{
    return D3DFE_GenClipFlags(pv);
}
//---------------------------------------------------------------------
DWORD
D3DFE_PVFUNCS::TransformVertices(D3DFE_PROCESSVERTICES *pv, 
                                 DWORD vertexCount, 
                                 LPD3DTRANSFORMDATAI data)
{

    if (pv->dwFlags & D3DDP_DONOTCLIP) 
        return D3DFE_TransformUnclippedVp(pv, vertexCount, data);
    else 
        return D3DFE_TransformClippedVp(pv, vertexCount, data);
}
//---------------------------------------------------------------------
DWORD ID3DFE_PVFUNCS::GenClipFlags(D3DFE_PROCESSVERTICES *pv)
{   
    return GeometryFuncsGuaranteed.GenClipFlags(pv);
}
//---------------------------------------------------------------------
// Used to implement viewport->TransformVertices
// Returns clip intersection code
DWORD ID3DFE_PVFUNCS::TransformVertices(D3DFE_PROCESSVERTICES *pv, 
                                DWORD vertexCount, 
                                D3DTRANSFORMDATAI* data)
{
    return GeometryFuncsGuaranteed.TransformVertices(pv, vertexCount, data);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\dp2hal.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cbhal.cpp
 *  Content:    DrawPrimitive implementation for command buffer HALs
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "drawprim.hpp"
#include "clipfunc.h"
#include "d3dfei.h"

extern const DWORD LOWVERTICESNUMBER;
extern "C" HRESULT WINAPI
DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits );
extern "C" FLATPTR GetAliasedVidMem( LPDDRAWI_DIRECTDRAW_LCL   pdrv_lcl,
                          LPDDRAWI_DDRAWSURFACE_LCL surf_lcl,
                          FLATPTR                   fpVidMem );

// Each vertex buffer is big enough to hold 256 TL vertices
const DWORD CDirect3DDeviceIDP2::dwD3DDefaultVertexBatchSize = 256; // * 32 = 8K bytes
// Command buffer size tuned to 16K to minimize flushes in Unreal
const DWORD CDirect3DDeviceIDP2::dwD3DDefaultCommandBatchSize = 16384; // * 1 = 16K bytes

inline void CDirect3DDeviceIDP2::ClearBatch()
{
    // Reset command buffer
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)lpvDP2Commands;
    dwDP2CommandLength = 0;
    dp2data.dwCommandOffset = 0;
    dp2data.dwCommandLength = 0;
    bDP2CurrCmdOP = 0;
    // Reset vertex buffer
    if (this->dwFlags & D3DPV_WITHINPRIMITIVE)
    {
        // Do not reset vertex buffer
        // or reset to the start of current primitives'
        // vertex data to prevent unecessary processing
        // of unused vertices by the driver.
        /*
        dp2data.dwVertexOffset = dwDP2CurrPrimVertexOffset;
        dp2data.dwVertexLength -= dwDP2CurrPrimVertexOffset;
        */
    }
    else
    {
        dp2data.dwVertexOffset = 0;
        dp2data.dwVertexLength = 0;
        dwVertexBase = 0;
        TLVbuf.Base() = 0;
        if (dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES)
        {
            // We are flushing a user mem primitive.
            // We need to clear dp2data.lpUMVertices
            // since we are done with it. We replace
            // it with TLVbuf.
            DDASSERT(lpDP2CurrBatchVBI == NULL);
            dp2data.lpDDVertex = ((LPDDRAWI_DDRAWSURFACE_INT)TLVbuf.GetDDS())->lpLcl;
            lpDP2CurrBatchVBI = TLVbuf.GetVBI();
            lpDP2CurrBatchVBI->AddRef();
            dp2data.dwFlags &= ~D3DHALDP2_USERMEMVERTICES;
        }
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::CheckSurfaces()"
HRESULT CDirect3DDeviceIDP2::CheckSurfaces()
{
    HRESULT hr;
    if(this->lpDirect3DI->lpTextureManager->CheckIfLost())
    {
        D3D_ERR("Managed Textures lost");
        return DDERR_SURFACELOST;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->lpGbl->dwUsageCount ||
         (this->lpDDSZBuffer && ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->lpGbl->dwUsageCount) )
    {
        D3D_ERR("Render target or Z buffer locked");
        return DDERR_SURFACEBUSY;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->dwFlags & DDRAWISURF_INVALID )\
        {
            D3D_ERR("Render target buffer lost");
            return DDERR_SURFACELOST;
        }
    if ( this->lpDDSZBuffer && ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->dwFlags & DDRAWISURF_INVALID ) )
    {
        D3D_ERR("Z buffer lost");
        return DDERR_SURFACELOST;
    }
    if (!(this->dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES) && (this->dp2data.lpDDVertex->dwFlags & DDRAWISURF_INVALID))
    {
        D3D_ERR("Vertex buffer lost");
        return DDERR_SURFACELOST;
    }
    if (this->dp2data.lpDDCommands->dwFlags & DDRAWISURF_INVALID)
    {
        D3D_ERR("Command buffer lost");
        return DDERR_SURFACELOST;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::FlushStates(void)"

HRESULT CDirect3DDeviceIDP2::FlushStates()
{
    HRESULT dwRet=D3D_OK;
    FlushTextureFromDevice( this ); // delink all texture surfaces
    if (dwDP2CommandLength) // Do we have some instructions to flush ?
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
        // Check if render target and / or z buffer is lost
        if ((dwRet = CheckSurfaces()) != D3D_OK)
        { // If lost, we'll just chuck all this work into the bit bucket
            ClearBatch();
            if (dwRet == DDERR_SURFACELOST)
            {
                this->dwFEFlags |= D3DFE_LOSTSURFACES;
                dwRet = D3D_OK;
            }
        }
        else
        {
            // Save since it will get overwritten by ddrval after DDI call
            DWORD dwVertexSize = dp2data.dwVertexSize;
            dp2data.dwCommandLength = dwDP2CommandLength;
            //we clear this to break re-entering as SW rasterizer needs to lock DDRAWSURFACE
            dwDP2CommandLength = 0;
            // Try and set these 2 values only once during initialization
            dp2data.dwhContext = this->dwhContext;
            dp2data.lpdwRStates = this->rstates;
            DDASSERT(dp2data.dwVertexSize != 0);
            // If we need the same TLVbuf next time do not swap buffers.
            if (this->dwFlags & D3DPV_WITHINPRIMITIVE)
            {
                dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
            }
            D3D_INFO(6, "dwVertexType passed to the driver = 0x%08x", dp2data.dwVertexType);
#ifndef WIN95
            if (!IS_DX7HAL_DEVICE(this))
            {
                if((dwRet = CheckContextSurface(this)) != D3D_OK)
                {
                    ClearBatch();
                    return dwRet;
                }
            }
#else
            // Take Win 16 Lock here
            LOCK_HAL( dwRet, this );
#endif //WIN95

            // Spin waiting on the driver if wait requested
            do {
                // Need to set this since the driver may have overwrote it by
                // setting ddrval = DDERR_WASSTILLDRAWING
                dp2data.dwVertexSize = dwVertexSize;
                CALL_HAL3ONLY_NOLOCK(dwRet, this, DrawPrimitives2, &dp2data);
                if (dwRet != DDHAL_DRIVER_HANDLED)
                {
                    D3D_ERR ( "Driver not handled in DrawPrimitives2" );
                    // Need sensible return value in this case,
                    // currently we return whatever the driver stuck in here.
                }
            } while (dp2data.ddrval == DDERR_WASSTILLDRAWING);
            if (dp2data.ddrval == D3DERR_COMMAND_UNPARSED)
            { // This should never occur since the driver must understand
              // all the instruction we batch.
                D3D_ERR("Driver could not parse this batch!");
                dwRet = DDERR_GENERIC; // Some thing better here ?
            }
            else
            {
                dwRet= dp2data.ddrval;
#ifdef WIN95
                // update command buffer pointer
                if ((dwRet == D3D_OK) && (dp2data.dwFlags & D3DHALDP2_SWAPCOMMANDBUFFER))
                {
                    // Get Aliased vid mem pointer if it is a vid mem surf.
                    if (dp2data.dwFlags & D3DHALDP2_VIDMEMCOMMANDBUF)
                    {
                        D3D_INFO(7, "Got back new vid mem command buffer");
                        FLATPTR paliasbits = GetAliasedVidMem( dp2data.lpDDCommands->lpSurfMore->lpDD_lcl,
                            dp2data.lpDDCommands, (FLATPTR) dp2data.lpDDCommands->lpGbl->fpVidMem );
                        if (paliasbits == NULL)
                        {
                            DPF_ERR("Could not get Aliased pointer for vid mem command buffer");
                            // Since we can't use this pointer, set it's size to 0
                            // That way next time around we will try and allocate a new one
                            dp2data.lpDDCommands->lpGbl->dwLinearSize = 0;
                        }
                        lpvDP2Commands = (LPVOID)paliasbits;
                    }
                    else
                    {
                        D3D_INFO(7, "Got back new sys mem command buffer");
                        lpvDP2Commands = (LPVOID)dp2data.lpDDCommands->lpGbl->fpVidMem;
                    }
                    dwDP2CommandBufSize = dp2data.lpDDCommands->lpGbl->dwLinearSize;
                }
                // update vertex buffer pointer
                if ((dwRet == D3D_OK) && (dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER))
                {
                    if (dp2data.dwFlags & D3DHALDP2_VIDMEMVERTEXBUF)
                    {
                        D3D_INFO(7, "Got back new vid mem vertex buffer");
                        FLATPTR paliasbits = GetAliasedVidMem( dp2data.lpDDVertex->lpSurfMore->lpDD_lcl,
                            dp2data.lpDDVertex, (FLATPTR) dp2data.lpDDVertex->lpGbl->fpVidMem );
                        if (paliasbits == NULL)
                        {
                            DPF_ERR("Could not get Aliased pointer for vid mem vertex buffer");
                            // Since we can't use this pointer, set it's size to 0
                            // That way next time around we will try and allocate a new one
                            dp2data.lpDDVertex->lpGbl->dwLinearSize = 0;
                        }
                        TLVbuf.alignedBuf = (LPVOID)paliasbits;
                    }
                    else
                    {
                        D3D_INFO(7, "Got back new sys mem vertex buffer");
                        TLVbuf.alignedBuf = (LPVOID)dp2data.lpDDVertex->lpGbl->fpVidMem;
                    }
                    TLVbuf.size = dp2data.lpDDVertex->lpGbl->dwLinearSize;
                }
#endif
            }
#ifdef WIN95
            // Release Win16 Lock here
            UNLOCK_HAL( this );
#endif
            // Restore to value before the DDI call
            dp2data.dwVertexSize = dwVertexSize;
            ClearBatch();
        }
    }
    // There are situations when the command stream has no data, but there is data in
    // the vertex pool. This could happen, for instance if every triangle got rejected
    // while clipping. In this case we still need to "Flush out" the vertex data.
    else if (dp2data.dwCommandLength == 0)
    {
        ClearBatch();
    }
    return dwRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::FlushStates(DWORD)"

HRESULT CDirect3DDeviceIDP2::FlushStates(DWORD dwReqSize)
{
    // Request the driver to grow the command buffer upon flush
    dp2data.dwReqVertexBufSize = dwReqSize;
    dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER | D3DHALDP2_REQVERTEXBUFSIZE;
    HRESULT ret = FlushStates();
    dp2data.dwFlags &= ~D3DHALDP2_REQVERTEXBUFSIZE;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::GrowCommandBuffer"
// Check and grow command buffer
HRESULT CDirect3DDeviceIDP2::GrowCommandBuffer(LPDIRECT3DI lpD3DI, DWORD dwSize)
{
    HRESULT ret;
    if (dwSize > dwDP2CommandBufSize)
    {
        if (lpDDSCB1)
            lpDDSCB1->Release();
        // Create command buffer through DirectDraw
        DDSURFACEDESC2 ddsd;
        memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
        ddsd.dwSize = sizeof(DDSURFACEDESC2);
        ddsd.dwFlags = DDSD_WIDTH | DDSD_CAPS;
        ddsd.dwWidth = dwSize;
        ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER;
        if (IS_HW_DEVICE(this))
            ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        else
            ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        ddsd.ddsCaps.dwCaps2 = DDSCAPS2_COMMANDBUFFER;
        // Try explicit video memory first
        D3D_INFO(7, "Trying to create a vid mem command buffer");
        ret = lpD3DI->lpDD4->CreateSurface(&ddsd, &lpDDSCB1, NULL);
        if (ret != DD_OK)
        {
            // If that failed, try explicit system memory
            ddsd.ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
            ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
            D3D_INFO(7, "Trying to create a sys mem command buffer");
            ret = lpD3DI->lpDD4->CreateSurface(&ddsd, &lpDDSCB1, NULL);
            if (ret != DD_OK)
            {
                D3D_ERR("failed to allocate Command Buffer 1");
                return ret;
            }
        }
        // Lock command buffer
        ret = lpDDSCB1->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_NOSYSLOCK, NULL);
        if (ret != DD_OK)
        {
            D3D_ERR("Could not lock command buffer.");
            return ret;
        }
        // update command buffer pointer
        lpvDP2Commands = ddsd.lpSurface;
        dp2data.lpDDCommands = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSCB1)->lpLcl;
        dwDP2CommandBufSize = dwSize;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::Init"

HRESULT CDirect3DDeviceIDP2::Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice, DWORD dwVersion)
{
    dwDP2CommandBufSize = 0;
    dwDP2Flags =0;
    lpDDSCB1 = NULL;
    lpvDP2Commands = NULL;
    // We do this early in case of DP2 since GrowCommandBuffer depends on this check
    if (IsEqualIID(riid, IID_IDirect3DHALDevice))
    {
        this->dwFEFlags |=  D3DFE_REALHAL;
    }
    HRESULT ret = GrowCommandBuffer(lpD3DI, dwD3DDefaultCommandBatchSize);
    if (ret != D3D_OK)
        return ret;
    // Fill the dp2data structure with initial values
    dp2data.dwFlags = D3DHALDP2_SWAPCOMMANDBUFFER;
    dp2data.dwVertexType = D3DFVF_TLVERTEX; // Initial assumption
    dp2data.dwVertexSize = sizeof(D3DTLVERTEX); // Initial assumption
    ClearBatch();

    // Initialize the DDI independent part of the device
    ret = DIRECT3DDEVICEI::Init(riid, lpD3DI, lpDDS, pUnkOuter, lplpD3DDevice, dwVersion);
    if (ret != D3D_OK)
    {
        return ret;
    }
    lpDP2CurrBatchVBI = TLVbuf.GetVBI();
    lpDP2CurrBatchVBI->AddRef();
    dp2data.lpDDVertex = ((LPDDRAWI_DDRAWSURFACE_INT)(lpDP2CurrBatchVBI->GetDDS()))->lpLcl;
    return ret;
}
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::~CDirect3DDeviceIDP2"

CDirect3DDeviceIDP2::~CDirect3DDeviceIDP2()
{
    DestroyDevice();
    if (lpDDSCB1)
        lpDDSCB1->Release();
    if (lpDP2CurrBatchVBI)
        lpDP2CurrBatchVBI->Release();
}
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetRenderStateI"

HRESULT D3DAPI CDirect3DDeviceIDP2::SetRenderStateI(D3DRENDERSTATETYPE dwStateType,
                                    DWORD value)
{
    HRESULT ret = D3D_OK;
    if (bDP2CurrCmdOP == D3DDP2OP_RENDERSTATE)
    { // Last instruction is a renderstate, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2RENDERSTATE) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2RENDERSTATE lpRState = (LPD3DHAL_DP2RENDERSTATE)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpRState->RenderState = dwStateType;
            lpRState->dwState = value;
            dwDP2CommandLength += sizeof(D3DHAL_DP2RENDERSTATE);
        D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return ret;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2RENDERSTATE) > dwDP2CommandBufSize)
    {
            ret = FlushStates();

            // Since we ran out of space, we were not able to put (dwStateType, value)
            // into the batch so rstates will reflect only the last batched
            // renderstate (since the driver updates rstates from the batch).
            // To fix this, we simply put the current (dwStateType, value) into rstates.
            this->rstates[dwStateType]=value;

            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in SetRenderStateI");
                return ret;
            }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_RENDERSTATE;
    bDP2CurrCmdOP = D3DDP2OP_RENDERSTATE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add renderstate data
    LPD3DHAL_DP2RENDERSTATE lpRState = (LPD3DHAL_DP2RENDERSTATE)(lpDP2CurrCommand + 1);
    lpRState->RenderState = dwStateType;
    lpRState->dwState = value;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2RENDERSTATE);
    return ret;
}

// Map D3DPRIMITIVETYPE to D3DHAL_DP2OPERATION
const iprim2cmdop[] = {
    0, // Invalid
    0, // Points are invalid too
    D3DDP2OP_INDEXEDLINELIST2,
    D3DDP2OP_INDEXEDLINESTRIP,
    D3DDP2OP_INDEXEDTRIANGLELIST2,
    D3DDP2OP_INDEXEDTRIANGLESTRIP,
    D3DDP2OP_INDEXEDTRIANGLEFAN
};

// Map D3DPRIMITIVETYPE to D3DHAL_DP2OPERATION (Execute buffer case)
// Only triangle lists and line lists are valid
const iprim2cmdopEx[] = {
    0,
    0,
    D3DDP2OP_INDEXEDLINELIST,
    0,
    D3DDP2OP_INDEXEDTRIANGLELIST,
    0,
    0
};

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::DrawIndexPrim"

//---------------------------------------------------------------------
//
// The vertices are already in the vertex buffer.
//
HRESULT CDirect3DDeviceIDP2::DrawIndexPrim()
{
    HRESULT ret = D3D_OK;
    DWORD dwByteCount;          // Command length plus indices
    DWORD dwIndicesByteCount;   // Indices only
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        UpdateTextures();
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }
    if (this->dwFlags & D3DPV_INSIDEEXECUTE)
    {
        if (this->primType == D3DPT_TRIANGLELIST)
            // Edge flags WORD presents in every triangle
            dwIndicesByteCount = sizeof(WORD) * this->dwNumPrimitives * 4;
        else
            // This is Line List
            dwIndicesByteCount = sizeof(WORD) * this->dwNumIndices;
        dwByteCount = dwIndicesByteCount + sizeof(D3DHAL_DP2COMMAND);
    }
    else
    {
        dwIndicesByteCount = sizeof(WORD) * this->dwNumIndices;
        dwByteCount = dwIndicesByteCount + sizeof(D3DHAL_DP2COMMAND) +
                      sizeof(D3DHAL_DP2STARTVERTEX);
    }

    if (dwDP2CommandLength + dwByteCount > dwDP2CommandBufSize)
    {
        // Request the driver to grow the command buffer upon flush
        dp2data.dwReqCommandBufSize = dwByteCount;
        dp2data.dwFlags |= D3DHALDP2_REQCOMMANDBUFSIZE;
        ret = FlushStates();
        dp2data.dwFlags &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
        if (ret != D3D_OK)
            return ret;
        // Check if the driver did give us what we need or do it ourselves
        ret = GrowCommandBuffer(this->lpDirect3DI, dwByteCount);
        if (ret != D3D_OK)
        {
            D3D_ERR("Could not grow Command Buffer");
            return ret;
        }
    }
    // Insert indexed primitive instruction
    LPD3DHAL_DP2COMMAND lpDP2CurrCommand;
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                       dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wPrimitiveCount = (WORD)this->dwNumPrimitives;

    LPBYTE pIndices = (BYTE*)(lpDP2CurrCommand + 1);     // Place for indices
    if (!(this->dwFlags & D3DPV_INSIDEEXECUTE))
    {
        lpDP2CurrCommand->bCommand = (BYTE)iprim2cmdop[this->primType];
        ((LPD3DHAL_DP2STARTVERTEX)(lpDP2CurrCommand+1))->wVStart =
            (WORD)this->dwVertexBase;
        pIndices += sizeof(D3DHAL_DP2STARTVERTEX);
    }
    else
    {
        // If we are inside Execute, the indexed triangle and line lists
        // do not have wVStart inside the command
        lpDP2CurrCommand->bCommand = (BYTE)iprim2cmdopEx[this->primType];
    }

    D3D_INFO(6, "Write Ins :%08lx @ %08lx", *(LPDWORD)lpDP2CurrCommand,lpDP2CurrCommand);
    D3D_INFO(6, "Vertex Base: %08lx", this->dwVertexBase);

#if DBG
    if (lpDP2CurrCommand->bCommand == 0)
    {
        D3D_ERR("Illegal primitive type");
        return DDERR_GENERIC;
    }
#endif
    bDP2CurrCmdOP = lpDP2CurrCommand->bCommand;

    memcpy(pIndices, this->lpwIndices, dwIndicesByteCount);

    wDP2CurrCmdCnt = lpDP2CurrCommand->wPrimitiveCount;
    dwDP2CommandLength += dwByteCount;
    // We have batched some stuff, so we could be within a primitive
    // Unless the higher functions clear this flag we need to assume
    // we are mid-primitive during our flushes.
    this->dwFlags |= D3DPV_WITHINPRIMITIVE;
    return ret;
}

// Map D3DPRIMITIVETYPE to D3DHAL_DP2OPERATION
const prim2cmdop[] = {
    0, // Invalid
    D3DDP2OP_POINTS,
    D3DDP2OP_LINELIST,
    D3DDP2OP_LINESTRIP,
    D3DDP2OP_TRIANGLELIST,
    D3DDP2OP_TRIANGLESTRIP,
    D3DDP2OP_TRIANGLEFAN
};
// Map D3DPRIMITIVETYPE to bytes needed in command stream
const prim2cmdsz[] = {
    0, // Invalid
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2POINTS),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2LINELIST),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2LINESTRIP),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLELIST),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLESTRIP),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLEFAN)
};

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::DrawPrim"

HRESULT CDirect3DDeviceIDP2::DrawPrim()
{
    HRESULT ret = D3D_OK;
    DWORD dwVertexPoolSize = this->dwNumVertices * this->dwOutputSize;
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        UpdateTextures();
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }
    // This primitive is generated by the clipper.
    // The vertices of this primitive are pointed to by the
    // lpvOut member, which need to be copied into the
    // command stream immediately after the command itself.
    if (this->dwFlags & D3DPV_CLIPPERPRIM)
    {
        DWORD dwExtra = 0;
        LPVOID lpvVerticesImm;  // Place for vertices
        if (this->primType == D3DPT_TRIANGLEFAN)
        {
            if (rstates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME &&
                this->dwFlags & D3DPV_NONCLIPPED)
            {
                // For unclipped (but pretended to be clipped) tri fans in
                // wireframe mode we generate 3-vertex tri fans to enable drawing of
                // interior edges
                BYTE vertices[__MAX_VERTEX_SIZE*3];
                BYTE *pV1 = vertices + this->dwOutputSize;
                BYTE *pV2 = pV1 + this->dwOutputSize;
                BYTE *pInput = (BYTE*)this->lpvOut;
                memcpy(vertices, pInput, this->dwOutputSize);
                pInput += this->dwOutputSize;
                const DWORD nTriangles = this->dwNumVertices - 2;
                this->dwNumVertices = 3;
                this->dwNumPrimitives = 1;
                this->lpvOut = vertices;
                this->dwFlags &= ~D3DPV_NONCLIPPED;  // Remove this flag for recursive call
                for (DWORD i = nTriangles; i; i--)
                {
                    memcpy(pV1, pInput, this->dwOutputSize);
                    memcpy(pV2, pInput+this->dwOutputSize, this->dwOutputSize);
                    pInput += this->dwOutputSize;
                    // To enable all edge flag we set the fill mode to SOLID.
                    // This will prevent checking the clip flags in the clipper state.
                    rstates[D3DRENDERSTATE_FILLMODE] = D3DFILL_SOLID;
                    ret = DrawPrim();
                    rstates[D3DRENDERSTATE_FILLMODE] = D3DFILL_WIREFRAME;
                    if (ret != D3D_OK)
                            return ret;
                }
                return D3D_OK;
            }
            dwExtra = sizeof(D3DHAL_DP2TRIANGLEFAN_IMM);
        }
        DWORD dwPad = (sizeof(D3DHAL_DP2COMMAND) + dwDP2CommandLength + dwExtra) & 3;
        DWORD dwByteCount = sizeof(D3DHAL_DP2COMMAND) + dwPad + dwExtra + dwVertexPoolSize;

        // Check for space in the command buffer for commands & vertices
        if (dwDP2CommandLength + dwByteCount > dwDP2CommandBufSize)
        {
            // Flush the current batch but hold on to the vertices
            ret = FlushStates();
            if (ret != D3D_OK)
                return ret;
            if (dwByteCount > dwDP2CommandBufSize)
            {
                ret = GrowCommandBuffer(this->lpDirect3DI, dwByteCount);
                if (ret != D3D_OK)
                {
                    D3D_ERR("Could not grow Command Buffer");
                    return ret;
                }
            }

            dwPad = (sizeof(D3DHAL_DP2COMMAND) + dwExtra) & 3;
            dwByteCount = sizeof(D3DHAL_DP2COMMAND) + dwExtra + dwPad + dwVertexPoolSize;
        }
        lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                            dwDP2CommandLength + dp2data.dwCommandOffset);
        lpDP2CurrCommand->wPrimitiveCount = (WORD)this->dwNumPrimitives;
        lpDP2CurrCommand->bReserved = 0;
        if (this->primType == D3DPT_TRIANGLEFAN)
        {
            // Insert inline instruction and vertices
            bDP2CurrCmdOP = D3DDP2OP_TRIANGLEFAN_IMM;
            lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
            D3D_INFO(6, "Write Ins :%08lx @ %08lx", *(LPDWORD)lpDP2CurrCommand,lpDP2CurrCommand);
            LPD3DHAL_DP2TRIANGLEFAN_IMM lpTriFanImm = (LPD3DHAL_DP2TRIANGLEFAN_IMM)(lpDP2CurrCommand + 1);
            if (rstates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME)
            {
                lpTriFanImm->dwEdgeFlags = 0;
                ClipVertex **clip = this->ClipperState.current_vbuf;
                // Look at the exterior edges and mark the visible ones
                for(DWORD i = 0; i < this->dwNumVertices; ++i)
                {
                    if (clip[i]->clip & CLIPPED_ENABLE)
                        lpTriFanImm->dwEdgeFlags |= (1 << i);
                }
            }
            else
            {
                // Mark all exterior edges visible
                lpTriFanImm->dwEdgeFlags = 0xFFFFFFFF;
            }
            lpvVerticesImm = (LPBYTE)(lpTriFanImm + 1) + dwPad;
        }
        else
        {
            // Insert inline instruction and vertices
            bDP2CurrCmdOP = D3DDP2OP_LINELIST_IMM;
            lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
            D3D_INFO(6, "Write Ins :%08lx @ %08lx", *(LPDWORD)lpDP2CurrCommand,lpDP2CurrCommand);
            lpvVerticesImm = (LPBYTE)(lpDP2CurrCommand + 1) + dwPad;
        }
        memcpy(lpvVerticesImm, this->lpvOut, dwVertexPoolSize);
        dwDP2CommandLength += dwByteCount;
    }
    else
    {
        // Check for space in the command buffer for new command.
        // The vertices are already in the vertex buffer.
        if (dwDP2CommandLength + prim2cmdsz[this->primType] > dwDP2CommandBufSize)
        {
            ret = FlushStates();
            if (ret != D3D_OK)
                return ret;
        }
        // Insert non indexed primitive instruction
        lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                            dwDP2CommandLength + dp2data.dwCommandOffset);
        bDP2CurrCmdOP = (BYTE)prim2cmdop[this->primType];
        lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
        lpDP2CurrCommand->bReserved = 0;
        switch(bDP2CurrCmdOP)
        {
        case D3DDP2OP_POINTS:
            {
                lpDP2CurrCommand->wPrimitiveCount = 1;
                LPD3DHAL_DP2POINTS lpPoints = (LPD3DHAL_DP2POINTS)(lpDP2CurrCommand + 1);
                lpPoints->wCount = (WORD)this->dwNumVertices;
                lpPoints->wVStart = (WORD)this->dwVertexBase;
                D3D_INFO(6, "Write Ins :%08lx @ %08lx", *(LPDWORD)lpDP2CurrCommand,lpDP2CurrCommand);
                D3D_INFO(6, "Write Data:%08lx", *(LPDWORD)lpPoints);
            }
            break;
        case D3DDP2OP_LINELIST:
        case D3DDP2OP_TRIANGLELIST:
            {
                lpDP2CurrCommand->wPrimitiveCount = (WORD)this->dwNumPrimitives;
                // Linelist and trianglelist are identical
                LPD3DHAL_DP2LINELIST lpLines = (LPD3DHAL_DP2LINELIST)(lpDP2CurrCommand + 1);
                lpLines->wVStart = (WORD)this->dwVertexBase;
                D3D_INFO(6, "Write Ins :%08lx @ %08lx", *(LPDWORD)lpDP2CurrCommand,lpDP2CurrCommand);
                D3D_INFO(6, "Write Data:%08lx", (DWORD)lpLines->wVStart);
            }
            break;
        default: // strips or fans
            {
                lpDP2CurrCommand->wPrimitiveCount = (WORD)this->dwNumPrimitives;
                // Linestrip, trianglestrip and trianglefan are identical
                LPD3DHAL_DP2LINESTRIP lpStrip = (LPD3DHAL_DP2LINESTRIP)(lpDP2CurrCommand + 1);
                lpStrip->wVStart = (WORD)this->dwVertexBase;
                D3D_INFO(6, "Write Ins :%08lx @ %08lx", *(LPDWORD)lpDP2CurrCommand,lpDP2CurrCommand);
                D3D_INFO(6, "Write Data:%08lx", (DWORD)lpStrip->wVStart);
            }
        }
        wDP2CurrCmdCnt = lpDP2CurrCommand->wPrimitiveCount;
        dwDP2CommandLength += prim2cmdsz[this->primType];
    }
    // We have batched some stuff, so we could be within a primitive
    // Unless the higher functions clear this flag we need to assume
    // we are mid-primitive during our flushes.
    this->dwFlags |= D3DPV_WITHINPRIMITIVE;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetTextureStageState"

HRESULT D3DAPI
CDirect3DDeviceIDP2::SetTextureStageState(DWORD dwStage,
                                          D3DTEXTURESTAGESTATETYPE dwState,
                                          DWORD dwValue)
{
    // Holds D3D lock until exit.
    CLockD3DMT ldmLock(this, DPF_MODNAME, REMIND(""));

#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES ||
        dwState == 0 || dwState >= D3DTSS_MAX)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif //DBG

    HRESULT hr;

    if (this->tsstates[dwStage][dwState] == dwValue)
    {
        D3D_WARN(4,"Ignoring redundant SetTextureStageState");
        return D3D_OK;
    }

    // Update runtime copy of state.
    DWORD dwOldValue = tsstates[dwStage][dwState];
    tsstates[dwStage][dwState] = dwValue;

    if (dwState == D3DTSS_TEXCOORDINDEX && TextureStageEnabled(this, dwStage) ||
        dwState == D3DTSS_COLOROP &&
        ((dwValue == D3DTOP_DISABLE) == !(dwOldValue == D3DTOP_DISABLE)))
    {
        this->dwFVFLastIn = 0;  // Force to recompute output VID
        this->dwFEFlags |= D3DFE_TSSINDEX_DIRTY;
    }

    if (dwStage >= dwMaxTextureBlendStages) return  D3D_OK; // Ignore higher stage states

    hr = SetTSSI(dwStage, dwState, dwValue);

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetTSSI"

HRESULT CDirect3DDeviceIDP2::SetTSSI(DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue)
{
    HRESULT ret = D3D_OK;
    if (bDP2CurrCmdOP == D3DDP2OP_TEXTURESTAGESTATE)
    { // Last instruction is a texture stage state, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2TEXTURESTAGESTATE) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2TEXTURESTAGESTATE lpRState = (LPD3DHAL_DP2TEXTURESTAGESTATE)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpRState->wStage = (WORD)dwStage;
            lpRState->TSState = (WORD)dwState;
            lpRState->dwValue = dwValue;
            dwDP2CommandLength += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
        D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return ret;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2TEXTURESTAGESTATE) > dwDP2CommandBufSize)
    {
            ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in SetTSSI");
                return ret;
            }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_TEXTURESTAGESTATE;
    bDP2CurrCmdOP = D3DDP2OP_TEXTURESTAGESTATE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add renderstate data
    LPD3DHAL_DP2TEXTURESTAGESTATE lpRState = (LPD3DHAL_DP2TEXTURESTAGESTATE)(lpDP2CurrCommand + 1);
    lpRState->wStage = (WORD)dwStage;
    lpRState->TSState = (WORD)dwState;
    lpRState->dwValue = dwValue;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::ValidateDevice"

HRESULT D3DAPI
CDirect3DDeviceIDP2::ValidateDevice(LPDWORD lpdwNumPasses)
{
    // Holds D3D lock until exit.
    CLockD3DMT ldmLock(this, DPF_MODNAME, REMIND(""));
    HRESULT ret;
    D3DHAL_VALIDATETEXTURESTAGESTATEDATA vbod;

    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR(lpdwNumPasses, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid lpdwNumPasses pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    // First, Update textures since drivers pass /fail this call based
    // on the current texture handles
    ret = UpdateTextures();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to update managed textures in ValidateDevice");
        return ret;
    }
    // Second, flush states, so we can validate the current state
    ret = FlushStates();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to FlushStates in ValidateDevice");
        return ret;
    }

    // Now ask the driver!

    *lpdwNumPasses = 0;
    memset(&vbod, 0, sizeof(D3DHAL_VALIDATETEXTURESTAGESTATEDATA));
    vbod.dwhContext = this->dwhContext;
    if (this->lpD3DHALCallbacks3->ValidateTextureStageState)
    {
         CALL_HAL3ONLY(ret, this, ValidateTextureStageState, &vbod);
         if (ret != DDHAL_DRIVER_HANDLED)
             return DDERR_UNSUPPORTED;

         *lpdwNumPasses = vbod.dwNumPasses;
         return vbod.ddrval;
    }
    else
    {
        D3D_ERR("Error: ValidateTextureStageState not supported by the driver.");
    }

    return DDERR_UNSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::StartPrimVB"
//---------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called only if vertices from user memory are NOT used for rendering
//
HRESULT CDirect3DDeviceIDP2::StartPrimVB(LPDIRECT3DVERTEXBUFFERI lpVBI,
                                         DWORD dwStartVertex)
{
    HRESULT ret = D3D_OK;

    // If VID has been changed or new vertex buffer is used we flush the batch
    if (this->dwVIDOut != dp2data.dwVertexType ||
        lpDP2CurrBatchVBI != lpVBI ||
        dp2data.lpDDVertex != ((LPDDRAWI_DDRAWSURFACE_INT)(lpVBI->GetDDS()))->lpLcl)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
            return ret;
        dp2data.dwVertexType = this->dwVIDOut;
        dp2data.dwVertexSize = this->dwOutputSize;
        dp2data.lpDDVertex = ((LPDDRAWI_DDRAWSURFACE_INT)(lpVBI->GetDDS()))->lpLcl;
        // Release previously used vertex buffer (if any), because we do not
        // need it any more. We did AddRef() to TL buffer, so it is safe.
        if (lpDP2CurrBatchVBI)
            lpDP2CurrBatchVBI->Release();
        // If a vertex buffer is used for rendering, make sure that it is not
        // released by user. So do AddRef().
        lpDP2CurrBatchVBI = lpVBI;
        lpDP2CurrBatchVBI->AddRef();
    }
    if (this->TLVbuf.GetVBI() == lpVBI)
    {
        this->dwVertexBase = this->dp2data.dwVertexLength;
        DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
        dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER;
    }
    else
    {
        this->dwVertexBase = dwStartVertex;
        dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
    }
    this->dp2data.dwVertexLength = this->dwVertexBase + this->dwNumVertices;
    this->dwFlags |= D3DPV_WITHINPRIMITIVE;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::StartPrimUserMem"
//---------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called if vertices from user memory is used for rendering
//
HRESULT CDirect3DDeviceIDP2::StartPrimUserMem(LPVOID lpMem)
{
    const DWORD vertexPoolSize = this->dwNumVertices * this->dwOutputSize;
    HRESULT ret = D3D_OK;

    // If the primitive is small, we copy vertices into the TL buffer
    if (this->dwNumVertices < LOWVERTICESNUMBER)
    {
        if (vertexPoolSize > this->TLVbuf.GetSize())
        {
            if (this->TLVbuf.Grow(this, vertexPoolSize) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                ret = DDERR_OUTOFMEMORY;
                goto l_exit;
            }
        }
        // So now user memory is not used any more.
        ret = StartPrimVB(this->TLVbuf.GetVBI(), 0);
        if (ret != D3D_OK)
            goto l_exit;
        LPVOID tmp = this->TLVbuf.GetAddress();
        memcpy(tmp, this->lpvOut, vertexPoolSize);
        // We have to update lpvOut, because it was set to user memory
        this->lpvOut = tmp;
    }
    else
    {
        // We can not mix user memory primitive with other primitives, so
        // flush the batch.
        // Do not forget to flush the batch after rendering this primitive
        ret = this->FlushStates();
        if (ret != D3D_OK)
            goto l_exit;
        // Release previously used vertex buffer (if any), because we do not
        // it any more
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->Release();
            lpDP2CurrBatchVBI = NULL;
        }
        dp2data.dwVertexType = this->dwVIDOut;
        dp2data.dwVertexSize = this->dwOutputSize;
        dp2data.lpVertices = lpMem;
        dp2data.dwFlags |= D3DHALDP2_USERMEMVERTICES;
        dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        dp2data.dwVertexLength = this->dwNumVertices;
        this->dwFlags |= D3DPV_USERMEMVERTICES;
    }
l_exit:
    this->dwFlags |= D3DPV_WITHINPRIMITIVE;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::EndPrim"
//---------------------------------------------------------------------
// This function should not be called from DrawVertexBufferVB
//
HRESULT CDirect3DDeviceIDP2::EndPrim(DWORD dwVertexPoolSize)
{
    HRESULT ret = D3D_OK;
    if (this->dwFlags & D3DPV_USERMEMVERTICES)
        // We can not mix user memory primitive, so flush it.
        ret = this->FlushStates();
    else
    {
        // If TL buffer was used, we have to move its internal base pointer
        this->TLVbuf.Base() += dwVertexPoolSize;
    }

    this->dwFlags &= ~(D3DPV_USERMEMVERTICES | D3DPV_WITHINPRIMITIVE);
    return ret;
}

//---------------------------------------------------------------------
//
//
HRESULT CDirect3DDeviceIDP2::UpdateDrvViewInfo(LPD3DVIEWPORT2 lpVwpData)
{
    HRESULT ret = D3D_OK;

    // Check to see if there is space to add a new command for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2VIEWPORTINFO) > dwDP2CommandBufSize)
    {
            ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in UpdateDrvViewInfo");
                return ret;
            }
    }
    // Add new ViewInfo instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_VIEWPORTINFO;
    bDP2CurrCmdOP = D3DDP2OP_VIEWPORTINFO;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);

    // Add ViewInfo data
    LPD3DHAL_DP2VIEWPORTINFO lpVpInfo = (LPD3DHAL_DP2VIEWPORTINFO)(lpDP2CurrCommand + 1);
    lpVpInfo->dwX = lpVwpData->dwX;
    lpVpInfo->dwY = lpVwpData->dwY;
    lpVpInfo->dwWidth = lpVwpData->dwWidth;
    lpVpInfo->dwHeight = lpVwpData->dwHeight;

    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VIEWPORTINFO);
    return ret;
}

//---------------------------------------------------------------------
//
//
HRESULT CDirect3DDeviceIDP2::UpdateDrvWInfo()
{
    HRESULT ret = D3D_OK;

    // Check to see if there is space to add a new command for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2WINFO) > dwDP2CommandBufSize)
    {
            ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in UpdateDrvViewInfo");
                return ret;
            }
    }
    // Add new WInfo instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_WINFO;
    bDP2CurrCmdOP = D3DDP2OP_WINFO;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);

    // Add WInfo data
    D3DMATRIXI &m = transform.proj;

    LPD3DHAL_DP2WINFO lpWInfo = (LPD3DHAL_DP2WINFO)(lpDP2CurrCommand + 1);
    if( (m._33 == m._34) || (m._33 == 0.0f) )
    {
        D3D_ERR( "Cannot compute WNear and WFar from the supplied projection matrix.\n Setting wNear to 0.0 and wFar to 1.0" );
        lpWInfo->dvWNear = 0.0f;
        lpWInfo->dvWFar  = 1.0f;
        dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2WINFO);
        return ret;
    }
    
    lpWInfo->dvWNear = m._44 - m._43/m._33*m._34;
    lpWInfo->dvWFar  = (m._44 - m._43)/(m._33 - m._34)*m._34 + m._44;

    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2WINFO);
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::UpdatePalette"
//---------------------------------------------------------------------
// This function should be called from PaletteUpdateNotify
//
HRESULT CDirect3DDeviceIDP2::UpdatePalette(
        DWORD dwPaletteHandle,
        DWORD dwStartIndex,
        DWORD dwNumberOfIndices,
        LPPALETTEENTRY pFirstIndex)
{
    HRESULT ret = D3D_OK;
    DWORD   dwSizeChange=sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2UPDATEPALETTE) + dwNumberOfIndices*sizeof(PALETTEENTRY);
    if (bDP2CurrCmdOP == D3DDP2OP_UPDATEPALETTE)
    { // Last instruction is a tex blt, append this one to it
    }
    // Check for space
    if (dwDP2CommandLength + dwSizeChange > dwDP2CommandBufSize)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in TexBltI");
            return ret;
        }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_UPDATEPALETTE;
    bDP2CurrCmdOP = D3DDP2OP_UPDATEPALETTE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add texture blt data
    LPD3DHAL_DP2UPDATEPALETTE lpUpdatePal = (LPD3DHAL_DP2UPDATEPALETTE)(lpDP2CurrCommand + 1);
    lpUpdatePal->dwPaletteHandle=dwPaletteHandle;
    lpUpdatePal->wStartIndex=(WORD)dwStartIndex; 
    lpUpdatePal->wNumEntries=(WORD)dwNumberOfIndices;
    memcpy((LPVOID)(lpUpdatePal+1),(LPVOID)pFirstIndex,
        dwNumberOfIndices*sizeof(PALETTEENTRY));
    dwDP2CommandLength += dwSizeChange;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetPalette"
//---------------------------------------------------------------------
// This function should be called from PaletteAssociateNotify
//
HRESULT CDirect3DDeviceIDP2::SetPalette(DWORD dwPaletteHandle, DWORD dwPaletteFlags, DWORD dwSurfaceHandle )
{
    HRESULT ret = D3D_OK;
    DWORD   dwSizeChange;
    if (bDP2CurrCmdOP == D3DDP2OP_SETPALETTE)
    { // Last instruction is a tex blt, append this one to it
    }

    dwSizeChange=sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETPALETTE);
    // Check for space
    if (dwDP2CommandLength + dwSizeChange > dwDP2CommandBufSize)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in TexBltI");
            return ret;
        }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    bDP2CurrCmdOP = lpDP2CurrCommand->bCommand = D3DDP2OP_SETPALETTE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    LPD3DHAL_DP2SETPALETTE lpSetPal = (LPD3DHAL_DP2SETPALETTE)(lpDP2CurrCommand + 1);
    lpSetPal->dwPaletteHandle=dwPaletteHandle;
    lpSetPal->dwPaletteFlags=dwPaletteFlags;
    lpSetPal->dwSurfaceHandle=dwSurfaceHandle; 
    dwDP2CommandLength += dwSizeChange;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetRenderTargetI"
void CDirect3DDeviceIDP2::SetRenderTargetI(LPDIRECTDRAWSURFACE pRenderTarget, LPDIRECTDRAWSURFACE pZBuffer)
{
    DWORD   dwSizeChange;
    dwSizeChange=sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETRENDERTARGET);
    // Check for space
    if (dwDP2CommandLength + dwSizeChange > dwDP2CommandBufSize)
    {
        if (FlushStates() != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in SetRenderTargetI");
            return;
        }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    bDP2CurrCmdOP = lpDP2CurrCommand->bCommand = D3DDP2OP_SETRENDERTARGET;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    LPD3DHAL_DP2SETRENDERTARGET pData = (LPD3DHAL_DP2SETRENDERTARGET)(lpDP2CurrCommand + 1);
    pData->hRenderTarget = ((LPDDRAWI_DDRAWSURFACE_INT)pRenderTarget)->lpLcl->lpSurfMore->dwSurfaceHandle;
    if (pZBuffer)
        pData->hZBuffer = ((LPDDRAWI_DDRAWSURFACE_INT)pZBuffer)->lpLcl->lpSurfMore->dwSurfaceHandle;
    else
        pData->hZBuffer = 0;
    dwDP2CommandLength += dwSizeChange;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::ClearI"

void CDirect3DDeviceIDP2::ClearI(DWORD dwFlags, DWORD clrCount, LPD3DRECT clrRects, D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil)
{
    DWORD dwCommandSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2CLEAR) + sizeof(RECT) * (clrCount - 1);

    // Check to see if there is space to add a new command for space
    if (dwCommandSize + dwDP2CommandLength > dwDP2CommandBufSize)
    {
        HRESULT ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands");
            throw ret;
        }
    }
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_CLEAR;
    bDP2CurrCmdOP = D3DDP2OP_CLEAR;
    lpDP2CurrCommand->bReserved = 0;
    wDP2CurrCmdCnt = (WORD)clrCount;
    lpDP2CurrCommand->wStateCount = wDP2CurrCmdCnt;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    dwDP2CommandLength += dwCommandSize;

    // Write data
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(lpDP2CurrCommand + 1);
    pData->dwFlags = dwFlags;
    pData->dwFillColor = dwColor;
    pData->dvFillDepth = dvZ;
    pData->dwFillStencil = dwStencil;
    memcpy(pData->Rects, clrRects, clrCount * sizeof(D3DRECT));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\halbuf.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   halbuf.c
 *  Content:    Direct3D HAL buffer management
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id: halbuf.c,v 1.1 1995/11/21 15:12:30 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   06/11/95   stevela Initial rev.
 *   07/11/95   stevela stuff.
 *   17/02/96   colinmc Fixed build problem.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

HRESULT D3DHAL_AllocateBuffer(LPDIRECT3DDEVICEI lpDevI,
                              LPD3DI_BUFFERHANDLE lphBuf,
                              LPD3DEXECUTEBUFFERDESC lpDebDesc,
                              LPDIRECTDRAWSURFACE* lplpBuf)
{
    DDSURFACEDESC ddsd;
    LPD3DHAL_EXDATA hexData;
    DWORD dwSize = lpDebDesc->dwBufferSize;
    HRESULT ddrval;

    D3D_INFO(6, "AllocateBuffer, dwhContext = %d, lpDebDesc = %08lx, size = %d",
        lpDevI->dwhContext, lpDebDesc, lpDebDesc->dwBufferSize);

    if ((!lpDebDesc->dwFlags) & D3DDEB_BUFSIZE) 
    {
        return (DDERR_INVALIDPARAMS);
    }

    D3DMalloc((void**)&hexData, sizeof(D3DHAL_EXDATA));
    if (!hexData) {
        D3D_ERR("Failed to create buffer internal data");
        return (D3DERR_EXECUTE_CREATE_FAILED);
    }
    memset(hexData, 0, sizeof(D3DHAL_EXDATA));

    hexData->debDesc = *lpDebDesc;

    /*
     * Create the buffer through DirectDraw
     */
    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    ddsd.dwFlags = DDSD_WIDTH | DDSD_CAPS;
    ddsd.dwWidth = hexData->debDesc.dwBufferSize;
    ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER;
// System memory exebufs only for now
//  if (hexData->debDesc.dwCaps & D3DDEBCAPS_VIDEOMEMORY) {
//      ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
//  } else {
    ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
//    }

    ddrval = lpDevI->lpDD->CreateSurface(&ddsd, &hexData->lpDDS, NULL);

    if (ddrval != DD_OK) {
        D3D_ERR("failed in AllocateBuffer");
        D3DFree(hexData);
        return (D3DERR_EXECUTE_CREATE_FAILED);
    }

    LIST_INSERT_ROOT(&lpDevI->bufferHandles, hexData, link);

    *lphBuf = (ULONG_PTR) hexData;
    *lplpBuf = hexData->lpDDS;

    memset(lpDebDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
    lpDebDesc->dwSize = sizeof(D3DEXECUTEBUFFERDESC);
    lpDebDesc->dwBufferSize = dwSize;
    if (hexData->debDesc.dwFlags & D3DDEB_CAPS)
    {
        lpDebDesc->dwCaps = hexData->debDesc.dwCaps;
        lpDebDesc->dwCaps &= ~DDSCAPS_VIDEOMEMORY;
        lpDebDesc->dwCaps |= DDSCAPS_SYSTEMMEMORY;
    }
    else
        lpDebDesc->dwCaps = DDSCAPS_SYSTEMMEMORY;
    lpDebDesc->dwFlags = D3DDEB_BUFSIZE | D3DDEB_CAPS;

    D3D_INFO(9, "AllocateBuffer, succeeded.");

    return (D3D_OK);
}

HRESULT D3DHAL_DeallocateBuffer(LPDIRECT3DDEVICEI lpDevI, D3DI_BUFFERHANDLE hBuf)
{
    LPD3DHAL_EXDATA hexData;
    HRESULT ddrval;

    D3D_INFO(6, "DeallocateBuffer, dwhContext = %d, hBuf = %08lx",
        lpDevI->dwhContext, hBuf);

    hexData = (LPD3DHAL_EXDATA) hBuf;

    TRY {
        ddrval = hexData->lpDDS->Release();
        if (ddrval != DD_OK) {
            D3D_ERR("did not free the memory");
            return (ddrval);
        }
    } EXCEPT (EXCEPTION_EXECUTE_HANDLER) {
        D3D_INFO(6, "Execute buffer surface was already freed by DirectDraw");
    }

    LIST_DELETE(hexData, link);
    D3DFree(hexData);

    return (D3D_OK);
}

HRESULT D3DHAL_DeallocateBuffers(LPDIRECT3DDEVICEI lpDevI)
{
    while (LIST_FIRST(&lpDevI->bufferHandles)) {
        D3DHAL_DeallocateBuffer(lpDevI,
                                (D3DI_BUFFERHANDLE)
                                LIST_FIRST(&lpDevI->bufferHandles));
    }
    return (D3D_OK);
}

HRESULT D3DHAL_LockBuffer(LPDIRECT3DDEVICEI lpDevI, D3DI_BUFFERHANDLE hBuf,
                          LPD3DEXECUTEBUFFERDESC lpUserDebDesc,
                          LPDIRECTDRAWSURFACE* lplpBuf)
{
    LPD3DHAL_EXDATA hexData;
    DDSURFACEDESC ddsd;
    HRESULT ddrval;

    D3D_INFO(6, "LockBuffer, dwhContext = %d, hBuf = %08lx",
        lpDevI->dwhContext, hBuf);

    hexData = (LPD3DHAL_EXDATA) hBuf;

#ifdef USE_INTERNAL_LOCK
    do {
        LPDDRAWI_DDRAWSURFACE_INT lpInt;
        lpInt = (LPDDRAWI_DDRAWSURFACE_INT) hexData->lpDDS;
        ddrval = DDInternalLock(lpInt->lpLcl, &ddsd.lpSurface);
    } while (ddrval == DDERR_WASSTILLDRAWING);
#else
    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    do {
        ddrval = hexData->lpDDS->Lock(NULL, &ddsd,
                                      DDLOCK_WAIT, NULL);
    } while (ddrval == DDERR_WASSTILLDRAWING);
#endif
    if (ddrval != DD_OK) {
        D3D_ERR("failed in LockBuffer");
        return (D3DERR_EXECUTE_LOCK_FAILED);
    }

    *lplpBuf = hexData->lpDDS;
    memset(lpUserDebDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
    lpUserDebDesc->dwSize = sizeof(D3DEXECUTEBUFFERDESC);
    lpUserDebDesc->dwBufferSize = hexData->debDesc.dwBufferSize;
    lpUserDebDesc->lpData = ddsd.lpSurface;
    lpUserDebDesc->dwFlags = D3DDEB_LPDATA;


    return (D3D_OK);
}

HRESULT D3DHAL_UnlockBuffer(LPDIRECT3DDEVICEI lpDevI, D3DI_BUFFERHANDLE hBuf)
{
    LPD3DHAL_EXDATA hexData;
    HRESULT ddrval;

    D3D_INFO(6, "UnlockBuffer, dwhContext = %d, hBuf = %08lx",
        lpDevI->dwhContext, hBuf);

    hexData = (LPD3DHAL_EXDATA) hBuf;

#ifdef USE_INTERNAL_LOCK
    {
        LPDDRAWI_DDRAWSURFACE_INT lpInt;
        lpInt = (LPDDRAWI_DDRAWSURFACE_INT) hexData->lpDDS;
        ddrval = DDInternalUnlock(lpInt->lpLcl);
    }
#else
    ddrval = hexData->lpDDS->Unlock(NULL);
#endif
    if (ddrval != DD_OK) {
        D3D_ERR("didn't handle handle UnlockBuffer");
        return (ddrval);
    }

    return (D3D_OK);
}

#ifndef USE_SURFACE_LOCK

HRESULT D3DHAL_LockDibEngine(LPDIRECT3DDEVICEI lpDevI)
{
#ifndef WIN95
    return D3D_OK;
#else
    HRESULT ret;
    LPDDRAWI_DIRECTDRAW_GBL pdrv = lpDevI->lpDDGbl;
    LPWORD pdflags;
    BOOL isbusy;

    pdflags = pdrv->lpwPDeviceFlags;
    isbusy = 0;

    _asm
    {
        mov eax, pdflags
        bts word ptr [eax], BUSY_BIT
        adc isbusy,0
    }

    if (isbusy) {
        D3D_WARN(2, "LOCK_DIBENGINE, dibengine is busy");
        ret = DDERR_SURFACEBUSY;
    } else
        ret = DD_OK;

    return ret;
#endif
}

void D3DHAL_UnlockDibEngine(LPDIRECT3DDEVICEI lpDevI)
{
#ifndef WIN95
    return;
#else
    LPDDRAWI_DIRECTDRAW_GBL pdrv = lpDevI->lpDDGbl;
    *pdrv->lpwPDeviceFlags &= ~BUSY;
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\dpoldhal.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpoldhal.c
 *  Content:    DrawPrimitive implementation for legacy (DX2) HALs
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "drawprim.hpp"
#include "clipfunc.h"
#include "commdrv.hpp"

extern D3DLINE LineListPrecomp[];
extern D3DLINE LineStripPrecomp[];
extern D3DTRIANGLE TriangleListPrecomp[];
extern D3DTRIANGLE TriangleStripPrecomp[];
extern D3DTRIANGLE TriangleFanPrecomp[];

#define BFCULLTEST_TVertTri(TLV0,TLV1,TLV2) (((TLV1).sx-(TLV0).sx)*((TLV2).sy-(TLV0).sy) -  \
                                         ((TLV2).sx-(TLV0).sx)*((TLV1).sy-(TLV0).sy))

#define ISCULLED(lpDevI, CullTestRes) ((CullTestRes==0.0) ||   \
                                   ((lpDevI->rstates[D3DRENDERSTATE_CULLMODE]==D3DCULL_CW) ^ (CullTestRes < 0.0)))
//---------------------------------------------------------------------
void WaitForFlip( LPDIRECT3DDEVICEI lpDevI )
{
    if (! (lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwDevCaps  & D3DDEVCAPS_CANRENDERAFTERFLIP) )
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSTarget)->lpLcl;

        if (lpLcl->ddsCaps.dwCaps & DDSCAPS_FLIP) {
            HRESULT ret;
            D3D_INFO(5, "Waiting for flip");
            do {
                ret = lpDevI->lpDDSTarget->GetFlipStatus(DDGFS_ISFLIPDONE);
            } while (ret == DDERR_WASSTILLDRAWING);
        }
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "FlushStatesHW"

HRESULT CDirect3DDeviceIHW::FlushStates()
{
    DWORD i;

    LPDWORD lpScan = (LPDWORD) this->lpHWVertices;
    LPD3DTRIANGLE lpTriScan = (LPD3DTRIANGLE) this->lpHWTris;

    DWORD dwRet;
    D3DHAL_RENDERSTATEDATA StateData;
    D3DHAL_RENDERPRIMITIVEDATA PrimitiveData;
    CDDSurfaceFromMem TLBuffer(NULL);
    CDDSurfaceFromMem ExeBuffer(lpTriScan);

    FlushTextureFromDevice( this ); // delink all texture surfaces
    if (this->dwHWOffset == 0)    return D3D_OK;
    this->dwHWOffset = 0; //zeroed to prevent re-enter by drivers's locking surfaces

    // Legacy HAL, therefore we have to wait
    // until the render target has flipped.
    WaitForFlip(this);

    // Pick up Win16 lock
    LOCK_HAL( dwRet, this );
    LOCK_DIBENGINE(dwRet, this);
#if _D3D_FORCEDOUBLE
    CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE

    memset(&StateData, 0, sizeof(StateData) );
    memset(&PrimitiveData, 0, sizeof(PrimitiveData) );

    // dwHWNumCounts is the number of recorded structs with
    // primitives attached.
    for (i = 0; i < this->dwHWNumCounts+1; i += 1)
    {


        if ( this->lpHWCounts[i].wNumStateChanges )
        {
            TLBuffer.SetBits(lpScan);

            StateData.dwhContext = this->dwhContext;
            StateData.dwOffset = 0;
            StateData.dwCount = this->lpHWCounts[i].wNumStateChanges;
            StateData.lpExeBuf = TLBuffer.GetSurface();
            dwRet = (*this->lpD3DHALCallbacks->RenderState)(&StateData);
            // No provision for NOT_HANDLED

            lpScan += 2*this->lpHWCounts[i].wNumStateChanges;
            lpScan = (LPDWORD) ( (((ULONG_PTR) lpScan) + 31) & ~31);
        }

        if ( this->lpHWCounts[i].wNumVertices )
        {

            TLBuffer.SetBits(this->lpHWVertices);
            ExeBuffer.SetBits(lpTriScan);

            PrimitiveData.dwhContext = this->dwhContext;
            PrimitiveData.dwOffset = 0;
            PrimitiveData.dwStatus = 0;
            PrimitiveData.lpExeBuf = ExeBuffer.GetSurface();
            PrimitiveData.dwTLOffset = 0;
            PrimitiveData.lpTLBuf = TLBuffer.GetSurface();
            PrimitiveData.diInstruction.bOpcode = D3DOP_TRIANGLE;
            PrimitiveData.diInstruction.bSize = sizeof(D3DTRIANGLE);
            PrimitiveData.diInstruction.wCount = (WORD) this->lpHWCounts[i].wNumTriangles;
            dwRet = (*this->lpD3DHALCallbacks->RenderPrimitive)(&PrimitiveData);
            // No provision for NOT_HANDLED
            lpScan = (LPDWORD)(((LPD3DTLVERTEX) lpScan) + this->lpHWCounts[i].wNumVertices);
            lpTriScan += this->lpHWCounts[i].wNumTriangles;
        }
    }
    UNLOCK_DIBENGINE( this );
    UNLOCK_HAL( this );
    this->dwHWTriIndex = 0;
    this->dwHWNumCounts = 0;
    memset(this->lpHWCounts, 0, sizeof(D3DI_HWCOUNTS) );
        return  D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveLegacyHalCall"

HRESULT
DrawPrimitiveLegacyHalCall(CDirect3DDeviceIHW * lpDevI,
                           LPD3DTLVERTEX lpVertices, LPVOID lpvData,
                           LPD3DINSTRUCTION ins, DWORD dwNumVertices, D3DVERTEXTYPE VtxType)
{
    DWORD dwRet;
    CDDSurfaceFromMem TLBuffer(lpVertices);
    CDDSurfaceFromMem ExeBuffer(lpvData);
    D3DHAL_RENDERPRIMITIVEDATA rdata;

    memset(&rdata, 0, sizeof(rdata) );

    rdata.dwhContext = lpDevI->dwhContext;
    rdata.dwOffset = 0;
    rdata.dwStatus = 0;
    rdata.lpExeBuf = ExeBuffer.GetSurface();
    rdata.dwTLOffset = 0;
    rdata.lpTLBuf = TLBuffer.GetSurface();
    rdata.diInstruction = *ins;
#ifndef WIN95
    if((dwRet = CheckContextSurface(lpDevI)) != D3D_OK)
    {
        return (dwRet);
    }
#endif //WIN95
#if _D3D_FORCEDOUBLE
    CD3DForceFPUDouble  ForceFPUDouble(lpDevI);
#endif  //_D3D_FORCEDOUBLE
    CALL_HALONLY(dwRet, lpDevI, RenderPrimitive, &rdata);
    if (dwRet != DDHAL_DRIVER_HANDLED)
    {
        D3D_ERR ( "Driver not handled in DrawPrimitive" );
        // Need sensible return value in this case,
        // currently we return whatever the driver stuck in here.
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FillLegacyHalIndices"

void
FillLegacyHalIndices(D3DPRIMITIVETYPE PrimitiveType, LPVOID lpOut,
                     LPWORD lpwIndices, DWORD dwNumPrimitives)
{
    LPD3DLINE lpTmpLines;
    LPD3DTRIANGLE lpTmpTris;
    DWORD i;
    WORD wIndex = 0;

    switch (PrimitiveType)
    {
    case D3DPT_LINELIST:
        lpTmpLines = (LPD3DLINE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpLines[i].v1 = lpwIndices[wIndex++];
            lpTmpLines[i].v2 = lpwIndices[wIndex++];
        }
        break;
    case D3DPT_LINESTRIP:
        lpTmpLines = (LPD3DLINE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpLines[i].v1 = lpwIndices[wIndex++];
            lpTmpLines[i].v2 = lpwIndices[wIndex];
        }
        break;
    case D3DPT_TRIANGLELIST:
        lpTmpTris = (LPD3DTRIANGLE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpTris[i].v1 = lpwIndices[wIndex++];
            lpTmpTris[i].v2 = lpwIndices[wIndex++];
            lpTmpTris[i].v3 = lpwIndices[wIndex++];
            lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
        }

        break;
    case D3DPT_TRIANGLESTRIP:
        lpTmpTris = (LPD3DTRIANGLE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpTris[i].v1 = lpwIndices[wIndex++];
            lpTmpTris[i].v2 = lpwIndices[wIndex++];
            lpTmpTris[i].v3 = lpwIndices[wIndex++];
            lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
            i++;
            if (i<dwNumPrimitives)
            {
                lpTmpTris[i].v1 = lpTmpTris[i-1].v2;
                lpTmpTris[i].v2 = lpwIndices[wIndex--];
                lpTmpTris[i].v3 = lpTmpTris[i-1].v3;
                lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        lpTmpTris = (LPD3DTRIANGLE) lpOut;
        lpTmpTris[0].v3 = lpwIndices[wIndex++];
        lpTmpTris[0].v1 = lpwIndices[wIndex++];
        lpTmpTris[0].v2 = lpwIndices[wIndex++];
        lpTmpTris[0].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
        for (i = 1; i < dwNumPrimitives; i += 1)
        {
            lpTmpTris[i].v1 = lpTmpTris[i-1].v2;
            lpTmpTris[i].v2 = lpwIndices[wIndex++];
            lpTmpTris[i].v3 = lpTmpTris[i-1].v3;
            lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
        }
        break;
    }
}


#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveInBatchesHW"

HRESULT
DrawPrimitiveInBatchesHW(CDirect3DDeviceIHW * lpDevI, D3DPRIMITIVETYPE PrimitiveType, D3DVERTEXTYPE VertexType, LPD3DTLVERTEX lpVertices, DWORD dwNumPrimitives)
{
    DWORD i;
    D3DTLVERTEX tmpV;
    LPD3DTLVERTEX lpFirstVertex;
    D3DINSTRUCTION ins;
    HRESULT ret;

    switch (PrimitiveType)
    {
    case D3DPT_LINELIST:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, LineListPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount*2;
        }
        break;
    case D3DPT_LINESTRIP:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, LineStripPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLELIST:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, TriangleListPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += 3*ins.wCount;
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, TriangleStripPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLEFAN:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        // Save the first vertex to spoof the driver
        lpFirstVertex = lpVertices;
        tmpV = lpVertices[0];
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            tmpV = *lpVertices;
            *lpVertices = *lpFirstVertex;
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, TriangleFanPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            *lpVertices = tmpV;
            lpVertices += ins.wCount;
        }
        break;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrimitiveInBatchesHW"

HRESULT
DrawIndexedPrimitiveInBatchesHW(CDirect3DDeviceIHW * lpDevI,
                                D3DPRIMITIVETYPE PrimitiveType,
                                D3DVERTEXTYPE VertexType,
                                LPD3DTLVERTEX lpVertices,
                                DWORD dwNumPrimitives,
                                LPWORD lpwIndices)
{
    DWORD i;
    WORD tmpW;
    LPWORD lpFirstIndex;
    D3DINSTRUCTION ins;
    HRESULT ret;

    switch (PrimitiveType)
    {
    case D3DPT_LINELIST:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            FillLegacyHalIndices(PrimitiveType, lpDevI->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, lpDevI->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpwIndices += ins.wCount*2;
        }
        break;
    case D3DPT_LINESTRIP:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            FillLegacyHalIndices(PrimitiveType, lpDevI->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, lpDevI->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLELIST:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            FillLegacyHalIndices(PrimitiveType, lpDevI->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, lpDevI->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpwIndices += 3*ins.wCount;
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            FillLegacyHalIndices(PrimitiveType, lpDevI->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, lpDevI->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpwIndices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLEFAN:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        // Save the first index to spoof the driver
        lpFirstIndex = lpwIndices;
        tmpW = lpwIndices[0];
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            tmpW = *lpwIndices;
            *lpwIndices = *lpFirstIndex;
            FillLegacyHalIndices(PrimitiveType, lpDevI->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, lpDevI->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            *lpwIndices = tmpW;
            lpwIndices += ins.wCount;
        }
        break;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// This is a call for a clipped primitive
//
HRESULT CDirect3DDeviceIHW::DrawIndexPrim()
{
    LPD3DTLVERTEX lpVertices = (LPD3DTLVERTEX)this->lpvOut;
    DWORD dwNumVertices = this->dwNumVertices;
    DWORD dwNumPrimitives = this->dwNumPrimitives;
    WORD *lpwIndices = this->lpwIndices;
    HRESULT ret;

    // Do we need to map new texture stage operations to DX5 renderstates?
    if(this->dwFEFlags & D3DFE_MAP_TSS_TO_RS) {
        MapTSSToRS();
        this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS; // Reset request bit
    }
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        UpdateTextures();
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }

    // If the number of vertices is small, then just batch them.
    if ( (this->primType == D3DPT_TRIANGLELIST ||
          this->primType == D3DPT_TRIANGLEFAN ||
          this->primType == D3DPT_TRIANGLESTRIP) &&
          this->dwNumVertices < dwHWFewVertices)
    {
        LPD3DTRIANGLE lpTriOut;
        DWORD i,dwTriOutCount,iV0,iV1,iV2;
        WORD wVertexOffset;
        float fCullTestResult;
        BOOL bDoBFCulling;

        // Pad the offset, if needed.  But first save the offset to restore for
        // case in which no vertices are added to the buffer.  This is necessary
        // when renderstates are buffered before and after a non-visible primitive.
        DWORD dwHWOffsetSave = this->dwHWOffset;
        this->dwHWOffset = (this->dwHWOffset + 31) & ~31;

        if (this->dwHWOffset + dwNumVertices*sizeof(D3DTLVERTEX) >= dwHWBufferSize ||
            this->dwHWTriIndex + dwNumPrimitives >= dwHWMaxTris )
        {
            CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                                      // Release in the destructor
            ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in DrawIndexPrim");
                return ret;
            }
            dwHWOffsetSave = this->dwHWOffset;
        }

        LPVOID lpvBatchAddress = (char*)this->lpHWVertices + this->dwHWOffset;
        if (this->dwVIDOut == D3DFVF_TLVERTEX)
            memcpy(lpvBatchAddress, lpVertices,
                   this->dwNumVertices*sizeof(D3DTLVERTEX));
        else
        {
            // We have to map FVF vertices to the D3DTLVERTEX.
            // This is only the case when lpvOut points to the user input
            // buffer.
            HRESULT ret;
            // Output will be in the batch buffer
            if ((ret = MapFVFtoTLVertex(this, lpvBatchAddress)) != D3D_OK)
                return ret;
            lpVertices = (D3DTLVERTEX*)lpvBatchAddress;
        }
        lpTriOut = this->lpHWTris + this->dwHWTriIndex;
        wVertexOffset = (WORD) (this->dwHWOffset/sizeof(D3DTLVERTEX));

        dwTriOutCount=0;  bDoBFCulling=(this->rstates[D3DRENDERSTATE_CULLMODE]!=D3DCULL_NONE);

        switch (this->primType)
        {
        case D3DPT_TRIANGLELIST:
            iV0=0;  iV1=1;  iV2=2;
            for (i = 0; i < dwNumPrimitives; i++,iV0+=3,iV1+=3,iV2+=3)
            {
                if(bDoBFCulling)
                {
                    fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV1]],lpVertices[lpwIndices[iV2]]);
                    if(ISCULLED(this, fCullTestResult))
                        continue;
                }

                lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                lpTriOut->v2 = lpwIndices[iV1] + wVertexOffset;
                lpTriOut->v3 = lpwIndices[iV2] + wVertexOffset;
                lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                lpTriOut += 1;
                dwTriOutCount++;
            }
            break;

        case D3DPT_TRIANGLEFAN:
            iV0=1;  iV1=2; iV2=0;
            for (i = 0; i < dwNumPrimitives; i++,iV0++,iV1++)
            {
                if(bDoBFCulling)
                {
                    fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV1]],lpVertices[lpwIndices[iV2]]);
                    if(ISCULLED(this, fCullTestResult))
                        continue;
                }

                lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                lpTriOut->v2 = lpwIndices[iV1] + wVertexOffset;
                lpTriOut->v3 = lpwIndices[iV2] + wVertexOffset;
                lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                lpTriOut += 1;
                dwTriOutCount++;
            }
            break;

        case D3DPT_TRIANGLESTRIP:
            iV0=0;  iV1=1;  iV2=2;
            for (i = 0; i < dwNumPrimitives; i++,iV0++,iV1++,iV2++)
            {
                if(bDoBFCulling)
                {
                    fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV1]],lpVertices[lpwIndices[iV2]]);
                    if(ISCULLED(this, fCullTestResult))
                        goto SecondTri;
                }

                lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                lpTriOut->v2 = lpwIndices[iV1] + wVertexOffset;
                lpTriOut->v3 = lpwIndices[iV2] + wVertexOffset;
                lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                lpTriOut += 1;
                dwTriOutCount++;

            SecondTri:

                i++;
                if(i < dwNumPrimitives)
                {
                    iV0++,iV1++,iV2++;

                    // swap vtx order for every 2nd tri

                    if(bDoBFCulling)
                    {
                        fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV2]],lpVertices[lpwIndices[iV1]]);
                        if(ISCULLED(this, fCullTestResult))
                            continue;
                    }

                    lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                    lpTriOut->v2 = lpwIndices[iV2] + wVertexOffset;
                    lpTriOut->v3 = lpwIndices[iV1] + wVertexOffset;
                    lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                    lpTriOut += 1;
                    dwTriOutCount++;
                }
            }
            break;
        }

        if(dwTriOutCount==0)
        {
            this->dwHWOffset = dwHWOffsetSave;    //  restore unpadded offset
            return D3D_OK;  // avoid adding unused verts to output
        }

        this->lpHWCounts[this->dwHWNumCounts].wNumTriangles += (WORD) dwTriOutCount;
        this->lpHWCounts[this->dwHWNumCounts].wNumVertices += (WORD) dwNumVertices;

        this->dwHWOffset += dwNumVertices * sizeof(D3DTLVERTEX);
        this->dwHWTriIndex += dwTriOutCount;

        return D3D_OK;
    }
    else
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                                  // Release in the destructor
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in DrawIndexPrim");
            return ret;
        }
        // We have to map FVF vertices to the D3DTLVERTEX.
        // This is only the case when lpvOut points to the user input buffer.
        if (this->dwVIDOut != D3DFVF_TLVERTEX)
        {
            HRESULT ret;
            // Output will be in the TL buffer
            if ((ret = MapFVFtoTLVertex(this, NULL)) != D3D_OK)
                return ret;
            lpVertices = (D3DTLVERTEX*)this->TLVbuf.GetAddress();
        }
        ret = DrawIndexedPrimitiveInBatchesHW(this, this->primType,
                                              D3DVT_TLVERTEX, lpVertices,
                                              dwNumPrimitives, this->lpwIndices);
        return ret;
    }
}
//---------------------------------------------------------------------
// This is a call for a clipped primitive
//
HRESULT CDirect3DDeviceIHW::DrawPrim()
{
    D3DPOINT TmpPoint;
    D3DINSTRUCTION ins = {D3DOP_POINT, sizeof(D3DPOINT), 1};
    LPD3DTLVERTEX lpVertices = (LPD3DTLVERTEX)this->lpvOut;

    // Do we need to map new texture stage operations to DX5 renderstates?
    if(this->dwFEFlags & D3DFE_MAP_TSS_TO_RS) {
        MapTSSToRS();
        this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS; // Reset request bit
    }
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        UpdateTextures();
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }

    // If the number of vertices is small, and none require
    // clipping, then just batch them.
    if ((this->primType == D3DPT_TRIANGLELIST ||
         this->primType == D3DPT_TRIANGLEFAN ||
         this->primType == D3DPT_TRIANGLESTRIP) &&
         this->dwNumVertices < dwHWFewVertices)
    {
        LPD3DTRIANGLE lpTriOut, lpTriPrim;
        DWORD i, dwTriOutCount;
        WORD wVertexOffset;
        float fCullTestResult;
        BOOL bDoBFCulling;

        // Pad the offset, if needed.  But first save the offset to restore for
        // case in which no vertices are added to the buffer.  This is necessary
        // when renderstates are buffered before and after a non-visible primitive.
        DWORD dwHWOffsetSave = this->dwHWOffset;
        this->dwHWOffset = (this->dwHWOffset + 31) & ~31;

        if (this->dwHWOffset +
            this->dwNumVertices * sizeof(D3DTLVERTEX) >= dwHWBufferSize ||
            this->dwHWTriIndex + this->dwNumPrimitives >= dwHWMaxTris )
        {
            // Takes D3D lock (ST only).
            CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));
            HRESULT ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in DrawPrim");
                return ret;
            }
            dwHWOffsetSave = this->dwHWOffset;
        }

        LPVOID lpvBatchAddress = (char*)this->lpHWVertices + this->dwHWOffset;
        if (this->dwVIDOut == D3DFVF_TLVERTEX)
            memcpy(lpvBatchAddress, lpVertices,
                   this->dwNumVertices*sizeof(D3DTLVERTEX));
        else
        {
            // We have to map FVF vertices to the D3DTLVERTEX.
            // This is only the case when lpvOut points to the user input
            // buffer.
            HRESULT ret;
            // Output will be in the batch buffer
            if ((ret = MapFVFtoTLVertex(this, lpvBatchAddress)) != D3D_OK)
                return ret;
            lpVertices = (LPD3DTLVERTEX)lpvBatchAddress;
        }
        switch (this->primType)
        {
        case D3DPT_TRIANGLELIST:
            lpTriPrim = TriangleListPrecomp;
            break;
        case D3DPT_TRIANGLEFAN:
            lpTriPrim = TriangleFanPrecomp;
            break;
        case D3DPT_TRIANGLESTRIP:
            lpTriPrim = TriangleStripPrecomp;
            break;
        }
        wVertexOffset = (WORD) (this->dwHWOffset/sizeof(D3DTLVERTEX));
        lpTriOut = this->lpHWTris + this->dwHWTriIndex;

        bDoBFCulling = (this->rstates[D3DRENDERSTATE_CULLMODE]!=D3DCULL_NONE);

        for (dwTriOutCount=0, i = 0; i < this->dwNumPrimitives; i++, lpTriPrim += 1)
        {
            if(bDoBFCulling)
            {
                fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpTriPrim->v1],lpVertices[lpTriPrim->v2],lpVertices[lpTriPrim->v3]);
                if(ISCULLED(this, fCullTestResult))
                    continue;
            }

            lpTriOut->v1 = lpTriPrim->v1 + wVertexOffset;
            lpTriOut->v2 = lpTriPrim->v2 + wVertexOffset;
            lpTriOut->v3 = lpTriPrim->v3 + wVertexOffset;
            lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
            lpTriOut += 1;
            dwTriOutCount++;
        }

        if(dwTriOutCount==0)
        {
            this->dwHWOffset = dwHWOffsetSave;    //  restore unpadded offset
            return D3D_OK;  // avoid adding unused verts to output
        }

        this->lpHWCounts[this->dwHWNumCounts].wNumTriangles += (WORD) dwTriOutCount;
        this->lpHWCounts[this->dwHWNumCounts].wNumVertices += (WORD)this->dwNumVertices;

        this->dwHWOffset += this->dwNumVertices * sizeof(D3DTLVERTEX);
        this->dwHWTriIndex += dwTriOutCount;

        return D3D_OK;
    }
    else
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                                  // Release in the destructor
        HRESULT ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in DrawPrim");
            return ret;
        }
        // We have to map FVF vertices to the D3DTLVERTEX.
        // This is only the case when lpvOut points to the user input buffer.
        if (this->dwVIDOut != D3DFVF_TLVERTEX)
        {
            HRESULT ret;
            // Output will be in the TL buffer
            if ((ret = MapFVFtoTLVertex(this, NULL)) != D3D_OK)
                return ret;
            lpVertices = (D3DTLVERTEX*)this->TLVbuf.GetAddress();
        }
        if (this->primType == D3DPT_POINTLIST)
        {
            TmpPoint.wFirst = 0;
            TmpPoint.wCount = (WORD)this->dwNumPrimitives;
            return DrawPrimitiveLegacyHalCall(this, lpVertices, &TmpPoint,
                                              &ins, 0, D3DVT_TLVERTEX);
        }
        else
            return DrawPrimitiveInBatchesHW(this, this->primType,
                                            D3DVT_TLVERTEX, lpVertices,
                                            this->dwNumPrimitives);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::SetTextureStageState"

HRESULT D3DAPI
CDirect3DDeviceIHW::SetTextureStageState(DWORD dwStage,
                                         D3DTEXTURESTAGESTATETYPE dwState,
                                         DWORD dwValue)
{
    // Holds D3D lock until exit.
    CLockD3DMT ldmLock(this, DPF_MODNAME, REMIND(""));

#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES ||
        dwState == 0 || dwState >= D3DTSS_MAX)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif //DBG

    // Update runtime copy of state.
    DWORD dwOldValue = tsstates[dwStage][dwState];
    tsstates[dwStage][dwState] = dwValue;
    if (dwStage > 0 ) return  D3D_OK;   // Ignore higher stage states

    if (dwState == D3DTSS_TEXCOORDINDEX && TextureStageEnabled(this, dwStage) ||
        dwState == D3DTSS_COLOROP &&
        ((dwValue == D3DTOP_DISABLE) == !(dwOldValue == D3DTOP_DISABLE)))
    {
        this->dwFVFLastIn = 0;  // Force to recompute outputVID
        this->dwFEFlags |= D3DFE_TSSINDEX_DIRTY;
    }

    switch(dwState) {
    case D3DTSS_ADDRESS:
        if(this->rstates[D3DRENDERSTATE_TEXTUREADDRESS] != dwValue) {
            SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREADDRESS, dwValue);
            return SetRenderStateI(D3DRENDERSTATE_TEXTUREADDRESS, dwValue);
        }
        else {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        break;
    case D3DTSS_ADDRESSU:
        if(this->rstates[D3DRENDERSTATE_TEXTUREADDRESSU] != dwValue) {
            SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREADDRESSU, dwValue);
            return SetRenderStateI(D3DRENDERSTATE_TEXTUREADDRESSU, dwValue);
        }
        else {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        break;
    case D3DTSS_ADDRESSV:
        if(this->rstates[D3DRENDERSTATE_TEXTUREADDRESSV] != dwValue) {
            SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREADDRESSV, dwValue);
            return SetRenderStateI(D3DRENDERSTATE_TEXTUREADDRESSV, dwValue);
        }
        else {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        break;
    case D3DTSS_BORDERCOLOR:
        if(this->rstates[D3DRENDERSTATE_BORDERCOLOR] != dwValue) {
            SetDeviceRenderState(this, D3DRENDERSTATE_BORDERCOLOR, dwValue);
            return SetRenderStateI(D3DRENDERSTATE_BORDERCOLOR, dwValue);
        }
        else {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        break;
    case D3DTSS_MIPMAPLODBIAS:
        if(this->rstates[D3DRENDERSTATE_MIPMAPLODBIAS] != dwValue) {
            SetDeviceRenderState(this, D3DRENDERSTATE_MIPMAPLODBIAS, dwValue);
            return SetRenderStateI(D3DRENDERSTATE_MIPMAPLODBIAS, dwValue);
        }
        else {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        break;
    case D3DTSS_MAXANISOTROPY:
        if(this->rstates[D3DRENDERSTATE_ANISOTROPY] != dwValue) {
            SetDeviceRenderState(this, D3DRENDERSTATE_ANISOTROPY, dwValue);
            return SetRenderStateI(D3DRENDERSTATE_ANISOTROPY, dwValue);
        }
        else {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        break;
    }

    // Set a bit requesting mapping to DX5 renderstates
    this->dwFEFlags |= D3DFE_MAP_TSS_TO_RS;

    return D3D_OK; // return Ok for the time being?
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::MapTSSToRS"

HRESULT CDirect3DDeviceIHW::MapTSSToRS()
{
    DWORD mag = this->tsstates[0][D3DTSS_MAGFILTER];
    DWORD min = this->tsstates[0][D3DTSS_MINFILTER];
    DWORD mip = this->tsstates[0][D3DTSS_MIPFILTER];

    if(mip == D3DTFP_NONE) {
        if(min != D3DTFN_POINT && min != D3DTFN_LINEAR) {
            min = D3DTFN_LINEAR;
            D3D_WARN(2,"Unable to map D3DTSS_MINFILTER mode to driver. Rendering maybe incorrect");
        }
        if(this->rstates[D3DRENDERSTATE_TEXTUREMIN] != min) {
            (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMIN, min);
            (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMIN, min);
        }
        else {
            D3D_WARN(4,"Ignoring redundant renderstate");
        }
    }
    else if(mip == D3DTFP_POINT) {
        if(min == D3DTFN_POINT) {
            if(this->rstates[D3DRENDERSTATE_TEXTUREMIN] != D3DFILTER_MIPNEAREST) {
                (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPNEAREST);
                (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPNEAREST);
            }
            else {
                D3D_WARN(4,"Ignoring redundant renderstate");
            }
        }
        else if(min == D3DTFN_LINEAR) {
            if(this->rstates[D3DRENDERSTATE_TEXTUREMIN] != D3DFILTER_MIPLINEAR) {
                (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPLINEAR);
                (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPLINEAR);
            }
            else {
                D3D_WARN(4,"Ignoring redundant renderstate");
            }
        }
        else {
            if(this->rstates[D3DRENDERSTATE_TEXTUREMIN] != D3DFILTER_MIPLINEAR) {
                (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPLINEAR);
                (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPLINEAR);
            }
            else {
                D3D_WARN(4,"Ignoring redundant renderstate");
            }
            D3D_WARN(2,"Unable to map D3DTSS_MINFILTER mode to driver. Rendering maybe incorrect");
        }
    }
    else { // mip == D3DTFP_LINEAR
        if(min == D3DTFN_POINT) {
            if(this->rstates[D3DRENDERSTATE_TEXTUREMIN] != D3DFILTER_LINEARMIPNEAREST) {
                (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPNEAREST);
                (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPNEAREST);
            }
            else {
                D3D_WARN(4,"Ignoring redundant renderstate");
            }
        }
        else if(min == D3DTFN_LINEAR) {
            if(this->rstates[D3DRENDERSTATE_TEXTUREMIN] != D3DFILTER_LINEARMIPLINEAR) {
                (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPLINEAR);
                (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPLINEAR);
            }
            else {
                D3D_WARN(4,"Ignoring redundant renderstate");
            }
        }
        else {
            if(this->rstates[D3DRENDERSTATE_TEXTUREMIN] != D3DFILTER_LINEARMIPLINEAR) {
                (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPLINEAR);
                (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPLINEAR);
            }
            else {
                D3D_WARN(4,"Ignoring redundant renderstate");
            }
            D3D_WARN(2,"Unable to map D3DTSS_MINFILTER mode to driver. Rendering maybe incorrect");
        }
    }
    if(mag != D3DTFG_POINT && mag != D3DTFG_LINEAR) {
        mag = D3DTFG_LINEAR;
        D3D_WARN(2,"Unable to map D3DTSS_MAGFILTER mode to driver. Rendering maybe incorrect");
    }
    if(this->rstates[D3DRENDERSTATE_TEXTUREMAG] != mag) {
        (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMAG, mag);
        (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMAG, mag);
    }
    else {
        D3D_WARN(4,"Ignoring redundant renderstate");
    }

    DWORD cop = this->tsstates[0][D3DTSS_COLOROP];
    DWORD ca1 = this->tsstates[0][D3DTSS_COLORARG1];
    DWORD ca2 = this->tsstates[0][D3DTSS_COLORARG2];
    DWORD aop = this->tsstates[0][D3DTSS_ALPHAOP];
    DWORD aa1 = this->tsstates[0][D3DTSS_ALPHAARG1];
    DWORD aa2 = this->tsstates[0][D3DTSS_ALPHAARG2];

    // Current is the same as diffuse in stage 0
    if(ca2 == D3DTA_CURRENT)
        ca2 = D3DTA_DIFFUSE;
    if(aa2 == D3DTA_CURRENT)
        aa2 = D3DTA_DIFFUSE;

    // Check if we need to disable texturing
    if(cop == D3DTOP_DISABLE ||
        (cop == D3DTOP_SELECTARG2 && ca2 == D3DTA_DIFFUSE && ((aop == D3DTOP_SELECTARG2 && aa2 == D3DTA_DIFFUSE) || aop == D3DTOP_DISABLE))
        ) {
        if(this->rstates[D3DRENDERSTATE_TEXTUREHANDLE] != 0) {
            (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREHANDLE, 0);
            (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREHANDLE, 0);
        }
        else {
            D3D_WARN(4,"Ignoring redundant renderstate");
        }
        this->dwFEFlags |= D3DFE_DISABLE_TEXTURES;
    }
    else if ((LPD3DI_TEXTUREBLOCK)TRUE != lpD3DMappedBlock[0])
    {
        LPD3DI_TEXTUREBLOCK lpBlock = this->lpD3DMappedBlock[0];
        if (lpBlock) {
            if(this->rstates[D3DRENDERSTATE_TEXTUREHANDLE] != lpBlock->hTex) {
                (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREHANDLE, lpBlock->hTex);
                (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREHANDLE, lpBlock->hTex);
            }
            else {
                D3D_WARN(4,"Ignoring redundant renderstate");
            }
        }
        this->dwFEFlags &= ~D3DFE_DISABLE_TEXTURES;
    }
    else
        this->dwFEFlags &= ~D3DFE_DISABLE_TEXTURES;

    // Check if we need to decal
    if((ca1 == D3DTA_TEXTURE && cop == D3DTOP_SELECTARG1) &&
        (aa1 == D3DTA_TEXTURE && aop == D3DTOP_SELECTARG1)) {
        if(this->rstates[D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_DECAL) {
            (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECAL);
            (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECAL);
        }
        else {
            D3D_WARN(4,"Ignoring redundant renderstate");
        }
    }
    // Check if we need to modulate
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_MODULATE &&
        ((aa1 == D3DTA_TEXTURE && aop == D3DTOP_SELECTARG1) || (aa2 == D3DTA_DIFFUSE && aop == D3DTOP_SELECTARG2))) {
        if(this->rstates[D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_MODULATE) {
            (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATE);
            (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATE);
        }
        else {
            D3D_WARN(4,"Ignoring redundant renderstate");
        }
    }
    // Check if we need to decal alpha
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_BLENDTEXTUREALPHA &&
        (aa2 == D3DTA_DIFFUSE && aop == D3DTOP_SELECTARG2)) {
        if(this->rstates[D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_DECALALPHA) {
            (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECALALPHA);
            (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECALALPHA);
        }
        else {
            D3D_WARN(4,"Ignoring redundant renderstate");
        }
    }
    // Check if we need to modulate alpha
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_MODULATE &&
        (aa2 == D3DTA_DIFFUSE && aa1 == D3DTA_TEXTURE) && aop == D3DTOP_MODULATE) {
        if(this->rstates[D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_MODULATEALPHA) {
            (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATEALPHA);
            (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATEALPHA);
        }
        else {
            D3D_WARN(4,"Ignoring redundant renderstate");
        }
    }
    // Check if we need to add
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_ADD &&
        (aa2 == D3DTA_DIFFUSE && aop == D3DTOP_SELECTARG2)) {
        if(this->rstates[D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_ADD) {
            (void) SetDeviceRenderState(this, D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_ADD);
            (void) this->SetRenderStateI(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_ADD);
        }
        else {
            D3D_WARN(4,"Ignoring redundant renderstate");
        }
    }
    else {
        if(!(this->dwFEFlags & D3DFE_DISABLE_TEXTURES))
        {
            D3D_WARN(2,"Mapping textureblend stage states to renderstates failed. Rendering maybe incorrect.");
        }
    }

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::ValidateDevice"

HRESULT D3DAPI
CDirect3DDeviceIHW::ValidateDevice(LPDWORD lpdwNumPasses)
{
    // Holds D3D lock until exit.
    CLockD3DMT ldmLock(this, DPF_MODNAME, REMIND(""));
    HRESULT ret;
    D3DHAL_VALIDATETEXTURESTAGESTATEDATA vbod;

    TRY
    {
        if (!VALID_DIRECT3DDEVICE3_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR(lpdwNumPasses, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid lpdwNumPasses pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    {
        DWORD mag = this->tsstates[0][D3DTSS_MAGFILTER];
        DWORD min = this->tsstates[0][D3DTSS_MINFILTER];
        DWORD mip = this->tsstates[0][D3DTSS_MIPFILTER];
        DWORD texcap;
        if (this->dwFEFlags &  D3DFE_REALHAL)
        {
            texcap = this->d3dHWDevDesc.dpcTriCaps.dwTextureFilterCaps;
        }
        else
        {
            texcap = this->d3dHELDevDesc.dpcTriCaps.dwTextureFilterCaps;
        }

        ret = D3DERR_UNSUPPORTEDTEXTUREFILTER;
        if(mip == D3DTFP_NONE) {
            if(min == D3DTFG_POINT) {
                if(!(texcap & D3DPTFILTERCAPS_NEAREST))
                    goto err;
            }
            else if(min == D3DTFG_LINEAR) {
                if(!(texcap & D3DPTFILTERCAPS_LINEAR))
                    goto err;
            }
            else
            {
                goto err;
            }
        }
        else if(mip == D3DTFP_POINT) {
            if(min == D3DTFG_POINT) {
                if(!(texcap & D3DPTFILTERCAPS_MIPNEAREST))
                    goto err;
            }
            else if(min == D3DTFG_LINEAR) {
                if(!(texcap & D3DPTFILTERCAPS_MIPLINEAR))
                    goto err;
            }
            else
            {
                ret = D3DERR_CONFLICTINGTEXTUREFILTER;
                goto err;
            }
        }
        else if(mip == D3DTFP_LINEAR) {
            if(min == D3DTFG_POINT) {
                if(!(texcap & D3DPTFILTERCAPS_LINEARMIPNEAREST))
                    goto err;
            }
            else if(min == D3DTFG_LINEAR) {
                if(!(texcap & D3DPTFILTERCAPS_LINEARMIPLINEAR))
                    goto err;
            }
            else
            {
                ret = D3DERR_CONFLICTINGTEXTUREFILTER;
                goto err;
            }
        }
        if(mag == D3DTFG_POINT) {
            if(!(texcap & D3DPTFILTERCAPS_NEAREST))
                goto err;
        }
        else if(mag == D3DTFG_LINEAR) {
            if(!(texcap & D3DPTFILTERCAPS_LINEAR))
                goto err;
        }
        else
        {
            goto err;
        }
    }

    {
        DWORD cop = this->tsstates[0][D3DTSS_COLOROP];
        DWORD ca1 = this->tsstates[0][D3DTSS_COLORARG1];
        DWORD ca2 = this->tsstates[0][D3DTSS_COLORARG2];
        DWORD aop = this->tsstates[0][D3DTSS_ALPHAOP];
        DWORD aa1 = this->tsstates[0][D3DTSS_ALPHAARG1];
        DWORD aa2 = this->tsstates[0][D3DTSS_ALPHAARG2];
        DWORD texcap;
        if (this->dwFEFlags &  D3DFE_REALHAL)
        {
            texcap = this->d3dHWDevDesc.dpcTriCaps.dwTextureBlendCaps;
        }
        else
        {
            texcap = this->d3dHELDevDesc.dpcTriCaps.dwTextureBlendCaps;
        }

        // Current is the same as diffuse in stage 0
        if(ca2 == D3DTA_CURRENT)
            ca2 = D3DTA_DIFFUSE;
        if(aa2 == D3DTA_CURRENT)
            aa2 = D3DTA_DIFFUSE;

        switch (cop)
        {
        // Check decal
        case D3DTOP_SELECTARG1:
            if(!(texcap & D3DPTBLENDCAPS_DECAL))
            {
                ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                goto err;
            }
            if (ca1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aa1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDALPHAARG;
                goto err;
            }
            if (aop != D3DTOP_SELECTARG1)
            {
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        case D3DTOP_MODULATE:
            switch (aop)
            {
            // Check modulate
            case D3DTOP_SELECTARG1:
                if(!(texcap & D3DPTBLENDCAPS_MODULATE))
                {
                    ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                    goto err;
                }
                if (ca1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (ca2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (aa1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                break;
            // Check modulate (second case)
            case D3DTOP_SELECTARG2:
                if(!(texcap & D3DPTBLENDCAPS_MODULATE))
                {
                    ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                    goto err;
                }
                if (ca1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (ca2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (aa2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                break;
            // Check modulate alpha
            case D3DTOP_MODULATE:
                if(!(texcap & D3DPTBLENDCAPS_MODULATEALPHA))
                {
                    ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                    goto err;
                }
                if (ca1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (ca2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (aa1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                if (aa2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                break;
            default:
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        // Check decal alpha
        case D3DTOP_BLENDTEXTUREALPHA:
            if(!(texcap & D3DPTBLENDCAPS_DECALALPHA))
            {
                ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                goto err;
            }
            if (ca1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (ca2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aa2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDALPHAARG;
                goto err;
            }
            if (aop != D3DTOP_SELECTARG2)
            {
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        case D3DTOP_ADD:
            if(!(texcap & D3DPTBLENDCAPS_ADD))
            {
                ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                goto err;
            }
            if (ca1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (ca2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aa2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDALPHAARG;
                goto err;
            }
            if (aop != D3DTOP_SELECTARG2)
            {
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        // Check disable
        case D3DTOP_SELECTARG2:
            if (ca2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aop != D3DTOP_DISABLE)
            {
                if (aop != D3DTOP_SELECTARG2)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                    goto err;
                }
                if (aa2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
            }
            break;
        // Check disable
        case D3DTOP_DISABLE:
            break;
        default:
            ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
            goto err;
        }
    }

    *lpdwNumPasses = 1;
    return D3D_OK;

err:
    D3D_INFO(1,"Failed to validate texture stage state.");
    *lpdwNumPasses = 0;
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\haldrv.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997, 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       haldrv.cpp
 *  Content:    Direct3D HAL Driver
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "commdrv.hpp"
#include "genpick.hpp"
#include "d3dfei.h"
#include "span.h"

#ifndef WIN95
#include <ntgdistr.h>
#endif

void Destroy(LPDIRECT3DDEVICEI lpDevI);
//---------------------------------------------------------------------
int
GenGetExtraVerticesNumber( LPDIRECT3DDEVICEI lpDevI )
{
    LPD3DHAL_GLOBALDRIVERDATA lpGlob = lpDevI->lpD3DHALGlobalDriverData;

    return (int)(lpGlob->dwNumVertices ?
        lpGlob->dwNumVertices : D3DHAL_DEFAULT_TL_NUM);

}
//---------------------------------------------------------------------
HRESULT CalcDDSurfInfo(LPDIRECT3DDEVICEI lpDevI, BOOL bUpdateZBufferFields)
{
    DDSURFACEDESC ddsd;
    HRESULT ddrval;
    DWORD dwWidth, dwHeight;
    unsigned long m;
    int s;

    // Get info from the surface

    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    ddrval = lpDevI->lpDDSTarget->GetSurfaceDesc(&ddsd);
    if (ddrval != DD_OK) {
        return ddrval;
    }

    dwWidth = ddsd.dwWidth;
    dwHeight = ddsd.dwHeight;
    if ((ddsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8)) == 0) {
        // palettized pixfmts will not have valid RGB Bitmasks, so avoid computing this for them

        lpDevI->red_mask = ddsd.ddpfPixelFormat.dwRBitMask;
        lpDevI->green_mask = ddsd.ddpfPixelFormat.dwGBitMask;
        lpDevI->blue_mask = ddsd.ddpfPixelFormat.dwBBitMask;

        if ((lpDevI->red_mask == 0x0)  ||
            (lpDevI->green_mask == 0x0) ||
            (lpDevI->blue_mask == 0x0))
        {
            D3D_ERR("All the color masks in the Render target's pixel-format must be non-zero");
            return DDERR_INVALIDPIXELFORMAT;
        }

        // these are used by Clear
        for (s = 0, m = lpDevI->red_mask; !(m & 1); s++, m >>= 1) ;
        lpDevI->red_shift = s;
        lpDevI->red_scale = 255 / (lpDevI->red_mask >> s);
        for (s = 0, m = lpDevI->green_mask; !(m & 1); s++, m >>= 1) ;
        lpDevI->green_shift = s;
        lpDevI->green_scale = 255 / (lpDevI->green_mask >> s);
        for (s = 0, m = lpDevI->blue_mask; !(m & 1); s++, m >>= 1) ;
        lpDevI->blue_shift = s;
        lpDevI->blue_scale = 255 / (lpDevI->blue_mask >> s);

        DDASSERT(lpDevI->red_scale!=0);
        DDASSERT(lpDevI->green_scale!=0);
        DDASSERT(lpDevI->blue_scale!=0);
        lpDevI->bDDSTargetIsPalettized=FALSE;
    } else
        lpDevI->bDDSTargetIsPalettized=TRUE;

    if (lpDevI->lpDDSZBuffer_DDS4 && bUpdateZBufferFields) {
        // Get info from the surface

        DDSURFACEDESC2 ddsd2;

        memset(&ddsd2, 0, sizeof(ddsd2));
        ddsd2.dwSize = sizeof(ddsd2);
        ddrval = lpDevI->lpDDSZBuffer_DDS4->GetSurfaceDesc(&ddsd2);
        if (ddrval != DD_OK) {
            return ddrval;
        }

        if( ddsd2.ddpfPixelFormat.dwZBitMask!=0x0) {
            for (s = 0, m = ddsd2.ddpfPixelFormat.dwZBitMask; !(m & 0x1); s++, m >>= 1) ;
            lpDevI->zmask_shift=s;
        } else {
            lpDevI->zmask_shift=0;     // if ZBitMask isn't being set, then Clear2 will never be used,
                                      // so zbuf_shift/stencil_shift wont be needed anyway
        }

        if( ddsd2.ddpfPixelFormat.dwStencilBitMask!=0x0) {
            for (s = 0, m = ddsd2.ddpfPixelFormat.dwStencilBitMask; !(m & 0x1); s++, m >>= 1) ;
            lpDevI->stencilmask_shift=s;
        } else {
            lpDevI->stencilmask_shift=0;
        }
    }

    return D3D_OK;
}

// called by DDRAW
extern "C" HRESULT __stdcall Direct3D_HALCleanUp(LPD3DHAL_CALLBACKS lpD3DHALCallbacks, DWORD dwPID)
{
    D3DHAL_CONTEXTDESTROYALLDATA data;
    HRESULT ret;

    DDASSERT(lpD3DHALCallbacks!=NULL);
    if (lpD3DHALCallbacks->ContextDestroyAll==NULL) {
        // no cleanup necessary (running on d3d hel)
    return D3D_OK;
    }

    memset(&data, 0, sizeof(D3DHAL_CONTEXTDESTROYALLDATA));
    data.dwPID = dwPID;

    // I'd prefer to use CALL_HALONLY() to do the locking (to avoid doing it for the SW rasterizers),
    // but that requires a pDevI which I can't get to from the caller, which is a ddraw cleanup routine

#ifdef WIN95
    _EnterSysLevel(lpWin16Lock);
#endif

    ret = (*lpD3DHALCallbacks->ContextDestroyAll)(&data);

#ifdef WIN95
    _LeaveSysLevel(lpWin16Lock);
#endif

    return ret;
}


// ATTENTION - These two functions should be combined into one as soon
// as ContextCreate has the new private data mechanism built in.
#ifdef WIN95
HRESULT halCreateContext(LPDIRECT3DDEVICEI lpDevI)
{
    D3DHAL_CONTEXTCREATEDATA data;
    HRESULT ret;

    D3D_INFO(6, "in halCreateContext. Creating Context for driver = %08lx", lpDevI);

    LIST_INITIALIZE(&lpDevI->bufferHandles);

    memset(&data, 0, sizeof(D3DHAL_CONTEXTCREATEDATA));
    //
    // From DX7 onwards, drivers should be accepting
    // Surface Locals instead of the Surface interfaces
    // this future-proofs the drivers
    //
    if (IS_DX7HAL_DEVICE(lpDevI))
    {
        if (lpDevI->lpDD)
            data.lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)(lpDevI->lpDD))->lpLcl;
        else
            data.lpDDLcl = NULL;

        if (lpDevI->lpDDSTarget)
            data.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl;
        else
            data.lpDDSLcl = NULL;

        if (lpDevI->lpDDSZBuffer)
            data.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSZBuffer)->lpLcl;
        else
            data.lpDDSZLcl = NULL;

    }
    else
    {
        data.lpDDGbl = lpDevI->lpDDGbl;
        data.lpDDS = lpDevI->lpDDSTarget;
        data.lpDDSZ = lpDevI->lpDDSZBuffer;
    }
    data.dwPID = GetCurrentProcessId();

    if (lpDevI->d3dHWDevDesc.dwFlags == 0)
    {
        // The new software rasterizers want to share IM's state vector so
        // we need to pass them the rstates pointer.  They don't
        // care about dwPID so stick the pointer in there.
        data.dwPID = (DWORD)lpDevI->rstates;
    }

    /* 0 for pre-DX5 devices.
     * 1 for DX5 devices.
     * 2 for DX6 devices.
     */
    data.dwhContext = lpDevI->dwVersion - 1;

    CALL_HALONLY(ret, lpDevI, ContextCreate, &data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
D3D_ERR("HAL context create failed");
        return (DDERR_GENERIC);
    }
    lpDevI->dwhContext = data.dwhContext;

    if (D3DMalloc ((void**)&lpDevI->lpwDPBufferAlloced,
                   max(dwD3DTriBatchSize*4*sizeof(WORD),
                       dwHWBufferSize) +32) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate" );
        return (DDERR_OUTOFMEMORY);
    }
    lpDevI->lpwDPBuffer =
        (LPWORD) (((DWORD) lpDevI->lpwDPBufferAlloced+31) & (~31));
    lpDevI->lpDPPrimCounts =
        (LPD3DHAL_DRAWPRIMCOUNTS) lpDevI->lpwDPBuffer;
    memset( (char *)lpDevI->lpwDPBuffer, 0,
            sizeof(D3DHAL_DRAWPRIMCOUNTS));     //Clear header also
    lpDevI->dwDPOffset = sizeof(D3DHAL_DRAWPRIMCOUNTS);
    lpDevI->dwDPMaxOffset = dwD3DTriBatchSize * sizeof(D3DTRIANGLE)-sizeof(D3DTLVERTEX);

    // save the surface handle for later checks
    lpDevI->hSurfaceTarget = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->lpSurfMore->dwSurfaceHandle;

    D3D_INFO(6, "in halCreateContext. Succeeded. dwhContext = %d", data.dwhContext);

    return (D3D_OK);
}
#else
    /*
     * On NT the kernel code creates the buffer to be used
     * for DrawPrim batching and returns it as extra data
     * in the ContextCreate request.
     */
HRESULT halCreateContext(LPDIRECT3DDEVICEI lpDevI)
{
    D3DNTHAL_CONTEXTCREATEI ntData;
    D3DHAL_CONTEXTCREATEDATA *lpData =
        (D3DHAL_CONTEXTCREATEDATA *)&ntData;
    HRESULT ret;

    D3D_INFO(6, "in halCreateContext. Creating Context for driver = %08lx", lpDevI);

    LIST_INITIALIZE(&lpDevI->bufferHandles);

    /*
     * AnanKan: Assert here that the D3DNTHAL_CONTEXTCREATEI structure is
     * 2 DWORDS bigger than D3DHAL_CONTEXTCREATEDATA. This will be a good
     * consistency check for NT kernel updates.
     */
    memset(&ntData, 0, sizeof(ntData));
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)
    {
        if (lpDevI->lpDD)
            lpData->lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)(lpDevI->lpDD))->lpLcl;
        else
            lpData->lpDDLcl = NULL;

        if (lpDevI->lpDDSTarget)
            lpData->lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl;
        else
            lpData->lpDDSLcl = NULL;

        if (lpDevI->lpDDSZBuffer)
            lpData->lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSZBuffer)->lpLcl;
        else
            lpData->lpDDSZLcl = NULL;
    }
    else
    {
        lpData->lpDDGbl = lpDevI->lpDDGbl;
        lpData->lpDDS = lpDevI->lpDDSTarget;
        lpData->lpDDSZ = lpDevI->lpDDSZBuffer;
    }
    lpData->dwPID = GetCurrentProcessId();

    if (lpDevI->d3dHWDevDesc.dwFlags == 0)
    {
        // The new software rasterizers want to share IM's state vector so
        // we need to pass them the rstates pointer.  They don't
        // care about dwPID so stick the pointer in there.
        // Sundown: was lpData->dwPID, but added a union in d3dhal.h
        lpData->dwrstates = (ULONG_PTR)lpDevI->rstates;
    }

    /* 0 for pre-DX5 devices.
     * 1 for DX5 devices.
     * 2 for DX6 devices.
     */
    lpData->dwhContext = lpDevI->dwVersion - 1;
    ntData.cjBuffer = lpDevI->dwDPBufferSize;
    ntData.pvBuffer = NULL;

    CALL_HALONLY(ret, lpDevI, ContextCreate, lpData);
    if (ret != DDHAL_DRIVER_HANDLED || lpData->ddrval != DD_OK) {

D3D_ERR("HAL context create failed");
        return (DDERR_GENERIC);
    }
    lpDevI->dwhContext = lpData->dwhContext;

    // If the lpDevI chose not to allocate a DrawPrim buffer do
    // it for them.
    if (ntData.pvBuffer == NULL)
    {
        lpDevI->dwDPBufferSize =
            dwD3DTriBatchSize * 4 * sizeof(WORD);
        if (lpDevI->dwDPBufferSize < dwHWBufferSize)
        {
            lpDevI->dwDPBufferSize = dwHWBufferSize;
        }

        ret = D3DMalloc((void**)&lpDevI->lpwDPBufferAlloced,
                        lpDevI->dwDPBufferSize + 32);
        if (ret != DD_OK)
        {
D3D_ERR("halCreateContext D3DMalloc");
            return ret;
        }

        ntData.pvBuffer = (LPVOID)
            (((ULONG_PTR)lpDevI->lpwDPBufferAlloced + 31) & ~31);
        ntData.cjBuffer = lpDevI->dwDPBufferSize + 32 -
             (DWORD)((ULONG_PTR)ntData.pvBuffer -
                     (ULONG_PTR)lpDevI->lpwDPBufferAlloced);
    }
    else if( (lpDevI->dwDPBufferSize &&
              ntData.cjBuffer < lpDevI->dwDPBufferSize) ||
             ntData.cjBuffer < sizeof(D3DHAL_DRAWPRIMCOUNTS) )
    {
D3D_ERR("halCreateContext buffer stuff");
        return (DDERR_GENERIC);
    }

    // Need to save the buffer space provided and its size
    lpDevI->lpwDPBuffer = (LPWORD)ntData.pvBuffer;
    lpDevI->lpDPPrimCounts =
        (LPD3DHAL_DRAWPRIMCOUNTS)ntData.pvBuffer;

    //Clear header also
    memset( (char *)ntData.pvBuffer, 0, sizeof(D3DHAL_DRAWPRIMCOUNTS));

    lpDevI->dwDPOffset = sizeof(D3DHAL_DRAWPRIMCOUNTS);
    lpDevI->dwDPMaxOffset = ntData.cjBuffer-sizeof(D3DTLVERTEX);

    // save the surface handle for later checks
    lpDevI->hSurfaceTarget = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface;

    D3D_INFO(6, "in halCreateContext. Succeeded. dwhContext = %d", lpData->dwhContext);

    return (D3D_OK);
}
#endif


void halDestroyContext(LPDIRECT3DDEVICEI lpDevI)
{
    D3DHAL_CONTEXTDESTROYDATA data;
    HRESULT ret;

    D3D_INFO(6, "in halCreateDestroy. Destroying Context for driver = %08lx", lpDevI);
    D3D_INFO(6, "                     dwhContext = %d", lpDevI->dwhContext);

    if(lpDevI->dwhContext!=NULL) {
        memset(&data, 0, sizeof(D3DHAL_CONTEXTDESTROYDATA));
        data.dwhContext = lpDevI->dwhContext;

        CALL_HALONLY(ret, lpDevI, ContextDestroy, &data);
        if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
            D3D_WARN(0,"Failed ContextDestroy HAL call in halDestroyContext");
            return;
        }
    }

    D3DHAL_DeallocateBuffers(lpDevI);
}
//---------------------------------------------------------------------
HRESULT D3DFE_Create(LPDIRECT3DDEVICEI lpDevI,
                     LPDIRECTDRAW lpDD,
                     LPDIRECTDRAWSURFACE lpDDS,
                     LPDIRECTDRAWSURFACE lpZ,
                     LPDIRECTDRAWPALETTE lpPal)
{
    DDSURFACEDESC ddsd;
    HRESULT hr;
    LPD3DHAL_GLOBALDRIVERDATA lpGlob;

    /*
     * Allocate and check validity of DirectDraw surfaces
     */

    lpDevI->lpDD = lpDD;
    lpDevI->lpDDGbl = ((LPDDRAWI_DIRECTDRAW_INT)lpDD)->lpLcl->lpGbl;
    lpDevI->lpDDSTarget = lpDDS;
    // For DX3 we do not keep references to Render target to avoid
    // circular references in the aggregation model. But for DX5 we
    // need to AddRef lpDDS. For DX6 we need to AddRef lpDDS4 which
    // is done later below
    if (lpDevI->dwVersion == 2) // DX5
        lpDDS->AddRef();

    // Get DDS4 Interfaces for RenderTarget/ZBuffer

    HRESULT ret = lpDDS->QueryInterface(IID_IDirectDrawSurface4, (LPVOID*)&lpDevI->lpDDSTarget_DDS4);

    if(FAILED(ret)) {
          D3D_ERR("QI for RenderTarget DDS4 Interface failed ");
          return ret;
    }
    // An implicit AddRef for lpDDSTarget_DDS4 in case of DX6
    if (lpDevI->dwVersion < 3) // DX3, DX5
        lpDevI->lpDDSTarget_DDS4->Release();

    if(lpZ!=NULL) {
        ret = lpZ->QueryInterface(IID_IDirectDrawSurface4, (LPVOID*)&lpDevI->lpDDSZBuffer_DDS4);

        if(FAILED(ret)) {
              D3D_ERR("QI for ZBuffer DDS4 Interface failed ");

              return ret;
        }
        lpDevI->lpDDSZBuffer_DDS4->Release();
    }

    LPD3DHAL_D3DEXTENDEDCAPS lpCaps = lpDevI->lpD3DExtendedCaps;
    if (NULL == lpCaps || 0.0f == lpCaps->dvExtentsAdjust)
    {
        lpDevI->dvExtentsAdjust = 1.0f;
    }
    else
    {
        lpDevI->dvExtentsAdjust = lpCaps->dvExtentsAdjust;
    }
    if (lpCaps != NULL)
        if (lpCaps->dvGuardBandLeft   != 0.0f ||
            lpCaps->dvGuardBandRight  != 0.0f ||
            lpCaps->dvGuardBandTop    != 0.0f ||
            lpCaps->dvGuardBandBottom != 0.0f)
        {
            lpDevI->dwDeviceFlags |= D3DDEV_GUARDBAND;
            DWORD v;
            if (GetD3DRegValue(REG_DWORD, "DisableGB", &v, 4) &&
                v != 0)
            {
                lpDevI->dwDeviceFlags &= ~D3DDEV_GUARDBAND;
            }
#if DBG
            // Try to get test values for the guard band
            char value[80];
            if (GetD3DRegValue(REG_SZ, "GuardBandLeft", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandLeft);
            if (GetD3DRegValue(REG_SZ, "GuardBandRight", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandRight);
            if (GetD3DRegValue(REG_SZ, "GuardBandTop", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandTop);
            if (GetD3DRegValue(REG_SZ, "GuardBandBottom", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandBottom);
#endif // DBG
        }

    if (lpDevI->dwVersion < 2)
        lpDevI->dwDeviceFlags |= D3DDEV_PREDX5DEVICE;

    if (lpDevI->dwVersion < 3)
        lpDevI->dwDeviceFlags |= D3DDEV_PREDX6DEVICE;

    if (!lpDevI->lpD3DHALCallbacks || ! lpDevI->lpD3DHALGlobalDriverData)
    {
D3D_ERR("CB NULL or GBD NULL %x %x",lpDevI->lpD3DHALGlobalDriverData,lpDevI->lpD3DHALCallbacks);
        return DDERR_INVALIDOBJECT;
    }

    // Helpful Note: for Device2 and Device3, lpDevI->guid is only guaranteed to be
    // the device type (HAL/RGB/etc) while init is happening.   At end of DX5/DX6 CreateDevice,
    // guid is reset to be IID_IDirect3DDevice2 or IID_IDirect3DDevice3, so don't try this sort
    // of device type determination outside of initialization.
    if (IsEqualIID((lpDevI->guid), IID_IDirect3DHALDevice))
    {
        lpDevI->dwFEFlags |=  D3DFE_REALHAL;

        // We do texture management (and hence clipped Blts) only for a real HAL.
        hr = lpDD->CreateClipper(0, &lpDevI->lpClipper, NULL);
        if(hr != DD_OK)
        {
            D3D_ERR("Failed to create a clipper");
            return hr;
        }
    }
    else
    {
        lpDevI->lpClipper = 0;
    }

    if (lpDevI->pfnRampService != NULL)
        lpDevI->dwDeviceFlags |=  D3DDEV_RAMP;

    lpGlob = lpDevI->lpD3DHALGlobalDriverData;

    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    if (lpZ)
    {
        if ((hr = lpZ->GetSurfaceDesc(&ddsd)) != DD_OK)
        {
            D3D_ERR("Failed to getsurfacedesc on z");
            return hr;
        }
        if (ddsd.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
            D3D_INFO(1, "Z buffer is in system memory.");
        }
        else if (ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
            D3D_INFO(1, "Z buffer is in video memory.");
        }
        else
        {
            D3D_ERR("Z buffer not in video or system?");
        }
    }
    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    if (lpDDS)
    {
        if ((hr = lpDDS->GetSurfaceDesc(&ddsd)) != DD_OK)
        {
            D3D_ERR("Failed to getsurfacedesc on back buffer");
            return hr;
        }
        if (ddsd.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
            D3D_INFO(1, "back buffer is in system memory.");
        }
        else if (ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
            D3D_INFO(1, "back buffer is in video memory.");
        }
        else
        {
            D3D_ERR("back buffer not in video or system?");
        }
        if (!(lpGlob->hwCaps.dwDeviceRenderBitDepth &
              BitDepthToDDBD(ddsd.ddpfPixelFormat.dwRGBBitCount)))
        {
            D3D_ERR("Rendering surface's RGB bit count not supported "
                    "by hardware device");
            return DDERR_INVALIDOBJECT;
        }
    }

    if (lpGlob->dwNumVertices &&
        (lpGlob->hwCaps.dwMaxVertexCount != lpGlob->dwNumVertices))
    {
        D3D_ERR("In global driver data, hwCaps.dwMaxVertexCount != "
                "dwNumVertices");
        lpGlob->hwCaps.dwMaxVertexCount = lpGlob->dwNumVertices;
    }
    if (lpGlob->dwNumVertices
        && lpGlob->dwNumClipVertices < D3DHAL_NUMCLIPVERTICES)
    {
        D3D_ERR("In global driver data, dwNumClipVertices "
                "< D3DHAL_NUMCLIPVERTICES");
        lpGlob->dwNumClipVertices = D3DHAL_NUMCLIPVERTICES;
    }

    if ((hr = CalcDDSurfInfo(lpDevI,TRUE)) != DD_OK)
    {
D3D_ERR("CalcDDSurfInfo failed");
        return hr;
    }

    RESET_HAL_CALLS(lpDevI);

    /*
     * Create our context in the HAL driver
     */
    if ((hr = halCreateContext(lpDevI)) != D3D_OK)
    {
D3D_ERR("halCreateContext failed");
        return hr;
    }

    STATESET_INIT(lpDevI->renderstate_overrides);

    if ((hr = D3DFE_InitTransform(lpDevI)) != D3D_OK)
    {
D3D_ERR("D3DFE_InitTransform failed");
        return hr;
    }
    if (hr = (D3DFE_InitRGBLighting(lpDevI)) != D3D_OK)
    {
D3D_ERR("D3DFE_InitRGBLighting failed");
        return hr;
    }

    lpDevI->dwFEFlags |= D3DFE_VALID;

    lpDevI->iClipStatus = D3DSTATUS_DEFAULT;
    lpDevI->rExtents.x1 = D3DVAL(2048);
    lpDevI->rExtents.x2 = D3DVAL(0);
    lpDevI->rExtents.y1 = D3DVAL(2048);
    lpDevI->rExtents.y2 = D3DVAL(0);

    return S_OK;
}

void D3DFE_Destroy(LPDIRECT3DDEVICEI lpDevI)
{
    if (lpDevI->dwFEFlags & D3DFE_VALID)
    {
        D3DFE_DestroyTransform(lpDevI);
        D3DFE_DestroyRGBLighting(lpDevI);
    }

    if(lpDevI->lpClipper)
    {
        lpDevI->lpClipper->Release();
    }

    if (lpDevI->lpD3DHALCallbacks) {
        halDestroyContext(lpDevI);
    }

#ifdef TRACK_HAL_CALLS
    D3D_INFO(0, "Made %d HAL calls", lpDevI->hal_calls);
#endif

    // If any picks were done the pick records need to be freed.
    // They are allocated in D3DHAL_AddPickRecord in halpick.c
    if (lpDevI->pick_data.records) {
        D3DFree(lpDevI->pick_data.records);
    }
}

void TriFillRectsTex(LPDIRECT3DDEVICEI lpDevI, DWORD count, LPD3DRECT rect,D3DTEXTUREHANDLE hTex)
{
    LPDIRECT3DDEVICE3 lpD3DDev = static_cast<LPDIRECT3DDEVICE3>(lpDevI);
    LPD3DVIEWPORT2 lpCurrentView = &((LPDIRECT3DVIEWPORTI)(lpDevI->lpCurrentViewport))->v_data;

    DWORD i;
    float width =   (float)lpCurrentView->dwWidth;
    float height =  (float)lpCurrentView->dwHeight;
    // ~.5 offset makes the result stable for even scales which are common.
    // since this offset is not scaled by texture size, need to make it a bit smaller
    float x =       (float)lpCurrentView->dwX - .41f;
    float y =       (float)lpCurrentView->dwY - .41f;

    DWORD dwZEnable;
    DWORD dwStencilEnable;
    DWORD dwZWriteEnable;
    DWORD dwZFunc;
    DWORD dwWrapU;
    DWORD dwWrapV;
    DWORD dwFillMode;
    DWORD dwFogEnable;
    DWORD dwFogMode;
    DWORD dwBlendEnable;
    DWORD dwColorKeyEnable;
    DWORD dwAlphaBlendEnable;
    DWORD dwTexture;
    DWORD dwTexturePers;
    DWORD dwDither;
    DWORD pdwWrap[D3DDP_MAXTEXCOORD];
    D3DTLVERTEX v[4];
    BOOL bWasInScene = FALSE;
    D3DMATERIALHANDLE hMat;

    if (!(lpDevI->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE))
    {
        lpDevI->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_INTERNAL_BEGIN_END;
        bWasInScene = TRUE;
        lpD3DDev->BeginScene();
    }

    // save current renderstate we need to reset to draw textured rect

    lpD3DDev->GetRenderState(D3DRENDERSTATE_ZENABLE, &dwZEnable);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_ZWRITEENABLE, &dwZWriteEnable);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_ZFUNC, &dwZFunc);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_WRAPU, &dwWrapU);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_WRAPV, &dwWrapV);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_FILLMODE, &dwFillMode);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_FOGENABLE, &dwFogEnable);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_FOGTABLEMODE, &dwFogMode);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_BLENDENABLE, &dwBlendEnable);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_COLORKEYENABLE, &dwColorKeyEnable);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, &dwAlphaBlendEnable);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_TEXTUREHANDLE, &dwTexture);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_STENCILENABLE, &dwStencilEnable);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, &dwTexturePers);
    lpD3DDev->GetRenderState(D3DRENDERSTATE_DITHERENABLE, &dwDither);

    // Save WRAPi
    for (i = 0; i < D3DDP_MAXTEXCOORD; i++)
    {
        lpD3DDev->GetRenderState((D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0 + i),
                                 pdwWrap + i);
    }

    lpD3DDev->SetRenderState(D3DRENDERSTATE_ZENABLE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_ZWRITEENABLE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_ZFUNC, D3DCMP_ALWAYS);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_WRAPU, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_WRAPV, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_FILLMODE, D3DFILL_SOLID);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_FOGTABLEMODE, D3DFOG_NONE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_FOGENABLE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_BLENDENABLE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_COLORKEYENABLE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_TEXTUREHANDLE, hTex);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_STENCILENABLE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, FALSE);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_DITHERENABLE, FALSE);

    // Disable WRAPi
    for (i = 0; i < D3DDP_MAXTEXCOORD; i++)
    {
        lpD3DDev->SetRenderState((D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0 + i),
                                 0);
    }

    BOOL bRampServiceClear = FALSE;

    if(lpDevI->pfnRampService!=NULL) {
        lpD3DDev->GetLightState(D3DLIGHTSTATE_MATERIAL, &hMat);
        lpD3DDev->SetLightState(D3DLIGHTSTATE_MATERIAL,
                            lpDevI->lpCurrentViewport->hBackgndMat);
        PD3DI_SPANTEX pTex = *(PD3DI_SPANTEX *)ULongToPtr(hTex);
        if (pTex->Format == D3DI_SPTFMT_PALETTE8)
        {
            // if it is Ramp, and if the texture is PALETTE8,
            // then we should use the new service that handles
            // non-power of 2 textures
            bRampServiceClear = TRUE;
        }
    }

    if (bRampServiceClear)
    {
        for (i = 0; i < count; i++, rect++) {
            CallRampService(lpDevI, RAMP_SERVICE_CLEAR_TEX_RECT,
                            lpDevI->lpCurrentViewport->hBackgndMat,rect);
        }
    }
    else
    {
        for (i = 0; i < count; i++, rect++) {
          D3DVALUE tu1, tv1, tu2, tv2;

            tu1 = ((D3DVALUE)(rect->x1 - x))/width;
            tv1 = ((D3DVALUE)(rect->y1 - y))/height;
            tu2 = ((D3DVALUE)(rect->x2 - x))/width;
            tv2 = ((D3DVALUE)(rect->y2 - y))/height;

            v[0].sx =   (D3DVALUE) rect->x1;
            v[0].sy =   (D3DVALUE) rect->y1;
            v[0].sz =   (D3DVALUE) 0;
            v[0].rhw =  (D3DVALUE) 1;
            v[0].color =    (D3DCOLOR) ~0UL;
            v[0].specular = (D3DCOLOR) 0;
            v[0].tu = tu1;
            v[0].tv = tv1;

            v[1].sx =   (D3DVALUE) rect->x2;
            v[1].sy =   (D3DVALUE) rect->y1;
            v[1].sz =   (D3DVALUE) 0;
            v[1].rhw =  (D3DVALUE) 1;
            v[1].color =    (D3DCOLOR) ~0UL;
            v[1].specular = (D3DCOLOR) 0;
            v[1].tu = tu2;
            v[1].tv = tv1;

            v[2].sx =   (D3DVALUE) rect->x2;
            v[2].sy =   (D3DVALUE) rect->y2;
            v[2].sz =   (D3DVALUE) 0;
            v[2].rhw =  (D3DVALUE) 1;
            v[2].color =    (D3DCOLOR) ~0UL;
            v[2].specular = (D3DCOLOR) 0;
            v[2].tu = tu2;
            v[2].tv = tv2;

            v[3].sx =   (D3DVALUE) rect->x1;
            v[3].sy =   (D3DVALUE) rect->y2;
            v[3].sz =   (D3DVALUE) 0;
            v[3].rhw =  (D3DVALUE) 1;
            v[3].color =    (D3DCOLOR) ~0UL;
            v[3].specular = (D3DCOLOR) 0;
            v[3].tu = tu1;
            v[3].tv = tv2;

            lpD3DDev->DrawPrimitive(D3DPT_TRIANGLEFAN,
                                    D3DFVF_TLVERTEX, v, 4,
                                    D3DDP_WAIT | D3DDP_DONOTCLIP);
        }
    }

    // restore saved renderstate
    lpD3DDev->SetRenderState(D3DRENDERSTATE_ZENABLE, dwZEnable);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_ZWRITEENABLE, dwZWriteEnable);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_ZFUNC, dwZFunc);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_WRAPU, dwWrapU);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_WRAPV, dwWrapV);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_FILLMODE, dwFillMode);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_FOGENABLE, dwFogEnable);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_FOGTABLEMODE, dwFogMode);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_BLENDENABLE, dwBlendEnable);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_COLORKEYENABLE, dwColorKeyEnable);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, dwAlphaBlendEnable);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_TEXTUREHANDLE, dwTexture);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_STENCILENABLE, dwStencilEnable);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_TEXTUREPERSPECTIVE, dwTexturePers);
    lpD3DDev->SetRenderState(D3DRENDERSTATE_DITHERENABLE, dwDither);

    // Restore WRAPi
    for (i = 0; i < D3DDP_MAXTEXCOORD; i++)
    {
        lpD3DDev->SetRenderState((D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0 + i),
                                 pdwWrap[i]);
    }
    if(lpDevI->pfnRampService!=NULL) {
        lpD3DDev->SetLightState(D3DLIGHTSTATE_MATERIAL, hMat);
    }

    if (bWasInScene)
    {
        lpD3DDev->EndScene();
        lpDevI->dwHintFlags &= ~D3DDEVBOOL_HINTFLAGS_INTERNAL_BEGIN_END;
    }
}


void BltFillRects(LPDIRECT3DDEVICEI lpDevI, DWORD count, LPD3DRECT rect, D3DCOLORVALUE *pFillColor)
{
    LPDIRECTDRAWSURFACE lpDDS = lpDevI->lpDDSTarget;
    HRESULT ddrval;
    DDBLTFX bltfx;
    RECT tr;
    DWORD i;
    DWORD r, g, b;

    // Fill with background color

    memset(&bltfx, 0, sizeof(bltfx));
    bltfx.dwSize = sizeof(bltfx);

// unlike clear callback, which just takes pure 32-bit ARGB word and forces the driver to scale it for
// the pixelformat, here we need to compute the exact fill word, depending on surface's R,G,B bitmasks

    if(lpDevI->pfnRampService!=NULL) {
      // DX5 allowed the background material to be NULL.  For this case, will clear to index 0
      // which is usually black in ramp mode

      if(lpDevI->lpCurrentViewport->hBackgndMat!=0) {
          CallRampService(lpDevI, RAMP_SERVICE_MATERIAL_TO_PIXEL,lpDevI->lpCurrentViewport->hBackgndMat,&bltfx.dwFillColor);
      } else {
          bltfx.dwFillColor=0;   // index 0 is usually black in ramp mode.
      }
    } else {

     if(lpDevI->bDDSTargetIsPalettized) {
         // map 24-bit color to 8-bit index used by 8bit RGB rasterizer
         CallRastService(lpDevI, RAST_SERVICE_RGB8COLORTOPIXEL, CVAL_TO_RGBA(*pFillColor), &bltfx.dwFillColor);
     } else {

        if((lpDevI->red_scale == 0) || (lpDevI->green_scale == 0) ||
           (lpDevI->blue_scale == 0))
        {
            DPF(1, "(ERROR) BltFillRects Failed one of the scales is zero" );
            return;
        }

        r = (DWORD)(255.0 * pFillColor->r) / lpDevI->red_scale;
        g = (DWORD)(255.0 * pFillColor->g) / lpDevI->green_scale;
        b = (DWORD)(255.0 * pFillColor->b) / lpDevI->blue_scale;
        bltfx.dwFillColor = (r << lpDevI->red_shift) | (g << lpDevI->green_shift) | (b << lpDevI->blue_shift);
     }
    }

    for (i = 0; i < count; i++,rect++) {
        tr.left = rect->x1;
        tr.right = rect->x2;
        tr.top = rect->y1;
        tr.bottom = rect->y2;
        do {
            ddrval = lpDDS->Blt(&tr, NULL, NULL, DDBLT_COLORFILL, &bltfx);
        } while (ddrval == DDERR_WASSTILLDRAWING);
    }
}

void BltFillZRects(LPDIRECT3DDEVICEI lpDevI, unsigned long Zpixel,
                    DWORD count, LPD3DRECT rect, DWORD dwWriteMask)
{
    HRESULT ddrval;
    DDBLTFX bltfx;
    DWORD i;
    RECT tr;
    DWORD dwExtraFlags=0;

#if DBG
    if (lpDevI->lpDDSZBuffer == NULL)  // should be checked prior to call
        return;
#endif

    memset(&bltfx, 0, sizeof(DDBLTFX));
    bltfx.dwSize = sizeof(DDBLTFX);
    bltfx.dwFillDepth = Zpixel;

    // hack to pass DepthBlt WriteMask through ddraw/ddhel to blitlib
    if(dwWriteMask!=0) {
        bltfx.dwZDestConstBitDepth=dwWriteMask;
        dwExtraFlags = DDBLT_DEPTHFILLWRITEMASK;
    }

    for(i=0;i<count;i++,rect++) {
        D3D_INFO(4, "Z Clearing x1 = %d, y1 = %d, x2 = %d, y2 = %d, WriteMask %X", rect->x1, rect->y1, rect->x2, rect->y2, bltfx.dwReserved);
        tr.left = rect->x1;
        tr.right = rect->x2;
        tr.top = rect->y1;
        tr.bottom = rect->y2;
        do {
            ddrval = lpDevI->lpDDSZBuffer->Blt(&tr, NULL, NULL, DDBLT_DEPTHFILL | dwExtraFlags, &bltfx);
        } while (ddrval == DDERR_WASSTILLDRAWING);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DFE_Clear"

HRESULT D3DFE_Clear(LPDIRECT3DDEVICEI lpDevI, DWORD dwFlags,
                     DWORD numRect, LPD3DRECT lpRect,
                     D3DCOLORVALUE *pFillColor,
                     D3DTEXTUREHANDLE dwTexture)
{
    HRESULT ret;
    BOOL bDoRGBClear,bDoZClear,bDoHALRGBClear,bDoHALZClear;
    D3DHAL_CLEARDATA ClearData;
    LPDIRECTDRAWSURFACE lpDDSBackDepth;

    // Flush any outstanding geometry to put framebuffer/Zbuffer in a known state for Clears that
    // don't use tris (i.e. HAL Clears and Blts).  Note this doesn't work for tiled architectures
    // outside of Begin/EndScene, this will be fixed later

    ret = lpDevI->FlushStates();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to render batched commands in D3DFE_Clear");
        return ret;
    }

    ClearData.ddrval=D3D_OK;

    bDoRGBClear=((dwFlags & D3DCLEAR_TARGET)!=0);  // must convert to pure bool so bDoHALRGBClear==bDoRGBClear works
    bDoZClear=((dwFlags & D3DCLEAR_ZBUFFER)!=0);

    lpDDSBackDepth=((LPDIRECT3DVIEWPORTI)(lpDevI->lpCurrentViewport))->lpDDSBackgndDepth;

   // note: textured clears and clears to background depth buffer must be handled explicitly
   // using Blt calls and not be passed to driver

    bDoHALRGBClear = bDoRGBClear && (dwTexture==0)  && (lpDevI->lpD3DHALCallbacks2->Clear!=NULL);
    bDoHALZClear = bDoZClear && (lpDDSBackDepth==NULL) && (lpDevI->lpD3DHALCallbacks2->Clear!=NULL);

    if(bDoHALRGBClear || bDoHALZClear) {
            ClearData.dwhContext = lpDevI->dwhContext;
            ClearData.dwFillColor = ClearData.dwFillDepth = 0;
            ClearData.dwFlags = 0x0;

            if(bDoHALRGBClear) {
                // original Clear DDI Spec had dwFillColor being dependent on the surface RGB bit depths
                // like the COLORFILL Blt in SetRectangles.  But the dx5 implementation always passed a
                // 32-bit ARGB to the driver for all surface depths.  So that's the way it stays.
                ClearData.dwFillColor =  CVAL_TO_RGBA(*pFillColor);
                ClearData.dwFlags = D3DCLEAR_TARGET;
            }

            if(bDoHALZClear) {
                // must clear to 0xffffffff because legacy drivers expect this
                // should be using (1<<lpDevI->lpDDSZBuffer->ddpfSurface.dwZBufferBitDepth)-1;
                ClearData.dwFillDepth = 0xffffffff;
                ClearData.dwFlags |= D3DCLEAR_ZBUFFER;
            }

            ClearData.lpRects = lpRect;
            ClearData.dwNumRects = numRect;
#ifndef WIN95
            if((ret = CheckContextSurface(lpDevI)) != D3D_OK)
                return ret;
#endif
            CALL_HAL2ONLY(ret, lpDevI, Clear, &ClearData);
            if (ret != DDHAL_DRIVER_HANDLED)
                return DDERR_UNSUPPORTED;

            // if all requested clears were done by HAL, can return now
            if((bDoRGBClear==bDoHALRGBClear) && (bDoZClear==bDoHALZClear))
              return ClearData.ddrval;
    }

    if((lpDevI->lpD3DHALCallbacks3->Clear2!=NULL) && (lpDevI->lpD3DHALCallbacks2->Clear==NULL)) {
      DWORD dwFlagsLeft=dwFlags;
      DWORD dwClear2Flags=0x0;

      // driver implemented Clear2 callback but not Clear
      // call Clear2 for as many items as we can, and leave the rest for SW

      if(bDoRGBClear && (dwTexture==0)) {
          dwClear2Flags |= D3DCLEAR_TARGET;
          dwFlagsLeft &= ~D3DCLEAR_TARGET;
          bDoRGBClear=FALSE;
      }

      if(bDoZClear && (lpDDSBackDepth==NULL)) {
          dwClear2Flags |= D3DCLEAR_ZBUFFER;
          dwFlagsLeft &= ~D3DCLEAR_ZBUFFER;
          bDoZClear=FALSE;
      }

      if(dwClear2Flags!=0x0) {
         ClearData.ddrval = D3DFE_Clear2(lpDevI,dwClear2Flags,numRect,lpRect,CVAL_TO_RGBA(*pFillColor),1.0,0);
      }

      if(dwFlagsLeft==0x0)
         return ClearData.ddrval;

      dwFlags=dwFlagsLeft;
    }

    // otherwise do clears using SW, since no HW method exists or using textured background for RGBclear
    // or background depth buffer for Zclear

    // clear RGB using Blt
    if (bDoRGBClear && (!bDoHALRGBClear)) {
        if(dwTexture == 0)
            BltFillRects(lpDevI, numRect, lpRect, pFillColor);
         else TriFillRectsTex(lpDevI, numRect, lpRect, dwTexture);
    }

    // clear Z using Blt
    if (bDoZClear && (!bDoHALZClear)) {
        if (lpDDSBackDepth!=NULL) {
            RECT src, dest;
            DDSURFACEDESC ddsd;
            HRESULT ret;

            D3D_INFO(2, "Z Clearing using depth background");
            ddsd.dwSize = sizeof ddsd;
            ddsd.dwFlags = 0;
            if (ret = lpDDSBackDepth->GetSurfaceDesc(&ddsd)) {
                D3D_ERR("GetSurfaceDesc failed trying to clear to depth background");
                return ret;
            }
            D3D_INFO(3, "Depth background width=%d, height=%d", ddsd.dwWidth, ddsd.dwHeight);

            SetRect(&src, 0, 0, ddsd.dwWidth, ddsd.dwHeight);

            LPD3DVIEWPORT2 lpCurrentView = &((LPDIRECT3DVIEWPORTI)(lpDevI->lpCurrentViewport))->v_data;

            SetRect(&dest,
                    lpCurrentView->dwX,
                    lpCurrentView->dwY,
                    lpCurrentView->dwX + lpCurrentView->dwWidth,
                    lpCurrentView->dwY + lpCurrentView->dwHeight );

            // copy from background depth buffer to zbuffer
            if (ret = lpDevI->lpDDSZBuffer->Blt(
                &dest, lpDDSBackDepth, &src, DDBLT_WAIT, NULL)) {
                    D3D_ERR("Blt failed clearing depth background");
                    return ret;
            }
        } else {

            // Clear to maximum Z value.  Presence of stencil buffer ignored, depthfill blt
            // can overwrite any existing stencil bits with 1's.  Clear2 should be used to
            // clear z while preserving stencil buffer

            BltFillZRects(lpDevI, 0xffffffff, numRect, lpRect, 0x0);
        }
    }

    if(ClearData.ddrval!=D3D_OK)
      return ClearData.ddrval;
    else
    {
        return CallRampService(lpDevI, RAMP_SERVICE_CLEAR, 0, 0);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DFE_Clear2"

HRESULT D3DFE_Clear2(LPDIRECT3DDEVICEI lpDevI, DWORD dwFlags,
                     DWORD numRect, LPD3DRECT lpRect,
                     D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil) {
    DWORD dwDepthClearVal,dwStencilClearVal;
    HRESULT ret;
    BOOL bDoRGBClear,bDoZClear,bDoStencilClear;
    BOOL bIsStencilSurface = FALSE;
    D3DHAL_CLEAR2DATA Clear2Data;
    DDPIXELFORMAT *pZPixFmt;
    D3DCOLORVALUE vFillColor;

    DDASSERT(lpDevI->pfnRampService==NULL);  // Device3 ramp not allowed, so dont have to handle this case

    // Flush any outstanding geometry to put framebuffer/Zbuffer in a known state for Clears that
    // don't use tris (i.e. HAL Clears and Blts).  Note this doesn't work for tiled architectures
    // outside of Begin/EndScene, this will be fixed later

    ret = lpDevI->FlushStates();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to render batched commands in D3DFE_Clear2");
        return ret;
    }

    bDoRGBClear=((dwFlags & D3DCLEAR_TARGET)!=0);
    bDoZClear=((dwFlags & D3DCLEAR_ZBUFFER)!=0);              //make these true boolean so XOR below works
    bDoStencilClear=((dwFlags & D3DCLEAR_STENCIL)!=0);

    if (lpDevI->lpD3DHALCallbacks3->Clear2)
    {
        // Clear2 HAL Callback exists

         Clear2Data.dwhContext = lpDevI->dwhContext;
         Clear2Data.lpRects = lpRect;
         Clear2Data.dwNumRects = numRect;
         Clear2Data.dwFillColor = Clear2Data.dwFillStencil = 0;
         Clear2Data.dvFillDepth = 0.0f;
         Clear2Data.dwFlags = dwFlags;

         if(bDoRGBClear) {
             // Here I will follow the ClearData.dwFillColor convention that
             // color word is raw 32bit ARGB, unadjusted for surface bit depth
             Clear2Data.dwFillColor =  dwColor;
         }

         // depth/stencil values both passed straight from user args
         if(bDoZClear)
            Clear2Data.dvFillDepth = dvZ;
         if(bDoStencilClear)
            Clear2Data.dwFillStencil = dwStencil;

    #ifndef WIN95
         if((ret = CheckContextSurface(lpDevI)) != D3D_OK)
             return ret;
    #endif
         CALL_HAL3ONLY(ret, lpDevI, Clear2, &Clear2Data);
         if (ret != DDHAL_DRIVER_HANDLED)
             return DDERR_UNSUPPORTED;
         return Clear2Data.ddrval;
    }

    if(bDoRGBClear) {
      const float fScalor=(float)(1.0/255.0);

       vFillColor.a =  RGBA_GETALPHA(dwColor)*fScalor;
       vFillColor.r =  RGBA_GETRED(dwColor)*fScalor;
       vFillColor.g =  RGBA_GETGREEN(dwColor)*fScalor;
       vFillColor.b =  RGBA_GETBLUE(dwColor)*fScalor;
    }

    if((bDoZClear || bDoStencilClear) && (lpDevI->lpDDSZBuffer!=NULL)) {    //PowerVR need no Zbuffer
        pZPixFmt=&((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSZBuffer)->lpLcl->lpGbl->ddpfSurface;

        // if surface has stencil bits, must verify either Clear2 callback exists or
        // we're using SW rasterizers (which require the special WriteMask DDHEL blt)

        bIsStencilSurface=(pZPixFmt->dwFlags & DDPF_STENCILBUFFER);

    }

    if(bDoZClear || bDoStencilClear) {
        // if Clear2 callback doesnt exist and it's a z-only surface and not doing zclear to
        // non-max value then Clear2 is attempting to do no more than Clear could do, so it's
        // safe to call Clear() instead of Clear2(), which will take advantage of older
        // drivers that implement Clear but not Clear2

        if((!bIsStencilSurface) && (!(bDoZClear && (dvZ!=1.0)))) {
            return D3DFE_Clear(lpDevI,dwFlags,numRect,lpRect,&vFillColor,0);
        }

        if(bIsStencilSurface) {
            DDSCAPS *pDDSCaps;

            pDDSCaps=&((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSZBuffer)->lpLcl->ddsCaps;

            // This case should not be hit since we check right at the
            // driver initialization time if the driver doesnt report Clear2
            // yet it supports stencils
            if(!(pDDSCaps->dwCaps & DDSCAPS_SYSTEMMEMORY)) {
                D3D_ERR("Driver HAL doesn't provide Clear2 callback, cannot use Clear2 with HW stencil surfaces");
                return DDERR_INVALIDPIXELFORMAT;
            }
        }
    } else {
        // we're just clearing RGB, so since Clear2 callback doesn't exist, try calling Clear
        return D3DFE_Clear(lpDevI,dwFlags,numRect,lpRect,&vFillColor,0);
    }


    dwDepthClearVal=dwStencilClearVal=0;

    if(bDoZClear) {
         LPDDPIXELFORMAT pPixFmt=&((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSZBuffer)->lpLcl->lpGbl->ddpfSurface;

         DDASSERT(pPixFmt->dwZBufferBitDepth<=32);

         if((dvZ!=1.0)&&(lpDevI->lpD3DHALCallbacks3->Clear2==NULL)&&(pPixFmt->dwZBitMask==0x0)) {
             // I have no way to emulate ZClears to non-maxZ values without a ZBitMask, so must fail call
             D3D_ERR("cant ZClear to non-maxz value without Clear2 HAL callback or valid ZBuffer pixfmt ZBitMask");
             return DDERR_INVALIDPIXELFORMAT;
         }

         // special case the common cases
         if(dvZ==1.0) {
             dwDepthClearVal=pPixFmt->dwZBitMask;
         } else if(dvZ==0.0) {
             dwDepthClearVal=0;
         } else {
             dwDepthClearVal=((DWORD)((dvZ*(pPixFmt->dwZBitMask >> lpDevI->zmask_shift))+0.5)) << lpDevI->zmask_shift;
         }
    }

    if(bDoStencilClear) {
         LPDDPIXELFORMAT pPixFmt=&((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSZBuffer)->lpLcl->lpGbl->ddpfSurface;

         DDASSERT(pPixFmt->dwStencilBitDepth<32);
         DDASSERT(pPixFmt->dwStencilBitMask!=0x0);

         // special case the common case
         if(dwStencil==0) {
             dwStencilClearVal=0;
         } else {
             dwStencilClearVal=(dwStencil & ((1<<pPixFmt->dwStencilBitDepth)-1))
                                << lpDevI->stencilmask_shift;
         }
    }

    // Fall back to Emulation using Blt

    if(bDoRGBClear) {
        BltFillRects(lpDevI, numRect, lpRect, &vFillColor);     //ok to not return possible errors from Blt?
    }

    if(bDoZClear||bDoStencilClear) {
       if((bDoZClear!=bDoStencilClear) && bIsStencilSurface) {
          // have to worry about using writemask to screen out writing the stencil or z buffer

          if(bDoZClear) {
                // WriteMask enabled Z bits only
                DDASSERT(pZPixFmt->dwZBitMask!=0x0);
                BltFillZRects(lpDevI,dwDepthClearVal, numRect, lpRect, pZPixFmt->dwZBitMask);
          } else {
              DDASSERT(pZPixFmt->dwStencilBitMask!=0x0);
              BltFillZRects(lpDevI,dwStencilClearVal, numRect, lpRect, pZPixFmt->dwStencilBitMask);
          }
       } else {
            // do Stencil & Z Blt together, using regular DepthFill blt which will be faster
            // than the writemask blt because its write-only, instead of read-modify-write

            // Note we're passing non-0xffffffff values to DepthFill Blt here
            // not absolutely guaranteed to work on legacy drivers

            BltFillZRects(lpDevI,(dwDepthClearVal | dwStencilClearVal), numRect, lpRect, 0x0);
       }
    }

    return D3D_OK;
}
#undef DPF_MODNAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\halexe.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       halexe.c
 *  Content:    Direct3D HAL execute calles
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: halexe.c,v 1.1 1995/11/21 15:12:37 sjl Exp $
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   07/11/95   stevela Initial rev.
 *   12/11/95   stevela Lock surface before calling HAL's execute.
 *   29/08/96   stevela Just bit test instead of calling IsLost()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "commdrv.hpp"
#include "genpick.hpp"
#include "d3dfei.h"
#include "clipfunc.h"

//---------------------------------------------------------------------
#define CHECK(ddrval, str)      \
    if (ddrval != DD_OK)        \
    {                           \
    D3D_ERR(str);           \
    return (ddrval);        \
    }
//---------------------------------------------------------------------
__inline BOOL DDSurfaceLost(LPDIRECTDRAWSURFACE s)
{
    return ((LPDDRAWI_DDRAWSURFACE_INT)s)->lpLcl->dwFlags & DDRAWISURF_INVALID;
}

#ifdef USE_INTERNAL_LOCK
__inline HRESULT DDLockSurface(LPDIRECTDRAWSURFACE s)
{
    LPDDRAWI_DDRAWSURFACE_INT lpInt;
    lpInt = (LPDDRAWI_DDRAWSURFACE_INT)s;
    return DDInternalLock(lpInt->lpLcl);
}

__inline HRESULT DDUnockSurface(LPDIRECTDRAWSURFACE s)
{
    LPDDRAWI_DDRAWSURFACE_INT lpInt;
    lpInt = (LPDDRAWI_DDRAWSURFACE_INT)s;
    return DDInternalUnlock(lpInt->lpLcl);
}
#endif

__inline BOOL DDCheckSurfaceCaps(LPDIRECTDRAWSURFACE s, DWORD flag)
{
    LPDDRAWI_DDRAWSURFACE_INT lpInt = (LPDDRAWI_DDRAWSURFACE_INT)s;
    return lpInt->lpLcl->ddsCaps.dwCaps & flag;
}
//---------------------------------------------------------------------
#define CHECKLOST(lpDevI)                                              \
{                                                                      \
    if (DDSurfaceLost(lpDevI->lpDDSTarget) ||                          \
        (lpDevI->lpDDSZBuffer && DDSurfaceLost(lpDevI->lpDDSZBuffer))) \
    {                                                                  \
        D3D_WARN(0, "Render-target or ZBuffer surface lost");              \
        lpDevI->dwFEFlags |= D3DFE_LOSTSURFACES;                       \
        return DDERR_SURFACELOST;                                      \
    }                                                                  \
}

#define NEXTINSTRUCTION(ptr, type, num) \
    ptr = (LPD3DINSTRUCTION)((LPBYTE)ptr + sizeof(D3DINSTRUCTION) + \
    (num * sizeof(type)))

//---------------------------------------------------------------------
#ifdef DBG

int
validateTriangleFlags(LPD3DINSTRUCTION  ins,
                      LPD3DTRIANGLE     tri)
{
    int count = ins->wCount;
    int v1,v2,v3;
    int flat;
    int flat_count;
    unsigned flags;

    D3D_INFO(5, "Start %d triangle instruction", count);

    flat = 0;
    flat_count = 0;

    for (; count; count--)
    {
        flags = tri->wFlags;
        flags &= 0x1f;

        switch (flags)
        {
        case D3DTRIFLAG_START:
            v1 = tri->v1;
            v2 = tri->v2;
            v3 = tri->v3;
            D3D_INFO(9, "  triangle %d is START", ins->wCount - count);
            break;

        case D3DTRIFLAG_ODD:
            v1 = v3;
            v2 = v2;
            v3 = tri->v3;
            if ((v1 != tri->v1) || (v2 != tri->v2))
            {
                D3D_WARN(1, "    triangle %d is not an odd triangle",
                    ins->wCount - count);
                return FALSE;
            }
            break;

        case D3DTRIFLAG_EVEN:
            v1 = v1;
            v2 = v3;
            v3 = tri->v3;
            if ((v1 != tri->v1) || (v2 != tri->v2))
            {
                D3D_WARN(1, "    triangle %d is not an even triangle",
                    ins->wCount - count);
                return FALSE;
            }
            break;

        default:
            /* (flags > 0) && (flags < 30) */
            v1 = tri->v1;
            v2 = tri->v2;
            v3 = tri->v3;
            D3D_INFO(9, "  triangle %d is START FLAT of %d", ins->wCount - count, flags);

            flat_count = flags;

            break;
        }

        tri = (D3DTRIANGLE*) ((char*) tri + ins->bSize);
    }
    return TRUE;
}
//---------------------------------------------------------------------
D3DVERTEXTYPE GetVertexType(LPDIRECT3DDEVICEI lpDevI)
{
    if (lpDevI->dwFEFlags & D3DFE_TLVERTEX)
       return D3DVT_TLVERTEX;
    else
    if (lpDevI->dwFlags & D3DPV_LIGHTING)
       return D3DVT_VERTEX;
    else
       return D3DVT_LVERTEX;

}
#endif // DBG
//---------------------------------------------------------------------
// Returns TRUE, if driver should be notified about the state
BOOL
trackState(LPDIRECT3DDEVICEI lpDevI, LPD3DSTATE state)
{
    DWORD type = (DWORD) state->drstRenderStateType;

    D3D_INFO(9, "trackState: state = %d", state->drstRenderStateType);
    if (IS_OVERRIDE(type))
    {
        DWORD override = GET_OVERRIDE(type);
        if (state->dwArg[0])
        {
            D3D_INFO(9, "trackState: setting override for state %d", override);
            STATESET_SET(lpDevI->renderstate_overrides, override);
        }
        else
        {
            D3D_INFO(9, "trackState: clearing override for state %d", override);
            STATESET_CLEAR(lpDevI->renderstate_overrides, override);
        }
        return TRUE;
    }

    if (STATESET_ISSET(lpDevI->renderstate_overrides, type))
    {
        D3D_INFO(9, "trackState: state %d is overridden, ignoring", type);
        return FALSE;
    }

    /* Save latest state for GetRenderState(). This will break if
    someone actually implements the Execute in DDI i.e. when
    D3DHAL_Execute{Un}Clipped calls us. */

    SetDeviceRenderState(lpDevI, state->drstRenderStateType, state->dwArg[0]);
    return TRUE;
}
//----------------------------------------------------------------------
// This function does not copy the data if pIn = pOut
//
void ConvertColorsToRamp(LPDIRECT3DDEVICEI lpDevI, D3DTLVERTEX *pIn,
                         D3DTLVERTEX *pOut, DWORD count)
{
    RAMP_RANGE_INFO RampInfo;
    BOOL theSameInAndOut = pIn == pOut;
    CallRampService(lpDevI, RAMP_SERVICE_FIND_LIGHTINGRANGE,
                    (ULONG_PTR)&RampInfo, 0);
    D3DVALUE colorScale = D3DVAL(max(min((INT32)RampInfo.size - 1, 0x7fff), 0));
    for (DWORD i=count; i; i--)
    {
        const D3DVALUE B_SCALE = 1.000f / 255.0f;

        // Convert diffuse color to shade value
        D3DVALUE color = RGBA_GETBLUE (pIn->color)*B_SCALE;
        if (RampInfo.specular)
        {
            // Convert specular color to shade value
            D3DVALUE specular = RGBA_GETBLUE (pIn->specular)*B_SCALE;

            color = 0.75f*color*(1.0f - specular) + specular;
        }
        DWORD outColor = (DWORD)(color * colorScale) + RampInfo.base;
        if (theSameInAndOut)
        {
            pIn->color = CI_MAKE(RGBA_GETALPHA(pIn->color), outColor, 0);
            pIn->specular = PtrToUlong(RampInfo.pTexRampMap);
        }
        else
        {
            pOut->color = CI_MAKE(RGBA_GETALPHA(pIn->color), outColor, 0);
            pOut->specular = PtrToUlong(RampInfo.pTexRampMap);
            pOut->sx  = pIn->sx;
            pOut->sy  = pIn->sy;
            pOut->sz  = pIn->sz;
            pOut->rhw = pIn->rhw;
            pOut->tu  = pIn->tu;
            pOut->tv  = pIn->tv;
            pOut++;
        }
        pIn++;
    }
}
//---------------------------------------------------------------------
void WaitForFlip(LPDIRECTDRAWSURFACE lpDDS)
{
    if (DDCheckSurfaceCaps(lpDDS, DDSCAPS_FLIP))
    {
        HRESULT ret;
        D3D_WARN(4, "Waiting for flip");
        do
        {
            ret = lpDDS->GetFlipStatus(DDGFS_ISFLIPDONE);
        } while (ret == DDERR_WASSTILLDRAWING);
    }
}
//---------------------------------------------------------------------
// DrawPrim for execute buffers using RenderPrimitive
// This function is called by the clipper
//
HRESULT CDirect3DDeviceIHW::DrawExeBuf()
{
    D3DHAL_RENDERPRIMITIVEDATA data;
    LPDIRECTDRAWSURFACE lpDDS = this->lpDDSTarget;
    HRESULT ret;
    WORD wFirstPointIndex;

    memset(&data, 0, sizeof data);
    data.dwhContext = this->dwhContext;
    data.dwStatus = this->iClipStatus;
    data.dwTLOffset = 0;
    if (this->dwFlags & D3DPV_CLIPPERPRIM)
    {
    // For clipped primitive vertices are generated in ClipperState.clipBuf
        data.lpTLBuf = this->ClipperState.clipBuf.GetDDS();
        data.lpExeBuf = this->ClipperState.clipBufPrim.GetDDS();
        data.dwOffset = 0;
        wFirstPointIndex = 0;
    }
    else
    {
        data.lpTLBuf = this->TLVbuf.GetDDS();
        if (this->primType == D3DPT_POINTLIST)
        {
            data.lpExeBuf = this->ClipperState.clipBufPrim.GetDDS();
            data.dwOffset = 0;
            wFirstPointIndex = (WORD)(((BYTE*)this->lpvOut -
                               (BYTE*)this->TLVbuf.GetAddress()) >> 5);
        }
        else
        {
            data.lpExeBuf = this->ClipperState.lpDDExeBuf;
            data.dwOffset = (DWORD)
                ((BYTE*)this->lpwIndices - (BYTE*)this->ClipperState.lpvExeBufMem);
        }
    }
    switch (this->primType)
    {
        case D3DPT_POINTLIST:
        {
            D3DPOINT *pPoint = (D3DPOINT*)this->ClipperState.clipBufPrim.GetAddress();
            // Size of TLVERTEX is 32
            pPoint->wFirst = wFirstPointIndex;
            pPoint->wCount = (WORD)this->dwNumVertices;
            data.diInstruction.bOpcode = D3DOP_POINT;
            data.diInstruction.bSize = sizeof(D3DPOINT);
            data.diInstruction.wCount = 1;
            break;
        }
        case D3DPT_LINELIST:
        {
            data.diInstruction.bOpcode = D3DOP_LINE;
            data.diInstruction.bSize = sizeof(D3DLINE);
            D3DLINE *pLine= (D3DLINE*)this->ClipperState.clipBufPrim.GetAddress();
            if (this->dwFlags & D3DPV_CLIPPERPRIM)
            {
                // Clipped line is not indexed
                pLine->v1 = 0;
                pLine->v2 = 1;
                data.diInstruction.wCount = 1;
            }
            else
                data.diInstruction.wCount = (WORD)(this->dwNumIndices >> 1);
            break;
        }
        case D3DPT_TRIANGLEFAN:
        case D3DPT_TRIANGLELIST:
        {
            data.diInstruction.bOpcode = D3DOP_TRIANGLE;
            data.diInstruction.bSize = sizeof(D3DTRIANGLE);
            D3DTRIANGLE *pTri = (D3DTRIANGLE*)
                                this->ClipperState.clipBufPrim.GetAddress();
            if (this->dwFlags & D3DPV_CLIPPERPRIM)
            {
                // Clipped triangle is non-indexed triangle fan
                // We have to convert it to indexed triangle list and compute
                // edge flags
                ClipVertex **clip = this->ClipperState.current_vbuf;
                pTri->wFlags = D3DTRIFLAG_STARTFLAT((WORD)this->dwNumPrimitives);
                if (clip[0]->clip & CLIPPED_ENABLE)
                    pTri->wFlags |= D3DTRIFLAG_EDGEENABLE1;
                DWORD i;
                for (i=1; i <= this->dwNumPrimitives; i++)
                {
                    pTri->v1 = 0;
                    pTri->v2 = (WORD)i;
                    pTri->v3 = (WORD)(i+1);
                    if (clip[i]->clip & CLIPPED_ENABLE)
                        pTri->wFlags |= D3DTRIFLAG_EDGEENABLE2;
                    pTri++;
                    pTri->wFlags = D3DTRIFLAG_EVEN; // All except first are EVEN
                }
                pTri--;
                // Edge 3 is enabled only for the last triangle in the fan
                // Not that "i" points to the last clip vertex
                if (clip[i]->clip & CLIPPED_ENABLE)
                    pTri->wFlags |= D3DTRIFLAG_EDGEENABLE3;
                data.diInstruction.wCount = (WORD)this->dwNumPrimitives;
            }
            else
                data.diInstruction.wCount = (WORD)this->dwNumPrimitives;
            break;
        }
    }

#ifndef WIN95
    if((ret = CheckContextSurfaceNOLOCK(this)) != D3D_OK)
        return (D3DERR_EXECUTE_FAILED);
#endif //WIN95

#if _D3D_FORCEDOUBLE
    CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE
    CALL_HALONLY_NOLOCK(ret, this, RenderPrimitive, &data);

    if (ret != DDHAL_DRIVER_HANDLED)
    {
        D3D_ERR("HAL failed to handle RenderPrimitive call from Execute API");
        return (D3DERR_EXECUTE_FAILED);
    }
    this->iClipStatus = data.dwStatus;

    if (data.ddrval != DD_OK)
    {
        D3D_ERR("HAL error in RenderPrimitive call from Execute API");
        return (data.ddrval);
    }
    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT DIRECT3DDEVICEI::PickExeBuf()
{
    LPD3DTRIANGLE tri;
    DWORD i;
    LPD3DRECT pick_region = &this->pick_data.pick;
    D3DVALUE result;
    LPD3DTLVERTEX lpTLV;
    HRESULT ret;

    if (this->dwFlags & D3DPV_CLIPPERPRIM)
    {
        // For clipped primitive vertices are generated in ClipperState.clipBuf
        lpTLV = (D3DTLVERTEX*)this->ClipperState.clipBuf.GetAddress();
        D3DTRIANGLE tri;
        tri.v1 = 0;
        for (i=1; i <= this->dwNumPrimitives; i++)
        {
            tri.v2 = (WORD)i;
            tri.v3 = (WORD)(i+1);
            tri.wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
            if (GenPickTriangle(this, lpTLV, &tri, pick_region, &result))
            {
                if ((ret = GenAddPickRecord(this,
                                            D3DOP_TRIANGLE,
                                            this->dwClipIns_offset,
                                            result)) != D3D_OK)
                    return ret;
            }
        }
    }
    else
    {
        lpTLV = (D3DTLVERTEX*)this->TLVbuf.GetAddress();
        tri = (LPD3DTRIANGLE)this->lpwIndices;
        for (i = this->dwNumPrimitives; i; i--, tri++)
        {
            if (GenPickTriangle(this, lpTLV, tri, pick_region, &result))
            {
                if ((ret = GenAddPickRecord(this,
                                           D3DOP_TRIANGLE,
                                           (DWORD)((BYTE*)tri - (BYTE*)this->lpbClipIns_base),
                                           result)) != D3D_OK)
                    return ret;
            }
        }
    }
    return D3D_OK;
}
/*************************************************************************/
/*                              Points                                   */
/*************************************************************************/
HRESULT D3DFEClipPointsHW(LPDIRECT3DDEVICEI lpDevI, D3DPOINT *point, DWORD dwCount)
{
    DWORD icount = dwCount;
    HRESULT ret;

    lpDevI->primType = D3DPT_LINELIST;
    lpDevI->lpwIndices = 0; // Points are not indexed

    for (; icount; icount--)
    {
        lpDevI->dwNumVertices = point->wCount;
        lpDevI->lpvOut = &((D3DTLVERTEX*)lpDevI->TLVbuf.GetAddress())[point->wFirst];
        WORD *lpClipFlagsOld = lpDevI->lpClipFlags;
        lpDevI->lpClipFlags = &lpDevI->lpClipFlags[point->wFirst];
        ret = ProcessClippedPoints(lpDevI);
        if (ret != D3D_OK)
        {
            D3D_ERR("ProcessClippedPoints failed!");
            return ret;
        }
        lpDevI->lpClipFlags = lpClipFlagsOld;
        point++;
    }
    return D3D_OK;
}
/*************************************************************************/
/*                              Lines                                    */
/*************************************************************************/
inline HRESULT D3DFEClipLinesHW(LPDIRECT3DDEVICEI lpDevI, D3DLINE *line,  DWORD dwCount)
{
    HRESULT ret;
    lpDevI->primType = D3DPT_LINELIST;
    lpDevI->dwNumIndices = dwCount << 1;
    lpDevI->dwNumPrimitives = dwCount;
    lpDevI->lpvOut = lpDevI->TLVbuf.GetAddress();
    lpDevI->lpwIndices = (WORD*)line;

    ret = ProcessClippedIndexedLine(lpDevI);

    return ret;
}
/*************************************************************************/
/*                           Triangles                                   */
/*************************************************************************/
inline HRESULT D3DFEClipTrianglesHW(LPDIRECT3DDEVICEI lpDevI, D3DTRIANGLE *tri,  DWORD dwCount)
{
    HRESULT ret;
    lpDevI->primType = D3DPT_TRIANGLELIST;
    lpDevI->dwNumPrimitives = dwCount;
    lpDevI->lpvOut = lpDevI->TLVbuf.GetAddress();
    lpDevI->dwNumIndices = dwCount * 3;
    lpDevI->lpwIndices = (WORD*)tri;

    ret = ProcessClippedIndexedTriangleList(lpDevI);

    return ret;
}
/*************************************************************************/
/*                           Pick triangles                              */
/*************************************************************************/
inline HRESULT GenPickTriangles(LPDIRECT3DDEVICEI lpDevI, D3DTRIANGLE *tri, DWORD dwCount)
{
    HRESULT ret;
    lpDevI->primType = D3DPT_TRIANGLELIST;
    lpDevI->dwNumIndices = dwCount * 3;
    lpDevI->dwNumPrimitives = dwCount;
    lpDevI->lpvOut = lpDevI->TLVbuf.GetAddress();
    lpDevI->lpwIndices = (WORD*)tri;

    ret = ProcessClippedIndexedTriangleList(lpDevI);

    return ret;
}/*----------------------------------------------------------------------------
 *
 * Instruction emulation.
 */
HRESULT D3DHELInst_D3DOP_MATRIXLOAD(LPDIRECT3DDEVICEI lpDevI,
                                    DWORD dwCount,
                                    LPD3DMATRIXLOAD lpMatLoad)
{
    LPD3DMATRIXI lpSrcMat;
    LPD3DMATRIXI lpDestMat;
    DWORD i;
    HRESULT ret;
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;

    for (i = 0; i < dwCount; i++)
    {
        D3DMATRIXHANDLE  hSrc = lpMatLoad[i].hSrcMatrix;
        D3DMATRIXHANDLE  hDst = lpMatLoad[i].hDestMatrix;
        lpSrcMat  = HANDLE_TO_MAT(lpDevI, hSrc);
        lpDestMat = HANDLE_TO_MAT(lpDevI, hDst);
        if (lpSrcMat == NULL || lpDestMat == NULL)
            return (DDERR_INVALIDPARAMS);

        memcpy (lpDestMat, lpSrcMat, offsetof(D3DMATRIXI, link));

        if (hDst == TRANSFORM.hWorld)
            ret = D3DFE_SetMatrixWorld(lpDevI, (D3DMATRIX*)lpSrcMat);
        else
            if (hDst == TRANSFORM.hView)
                ret = D3DFE_SetMatrixView(lpDevI, (D3DMATRIX*)lpSrcMat);
            else
                if (hDst == TRANSFORM.hProj)
                    ret = D3DFE_SetMatrixProj(lpDevI, (D3DMATRIX*)lpSrcMat);

        if (ret != D3D_OK)
            return (DDERR_GENERIC);
    }

    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT D3DHELInst_D3DOP_MATRIXMULTIPLY(LPDIRECT3DDEVICEI lpDevI,
                                        DWORD dwCount,
                                        LPD3DMATRIXMULTIPLY lpMmult)
{
    LPD3DMATRIXI lpMat1, lpMat2;
    LPD3DMATRIXI result;
    DWORD i;
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;

    for (i = 0; i < dwCount; i++)
    {
        D3DMATRIXHANDLE  hSrc1 = lpMmult[i].hSrcMatrix1;
        D3DMATRIXHANDLE  hSrc2 = lpMmult[i].hSrcMatrix2;
        D3DMATRIXHANDLE  hDst  = lpMmult[i].hDestMatrix;
        lpMat1 = HANDLE_TO_MAT(lpDevI, hSrc1);
        lpMat2 = HANDLE_TO_MAT(lpDevI, hSrc2);
        result = HANDLE_TO_MAT(lpDevI, hDst);
        if (!lpMat1 || !lpMat2)
        {
            return (DDERR_GENERIC);
        }
        MatrixProduct(result, lpMat1, lpMat2);
        if (hDst == TRANSFORM.hWorld)
        {
            D3DFE_SetMatrixWorld(lpDevI, (D3DMATRIX*)result);
        }
        else
            if (hDst == TRANSFORM.hView)
            {
                D3DFE_SetMatrixView(lpDevI, (D3DMATRIX*)result);
            }
            else
                if (hDst == TRANSFORM.hProj)
                {
                    D3DFE_SetMatrixProj(lpDevI, (D3DMATRIX*)result);
                }
    }

    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT D3DHELInst_D3DOP_STATETRANSFORM(LPDIRECT3DDEVICEI lpDevI,
                                        DWORD count,
                                        LPD3DSTATE lpMset)
{
    DWORD i;
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;

    for (i = 0; i < count; i++)
    {
        DWORD type = (DWORD) lpMset[i].dtstTransformStateType;

        D3D_INFO(9, "HEL D3DOP_STATETRANSFORM: state = %d", type);
        if (IS_OVERRIDE(type))
        {
            DWORD override = GET_OVERRIDE(type);
            if (lpMset[i].dwArg[0])
            {
                D3D_WARN(5, "HEL D3DOP_STATETRANSFORM: setting override for state %d", override);
                STATESET_SET(lpDevI->transformstate_overrides, override);
            } else
            {
                D3D_WARN(5, "HEL D3DOP_STATETRANSFORM: clearing override for state %d", override);
                STATESET_CLEAR(lpDevI->transformstate_overrides, override);
            }
            continue;
        }

        if (STATESET_ISSET(lpDevI->transformstate_overrides, type))
        {
            D3D_WARN(5, "HEL D3DOP_STATETRANSFORM: state %d is overridden, ignoring", type);
            continue;
        }

        D3DMATRIXHANDLE hSrc = lpMset[i].dwArg[0];
        D3DMATRIX *lpSrcMat = (D3DMATRIX*)HANDLE_TO_MAT(lpDevI, hSrc);
        if (lpSrcMat == NULL)
        {
            // In DX5 days, this error was not propagated back.
            if (lpDevI->dwVersion <= 2)
                return D3D_OK;
            else
            {
                D3D_ERR("NULL srcMat in D3DHELInst_D3DOP_STATETRANSFORM");
                return (DDERR_INVALIDPARAMS);
            }
        }

        switch (type)
        {
        case D3DTRANSFORMSTATE_WORLD:
            D3DFE_SetMatrixWorld(lpDevI, lpSrcMat);
            TRANSFORM.hWorld = hSrc;
            break;
        case D3DTRANSFORMSTATE_VIEW:
            D3DFE_SetMatrixView(lpDevI, lpSrcMat);
            TRANSFORM.hView = hSrc;
            break;
        case D3DTRANSFORMSTATE_PROJECTION:
            D3DFE_SetMatrixProj(lpDevI, lpSrcMat);
            TRANSFORM.hProj = hSrc;
            break;
        default:
            D3D_ERR("Bad State in D3DopStateTransform emulation.");
            return DDERR_GENERIC;
        }
    }
    return (D3D_OK);
}
//---------------------------------------------------------------------
#if DBG
HRESULT validateProcessVertices(LPDIRECT3DDEVICEI lpDevI,
                                LPD3DPROCESSVERTICES data)
{
    LPD3DHAL_GLOBALDRIVERDATA lpGlob = lpDevI->lpD3DHALGlobalDriverData;
    unsigned int vnum;

    vnum = (unsigned int)(lpGlob->dwNumVertices ? lpGlob->dwNumVertices :
                                                  D3DHAL_DEFAULT_TL_NUM);

    if (data->wDest >= vnum) {
        D3D_ERR("Dest index to large for Execute Buffer.");
        return DDERR_INVALIDPARAMS;
    } else if ((data->wDest + data->dwCount) > vnum) {
        D3D_ERR("Process vertices exceeds Execute Buffer size.");
        return DDERR_INVALIDPARAMS;
    }

    return D3D_OK;
}
#endif
//---------------------------------------------------------------------
HRESULT D3DHELInst_D3DOP_TRANSFORM(LPDIRECT3DDEVICEI lpDevI,
                                   DWORD count,
                                   LPD3DPROCESSVERTICES data,
                                   LPD3DEXECUTEBUFFERDESC eb)
{
    LPD3DTLVERTEX lpTlv;
    DWORD i;
    DWORD op;
    HRESULT ret = DD_OK;

    lpDevI->primType = D3DPT_TRIANGLELIST;
    lpDevI->dwOutputSize = sizeof(D3DVERTEX);
    lpDevI->position.dwStride =  sizeof(D3DVERTEX);
    lpDevI->nTexCoord = 1;

    for (i = 0; i < count; i++)
    {

#if DBG
        if ((ret = validateProcessVertices(lpDevI, data)))
            return ret;
#endif

        int nVertices = data->wDest+data->dwCount;

        lpTlv = (LPD3DTLVERTEX)lpDevI->TLVbuf.GetAddress();
        lpDevI->dwNumVertices = data->dwCount;
        lpDevI->position.lpvData = ((char*)eb->lpData) +
                                   data->wStart * sizeof(D3DVERTEX);
        lpDevI->lpvOut = lpTlv + data->wDest;
        /*
        * Transform the vertices
        */

        op = data->dwFlags & D3DPROCESSVERTICES_OPMASK;
        if (op == D3DPROCESSVERTICES_COPY)
        {
            lpDevI->dwVIDIn = d3dVertexToFVF[D3DVT_TLVERTEX];
            memcpy(lpDevI->lpvOut, lpDevI->position.lpvData,
                data->dwCount * sizeof(D3DVERTEX));
            D3DFE_updateExtents(lpDevI);
            D3D_INFO(4, "TLVERTEX encountered. Will not clip.");
            lpDevI->dwFEFlags |= D3DFE_TLVERTEX;
            // Apply ramp post-lighting stuff only for D3DTLVERTEX.
            // For other vertex types this is done in the transformation loop
            //
            if (lpDevI->pfnRampService != NULL)
            {
                ConvertColorsToRamp(lpDevI, (D3DTLVERTEX*)lpDevI->lpvOut,
                                    (D3DTLVERTEX*)lpDevI->lpvOut, data->dwCount);
            }
            lpDevI->iClipStatus &= ~D3DSTATUS_CLIPINTERSECTIONALL;
        }
        else
        {
            if (op == D3DPROCESSVERTICES_TRANSFORMLIGHT)
            {
                lpDevI->dwVIDIn = d3dVertexToFVF[D3DVT_VERTEX];
                lpDevI->dwFlags |= D3DPV_LIGHTING;
            }
            else
            {
                lpDevI->dwVIDIn = d3dVertexToFVF[D3DVT_LVERTEX];
            }

            if (lpDevI->dwFlags & D3DDP_DONOTCLIP)
            {
                D3DFE_ProcessVertices(lpDevI);
                lpDevI->iClipStatus &= ~D3DSTATUS_CLIPINTERSECTIONALL;
            }
            else
            {
                lpDevI->lpClipFlags = (D3DFE_CLIPCODE*)lpDevI->HVbuf.GetAddress() +
                                       data->wDest;

                D3DFE_ProcessVertices(lpDevI);
                D3DFE_UpdateClipStatus(lpDevI);

                D3D_INFO(4, "Status Change -> Clip flags. status = %08x", lpDevI->iClipStatus);
                // Restore initial value for lpClipFlags
                lpDevI->lpClipFlags = (D3DFE_CLIPCODE*)lpDevI->HVbuf.GetAddress();
            }
        }

        /* update stats
        */
        lpDevI->D3DStats.dwVerticesProcessed += data->dwCount;
        data++;
    }
    //out_of_here:
    return (ret);
}
//--------------------------------------------------------------------
inline HRESULT GrowTLandHbuffers(LPDIRECT3DDEVICEI lpDevI, DWORD dwUsedVertexCount)
{
    HRESULT ddrval;
    if (dwUsedVertexCount > 4096)
        dwUsedVertexCount = 4096;
    else
        if (dwUsedVertexCount < lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwMaxVertexCount)
            dwUsedVertexCount = lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwMaxVertexCount;

    ddrval = lpDevI->TLVbuf.CheckAndGrow(lpDevI, dwUsedVertexCount << 5);
    if (ddrval != D3D_OK)
    {
        D3D_ERR("Failed to check and grow TLVbuf in Execute");
        return ddrval;
    }
    ddrval = lpDevI->HVbuf.CheckAndGrow(dwUsedVertexCount*sizeof(D3DFE_CLIPCODE));
    if (ddrval != D3D_OK)
    {
        D3D_ERR("Failed to check and grow HVbuf in Execute");
        return ddrval;
    }
    return D3D_OK;
}
//--------------------------------------------------------------------
//
#define WAIT_FOR_FLIP()                 \
    if (!waitedForFlip)                 \
    {                                   \
        WaitForFlip(lpDDS);             \
        waitedForFlip = TRUE;           \
    }

HRESULT
CDirect3DDeviceIHW::ExecuteI(LPD3DI_EXECUTEDATA lpExData, DWORD mode)
{
    BOOL waitedForFlip = FALSE;
    D3DINSTRUCTION* lpIns;
    D3DHAL_RENDERSTATEDATA stateData;
    D3DHAL_RENDERPRIMITIVEDATA primitiveData;
    D3DEXECUTEBUFFERDESC debDesc;
    LPDIRECTDRAWSURFACE lpDDS = this->lpDDSTarget;
    LPBYTE prim;
    D3DFE_TRANSFORM *transform = &this->transform;
    LPDIRECTDRAWSURFACE lpDDExeBuf;
    HRESULT ddrval;

    CHECKLOST(this);

    // Do we need to map new texture stage operations to DX5 renderstates?
    if(this->dwFEFlags & D3DFE_MAP_TSS_TO_RS) {
        MapTSSToRS();
        this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS; // Reset request bit
    }
    /* Update textures */
    UpdateTextures();

    if (mode == D3DEXECUTE_UNCLIPPED)
        this->dwFlags |= D3DDP_DONOTCLIP;
    else if (mode != D3DEXECUTE_CLIPPED)
        return DDERR_INVALIDPARAMS;
    /*
    * If the driver can process triangles while the hardware has a
    * pending page-flip such as the 3Dfx voodoo chipset, then we
    * don't need to call WaitForFlip.  We pretend that it has already
    * been called to keep the code simple.
    */
    if (this->lpD3DHALGlobalDriverData->hwCaps.dwDevCaps &
        D3DDEVCAPS_CANRENDERAFTERFLIP)
    {
        waitedForFlip = TRUE;
    }

    /*
    * Lock the HAL for the duration.
    */
    LOCK_HAL(ddrval, this);
    if (ddrval != DD_OK)
    {
        D3D_ERR("Failed to lock HAL in Execute");
        return (ddrval);
    }
#if _D3D_FORCEDOUBLE
    CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE

    /*
    * Execute the buffer through the HAL
    */
    {
        LPD3DHAL_EXDATA hexData = (LPD3DHAL_EXDATA) lpExData->dwHandle;

        debDesc.lpData = SURFACE_MEMORY(hexData->lpDDS);
        lpDDExeBuf = hexData->lpDDS;
    }

    memset(&stateData, 0, sizeof(D3DHAL_RENDERSTATEDATA));
    stateData.dwhContext = this->dwhContext;
    stateData.lpExeBuf = lpDDExeBuf;

    memset(&primitiveData, 0, sizeof(D3DHAL_RENDERPRIMITIVEDATA));
    primitiveData.dwhContext = this->dwhContext;
    primitiveData.lpExeBuf = lpDDExeBuf;
    primitiveData.dwTLOffset = 0L;

    this->ClipperState.lpDDExeBuf = lpDDExeBuf;
    this->ClipperState.lpvExeBufMem = debDesc.lpData;

    // Modify driver funcs for EB case
    PFN_DRAWPRIM pfnOldDrawPrim = this->pfnDrawPrim;
    PFN_DRAWPRIM pfnOldDrawIndexedPrim = this->pfnDrawIndexedPrim;
    this->pfnDrawPrim = &DIRECT3DDEVICEI::DrawExeBuf;
    this->pfnDrawIndexedPrim = &DIRECT3DDEVICEI::DrawExeBuf;

    /*
     * The first instruction.
     */
    lpIns = (LPD3DINSTRUCTION)((LPBYTE)debDesc.lpData +
                   lpExData->dwInstructionOffset);

    ddrval = GrowTLandHbuffers(this, lpExData->dwVertexCount);
    if (ddrval != D3D_OK)
        goto execute_failed;

    // do this after CheckAndGrow, because TL buffer could be re-created
    primitiveData.lpTLBuf = this->TLVbuf.GetDDS();

    while (lpIns->bOpcode != D3DOP_EXIT)
    {
        prim = (LPBYTE)lpIns + sizeof(D3DINSTRUCTION);
        D3D_INFO(5, "HAL parsing instruction %d", lpIns->bOpcode);

        /*
        * Parse the instruction.
        */
        switch (lpIns->bOpcode)
        {
        case D3DOP_MATRIXLOAD:
            {
                D3D_INFO(5, "Emulating D3DOP_MATRIXLOAD for HAL");
                ddrval = D3DHELInst_D3DOP_MATRIXLOAD(this,
                    lpIns->wCount,
                    (LPD3DMATRIXLOAD)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_MATRIXLOAD failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DMATRIXLOAD, lpIns->wCount);
                break;
            }

        case D3DOP_MATRIXMULTIPLY:
            {
                D3D_INFO(5, "Emulating D3DOP_MATRIXMULTIPLY for HAL");
                ddrval = D3DHELInst_D3DOP_MATRIXMULTIPLY(this,
                    lpIns->wCount,
                    (LPD3DMATRIXMULTIPLY)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_MATRIXMULTIPLY failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DMATRIXMULTIPLY, lpIns->wCount);
                break;
            }

        case D3DOP_PROCESSVERTICES:
            {
                D3D_INFO(5, "Emulating D3DOP_PROCESSVERTICES for HAL");

                ddrval = D3DHELInst_D3DOP_TRANSFORM
                    (this, lpIns->wCount, (LPD3DPROCESSVERTICES)prim,
                     &debDesc);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_PROCESSVERTICES failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DPROCESSVERTICES, lpIns->wCount);
                break;
            }

        case D3DOP_STATETRANSFORM:
            {
                D3D_INFO(5, "Emulating D3DOP_STATETRANSFORM for HAL");
                ddrval = D3DHELInst_D3DOP_STATETRANSFORM(this,
                    lpIns->wCount,
                    (LPD3DSTATE)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_STATETRANSFORM failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                break;
            }

        case D3DOP_STATELIGHT:
            {
                D3D_INFO(5, "Emulating D3DOP_STATELIGHT for HAL");
                ddrval = D3DHELInst_D3DOP_STATELIGHT(this,
                    lpIns->wCount,
                    (LPD3DSTATE)prim);
                if (ddrval != D3D_OK) {
                    D3D_ERR("Emulated D3DOP_STATELIGHT failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                break;
            }

        case D3DOP_BRANCHFORWARD:
            {
                D3DBRANCH* branch = (D3DBRANCH*)prim;
                LPBYTE target;
                BOOL isTaken = FALSE;

                D3D_INFO(5, "Emulating D3DOP_BRANCHFORWARD");
                if (branch->bNegate)
                {
                    if ((branch->dwMask & this->iClipStatus) != branch->dwValue)
                    {
                        D3D_INFO(4, "Taking forward branch");
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        }
                        else
                        {
                            D3D_INFO(4, "branch says to exit.");
                            goto execute_done;
                        }
                    }
                }
                else
                {
                    if ((branch->dwMask & this->iClipStatus) == branch->dwValue)
                    {
                        D3D_INFO(4, "Taking forward branch");
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        } else
                        {
                            D3D_INFO(2, "branch says to exit.");
                            goto execute_done;
                        }
                    }
                }
                if (isTaken)
                {
                    D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: branch taken");
                    lpIns = (LPD3DINSTRUCTION) target;
                }
                else
                {
                    D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: branch not taken");
                    NEXTINSTRUCTION(lpIns, D3DBRANCH, lpIns->wCount);
                }
                break;
            }

        case D3DOP_TEXTURELOAD:
            {
                D3D_INFO(5, "Emulating D3DOP_TEXTURELOAD for HAL");
                ddrval = D3DHELInst_D3DOP_TEXTURELOAD(this,
                    lpIns->wCount,
                    (LPD3DTEXTURELOAD)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_TEXTURELOAD failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DTEXTURELOAD, lpIns->wCount);
                break;
            }

        case D3DOP_STATERENDER:
            {
                LPD3DSTATE lpState;
                DWORD i,j,statek,valuek;

                lpState = (LPD3DSTATE) (lpIns + 1);
                for (i = 0,j=0,statek=(DWORD)-1; i < lpIns->wCount; i++)
                {
                    trackState(this, &lpState[i]);
                }
                stateData.dwOffset = (DWORD)(prim - (LPBYTE) debDesc.lpData);
                stateData.dwCount =  lpIns->wCount;
                CALL_HALONLY_NOLOCK(ddrval, this, RenderState, &stateData);
                if (stateData.ddrval != DD_OK)
                {
                    D3D_ERR("HAL error in RenderState call from Execute API");
                    ddrval = stateData.ddrval;
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                break;
            }

        case D3DOP_SETSTATUS:
            {
                LPD3DSTATUS status = (LPD3DSTATUS)prim;
                if (status->dwFlags & D3DSETSTATUS_STATUS)
                    this->iClipStatus = status->dwStatus;
                if (status->dwFlags & D3DSETSTATUS_EXTENTS)
                {
                    this->rExtents.x1 = D3DVAL(status->drExtent.x1);
                    this->rExtents.y1 = D3DVAL(status->drExtent.y1);
                    this->rExtents.x2 = D3DVAL(status->drExtent.x2);
                    this->rExtents.y2 = D3DVAL(status->drExtent.y2);
                }
                NEXTINSTRUCTION(lpIns, D3DSTATUS, lpIns->wCount);
                break;
            }

        default:
            if (mode == D3DEXECUTE_UNCLIPPED || this->dwFEFlags & D3DFE_TLVERTEX)
            {
                switch (lpIns->bOpcode)
                {
                case D3DOP_POINT:
                case D3DOP_LINE:
                case D3DOP_SPAN:
                case D3DOP_TRIANGLE:
                    {
                        if (lpIns->wCount == 0)
                            goto noprim;
#if DBG
                        switch (lpIns->bOpcode)
                        {
                        case D3DOP_POINT:
                            Profile(PROF_EXECUTE, D3DPT_POINTLIST, GetVertexType(this));
                            break;
                        case D3DOP_LINE:
                            Profile(PROF_EXECUTE, D3DPT_LINELIST, GetVertexType(this));
                            break;
                        case D3DOP_TRIANGLE:
                            Profile(PROF_EXECUTE, D3DPT_TRIANGLELIST, GetVertexType(this));
                            break;
                        }
#endif // DBG
                        if (!waitedForFlip)
                        {
                            WaitForFlip(lpDDS);
                            waitedForFlip = TRUE;
                        }

                        primitiveData.dwOffset = (DWORD)(prim - (LPBYTE) debDesc.lpData);
                        primitiveData.dwStatus = this->iClipStatus;
                        primitiveData.diInstruction = *lpIns;

#ifndef WIN95
                        if((ddrval = CheckContextSurfaceNOLOCK (this)) != D3D_OK)
                        {
                            goto execute_failed;
                        }
#endif //WIN95
                        CALL_HALONLY_NOLOCK(ddrval, this, RenderPrimitive,
                                &primitiveData);
                        if (primitiveData.ddrval != DD_OK)
                        {
                            D3D_ERR("HAL error in RenderPrimitive call from Execute API");
                            ddrval = primitiveData.ddrval;
                            goto execute_failed;
                        }
                        switch (lpIns->bOpcode)
                        {
                            int i;
                        case D3DOP_LINE:
                            this->D3DStats.dwLinesDrawn += lpIns->wCount;
                            break;
                        case D3DOP_TRIANGLE:
#if DBG
                            if (!validateTriangleFlags(lpIns, (LPD3DTRIANGLE) prim))
                            {
                                ddrval = DDERR_INVALIDPARAMS;
                                goto execute_failed;
                            }
#endif
                            this->D3DStats.dwTrianglesDrawn += lpIns->wCount;
                            break;
                        case D3DOP_POINT:
                            {
                                LPD3DPOINT point = (LPD3DPOINT)prim;
                                for (i = 0; i < lpIns->wCount; i++)
                                {
                                    this->D3DStats.dwPointsDrawn += point->wCount;
                                    point++;
                                }
                            }
                            break;
                        case D3DOP_SPAN:
                            {
                                LPD3DSPAN span = (LPD3DSPAN)prim;
                                for (i = 0; i < lpIns->wCount; i++)
                                {
                                    this->D3DStats.dwSpansDrawn += span->wCount;
                                    span++;
                                }
                            }
                            break;
                        }

                        this->iClipStatus = primitiveData.dwStatus;
                    noprim:
                        lpIns = (LPD3DINSTRUCTION)((LPBYTE)lpIns +
                            sizeof(D3DINSTRUCTION) +
                            (lpIns->bSize * lpIns->wCount));
                        break;
                    }
                default:
                    D3D_ERR("HAL detected invalid instruction opcode in Execute");
                    goto execute_failed;
                }
            }
            else
            {
                switch (lpIns->bOpcode)
                {
                case D3DOP_TRIANGLE:
                    if (lpIns->wCount == 0)
                    {
                        NEXTINSTRUCTION(lpIns, D3DTRIANGLE, lpIns->wCount);
                        break;
                    }
                    Profile(PROF_EXECUTE, D3DPT_TRIANGLELIST, GetVertexType(this));
                    WAIT_FOR_FLIP();
#if DBG
                    if (!validateTriangleFlags(lpIns, (LPD3DTRIANGLE) prim))
                    {
                        ddrval = DDERR_INVALIDPARAMS;
                        goto execute_failed;
                    }
#endif
                    this->D3DStats.dwTrianglesDrawn += lpIns->wCount;
                    D3D_INFO(5, "Emulating D3DOP_TRIANGLE for HAL and clipping");
                    ddrval = D3DFEClipTrianglesHW(this, (LPD3DTRIANGLE)prim, lpIns->wCount);
                    if (ddrval != D3D_OK)
                    {
                        D3D_ERR("D3DFEClipTrianglesHW failed");
                        goto execute_failed;
                    }
                    NEXTINSTRUCTION(lpIns, D3DTRIANGLE, lpIns->wCount);
                    break;

                case D3DOP_LINE:

                    if (lpIns->wCount == 0)
                    {
                        NEXTINSTRUCTION(lpIns, D3DLINE, lpIns->wCount);
                        break;
                    }
                    Profile(PROF_EXECUTE, D3DPT_LINELIST, GetVertexType(this));
                    WAIT_FOR_FLIP();

                    D3D_INFO(5, "Emulating D3DOP_LINE for HAL and clipping");
                    this->D3DStats.dwLinesDrawn += lpIns->wCount;

                    ddrval = D3DFEClipLinesHW(this, (LPD3DLINE)prim, lpIns->wCount);
                    if (ddrval != D3D_OK)
                    {
                        D3D_ERR("D3DFEClipLinesHW failed");
                        goto execute_failed;
                    }
                    NEXTINSTRUCTION(lpIns, D3DLINE, lpIns->wCount);
                    break;

                case D3DOP_POINT:
                    WAIT_FOR_FLIP();

                    Profile(PROF_EXECUTE, D3DPT_POINTLIST, GetVertexType(this));
                    D3D_INFO(5, "Emulating D3DOP_POINT for HAL and clipping");
                    {
                        LPD3DPOINT point = (LPD3DPOINT) prim;
                        int i;
                        for (i = 0; i < lpIns->wCount; i++)
                        {
                            this->D3DStats.dwPointsDrawn += point->wCount;
                            point++;
                        }
                    }
                    if ((ddrval = D3DFEClipPointsHW(this, (LPD3DPOINT)prim, lpIns->wCount)) != D3D_OK)
                    {
                        D3D_ERR("Failed D3DFEClipPointsHW");
                        goto execute_failed;
                    }
                    NEXTINSTRUCTION(lpIns, D3DPOINT, lpIns->wCount);
                    break;

                case D3DOP_SPAN:
                    {
                        LPD3DSPAN span = (LPD3DSPAN)prim;
                        D3DHAL_RENDERPRIMITIVEDATA primitiveData;
                        int i;

                        WAIT_FOR_FLIP();

                        memset(&primitiveData, 0, sizeof(D3DHAL_RENDERPRIMITIVEDATA));
                        primitiveData.dwhContext = this->dwhContext;
                        primitiveData.lpExeBuf = lpDDExeBuf;
                        primitiveData.dwTLOffset = 0L;
                        primitiveData.lpTLBuf = this->TLVbuf.GetDDS();
                        primitiveData.dwOffset = (DWORD)(prim - (LPBYTE) debDesc.lpData);
                        primitiveData.dwStatus = this->iClipStatus;
                        primitiveData.diInstruction = *lpIns;

#ifndef WIN95
                        if((ddrval = CheckContextSurfaceNOLOCK(this)) != D3D_OK)
                            goto execute_failed;
#endif //WIN95
                        CALL_HALONLY_NOLOCK(ddrval, this, RenderPrimitive,
                            &primitiveData);

                        if (primitiveData.ddrval != DD_OK)
                        {
                            D3D_ERR("HAL error in RenderPrimitive call from Execute API");
                            ddrval = primitiveData.ddrval;
                            goto execute_failed;
                        }
                        for (i = 0; i < lpIns->wCount; i++)
                        {
                            this->D3DStats.dwSpansDrawn += span->wCount;
                            span++;
                        }
                        this->iClipStatus = primitiveData.dwStatus;
                        lpIns = (LPD3DINSTRUCTION)((LPBYTE)lpIns
                            + sizeof(D3DINSTRUCTION)
                            + (lpIns->bSize * lpIns->wCount));
                        break;
                    }
                default:
                    D3D_ERR("HAL detected invalid instruction opcode in Execute");
                    goto execute_failed;
            }
            ClampExtents(this);
        }
    }
    }

execute_done:
    ddrval = D3D_OK;
    D3DFE_ConvertExtent(this, &this->rExtents, &lpExData->dsStatus.drExtent);
    lpExData->dsStatus.dwStatus = this->iClipStatus;
execute_failed:
    UNLOCK_HAL(this);
    // Restore driver funcs
    this->pfnDrawIndexedPrim = pfnOldDrawIndexedPrim;
    this->pfnDrawPrim = pfnOldDrawPrim;
    return ddrval;
}
//-------------------------------------------------------------------------------------------------
void TrackAllStates(LPDIRECT3DDEVICEI lpDevI, LPD3DINSTRUCTION lpIns, LPD3DINSTRUCTION lpEnd)
{
    while (lpIns->bOpcode != D3DOP_EXIT && (lpEnd == NULL || lpIns < lpEnd))
    {
        LPBYTE prim = (LPBYTE)lpIns + sizeof(D3DINSTRUCTION);
        switch (lpIns->bOpcode)
        {
        case D3DOP_MATRIXLOAD:
            {
                NEXTINSTRUCTION(lpIns, D3DMATRIXLOAD, lpIns->wCount);
                break;
            }

        case D3DOP_MATRIXMULTIPLY:
            {
                NEXTINSTRUCTION(lpIns, D3DMATRIXMULTIPLY, lpIns->wCount);
                break;
            }

        case D3DOP_PROCESSVERTICES:
            {
                NEXTINSTRUCTION(lpIns, D3DPROCESSVERTICES, lpIns->wCount);
                break;
            }

        case D3DOP_STATETRANSFORM:
            {
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                break;
            }

        case D3DOP_STATELIGHT:
            {
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                break;
            }

        case D3DOP_BRANCHFORWARD:
            {
                D3DBRANCH* branch = (D3DBRANCH*)prim;
                LPBYTE target;
                BOOL isTaken = FALSE;

                if (branch->bNegate)
                {
                    if ((branch->dwMask & lpDevI->iClipStatus) != branch->dwValue)
                    {
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        }
                        else
                        {
                            D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: branch says to exit.");
                            break;
                        }
                    }
                }
                else
                {
                    if ((branch->dwMask & lpDevI->iClipStatus) == branch->dwValue)
                    {
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        } else
                        {
                            break;
                        }
                    }
                }
                if (isTaken)
                {
                    lpIns = (LPD3DINSTRUCTION) target;
                }
                else
                {
                    NEXTINSTRUCTION(lpIns, D3DBRANCH, lpIns->wCount);
                }
                break;
            }

        case D3DOP_TEXTURELOAD:
            {
                NEXTINSTRUCTION(lpIns, D3DTEXTURELOAD, lpIns->wCount);
                break;
            }

        case D3DOP_SETSTATUS:
            {
                NEXTINSTRUCTION(lpIns, D3DSTATUS, lpIns->wCount);
                break;
            }
        case D3DOP_STATERENDER:
            {
                LPD3DSTATE lpState;
                DWORD i,j,statek,valuek;
                lpState = (LPD3DSTATE) (lpIns + 1);
                for (i = 0,j=0,statek=(DWORD)-1; i < lpIns->wCount; i++)
                {
                    trackState(lpDevI, &lpState[i]);
                }
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
            }
            break;
        case D3DOP_TRIANGLE:
            NEXTINSTRUCTION(lpIns, D3DTRIANGLE, lpIns->wCount);
            break;

        case D3DOP_LINE:
            NEXTINSTRUCTION(lpIns, D3DLINE, lpIns->wCount);
            break;

        case D3DOP_POINT:
            NEXTINSTRUCTION(lpIns, D3DPOINT, lpIns->wCount);
            break;

        case D3DOP_SPAN:
            // This case is NOOP since we do not implement spans in DP2 DDI
            {
                lpIns = (LPD3DINSTRUCTION)((LPBYTE)lpIns
                    + sizeof(D3DINSTRUCTION)
                    + (lpIns->bSize * lpIns->wCount));
                break;
            }
        default:
            D3D_ERR("Invalid instruction opcode in TrackAllStates");
            break;
        } // switch
    } // while
}
//-------------------------------------------------------------------------------------------------
// New execute for DP2 HAL
//
HRESULT
CDirect3DDeviceIDP2::ExecuteI(LPD3DI_EXECUTEDATA lpExData, DWORD mode)
{
    BOOL waitedForFlip = FALSE;
    D3DINSTRUCTION* lpIns;
    D3DEXECUTEBUFFERDESC debDesc;
    LPDIRECTDRAWSURFACE lpDDS = this->lpDDSTarget;
    LPBYTE prim;
    D3DFE_TRANSFORM *transform = &this->transform;
    LPDIRECTDRAWSURFACE lpDDExeBuf;
    HRESULT ddrval, dp2dataddrval;

    CHECKLOST(this);

    /* Update textures */
    UpdateTextures();

    if (mode == D3DEXECUTE_UNCLIPPED)
        this->dwFlags |= D3DDP_DONOTCLIP;
    else if (mode != D3DEXECUTE_CLIPPED)
        return DDERR_INVALIDPARAMS;
    /*
     * If the driver can process triangles while the hardware has a
     * pending page-flip such as the 3Dfx voodoo chipset, then we
     * don't need to call WaitForFlip.  We pretend that it has already
     * been called to keep the code simple.
     */
    if (this->lpD3DHALGlobalDriverData->hwCaps.dwDevCaps &
        D3DDEVCAPS_CANRENDERAFTERFLIP)
    {
        waitedForFlip = TRUE;
    }

    /*
     * Lock the HAL for the duration.
     */
    LOCK_HAL(ddrval, this);
    if (ddrval != DD_OK)
    {
        D3D_ERR("Failed to lock HAL in Execute");
        return (ddrval);
    }

    /*
     * Execute the buffer through the HAL
     */
    LPD3DHAL_EXDATA hexData = (LPD3DHAL_EXDATA) lpExData->dwHandle;

    debDesc.lpData = SURFACE_MEMORY(hexData->lpDDS);
    lpDDExeBuf = hexData->lpDDS;

    /*
     * The first instruction.
     */
    lpIns = (LPD3DINSTRUCTION)((LPBYTE)debDesc.lpData +
        lpExData->dwInstructionOffset);
    // Fill up common part of dp2Data
    this->dp2data.dwVertexType = D3DFVF_TLVERTEX;
    this->dp2data.dwVertexSize = sizeof(D3DTLVERTEX);
    this->dp2data.dwVertexOffset = 0;

    ddrval = GrowTLandHbuffers(this, lpExData->dwVertexCount);
    if (ddrval != D3D_OK)
        goto execute_failed;

    this->dwOutputSize = sizeof(D3DTLVERTEX);
    // Start new primitive batch
    ddrval= StartPrimVB(this->TLVbuf.GetVBI(), 0);
    if (ddrval != D3D_OK)
    {
        UNLOCK_HAL(this);
        D3D_ERR("Failed to start new primitve batch in Execute");
        return ddrval;
    }
    // Since many legacy apps do not bother to set the dwVertexLength correctly, we estimate
    // the vertex length here to be thse size of buffer allocated. This atleast guarantees
    // that the memory is valid. It may still contain garbage data which the driver needs
    // to protect itself from
    this->dp2data.dwVertexLength = this->TLVbuf.GetSize() >> 5; // divide by sizeof(D3DTLVERTEX)

    this->ClipperState.lpDDExeBuf = lpDDExeBuf;
    this->ClipperState.lpvExeBufMem = debDesc.lpData;

    while (lpIns->bOpcode != D3DOP_EXIT)
    {
        prim = (LPBYTE)lpIns + sizeof(D3DINSTRUCTION);
        D3D_INFO(5, "HAL parsing instruction %d", lpIns->bOpcode);

        /*
        * Parse the instruction.
        */
        switch (lpIns->bOpcode)
        {
        case D3DOP_MATRIXLOAD:
            {
                D3D_INFO(5, "Emulating D3DOP_MATRIXLOAD for HAL");
                ddrval = D3DHELInst_D3DOP_MATRIXLOAD(this,
                    lpIns->wCount,
                    (LPD3DMATRIXLOAD)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_MATRIXLOAD failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DMATRIXLOAD, lpIns->wCount);
                break;
            }

        case D3DOP_MATRIXMULTIPLY:
            {
                D3D_INFO(5, "Emulating D3DOP_MATRIXMULTIPLY for HAL");
                ddrval = D3DHELInst_D3DOP_MATRIXMULTIPLY(this,
                    lpIns->wCount,
                    (LPD3DMATRIXMULTIPLY)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_MATRIXMULTIPLY failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DMATRIXMULTIPLY, lpIns->wCount);
                break;
            }

        case D3DOP_PROCESSVERTICES:
            {
                D3D_INFO(5, "Emulating D3DOP_PROCESSVERTICES for HAL");

                ddrval = D3DHELInst_D3DOP_TRANSFORM
                    (this, lpIns->wCount, (LPD3DPROCESSVERTICES)prim,
                     &debDesc);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_PROCESSVERTICES failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DPROCESSVERTICES, lpIns->wCount);
                break;
            }

        case D3DOP_STATETRANSFORM:
            {
                D3D_INFO(5, "Emulating D3DOP_STATETRANSFORM for HAL");
                ddrval = D3DHELInst_D3DOP_STATETRANSFORM(this,
                    lpIns->wCount,
                    (LPD3DSTATE)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_STATETRANSFORM failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                break;
            }

        case D3DOP_STATELIGHT:
            {
                D3D_INFO(5, "Emulating D3DOP_STATELIGHT for HAL");
                ddrval = D3DHELInst_D3DOP_STATELIGHT(this,
                    lpIns->wCount,
                    (LPD3DSTATE)prim);
                if (ddrval != D3D_OK) {
                    D3D_ERR("Emulated D3DOP_STATELIGHT failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                break;
            }

        case D3DOP_BRANCHFORWARD:
            {
                D3DBRANCH* branch = (D3DBRANCH*)prim;
                LPBYTE target;
                BOOL isTaken = FALSE;

                D3D_INFO(5, "Emulating D3DOP_BRANCHFORWARD");
                if (branch->bNegate)
                {
                    if ((branch->dwMask & this->iClipStatus) != branch->dwValue)
                    {
                        D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: Taking forward branch");
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        }
                        else
                        {
                            D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: branch says to exit.");
                            goto execute_done;
                        }
                    }
                }
                else
                {
            D3D_INFO(5, "dwMask = %lx, iClipStatus = %lx, dwValue = %lx", branch->dwMask, this->iClipStatus, branch->dwValue);
                    if ((branch->dwMask & this->iClipStatus) == branch->dwValue)
                    {
                        D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: Taking forward branch");
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        } else
                        {
                            D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: branch says to exit.");
                            goto execute_done;
                        }
                    }
                }
                if (isTaken)
                {
                    D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: branch taken");
                    lpIns = (LPD3DINSTRUCTION) target;
                }
                else
                {
                    D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: branch not taken");
                    NEXTINSTRUCTION(lpIns, D3DBRANCH, lpIns->wCount);
                }
                break;
            }

        case D3DOP_TEXTURELOAD:
            {
                D3D_INFO(5, "Emulating D3DOP_TEXTURELOAD for HAL");
                ddrval = D3DHELInst_D3DOP_TEXTURELOAD(this,
                    lpIns->wCount,
                    (LPD3DTEXTURELOAD)prim);
                if (ddrval != D3D_OK)
                {
                    D3D_ERR("Emulated D3DOP_TEXTURELOAD failed.");
                    goto execute_failed;
                }
                NEXTINSTRUCTION(lpIns, D3DTEXTURELOAD, lpIns->wCount);
                break;
            }

        case D3DOP_SETSTATUS:
            {
                LPD3DSTATUS status = (LPD3DSTATUS)prim;
                if (status->dwFlags & D3DSETSTATUS_STATUS)
                    this->iClipStatus = status->dwStatus;
                if (status->dwFlags & D3DSETSTATUS_EXTENTS)
                {
                    this->rExtents.x1 = D3DVAL(status->drExtent.x1);
                    this->rExtents.y1 = D3DVAL(status->drExtent.y1);
                    this->rExtents.x2 = D3DVAL(status->drExtent.x2);
                    this->rExtents.y2 = D3DVAL(status->drExtent.y2);
                }
                NEXTINSTRUCTION(lpIns, D3DSTATUS, lpIns->wCount);
                break;
            }

        default:
            if ((this->dwFEFlags & D3DFE_TLVERTEX) || (mode == D3DEXECUTE_UNCLIPPED))
            {
                switch (lpIns->bOpcode)
                {
                case D3DOP_STATERENDER:
                case D3DOP_POINT:
                case D3DOP_LINE:
                case D3DOP_SPAN:
                    // ATTENTION
                    // We need to disallow SPAN from going through since the new DDI spec
                    // does not account for spans. We probably want to deprecate spans in
                    // any case so them being slower might not be too bad. Right now, though
                    // we are passing them to the driver.
                case D3DOP_TRIANGLE:
#if DBG
                    switch (lpIns->bOpcode)
                    {
                    case D3DOP_POINT:
                        Profile(PROF_EXECUTE, D3DPT_POINTLIST, GetVertexType(this));
                        break;
                    case D3DOP_LINE:
                        Profile(PROF_EXECUTE, D3DPT_LINELIST, GetVertexType(this));
                        break;
                    case D3DOP_TRIANGLE:
                        Profile(PROF_EXECUTE, D3DPT_TRIANGLELIST, GetVertexType(this));
                        break;
                    }
#endif // DBG
                    if (lpIns->wCount == 0)
                    {
                        lpIns = (LPD3DINSTRUCTION)((LPBYTE)lpIns +
                            sizeof(D3DINSTRUCTION) +
                            (lpIns->bSize * lpIns->wCount));
                        break;
                    }
                    if (!waitedForFlip)
                    {
                        WaitForFlip(lpDDS);
                        waitedForFlip = TRUE;
                    }

                    this->dp2data.dwVertexType = D3DFVF_TLVERTEX;
                    this->dp2data.dwVertexSize = sizeof(D3DTLVERTEX);
                    this->dp2data.lpDDCommands = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDExeBuf)->lpLcl;
                    this->dp2data.dwCommandOffset = (DWORD)((LPBYTE)lpIns - (LPBYTE) debDesc.lpData);
                    this->dp2data.dwCommandLength = lpExData->dwInstructionOffset + lpExData->dwInstructionLength -
                                              this->dp2data.dwCommandOffset;
                    // Can't swap command buffer in this case
                    this->dp2data.dwFlags &= ~(D3DHALDP2_SWAPCOMMANDBUFFER | D3DHALDP2_SWAPVERTEXBUFFER);
                    this->dp2data.lpdwRStates = this->rstates;
#ifndef WIN95
                    if (!IS_DX7HAL_DEVICE(this))
                    {
                        if((ddrval = CheckContextSurfaceNOLOCK (this)) != D3D_OK)
                        {
                            goto execute_failed;
                        }
                    }
#endif //WIN95
                    // and tell driver to update lpdwRStates
                    this->dp2data.dwFlags |= D3DHALDP2_EXECUTEBUFFER;
                    // Spin waiting on the driver
                    do {
                        CALL_HAL3ONLY_NOLOCK(ddrval, this, DrawPrimitives2, &this->dp2data);
                        if (ddrval != DDHAL_DRIVER_HANDLED)
                        {
                            D3D_ERR ( "Driver not handled in DrawPrimitives2" );
                            // Need sensible return value in this case,
                            // currently we return whatever the driver stuck in here.
                            goto execute_failed;
                        }
                    } while (dp2data.ddrval == DDERR_WASSTILLDRAWING);

	            // restore right value of dwVertexSize as it is a union with ddrval
                    dp2dataddrval = this->dp2data.ddrval;
#if _WIN32_WINNT >= 0x0501
                    this->dp2data.dwVertexSize = sizeof(D3DTLVERTEX);
#endif

                    // clear this bit in case drawprimitive calls after this
                    this->dp2data.dwFlags &= ~D3DHALDP2_EXECUTEBUFFER;

                    if (dp2dataddrval != DD_OK)
                    {
                        if (dp2dataddrval == D3DERR_COMMAND_UNPARSED)
                        {
                            LPD3DINSTRUCTION lpStart = lpIns;
                            lpIns = (LPD3DINSTRUCTION)(this->dp2data.dwErrorOffset + (LPBYTE)debDesc.lpData);
                            TrackAllStates(this, lpStart, lpIns);
                            break; // Continue parsing
                        }
                        else
                        {
                            D3D_ERR("HAL error in DrawPrimitives2 call from Execute API");
                            ddrval = dp2dataddrval;
                            goto execute_failed;
                        }
                    }
                    else
                    {
                        TrackAllStates(this, lpIns, NULL);
                        goto execute_done;
                    }
                default:
                    D3D_ERR("HAL detected invalid instruction opcode in Execute");
                    goto execute_failed;
                } // switch
            } // if unclipped
            else
            { // Execute Clipped
                switch (lpIns->bOpcode)
                {
                case D3DOP_STATERENDER:
                    // We do not track state. This means GetRenderState needs a DDI to
                    // work. More importantly, state overrides will get ignored. To fix
                    // this, the ParseUnknownCommand function needs to be called by the
                    // driver if it cannot understand the state change value.
                    // This function should examine if the renderstate had an override,
                    // and if so, inform the driver to request the runtime to parse the EB
                    {
                        LPD3DSTATE lpState;
                        DWORD i,j,statek,valuek;
                        lpState = (LPD3DSTATE) (lpIns + 1);
                        for (i = 0,j=0,statek=(DWORD)-1; i < lpIns->wCount; i++)
                        {
                            // This call also calls SetDeviceRenderState which
                            // is not required. But this is an optimization which
                            // can wait till later (if required)
                            if (trackState(this, &lpState[i]))
                                this->SetRenderStateI(lpState[i].drstRenderStateType, lpState[i].dwArg[0]);
                        }
                        NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
                    }
                    break;
                case D3DOP_TRIANGLE:
                    if (lpIns->wCount == 0)
                    {
                        NEXTINSTRUCTION(lpIns, D3DTRIANGLE, lpIns->wCount);
                        break;
                    }
                    Profile(PROF_EXECUTE, D3DPT_TRIANGLELIST, GetVertexType(this));
                    WAIT_FOR_FLIP();
#if DBG
                    if (!validateTriangleFlags(lpIns, (LPD3DTRIANGLE) prim))
                    {
                        ddrval = DDERR_INVALIDPARAMS;
                        goto execute_failed;
                    }
#endif
                    this->D3DStats.dwTrianglesDrawn += lpIns->wCount;
                    D3D_INFO(5, "Emulating D3DOP_TRIANGLE for HAL and clipping");

                    if (this->rstates[D3DRENDERSTATE_ZVISIBLE])
                    {
                        this->iClipStatus &= ~D3DSTATUS_ZNOTVISIBLE;
                    }
                    else
                    {
                        ddrval = D3DFEClipTrianglesHW(this, (LPD3DTRIANGLE)prim, lpIns->wCount);
                        if (ddrval != D3D_OK)
                        {
                            D3D_ERR("D3DFEClipLinesHW failed");
                            goto execute_failed;
                        }
                    }
                    NEXTINSTRUCTION(lpIns, D3DTRIANGLE, lpIns->wCount);
                    break;

                case D3DOP_LINE:

                    if (lpIns->wCount == 0)
                    {
                        NEXTINSTRUCTION(lpIns, D3DLINE, lpIns->wCount);
                        break;
                    }
                    Profile(PROF_EXECUTE, D3DPT_LINELIST, GetVertexType(this));
                    WAIT_FOR_FLIP();

                    D3D_INFO(5, "Emulating D3DOP_LINE for HAL and clipping");
                    this->D3DStats.dwLinesDrawn += lpIns->wCount;

                    if (this->rstates[D3DRENDERSTATE_ZVISIBLE])
                    {
                        this->iClipStatus &= ~D3DSTATUS_ZNOTVISIBLE;
                    }
                    else
                    {
                        ddrval = D3DFEClipLinesHW(this, (LPD3DLINE)prim, lpIns->wCount);
                        if (ddrval != D3D_OK)
                        {
                            D3D_ERR("D3DFEClipLinesHW failed");
                            goto execute_failed;
                        }
                    }
                    NEXTINSTRUCTION(lpIns, D3DLINE, lpIns->wCount);
                    break;

                case D3DOP_POINT:
                    WAIT_FOR_FLIP();

                    Profile(PROF_EXECUTE, D3DPT_POINTLIST, GetVertexType(this));
                    D3D_INFO(5, "Emulating D3DOP_POINT for HAL and clipping");
                    {
                        LPD3DPOINT point = (LPD3DPOINT) prim;
                        int i;
                        for (i = 0; i < lpIns->wCount; i++)
                        {
                            this->D3DStats.dwPointsDrawn += point->wCount;
                            point++;
                        }
                    }
                    if (this->rstates[D3DRENDERSTATE_ZVISIBLE])
                    {
                        this->iClipStatus &= ~D3DSTATUS_ZNOTVISIBLE;
                    }
                    else
                    {
                        ddrval = D3DFEClipPointsHW(this, (LPD3DPOINT)prim, lpIns->wCount);
                        if (ddrval != D3D_OK)
                        {
                            D3D_ERR("D3DFEClipPointsHW failed");
                            goto execute_failed;
                        }
                    }
                    NEXTINSTRUCTION(lpIns, D3DPOINT, lpIns->wCount);
                    break;

                case D3DOP_SPAN:
                    // This case is NOOP since we do not implement spans in DP2 DDI
                    {
                        lpIns = (LPD3DINSTRUCTION)((LPBYTE)lpIns
                            + sizeof(D3DINSTRUCTION)
                            + (lpIns->bSize * lpIns->wCount));
                        break;
                    }
                default:
                    D3D_ERR("HAL detected invalid instruction opcode in Execute");
                    goto execute_failed;
                } // switch
                ClampExtents(this);
            } // Execute Clipped
        } // switch
    } // while

execute_done:

    D3DFE_ConvertExtent(this, &this->rExtents, &lpExData->dsStatus.drExtent);
    lpExData->dsStatus.dwStatus = this->iClipStatus;
    ddrval = D3D_OK;

execute_failed:
    // Restore Command Buffer in case of Unclipped EB
    if ((this->dwFEFlags & D3DFE_TLVERTEX) || (mode == D3DEXECUTE_UNCLIPPED))
    {
        this->dp2data.lpDDCommands = ((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSCB1)->lpLcl;
        this->dp2data.dwCommandOffset = 0;
        this->dp2data.dwCommandLength = 0;
            this->dp2data.dwFlags |= D3DHALDP2_SWAPCOMMANDBUFFER;
    }
    this->dwFlags &= ~D3DPV_WITHINPRIMITIVE;
    UNLOCK_HAL(this);
    return ddrval;
#undef WAIT_FOR_FLIP
}
//---------------------------------------------------------------------
HRESULT D3DHAL_ExecutePick(LPDIRECT3DDEVICEI lpDevI,
                           LPD3DI_PICKDATA      lpPickData)
{
    LPD3DI_EXECUTEDATA  lpExData = lpPickData->exe;
    D3DRECT*    pick_rect = &lpPickData->pick;
    D3DINSTRUCTION* lpIns;
    D3DEXECUTEBUFFERDESC debDesc;
    LPBYTE prim;
    LPD3DDEVICEDESC_V1 halCaps = &lpDevI->lpD3DHALGlobalDriverData->hwCaps;
    BOOL bMustDoTransform = halCaps->dwFlags & D3DDD_TRANSFORMCAPS;
    D3DI_PICKDATA* pdata = &lpDevI->pick_data;
    LPDIRECTDRAWSURFACE lpDDExeBuf;
    HRESULT ddrval;
    D3DFE_TRANSFORM *transform = &lpDevI->transform;
    DWORD i;
    LPD3DSTATE lpState;

    D3D_INFO(3, "ExecutePick called.%d");

    /*
    * Clear all the old pick records.
    */

    pdata->pick_count = 0;

    if (pdata->records)
        D3DFree(pdata->records);

    pdata->records = NULL;

    //Flush the cached states
    ddrval = lpDevI->FlushStates();
    if (ddrval != D3D_OK)
    {
        D3D_ERR("Error trying to render batched commands in D3DHAL_ExecutePick");
        return ddrval;
    }

    // Grow internal buffers to hold vertices
    ddrval = lpDevI->TLVbuf.CheckAndGrow
        (lpDevI, lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwMaxVertexCount << 5);
    if (ddrval != D3D_OK)
    {
        D3D_ERR("Failed to check and grow TLVbuf in ExecutePick");
        return ddrval;
    }
    ddrval = lpDevI->HVbuf.CheckAndGrow
        (lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwMaxVertexCount*sizeof(D3DFE_CLIPCODE));
    if (ddrval != D3D_OK)
    {
        D3D_ERR("Failed to check and grow HVbuf in ExecutePick");
        return ddrval;
    }
    /*
    * Execute the buffer through the HAL
    */
    D3D_INFO(4, "Locking execute buffer for execution");
    memset(&debDesc, 0, sizeof(D3DEXECUTEBUFFERDESC));
    debDesc.dwSize = sizeof(D3DEXECUTEBUFFERDESC);

    ddrval = D3DHAL_LockBuffer(lpDevI, lpExData->dwHandle, &debDesc, &lpDDExeBuf);
    CHECK(ddrval, "Lock of execute buffer for execution failed");

    // Modify driver funcs for EB pick case
    PFN_DRAWPRIM pfnOldDrawPrim = lpDevI->pfnDrawPrim;
    PFN_DRAWPRIM pfnOldDrawIndexedPrim = lpDevI->pfnDrawIndexedPrim;
    lpDevI->pfnDrawPrim = &DIRECT3DDEVICEI::PickExeBuf;
    lpDevI->pfnDrawIndexedPrim = &DIRECT3DDEVICEI::PickExeBuf;

    /*
    * Calculate the instruction that could not be handled.
    */
    lpIns = (LPD3DINSTRUCTION)((LPBYTE)debDesc.lpData + lpExData->dwInstructionOffset);

    lpDevI->lpbClipIns_base = (unsigned char*)lpIns;

    while (lpIns->bOpcode != D3DOP_EXIT)
    {
        prim = (LPBYTE)(lpIns + 1);

        /*
        * Parse the instruction, passing rasterisation calls to HAL.
        */
        switch (lpIns->bOpcode)
        {
        /*
        * Instructions that must be emulated.
            */
        case D3DOP_MATRIXLOAD:
            D3D_INFO(5, "Emulating D3DOP_MATRIXLOAD for HAL");
            ddrval = D3DHELInst_D3DOP_MATRIXLOAD(lpDevI,
                lpIns->wCount,
                (LPD3DMATRIXLOAD)prim);
            if (ddrval != D3D_OK)
            {
                D3D_ERR("Emulated D3DOP_MATRIXLOAD failed.");
                goto executePick_failed;
            }
            NEXTINSTRUCTION(lpIns, D3DMATRIXLOAD, lpIns->wCount);
            break;
        case D3DOP_MATRIXMULTIPLY:
            D3D_INFO(5, "Emulating D3DOP_MATRIXMULTIPLY for HAL");
            ddrval = D3DHELInst_D3DOP_MATRIXMULTIPLY(lpDevI,
                lpIns->wCount,
                (LPD3DMATRIXMULTIPLY)prim);
            if (ddrval != D3D_OK)
            {
                D3D_ERR("Emulated D3DOP_MATRIXMULTIPLY failed.");
                goto executePick_failed;
            }
            NEXTINSTRUCTION(lpIns, D3DMATRIXMULTIPLY, lpIns->wCount);
            break;
        case D3DOP_STATERENDER:
            lpState = (LPD3DSTATE) (lpIns + 1);
            {
                D3DHAL_RENDERSTATEDATA stateData;
                DWORD j,statek,valuek;
                stateData.dwhContext = lpDevI->dwhContext;
                stateData.lpExeBuf = lpDDExeBuf;
                stateData.dwOffset = (DWORD)((ULONG_PTR)lpIns - (ULONG_PTR)debDesc.lpData +
                    sizeof(D3DINSTRUCTION));
                stateData.dwCount = lpIns->wCount;
                CALL_HALONLY(ddrval, lpDevI, RenderState, &stateData);
                if (stateData.ddrval != DD_OK)
                {
                    D3D_ERR("HAL error in RenderState call from ExecutePick API");
                    ddrval = stateData.ddrval;
                    goto executePick_failed;
                }
            }
            for (i = 0; i < lpIns->wCount; i++)
            {
                trackState(lpDevI, &lpState[i]);
            }
            NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
            break;

        case D3DOP_STATETRANSFORM:
            D3D_INFO(5, "Emulating D3DOP_STATETRANSFORM for HAL");
            ddrval = D3DHELInst_D3DOP_STATETRANSFORM(lpDevI, lpIns->wCount,
                (LPD3DSTATE)prim);
            if (ddrval != D3D_OK)
            {
                D3D_ERR("Emulated D3DOP_STATETRANSFORM failed.");
                goto executePick_failed;
            }
            NEXTINSTRUCTION(lpIns, D3DSTATE, lpIns->wCount);
            break;
            /*
            * Operations that require clipping.
            */
        case D3DOP_PROCESSVERTICES:
            D3D_INFO(5, "Emulating D3DOP_PROCESSVERTICES for HAL and clipping");
            ddrval = D3DHELInst_D3DOP_TRANSFORM
                (lpDevI, lpIns->wCount, (LPD3DPROCESSVERTICES)prim, &debDesc);
            if (ddrval != D3D_OK)
            {
                D3D_ERR("Emulated D3DOP_PROCESSVERTICES failed.");
                goto executePick_failed;
            }
            NEXTINSTRUCTION(lpIns, D3DPROCESSVERTICES, lpIns->wCount);
            break;
        case D3DOP_TRIANGLE:
            if (!lpDevI->rstates[D3DRENDERSTATE_ZVISIBLE])
            {
                D3D_INFO(5, "Picking D3DOP_TRIANGLE for HAL and clipping");
                lpDevI->pick_data.pick = *pick_rect;

                HRESULT ret;
                if (lpDevI->dwFEFlags & D3DFE_TLVERTEX)
                {
                    lpDevI->primType = D3DPT_TRIANGLELIST;
                    lpDevI->dwNumIndices = lpIns->wCount * 3;
                    lpDevI->dwNumPrimitives = lpIns->wCount;
                    lpDevI->lpvOut = lpDevI->TLVbuf.GetAddress();
                    lpDevI->lpwIndices = (WORD*)prim;
                    ret = lpDevI->PickExeBuf();
                }
                else
                    ret = GenPickTriangles(lpDevI, (LPD3DTRIANGLE)prim, lpIns->wCount);

                if (ret != D3D_OK)
                    goto executePick_failed;
            }
            NEXTINSTRUCTION(lpIns, D3DTRIANGLE, lpIns->wCount);
            break;
        case D3DOP_SETSTATUS:
            {
                LPD3DSTATUS status = (LPD3DSTATUS)prim;
                if (status->dwFlags & D3DSETSTATUS_STATUS)
                    lpDevI->iClipStatus = status->dwStatus;
                if (status->dwFlags & D3DSETSTATUS_EXTENTS)
                {
                    lpDevI->rExtents.x1 = D3DVAL(status->drExtent.x1);
                    lpDevI->rExtents.y1 = D3DVAL(status->drExtent.y1);
                    lpDevI->rExtents.x2 = D3DVAL(status->drExtent.x2);
                    lpDevI->rExtents.y2 = D3DVAL(status->drExtent.y2);
                }
            }
            NEXTINSTRUCTION(lpIns, D3DSTATUS, lpIns->wCount);
            break;
        case D3DOP_BRANCHFORWARD:
            {
                D3DBRANCH* branch = (D3DBRANCH*)prim;
                LPBYTE target;
                BOOL isTaken = FALSE;
                D3D_INFO(5, "Emulating D3DOP_BRANCHFORWARD for HAL.");
                if (branch->bNegate)
                {
                    if ((branch->dwMask & lpDevI->iClipStatus) != branch->dwValue)
                    {
                        D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: Taking forward branch");
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        } else
                            goto early_out;
                    }
                }
                else
                {
                    if ((branch->dwMask & lpDevI->iClipStatus) == branch->dwValue)
                    {
                        D3D_INFO(5, "D3DOP_BRANCHFORWARD instruction: Taking forward branch");
                        if (branch->dwOffset)
                        {
                            isTaken = TRUE;
                            target = (LPBYTE)lpIns + branch->dwOffset;
                        }
                        else
                            goto early_out;
                    }
                }
                if (isTaken)
                    lpIns = (LPD3DINSTRUCTION)target;
                else
                {
                    NEXTINSTRUCTION(lpIns, D3DBRANCH, lpIns->wCount);
                }
            }
            break;

        default:
            D3D_INFO(4, "Skipping instruction %d in ExecutePick",
                lpIns->bOpcode);
            lpIns = (LPD3DINSTRUCTION)((LPBYTE)lpIns +
                sizeof(D3DINSTRUCTION) +
                (lpIns->wCount * lpIns->bSize));
            break;
        }
    }
early_out:
    D3DHAL_UnlockBuffer(lpDevI, lpExData->dwHandle);
    D3DFE_ConvertExtent(lpDevI, &lpDevI->rExtents, &lpExData->dsStatus.drExtent);
    lpExData->dsStatus.dwStatus = lpDevI->iClipStatus;
    // Restore driver funcs
    lpDevI->pfnDrawIndexedPrim = pfnOldDrawIndexedPrim;
    lpDevI->pfnDrawPrim = pfnOldDrawPrim;

    return (D3D_OK);

executePick_failed:
    D3D_ERR("ExecutePick Failed.");
    D3DHAL_UnlockBuffer(lpDevI, lpExData->dwHandle);
    // Restore driver funcs
    lpDevI->pfnDrawIndexedPrim = pfnOldDrawIndexedPrim;
    lpDevI->pfnDrawPrim = pfnOldDrawPrim;
    return ddrval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\genpick.cpp ===
/*
 *
 * Copyright (c) Microsoft Corp. 1997
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#include "pch.cpp"
#pragma hdrstop

#include "commdrv.hpp"


#define FILLSPAN(left, right, zleft, zstep, px, result)                 \
    do {                                                                \
        int x = FXTOI(left);                                            \
        int w = FXTOI(right) - x;                                       \
        if (w > 0) {                                                    \
            if ((x <= px) && (px < (x + w))) {                          \
                int t = px - x;                                         \
                int z = zleft + t * zstep;                              \
                *result = FXTOVAL(z >> 8);                              \
                return TRUE;                                            \
            }                                                           \
        }                                                               \
    } while (0)

int ZTFill1(int xl, int dxl,
                   int xr, int dxr,
                   int zl, int dzl, int dz,
                   int h, int y, int px, int py, float* result)
{

    while (1) {
        h--;
        if (y++ == py)
            FILLSPAN(xl, xr, zl, dz, px, result);
        if (!h) return FALSE;
        xl += dxl;
        xr += dxr;
        zl += dzl;
    }
}

int ZTFill2( int xl1, int dxl1,
                    int xl2, int dxl2,
                    int xr1, int dxr1,
                    int xr2, int dxr2,
                    int zl,
                    int dzl1,
                    int dzl2,
                    int dz,
                    int h1, int h2,
                    int y, int px, int py, float* result)
{
    while (h1) {
        h1--;
        if (y++ == py)
            FILLSPAN(xl1, xr1, zl, dz, px, result);
        xl1 += dxl1;
        xr1 += dxr1;
        zl += dzl1;
    }
    while (1) {
        h2--;
        if (y++ == py)
            FILLSPAN(xl2, xr2, zl, dz, px, result);
        if (!h2) return FALSE;
        xl2 += dxl2;
        xr2 += dxr2;
        zl += dzl2;
    }
}

int GenPickTriangle(LPDIRECT3DDEVICEI lpDevI,
                    D3DTLVERTEX*   base,
                    D3DTRIANGLE*   tri,
                    D3DRECT*   rect,
                    D3DVALUE*  result)
{
    int h1, h2, h3;
    float h1s, h3s;
    int y, y1, y2, y3;
    D3DTLVERTEX *p1, *p2, *p3;
    float xl, xr, xm, ml, ml2, mr, mr2;
    float zl, zr, zm, mz, mz2, zstep;
    float dx;

    int px = rect->x1;
    int py = rect->y1;

    p1 = base + tri->v1;
    p2 = base + tri->v2;
    p3 = base + tri->v3;

    y1 = VALTOI(p1->sy);
    y2 = VALTOI(p2->sy);
    y3 = VALTOI(p3->sy);

    if (y1 == y2 && y2 == y3)
        return FALSE;
    {
        int y;
        D3DTLVERTEX *p;

        /*
         * Work out which vertex is topmost.
         */
        if (y2 <= y1 && y2 <= y3) {
            y = y1;
            y1 = y2;
            y2 = y3;
            y3 = y;
            p = p1;
            p1 = p2;
            p2 = p3;
            p3 = p;
        } else if (y3 <= y1 && y3 <= y2) {
            y = y1;
            y1 = y3;
            y3 = y2;
            y2 = y;
            p = p1;
            p1 = p3;
            p3 = p2;
            p2 = p;
        }
    }

    y = y1;

    if (py < y)
        return FALSE;

    if (py >= y2 && py >= y3)
        return FALSE;

    h1 = y2 - y1;
    h2 = y3 - y2;
    h3 = y3 - y1;

    if (h1 == 0) {
        xl = p1->sx;
        xr = p2->sx;
        dx = xr - xl;
        if (dx <= 0)
            return FALSE;
        zl = p1->sz;
        zr = p2->sz;
        zstep = RLDDICheckDiv16(zr - zl, dx);
        xm = p3->sx;
        ml = (xm - xl) / h2;
        mr = (xm - xr) / h2;
        mz = ((p3->sz) - zl) / h2;

        if (ZTFill1(VALTOFX(xl), VALTOFX(ml), VALTOFX(xr), VALTOFX(mr),
                    VALTOFX24(zl), VALTOFX24(mz), VALTOFX24(zstep), h2,
                    y, px, py, result)) {
            return TRUE;
        }
    } else if (h2 == 0) {
        xl = p3->sx;
        xr = p2->sx;
        dx = xr - xl;
        if (dx <= 0)
            return FALSE;
        zl = p3->sz;
        zr = p2->sz;
        zm = p1->sz;
        zstep = RLDDICheckDiv16(zr - zl, dx);
        if (h1 == 1)
            ;
        else {
            xm = p1->sx;
            ml = (xl - xm) / h1;
            mr = (xr - xm) / h1;
            mz = (zl - zm) / h1;

            if (ZTFill1(VALTOFX(xm), VALTOFX(ml), VALTOFX(xm), VALTOFX(mr),
                        VALTOFX24(zm), VALTOFX24(mz), VALTOFX24(zstep), h1,
                        y, px, py, result)) {
                return TRUE;
            }
        }
    } else if (h3 == 0) {
        xl = p3->sx;
        xr = p1->sx;
        dx = xr - xl;
        if (dx <= 0)
            return FALSE;
        zl = p3->sz;
        zr = p1->sz;
        zstep = RLDDICheckDiv16(zr - zl, dx);
        xm = p2->sx;
        ml = (xm - xl) / h1;
        mr = (xm - xr) / h1;
        mz = ((p2->sz)- zl) / h1;
        if (ZTFill1(VALTOFX(xl), VALTOFX(ml), VALTOFX(xr), VALTOFX(mr),
                    VALTOFX24(zl), VALTOFX24(mz), VALTOFX24(zstep), h1,
                    y, px, py, result)) {
            return TRUE;
        }
    } else if (h1 < h3) {
        float denom;
        float dx1, dx2;

        xl = p3->sx;
        xr = p2->sx;
        xm = p1->sx;

        dx1 = xr - xm;
        dx2 = xl - xm;

        /*
         * Make a stab at guessing the sign of the area for quick backface
         * culling.  Note that h1 and h3 are positive.
         */
        if (dx1 < 0 && dx2 > 0)
            return FALSE;

        /*
         * This uses Mul24 to get an 8 bit precision result otherwise
         * we can get the wrong result for large triangles.
         */
        denom = RLDDIFMul24(dx1, ITOVAL(h3)) - RLDDIFMul24(dx2, ITOVAL(h1));

        if (denom <= 0)
            return FALSE;

        h1s = RLDDIFDiv8(ITOVAL(h1), denom);
        h3s = RLDDIFDiv8(ITOVAL(h3), denom);

        zl = p3->sz;
        zr = p2->sz;
        zm = p1->sz;
        zstep = RLDDIFMul16(zr - zm, h3s) - RLDDIFMul16(zl - zm, h1s);

        ml = (xl - xm) / h3;
        mz = (zl - zm) / h3;
        mr = (xr - xm) / h1;
        mr2 = (xl - xr) / h2;

        if (ZTFill2(VALTOFX(xm), VALTOFX(ml), VALTOFX(xm + h1*ml), VALTOFX(ml),
                    VALTOFX(xm), VALTOFX(mr), VALTOFX(xr), VALTOFX(mr2),
                    VALTOFX24(zm), VALTOFX24(mz), VALTOFX24(mz), VALTOFX24(zstep),
                    h1, h2, y, px, py, result)) {
            return TRUE;
        }
    } else {
        float denom;
        float dx1, dx2;

        xl = p3->sx;
        xr = p2->sx;
        xm = p1->sx;

        dx1 = xr - xm;
        dx2 = xl - xm;

        /*
         * Make a stab at guessing the sign of the area for quick backface
         * culling.  Note that h1 and h3 are positive.
         */
        if (dx1 < 0 && dx2 > 0)
            return FALSE;

        /*
         * This uses Mul24 to get an 8 bit precision result otherwise
         * we can get the wrong result for large triangles.
         */
        denom = RLDDIFMul24(dx1, ITOVAL(h3)) - RLDDIFMul24(dx2, ITOVAL(h1));

        if (denom <= 0)
            return FALSE;

        h1s = RLDDIFDiv8(ITOVAL(h1), denom);
        h3s = RLDDIFDiv8(ITOVAL(h3), denom);

        zl = p3->sz;
        zr = p2->sz;
        zm = p1->sz;
        zstep = RLDDIFMul16(zr - zm, h3s) - RLDDIFMul16(zl - zm, h1s);

        ml = (xl - xm) / h3;
        mz = (zl - zm) / h3;
        mr = (xr - xm) / h1;
        h2 = -h2;
        ml2 = (xr - xl) / h2;
        mz2 = (zr - zl) / h2;

        if (ZTFill2(VALTOFX(xm), VALTOFX(ml), VALTOFX(xl), VALTOFX(ml2),
                    VALTOFX(xm), VALTOFX(mr), VALTOFX(xm + h3*mr), VALTOFX(mr),
                    VALTOFX24(zm), VALTOFX24(mz), VALTOFX24(mz2), VALTOFX24(zstep),
                    h3, h2, y, px, py, result)) {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT GenAddPickRecord(LPDIRECT3DDEVICEI lpDevI,
                         D3DOPCODE op, int offset, float result)
{
    D3DI_PICKDATA* pdata = &lpDevI->pick_data;

    int i;

    i = pdata->pick_count++;

    if (D3DRealloc((void**) &pdata->records, pdata->pick_count *
                   sizeof(D3DPICKRECORD))) {
        return (DDERR_OUTOFMEMORY);
    }

    pdata->records[i].bOpcode = op;
    pdata->records[i].dwOffset = offset;
    pdata->records[i].dvZ = result;
    return (D3D_OK);
}

HRESULT GenGetPickRecords(LPDIRECT3DDEVICEI lpDevI, D3DI_PICKDATA* pdata)
{
    D3DI_PICKDATA* drv_pdata = &lpDevI->pick_data;
    int picked_count;
    int picked_size;

    picked_count = drv_pdata->pick_count;
    picked_size = picked_count * sizeof(D3DPICKRECORD);

    if (pdata->records == NULL) {
        pdata->pick_count = drv_pdata->pick_count;
    } else {
        memcpy((char*)pdata->records, (char*)drv_pdata->records, picked_size);
        pdata->pick_count = drv_pdata->pick_count;
    }

    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\halmat.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   halmat.c
 *  Content:    Direct3D HAL material handler
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: halmat.c,v 1.1 1995/11/21 15:12:40 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   07/11/95   stevela Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

extern HRESULT SetMaterial(LPDIRECT3DDEVICEI lpDevI, D3DMATERIALHANDLE hMat);

HRESULT
D3DHAL_MaterialCreate(LPDIRECT3DDEVICEI lpDevI,
                      LPD3DMATERIALHANDLE lphMat,
                      LPD3DMATERIAL lpMat)
{
    LPD3DFE_MATERIAL lpNewMat;

    D3DMalloc((void**)&lpNewMat, sizeof(D3DFE_MATERIAL));
    if (!lpNewMat)
        return D3DERR_MATERIAL_CREATE_FAILED;
    lpNewMat->mat = *lpMat;
    LIST_INSERT_ROOT(&lpDevI->materials, lpNewMat, link);
    *lphMat = (DWORD)((ULONG_PTR)lpNewMat);

    //  continue for ramp only - need to munge ramp handles and call ramp
    //  service with material info
    return CallRampService(lpDevI, RAMP_SERVICE_CREATEMAT,
                   (ULONG_PTR) lpNewMat, 0);
}

HRESULT
D3DHAL_MaterialDestroy(LPDIRECT3DDEVICEI lpDevI, D3DMATERIALHANDLE hMat)
{
    HRESULT hr;

    if(hMat==0)
    {
        return D3DERR_MATERIAL_DESTROY_FAILED;
    }

    if (lpDevI->lighting.hMat == hMat)
        lpDevI->lighting.hMat = 0;

    hr = CallRampService(lpDevI, RAMP_SERVICE_DESTORYMAT, (DWORD) hMat, 0);

    LPD3DFE_MATERIAL lpMat = (LPD3DFE_MATERIAL)ULongToPtr(hMat);
    LIST_DELETE(lpMat, link);
    D3DFree(lpMat);
    return (hr);
}

HRESULT
D3DHAL_MaterialSetData(LPDIRECT3DDEVICEI lpDevI,
                       D3DMATERIALHANDLE hMat,
                       LPD3DMATERIAL lpMat)
{
    if(hMat==0)
        return D3DERR_MATERIAL_SETDATA_FAILED;

    LPD3DFE_MATERIAL mat = (LPD3DFE_MATERIAL)ULongToPtr(hMat);
    mat->mat = *lpMat;
    if (hMat == lpDevI->lighting.hMat)
        SetMaterial(lpDevI, hMat);

    //  continue for ramp only - need to munge ramp handles and call ramp
    //  service with material info
    if(lpDevI->pfnRampService != NULL)
        return CallRampService(lpDevI, RAMP_SERVICE_SETMATDATA,
                                    (ULONG_PTR) hMat, 0, TRUE);
    else
        return D3D_OK;
}

HRESULT
D3DHAL_MaterialGetData(LPDIRECT3DDEVICEI lpDevI,
                       D3DMATERIALHANDLE hMat,
                       LPD3DMATERIAL lpMat)
{

    if(hMat==0)
    {
        memset(lpMat,0,sizeof(D3DMATERIAL));
        return D3DERR_MATERIAL_GETDATA_FAILED;
    }

    LPD3DFE_MATERIAL mat = (LPD3DFE_MATERIAL)ULongToPtr(hMat);
    *lpMat = mat->mat;
    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\halscene.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   halscene.c
 *  Content:    Direct3D HAL scene capture
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   07/12/95   stevela Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

HRESULT D3DHAL_SceneCapture(LPDIRECT3DDEVICEI lpDevI,
                            BOOL bState)
{
    D3DHAL_SCENECAPTUREDATA data;
    HRESULT ret;
    
    if (IS_DX7HAL_DEVICE(lpDevI))
    {
        return lpDevI->SetRenderStateI((D3DRENDERSTATETYPE)D3DRENDERSTATE_SCENECAPTURE, bState);
    }

    ret = CallRampService(lpDevI, RAMP_SERVICE_SCENE_CAPTURE, bState, lpDevI);
    if (ret != DD_OK)
    {
        return ret;
    }

    if (!lpDevI->lpD3DHALCallbacks->SceneCapture) {
        return (D3D_OK);
    }

    D3D_INFO(6, "SceneCapture, setting %d dwhContext = %d",
             bState, lpDevI->dwhContext);

    memset(&data, 0, sizeof(D3DHAL_SCENECAPTUREDATA));
    data.dwhContext = lpDevI->dwhContext;
    data.dwFlag = bState ? D3DHAL_SCENE_CAPTURE_START : D3DHAL_SCENE_CAPTURE_END;

    CALL_HALONLY(ret, lpDevI, SceneCapture, &data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
        D3D_ERR("HAL failed to handle SceneCapture");
        return (data.ddrval);
    }

    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\init.c ===
#define INITGUID

#include <objbase.h>
#include <d3dp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\hwprov.cpp ===
/*
 *
 * Copyright (c) Microsoft Corp. 1997
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#include "pch.cpp"
#pragma hdrstop
#include <hwprov.h>

#define nullPrimCaps {                          \
    sizeof(D3DPRIMCAPS), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0          \
}                                               \

#define nullLightCaps {                         \
    sizeof(D3DLIGHTINGCAPS), 0, 0, 0 \
}

#define transformCaps { sizeof(D3DTRANSFORMCAPS), D3DTRANSFORMCAPS_CLIP }

#define THIS_MODEL D3DLIGHTINGMODEL_RGB

#define lightingCaps {                                                  \
        sizeof(D3DLIGHTINGCAPS),                                        \
        (D3DLIGHTCAPS_POINT                                             \
         | D3DLIGHTCAPS_SPOT                                            \
         | D3DLIGHTCAPS_DIRECTIONAL                                     \
         | D3DLIGHTCAPS_PARALLELPOINT),                                 \
        THIS_MODEL,                     /* dwLightingModel */           \
        0,                              /* dwNumLights (infinite) */    \
}

/*
 * Software Driver caps
 */

static D3DDEVICEDESC devDesc =
{
    sizeof(D3DDEVICEDESC),      /* dwSize */
    D3DDD_COLORMODEL |          /* dwFlags */
    D3DDD_DEVCAPS |
    D3DDD_TRANSFORMCAPS |
    D3DDD_LIGHTINGCAPS |
    D3DDD_BCLIPPING,
    0,                          /* dcmColorModel */
    D3DDEVCAPS_FLOATTLVERTEX,   /* devCaps */
    transformCaps,              /* dtcTransformCaps */
    TRUE,                       /* bClipping */
    lightingCaps,               /* dlcLightingCaps */
    nullPrimCaps,               /* lineCaps */
    nullPrimCaps,               /* triCaps */
    0,                          /* dwDeviceRenderBitDepth */
    0,                          /* dwDeviceZBufferBitDepth */
    0,                          /* dwMaxBufferSize */
    0                           /* dwMaxVertexCount */
};

//----------------------------------------------------------------------------
//
// HwHalProvider::QueryInterface
//
// Internal interface, no need to implement.
//
//----------------------------------------------------------------------------

STDMETHODIMP HwHalProvider::QueryInterface(THIS_ REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::AddRef
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) HwHalProvider::AddRef(THIS)
{
    return 1;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::Release
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) HwHalProvider::Release(THIS)
{
    return 0;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::GetCaps
//
// Returns the HAL caps.
//
//----------------------------------------------------------------------------

STDMETHODIMP
HwHalProvider::GetCaps(LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion)
{
    D3DDeviceDescConvert(pHwDesc,
                         &pDdGbl->lpD3DGlobalDriverData->hwCaps,
                         pDdGbl->lpD3DExtendedCaps);
    if (pHwDesc->dwMaxVertexCount == 0)
    {
        D3D_WARN(2, "Setting dwMaxVertexCount to %d", D3DHAL_DEFAULT_TL_NUM);
        pHwDesc->dwMaxVertexCount = D3DHAL_DEFAULT_TL_NUM;
    }
    else
    {
        D3D_INFO(2, "Hal driver has max vertices of %d", pHwDesc->dwMaxVertexCount);
    }

    *pHelDesc = devDesc;

    // Force HEL's vertex and buffer size to the HAL's.
    D3D_WARN(1, "Forcing HEL's vertex and buffer size to the HAL's v %d b %d",
        pHwDesc->dwMaxVertexCount, pHwDesc->dwMaxBufferSize);
    pHelDesc->dwMaxVertexCount = pHwDesc->dwMaxVertexCount;
    pHelDesc->dwMaxBufferSize = pHwDesc->dwMaxBufferSize;

    // Set D3DPRASTERCAPS_WFOG, texture op caps and texture stage caps
    // for legacy hal drivers off device3.
    LPD3DHAL_CALLBACKS3 lpD3DHALCallbacks3 =
        (LPD3DHAL_CALLBACKS3)pDdGbl->lpD3DHALCallbacks3;
    if (dwVersion >= 3 &&
        (lpD3DHALCallbacks3 == NULL || lpD3DHALCallbacks3->DrawPrimitives2 == NULL))
    {
        pHwDesc->dpcTriCaps.dwRasterCaps |= D3DPRASTERCAPS_WFOG;
        D3D_INFO(2, "Setting D3DPRASTERCAPS_WFOG for legacy HAL driver off Device3");

        pHwDesc->dwMaxAnisotropy = 1;
        pHwDesc->wMaxTextureBlendStages = 1;
        pHwDesc->wMaxSimultaneousTextures = 1;
        D3D_INFO(2, "Setting texture stage state info for legacy HAL driver off Device3");


        pHwDesc->dwTextureOpCaps = D3DTEXOPCAPS_DISABLE;
        if ((pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_DECAL) ||
            (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_COPY))
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_SELECTARG1;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_MODULATE) ||
            (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_MODULATEALPHA))
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_MODULATE;
        }
        if (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_ADD)
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_ADD;
        }
        if (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_DECALALPHA)
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_BLENDTEXTUREALPHA;
        }
        D3D_INFO(2, "Setting textureop caps for legacy HAL driver off Device3");

        // map texture filter operations to DX6 set
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_NEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPNEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPNEAREST))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MINFPOINT;
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MAGFPOINT;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEAR) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPLINEAR) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPLINEAR))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MINFLINEAR;
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MAGFLINEAR;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPNEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPLINEAR))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MIPFPOINT;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPNEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPLINEAR))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MIPFLINEAR;
        }
        D3D_INFO(2, "Setting texturefilter caps for legacy HAL driver off Device3");
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::GetCallbacks
//
// Returns the HAL callbacks in the given DDraw global.
//
//----------------------------------------------------------------------------

STDMETHODIMP
HwHalProvider::GetInterface(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion)
{
    pInterfaceData->pGlobalData = pDdGbl->lpD3DGlobalDriverData;
    pInterfaceData->pExtCaps = pDdGbl->lpD3DExtendedCaps;
    pInterfaceData->pCallbacks  = pDdGbl->lpD3DHALCallbacks;
    pInterfaceData->pCallbacks2 = pDdGbl->lpD3DHALCallbacks2;

    pInterfaceData->pCallbacks3 = pDdGbl->lpD3DHALCallbacks3;
    pInterfaceData->pfnRampService = NULL;

    return S_OK;
}

//----------------------------------------------------------------------------
//
// GetHwHalProvider
//
// Returns the hardware HAL provider.
//
//----------------------------------------------------------------------------

static HwHalProvider g_HwHalProvider;

STDAPI
GetHwHalProvider(REFIID riid, IHalProvider **ppHalProvider, HINSTANCE *phDll,  LPDDRAWI_DIRECTDRAW_GBL pDdGbl)
{
    *phDll = NULL;
    if (IsEqualIID(riid, IID_IDirect3DHALDevice) && D3DI_isHALValid(pDdGbl->lpD3DHALCallbacks))
    {
        *ppHalProvider = &g_HwHalProvider;
    }
    else
    {
        *ppHalProvider = NULL;
        return E_NOINTERFACE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\halstate.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   halstate.c
 *  Content:    Direct3D HAL pipeline state management
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   18/12/95   stevela Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

HRESULT 
D3DHAL_GetState(LPDIRECT3DDEVICEI lpDevI, DWORD dwWhich, LPD3DSTATE lpState)
{
    LPD3DHAL_GLOBALDRIVERDATA gdd = lpDevI->lpD3DHALGlobalDriverData;
    D3DHAL_GETSTATEDATA data;
    HRESULT ret;

    D3D_INFO(6, "GetState, getting state dwhContext = %d", lpDevI->dwhContext);

    memset(&data, 0, sizeof(D3DHAL_GETSTATEDATA));
    data.dwhContext = lpDevI->dwhContext;
    data.dwWhich = dwWhich;
    data.ddState = *lpState;

    if (dwWhich == D3DHALSTATE_GET_RENDER ||
        (dwWhich == D3DHALSTATE_GET_TRANSFORM
         && (gdd->hwCaps.dwFlags & D3DDD_TRANSFORMCAPS)) ||
        (dwWhich == D3DHALSTATE_GET_LIGHT
         && (gdd->hwCaps.dwFlags & D3DDD_LIGHTINGCAPS))) 
    {
        CALL_HALONLY(ret, lpDevI, GetState, &data);
        if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) 
        {
            D3D_ERR("HAL failed to handle GetState");
            return (DDERR_GENERIC);
        }
    } 
    else 
    {
        switch (data.dwWhich) 
        {
        case D3DHALSTATE_GET_RENDER:
            D3D_ERR("HEL called for D3DHALSTATE_GET_RENDER");
            return (DDERR_INVALIDPARAMS);

        case D3DHALSTATE_GET_TRANSFORM:
            D3D_INFO(3, "GetState called for transform");
            switch (data.ddState.dtstTransformStateType) 
            {
            case D3DTRANSFORMSTATE_WORLD:
                data.ddState.dwArg[0] = lpDevI->transform.hWorld;
                break;
            case D3DTRANSFORMSTATE_VIEW:
                data.ddState.dwArg[0] = lpDevI->transform.hView;
                break;
            case D3DTRANSFORMSTATE_PROJECTION:
                data.ddState.dwArg[0] = lpDevI->transform.hProj;
                break;
            default:
                D3D_ERR("Unknown GetState found");
                return (DDERR_GENERIC);
            }
            break;
        case D3DHALSTATE_GET_LIGHT:
            D3D_INFO(3, "GetState called for lighting");
            switch (data.ddState.dlstLightStateType) 
            {
            case D3DLIGHTSTATE_MATERIAL:
                data.ddState.dwArg[0] = lpDevI->lighting.hMat;
                break;
            case D3DLIGHTSTATE_AMBIENT:
                data.ddState.dwArg[0] = 
                    RGB_MAKE((int)lpDevI->lighting.ambient_red, 
                             (int)lpDevI->lighting.ambient_green, 
                             (int)lpDevI->lighting.ambient_blue);
                break;
            case D3DLIGHTSTATE_COLORMODEL:
#pragma message("XXX - D3DLIGHTSTATE_COLORMODEL in HEL GetState not implemented.")
                break;
            default:
                D3D_ERR("Unknown GetState found");
                return (DDERR_GENERIC);
            }
        default:
            D3D_ERR("Unknown GetState found");
            return (DDERR_GENERIC);
        }
    }

    *lpState = data.ddState;
    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\haltex.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   haltex.c
 *  Content:    Direct3D HAL texture handling
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: haltex.c,v 1.1 1995/11/21 15:12:43 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   07/11/95   stevela Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Texture functionality is not emulated.
 */

HRESULT D3DHAL_TextureCreate(LPDIRECT3DDEVICEI lpDevI,
                             LPD3DTEXTUREHANDLE lphTex,
                             LPDIRECTDRAWSURFACE lpDDS)
{
    if (IS_DX7HAL_DEVICE(lpDevI))
    {
        *lphTex = 
            ((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl->lpSurfMore->dwSurfaceHandle;    
    }
    else
    {
        D3DHAL_TEXTURECREATEDATA data;
        HRESULT ret;

        if (!lpDevI->lpD3DHALCallbacks->TextureCreate) {
            D3D_ERR("TextureCreate called, but no texture support.");
            return (D3DERR_TEXTURE_NO_SUPPORT);
        }

        memset(&data, 0, sizeof(D3DHAL_TEXTURECREATEDATA));
        data.dwhContext = lpDevI->dwhContext;
        data.lpDDS = lpDDS;

        D3D_INFO(6, "TextureCreate, creating texture dwhContext = %08lx, lpDDS = %08lx",
            data.dwhContext, data.lpDDS);

        CALL_HALONLY(ret, lpDevI, TextureCreate, &data);
        if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
            D3D_ERR("HAL failed to handle TextureCreate");
            return (D3DERR_TEXTURE_CREATE_FAILED);
        }
        *lphTex = data.dwHandle;
    }

    D3D_INFO(6, "TextureCreate, created texture hTex = %08lx", *lphTex);
    return (D3D_OK);
}

HRESULT D3DHAL_TextureDestroy(LPD3DI_TEXTUREBLOCK lpBlock)
{
    LPDIRECT3DDEVICEI lpDevI=lpBlock->lpDevI;
    D3DTEXTUREHANDLE  hTex=lpBlock->hTex;
    D3DHAL_TEXTUREDESTROYDATA data;
    HRESULT ret;
    lpBlock->hTex=0;
    if (!IS_DX7HAL_DEVICE(lpDevI))
    {
        // on winnt we alway use the surfacehandle, so there is no need calling driver
        if (!lpDevI->lpD3DHALCallbacks->TextureDestroy) {
            D3D_ERR("TextureDestroy called, but no texture support.");
            return (D3DERR_TEXTURE_NO_SUPPORT);
        }
    }
    // The following code ensures that before we ask the driver to unmap
    // the texture, we set the stages to NULL if the texture is still present
    // in any stage. This is probably not necessary, but we are just trying
    // to be extra cautious here. The CAVEAT here is that it is possible that
    // D3DHAL_TextureDestroy() is being called from DestroyDevice() and hence
    // IT COULD BE REALLY BAD TO BATCH additional commands to the device at
    // this stage. (snene - 3/2/98)
    BOOL bNeedFlush = FALSE;
    if (IS_DP2HAL_DEVICE(lpDevI)) {
        int dwStage;
        CDirect3DDeviceIDP2 *dp2dev = static_cast<CDirect3DDeviceIDP2 *>(lpDevI);

        // Find out the first stage with hTex and NULL out
        for (dwStage=0;dwStage<(int)lpDevI->dwMaxTextureBlendStages; dwStage++)
        {
            if (hTex == lpDevI->tsstates[dwStage][D3DTSS_TEXTUREMAP])
            {
                dp2dev->SetTSSI(dwStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, 0);
                bNeedFlush = TRUE;
            }
        }
    }
    DWORD txh;
    if(lpDevI->GetRenderState(D3DRENDERSTATE_TEXTUREHANDLE, &txh) != D3D_OK)
    {
        D3D_WARN(0, "Error getting texture handle in D3DHAL_TextureDestroy");
    }
    else
    {
        if (txh == hTex)
        {
            lpDevI->rstates[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
            lpDevI->SetRenderStateI(D3DRENDERSTATE_TEXTUREHANDLE, 0);
            bNeedFlush = TRUE;
        }
    }

    // Make sure that we send down the command immediately to guarantee
    // that the driver gets it before we call it with Destroy
    if(bNeedFlush)
    {
        if(lpDevI->FlushStates() != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in D3DHAL_TextureDestroy");
        }
    }
    else // Now we decide whether to flush due to a referenced texture in the batch or not
    {
        LPD3DBUCKET list;
        if(lpBlock->lpD3DTextureI->lpDDS != NULL)
        {
            list = reinterpret_cast<LPD3DBUCKET>(((LPDDRAWI_DDRAWSURFACE_INT)(lpBlock->lpD3DTextureI->lpDDS))->lpLcl->lpSurfMore->lpD3DDevIList);
        }
        else
        {
            list = reinterpret_cast<LPD3DBUCKET>(((LPDDRAWI_DDRAWSURFACE_INT)(lpBlock->lpD3DTextureI->lpDDSSys))->lpLcl->lpSurfMore->lpD3DDevIList);
        }
        while(list != NULL)
        {
            if(list->lpD3DDevI == lpDevI)
            {
                if(lpDevI->FlushStates() != D3D_OK)
                {
                    D3D_ERR("Error trying to render batched commands in D3DHAL_TextureDestroy");
                }
                break;
            }
            list = list->next;
        }
    }
    if (!IS_DX7HAL_DEVICE(lpDevI))
    {
        memset(&data, 0, sizeof(D3DHAL_TEXTUREDESTROYDATA));
        data.dwhContext = lpDevI->dwhContext;
        data.dwHandle = hTex;

        D3D_INFO(6, "TextureDestroy, destroying texture dwhContext = %08lx, hTex = %08lx",
            data.dwhContext, hTex);

        CALL_HALONLY(ret, lpDevI, TextureDestroy, &data);
        if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
            D3D_ERR("HAL failed to handle TextureDestroy");
            return (D3DERR_TEXTURE_DESTROY_FAILED);
        }
    }
    D3D_INFO(6, "TextureDestroy, destroyed texture hTex = %08lx", hTex);
    return (D3D_OK);
}

HRESULT D3DHAL_TextureSwap(LPDIRECT3DDEVICEI lpDevI,
                           D3DTEXTUREHANDLE hTex1,
                           D3DTEXTUREHANDLE hTex2)
{
    D3DHAL_TEXTURESWAPDATA data;
    HRESULT ret;

    if (!lpDevI->lpD3DHALCallbacks->TextureSwap) {
        D3D_ERR("TextureSwapcalled, but no texture support.");
        return (D3DERR_TEXTURE_NO_SUPPORT);
    }

    memset(&data, 0, sizeof(D3DHAL_TEXTURESWAPDATA));
    data.dwhContext = lpDevI->dwhContext;
    data.dwHandle1 = hTex1;
    data.dwHandle2 = hTex2;
    data.ddrval = D3D_OK; 
    D3D_INFO(6, "TextureSwap, dwhContext = %d. hTex1 = %d, hTex2 = %d",
        data.dwhContext, hTex1, hTex2);
    CALL_HALONLY(ret, lpDevI, TextureSwap, &data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
        D3D_ERR("HAL failed to handle TextureSwap");
        return (D3DERR_TEXTURE_SWAP_FAILED);
    }
    return (D3D_OK);
}

__declspec (dllexport) HRESULT
D3DHAL_TextureGetSurf(LPDIRECT3DDEVICEI lpDevI,
                      D3DTEXTUREHANDLE hTex,
                      LPDIRECTDRAWSURFACE* lpDDS)
{
    if (IS_DX7HAL_DEVICE(lpDevI))
    {
        LPD3DI_TEXTUREBLOCK tBlock=LIST_FIRST(&lpDevI->texBlocks);
        while (tBlock)
        {
            if (tBlock->hTex == hTex)
            {
                *lpDDS = (LPDIRECTDRAWSURFACE)tBlock->lpD3DTextureI->lpDDS1Tex;
                return D3D_OK;
            }
            tBlock=LIST_NEXT(tBlock,devList);
        }
        return (D3DERR_TEXTURE_CREATE_FAILED);
    }
    else
    {
        D3DHAL_TEXTUREGETSURFDATA data;
        HRESULT ret;

        if (!lpDevI->lpD3DHALCallbacks->TextureGetSurf) {
            D3D_ERR("TextureGetSurf called, but no texture support.");
            return (D3DERR_TEXTURE_NO_SUPPORT);
        }

        memset(&data, 0, sizeof(D3DHAL_TEXTUREGETSURFDATA));
        data.dwhContext = lpDevI->dwhContext;
        data.dwHandle = hTex;

        D3D_INFO(6, "TextureGetSurf, getting texture for dwhContext = %d, hTex = %d",
            data.dwhContext, hTex);

        CALL_HALONLY(ret, lpDevI, TextureGetSurf, &data);
        if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
            D3D_ERR("HAL failed to handle TextureGetSurf");
            return (D3DERR_TEXTURE_CREATE_FAILED);
        }

        *lpDDS = (LPDIRECTDRAWSURFACE)data.lpDDS;

        return (D3D_OK);
    }
}

HRESULT D3DHELInst_D3DOP_TEXTURELOAD(LPDIRECT3DDEVICEI lpDevI,
                                     DWORD dwCount,
                                     LPD3DTEXTURELOAD load)
{
    HRESULT ddrval;
    DWORD i;
    LPDIRECTDRAWSURFACE lpDDSSrc;
    LPDIRECTDRAWSURFACE lpDDSDst;
    DDSURFACEDESC   ddsd;
    PALETTEENTRY    ppe[256];
    LPDIRECTDRAWPALETTE lpDDPalSrc, lpDDPalDst;
    int psize;

    for (i = 0; i < dwCount; i++) {
        if (D3DHAL_TextureGetSurf(lpDevI, load->hSrcTexture, &lpDDSSrc)) {
            D3D_ERR("HAL failed to get source surface in D3DHELInst_D3DOP_TEXTURELOAD");
            return (D3DERR_TEXTURE_LOAD_FAILED);
        }
        if (D3DHAL_TextureGetSurf(lpDevI, load->hDestTexture, &lpDDSDst)) {
            D3D_ERR("HAL failed to get destination surface in D3DHELInst_D3DOP_TEXTURELOAD");
            return (D3DERR_TEXTURE_LOAD_FAILED);
        }

        memset(&ddsd, 0, sizeof ddsd);
        ddsd.dwSize = sizeof(ddsd);
        ddrval = lpDDSDst->GetSurfaceDesc(&ddsd);
        if (ddrval != DD_OK) {
            D3D_ERR("Failed to get surface description of source texture surface in D3DHELInst_D3DOP_TEXTURELOAD");
            return (D3DERR_TEXTURE_LOAD_FAILED);
        }

        if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8) {
            psize = 256;
        } else if (ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED4) {
            psize = 16;
        } else {
            psize = 0;
        }

        if (psize) {
            ddrval = lpDDSSrc->GetPalette(&lpDDPalSrc);
            if (ddrval != DD_OK) {
                if (ddrval != DDERR_NOPALETTEATTACHED) {
                    D3D_ERR("Failed to get palette of source texture in D3DHELInst_D3DOP_TEXTURELOAD");
                    return (D3DERR_TEXTURE_LOAD_FAILED);
                }
            } else {
                ddrval = lpDDPalSrc->GetEntries(0, 0, psize, ppe);
                if (ddrval != DD_OK) {
                    D3D_ERR("Failed to get palette entries of source texture in D3DHELInst_D3DOP_TEXTURELOAD");
                    lpDDPalSrc->Release();
                    return (D3DERR_TEXTURE_LOAD_FAILED);
                }
                lpDDPalSrc->Release();
                ddrval = lpDDSDst->GetPalette(&lpDDPalDst);
                if (ddrval != DD_OK) {
                    D3D_ERR("Failed to get palette of destination texture in D3DHELInst_D3DOP_TEXTURELOAD");
                    return (D3DERR_TEXTURE_LOAD_FAILED);
                }
                ddrval = lpDDPalDst->SetEntries(0, 0, psize, ppe);
                if (ddrval != DD_OK) {
                    D3D_ERR("Failed to set palette entries of destination texture in D3DHELInst_D3DOP_TEXTURELOAD");
                    lpDDPalDst->Release();
                    return (D3DERR_TEXTURE_LOAD_FAILED);
                }
                lpDDPalDst->Release();
            }
        }

        lpDDSSrc->AddRef();
        lpDDSDst->AddRef();
        do {
            DDSCAPS ddscaps;
            LPDIRECTDRAWSURFACE lpDDSTmp;
            ddrval = lpDDSDst->Blt(NULL, lpDDSSrc,
                                   NULL, DDBLT_WAIT, NULL);

            if (ddrval == E_NOTIMPL && (psize == 16 || psize == 4 || psize == 2) ) {
                DDSURFACEDESC ddsd_s, ddsd_d;
                LPBYTE psrc, pdst;
                DWORD i;
                DWORD dwBytesPerLine;

                memset(&ddsd_s, 0, sizeof ddsd_s);
                memset(&ddsd_d, 0, sizeof ddsd_d);
                ddsd_s.dwSize = ddsd_d.dwSize = sizeof(DDSURFACEDESC);

                if ((ddrval = lpDDSSrc->Lock(NULL, &ddsd_s, DDLOCK_WAIT, NULL)) != DD_OK) {
                    lpDDSSrc->Release();
                    lpDDSDst->Release();
                    D3D_ERR("Failed to lock src surface");
                    return ddrval;
                }
                if ((ddrval = lpDDSDst->Lock(NULL, &ddsd_d, DDLOCK_WAIT, NULL)) != DD_OK) {
                    lpDDSSrc->Unlock(NULL);
                    lpDDSSrc->Release();
                    lpDDSDst->Release();
                    D3D_ERR("Failed to lock dst surface");
                    return ddrval;
                }

                switch (psize)
                {
                case 16: dwBytesPerLine = (ddsd.dwWidth + 1) / 2; break;
                case 4: dwBytesPerLine = (ddsd.dwWidth + 3) / 4; break;
                case 2: dwBytesPerLine = (ddsd.dwWidth + 7) / 8; break;
                }

                psrc = (LPBYTE)ddsd_s.lpSurface;
                pdst = (LPBYTE)ddsd_d.lpSurface;
                for (i = 0; i < ddsd_s.dwHeight; i++) {
                    memcpy( pdst, psrc, dwBytesPerLine );
                    psrc += ddsd_s.lPitch;
                    pdst += ddsd_d.lPitch;
                }

                lpDDSSrc->Unlock(NULL);
                lpDDSDst->Unlock(NULL);
                lpDDSSrc->Release();
                lpDDSDst->Release();
                return D3D_OK;

            }
            if (ddrval != DD_OK)
            {
                lpDDSSrc->Release();
                lpDDSDst->Release();
                return ddrval;
            }

            memset(&ddscaps, 0, sizeof(DDSCAPS));
            ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
            ddrval = lpDDSSrc->GetAttachedSurface(&ddscaps, &lpDDSTmp);
            lpDDSSrc->Release();
            lpDDSSrc = lpDDSTmp;
            if (ddrval == DDERR_NOTFOUND) {
                // no more surfaces in the chain
                lpDDSDst->Release();
                break;
            } else if (ddrval != DD_OK) {
                lpDDSDst->Release();
                D3D_ERR("GetAttachedSurface of source failed in D3DHELInst_D3DOP_TEXTURELOAD");
                return (D3DERR_TEXTURE_LOAD_FAILED);
            }
            memset(&ddscaps, 0, sizeof(DDSCAPS));
            ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
            ddrval = lpDDSDst->GetAttachedSurface(&ddscaps, &lpDDSTmp);
            lpDDSDst->Release();
            lpDDSDst = lpDDSTmp;
            if (ddrval == DDERR_NOTFOUND) {
                lpDDSSrc->Release();
                D3D_ERR("Destination texture has fewer attached mipmap surfaces than source in D3DHELInst_D3DOP_TEXTURELOAD");
                return (D3DERR_TEXTURE_LOAD_FAILED);
            } else if (ddrval != DD_OK) {
                lpDDSSrc->Release();
                D3D_ERR("GetAttachedSurface of destination failed in D3DHELInst_D3DOP_TEXTURELOAD");
                return (D3DERR_TEXTURE_LOAD_FAILED);
            }
        } while (1);
        load++;
    }
    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\knibbt.cpp ===
#include "pch.cpp"
#pragma hdrstop

HRESULT D3DAPI katmai_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs)
{
    LPD3DFE_CONTEXTCREATE pfnFEContextCreate = NULL;

    HKEY hKey;
    LONG lRet;
    lRet = RegOpenKey( HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey );
    if ( lRet == ERROR_SUCCESS )
    {
        char filename[_MAX_PATH];
        DWORD dwSize = sizeof(filename);
        DWORD dwType;
        lRet = RegQueryValueEx(hKey,
                               "GeometryDriver",
                               NULL,
                               &dwType,
                               (LPBYTE) filename,
                               &dwSize);
        if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
        {
            HINSTANCE hGeometryDLL;
            hGeometryDLL = LoadLibrary(filename);
            if (hGeometryDLL)
            {
                pfnFEContextCreate = (LPD3DFE_CONTEXTCREATE) GetProcAddress(hGeometryDLL, "FEContextCreate");
            }
            else
            {
                D3D_ERR("LoadLibrary failed on GeometryDriver");
                goto _error_exit;
            }
        }
        else
        {
            D3D_ERR("RegQueryValue failed on GeometryDriver");
            goto _error_exit;
        }
        RegCloseKey( hKey );
    }
    else
    {
        D3D_ERR("RegOpenKey failed on GeometryDriver");
        goto _error_exit;
    }

    // here if we think we have a valid pfnFEContextCreate
    return(pfnFEContextCreate(dwFlags, lpLeafFuncs));


_error_exit:
    return DDERR_GENERIC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\light.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   light.c
 *  Content:    Direct3D light management
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   11/11/95   stevela Initial rev with this header.
 *          Light handling changed.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

/*
 * Create an api for the Direct3DLight object
 */

#include "pch.cpp"
#pragma hdrstop

HRESULT 
hookLightToD3D(LPDIRECT3DI lpD3DI,
               LPDIRECT3DLIGHTI lpD3DLight)
{

    LIST_INSERT_ROOT(&lpD3DI->lights, lpD3DLight, list);
    lpD3DLight->lpDirect3DI = lpD3DI;

    lpD3DI->numLights++;

    return (D3D_OK);
}

HRESULT D3DAPI DIRECT3DLIGHTI::Initialize(LPDIRECT3D lpD3D)
{
    return DDERR_ALREADYINITIALIZED;
}

void inverseRotateVector(D3DVECTOR* d, D3DVECTOR* v, D3DMATRIX* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    d->x = vx * M->_11 + vy * M->_12 + vz * M->_13;
    d->y = vx * M->_21 + vy * M->_22 + vz * M->_23;
    d->z = vx * M->_31 + vy * M->_32 + vz * M->_33;
}

void inverseTransformVector(D3DVECTOR* d, D3DVECTOR* v, D3DMATRIX* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    vx -= M->_41; vy -= M->_42; vz -= M->_43;
    d->x = vx * M->_11 + vy * M->_12 + vz * M->_13;
    d->y = vx * M->_21 + vy * M->_22 + vz * M->_23;
    d->z = vx * M->_31 + vy * M->_32 + vz * M->_33;
}

void D3DI_UpdateLightInternal(LPDIRECT3DLIGHTI lpLight)
{
    LPDIRECT3DVIEWPORTI lpViewI = lpLight->lpD3DViewportI;
    LPD3DLIGHT2 lpLight2 = (D3DLIGHT2 *)&lpLight->dlLight;
    
    if (sizeof(D3DLIGHT) == lpLight->dlLight.dwSize) 
    {
        lpLight->diLightData.version = 1;
        lpLight->diLightData.flags = D3DLIGHT_ACTIVE;
    } else {
        lpLight->diLightData.version = 2;
        lpLight->diLightData.flags = lpLight2->dwFlags;
    }
    lpLight->diLightData.valid  = TRUE;
    lpLight->diLightData.type   = lpLight->dlLight.dltType;
    lpLight->diLightData.red    = lpLight->dlLight.dcvColor.r;
    lpLight->diLightData.green  = lpLight->dlLight.dcvColor.g;
    lpLight->diLightData.blue   = lpLight->dlLight.dcvColor.b;
    lpLight->diLightData.position.x = lpLight->dlLight.dvPosition.x;
    lpLight->diLightData.position.y = lpLight->dlLight.dvPosition.y;
    lpLight->diLightData.position.z = lpLight->dlLight.dvPosition.z;
    lpLight->diLightData.direction.x = lpLight->dlLight.dvDirection.x;
    lpLight->diLightData.direction.y = lpLight->dlLight.dvDirection.y;
    lpLight->diLightData.direction.z = lpLight->dlLight.dvDirection.z;
    lpLight->diLightData.attenuation0 = lpLight->dlLight.dvAttenuation0;
    lpLight->diLightData.attenuation1 = lpLight->dlLight.dvAttenuation1;
    lpLight->diLightData.attenuation2 = lpLight->dlLight.dvAttenuation2;

    VecNormalize(lpLight->diLightData.direction);

    lpLight->diLightData.range = lpLight->dlLight.dvRange;
    lpLight->diLightData.range_squared = lpLight->dlLight.dvRange * lpLight->dlLight.dvRange;

    lpLight->diLightData.shade = lpLight->dlLight.dcvColor.r * 0.3f +
                                 lpLight->dlLight.dcvColor.g * 0.59f +
                                 lpLight->dlLight.dcvColor.b * 0.11f;

    if (lpLight->dlLight.dltType == D3DLIGHT_SPOT) 
    {
        lpLight->diLightData.cos_theta_by_2 = (float)cos(lpLight->dlLight.dvTheta / 2.0);
        lpLight->diLightData.cos_phi_by_2 = (float)cos(lpLight->dlLight.dvPhi / 2.0);

        if (lpLight->diLightData.version == 1) 
        {
            if (lpLight->diLightData.cos_phi_by_2 < lpLight->diLightData.cos_theta_by_2) 
            {
                lpLight->diLightData.falloff = 
                    1.0f / (lpLight->diLightData.cos_theta_by_2 -
                            lpLight->diLightData.cos_phi_by_2);
            } 
            else 
            {
                lpLight->diLightData.falloff = DTOVAL(0.0);
            }
        } 
        else 
        {
            lpLight->diLightData.falloff = lpLight->dlLight.dvFalloff;
            lpLight->diLightData.inv_theta_minus_phi = lpLight->diLightData.cos_theta_by_2 - 
                lpLight->diLightData.cos_phi_by_2;
            if (lpLight->diLightData.inv_theta_minus_phi != 0.0) 
            {
                lpLight->diLightData.inv_theta_minus_phi = 1.0f/lpLight->diLightData.inv_theta_minus_phi;
            } 
            else 
            {
                lpLight->diLightData.inv_theta_minus_phi = 1.0f;
            }
        }
    }

    /* set internal flags */
    if (lpLight->diLightData.version != 1) 
    {
        if (lpLight->diLightData.attenuation0 != 0.0) 
        {
            lpLight->diLightData.flags |= D3DLIGHTI_ATT0_IS_NONZERO;
        }
        if (lpLight->diLightData.attenuation1 != 0.0) 
        {
            lpLight->diLightData.flags |= D3DLIGHTI_ATT1_IS_NONZERO;
        }
        if (lpLight->diLightData.attenuation2 != 0.0) 
        {
            lpLight->diLightData.flags |= D3DLIGHTI_ATT2_IS_NONZERO;
        }
        if (lpLight->diLightData.falloff == 1.0) 
        {
            lpLight->diLightData.flags |= D3DLIGHTI_LINEAR_FALLOFF;
        }
    }
    if (lpViewI) 
    {
        lpViewI->bLightsChanged = TRUE;
    }
}

/*
 * Create the Light
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::CreateLight"

HRESULT D3DAPI 
DIRECT3DI::CreateLight(LPDIRECT3DLIGHT* lplpLight,
                       IUnknown* pUnkOuter)
{
    LPDIRECT3DLIGHTI    lpLight;
    HRESULT             ret;

    if(pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    if (!VALID_DIRECT3D3_PTR(this)) {
        D3D_ERR( "Invalid Direct3D pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_OUTPTR(lplpLight)) {
        D3D_ERR( "Invalid pointer to pointer" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpLight = NULL;

    /*
     * setup the object
     */

    lpLight = static_cast<LPDIRECT3DLIGHTI>(new DIRECT3DLIGHTI);
    if (!lpLight) {
        D3D_ERR("failed to allocate space for object");
        return DDERR_OUTOFMEMORY;
    }

    /*
     * Put this device in the list of those owned by the
     * Direct3Dobject
     */
    ret = hookLightToD3D(this, lpLight);
    if (ret != D3D_OK) {
        D3D_ERR("failed to associate light to Direct3D");
        D3DFree(lpLight);
        return ret;
    }

    *lplpLight = (LPDIRECT3DLIGHT)lpLight;

    return (D3D_OK);
}

DIRECT3DLIGHTI::DIRECT3DLIGHTI()
{
    lpD3DViewportI = NULL;
    memset(&dlLight, 0, sizeof(D3DLIGHT2));
    memset(&diLightData, 0, sizeof(D3DI_LIGHT));    // Internal representation of light
    refCnt = 1;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DLight::SetLight"

HRESULT D3DAPI 
DIRECT3DLIGHTI::SetLight(LPD3DLIGHT lpData)
{
    HRESULT             ret;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DLIGHT_PTR(this)) {
            D3D_ERR( "Invalid Direct3DLight pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DLIGHT_PTR(lpData) && !VALID_D3DLIGHT2_PTR(lpData)) {
            D3D_ERR( "Invalid D3DLIGHT pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (lpData->dwSize == sizeof(D3DLIGHT2)) {
            if (lpData->dltType != D3DLIGHT_POINT && 
                lpData->dltType != D3DLIGHT_SPOT &&
                lpData->dltType != D3DLIGHT_DIRECTIONAL && 
                lpData->dltType != D3DLIGHT_PARALLELPOINT) {
                D3D_ERR( "Invalid D3DLIGHT type" );
                return DDERR_INVALIDPARAMS;
            }
            if (lpData->dvRange < 0.0f || lpData->dvRange > D3DLIGHT_RANGE_MAX) {
                D3D_ERR( "Invalid D3DLIGHT range" );
                return DDERR_INVALIDPARAMS;
            }
            if (lpData->dltType == D3DLIGHT_SPOT || lpData->dltType == D3DLIGHT_DIRECTIONAL) { 
                float   magnitude;
                magnitude = lpData->dvDirection.x * lpData->dvDirection.x +
                    lpData->dvDirection.y * lpData->dvDirection.y +
                    lpData->dvDirection.z * lpData->dvDirection.z;
                if (magnitude < 0.00001f) {
                    D3D_ERR( "Invalid D3DLIGHT direction" );
                    return DDERR_INVALIDPARAMS;
                }
                if (lpData->dltType == D3DLIGHT_SPOT) {
                    if (lpData->dvPhi < 0.0f) {
                        D3D_ERR( "Invalid D3DLIGHT Phi angle, must be >= 0" );
                        return DDERR_INVALIDPARAMS;
                    }
                    if (lpData->dvPhi > 3.1415927f) {
                        D3D_ERR( "Invalid D3DLIGHT Phi angle, must be <= pi" );
                        return DDERR_INVALIDPARAMS;
                    }
                    if (lpData->dvTheta < 0.0f) {
                        D3D_ERR( "Invalid D3DLIGHT Theta angle, must be >= 0" );
                        return DDERR_INVALIDPARAMS;
                    }
                    if (lpData->dvTheta > lpData->dvPhi) {
                        D3D_ERR( "Invalid D3DLIGHT Theta angle, must be <= Phi" );
                        return DDERR_INVALIDPARAMS;
                    }
                }
            }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    /* use memcpy so this works with either D3DLIGHT or D3DLIGHT2 */
    memcpy(&this->dlLight, lpData, lpData->dwSize);
    
    D3DI_UpdateLightInternal(this);

    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DLight::GetLight"

HRESULT D3DAPI 
DIRECT3DLIGHTI::GetLight(LPD3DLIGHT lpData)
{
    HRESULT     ret;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DLIGHT_PTR(this)) {
            D3D_ERR( "Invalid Direct3DLight pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DLIGHT_PTR(lpData) && !VALID_D3DLIGHT2_PTR(lpData)) {
            D3D_ERR( "Invalid D3DLIGHT pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    /* use memcpy so this works with either D3DLIGHT or D3DLIGHT2 */
    memcpy(lpData, &this->dlLight, this->dlLight.dwSize);

    return (ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\liunk.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   liunk.c
 *  Content:    Direct3DLight IUnknown implementation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * D3DLight_QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DLight::QueryInterface"

HRESULT D3DAPI DIRECT3DLIGHTI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DLIGHT_PTR(this)) {
            D3D_ERR( "Invalid Direct3DLight pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(ppvObj)) {
            D3D_ERR( "Invalid pointer to pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!VALID_OUTPTR(ppvObj)) {
        return (DDERR_INVALIDPARAMS);
    }

    *ppvObj = NULL;

    if(IsEqualIID(riid, IID_IUnknown) ||
       IsEqualIID(riid, IID_IDirect3DLight) )
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DLIGHT>(this));
        return (D3D_OK);
    }
    return (E_NOINTERFACE);

} /* D3DLight_QueryInterface */

/*
 * D3DLight_AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DLight::AddRef"

ULONG D3DAPI DIRECT3DLIGHTI::AddRef()
{
    DWORD       rcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DLIGHT_PTR(this)) {
            D3D_ERR( "Invalid Direct3DLight pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }

    this->refCnt++;
    rcnt = this->refCnt;

    return (rcnt);
} /* D3DLight_AddRef */

/*
 * D3DLight_Release
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DLight::Release"

ULONG D3DAPI DIRECT3DLIGHTI::Release()
{
    DWORD           lastrefcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DLIGHT_PTR(this)) {
            D3D_ERR( "Invalid Direct3DLight pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }

    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    lastrefcnt = this->refCnt;

    if( lastrefcnt == 0 )
    {
        delete this;
        return 0;
    }
    return lastrefcnt;

} /* D3DLight_Release */

DIRECT3DLIGHTI::~DIRECT3DLIGHTI()
{
    /* remove us from our viewport's list of lights */
    if (this->lpD3DViewportI) {
        CIRCLE_QUEUE_DELETE(&this->lpD3DViewportI->lights, this, light_list);
        this->lpD3DViewportI->numLights--;
        this->lpD3DViewportI->bLightsChanged = TRUE;
    }

    /* remove us from the Direct3D object list of lights */
    LIST_DELETE(this, list);
    this->lpDirect3DI->numLights--;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\material.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        material.c
 *  Content:        Direct3D material management
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date        By        Reason
 *   ====        ==        ======
 *   11/12/95   stevela        Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Create an api for the Direct3DMaterial object
 */

#undef  DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial"

HRESULT hookMaterialToD3D(LPDIRECT3DI lpD3DI,
                                 LPDIRECT3DMATERIALI lpD3DMatI)
{

    LIST_INSERT_ROOT(&lpD3DI->materials, lpD3DMatI, list);
    lpD3DMatI->lpDirect3DI = lpD3DI;

    lpD3DI->numMaterials++;

    return (D3D_OK);
}

HRESULT hookMaterialToDevice(LPDIRECT3DMATERIALI lpMatI,
                                    LPDIRECT3DDEVICEI lpDevI,
                                    D3DMATERIALHANDLE hMat,
                                    DWORD hMatDDI)
{
    LPD3DI_MATERIALBLOCK mBlock;

    if (D3DMalloc((void**)&mBlock, sizeof(D3DI_MATERIALBLOCK)) != D3D_OK) {
        D3D_ERR("failed to allocate space for material block");
        return (DDERR_OUTOFMEMORY);
    }
    mBlock->lpDevI = lpDevI;
    mBlock->lpD3DMaterialI = lpMatI;
    mBlock->hMat = hMat;
    mBlock->hMatDDI = hMatDDI;

    LIST_INSERT_ROOT(&lpMatI->blocks, mBlock, list);
    LIST_INSERT_ROOT(&lpDevI->matBlocks, mBlock, devList);

    return (D3D_OK);
}

void D3DI_RemoveMaterialBlock(LPD3DI_MATERIALBLOCK lpBlock)
{
    // Remove from device
    if ( lpBlock->lpDevI )
    {
        D3DHAL_MaterialDestroy(lpBlock->lpDevI, lpBlock->hMat);
    }

    LIST_DELETE(lpBlock, devList);

    // Remove from material
    LIST_DELETE(lpBlock, list);

    D3DFree(lpBlock);
}

D3DMATERIALHANDLE findMaterialHandle(LPDIRECT3DMATERIALI lpMat,
                                            LPDIRECT3DDEVICEI lpDev)
{
    LPD3DI_MATERIALBLOCK mBlock;
    D3DMATERIALHANDLE hMat = 0;

    mBlock = LIST_FIRST(&lpMat->blocks);
    while (mBlock) {
        if (!mBlock) {
            D3D_ERR("internal error - material list out of sync");
            return 0;
        }
        if (mBlock->lpDevI == lpDev) {
            hMat = mBlock->hMat;
            break;
        }
        mBlock = LIST_NEXT(mBlock,list);
    }
    return hMat;
}

HRESULT D3DAPI DIRECT3DMATERIALI::Initialize(LPDIRECT3D lpD3D)
{
    return DDERR_ALREADYINITIALIZED;
}

/*
 * Create the Material
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::CreateMaterial"

HRESULT D3DAPI DIRECT3DI::CreateMaterial(LPDIRECT3DMATERIAL* lplpD3DMat,
                                         IUnknown* pUnkOuter)
{
    LPDIRECT3DMATERIAL3 lpD3DMat3;
    HRESULT ret = CreateMaterial(&lpD3DMat3, pUnkOuter);
    if (ret == D3D_OK)
        *lplpD3DMat = static_cast<LPDIRECT3DMATERIAL>(static_cast<LPDIRECT3DMATERIALI>(lpD3DMat3));
    return ret;
}

HRESULT D3DAPI DIRECT3DI::CreateMaterial(LPDIRECT3DMATERIAL2* lplpD3DMat,
                                         IUnknown* pUnkOuter)
{
    LPDIRECT3DMATERIAL3 lpD3DMat3;
    HRESULT ret = CreateMaterial(&lpD3DMat3, pUnkOuter);
    if (ret == D3D_OK)
        *lplpD3DMat = static_cast<LPDIRECT3DMATERIAL2>(static_cast<LPDIRECT3DMATERIALI>(lpD3DMat3));
    return ret;
}

HRESULT D3DAPI DIRECT3DI::CreateMaterial(LPDIRECT3DMATERIAL3* lplpD3DMat,
                                         IUnknown* pUnkOuter)
{
    LPDIRECT3DMATERIALI        lpMat;
    HRESULT                ret;

    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    /*
     * validate parms
     */
    if (!VALID_DIRECT3D3_PTR(this)) {
        D3D_ERR( "Invalid Direct3D pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_OUTPTR(lplpD3DMat)) {
        D3D_ERR( "Invalid pointer to pointer" );
        return DDERR_INVALIDPARAMS;
    }
    *lplpD3DMat = NULL;

    lpMat = static_cast<LPDIRECT3DMATERIALI>(new DIRECT3DMATERIALI());
    if (!lpMat) {
        D3D_ERR("failed to allocate space for object");
        return (DDERR_OUTOFMEMORY);
    }

    /*
     * setup the object
     */
    /*
     * Put this device in the list of those owned by the
     * Direct3D object
     */
    ret = hookMaterialToD3D(this, lpMat);
    if (ret != D3D_OK) {
        D3D_ERR("failed to associate material with object");
        delete lpMat;
        return (ret);
    }

    *lplpD3DMat = (LPDIRECT3DMATERIAL3)lpMat;

    return (D3D_OK);
}

DIRECT3DMATERIALI::DIRECT3DMATERIALI()
{
    memset(&dmMaterial, 0, sizeof(D3DMATERIAL)); /* Data describing material */
    dmMaterial.dwSize = sizeof(D3DMATERIAL);
    bRes= false;    /* Is this material reserved in the driver */

    refCnt = 1;
    LIST_INITIALIZE(&blocks);

}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::SetMaterial"

HRESULT D3DAPI DIRECT3DMATERIALI::SetMaterial(LPD3DMATERIAL lpData)
{
    HRESULT                ret;
    HRESULT                err;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DMATERIAL_PTR(lpData)) {
            D3D_ERR( "Invalid D3DMATERIAL pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (memcmp(&this->dmMaterial, lpData, sizeof(D3DMATERIAL))) {
        LPD3DI_MATERIALBLOCK mBlock = LIST_FIRST(&this->blocks);
        this->dmMaterial = *lpData;

        /*
         * Download material data
         */

        while (mBlock) {
            err = D3DHAL_MaterialSetData(mBlock->lpDevI, 
                                         mBlock->hMat,  &this->dmMaterial);
            if ( err != DD_OK ) {
                D3D_ERR("error ocurred whilst informing device about material change");
                return err;
            }
            mBlock = LIST_NEXT(mBlock,list);
        }

    }

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::GetMaterial"

HRESULT D3DAPI DIRECT3DMATERIALI::GetMaterial(LPD3DMATERIAL lpData)
{
    HRESULT                ret;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DMATERIAL_PTR(lpData)) {
            D3D_ERR( "Invalid D3DMATERIAL pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *lpData = this->dmMaterial;

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::GetHandle"

HRESULT D3DAPI DIRECT3DMATERIALI::GetHandle(LPDIRECT3DDEVICE lpDev,
                                            LPD3DMATERIALHANDLE lphMat)
{
    LPDIRECT3DDEVICE3 lpDev3 = static_cast<LPDIRECT3DDEVICE3>(static_cast<LPDIRECT3DDEVICEI>(lpDev));
    return GetHandle(lpDev3, lphMat);
}

HRESULT D3DAPI DIRECT3DMATERIALI::GetHandle(LPDIRECT3DDEVICE2 lpDev,
                                            LPD3DMATERIALHANDLE lphMat)
{
    LPDIRECT3DDEVICE3 lpDev3 = static_cast<LPDIRECT3DDEVICE3>(static_cast<LPDIRECT3DDEVICEI>(lpDev));
    return GetHandle(lpDev3, lphMat);
}

HRESULT D3DAPI DIRECT3DMATERIALI::GetHandle(LPDIRECT3DDEVICE3 lpDev,
                                            LPD3DMATERIALHANDLE lphMat)
{
    LPDIRECT3DDEVICEI        lpD3DDevI;
    D3DMATERIALHANDLE        hMat;
    HRESULT                ret;
    HRESULT                err;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    /*
     * validate parms
     */
    TRY
    {
        lpD3DDevI = static_cast<LPDIRECT3DDEVICEI>(lpDev);
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DDEVICE3_PTR(lpD3DDevI)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DMATERIALHANDLE_PTR(lphMat)) {
            D3D_ERR( "Invalid D3DMATERIALHANDLE pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    /*
     * If we're already on a device, return the right handle.
     */
    hMat = findMaterialHandle(this, lpD3DDevI);

    if (!hMat) {
        DWORD hMatDDI = 0x0;
        /*
         * Create the material handle through RLDDI
         */
        err = D3DHAL_MaterialCreate(lpD3DDevI, &hMat, &this->dmMaterial);
        if (err != DD_OK) {
            D3D_ERR("failed to allocate material through the device");
            return err;
        }

        err = hookMaterialToDevice(this, lpD3DDevI, hMat, hMatDDI);
        if (err != D3D_OK) {
            D3DHAL_MaterialDestroy(lpD3DDevI, hMat);
            D3D_ERR("failed to associated material to device");
            return err;
        }
    }

    *lphMat = hMat;

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::Reserve"

HRESULT D3DAPI DIRECT3DMATERIALI::Reserve()
{
#ifdef SUPPORT_RESERVE
    LPD3DI_MATERIALBLOCK mBlock, nBlock;
#endif
    HRESULT                ret;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

#ifdef SUPPORT_RESERVE
    /*
     * Reserve the material through RLDDI
     */

    /*
     * Iterate over all devices we're associated with.
     */

    mBlock = LIST_FIRST(&this->blocks);
    while (mBlock) {
        if (RLDDIService(mBlock->lpDevI->stack, RLDDIMaterialReserve,
                         mBlock->hMat, NULL) != DD_OK) {
            D3D_ERR("failed to reserve material");
            goto free_and_exit;
        }
        mBlock = LIST_NEXT(mBlock,list);
    }
    this->bRes = 1;

    return (ret);

free_and_exit:
    nBlock = LIST_FIRST(&this->blocks);
    while (nBlock != mBlock) {
        if (!nBlock) {
            D3D_ERR("internal error - material blocks out of sync");
            return (DDERR_GENERIC);
        }
        ret = RLDDIService(nBlock->lpDevI->stack, RLDDIMaterialUnreserve,
                           (LONG)nBlock->hMat, NULL);
        if (ret != D3D_OK) {
            D3D_ERR("error occured whilst unreserving material after error");
        }
        nBlock = LIST_NEXT(nBlock,list);
    }
#else
    ret = DDERR_UNSUPPORTED;
#endif

    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::Unreserve"

HRESULT D3DAPI DIRECT3DMATERIALI::Unreserve()
{
#ifdef SUPPORT_RESERVE
    LPD3DI_MATERIALBLOCK mBlock;
#endif
    HRESULT                ret;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

#ifdef SUPPORT_RESERVE
    /*
     * Unreserve the material through RLDDI
     */
    if (this->bRes) {
        mBlock = LIST_FIRST(&this->blocks);
        while (mBlock) {
            if (RLDDIService(mBlock->lpDevI->stack, RLDDIMaterialUnreserve,
                             mBlock->hMat, NULL) != DD_OK) {
                D3D_ERR("failed to unreserve material");
            }
            mBlock = LIST_NEXT(mBlock,list);
        }
    }
#else
    ret = DDERR_UNSUPPORTED;
#endif

    return (ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\pch.cpp ===
#include "ddrawpr.h"
#include <windows.h>
#include <assert.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "dpf.h"
#include "d3di.hpp"
#include "d3dpr.hpp"
#include "ddrawp.h"
#include "haldrv.hpp"
#include "memalloc.h"
#include "fltval.h"
#include "texman.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\matiunk.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * 
 *  File:   matiunk.c
 *  Content:    Direct3DMaterial IUnknown implementation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * D3DMat_QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::QueryInterface"

HRESULT D3DAPI DIRECT3DMATERIALI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{   
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(ppvObj)) {
            D3D_ERR( "Invalid pointer to pointer" );
            return DDERR_INVALIDPARAMS;
        }
        *ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    
    if(IsEqualIID(riid, IID_IUnknown) ||
       IsEqualIID(riid, IID_IDirect3DMaterial3) )
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DMATERIAL3>(this));
        return (D3D_OK);
    }
    else if (IsEqualIID(riid, IID_IDirect3DMaterial2))
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DMATERIAL2>(this));
        return D3D_OK;
    }
    else if (IsEqualIID(riid, IID_IDirect3DMaterial))
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DMATERIAL>(this));
        return D3D_OK;
    }
    else
    {
        D3D_ERR( "Don't know this riid" );
        return (E_NOINTERFACE);
    }
} /* D3DMat2_QueryInterface */

/*
 * D3DMat_AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::AddRef"

ULONG D3DAPI DIRECT3DMATERIALI::AddRef()
{
    DWORD       rcnt;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    
    this->refCnt++;
    rcnt = this->refCnt;
    
    return (rcnt);
    
} /* D3DMat_AddRef */

/*
  * D3DMat_Release
  *
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DMaterial::Release"

ULONG D3DAPI DIRECT3DMATERIALI::Release()
{
    DWORD           lastrefcnt;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DMATERIAL2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DMaterial pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    lastrefcnt = this->refCnt;
    
    if( lastrefcnt == 0 )
    {
        delete this;
        return 0;
    }
    return lastrefcnt;
    
} /* D3DMat_Release */

DIRECT3DMATERIALI::~DIRECT3DMATERIALI()
{       
    /*
     * Remove ourselves from the devices
     */
    while (LIST_FIRST(&this->blocks)) {
        LPD3DI_MATERIALBLOCK mBlock = LIST_FIRST(&this->blocks);
        D3DI_RemoveMaterialBlock(mBlock);
    }
        
    /*
        * Remove ourselves from the Direct3D object
        */
    LIST_DELETE(this, list);
    this->lpDirect3DI->numMaterials--;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\texiunk.cpp ===
/*==========================================================================;
*
*  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
*  File:    texiunk.c
*  Content: Direct3DTexture IUnknown
*@@BEGIN_MSINTERNAL
* 
*  $Id$
*
*  History:
*   Date    By  Reason
*   ====    ==  ======
*   07/12/95    stevela Merged Colin's changes.
*   10/12/95    stevela Removed AGGREGATE_D3D
*@@END_MSINTERNAL
*
***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
* If we are built with aggregation enabled then we actually need two
* different Direct3D QueryInterface, AddRef and Releases. One which
* does the right thing on the Direct3DTexture object and one which
* simply punts to the owning interface.
*/

/*
* D3DTextIUnknown_QueryInterface
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::QueryInterface"

HRESULT D3DAPI CDirect3DTextureUnk::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DWORD_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if( !VALID_OUTPTR( ppvObj ) )
        {
            D3D_ERR( "Invalid obj ptr" );
            return DDERR_INVALIDPARAMS;
        }
        *ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    
    *ppvObj = NULL;
    
    if(IsEqualIID(riid, IID_IUnknown))
    {
        /*
         * Asking for IUnknown and we are IUnknown.
         * NOTE: Must AddRef through the interface being returned.
         */
        pTexI->AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPUNKNOWN>(this));
    }
    else if (IsEqualIID(riid, IID_IDirect3DTexture))
    {
        /*
         * Asking for the actual IDirect3DTexture interface
         * NOTE: Must AddRef throught the interface being returned.
         */
        pTexI->AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DTEXTURE>(pTexI));
    }
    else if (IsEqualIID(riid, IID_IDirect3DTexture2))
    {
        /*
         * Asking for the actual IDirect3DTexture2 interface
         * NOTE: Must AddRef throught the interface being returned.
         */
        pTexI->AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DTEXTURE2>(pTexI));
    }
    else
    {
        return (E_NOINTERFACE);
    }
    
    return (D3D_OK);
    
} /* D3DTextIUnknown_QueryInterface */

/*
  * D3DTextIUnknown_AddRef
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::AddRef"

ULONG D3DAPI CDirect3DTextureUnk::AddRef()
{
    DWORD                     rcnt;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DWORD_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }

    this->refCnt++;
    rcnt = this->refCnt;
    
    D3D_INFO(3, "Direct3DTexture IUnknown AddRef: Reference count = %d", rcnt);
    
    return (rcnt);
} /* D3DTextIUnknown_AddRef */

/*
  * D3DTextIUnknown_Release
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::Release"

ULONG D3DAPI CDirect3DTextureUnk::Release()
{
    DWORD           lastrefcnt;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DWORD_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    lastrefcnt = this->refCnt;
    
    D3D_INFO(3, "Direct3DTexture IUnknown Release: Reference count = %d", lastrefcnt);
    
    if (lastrefcnt == 0)
    {
        delete pTexI; // Delete Parent object
        return 0;
    }
    
    return lastrefcnt;
} /* D3DTextIUnknown_Release */

DIRECT3DTEXTUREI::~DIRECT3DTEXTUREI()
{
    /*
     * just in case someone comes back in with this pointer, set
     * an invalid vtbl.  Once we do that, it is safe to leave
     * the protected area...
        */
    while (LIST_FIRST(&this->blocks)) {
        LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&this->blocks);
        D3DI_RemoveTextureHandle(tBlock);
        // Remove from device
        LIST_DELETE(tBlock, devList);
        // Remove from texture
        LIST_DELETE(tBlock, list);
        D3DFree(tBlock);
    }

    if (lpTMBucket)
    {	//need to release the private lpDDS if any
        lpDDS1Tex->Release();
        lpDDS->Release();
        lpTMBucket->lpD3DTexI=NULL;
    }

}

/*
  * D3DText_QueryInterface
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::QueryInterface"

HRESULT D3DAPI DIRECT3DTEXTUREI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE_PTR(this)) {
            D3D_ERR( "Invalid IDirect3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if( !VALID_OUTPTR( ppvObj ) )
        {
            D3D_ERR( "Invalid obj ptr" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    
    /*
     * Punt to the owning interface.
     */
    ret = this->lpOwningIUnknown->QueryInterface(riid, ppvObj);
    return ret;
}

/*
  * D3DText_AddRef
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::AddRef"

ULONG D3DAPI DIRECT3DTEXTUREI::AddRef()
{
    ULONG ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    
    /*
     * Punt to owning interface.
     */
    ret = this->lpOwningIUnknown->AddRef();
    
    return ret;
} /* D3DText_AddRef */

/*
  * D3DText_Release
  */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::Release"

ULONG D3DAPI DIRECT3DTEXTUREI::Release()
{
    ULONG ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    
    /*
     * Punt to owning interface.
     */
    ret = this->lpOwningIUnknown->Release();
    
    return ret;
} /* D3DText_Release */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\testprov.cpp ===
//----------------------------------------------------------------------------
//
// testprov.cpp
//
// Test HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop
                       
//#ifdef DEBUG_PIPELINE

#include "testprov.h"
#include "testfile.h"
#include "stdio.h"

// Real rasterizer data
static D3DHALPROVIDER_INTERFACEDATA CurInterfaceData;
static IHalProvider    *pCurHalProvider;    // Real HAL provider

// Test provider data
static CTestHalProvider g_TestHalProvider;
static D3DHALPROVIDER_INTERFACEDATA TestInterfaceData;
static D3DHAL_CALLBACKS  TestCallbacks;
static D3DHAL_CALLBACKS2 TestCallbacks2;
static D3DHAL_CALLBACKS3 TestCallbacks3;
static char szFileName[_MAX_PATH] = "";     // Output file name
static FILE *fout = NULL;                   // Output file
DWORD g_dwTestHalFlags = 0;                   // Could be set from debugger

// Bits for g_dwTestHalFlags
const DWORD __TESTHAL_OUTPUTFILE    = 1;    // If need output to test file
const DWORD __TESTHAL_NORENDER      = 2;    // If no rendering needed

//---------------------------------------------------------------------
// Provides access to DIRECTDRAWSURFACE memory;
// In the constructor the surface is locked.
// In the destructor it is unlocked.
// LPBYTE() or LPVOID() casts will get pointer to the surface bits.
//
class CLockedDDSurface
{
public:
    CLockedDDSurface(LPDIRECTDRAWSURFACE surface);
    ~CLockedDDSurface();
    operator LPVOID() {return descr.lpSurface;}
    operator LPBYTE() {return (LPBYTE)descr.lpSurface;}
protected:
    DDSURFACEDESC descr;
    LPDIRECTDRAWSURFACE pSurface;
};

CLockedDDSurface::CLockedDDSurface(LPDIRECTDRAWSURFACE surface)
{
    pSurface = surface;
    memset (&descr, 0, sizeof(descr));
    descr.dwSize = sizeof(descr);
    surface->Lock(NULL, &descr,  0, NULL);
}

CLockedDDSurface::~CLockedDDSurface()
{
    if (descr.lpSurface) 
        pSurface->Unlock(descr.lpSurface);
}
//---------------------------------------------------------------------
void PutHeader(DWORD id, DWORD size)
{
    if (fout)
    {
        fwrite(&id, sizeof(DWORD), 1, fout);
        fwrite(&size, sizeof(DWORD), 1, fout);
    }
}
//---------------------------------------------------------------------
DWORD GetCurrentPosition()
{
    if (fout)
        return ftell(fout);
    else
        return 0;
}
//---------------------------------------------------------------------
void SetCurrentPosition(DWORD offset)
{
    if (fout)
        fseek(fout, offset, SEEK_SET);
}
//---------------------------------------------------------------------
void PutBuffer(LPVOID buffer, DWORD size)
{
    if (fout)
    {
        fwrite(buffer, 1, size, fout);
    }
}
//---------------------------------------------------------------------
// Implementation of test callbacks
//
DWORD __stdcall
TestDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA data)
{   
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        TFREC_DRAWONEPRIMITIVE rec;
        PutHeader(TFID_DRAWONEPRIMITIVE, 
                  sizeof(rec) + data->dwNumVertices*sizeof(D3DTLVERTEX));
        rec.primitiveType = data->PrimitiveType;
        rec.vertexCount = data->dwNumVertices;
        rec.vertexType = data->VertexType;
        rec.dwFlags = data->dwFlags;
        PutBuffer(&rec, sizeof(rec));
        PutBuffer(data->lpvVertices, sizeof(D3DTLVERTEX)*data->dwNumVertices);  
    }

    if (CurInterfaceData.pCallbacks2->DrawOnePrimitive &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks2->DrawOnePrimitive(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        TFREC_DRAWONEINDEXEDPRIMITIVE rec;
        PutHeader(TFID_DRAWONEINDEXEDPRIMITIVE, 
                  sizeof(rec) + 
                  data->dwNumVertices*sizeof(D3DTLVERTEX) +
                  data->dwNumIndices*sizeof(WORD));
        rec.primitiveType = data->PrimitiveType;
        rec.vertexCount = data->dwNumVertices;
        rec.vertexType = data->VertexType;
        rec.dwFlags = data->dwFlags;
        rec.indexCount = data->dwNumIndices;
        PutBuffer(&rec, sizeof(rec));
        PutBuffer(data->lpvVertices, sizeof(D3DTLVERTEX)*data->dwNumVertices);  
        PutBuffer(data->lpwIndices, sizeof(WORD)*data->dwNumIndices);  
    }

    if (CurInterfaceData.pCallbacks2->DrawOneIndexedPrimitive &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks2->DrawOneIndexedPrimitive(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        DWORD endPos = 0;
        LPVOID header = data->lpvData;
        PutHeader(0,0);     // Dummy header. Will be filled later
        DWORD startPos = GetCurrentPosition();
        for (;;)
        {
            DWORD nStates = ((D3DHAL_DRAWPRIMCOUNTS*)header)->wNumStateChanges;
            DWORD nVertices = ((D3DHAL_DRAWPRIMCOUNTS*)header)->wNumVertices;
            DWORD size;
        // Primitive header
            PutBuffer(header, sizeof(D3DHAL_DRAWPRIMCOUNTS));
            header = (char*)header + sizeof(D3DHAL_DRAWPRIMCOUNTS);
        // States
            size = nStates * sizeof(WORD);
            PutBuffer(header, size);
            header = (char*)header + size; 
            header = (LPVOID)(((ULONG_PTR)header + 31) & ~31);  //32 bytes aligned
        // Vertices
            if (!nVertices)
                break;
            size = nVertices * sizeof(D3DTLVERTEX);
            PutBuffer(header, size);

        }
        // Write record header
        endPos = GetCurrentPosition();
        SetCurrentPosition(startPos - sizeof(TF_HEADER));
        PutHeader(TFID_DRAWPRIMITIVES, endPos - startPos);
        SetCurrentPosition(endPos);
    }

    if (CurInterfaceData.pCallbacks2->DrawPrimitives &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks2->DrawPrimitives(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        TFREC_DRAWPRIMITIVES2 rec;
        rec.dwFlags = 0;
        PutBuffer(&rec, sizeof(rec));
        PutHeader(TFID_DRAWPRIMITIVES, sizeof(rec));
    }

    if (CurInterfaceData.pCallbacks3->DrawPrimitives2 &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks3->DrawPrimitives2(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestRenderState(LPD3DHAL_RENDERSTATEDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        // mem should be destroyed before calling to real driver to unlock
        // the surface
        CLockedDDSurface mem(data->lpExeBuf);
        LPD3DSTATE	pState;
        pState = (LPD3DSTATE)(LPBYTE(mem) + data->dwOffset);
        PutHeader(TFID_RENDERSTATE, sizeof(DWORD) + data->dwCount*sizeof(D3DSTATE));
        PutBuffer(&data->dwCount, sizeof(DWORD));
        for (DWORD i = 0; i < data->dwCount; i++) 
        {
            PutBuffer(&pState, sizeof(D3DSTATE));
	        pState++;
        }
    }

    if (CurInterfaceData.pCallbacks->RenderState)
        return CurInterfaceData.pCallbacks->RenderState(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        // mem and tlmem should be destroyed before calling the real driver
        // to unlock the surface
        CLockedDDSurface mem(data->lpExeBuf);
        CLockedDDSurface tlmem(data->lpTLBuf);
        LPBYTE        lpPrimData;
        LPD3DTLVERTEX lpTLData;	
        DWORD         i;
        DWORD         primitiveDataSize;
        DWORD         count = data->diInstruction.wCount;
        TFREC_RENDERPRIMITIVE rec;

        // Find the pointer to the first primitive structure
        lpPrimData = (LPBYTE)mem + data->dwOffset;

        // Find the pointer to the vertex data
        // Find the pointer to the first TL vertex
        lpTLData = (LPD3DTLVERTEX)((LPBYTE)tlmem + data->dwTLOffset);

        rec.status = data->dwStatus;
        rec.vertexType = D3DVT_TLVERTEX;
        // Find out number of vertices, primitive type and
        // size of primitive data
        switch (data->diInstruction.bOpcode) 
        {
        case D3DOP_POINT:
            rec.primitiveType = D3DPT_POINTLIST;
            rec.vertexCount = count;
            primitiveDataSize = count*sizeof(D3DPOINT);
	        break;
        case D3DOP_LINE:
            rec.primitiveType = D3DPT_LINELIST;
            rec.vertexCount = count*2;
            primitiveDataSize = count*sizeof(D3DLINE);
	        break;
        case D3DOP_SPAN:
            rec.primitiveType = D3DPT_POINTLIST;
            rec.vertexCount = count;
            primitiveDataSize = count*sizeof(D3DSPAN);
	        break;
        case D3DOP_TRIANGLE:
            rec.primitiveType = D3DPT_TRIANGLELIST;
            rec.vertexCount = count*3;
            primitiveDataSize = count*sizeof(D3DTRIANGLE);
	        break;
        }

        PutHeader(TFID_RENDERPRIMITIVE,
                  sizeof(D3DINSTRUCTION) +
                  sizeof(rec) + rec.vertexCount*sizeof(D3DTLVERTEX) +
                  primitiveDataSize);
        PutBuffer(&rec, sizeof(rec));
        PutBuffer(&data->diInstruction, sizeof(D3DINSTRUCTION));

        // Parse the structures based on the instruction
        switch (data->diInstruction.bOpcode) 
        {
        case D3DOP_POINT:
        {
	        LPD3DPOINT lpPoint = (LPD3DPOINT)lpPrimData;
	        for (i = 0; i < count; i++) 
            {
                PutBuffer(lpPoint, sizeof(D3DPOINT));
                PutBuffer(&lpTLData[lpPoint->wFirst], 
                          lpPoint->wCount*sizeof(D3DTLVERTEX));
                lpPoint++;
	        }
	        break;
        }
        case D3DOP_LINE:
        {
	        LPD3DLINE lpLine = (LPD3DLINE)lpPrimData;
	        for (i = 0; i < count; i++) 
            {
                PutBuffer(lpLine, sizeof(D3DLINE));
                PutBuffer(&lpTLData[lpLine->v1], sizeof(D3DTLVERTEX));
                PutBuffer(&lpTLData[lpLine->v2], sizeof(D3DTLVERTEX));
                lpLine++;
	        }
	        break;
        }
        case D3DOP_SPAN:
        {
	        LPD3DSPAN lpSpan = (LPD3DSPAN)lpPrimData;
	        for (i = 0; i < count; i++) 
            {
                PutBuffer(lpSpan, sizeof(D3DSPAN));
                PutBuffer(&lpTLData[lpSpan->wFirst], 
                          lpSpan->wCount*sizeof(D3DTLVERTEX));
                lpSpan++;
	        }
	        break;
        }
        case D3DOP_TRIANGLE:
        {
	        LPD3DTRIANGLE lpTri = (LPD3DTRIANGLE)lpPrimData;
	        for (i = 0; i < count; i++) 
            {
                PutBuffer(lpTri, sizeof(D3DTRIANGLE));
                PutBuffer(&lpTLData[lpTri->v1], sizeof(D3DTLVERTEX));
                PutBuffer(&lpTLData[lpTri->v2], sizeof(D3DTLVERTEX));
                PutBuffer(&lpTLData[lpTri->v3], sizeof(D3DTLVERTEX));
                lpTri++;
	        }
	        break;
        }
        }
    }

    if (CurInterfaceData.pCallbacks->RenderPrimitive &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks->RenderPrimitive(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestSceneCapture(LPD3DHAL_SCENECAPTUREDATA pData)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        PutHeader(TFID_SCENECAPTURE, sizeof(DWORD));
        PutBuffer(&pData->dwFlag, sizeof(DWORD));
        fflush(fout);
    }

    if (CurInterfaceData.pCallbacks->SceneCapture)
        return CurInterfaceData.pCallbacks->SceneCapture(pData);
    else
        return DDHAL_DRIVER_HANDLED;
}
//----------------------------------------------------------------------------
//
// TestHalProvider::QueryInterface
//
// Internal interface, no need to implement.
//
//----------------------------------------------------------------------------

STDMETHODIMP CTestHalProvider::QueryInterface(THIS_ REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//----------------------------------------------------------------------------
//
// CTestHalProvider::AddRef
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CTestHalProvider::AddRef(THIS)
{
    return 1;
}

//----------------------------------------------------------------------------
//
// TestHalProvider::Release
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CTestHalProvider::Release(THIS)
{
    if (fout)
    {
        fclose(fout);
        fout = NULL;
    }
    return pCurHalProvider->Release();
}
//----------------------------------------------------------------------------
//
// GetTestProvider
//
// Input:
//      riid and pCurrentHalProvider are equal to 
//      the currently selected provider.
//      GlobalData  - data provided by DDraw
//      fileName    - output file name
//      dwFlagsInp  - currently not used
//
// Returns:
//      the test HAL provider in ppHalProvider.
//
// Notes:
//      Only one instance of the test HAL is handled correctly.
//
//----------------------------------------------------------------------------
STDAPI GetTestHalProvider(REFIID riid, 
                          DDRAWI_DIRECTDRAW_GBL *GlobalData,
                          IHalProvider **ppHalProvider,
                          IHalProvider * pCurrentHalProvider, 
                          DWORD dwFlagsInp)
{
    *ppHalProvider = &g_TestHalProvider;
    pCurHalProvider = pCurrentHalProvider;

    g_dwTestHalFlags |= __TESTHAL_NORENDER;
    if (GetD3DRegValue(REG_SZ, "TestHalFile", &szFileName, _MAX_PATH) &&
        szFileName[0] != 0)
    {
        g_dwTestHalFlags |= __TESTHAL_OUTPUTFILE;
    }
    DWORD dwValue;
    if (GetD3DRegValue(REG_DWORD, "TestHalDoRender", &dwValue, sizeof(DWORD)) &&
        dwValue != 0)
    {
        g_dwTestHalFlags &= ~__TESTHAL_NORENDER;
    }
// Get interface from the current hal provider to call to it
    pCurrentHalProvider->GetInterface(GlobalData, &CurInterfaceData, 3);

    TestInterfaceData = CurInterfaceData;
    TestInterfaceData.pCallbacks  = &TestCallbacks;
    TestInterfaceData.pCallbacks2 = &TestCallbacks2;
    TestInterfaceData.pCallbacks3 = &TestCallbacks3;

// Initialize callbacks we do not care of

    TestCallbacks  = *CurInterfaceData.pCallbacks;
    TestCallbacks2 = *CurInterfaceData.pCallbacks2;
    TestCallbacks3 = *CurInterfaceData.pCallbacks3;

// Initialize callbacks that we want to intersept

    TestCallbacks.RenderState = &TestRenderState;
    TestCallbacks.RenderPrimitive = &TestRenderPrimitive;
    TestCallbacks.SceneCapture = &TestSceneCapture;

    TestCallbacks2.DrawOnePrimitive = &TestDrawOnePrimitive;
    TestCallbacks2.DrawOneIndexedPrimitive = &TestDrawOneIndexedPrimitive;
    TestCallbacks2.DrawPrimitives = &TestDrawPrimitives;

    TestCallbacks3.DrawPrimitives2 = &TestDrawPrimitives2;

    fout = NULL;
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        fout = fopen(szFileName, "wb");
        if (!fout)
            return DDERR_GENERIC;
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// CTestHalProvider::GetInterface
//
// Returns  test provider interface and real rasterizer global data.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CTestHalProvider::GetInterface(THIS_
                               LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                               LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                               DWORD dwVersion)
{
    *pInterfaceData = TestInterfaceData;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// TestHalProvider::GetCaps
//
// Returns real rasterizer caps.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CTestHalProvider::GetCaps(THIS_
                          LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                          LPD3DDEVICEDESC pHwDesc,
                          LPD3DDEVICEDESC pHelDesc,
                          DWORD dwVersion)
{
    return pCurHalProvider->GetCaps(pDdGbl, pHwDesc, pHelDesc, dwVersion);
}

//#endif //DEBUG_PIPELINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\sources.inc ===
MAJORCOMP=d3dim
MINORCOMP=d3dim
TARGETNAME=d3dim
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES = ..;$(INCLUDES);$(D3DDX6)\pipeln\inc
C_DEFINES = -DBUILD_D3D_LAYER $(C_DEFINES)

SOURCES=\
    ..\beginend.cpp \
    ..\buffer.cpp   \
    ..\bufiunk.cpp  \
    ..\d3dcreat.cpp \
    ..\d3ddev.cpp   \
    ..\d3diunk.cpp  \
    ..\d3dmem.cpp   \
    ..\d3dtex.cpp   \
    ..\deviunk.cpp  \
    ..\devstate.cpp \
    ..\dlld3d.cpp   \
    ..\dp2hal.cpp   \
    ..\dphal.cpp    \
    ..\dpoldhal.cpp \
    ..\genpick.cpp  \
    ..\halbuf.cpp   \
    ..\haldrv.cpp   \
    ..\halexe.cpp   \
    ..\halmat.cpp   \
    ..\halscene.cpp \
    ..\halstate.cpp \
    ..\haltex.cpp   \
    ..\hwprov.cpp   \
    ..\init.c       \
    ..\light.cpp    \
    ..\liunk.cpp    \
    ..\material.cpp \
    ..\matiunk.cpp  \
    ..\table.cpp    \
    ..\texiunk.cpp  \
    ..\texman.cpp   \
    ..\vertbuf.cpp  \
    ..\vwiunk.cpp   \
    ..\testprov.cpp \
    ..\vwport.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp

!ifndef  MAKEDLL
!if "$(__PRODUCT)" == "DX7"
MISCFILES=$(TARGET)
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\table.cpp ===
#include "pch.cpp"
#pragma hdrstop

D3DLINE LineListPrecomp[] = {
    { 0, 1 }, { 2, 3 }, { 4, 5 }, { 6, 7 }, 
    { 8, 9 }, { 10, 11 }, { 12, 13 }, { 14, 15 }, 
    { 16, 17 }, { 18, 19 }, { 20, 21 }, { 22, 23 }, 
    { 24, 25 }, { 26, 27 }, { 28, 29 }, { 30, 31 }, 
    { 32, 33 }, { 34, 35 }, { 36, 37 }, { 38, 39 }, 
    { 40, 41 }, { 42, 43 }, { 44, 45 }, { 46, 47 }, 
    { 48, 49 }, { 50, 51 }, { 52, 53 }, { 54, 55 }, 
    { 56, 57 }, { 58, 59 }, { 60, 61 }, { 62, 63 }, 
    { 64, 65 }, { 66, 67 }, { 68, 69 }, { 70, 71 }, 
    { 72, 73 }, { 74, 75 }, { 76, 77 }, { 78, 79 }, 
    { 80, 81 }, { 82, 83 }, { 84, 85 }, { 86, 87 }, 
    { 88, 89 }, { 90, 91 }, { 92, 93 }, { 94, 95 }, 
    { 96, 97 }, { 98, 99 }, { 100, 101 }, { 102, 103 }, 
    { 104, 105 }, { 106, 107 }, { 108, 109 }, { 110, 111 }, 
    { 112, 113 }, { 114, 115 }, { 116, 117 }, { 118, 119 }, 
    { 120, 121 }, { 122, 123 }, { 124, 125 }, { 126, 127 }, 
    { 128, 129 }, { 130, 131 }, { 132, 133 }, { 134, 135 }, 
    { 136, 137 }, { 138, 139 }, { 140, 141 }, { 142, 143 }, 
    { 144, 145 }, { 146, 147 }, { 148, 149 }, { 150, 151 }, 
    { 152, 153 }, { 154, 155 }, { 156, 157 }, { 158, 159 }, 
    { 160, 161 }, { 162, 163 }, { 164, 165 }, { 166, 167 }, 
    { 168, 169 }, { 170, 171 }, { 172, 173 }, { 174, 175 }, 
    { 176, 177 }, { 178, 179 }, { 180, 181 }, { 182, 183 }, 
    { 184, 185 }, { 186, 187 }, { 188, 189 }, { 190, 191 }, 
    { 192, 193 }, { 194, 195 }, { 196, 197 }, { 198, 199 }, 
    { 200, 201 }, { 202, 203 }, { 204, 205 }, { 206, 207 }, 
    { 208, 209 }, { 210, 211 }, { 212, 213 }, { 214, 215 }, 
    { 216, 217 }, { 218, 219 }, { 220, 221 }, { 222, 223 }, 
    { 224, 225 }, { 226, 227 }, { 228, 229 }, { 230, 231 }, 
    { 232, 233 }, { 234, 235 }, { 236, 237 }, { 238, 239 }, 
    { 240, 241 }, { 242, 243 }, { 244, 245 }, { 246, 247 }, 
    { 248, 249 }, { 250, 251 }, { 252, 253 }, { 254, 255 }, 
    { 256, 257 }, { 258, 259 }, { 260, 261 }, { 262, 263 }, 
    { 264, 265 }, { 266, 267 }, { 268, 269 }, { 270, 271 }, 
    { 272, 273 }, { 274, 275 }, { 276, 277 }, { 278, 279 }, 
    { 280, 281 }, { 282, 283 }, { 284, 285 }, { 286, 287 }, 
    { 288, 289 }, { 290, 291 }, { 292, 293 }, { 294, 295 }, 
    { 296, 297 }, { 298, 299 }, { 300, 301 }, { 302, 303 }, 
    { 304, 305 }, { 306, 307 }, { 308, 309 }, { 310, 311 }, 
    { 312, 313 }, { 314, 315 }, { 316, 317 }, { 318, 319 }, 
    { 320, 321 }, { 322, 323 }, { 324, 325 }, { 326, 327 }, 
    { 328, 329 }, { 330, 331 }, { 332, 333 }, { 334, 335 }, 
    { 336, 337 }, { 338, 339 }, { 340, 341 }, { 342, 343 }, 
    { 344, 345 }, { 346, 347 }, { 348, 349 }, { 350, 351 }, 
    { 352, 353 }, { 354, 355 }, { 356, 357 }, { 358, 359 }, 
    { 360, 361 }, { 362, 363 }, { 364, 365 }, { 366, 367 }, 
    { 368, 369 }, { 370, 371 }, { 372, 373 }, { 374, 375 }, 
    { 376, 377 }, { 378, 379 }, { 380, 381 }, { 382, 383 }, 
    { 384, 385 }, { 386, 387 }, { 388, 389 }, { 390, 391 }, 
    { 392, 393 }, { 394, 395 }, { 396, 397 }, { 398, 399 }, 
    { 400, 401 }, { 402, 403 }, { 404, 405 }, { 406, 407 }, 
    { 408, 409 }, { 410, 411 }, { 412, 413 }, { 414, 415 }, 
    { 416, 417 }, { 418, 419 }, { 420, 421 }, { 422, 423 }, 
    { 424, 425 }, { 426, 427 }, { 428, 429 }, { 430, 431 }, 
    { 432, 433 }, { 434, 435 }, { 436, 437 }, { 438, 439 }, 
    { 440, 441 }, { 442, 443 }, { 444, 445 }, { 446, 447 }, 
    { 448, 449 }, { 450, 451 }, { 452, 453 }, { 454, 455 }, 
    { 456, 457 }, { 458, 459 }, { 460, 461 }, { 462, 463 }, 
    { 464, 465 }, { 466, 467 }, { 468, 469 }, { 470, 471 }, 
    { 472, 473 }, { 474, 475 }, { 476, 477 }, { 478, 479 }, 
    { 480, 481 }, { 482, 483 }, { 484, 485 }, { 486, 487 }, 
    { 488, 489 }, { 490, 491 }, { 492, 493 }, { 494, 495 }, 
    { 496, 497 }, { 498, 499 }, { 500, 501 }, { 502, 503 }, 
    { 504, 505 }, { 506, 507 }, { 508, 509 }, { 510, 511 },
    { 512, 513 }, { 514, 515 }, { 516, 517 }, { 518, 519 },
    { 520, 521 }, { 522, 523 }, { 524, 525 }, { 526, 527 }, 
    { 528, 529 }, { 530, 531 }, { 532, 533 }, { 534, 535 }, 
    { 536, 537 }, { 538, 539 }, { 540, 541 }, { 542, 543 }, 
    { 544, 545 }, { 546, 547 }, { 548, 549 }, { 550, 551 }, 
    { 552, 553 }, { 554, 555 }, { 556, 557 }, { 558, 559 }, 
    { 560, 561 }, { 562, 563 }, { 564, 565 }, { 566, 567 }, 
    { 568, 569 }, { 570, 571 }, { 572, 573 }, { 574, 575 }, 
    { 576, 577 }, { 578, 579 }, { 580, 581 }, { 582, 583 }, 
    { 584, 585 }, { 586, 587 }, { 588, 589 }, { 590, 591 }, 
    { 592, 593 }, { 594, 595 }, { 596, 597 }, { 598, 599 }, 
    { 600, 601 }, { 602, 603 }, { 604, 605 }, { 606, 607 }, 
    { 608, 609 }, { 610, 611 }, { 612, 613 }, { 614, 615 }, 
    { 616, 617 }, { 618, 619 }, { 620, 621 }, { 622, 623 }, 
    { 624, 625 }, { 626, 627 }, { 628, 629 }, { 630, 631 }, 
    { 632, 633 }, { 634, 635 }, { 636, 637 }, { 638, 639 }, 
    { 640, 641 }, { 642, 643 }, { 644, 645 }, { 646, 647 }, 
    { 648, 649 }, { 650, 651 }, { 652, 653 }, { 654, 655 }, 
    { 656, 657 }, { 658, 659 }, { 660, 661 }, { 662, 663 }, 
    { 664, 665 }, { 666, 667 }, { 668, 669 }, { 670, 671 }, 
    { 672, 673 }, { 674, 675 }, { 676, 677 }, { 678, 679 }, 
    { 680, 681 }, { 682, 683 }, { 684, 685 }, { 686, 687 }, 
    { 688, 689 }, { 690, 691 }, { 692, 693 }, { 694, 695 }, 
    { 696, 697 }, { 698, 699 }, { 700, 701 }, { 702, 703 }, 
    { 704, 705 }, { 706, 707 }, { 708, 709 }, { 710, 711 }, 
    { 712, 713 }, { 714, 715 }, { 716, 717 }, { 718, 719 }, 
    { 720, 721 }, { 722, 723 }, { 724, 725 }, { 726, 727 }, 
    { 728, 729 }, { 730, 731 }, { 732, 733 }, { 734, 735 }, 
    { 736, 737 }, { 738, 739 }, { 740, 741 }, { 742, 743 }, 
    { 744, 745 }, { 746, 747 }, { 748, 749 }, { 750, 751 }, 
    { 752, 753 }, { 754, 755 }, { 756, 757 }, { 758, 759 }, 
    { 760, 761 }, { 762, 763 }, { 764, 765 }, { 766, 767 }, 
    { 768, 769 }, { 770, 771 }, { 772, 773 }, { 774, 775 }, 
    { 776, 777 }, { 778, 779 }, { 780, 781 }, { 782, 783 }, 
    { 784, 785 }, { 786, 787 }, { 788, 789 }, { 790, 791 }, 
    { 792, 793 }, { 794, 795 }, { 796, 797 }, { 798, 799 }, 
    { 800, 801 }, { 802, 803 }, { 804, 805 }, { 806, 807 }, 
    { 808, 809 }, { 810, 811 }, { 812, 813 }, { 814, 815 }, 
    { 816, 817 }, { 818, 819 }, { 820, 821 }, { 822, 823 }, 
    { 824, 825 }, { 826, 827 }, { 828, 829 }, { 830, 831 }, 
    { 832, 833 }, { 834, 835 }, { 836, 837 }, { 838, 839 }, 
    { 840, 841 }, { 842, 843 }, { 844, 845 }, { 846, 847 }, 
    { 848, 849 }, { 850, 851 }, { 852, 853 }, { 854, 855 }, 
    { 856, 857 }, { 858, 859 }, { 860, 861 }, { 862, 863 }, 
    { 864, 865 }, { 866, 867 }, { 868, 869 }, { 870, 871 }, 
    { 872, 873 }, { 874, 875 }, { 876, 877 }, { 878, 879 }, 
    { 880, 881 }, { 882, 883 }, { 884, 885 }, { 886, 887 }, 
    { 888, 889 }, { 890, 891 }, { 892, 893 }, { 894, 895 }, 
    { 896, 897 }, { 898, 899 }, { 900, 901 }, { 902, 903 }, 
    { 904, 905 }, { 906, 907 }, { 908, 909 }, { 910, 911 }, 
    { 912, 913 }, { 914, 915 }, { 916, 917 }, { 918, 919 }, 
    { 920, 921 }, { 922, 923 }, { 924, 925 }, { 926, 927 }, 
    { 928, 929 }, { 930, 931 }, { 932, 933 }, { 934, 935 }, 
    { 936, 937 }, { 938, 939 }, { 940, 941 }, { 942, 943 }, 
    { 944, 945 }, { 946, 947 }, { 948, 949 }, { 950, 951 }, 
    { 952, 953 }, { 954, 955 }, { 956, 957 }, { 958, 959 }, 
    { 960, 961 }, { 962, 963 }, { 964, 965 }, { 966, 967 }, 
    { 968, 969 }, { 970, 971 }, { 972, 973 }, { 974, 975 }, 
    { 976, 977 }, { 978, 979 }, { 980, 981 }, { 982, 983 }, 
    { 984, 985 }, { 986, 987 }, { 988, 989 }, { 990, 991 }, 
    { 992, 993 }, { 994, 995 }, { 996, 997 }, { 998, 999 }, 
    { 1000, 1001 }, { 1002, 1003 }, { 1004, 1005 }, { 1006, 1007 }, 
    { 1008, 1009 }, { 1010, 1011 }, { 1012, 1013 }, { 1014, 1015 }, 
    { 1016, 1017 }, { 1018, 1019 }, { 1020, 1021 }, { 1022, 1023 }, 
    };

D3DLINE LineStripPrecomp[] = {
    { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 }, 
    { 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 8 }, 
    { 8, 9 }, { 9, 10 }, { 10, 11 }, { 11, 12 }, 
    { 12, 13 }, { 13, 14 }, { 14, 15 }, { 15, 16 }, 
    { 16, 17 }, { 17, 18 }, { 18, 19 }, { 19, 20 }, 
    { 20, 21 }, { 21, 22 }, { 22, 23 }, { 23, 24 }, 
    { 24, 25 }, { 25, 26 }, { 26, 27 }, { 27, 28 }, 
    { 28, 29 }, { 29, 30 }, { 30, 31 }, { 31, 32 }, 
    { 32, 33 }, { 33, 34 }, { 34, 35 }, { 35, 36 }, 
    { 36, 37 }, { 37, 38 }, { 38, 39 }, { 39, 40 }, 
    { 40, 41 }, { 41, 42 }, { 42, 43 }, { 43, 44 }, 
    { 44, 45 }, { 45, 46 }, { 46, 47 }, { 47, 48 }, 
    { 48, 49 }, { 49, 50 }, { 50, 51 }, { 51, 52 }, 
    { 52, 53 }, { 53, 54 }, { 54, 55 }, { 55, 56 }, 
    { 56, 57 }, { 57, 58 }, { 58, 59 }, { 59, 60 }, 
    { 60, 61 }, { 61, 62 }, { 62, 63 }, { 63, 64 }, 
    { 64, 65 }, { 65, 66 }, { 66, 67 }, { 67, 68 }, 
    { 68, 69 }, { 69, 70 }, { 70, 71 }, { 71, 72 }, 
    { 72, 73 }, { 73, 74 }, { 74, 75 }, { 75, 76 }, 
    { 76, 77 }, { 77, 78 }, { 78, 79 }, { 79, 80 }, 
    { 80, 81 }, { 81, 82 }, { 82, 83 }, { 83, 84 }, 
    { 84, 85 }, { 85, 86 }, { 86, 87 }, { 87, 88 }, 
    { 88, 89 }, { 89, 90 }, { 90, 91 }, { 91, 92 }, 
    { 92, 93 }, { 93, 94 }, { 94, 95 }, { 95, 96 }, 
    { 96, 97 }, { 97, 98 }, { 98, 99 }, { 99, 100 }, 
    { 100, 101 }, { 101, 102 }, { 102, 103 }, { 103, 104 }, 
    { 104, 105 }, { 105, 106 }, { 106, 107 }, { 107, 108 }, 
    { 108, 109 }, { 109, 110 }, { 110, 111 }, { 111, 112 }, 
    { 112, 113 }, { 113, 114 }, { 114, 115 }, { 115, 116 }, 
    { 116, 117 }, { 117, 118 }, { 118, 119 }, { 119, 120 }, 
    { 120, 121 }, { 121, 122 }, { 122, 123 }, { 123, 124 }, 
    { 124, 125 }, { 125, 126 }, { 126, 127 }, { 127, 128 }, 
    { 128, 129 }, { 129, 130 }, { 130, 131 }, { 131, 132 }, 
    { 132, 133 }, { 133, 134 }, { 134, 135 }, { 135, 136 }, 
    { 136, 137 }, { 137, 138 }, { 138, 139 }, { 139, 140 }, 
    { 140, 141 }, { 141, 142 }, { 142, 143 }, { 143, 144 }, 
    { 144, 145 }, { 145, 146 }, { 146, 147 }, { 147, 148 }, 
    { 148, 149 }, { 149, 150 }, { 150, 151 }, { 151, 152 }, 
    { 152, 153 }, { 153, 154 }, { 154, 155 }, { 155, 156 }, 
    { 156, 157 }, { 157, 158 }, { 158, 159 }, { 159, 160 }, 
    { 160, 161 }, { 161, 162 }, { 162, 163 }, { 163, 164 }, 
    { 164, 165 }, { 165, 166 }, { 166, 167 }, { 167, 168 }, 
    { 168, 169 }, { 169, 170 }, { 170, 171 }, { 171, 172 }, 
    { 172, 173 }, { 173, 174 }, { 174, 175 }, { 175, 176 }, 
    { 176, 177 }, { 177, 178 }, { 178, 179 }, { 179, 180 }, 
    { 180, 181 }, { 181, 182 }, { 182, 183 }, { 183, 184 }, 
    { 184, 185 }, { 185, 186 }, { 186, 187 }, { 187, 188 }, 
    { 188, 189 }, { 189, 190 }, { 190, 191 }, { 191, 192 }, 
    { 192, 193 }, { 193, 194 }, { 194, 195 }, { 195, 196 }, 
    { 196, 197 }, { 197, 198 }, { 198, 199 }, { 199, 200 }, 
    { 200, 201 }, { 201, 202 }, { 202, 203 }, { 203, 204 }, 
    { 204, 205 }, { 205, 206 }, { 206, 207 }, { 207, 208 }, 
    { 208, 209 }, { 209, 210 }, { 210, 211 }, { 211, 212 }, 
    { 212, 213 }, { 213, 214 }, { 214, 215 }, { 215, 216 }, 
    { 216, 217 }, { 217, 218 }, { 218, 219 }, { 219, 220 }, 
    { 220, 221 }, { 221, 222 }, { 222, 223 }, { 223, 224 }, 
    { 224, 225 }, { 225, 226 }, { 226, 227 }, { 227, 228 }, 
    { 228, 229 }, { 229, 230 }, { 230, 231 }, { 231, 232 }, 
    { 232, 233 }, { 233, 234 }, { 234, 235 }, { 235, 236 }, 
    { 236, 237 }, { 237, 238 }, { 238, 239 }, { 239, 240 }, 
    { 240, 241 }, { 241, 242 }, { 242, 243 }, { 243, 244 }, 
    { 244, 245 }, { 245, 246 }, { 246, 247 }, { 247, 248 }, 
    { 248, 249 }, { 249, 250 }, { 250, 251 }, { 251, 252 }, 
    { 252, 253 }, { 253, 254 }, { 254, 255 }, { 255, 256 },
    { 256, 257 }, { 257, 258 }, { 258, 259 }, { 259, 260 }, 
    { 260, 261 }, { 261, 262 }, { 262, 263 }, { 263, 264 }, 
    { 264, 265 }, { 265, 266 }, { 266, 267 }, { 267, 268 }, 
    { 268, 269 }, { 269, 270 }, { 270, 271 }, { 271, 272 }, 
    { 272, 273 }, { 273, 274 }, { 274, 275 }, { 275, 276 }, 
    { 276, 277 }, { 277, 278 }, { 278, 279 }, { 279, 280 }, 
    { 280, 281 }, { 281, 282 }, { 282, 283 }, { 283, 284 }, 
    { 284, 285 }, { 285, 286 }, { 286, 287 }, { 287, 288 }, 
    { 288, 289 }, { 289, 290 }, { 290, 291 }, { 291, 292 }, 
    { 292, 293 }, { 293, 294 }, { 294, 295 }, { 295, 296 }, 
    { 296, 297 }, { 297, 298 }, { 298, 299 }, { 299, 300 }, 
    { 300, 301 }, { 301, 302 }, { 302, 303 }, { 303, 304 }, 
    { 304, 305 }, { 305, 306 }, { 306, 307 }, { 307, 308 }, 
    { 308, 309 }, { 309, 310 }, { 310, 311 }, { 311, 312 }, 
    { 312, 313 }, { 313, 314 }, { 314, 315 }, { 315, 316 }, 
    { 316, 317 }, { 317, 318 }, { 318, 319 }, { 319, 320 }, 
    { 320, 321 }, { 321, 322 }, { 322, 323 }, { 323, 324 }, 
    { 324, 325 }, { 325, 326 }, { 326, 327 }, { 327, 328 }, 
    { 328, 329 }, { 329, 330 }, { 330, 331 }, { 331, 332 }, 
    { 332, 333 }, { 333, 334 }, { 334, 335 }, { 335, 336 }, 
    { 336, 337 }, { 337, 338 }, { 338, 339 }, { 339, 340 }, 
    { 340, 341 }, { 341, 342 }, { 342, 343 }, { 343, 344 }, 
    { 344, 345 }, { 345, 346 }, { 346, 347 }, { 347, 348 }, 
    { 348, 349 }, { 349, 350 }, { 350, 351 }, { 351, 352 }, 
    { 352, 353 }, { 353, 354 }, { 354, 355 }, { 355, 356 }, 
    { 356, 357 }, { 357, 358 }, { 358, 359 }, { 359, 360 }, 
    { 360, 361 }, { 361, 362 }, { 362, 363 }, { 363, 364 }, 
    { 364, 365 }, { 365, 366 }, { 366, 367 }, { 367, 368 }, 
    { 368, 369 }, { 369, 370 }, { 370, 371 }, { 371, 372 }, 
    { 372, 373 }, { 373, 374 }, { 374, 375 }, { 375, 376 }, 
    { 376, 377 }, { 377, 378 }, { 378, 379 }, { 379, 380 }, 
    { 380, 381 }, { 381, 382 }, { 382, 383 }, { 383, 384 }, 
    { 384, 385 }, { 385, 386 }, { 386, 387 }, { 387, 388 }, 
    { 388, 389 }, { 389, 390 }, { 390, 391 }, { 391, 392 }, 
    { 392, 393 }, { 393, 394 }, { 394, 395 }, { 395, 396 }, 
    { 396, 397 }, { 397, 398 }, { 398, 399 }, { 399, 400 }, 
    { 400, 401 }, { 401, 402 }, { 402, 403 }, { 403, 404 }, 
    { 404, 405 }, { 405, 406 }, { 406, 407 }, { 407, 408 }, 
    { 408, 409 }, { 409, 410 }, { 410, 411 }, { 411, 412 }, 
    { 412, 413 }, { 413, 414 }, { 414, 415 }, { 415, 416 }, 
    { 416, 417 }, { 417, 418 }, { 418, 419 }, { 419, 420 }, 
    { 420, 421 }, { 421, 422 }, { 422, 423 }, { 423, 424 }, 
    { 424, 425 }, { 425, 426 }, { 426, 427 }, { 427, 428 }, 
    { 428, 429 }, { 429, 430 }, { 430, 431 }, { 431, 432 }, 
    { 432, 433 }, { 433, 434 }, { 434, 435 }, { 435, 436 }, 
    { 436, 437 }, { 437, 438 }, { 438, 439 }, { 439, 440 }, 
    { 440, 441 }, { 441, 442 }, { 442, 443 }, { 443, 444 }, 
    { 444, 445 }, { 445, 446 }, { 446, 447 }, { 447, 448 }, 
    { 448, 449 }, { 449, 450 }, { 450, 451 }, { 451, 452 }, 
    { 452, 453 }, { 453, 454 }, { 454, 455 }, { 455, 456 }, 
    { 456, 457 }, { 457, 458 }, { 458, 459 }, { 459, 460 }, 
    { 460, 461 }, { 461, 462 }, { 462, 463 }, { 463, 464 }, 
    { 464, 465 }, { 465, 466 }, { 466, 467 }, { 467, 468 }, 
    { 468, 469 }, { 469, 470 }, { 470, 471 }, { 471, 472 }, 
    { 472, 473 }, { 473, 474 }, { 474, 475 }, { 475, 476 }, 
    { 476, 477 }, { 477, 478 }, { 478, 479 }, { 479, 480 }, 
    { 480, 481 }, { 481, 482 }, { 482, 483 }, { 483, 484 }, 
    { 484, 485 }, { 485, 486 }, { 486, 487 }, { 487, 488 }, 
    { 488, 489 }, { 489, 490 }, { 490, 491 }, { 491, 492 }, 
    { 492, 493 }, { 493, 494 }, { 494, 495 }, { 495, 496 }, 
    { 496, 497 }, { 497, 498 }, { 498, 499 }, { 499, 500 }, 
    { 500, 501 }, { 501, 502 }, { 502, 503 }, { 503, 504 }, 
    { 504, 505 }, { 505, 506 }, { 506, 507 }, { 507, 508 }, 
    { 508, 509 }, { 509, 510 }, { 510, 511 }, { 511, 512 }, 
    };

D3DTRIANGLE TriangleListPrecomp[] = {
    { 0, 1, 2, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 3, 4, 5, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 6, 7, 8, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 9, 10, 11, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 12, 13, 14, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 15, 16, 17, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 18, 19, 20, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 21, 22, 23, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 24, 25, 26, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 27, 28, 29, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 30, 31, 32, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 33, 34, 35, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 36, 37, 38, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 39, 40, 41, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 42, 43, 44, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 45, 46, 47, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 48, 49, 50, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 51, 52, 53, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 54, 55, 56, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 57, 58, 59, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 60, 61, 62, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 63, 64, 65, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 66, 67, 68, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 69, 70, 71, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 72, 73, 74, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 75, 76, 77, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 78, 79, 80, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 81, 82, 83, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 84, 85, 86, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 87, 88, 89, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 90, 91, 92, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 93, 94, 95, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 96, 97, 98, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 99, 100, 101, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 102, 103, 104, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 105, 106, 107, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 108, 109, 110, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 111, 112, 113, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 114, 115, 116, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 117, 118, 119, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 120, 121, 122, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 123, 124, 125, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 126, 127, 128, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 129, 130, 131, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 132, 133, 134, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 135, 136, 137, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 138, 139, 140, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 141, 142, 143, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 144, 145, 146, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 147, 148, 149, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 150, 151, 152, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 153, 154, 155, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 156, 157, 158, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 159, 160, 161, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 162, 163, 164, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 165, 166, 167, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 168, 169, 170, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 171, 172, 173, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 174, 175, 176, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 177, 178, 179, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 180, 181, 182, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 183, 184, 185, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 186, 187, 188, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 189, 190, 191, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 192, 193, 194, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 195, 196, 197, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 198, 199, 200, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 201, 202, 203, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 204, 205, 206, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 207, 208, 209, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 210, 211, 212, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 213, 214, 215, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 216, 217, 218, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 219, 220, 221, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 222, 223, 224, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 225, 226, 227, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 228, 229, 230, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 231, 232, 233, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 234, 235, 236, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 237, 238, 239, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 240, 241, 242, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 243, 244, 245, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 246, 247, 248, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 249, 250, 251, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 252, 253, 254, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 255, 256, 257, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 258, 259, 260, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 261, 262, 263, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 264, 265, 266, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 267, 268, 269, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 270, 271, 272, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 273, 274, 275, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 276, 277, 278, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 279, 280, 281, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 282, 283, 284, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 285, 286, 287, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 288, 289, 290, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 291, 292, 293, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 294, 295, 296, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 297, 298, 299, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 300, 301, 302, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 303, 304, 305, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 306, 307, 308, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 309, 310, 311, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 312, 313, 314, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 315, 316, 317, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 318, 319, 320, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 321, 322, 323, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 324, 325, 326, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 327, 328, 329, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 330, 331, 332, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 333, 334, 335, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 336, 337, 338, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 339, 340, 341, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 342, 343, 344, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 345, 346, 347, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 348, 349, 350, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 351, 352, 353, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 354, 355, 356, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 357, 358, 359, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 360, 361, 362, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 363, 364, 365, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 366, 367, 368, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 369, 370, 371, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 372, 373, 374, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 375, 376, 377, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 378, 379, 380, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 381, 382, 383, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 384, 385, 386, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 387, 388, 389, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 390, 391, 392, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 393, 394, 395, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 396, 397, 398, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 399, 400, 401, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 402, 403, 404, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 405, 406, 407, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 408, 409, 410, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 411, 412, 413, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 414, 415, 416, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 417, 418, 419, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 420, 421, 422, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 423, 424, 425, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 426, 427, 428, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 429, 430, 431, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 432, 433, 434, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 435, 436, 437, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 438, 439, 440, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 441, 442, 443, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 444, 445, 446, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 447, 448, 449, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 450, 451, 452, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 453, 454, 455, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 456, 457, 458, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 459, 460, 461, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 462, 463, 464, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 465, 466, 467, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 468, 469, 470, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 471, 472, 473, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 474, 475, 476, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 477, 478, 479, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 480, 481, 482, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 483, 484, 485, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 486, 487, 488, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 489, 490, 491, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 492, 493, 494, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 495, 496, 497, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 498, 499, 500, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 501, 502, 503, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 504, 505, 506, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 507, 508, 509, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 510, 511, 512, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 513, 514, 515, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 516, 517, 518, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 519, 520, 521, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 522, 523, 524, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 525, 526, 527, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 528, 529, 530, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 531, 532, 533, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 534, 535, 536, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 537, 538, 539, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 540, 541, 542, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 543, 544, 545, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 546, 547, 548, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 549, 550, 551, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 552, 553, 554, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 555, 556, 557, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 558, 559, 560, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 561, 562, 563, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 564, 565, 566, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 567, 568, 569, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 570, 571, 572, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 573, 574, 575, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 576, 577, 578, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 579, 580, 581, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 582, 583, 584, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 585, 586, 587, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 588, 589, 590, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 591, 592, 593, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 594, 595, 596, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 597, 598, 599, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 600, 601, 602, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 603, 604, 605, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 606, 607, 608, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 609, 610, 611, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 612, 613, 614, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 615, 616, 617, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 618, 619, 620, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 621, 622, 623, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 624, 625, 626, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 627, 628, 629, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 630, 631, 632, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 633, 634, 635, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 636, 637, 638, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 639, 640, 641, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 642, 643, 644, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 645, 646, 647, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 648, 649, 650, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 651, 652, 653, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 654, 655, 656, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 657, 658, 659, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 660, 661, 662, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 663, 664, 665, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 666, 667, 668, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 669, 670, 671, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 672, 673, 674, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 675, 676, 677, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 678, 679, 680, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 681, 682, 683, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 684, 685, 686, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 687, 688, 689, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 690, 691, 692, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 693, 694, 695, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 696, 697, 698, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 699, 700, 701, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 702, 703, 704, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 705, 706, 707, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 708, 709, 710, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 711, 712, 713, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 714, 715, 716, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 717, 718, 719, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 720, 721, 722, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 723, 724, 725, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 726, 727, 728, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 729, 730, 731, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 732, 733, 734, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 735, 736, 737, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 738, 739, 740, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 741, 742, 743, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 744, 745, 746, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 747, 748, 749, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 750, 751, 752, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 753, 754, 755, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 756, 757, 758, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 759, 760, 761, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 762, 763, 764, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 765, 766, 767, D3DTRIFLAG_EDGEENABLETRIANGLE },
};

D3DTRIANGLE TriangleStripPrecomp[] = {
    { 0, 1, 2, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 1, 3, 2, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 2, 3, 4, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 3, 5, 4, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 4, 5, 6, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 5, 7, 6, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 6, 7, 8, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 7, 9, 8, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 8, 9, 10, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 9, 11, 10, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 10, 11, 12, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 11, 13, 12, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 12, 13, 14, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 13, 15, 14, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 14, 15, 16, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 15, 17, 16, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 16, 17, 18, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 17, 19, 18, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 18, 19, 20, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 19, 21, 20, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 20, 21, 22, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 21, 23, 22, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 22, 23, 24, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 23, 25, 24, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 24, 25, 26, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 25, 27, 26, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 26, 27, 28, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 27, 29, 28, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 28, 29, 30, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 29, 31, 30, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 30, 31, 32, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 31, 33, 32, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 32, 33, 34, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 33, 35, 34, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 34, 35, 36, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 35, 37, 36, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 36, 37, 38, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 37, 39, 38, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 38, 39, 40, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 39, 41, 40, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 40, 41, 42, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 41, 43, 42, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 42, 43, 44, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 43, 45, 44, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 44, 45, 46, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 45, 47, 46, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 46, 47, 48, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 47, 49, 48, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 48, 49, 50, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 49, 51, 50, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 50, 51, 52, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 51, 53, 52, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 52, 53, 54, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 53, 55, 54, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 54, 55, 56, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 55, 57, 56, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 56, 57, 58, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 57, 59, 58, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 58, 59, 60, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 59, 61, 60, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 60, 61, 62, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 61, 63, 62, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 62, 63, 64, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 63, 65, 64, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 64, 65, 66, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 65, 67, 66, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 66, 67, 68, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 67, 69, 68, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 68, 69, 70, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 69, 71, 70, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 70, 71, 72, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 71, 73, 72, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 72, 73, 74, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 73, 75, 74, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 74, 75, 76, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 75, 77, 76, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 76, 77, 78, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 77, 79, 78, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 78, 79, 80, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 79, 81, 80, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 80, 81, 82, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 81, 83, 82, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 82, 83, 84, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 83, 85, 84, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 84, 85, 86, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 85, 87, 86, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 86, 87, 88, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 87, 89, 88, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 88, 89, 90, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 89, 91, 90, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 90, 91, 92, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 91, 93, 92, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 92, 93, 94, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 93, 95, 94, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 94, 95, 96, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 95, 97, 96, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 96, 97, 98, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 97, 99, 98, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 98, 99, 100, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 99, 101, 100, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 100, 101, 102, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 101, 103, 102, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 102, 103, 104, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 103, 105, 104, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 104, 105, 106, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 105, 107, 106, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 106, 107, 108, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 107, 109, 108, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 108, 109, 110, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 109, 111, 110, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 110, 111, 112, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 111, 113, 112, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 112, 113, 114, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 113, 115, 114, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 114, 115, 116, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 115, 117, 116, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 116, 117, 118, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 117, 119, 118, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 118, 119, 120, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 119, 121, 120, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 120, 121, 122, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 121, 123, 122, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 122, 123, 124, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 123, 125, 124, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 124, 125, 126, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 125, 127, 126, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 126, 127, 128, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 127, 129, 128, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 128, 129, 130, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 129, 131, 130, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 130, 131, 132, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 131, 133, 132, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 132, 133, 134, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 133, 135, 134, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 134, 135, 136, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 135, 137, 136, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 136, 137, 138, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 137, 139, 138, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 138, 139, 140, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 139, 141, 140, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 140, 141, 142, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 141, 143, 142, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 142, 143, 144, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 143, 145, 144, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 144, 145, 146, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 145, 147, 146, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 146, 147, 148, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 147, 149, 148, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 148, 149, 150, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 149, 151, 150, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 150, 151, 152, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 151, 153, 152, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 152, 153, 154, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 153, 155, 154, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 154, 155, 156, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 155, 157, 156, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 156, 157, 158, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 157, 159, 158, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 158, 159, 160, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 159, 161, 160, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 160, 161, 162, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 161, 163, 162, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 162, 163, 164, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 163, 165, 164, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 164, 165, 166, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 165, 167, 166, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 166, 167, 168, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 167, 169, 168, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 168, 169, 170, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 169, 171, 170, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 170, 171, 172, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 171, 173, 172, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 172, 173, 174, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 173, 175, 174, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 174, 175, 176, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 175, 177, 176, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 176, 177, 178, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 177, 179, 178, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 178, 179, 180, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 179, 181, 180, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 180, 181, 182, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 181, 183, 182, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 182, 183, 184, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 183, 185, 184, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 184, 185, 186, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 185, 187, 186, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 186, 187, 188, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 187, 189, 188, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 188, 189, 190, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 189, 191, 190, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 190, 191, 192, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 191, 193, 192, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 192, 193, 194, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 193, 195, 194, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 194, 195, 196, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 195, 197, 196, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 196, 197, 198, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 197, 199, 198, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 198, 199, 200, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 199, 201, 200, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 200, 201, 202, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 201, 203, 202, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 202, 203, 204, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 203, 205, 204, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 204, 205, 206, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 205, 207, 206, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 206, 207, 208, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 207, 209, 208, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 208, 209, 210, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 209, 211, 210, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 210, 211, 212, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 211, 213, 212, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 212, 213, 214, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 213, 215, 214, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 214, 215, 216, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 215, 217, 216, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 216, 217, 218, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 217, 219, 218, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 218, 219, 220, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 219, 221, 220, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 220, 221, 222, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 221, 223, 222, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 222, 223, 224, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 223, 225, 224, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 224, 225, 226, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 225, 227, 226, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 226, 227, 228, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 227, 229, 228, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 228, 229, 230, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 229, 231, 230, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 230, 231, 232, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 231, 233, 232, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 232, 233, 234, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 233, 235, 234, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 234, 235, 236, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 235, 237, 236, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 236, 237, 238, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 237, 239, 238, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 238, 239, 240, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 239, 241, 240, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 240, 241, 242, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 241, 243, 242, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 242, 243, 244, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 243, 245, 244, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 244, 245, 246, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 245, 247, 246, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 246, 247, 248, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 247, 249, 248, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 248, 249, 250, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 249, 251, 250, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 250, 251, 252, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 251, 253, 252, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 252, 253, 254, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 253, 255, 254, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 254, 255, 256, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 255, 257, 256, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    };

D3DTRIANGLE TriangleFanPrecomp[] = {
    { 1, 2, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 2, 3, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 3, 4, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 4, 5, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 5, 6, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 6, 7, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 7, 8, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 8, 9, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 9, 10, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 10, 11, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 11, 12, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 12, 13, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 13, 14, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 14, 15, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 15, 16, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 16, 17, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 17, 18, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 18, 19, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 19, 20, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 20, 21, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 21, 22, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 22, 23, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 23, 24, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 24, 25, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 25, 26, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 26, 27, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 27, 28, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 28, 29, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 29, 30, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 30, 31, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 31, 32, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 32, 33, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 33, 34, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 34, 35, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 35, 36, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 36, 37, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 37, 38, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 38, 39, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 39, 40, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 40, 41, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 41, 42, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 42, 43, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 43, 44, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 44, 45, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 45, 46, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 46, 47, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 47, 48, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 48, 49, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 49, 50, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 50, 51, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 51, 52, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 52, 53, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 53, 54, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 54, 55, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 55, 56, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 56, 57, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 57, 58, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 58, 59, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 59, 60, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 60, 61, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 61, 62, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 62, 63, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 63, 64, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 64, 65, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 65, 66, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 66, 67, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 67, 68, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 68, 69, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 69, 70, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 70, 71, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 71, 72, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 72, 73, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 73, 74, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 74, 75, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 75, 76, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 76, 77, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 77, 78, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 78, 79, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 79, 80, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 80, 81, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 81, 82, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 82, 83, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 83, 84, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 84, 85, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 85, 86, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 86, 87, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 87, 88, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 88, 89, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 89, 90, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 90, 91, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 91, 92, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 92, 93, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 93, 94, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 94, 95, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 95, 96, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 96, 97, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 97, 98, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 98, 99, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 99, 100, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 100, 101, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 101, 102, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 102, 103, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 103, 104, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 104, 105, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 105, 106, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 106, 107, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 107, 108, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 108, 109, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 109, 110, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 110, 111, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 111, 112, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 112, 113, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 113, 114, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 114, 115, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 115, 116, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 116, 117, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 117, 118, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 118, 119, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 119, 120, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 120, 121, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 121, 122, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 122, 123, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 123, 124, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 124, 125, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 125, 126, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 126, 127, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 127, 128, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 128, 129, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 129, 130, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 130, 131, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 131, 132, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 132, 133, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 133, 134, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 134, 135, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 135, 136, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 136, 137, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 137, 138, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 138, 139, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 139, 140, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 140, 141, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 141, 142, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 142, 143, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 143, 144, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 144, 145, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 145, 146, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 146, 147, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 147, 148, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 148, 149, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 149, 150, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 150, 151, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 151, 152, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 152, 153, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 153, 154, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 154, 155, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 155, 156, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 156, 157, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 157, 158, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 158, 159, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 159, 160, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 160, 161, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 161, 162, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 162, 163, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 163, 164, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 164, 165, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 165, 166, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 166, 167, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 167, 168, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 168, 169, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 169, 170, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 170, 171, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 171, 172, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 172, 173, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 173, 174, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 174, 175, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 175, 176, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 176, 177, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 177, 178, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 178, 179, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 179, 180, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 180, 181, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 181, 182, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 182, 183, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 183, 184, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 184, 185, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 185, 186, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 186, 187, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 187, 188, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 188, 189, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 189, 190, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 190, 191, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 191, 192, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 192, 193, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 193, 194, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 194, 195, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 195, 196, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 196, 197, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 197, 198, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 198, 199, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 199, 200, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 200, 201, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 201, 202, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 202, 203, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 203, 204, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 204, 205, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 205, 206, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 206, 207, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 207, 208, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 208, 209, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 209, 210, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 210, 211, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 211, 212, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 212, 213, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 213, 214, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 214, 215, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 215, 216, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 216, 217, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 217, 218, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 218, 219, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 219, 220, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 220, 221, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 221, 222, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 222, 223, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 223, 224, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 224, 225, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 225, 226, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 226, 227, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 227, 228, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 228, 229, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 229, 230, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 230, 231, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 231, 232, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 232, 233, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 233, 234, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 234, 235, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 235, 236, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 236, 237, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 237, 238, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 238, 239, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 239, 240, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 240, 241, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 241, 242, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 242, 243, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 243, 244, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 244, 245, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 245, 246, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 246, 247, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 247, 248, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 248, 249, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 249, 250, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 250, 251, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 251, 252, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 252, 253, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 253, 254, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 254, 255, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 255, 256, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 256, 257, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
};

/* This can be (and should be) replaced by LineListPrecomp */
WORD TriangleListPrecompDP[][3] = {
    { 0, 1, 2 }, { 3, 4, 5 },
    { 6, 7, 8 }, { 9, 10, 11 },
    { 12, 13, 14 }, { 15, 16, 17 },
    { 18, 19, 20 }, { 21, 22, 23 },
    { 24, 25, 26 }, { 27, 28, 29 },
    { 30, 31, 32 }, { 33, 34, 35 },
    { 36, 37, 38 }, { 39, 40, 41 },
    { 42, 43, 44 }, { 45, 46, 47 },
    { 48, 49, 50 }, { 51, 52, 53 },
    { 54, 55, 56 }, { 57, 58, 59 },
    { 60, 61, 62 }, { 63, 64, 65 },
    { 66, 67, 68 }, { 69, 70, 71 },
    { 72, 73, 74 }, { 75, 76, 77 },
    { 78, 79, 80 }, { 81, 82, 83 },
    { 84, 85, 86 }, { 87, 88, 89 },
    { 90, 91, 92 }, { 93, 94, 95 },
    { 96, 97, 98 }, { 99, 100, 101 },
    { 102, 103, 104 }, { 105, 106, 107 },
    { 108, 109, 110 }, { 111, 112, 113 },
    { 114, 115, 116 }, { 117, 118, 119 },
    { 120, 121, 122 }, { 123, 124, 125 },
    { 126, 127, 128 }, { 129, 130, 131 },
    { 132, 133, 134 }, { 135, 136, 137 },
    { 138, 139, 140 }, { 141, 142, 143 },
    { 144, 145, 146 }, { 147, 148, 149 },
    { 150, 151, 152 }, { 153, 154, 155 },
    { 156, 157, 158 }, { 159, 160, 161 },
    { 162, 163, 164 }, { 165, 166, 167 },
    { 168, 169, 170 }, { 171, 172, 173 },
    { 174, 175, 176 }, { 177, 178, 179 },
    { 180, 181, 182 }, { 183, 184, 185 },
    { 186, 187, 188 }, { 189, 190, 191 },
    { 192, 193, 194 }, { 195, 196, 197 },
    { 198, 199, 200 }, { 201, 202, 203 },
    { 204, 205, 206 }, { 207, 208, 209 },
    { 210, 211, 212 }, { 213, 214, 215 },
    { 216, 217, 218 }, { 219, 220, 221 },
    { 222, 223, 224 }, { 225, 226, 227 },
    { 228, 229, 230 }, { 231, 232, 233 },
    { 234, 235, 236 }, { 237, 238, 239 },
    { 240, 241, 242 }, { 243, 244, 245 },
    { 246, 247, 248 }, { 249, 250, 251 },
    { 252, 253, 254 }, { 255, 256, 257 },
    { 258, 259, 260 }, { 261, 262, 263 },
    { 264, 265, 266 }, { 267, 268, 269 },
    { 270, 271, 272 }, { 273, 274, 275 },
    { 276, 277, 278 }, { 279, 280, 281 },
    { 282, 283, 284 }, { 285, 286, 287 },
    { 288, 289, 290 }, { 291, 292, 293 },
    { 294, 295, 296 }, { 297, 298, 299 },
    { 300, 301, 302 }, { 303, 304, 305 },
    { 306, 307, 308 }, { 309, 310, 311 },
    { 312, 313, 314 }, { 315, 316, 317 },
    { 318, 319, 320 }, { 321, 322, 323 },
    { 324, 325, 326 }, { 327, 328, 329 },
    { 330, 331, 332 }, { 333, 334, 335 },
    { 336, 337, 338 }, { 339, 340, 341 },
    { 342, 343, 344 }, { 345, 346, 347 },
    { 348, 349, 350 }, { 351, 352, 353 },
    { 354, 355, 356 }, { 357, 358, 359 },
    { 360, 361, 362 }, { 363, 364, 365 },
    { 366, 367, 368 }, { 369, 370, 371 },
    { 372, 373, 374 }, { 375, 376, 377 },
    { 378, 379, 380 }, { 381, 382, 383 },
    { 384, 385, 386 }, { 387, 388, 389 },
    { 390, 391, 392 }, { 393, 394, 395 },
    { 396, 397, 398 }, { 399, 400, 401 },
    { 402, 403, 404 }, { 405, 406, 407 },
    { 408, 409, 410 }, { 411, 412, 413 },
    { 414, 415, 416 }, { 417, 418, 419 },
    { 420, 421, 422 }, { 423, 424, 425 },
    { 426, 427, 428 }, { 429, 430, 431 },
    { 432, 433, 434 }, { 435, 436, 437 },
    { 438, 439, 440 }, { 441, 442, 443 },
    { 444, 445, 446 }, { 447, 448, 449 },
    { 450, 451, 452 }, { 453, 454, 455 },
    { 456, 457, 458 }, { 459, 460, 461 },
    { 462, 463, 464 }, { 465, 466, 467 },
    { 468, 469, 470 }, { 471, 472, 473 },
    { 474, 475, 476 }, { 477, 478, 479 },
    { 480, 481, 482 }, { 483, 484, 485 },
    { 486, 487, 488 }, { 489, 490, 491 },
    { 492, 493, 494 }, { 495, 496, 497 },
    { 498, 499, 500 }, { 501, 502, 503 },
    { 504, 505, 506 }, { 507, 508, 509 },
    { 510, 511, 512 }, { 513, 514, 515 },
    { 516, 517, 518 }, { 519, 520, 521 },
    { 522, 523, 524 }, { 525, 526, 527 },
    { 528, 529, 530 }, { 531, 532, 533 },
    { 534, 535, 536 }, { 537, 538, 539 },
    { 540, 541, 542 }, { 543, 544, 545 },
    { 546, 547, 548 }, { 549, 550, 551 },
    { 552, 553, 554 }, { 555, 556, 557 },
    { 558, 559, 560 }, { 561, 562, 563 },
    { 564, 565, 566 }, { 567, 568, 569 },
    { 570, 571, 572 }, { 573, 574, 575 },
    { 576, 577, 578 }, { 579, 580, 581 },
    { 582, 583, 584 }, { 585, 586, 587 },
    { 588, 589, 590 }, { 591, 592, 593 },
    { 594, 595, 596 }, { 597, 598, 599 },
    { 600, 601, 602 }, { 603, 604, 605 },
    { 606, 607, 608 }, { 609, 610, 611 },
    { 612, 613, 614 }, { 615, 616, 617 },
    { 618, 619, 620 }, { 621, 622, 623 },
    { 624, 625, 626 }, { 627, 628, 629 },
    { 630, 631, 632 }, { 633, 634, 635 },
    { 636, 637, 638 }, { 639, 640, 641 },
    { 642, 643, 644 }, { 645, 646, 647 },
    { 648, 649, 650 }, { 651, 652, 653 },
    { 654, 655, 656 }, { 657, 658, 659 },
    { 660, 661, 662 }, { 663, 664, 665 },
    { 666, 667, 668 }, { 669, 670, 671 },
    { 672, 673, 674 }, { 675, 676, 677 },
    { 678, 679, 680 }, { 681, 682, 683 },
    { 684, 685, 686 }, { 687, 688, 689 },
    { 690, 691, 692 }, { 693, 694, 695 },
    { 696, 697, 698 }, { 699, 700, 701 },
    { 702, 703, 704 }, { 705, 706, 707 },
    { 708, 709, 710 }, { 711, 712, 713 },
    { 714, 715, 716 }, { 717, 718, 719 },
    { 720, 721, 722 }, { 723, 724, 725 },
    { 726, 727, 728 }, { 729, 730, 731 },
    { 732, 733, 734 }, { 735, 736, 737 },
    { 738, 739, 740 }, { 741, 742, 743 },
    { 744, 745, 746 }, { 747, 748, 749 },
    { 750, 751, 752 }, { 753, 754, 755 },
    { 756, 757, 758 }, { 759, 760, 761 },
    { 762, 763, 764 }, { 765, 766, 767 },
};

WORD TriangleStripPrecompDP[][3] = {
    { 0, 1, 2 }, { 1, 3, 2 },
    { 2, 3, 4 }, { 3, 5, 4 },
    { 4, 5, 6 }, { 5, 7, 6 },
    { 6, 7, 8 }, { 7, 9, 8 },
    { 8, 9, 10 }, { 9, 11, 10 },
    { 10, 11, 12 }, { 11, 13, 12 },
    { 12, 13, 14 }, { 13, 15, 14 },
    { 14, 15, 16 }, { 15, 17, 16 },
    { 16, 17, 18 }, { 17, 19, 18 },
    { 18, 19, 20 }, { 19, 21, 20 },
    { 20, 21, 22 }, { 21, 23, 22 },
    { 22, 23, 24 }, { 23, 25, 24 },
    { 24, 25, 26 }, { 25, 27, 26 },
    { 26, 27, 28 }, { 27, 29, 28 },
    { 28, 29, 30 }, { 29, 31, 30 },
    { 30, 31, 32 }, { 31, 33, 32 },
    { 32, 33, 34 }, { 33, 35, 34 },
    { 34, 35, 36 }, { 35, 37, 36 },
    { 36, 37, 38 }, { 37, 39, 38 },
    { 38, 39, 40 }, { 39, 41, 40 },
    { 40, 41, 42 }, { 41, 43, 42 },
    { 42, 43, 44 }, { 43, 45, 44 },
    { 44, 45, 46 }, { 45, 47, 46 },
    { 46, 47, 48 }, { 47, 49, 48 },
    { 48, 49, 50 }, { 49, 51, 50 },
    { 50, 51, 52 }, { 51, 53, 52 },
    { 52, 53, 54 }, { 53, 55, 54 },
    { 54, 55, 56 }, { 55, 57, 56 },
    { 56, 57, 58 }, { 57, 59, 58 },
    { 58, 59, 60 }, { 59, 61, 60 },
    { 60, 61, 62 }, { 61, 63, 62 },
    { 62, 63, 64 }, { 63, 65, 64 },
    { 64, 65, 66 }, { 65, 67, 66 },
    { 66, 67, 68 }, { 67, 69, 68 },
    { 68, 69, 70 }, { 69, 71, 70 },
    { 70, 71, 72 }, { 71, 73, 72 },
    { 72, 73, 74 }, { 73, 75, 74 },
    { 74, 75, 76 }, { 75, 77, 76 },
    { 76, 77, 78 }, { 77, 79, 78 },
    { 78, 79, 80 }, { 79, 81, 80 },
    { 80, 81, 82 }, { 81, 83, 82 },
    { 82, 83, 84 }, { 83, 85, 84 },
    { 84, 85, 86 }, { 85, 87, 86 },
    { 86, 87, 88 }, { 87, 89, 88 },
    { 88, 89, 90 }, { 89, 91, 90 },
    { 90, 91, 92 }, { 91, 93, 92 },
    { 92, 93, 94 }, { 93, 95, 94 },
    { 94, 95, 96 }, { 95, 97, 96 },
    { 96, 97, 98 }, { 97, 99, 98 },
    { 98, 99, 100 }, { 99, 101, 100 },
    { 100, 101, 102 }, { 101, 103, 102 },
    { 102, 103, 104 }, { 103, 105, 104 },
    { 104, 105, 106 }, { 105, 107, 106 },
    { 106, 107, 108 }, { 107, 109, 108 },
    { 108, 109, 110 }, { 109, 111, 110 },
    { 110, 111, 112 }, { 111, 113, 112 },
    { 112, 113, 114 }, { 113, 115, 114 },
    { 114, 115, 116 }, { 115, 117, 116 },
    { 116, 117, 118 }, { 117, 119, 118 },
    { 118, 119, 120 }, { 119, 121, 120 },
    { 120, 121, 122 }, { 121, 123, 122 },
    { 122, 123, 124 }, { 123, 125, 124 },
    { 124, 125, 126 }, { 125, 127, 126 },
    { 126, 127, 128 }, { 127, 129, 128 },
    { 128, 129, 130 }, { 129, 131, 130 },
    { 130, 131, 132 }, { 131, 133, 132 },
    { 132, 133, 134 }, { 133, 135, 134 },
    { 134, 135, 136 }, { 135, 137, 136 },
    { 136, 137, 138 }, { 137, 139, 138 },
    { 138, 139, 140 }, { 139, 141, 140 },
    { 140, 141, 142 }, { 141, 143, 142 },
    { 142, 143, 144 }, { 143, 145, 144 },
    { 144, 145, 146 }, { 145, 147, 146 },
    { 146, 147, 148 }, { 147, 149, 148 },
    { 148, 149, 150 }, { 149, 151, 150 },
    { 150, 151, 152 }, { 151, 153, 152 },
    { 152, 153, 154 }, { 153, 155, 154 },
    { 154, 155, 156 }, { 155, 157, 156 },
    { 156, 157, 158 }, { 157, 159, 158 },
    { 158, 159, 160 }, { 159, 161, 160 },
    { 160, 161, 162 }, { 161, 163, 162 },
    { 162, 163, 164 }, { 163, 165, 164 },
    { 164, 165, 166 }, { 165, 167, 166 },
    { 166, 167, 168 }, { 167, 169, 168 },
    { 168, 169, 170 }, { 169, 171, 170 },
    { 170, 171, 172 }, { 171, 173, 172 },
    { 172, 173, 174 }, { 173, 175, 174 },
    { 174, 175, 176 }, { 175, 177, 176 },
    { 176, 177, 178 }, { 177, 179, 178 },
    { 178, 179, 180 }, { 179, 181, 180 },
    { 180, 181, 182 }, { 181, 183, 182 },
    { 182, 183, 184 }, { 183, 185, 184 },
    { 184, 185, 186 }, { 185, 187, 186 },
    { 186, 187, 188 }, { 187, 189, 188 },
    { 188, 189, 190 }, { 189, 191, 190 },
    { 190, 191, 192 }, { 191, 193, 192 },
    { 192, 193, 194 }, { 193, 195, 194 },
    { 194, 195, 196 }, { 195, 197, 196 },
    { 196, 197, 198 }, { 197, 199, 198 },
    { 198, 199, 200 }, { 199, 201, 200 },
    { 200, 201, 202 }, { 201, 203, 202 },
    { 202, 203, 204 }, { 203, 205, 204 },
    { 204, 205, 206 }, { 205, 207, 206 },
    { 206, 207, 208 }, { 207, 209, 208 },
    { 208, 209, 210 }, { 209, 211, 210 },
    { 210, 211, 212 }, { 211, 213, 212 },
    { 212, 213, 214 }, { 213, 215, 214 },
    { 214, 215, 216 }, { 215, 217, 216 },
    { 216, 217, 218 }, { 217, 219, 218 },
    { 218, 219, 220 }, { 219, 221, 220 },
    { 220, 221, 222 }, { 221, 223, 222 },
    { 222, 223, 224 }, { 223, 225, 224 },
    { 224, 225, 226 }, { 225, 227, 226 },
    { 226, 227, 228 }, { 227, 229, 228 },
    { 228, 229, 230 }, { 229, 231, 230 },
    { 230, 231, 232 }, { 231, 233, 232 },
    { 232, 233, 234 }, { 233, 235, 234 },
    { 234, 235, 236 }, { 235, 237, 236 },
    { 236, 237, 238 }, { 237, 239, 238 },
    { 238, 239, 240 }, { 239, 241, 240 },
    { 240, 241, 242 }, { 241, 243, 242 },
    { 242, 243, 244 }, { 243, 245, 244 },
    { 244, 245, 246 }, { 245, 247, 246 },
    { 246, 247, 248 }, { 247, 249, 248 },
    { 248, 249, 250 }, { 249, 251, 250 },
    { 250, 251, 252 }, { 251, 253, 252 },
    { 252, 253, 254 }, { 253, 255, 254 },
    { 254, 255, 256 }, { 255, 257, 256 },
};

WORD TriangleFanPrecompDP[][3] = {
    { 1, 2, 0 }, { 2, 3, 0 },
    { 3, 4, 0 }, { 4, 5, 0 },
    { 5, 6, 0 }, { 6, 7, 0 },
    { 7, 8, 0 }, { 8, 9, 0 },
    { 9, 10, 0 }, { 10, 11, 0 },
    { 11, 12, 0 }, { 12, 13, 0 },
    { 13, 14, 0 }, { 14, 15, 0 },
    { 15, 16, 0 }, { 16, 17, 0 },
    { 17, 18, 0 }, { 18, 19, 0 },
    { 19, 20, 0 }, { 20, 21, 0 },
    { 21, 22, 0 }, { 22, 23, 0 },
    { 23, 24, 0 }, { 24, 25, 0 },
    { 25, 26, 0 }, { 26, 27, 0 },
    { 27, 28, 0 }, { 28, 29, 0 },
    { 29, 30, 0 }, { 30, 31, 0 },
    { 31, 32, 0 }, { 32, 33, 0 },
    { 33, 34, 0 }, { 34, 35, 0 },
    { 35, 36, 0 }, { 36, 37, 0 },
    { 37, 38, 0 }, { 38, 39, 0 },
    { 39, 40, 0 }, { 40, 41, 0 },
    { 41, 42, 0 }, { 42, 43, 0 },
    { 43, 44, 0 }, { 44, 45, 0 },
    { 45, 46, 0 }, { 46, 47, 0 },
    { 47, 48, 0 }, { 48, 49, 0 },
    { 49, 50, 0 }, { 50, 51, 0 },
    { 51, 52, 0 }, { 52, 53, 0 },
    { 53, 54, 0 }, { 54, 55, 0 },
    { 55, 56, 0 }, { 56, 57, 0 },
    { 57, 58, 0 }, { 58, 59, 0 },
    { 59, 60, 0 }, { 60, 61, 0 },
    { 61, 62, 0 }, { 62, 63, 0 },
    { 63, 64, 0 }, { 64, 65, 0 },
    { 65, 66, 0 }, { 66, 67, 0 },
    { 67, 68, 0 }, { 68, 69, 0 },
    { 69, 70, 0 }, { 70, 71, 0 },
    { 71, 72, 0 }, { 72, 73, 0 },
    { 73, 74, 0 }, { 74, 75, 0 },
    { 75, 76, 0 }, { 76, 77, 0 },
    { 77, 78, 0 }, { 78, 79, 0 },
    { 79, 80, 0 }, { 80, 81, 0 },
    { 81, 82, 0 }, { 82, 83, 0 },
    { 83, 84, 0 }, { 84, 85, 0 },
    { 85, 86, 0 }, { 86, 87, 0 },
    { 87, 88, 0 }, { 88, 89, 0 },
    { 89, 90, 0 }, { 90, 91, 0 },
    { 91, 92, 0 }, { 92, 93, 0 },
    { 93, 94, 0 }, { 94, 95, 0 },
    { 95, 96, 0 }, { 96, 97, 0 },
    { 97, 98, 0 }, { 98, 99, 0 },
    { 99, 100, 0 }, { 100, 101, 0 },
    { 101, 102, 0 }, { 102, 103, 0 },
    { 103, 104, 0 }, { 104, 105, 0 },
    { 105, 106, 0 }, { 106, 107, 0 },
    { 107, 108, 0 }, { 108, 109, 0 },
    { 109, 110, 0 }, { 110, 111, 0 },
    { 111, 112, 0 }, { 112, 113, 0 },
    { 113, 114, 0 }, { 114, 115, 0 },
    { 115, 116, 0 }, { 116, 117, 0 },
    { 117, 118, 0 }, { 118, 119, 0 },
    { 119, 120, 0 }, { 120, 121, 0 },
    { 121, 122, 0 }, { 122, 123, 0 },
    { 123, 124, 0 }, { 124, 125, 0 },
    { 125, 126, 0 }, { 126, 127, 0 },
    { 127, 128, 0 }, { 128, 129, 0 },
    { 129, 130, 0 }, { 130, 131, 0 },
    { 131, 132, 0 }, { 132, 133, 0 },
    { 133, 134, 0 }, { 134, 135, 0 },
    { 135, 136, 0 }, { 136, 137, 0 },
    { 137, 138, 0 }, { 138, 139, 0 },
    { 139, 140, 0 }, { 140, 141, 0 },
    { 141, 142, 0 }, { 142, 143, 0 },
    { 143, 144, 0 }, { 144, 145, 0 },
    { 145, 146, 0 }, { 146, 147, 0 },
    { 147, 148, 0 }, { 148, 149, 0 },
    { 149, 150, 0 }, { 150, 151, 0 },
    { 151, 152, 0 }, { 152, 153, 0 },
    { 153, 154, 0 }, { 154, 155, 0 },
    { 155, 156, 0 }, { 156, 157, 0 },
    { 157, 158, 0 }, { 158, 159, 0 },
    { 159, 160, 0 }, { 160, 161, 0 },
    { 161, 162, 0 }, { 162, 163, 0 },
    { 163, 164, 0 }, { 164, 165, 0 },
    { 165, 166, 0 }, { 166, 167, 0 },
    { 167, 168, 0 }, { 168, 169, 0 },
    { 169, 170, 0 }, { 170, 171, 0 },
    { 171, 172, 0 }, { 172, 173, 0 },
    { 173, 174, 0 }, { 174, 175, 0 },
    { 175, 176, 0 }, { 176, 177, 0 },
    { 177, 178, 0 }, { 178, 179, 0 },
    { 179, 180, 0 }, { 180, 181, 0 },
    { 181, 182, 0 }, { 182, 183, 0 },
    { 183, 184, 0 }, { 184, 185, 0 },
    { 185, 186, 0 }, { 186, 187, 0 },
    { 187, 188, 0 }, { 188, 189, 0 },
    { 189, 190, 0 }, { 190, 191, 0 },
    { 191, 192, 0 }, { 192, 193, 0 },
    { 193, 194, 0 }, { 194, 195, 0 },
    { 195, 196, 0 }, { 196, 197, 0 },
    { 197, 198, 0 }, { 198, 199, 0 },
    { 199, 200, 0 }, { 200, 201, 0 },
    { 201, 202, 0 }, { 202, 203, 0 },
    { 203, 204, 0 }, { 204, 205, 0 },
    { 205, 206, 0 }, { 206, 207, 0 },
    { 207, 208, 0 }, { 208, 209, 0 },
    { 209, 210, 0 }, { 210, 211, 0 },
    { 211, 212, 0 }, { 212, 213, 0 },
    { 213, 214, 0 }, { 214, 215, 0 },
    { 215, 216, 0 }, { 216, 217, 0 },
    { 217, 218, 0 }, { 218, 219, 0 },
    { 219, 220, 0 }, { 220, 221, 0 },
    { 221, 222, 0 }, { 222, 223, 0 },
    { 223, 224, 0 }, { 224, 225, 0 },
    { 225, 226, 0 }, { 226, 227, 0 },
    { 227, 228, 0 }, { 228, 229, 0 },
    { 229, 230, 0 }, { 230, 231, 0 },
    { 231, 232, 0 }, { 232, 233, 0 },
    { 233, 234, 0 }, { 234, 235, 0 },
    { 235, 236, 0 }, { 236, 237, 0 },
    { 237, 238, 0 }, { 238, 239, 0 },
    { 239, 240, 0 }, { 240, 241, 0 },
    { 241, 242, 0 }, { 242, 243, 0 },
    { 243, 244, 0 }, { 244, 245, 0 },
    { 245, 246, 0 }, { 246, 247, 0 },
    { 247, 248, 0 }, { 248, 249, 0 },
    { 249, 250, 0 }, { 250, 251, 0 },
    { 251, 252, 0 }, { 252, 253, 0 },
    { 253, 254, 0 }, { 254, 255, 0 },
    { 255, 256, 0 }, { 256, 257, 0 },
    { 257, 258, 0 },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\texman.cpp ===
#include "pch.cpp"
#pragma hdrstop
#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager"

TextureCacheManager::TextureCacheManager(LPDIRECT3DI lpD3DI)
{
    for(int i = 0; i < MAXLOGTEXSIZE; tcm_bucket[i++] = NULL);
    tcm_ticks = 0;
    numvidtex = 0;
    lpDirect3DI=lpD3DI;
}

TextureCacheManager::~TextureCacheManager()
{
    for(int i = 0; i < MAXLOGTEXSIZE;i++){
        LPD3DBUCKET	bucket=tcm_bucket[i];
        while(bucket){
            tcm_bucket[i]=bucket->next;
            if (bucket->lpD3DTexI)  remove(bucket);
            D3DFreeBucket(lpDirect3DI,bucket);
            bucket=tcm_bucket[i];
        }
    }
}

BOOL TextureCacheManager::freeNode(LPD3DI_TEXTUREBLOCK lpBlock, LPD3DBUCKET* lplpBucket)
{
    // Starting from the current size, find the LRU texture and remove it.
    unsigned int oldest = tcm_ticks;
    LPD3DBUCKET	bucket,last,target=NULL;
    int     k=lpBlock->lpD3DTextureI->LogTexSize;
    DWORD   dwTextureStage=lpBlock->lpD3DTextureI->ddsd.dwTextureStage;
    BOOL    bSingleMemory = !(lpBlock->lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_SEPARATETEXTUREMEMORIES);
    D3D_INFO(8,"freeing size %d bSingleMemory=%d",k,bSingleMemory);
    for(int i = k; i < MAXLOGTEXSIZE; ++i) {
        for(bucket=tcm_bucket[i],last=NULL; bucket;){
	    if (!bucket->lpD3DTexI){	//invalidated by Tex3I destructors ?
                LPD3DBUCKET	temp=bucket->next;
                D3DFreeBucket(lpDirect3DI,bucket);
                bucket=temp;
                if (last){	// Yes, but is this the first node on the list
                    last->next=bucket;
                }
                else
                {
                    tcm_bucket[i]=bucket;
                }
                continue;
            }
            if(bucket->ticks < oldest && 
                (bSingleMemory || (bucket->lpD3DTexI->ddsd.dwTextureStage == dwTextureStage)) && 
                !bucket->lpD3DTexI->bInUse) 
            {
                oldest = bucket->ticks;
                target = bucket;
            }
            last=bucket;
            bucket=last->next;
        }
        if (oldest != tcm_ticks)
        {
            if (i==k && 
                !(lpBlock->lpD3DTextureI->ddsd.ddsCaps.dwCaps2 & 
                (DDSCAPS2_HINTSTATIC | DDSCAPS2_OPAQUE)  
                ) &&
                !(target->lpD3DTexI->ddsd.ddsCaps.dwCaps2 & 
                (DDSCAPS2_HINTSTATIC | DDSCAPS2_OPAQUE)  
                ) &&
                !(!(lpBlock->lpD3DTextureI->ddsd.ddsCaps.dwCaps & DDSCAPS_MIPMAP) && (target->lpD3DTexI->ddsd.ddsCaps.dwCaps & DDSCAPS_MIPMAP)
                ) &&
                !((DDPF_PALETTEINDEXED1 | 
                DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8) 
                & lpBlock->lpD3DTextureI->ddsd.ddpfPixelFormat.dwFlags)) //workaround of ddraw not updating surface pallete
                *lplpBucket=target; //possible candidate for replace
            else
                remove(target);
            return TRUE;
        }
    }
    // If bigger size texture not found, try smaller sizes.
    for(i = k - 1; i > 0; --i) {
        for(bucket=tcm_bucket[i],last=NULL; bucket;){
            if (!bucket->lpD3DTexI){	//invalidated by TexI destructors ?
                LPD3DBUCKET	temp=bucket->next;
                D3DFreeBucket(lpDirect3DI,bucket);
                bucket=temp;
                if (last){	// Yes, but is this the first node on the list
                    last->next=bucket;
                }
                else
                {
                    tcm_bucket[i]=bucket;
                }
                continue;
            }
            if(bucket->ticks < oldest && 
                (bSingleMemory || (bucket->lpD3DTexI->ddsd.dwTextureStage == dwTextureStage)) && 
                !bucket->lpD3DTexI->bInUse) 
            {
                oldest = bucket->ticks;
                target = bucket;
            }
            last=bucket;
            bucket=last->next;
        }
        if (oldest != tcm_ticks)
        {
            remove(target);
            return TRUE;
        }
    }
    return  FALSE;
}

HRESULT MarkDirtyPointers(LPDIRECT3DTEXTUREI  lpD3DTexI)
{
    // Next, we need to loop thru and set pointers to the dirty
    // bit in the DDraw surfaces
    HRESULT ddrval;
    DDSCAPS2 ddscaps;
    LPDIRECTDRAWSURFACE4 lpDDSTmp, lpDDS = lpD3DTexI->lpDDS, lpDDSSys = lpD3DTexI->lpDDSSys;
    do 
    {
        ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpSurfMore->lpbDirty = &(lpD3DTexI->bDirty);
        ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpSurfMore->lpRegionList = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSys)->lpLcl->lpSurfMore->lpRegionList;
        memset(&ddscaps, 0, sizeof(ddscaps));
        ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
        ddrval = lpDDS->GetAttachedSurface(&ddscaps, &lpDDSTmp);
        if (lpDDS != lpD3DTexI->lpDDS)  lpDDS->Release();
        lpDDS = lpDDSTmp;
        if (DDERR_NOTFOUND == ddrval)
        {
            if (lpDDSSys != lpD3DTexI->lpDDSSys)  lpDDSSys->Release();
            return  D3D_OK;
        }
        else if(DD_OK != ddrval)
        {
            D3D_ERR("GetAttachedSurface failed unexpectedly in MarkDirtyPointers");
            if (lpDDSSys != lpD3DTexI->lpDDSSys)  lpDDSSys->Release();
            return ddrval;
        }
        memset(&ddscaps, 0, sizeof(ddscaps));
        ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
        ddrval = lpDDSSys->GetAttachedSurface(&ddscaps, &lpDDSTmp);
        if (lpDDSSys != lpD3DTexI->lpDDSSys)  lpDDSSys->Release();
        lpDDSSys = lpDDSTmp;
    }
    while(ddrval == DD_OK);
    D3D_ERR("GetAttachedSurface failed unexpectedly in MarkDirtyPointers");
    if (lpDDS != lpD3DTexI->lpDDS)  lpDDS->Release();
    return ddrval;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::allocNode"

HRESULT TextureCacheManager::allocNode(LPD3DI_TEXTUREBLOCK lpBlock)
{
    LPD3DBUCKET	    lpCachedTexture=NULL;
    DWORD   pcaps,dwCaps;
    HRESULT ddrval;
    LPDIRECT3DTEXTUREI  lpD3DTexI=lpBlock->lpD3DTextureI;
    DDASSERT(!lpBlock->hTex && lpD3DTexI && lpBlock->lpDevI);
    if (0 == lpD3DTexI->LogTexSize)
    {
        DWORD texsize;  // in the number of half bytes
        // Compute log2 of the texture size. This is the bucket index.
        memset(&lpD3DTexI->ddsd, 0, sizeof(lpD3DTexI->ddsd));
        lpD3DTexI->ddsd.dwSize = sizeof(lpD3DTexI->ddsd);
        if (DD_OK != (ddrval=lpD3DTexI->lpDDSSys->GetSurfaceDesc(&lpD3DTexI->ddsd)))
        {
            D3D_WARN(1,"GetSurfaceDesc failed in TextureCacheManager::allocNode");
            return ddrval;
        }
        if (DDSD_LINEARSIZE & lpD3DTexI->ddsd.dwFlags)
        {
            texsize = lpD3DTexI->ddsd.dwLinearSize*2;
        }
        else 
        {
            texsize = lpD3DTexI->ddsd.dwWidth*lpD3DTexI->ddsd.dwHeight*lpD3DTexI->ddsd.ddpfPixelFormat.dwRGBBitCount/4;
        }
        if (0 != texsize )
        {
            for(; (texsize & 1) == 0; texsize >>= 1) ++lpD3DTexI->LogTexSize;
        }
        else
            lpD3DTexI->LogTexSize=1;

        D3D_INFO(7,"Managed Texture size=%d",lpD3DTexI->LogTexSize);    
        DDASSERT(lpD3DTexI->LogTexSize < MAXLOGTEXSIZE );
        lpD3DTexI->ddsd.dwFlags &= ~DDSD_PITCH;    // DDRAW always give that, but we don't want
        lpD3DTexI->ddsd.ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
        lpD3DTexI->ddsd.ddsCaps.dwCaps2 &= ~(DDSCAPS2_TEXTUREMANAGE);
        lpD3DTexI->ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
    }
    // Attempt to allocate a texture. If out of video memory, first try to replace
    // an old texture. If replacement not possible, free old textures using an LRU scheme
    // till enough memory is available.
    do {
        ddrval = lpDirect3DI->lpDD4->CreateSurface(&lpD3DTexI->ddsd, &lpD3DTexI->lpDDS, NULL);
        if (DD_OK== ddrval) { // No problem, there is enough memory. 
            if (D3D_OK != (ddrval=MarkDirtyPointers(lpD3DTexI)))
            {
                lpD3DTexI->lpDDS->Release();
                lpD3DTexI->lpDDS=NULL;
                return ddrval;
            }
            if (D3D_OK != (ddrval=D3DMallocBucket(lpDirect3DI,&lpCachedTexture)))
            {
                lpD3DTexI->lpDDS->Release();
                lpD3DTexI->lpDDS=NULL;
                return ddrval;
            }
            lpCachedTexture->next=tcm_bucket[lpD3DTexI->LogTexSize];
            lpCachedTexture->lpD3DTexI=lpD3DTexI;
            lpCachedTexture->ticks=tcm_ticks;
            tcm_bucket[lpD3DTexI->LogTexSize]=lpCachedTexture;
            ++numvidtex;
        }
        else
        if(ddrval == DDERR_OUTOFVIDEOMEMORY) { // If out of video memory
            if (freeNode(lpBlock,&lpCachedTexture))
            {
                if (lpCachedTexture)
                {   //found a replace candidate
                    replace(lpCachedTexture,lpBlock);
                    if ( lpD3DTexI->ddsd.dwWidth == lpCachedTexture->lpD3DTexI->ddsd.dwWidth 
                        && lpD3DTexI->ddsd.dwHeight == lpCachedTexture->lpD3DTexI->ddsd.dwHeight 
                        && lpD3DTexI->ddsd.ddpfPixelFormat.dwRBitMask == lpCachedTexture->lpD3DTexI->ddsd.ddpfPixelFormat.dwRBitMask 
                        && lpD3DTexI->ddsd.ddpfPixelFormat.dwFlags == lpCachedTexture->lpD3DTexI->ddsd.ddpfPixelFormat.dwFlags 
                        )
                    {
                        lpD3DTexI->lpDDS = lpCachedTexture->lpD3DTexI->lpDDS;
                        if (DD_OK == CopySurface(lpD3DTexI->lpDDS,lpD3DTexI->lpDDSSys,NULL) 
                            && D3D_OK == MarkDirtyPointers(lpD3DTexI) )
                        {
                            lpCachedTexture->lpD3DTexI->lpDDS=NULL;
                            lpD3DTexI->lpTMBucket=lpCachedTexture;
                            lpCachedTexture->lpD3DTexI->lpTMBucket=NULL;
                            lpD3DTexI->lpDDS1Tex = lpCachedTexture->lpD3DTexI->lpDDS1Tex;
                            lpCachedTexture->lpD3DTexI->lpDDS1Tex=NULL;
                            lpCachedTexture->lpD3DTexI=lpD3DTexI;
                            lpCachedTexture->ticks=tcm_ticks;
                            lpD3DTexI->bDirty=FALSE;
                            return D3D_OK;
                        }
                        lpD3DTexI->lpDDS = NULL;
                        D3D_WARN(2,"(%d %d %d) matching replace failed in TextureCacheManager::allocNode lpD3DTexI=%08lx with lpDDS=%08lx",
                                lpD3DTexI->LogTexSize,lpD3DTexI->ddsd.dwWidth,lpD3DTexI->ddsd.dwHeight,lpD3DTexI,lpCachedTexture->lpD3DTexI->lpDDS);
                    }
                    if (lpBlock->hTex)  //copy failed, therefore clear handle also  
                    {
                        CLockD3DST lockObject(lpBlock->lpDevI, DPF_MODNAME, REMIND(""));
                        D3DHAL_TextureDestroy(lpBlock);                        
                    }
                    remove(lpCachedTexture);
                    lpCachedTexture=NULL;
                }
            }
            else
            {
                D3D_ERR("all Freed no further video memory available");
#if DBG
                D3D_INFO(4,"freeing size %d dwTextureStage=%d tcm_ticks=%08lx dwCaps =%08lx failed",
                    lpD3DTexI->LogTexSize,lpD3DTexI->ddsd.dwTextureStage,tcm_ticks,lpD3DTexI->ddsd.ddsCaps.dwCaps);
                for(int i = 0; i < MAXLOGTEXSIZE; ++i) 
                {
                    if (tcm_bucket[i])  D3D_INFO(5,"List of size %d",i);
                    for(LPD3DBUCKET bucket=tcm_bucket[i];bucket;bucket=bucket->next)
                    {
                        if (bucket->lpD3DTexI)
                            D3D_INFO(5,"ticks=%08lx lpD3DTexI=%08lx InUse=%08lx dwTextureStage=%d",
                            bucket->ticks,bucket->lpD3DTexI, 
                            bucket->lpD3DTexI->bInUse,
                            bucket->lpD3DTexI->ddsd.dwTextureStage);
                    }
                }
#endif
                return	DDERR_OUTOFVIDEOMEMORY;	//nothing left
            }
        }
        else{
                D3D_ERR("Unexpected error got in allocNode");
                return	ddrval;
        }
    }while(ddrval == DDERR_OUTOFVIDEOMEMORY);
    if (lpD3DTexI->ddsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXED4)) {
        LPDIRECTDRAWPALETTE	lpDDPal;
        if (DD_OK != (ddrval=lpD3DTexI->lpDDSSys->GetPalette(&lpDDPal))) {
            lpD3DTexI->lpDDS->Release();
            lpD3DTexI->lpDDS=NULL;
            lpCachedTexture->lpD3DTexI=NULL;
            D3D_ERR("failed to check for palette on texture");
            return ddrval;
        } 
        if (DD_OK != (ddrval=lpD3DTexI->lpDDS->SetPalette(lpDDPal))){
            lpD3DTexI->lpDDS->Release();
            lpD3DTexI->lpDDS=NULL;
            lpCachedTexture->lpD3DTexI=NULL;
            D3D_ERR("SetPalette returned error");
            return ddrval;    
        }
        lpDDPal->Release();
    }
    if (DD_OK != (ddrval=CopySurface(lpD3DTexI->lpDDS,lpD3DTexI->lpDDSSys,NULL))){
        lpD3DTexI->lpDDS->Release();
        lpD3DTexI->lpDDS=NULL;
        lpCachedTexture->lpD3DTexI=NULL;
        D3D_ERR("CopySurface returned error");
        return ddrval;
    }
    lpD3DTexI->bDirty=FALSE;
    lpD3DTexI->lpTMBucket=lpCachedTexture;
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::remove"

//remove all HW handles and release surface
void TextureCacheManager::remove(LPD3DBUCKET bucket)
{
    LPDIRECT3DTEXTUREI	lpD3DTexI=bucket->lpD3DTexI;
    LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&lpD3DTexI->blocks);
    while(tBlock){
        if (tBlock->hTex)
        {
            CLockD3DST lockObject(tBlock->lpDevI, DPF_MODNAME, REMIND(""));
            D3DHAL_TextureDestroy(tBlock);
        }
        tBlock=LIST_NEXT(tBlock,list);
    }
    D3D_INFO(7,"removing lpD3DTexI=%08lx lpDDS=%08lx",lpD3DTexI,lpD3DTexI->lpDDS);
    lpD3DTexI->lpDDS1Tex->Release();
    lpD3DTexI->lpDDS1Tex=NULL;
    lpD3DTexI->lpDDS->Release();
    lpD3DTexI->lpDDS=NULL;
    lpD3DTexI->lpTMBucket=NULL;
    bucket->lpD3DTexI=NULL;
    --numvidtex;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::replace"

//remove any HW handle that's not with lpBlock->lpDevI,save lpBlock->hTex,keep surface
void TextureCacheManager::replace(LPD3DBUCKET bucket,LPD3DI_TEXTUREBLOCK lpBlock)
{
    LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&bucket->lpD3DTexI->blocks);
    while(tBlock){
        if (tBlock->hTex)
        {	
            if (tBlock->lpDevI == lpBlock->lpDevI)
            {
                lpBlock->hTex=tBlock->hTex;     //save it
                //flush before copy
                LPD3DBUCKET list = reinterpret_cast<LPD3DBUCKET>(((LPDDRAWI_DDRAWSURFACE_INT)(tBlock->lpD3DTextureI->lpDDS))->lpLcl->lpSurfMore->lpD3DDevIList);
                while(list != NULL)
                {
                    if(list->lpD3DDevI == tBlock->lpDevI)
                    {
                        if(tBlock->lpDevI->FlushStates() != D3D_OK)
                        {
                            D3D_ERR("Error trying to render batched commands in TextureCacheManager::replace");
                        }
                        break;
                    }
                    list = list->next;
                }
                tBlock->hTex=0;
            }
            else
            {
                CLockD3DST lockObject(tBlock->lpDevI, DPF_MODNAME, REMIND(""));
                D3DHAL_TextureDestroy(tBlock);
            }
        }
        tBlock=LIST_NEXT(tBlock,list);
    }
    D3D_INFO(7,"replacing lpDDS=%08lx from lpD3DTexI=%08lx",bucket->lpD3DTexI->lpDDS,bucket->lpD3DTexI);
}

void TextureCacheManager::EvictTextures()
{
    for(int i = 0; i < MAXLOGTEXSIZE;i++){
        LPD3DBUCKET	bucket=tcm_bucket[i];
        while(bucket){
            if (bucket->lpD3DTexI)
            {
                remove(bucket);
            }
            bucket=bucket->next;
        }
    }
}

void TextureCacheManager::cleanup()
{
    for(int i = 0; i < MAXLOGTEXSIZE;i++){
        for(LPD3DBUCKET bucket=tcm_bucket[i],last=NULL; bucket;){
            if (!bucket->lpD3DTexI){	//invalidated by Tex3I destructors ?
                LPD3DBUCKET	temp=bucket->next;
                D3DFreeBucket(lpDirect3DI,bucket);
                bucket=temp;
                if (last){	// Yes, but is this the first node on the list
                    last->next=bucket;
                }
                else
                {
                    tcm_bucket[i]=bucket;
                }
            }
            else{
                last=bucket;
                bucket=last->next;
            }   
        }
    }
}

BOOL TextureCacheManager::CheckIfLost()
{
    if(numvidtex)
    {
        for(int i = 0; i < MAXLOGTEXSIZE; ++i)
        {
            for(LPD3DBUCKET bucket = tcm_bucket[i]; bucket; bucket = bucket->next)
            {
                if(bucket->lpD3DTexI)
                {
                    if(((LPDDRAWI_DDRAWSURFACE_INT)(bucket->lpD3DTexI->lpDDS))->lpLcl->dwFlags & DDRAWISURF_INVALID)
                        return TRUE;
                    else
                        return FALSE;
                }
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\vwiunk.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   texiunk.c
 *  Content:    Direct3DViewport IUnknown implementation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * D3DVwp_QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::QueryInterface"

HRESULT D3DAPI DIRECT3DVIEWPORTI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(ppvObj)) {
            D3D_ERR( "Invalid pointer to pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *ppvObj = NULL;

    if(IsEqualIID(riid, IID_IUnknown) ||
       IsEqualIID(riid, IID_IDirect3DViewport) ||
       IsEqualIID(riid, IID_IDirect3DViewport2) ||
       IsEqualIID(riid, IID_IDirect3DViewport3))
    {
        AddRef();
        *ppvObj = (LPVOID)this;
        ret = D3D_OK;
    }
    else
        ret = E_NOINTERFACE;
    return ret;
} /* D3DVwp_QueryInterface */

/*
 * D3DVwp_AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::AddRef"

ULONG D3DAPI DIRECT3DVIEWPORTI::AddRef()
{
    DWORD       rcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }

    this->refCnt++;
    rcnt = this->refCnt;

    return (rcnt);
} /* D3DVwp_AddRef */

/*
 * D3DVwp_Release
 *
 */
ULONG D3DAPI DIRECT3DVIEWPORTI::Release()
{
    DWORD           lastrefcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }

    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    lastrefcnt = this->refCnt;

    if( lastrefcnt == 0 ) {
        delete this;
        return 0;
    }
    return lastrefcnt;
} /* D3DVwp_Release */

DIRECT3DVIEWPORTI::~DIRECT3DVIEWPORTI()
{
    LPDIRECT3DLIGHTI lpLightI;

    /*
     * Drop all the lights currently associated with the viewport.
     */
    while ((lpLightI = CIRCLE_QUEUE_FIRST(&this->lights)) &&
           (lpLightI != (LPDIRECT3DLIGHTI)&this->lights)) {
        DeleteLight((LPDIRECT3DLIGHT)lpLightI);
    }

    /*
     * Deallocate rects used for clearing.
     */
    if (this->clrRects) {
        D3DFree(this->clrRects);
    }

    // remove us from our device
    if (this->lpDevI) 
        this->lpDevI->DeleteViewport(this);

    /* remove us from the Direct3D object list of viewports */
    LIST_DELETE(this, list);
    this->lpDirect3DI->numViewports--;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\vertbuf.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * 
 *  File:    vertbuf.cpp
 *  Content:    Direct3DVertexBuffer implementation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date    By    Reason
 *   ====    ==    ======
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "drawprim.hpp"
#include "d3dfei.h"

const DWORD D3DVOP_RENDER = 1 << 31;
const DWORD D3DVBCAPS_VALID = D3DVBCAPS_SYSTEMMEMORY | 
                              D3DVBCAPS_WRITEONLY |
                              D3DVBCAPS_OPTIMIZED;

void hookVertexBufferToD3D(LPDIRECT3DI lpDirect3DI,
                                 LPDIRECT3DVERTEXBUFFERI lpVBufI)
{

    LIST_INSERT_ROOT(&lpDirect3DI->vbufs, lpVBufI, list);
    lpVBufI->lpDirect3DI = lpDirect3DI;

    lpDirect3DI->numVBufs++;
}

/*
 * Direct3DVertexBuffer::QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::QueryInterface"

HRESULT D3DAPI CDirect3DVertexBuffer::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
#if DBG    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(ppvObj)) {
            D3D_ERR( "Invalid pointer to pointer" );
            return DDERR_INVALIDPARAMS;
        }
        *ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
#endif    
    if(IsEqualIID(riid, IID_IUnknown) ||
       IsEqualIID(riid, IID_IDirect3DVertexBuffer) )
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DVERTEXBUFFER>(this));
        return(D3D_OK);
    }
    else
    {
        D3D_ERR( "Don't know this riid" );
        return (E_NOINTERFACE);
    }
} /* CDirect3DVertexBuffer::QueryInterface */

/*
 * Direct3DVertexBuffer::AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::AddRef"

ULONG D3DAPI CDirect3DVertexBuffer::AddRef()
{
    DWORD        rcnt;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
#if DBG    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
#endif    
    this->refCnt++;
    rcnt = this->refCnt;
    
    return (rcnt);
    
} /* Direct3DVertexBuffer::AddRef */

/*
  * Direct3DVertexBuffer::Release
  *
*/
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::Release"

ULONG D3DAPI CDirect3DVertexBuffer::Release()
{
    DWORD            lastrefcnt;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
#if DBG    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
#endif    
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    lastrefcnt = this->refCnt;
    
    if( lastrefcnt == 0 )
    {
        delete this;
        return 0;
    }
    
    return lastrefcnt;
    
} /* D3DTex3_Release */
//---------------------------------------------------------------------
// Internal version.
// No D3D lock, no checks
//
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::CreateVertexBufferI"

HRESULT DIRECT3DI::CreateVertexBufferI(LPD3DVERTEXBUFFERDESC lpDesc, 
                                              LPDIRECT3DVERTEXBUFFER* lplpVBuf,
                                              DWORD dwFlags)
{
    CDirect3DVertexBuffer*     lpVBufI;
    HRESULT ret = D3D_OK;

    *lplpVBuf = NULL;

    lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(new CDirect3DVertexBuffer(this));
    if (!lpVBufI) {
        D3D_ERR("failed to allocate space for vertex buffer");
        return (DDERR_OUTOFMEMORY);
    }

    if ((ret=lpVBufI->Init(this, lpDesc, dwFlags))!=D3D_OK)
    {
        D3D_ERR("Failed to initialize the vertex buffer object");
        delete lpVBufI;
        return ret;
    }
    *lplpVBuf = (LPDIRECT3DVERTEXBUFFER)lpVBufI;

    return(D3D_OK);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::CreateVertexBuffer"

HRESULT D3DAPI DIRECT3DI::CreateVertexBuffer(LPD3DVERTEXBUFFERDESC lpDesc, LPDIRECT3DVERTEXBUFFER* lplpVBuf,
        DWORD dwFlags, LPUNKNOWN pUnkOuter)
{
    if(pUnkOuter != NULL) {
        D3D_ERR("Unknown pointer should be NULL");
        return CLASS_E_NOAGGREGATION;
    }

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
#if DBG
    /*
     * validate parms
     */
    if (!VALID_DIRECT3D3_PTR(this)) {
        D3D_ERR( "Invalid Direct3D pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_OUTPTR(lplpVBuf)) {
        D3D_ERR( "Invalid pointer to pointer pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if ((lpDesc->dwCaps & D3DVBCAPS_VALID) != lpDesc->dwCaps)
    {
        D3D_ERR("Invalid caps");
        return DDERR_INVALIDCAPS;
    }
    if (dwFlags & ~D3DDP_DONOTCLIP)
    {
        D3D_ERR("Invalid dwFlags");
        return DDERR_INVALIDPARAMS;
    }
#endif
    return CreateVertexBufferI(lpDesc, lplpVBuf, dwFlags);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::constructor"

CDirect3DVertexBuffer::CDirect3DVertexBuffer(LPDIRECT3DI lpD3DI)
{
    refCnt = 1;
    /*
     * Put this vertex buffer in the list of those owned by the
     * Direct3D object
     */
    hookVertexBufferToD3D(lpD3DI, this);
    srcVOP = dstVOP = dwPVFlags = position.dwStride = dwLockCnt = 0;
    legacyVertexType = (D3DVERTEXTYPE)0;
    position.lpvData = NULL;
    clipCodes = NULL;
    lpDDSVB = NULL;
    dwCaps = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::destructor"

CDirect3DVertexBuffer::~CDirect3DVertexBuffer()
{
    /*
    * Remove ourselves from the Direct3D object
    */
    LIST_DELETE(this, list);
    this->lpDirect3DI->numVBufs--;
    delete [] clipCodes;
    if (lpDDSVB)
    {
        lpDDSVB->Release();
        lpDDS1VB->Release();
    }
}

/* Calculates the per vertex size in bytes based on the vertex ID
 * This function ignores the CLIPFLAGS field since it is allocated
 * separatly. 
 */
DWORD calcVertexSize(DWORD fvf)
{
    DWORD vertSize=0;
    static const BYTE nibble1[]={0, 0, 
                                  12, 12, 
                                  16, 16,
                                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    static const BYTE nibble2[]={0, 12, 4, 16, 4, 16, 8, 20, 4, 16, 8, 20, 8, 20, 12, 24};
#if DBG    
    if (fvf & D3DFVF_XYZ)
        vertSize += 12;
    else if (fvf & D3DFVF_XYZRHW)
        vertSize += 16;
    if (fvf & D3DFVF_NORMAL)
        vertSize += 12;
    if (fvf & D3DFVF_RESERVED1)
        vertSize += 4;
    if (fvf & D3DFVF_DIFFUSE)
        vertSize += 4;
    if (fvf & D3DFVF_SPECULAR)
        vertSize += 4;
#else
    vertSize = nibble1[fvf&0xf] + nibble2[(fvf>>4)&0xf];
#endif
    vertSize += ((fvf >> 8) & 0xf) << 3; // 8 * #textures
    return vertSize;
}
//---------------------------------------------------------------------
//
// Create the vertex memory buffer through DirectDraw
//
// Notes:
//    this->dwMemType should be set before calling this function
//    this->dwCaps should be set too.
//    this->dwMemType is set to DDSCAPS_VIDEOMEMORY is the VB was driver allocated
//
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::CreateMemoryBuffer"
HRESULT CDirect3DVertexBuffer::CreateMemoryBuffer(
    LPDIRECT3DI lpD3DI,
    LPDIRECTDRAWSURFACE4 *lplpSurface4,
    LPDIRECTDRAWSURFACE  *lplpSurface,
    LPVOID *lplpMemory,
    DWORD dwBufferSize,
    DWORD dwFlags)
{
    HRESULT ret;
    DDSURFACEDESC2 ddsd;
    memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
    ddsd.dwSize = sizeof(DDSURFACEDESC2);
    ddsd.dwFlags = DDSD_WIDTH | DDSD_CAPS;
    ddsd.dwWidth = dwBufferSize; 
    ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER;
    ddsd.ddsCaps.dwCaps2 = this->dwMemType;

    // The meaning of DDSCAPS_VIDEOMEMORY and DDSCAPS_SYSTEMEMORY are
    // slightly different in case of VBs. the former only means that
    // the buffer is drivers allocated and could be in any memory type.
    // The latter means that the driver did not care to allocate VBs
    // hence they are always in DDraw allocated system memory.

    // The reason we try video memory followed by system memory 
    // (rather than simply not specifying the memory type) is for
    // drivers which do not care to do any special VB allocations, we
    // do not DDraw to take the Win16 lock for locking system memory
    // surfaces.

    if ((dwCaps & D3DVBCAPS_SYSTEMMEMORY) || !FVF_TRANSFORMED(fvf))
    {
        // This VB cannot reside in driver friendly memory for one of the following reasons:
        // 1. The app explicitly specified system memory
        // 2. The vertex buffer is untransformed - the driver will never see this VB
        D3D_INFO(8, "Trying to create a sys mem vertex buffer");
        ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        ret = lpD3DI->lpDD4->CreateSurface(&ddsd, lplpSurface4, NULL);
        if (ret != DD_OK) 
        {
            D3D_ERR("Could not allocate the Vertex buffer.");
            return ret;
        }
    }
    else
    {
        // Try explicit video memory first
        ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        if (dwFlags & D3DDP_DONOTCLIP)
            ddsd.ddsCaps.dwCaps |= dwCaps & DDSCAPS_WRITEONLY;
        D3D_INFO(8, "Trying to create a vid mem vertex buffer");
        if (lpD3DI->lpDD4->CreateSurface(&ddsd, lplpSurface4, NULL) != DD_OK)
        {
            // If that failed, or user requested sys mem, try explicit system memory
            D3D_INFO(6, "Trying to create a sys mem vertex buffer");
            ddsd.ddsCaps.dwCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_WRITEONLY);
            ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
            ret = lpD3DI->lpDD4->CreateSurface(&ddsd, lplpSurface4, NULL);
            if (ret != DD_OK) 
            {
                D3D_ERR("Could not allocate the Vertex buffer.");
                return ret;
            }
        }
        else
        {
            // Mark VB as REALLY in vid mem for Lock / Unlock optimizations
            this->dwMemType = DDSCAPS_VIDEOMEMORY;
        }
    }
    *lplpMemory = NULL;
    if (!(this->dwMemType & DDSCAPS_VIDEOMEMORY))
    {
        ret = (*lplpSurface4)->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_NOSYSLOCK, NULL);
        if (ret != DD_OK)
        {
            D3D_ERR("Could not lock system memory Vertex Buffer.");
            return ret;
        }
        *lplpMemory = ddsd.lpSurface;
    }
    ret = lpDDSVB->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)lplpSurface);
    if (ret != DD_OK) 
    {
        D3D_ERR("failed to QI for DDS1");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::init"

HRESULT CDirect3DVertexBuffer::Init(LPDIRECT3DI lpD3DI, LPD3DVERTEXBUFFERDESC lpDesc, DWORD dwFlags)
{
    HRESULT ret;
    
    bReallyOptimized = FALSE;
    dwCaps = lpDesc->dwCaps;
    fvf = lpDesc->dwFVF;
    dwNumVertices = lpDesc->dwNumVertices;
    if (dwNumVertices > MAX_DX6_VERTICES)
    {
        D3D_ERR("Direct3D for DirectX 6.0 cannot handle greater than 64K vertices");
        return D3DERR_TOOMANYVERTICES;
    }
    if (lpDesc->dwCaps & D3DVBCAPS_OPTIMIZED)
    {
        D3D_ERR("D3DVBCAPS_OPTIMIZED flag should not be set");
        return DDERR_INVALIDPARAMS;
    }
    if (fvf & 0xfffff000) // Higher order 20 bits must be zero for DX6
    {
        D3D_ERR("Invalid FVF id");
        return D3DERR_INVALIDVERTEXFORMAT;
    }
    nTexCoord = FVF_TEXCOORD_NUMBER(fvf);
    if ((position.dwStride = calcVertexSize(fvf)) == 0)
    {
        D3D_ERR("Vertex size is zero according to the FVF id");
        return D3DERR_INVALIDVERTEXFORMAT;
    }

    if (dwFlags & D3DVBFLAGS_CREATEMULTIBUFFER)
        dwMemType = 0;
    else
        dwMemType = DDSCAPS2_VERTEXBUFFER;
    ret = CreateMemoryBuffer(lpD3DI, &lpDDSVB, &lpDDS1VB, &position.lpvData, 
                             position.dwStride * dwNumVertices, dwFlags);
    if (ret != D3D_OK)
        return ret;

    /* Classify the operations that can be done using this VB */
    if ((fvf & D3DFVF_POSITION_MASK) == D3DFVF_XYZ)
    {
        D3D_INFO(4, "D3DFVF_XYZ set. Can be source VB for Transform");
        srcVOP = D3DVOP_TRANSFORM | D3DVOP_EXTENTS | D3DVOP_CLIP;
    }
    else if ((fvf & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
    {
        D3D_INFO(4, "D3DFVF_XYZRHW set. Can be dest VB for Transform");
        dstVOP = D3DVOP_TRANSFORM | D3DVOP_EXTENTS;
        srcVOP |= D3DVOP_EXTENTS;
        if ((dwFlags & D3DDP_DONOTCLIP) == 0)
        {
            clipCodes = new D3DFE_CLIPCODE[dwNumVertices];
            if (clipCodes == NULL)
            {
                D3D_ERR("Could not allocate space for clip flags");
                return DDERR_OUTOFMEMORY;
            }
            memset(clipCodes, 0, dwNumVertices * sizeof(D3DFE_CLIPCODE));
            dstVOP |= D3DVOP_CLIP;
        }
    }
    if (fvf & D3DFVF_NORMAL)
    {
        D3D_INFO(4, "D3DFVF_NORMAL set.");
        if (srcVOP & D3DVOP_TRANSFORM)
        {
            D3D_INFO(4, "Can be src VB for lighting.");
            srcVOP |= D3DVOP_LIGHT;
        }
        this->dwPVFlags |= D3DPV_LIGHTING;
    }
    if (fvf & D3DFVF_DIFFUSE)
    {
        D3D_INFO(4, "D3DFVF_DIFFUSE set. Can be dest VB for lighting");
        dstVOP |= D3DVOP_LIGHT;
    }
    if (dstVOP & D3DVOP_TRANSFORM)
    {
        D3D_INFO(4, "VB can be rendered");
        srcVOP |= D3DVOP_RENDER;
    }

    /* Compare with legacy vertex types */
    if (fvf == D3DFVF_VERTEX)
    {
        legacyVertexType = D3DVT_VERTEX;
    }
    else if (fvf == D3DFVF_LVERTEX)
    {
        legacyVertexType = D3DVT_LVERTEX;
    }
    else if (fvf == D3DFVF_TLVERTEX)
    {
        legacyVertexType = D3DVT_TLVERTEX;
    }
    return(D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::Lock"

HRESULT D3DAPI CDirect3DVertexBuffer::Lock(DWORD dwFlags, LPVOID* lplpData, DWORD* lpdwSize)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
    HRESULT ret;
#if DBG
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (IsBadWritePtr( lplpData, sizeof(LPVOID))) {
            D3D_ERR( "Invalid lpData pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (lpdwSize)
            if (IsBadWritePtr( lpdwSize, sizeof(DWORD))) {
                D3D_ERR( "Invalid lpData pointer" );
                return DDERR_INVALIDPARAMS;
            }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
#endif
    if (this->dwCaps & D3DVBCAPS_OPTIMIZED)
    {
        D3D_ERR("Cannot lock optimized vertex buffer");
        return(D3DERR_VERTEXBUFFEROPTIMIZED);
    }

    return this->LockI(dwFlags, lplpData, lpdwSize);

}
//---------------------------------------------------------------------
// Side effect:
//      position.lpvData is set.
//
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::LockI"

HRESULT D3DAPI CDirect3DVertexBuffer::LockI(DWORD dwFlags, LPVOID* lplpData, 
                                            DWORD* lpdwSize)
{
    HRESULT ret;

    if (lpdwSize)
        *lpdwSize = position.dwStride * dwNumVertices;

    if (position.lpvData)
    {
        *lplpData = position.lpvData;
    }
    else
    {
        DDSURFACEDESC2 ddsd;
        memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
        ddsd.dwSize = sizeof(DDSURFACEDESC2);
        ret = lpDDSVB->Lock(NULL, &ddsd, dwFlags | DDLOCK_NOSYSLOCK, NULL);
        if (ret != DD_OK)
        {
            D3D_ERR("Could not lock vertex buffer.");
            return ret;
        }
        *lplpData = ddsd.lpSurface;
        position.lpvData = ddsd.lpSurface;
    }
    dwLockCnt++;
    D3D_INFO(6, "VB Lock: %lx Lock Cnt =%d", this, dwLockCnt);
    if (lpDevIBatched && !(dwFlags & DDLOCK_READONLY))
    {
        ret = lpDevIBatched->FlushStates();
        lpDevIBatched = NULL;
        if (ret != D3D_OK)
        {
            D3D_ERR("Could not flush batch referring to VB during Lock");
            return ret;
        }
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::Unlock"

HRESULT D3DAPI CDirect3DVertexBuffer::Unlock()
{
    if (dwLockCnt)
    {
        dwLockCnt--;
        if ((dwMemType & DDSCAPS_VIDEOMEMORY) && (dwLockCnt == 0))
        {
            position.lpvData = NULL;
            D3D_INFO(6, "VB Unlock: %lx Lock Cnt =%d", this, dwLockCnt);
            return lpDDSVB->Unlock(NULL);
        }
    }
    D3D_INFO(6, "VB Unlock: %lx Lock Cnt =%d", this, dwLockCnt);
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::GetVertexBufferDesc"

HRESULT D3DAPI CDirect3DVertexBuffer::GetVertexBufferDesc(LPD3DVERTEXBUFFERDESC lpDesc)
{
#if DBG
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (IsBadWritePtr( lpDesc, lpDesc->dwSize)) {
            D3D_ERR( "Invalid lpData pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (! VALID_D3DVERTEXBUFFERDESC_PTR(lpDesc) )
        {
            D3D_ERR( "Invalid D3DVERTEXBUFFERDESC" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
#endif
    lpDesc->dwCaps = dwCaps;
    lpDesc->dwFVF = fvf;
    lpDesc->dwNumVertices = this->dwNumVertices;
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::ProcessVertices"

HRESULT D3DAPI CDirect3DVertexBuffer::ProcessVertices(DWORD vertexOP, DWORD dwDstIndex, DWORD dwCount, 
                                                      LPDIRECT3DVERTEXBUFFER lpSrc, 
                                                      DWORD dwSrcIndex, 
                                                      LPDIRECT3DDEVICE3 lpDevice, DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpSrcI;
    LPDIRECT3DDEVICEI lpDevI;

#if DBG
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(lpSrc)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        lpSrcI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpSrc);
        if (!VALID_DIRECT3DDEVICE3_PTR(lpDevice)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    if (dwFlags != 0 ||
        (dwDstIndex + dwCount) > this->dwNumVertices ||
        (dwSrcIndex + dwCount) > lpSrcI->dwNumVertices)
    {
        D3D_ERR( "Invalid parameters" );
        return DDERR_INVALIDPARAMS;
    }

    /* Validate Src & Dst Vertex Formats */
    if ((lpSrcI->srcVOP & vertexOP) != vertexOP)
    {
        D3D_ERR("Source VB cannot support this operation");
        return D3DERR_INVALIDVERTEXFORMAT;
    }
    if (!(vertexOP & D3DVOP_TRANSFORM))
    {
        D3D_ERR("D3DVOP_TRANSFORM flag should be set");
        return DDERR_INVALIDPARAMS;
    }

    if ((dstVOP & vertexOP) != vertexOP)
    {
        D3D_ERR("Destination VB cannot support this operation");
        return D3DERR_INVALIDVERTEXFORMAT;
    }

    if (this->fvf & D3DFVF_NORMAL)
    {

        D3D_ERR("The destination vertex buffer cannot have normals");
        return D3DERR_INVALIDVERTEXFORMAT;
    }
#else
    lpSrcI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpSrc);
    lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
#endif

    CLockD3DMT lockObject(lpDevI, DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    // Fill the D3DFE_PROCESSVERTICES structure
    // STRIDE and SOA flags
    lpDevI->dwFlags = lpSrcI->dwPVFlags & D3DPV_SOA;
    // LIGHTING, EXTENTS and CLIP flags (note extents and clip flags are inverted)
    // Currently transform is always done
    lpDevI->dwFlags |= (vertexOP ^ (D3DVOP_CLIP | D3DVOP_EXTENTS)) | D3DVOP_TRANSFORM;

    HRESULT ret;

    // Download viewport ??
    if (lpDevI->v_id != lpDevI->lpCurrentViewport->v_id)
    {
        ret = downloadView(lpDevI->lpCurrentViewport);
        if (ret != D3D_OK)
            return ret;
    }

    // Num vertices
    lpDevI->dwNumVertices = dwCount;

    // Lock the VBs
    LPVOID lpVoid;
    ret = LockI(DDLOCK_WAIT, &lpVoid, NULL);
    if (ret != D3D_OK)
    {
        D3D_ERR("Could not lock the vertex buffer");
        return ret;
    }
    ret = lpSrcI->LockI(DDLOCK_WAIT | DDLOCK_READONLY, &lpVoid, NULL);
    if (ret != D3D_OK)
    {
        D3D_ERR("Could not lock the vertex buffer");
        return ret;
    }

    // Output
    lpDevI->lpvOut = LPVOID(LPBYTE(position.lpvData) + dwDstIndex * position.dwStride);
    lpDevI->lpClipFlags = clipCodes + dwDstIndex;
    lpDevI->dwVIDIn = lpSrcI->fvf;
    lpDevI->dwVIDOut = fvf;

    if (lpSrcI->legacyVertexType && legacyVertexType)
    { // AOS Legacy
        /* We can use the legacy FE codepaths which might
         * be faster
         */
        lpDevI->position.lpvData = LPVOID(LPBYTE(lpSrcI->position.lpvData) + dwSrcIndex * lpSrcI->position.dwStride);
        lpDevI->nTexCoord = 1;
        lpDevI->position.dwStride = lpSrcI->position.dwStride;
        lpDevI->dwOutputSize = position.dwStride;
    }
    else
    {
        lpDevI->nTexCoord = min(nTexCoord, lpSrcI->nTexCoord);
        if (lpSrcI->bReallyOptimized)
        { // SOA
          // Assume that SOA.lpvData is the same as position.lpvData
            lpDevI->SOA.lpvData = lpSrcI->position.lpvData;
            lpDevI->SOA.dwStride = lpSrcI->dwNumVertices;
            lpDevI->dwSOAStartVertex = dwSrcIndex;
            lpDevI->dwOutputSize = position.dwStride;
        }
        else
        { // AOS FVF
            lpDevI->dwOutputSize = position.dwStride;
            lpDevI->position.lpvData = LPVOID(LPBYTE(lpSrcI->position.lpvData) + dwSrcIndex * lpSrcI->position.dwStride);
            lpDevI->position.dwStride = lpSrcI->position.dwStride;
        }
    }
    lpDevI->dwFlags |= D3DPV_VBCALL;
    D3DFE_ProcessVertices(lpDevI);
    if (!(lpDevI->dwFlags & D3DDP_DONOTCLIP))
        D3DFE_UpdateClipStatus(lpDevI);
    // Unlock the VBs
    Unlock();
    lpSrcI->Unlock();
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "IDirect3DDevice3::DrawIndexedPrimitiveVB"

HRESULT D3DAPI DIRECT3DDEVICEI::DrawIndexedPrimitiveVB(D3DPRIMITIVETYPE dptPrimitiveType, 
                                                       LPDIRECT3DVERTEXBUFFER lpVBuf, 
                                                       LPWORD lpwIndices, DWORD dwIndexCount, 
                                                       DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpVBufI;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
    HRESULT ret;
#if DBG
    /* 
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(lpVBuf)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    if (!IsDPFlagsValid(dwFlags))
    {
        D3D_ERR("Invalid Flags in dwFlags field");
        return DDERR_INVALIDPARAMS;
    }
    if (!(IS_HW_DEVICE(this) || (lpVBufI->dwCaps & D3DVBCAPS_SYSTEMMEMORY)))
    {
        D3D_ERR("Cannot use vid mem vertex buffers with SW devices");
        return DDERR_INVALIDPARAMS;
    }
    if (lpVBufI->dwLockCnt)
    {
        D3D_ERR("Cannot render using a locked vertex buffer");
        return D3DERR_VERTEXBUFFERLOCKED;
    }
    if (this->dwNumPrimitives > MAX_DX6_PRIMCOUNT)
    {
        D3D_ERR("D3D for DX6 cannot handle greater that 64K sized primitives");
        return D3DERR_TOOMANYPRIMITIVES;
    }

    Profile(PROF_DRAWINDEXEDPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#else
    lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
#endif
    this->dwFlags = dwFlags | lpVBufI->dwPVFlags;
    this->primType = dptPrimitiveType;
    this->dwNumVertices = lpVBufI->dwNumVertices;
    this->dwNumIndices = dwIndexCount;
    this->lpwIndices = lpwIndices;
    GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives and update stats

    this->dwFEFlags |= D3DFE_NEED_TEXTURE_UPDATE; // Need to call UpdateTextures()
    if (lpVBufI->srcVOP & D3DVOP_RENDER)
    { // TLVERTEX
#if DBG
        if (lpVBufI->fvf & D3DFVF_NORMAL)
        {

            D3D_ERR("The vertex buffer cannot be processed");
            D3D_ERR("It has XYZRHW position type and normals");
            return DDERR_INVALIDPARAMS;
        }
#endif
        this->dwOutputSize = lpVBufI->position.dwStride;
        this->dwVIDOut = lpVBufI->fvf;
        this->dwVIDIn = lpVBufI->fvf;
        // needed for legacy drivers' DrawIndexPrim code
        this->lpvOut = lpVBufI->position.lpvData;
        if (IS_DP2HAL_DEVICE(this))
        {
            this->nTexCoord = lpVBufI->nTexCoord;
            CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
            ret = dev->StartPrimVB(lpVBufI, 0);
            lpVBufI->lpDevIBatched = this;
             if (ret != D3D_OK)
                return ret;
        }
        else
        {
            ComputeTCI2CopyLegacy(this, lpVBufI->nTexCoord, TRUE);
        }
        if (dwFlags & D3DDP_DONOTCLIP)
        {
            return DrawIndexPrim();
        }
        else
        {
            this->lpClipFlags = lpVBufI->clipCodes;
            this->dwClipUnion = ~0; // Force clipping
            // If lpvData is NULL, it is a driver allocated buffer which
            // means IS_DPHAL_DEVICE() is true.
            // We need to lock such a buffer only if we need to clip
            if (!lpVBufI->position.lpvData)
            {
                // Lock VB
                DDSURFACEDESC2 ddsd;
                memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
                ddsd.dwSize = sizeof(DDSURFACEDESC2);
                ret = lpVBufI->lpDDSVB->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_READONLY | DDLOCK_NOSYSLOCK, NULL);
                if (ret != DD_OK)
                {
                    D3D_ERR("Could not lock vertex buffer.");
                    return ret;
                }
                this->lpvOut = ddsd.lpSurface;

                // Draw with clipping
#if DBG
                // To Do: Check vertices & clip flags against current viewport
                this->position.lpvData = this->lpvOut;  // Otherwise the check will fail
                ret = CheckDrawIndexedPrimitive(this);
                if (ret == D3D_OK)
                    ret = DoDrawIndexedPrimitive(this);
#else
                ret = DoDrawIndexedPrimitive(this);
#endif
                // Unlock VB
                if (ret == D3D_OK)
                    return lpVBufI->lpDDSVB->Unlock(NULL);
                else
                    lpVBufI->lpDDSVB->Unlock(NULL);
                return ret;
            }
            else
            {
                // Draw with clipping
#if DBG
                // To Do: Check vertices & clip flags against current viewport
                this->position.lpvData = this->lpvOut;  // Otherwise the check will fail
                ret = CheckDrawIndexedPrimitive(this);
                if (ret != D3D_OK)
                    return ret;
#endif
                return DoDrawIndexedPrimitive(this);
            }
        }
    }
    else
    { 
        this->dwVIDIn = lpVBufI->fvf;
        if (lpVBufI->bReallyOptimized)
        {
           // Assume that SOA.lpvData is the same as position.lpvData
            this->SOA.lpvData = lpVBufI->position.lpvData;
            this->SOA.dwStride = lpVBufI->dwNumVertices;
            this->dwSOAStartVertex = 0;
        }
        else
        {
            this->position = lpVBufI->position;
        }
        ComputeOutputFVF(this);
#if DBG    
        ret = CheckDrawIndexedPrimitive(this);
        if (ret != D3D_OK)
            return ret;
#endif
        return this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM); 
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice3::DrawPrimitiveVB"

HRESULT D3DAPI DIRECT3DDEVICEI::DrawPrimitiveVB(D3DPRIMITIVETYPE dptPrimitiveType, 
                                                LPDIRECT3DVERTEXBUFFER lpVBuf, 
                                                DWORD dwStartVertex, DWORD dwNumVertices, 
                                                DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpVBufI;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock
    HRESULT ret;
#if DBG
    /* 
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(lpVBuf)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    if (!IsDPFlagsValid(dwFlags) ||
        (dwStartVertex + dwNumVertices) > lpVBufI->dwNumVertices)
        return DDERR_INVALIDPARAMS;
    if (!(IS_HW_DEVICE(this) || (lpVBufI->dwCaps & D3DVBCAPS_SYSTEMMEMORY)))
    {
        D3D_ERR("Cannot use vid mem vertex buffers with SW devices");
        return DDERR_INVALIDPARAMS;
    }
    if (lpVBufI->dwLockCnt)
    {
        D3D_ERR("Cannot render using a locked vertex buffer");
        return D3DERR_VERTEXBUFFERLOCKED;
    }
    if (dwNumVertices > MAX_DX6_VERTICES)
    {
        D3D_ERR("D3D for DX6 cannot handle greater than 64K vertices");
        return D3DERR_TOOMANYVERTICES;
    }
    Profile(PROF_DRAWPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#else
    lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
#endif
    this->dwFlags = dwFlags | lpVBufI->dwPVFlags;
    this->primType = dptPrimitiveType;
    this->dwNumVertices = dwNumVertices;
    this->dwNumIndices = 0;
    this->lpwIndices = NULL;
    GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives and update stats
    this->dwFEFlags |= D3DFE_NEED_TEXTURE_UPDATE; // Need to call UpdateTextures()
    if (lpVBufI->srcVOP & D3DVOP_RENDER)
    { // TLVERTEX
#if DBG
        if (lpVBufI->fvf & D3DFVF_NORMAL)
        {

            D3D_ERR("The vertex buffer cannot be processed");
            D3D_ERR("It has XYZRHW position type and normals");
            return DDERR_INVALIDPARAMS;
        }
#endif
        this->dwOutputSize = lpVBufI->position.dwStride;
        this->dwVIDOut = lpVBufI->fvf;
        // needed for legacy drivers' DrawPrim code
        this->lpvOut = (BYTE*)(lpVBufI->position.lpvData) + 
                       dwStartVertex * this->dwOutputSize;
        if (IS_DP2HAL_DEVICE(this))
        {
            this->nTexCoord = lpVBufI->nTexCoord;
            CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
            ret = dev->StartPrimVB(lpVBufI, dwStartVertex);
            lpVBufI->lpDevIBatched = this;
            if (ret != D3D_OK)
                return ret;
        }
        else
        {
            ComputeTCI2CopyLegacy(this, lpVBufI->nTexCoord, TRUE);
        }
        if (dwFlags & D3DDP_DONOTCLIP)
        {
            return DrawPrim();
        }
        else
        {
            this->lpClipFlags = lpVBufI->clipCodes + dwStartVertex;
            this->dwClipUnion = ~0; // Force clipping
            // If lpvData is NULL, it is a driver allocated buffer which
            // means IS_DPHAL_DEVICE() is true.
            // We need to lock such a buffer only if we need to clip
            if (!lpVBufI->position.lpvData)
            {
                // Lock VB
                DDSURFACEDESC2 ddsd;
                memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
                ddsd.dwSize = sizeof(DDSURFACEDESC2);
                ret = lpVBufI->lpDDSVB->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_READONLY | DDLOCK_NOSYSLOCK, NULL);
                if (ret != DD_OK)
                {
                    D3D_ERR("Could not lock vertex buffer.");
                    return ret;
                }
                this->lpvOut = (BYTE*)(ddsd.lpSurface) + 
                               dwStartVertex * this->dwOutputSize;

                // Draw with clipping
#if DBG
                // To Do: Check vertices & clip flags against current viewport
                this->position.lpvData = this->lpvOut;  // Otherwise the check will fail
                ret=CheckDrawPrimitive(this);
                if (ret == D3D_OK)
                    ret = DoDrawPrimitive(this);
#else
                ret = DoDrawPrimitive(this);
#endif
                // Unlock VB
                if (ret == D3D_OK)
                    return lpVBufI->lpDDSVB->Unlock(NULL);
                else
                    lpVBufI->lpDDSVB->Unlock(NULL);
                return ret;
            }
            else
            {
                // Draw with clipping
#if DBG
                // To Do: Check vertices & clip flags against current viewport
                this->position.lpvData = this->lpvOut;  // Otherwise the check will fail
                ret=CheckDrawPrimitive(this);
                if (ret != D3D_OK)
                    return ret;
#endif
                return DoDrawPrimitive(this);
            }
        }
    }
    else
    { 
        this->dwVIDIn = lpVBufI->fvf;
        if (lpVBufI->bReallyOptimized)
        {
           // Assume that SOA.lpvData is the same as position.lpvData
            this->SOA.lpvData = lpVBufI->position.lpvData;
            this->SOA.dwStride = lpVBufI->dwNumVertices;
            this->dwSOAStartVertex = dwStartVertex;
        }
        else
        {
            this->position.lpvData = (BYTE*)(lpVBufI->position.lpvData) + 
                                     dwStartVertex * lpVBufI->position.dwStride;
            this->position.dwStride = lpVBufI->position.dwStride;
        }
        ComputeOutputFVF(this);
#if DBG    
        ret=CheckDrawPrimitive(this);
        if (ret != D3D_OK)
            return ret;
#endif
        return this->ProcessPrimitive(); 
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DVertexBuffer::Optimize"

HRESULT D3DAPI CDirect3DVertexBuffer::Optimize(LPDIRECT3DDEVICE3 lpDevice, DWORD dwFlags)
{
    HRESULT ret;
    LPDIRECT3DDEVICEI lpDevI;

// Validate parms
//
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) 
        {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_DIRECT3DDEVICE3_PTR(lpDevice)) 
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    if (dwFlags != 0)
    {
        D3D_ERR("dwFlags should be zero");
        return DDERR_INVALIDPARAMS;
    }

    CLockD3DMT lockObject(lpDevI, DPF_MODNAME, REMIND(""));  

    if (this->dwCaps & D3DVBCAPS_OPTIMIZED)
    {
        D3D_ERR("The vertex buffer already optimized");
        return D3DERR_VERTEXBUFFEROPTIMIZED;
    }
    if (this->dwLockCnt != 0)
    {
        D3D_ERR("Could not optimize locked vertex buffer");
        return D3DERR_VERTEXBUFFERLOCKED;
    }
// Do nothing for transformed vertices 
    if ((this->fvf & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
    {
        this->dwCaps |= D3DVBCAPS_OPTIMIZED;
        return D3D_OK;
    }
// Get the buffer size to allocate
    DWORD bufferSize = lpDevI->pGeometryFuncs->ComputeOptimizedVertexBufferSize
                                                (this->fvf, this->position.dwStride, 
                                                 dwNumVertices);
// Create new surfaces for optimized vertex buffer
    if (bufferSize == 0)
    {
        this->dwCaps |= D3DVBCAPS_OPTIMIZED;
        return D3D_OK;
    }
    LPDIRECTDRAWSURFACE4 lpSurface4; 
    LPDIRECTDRAWSURFACE  lpSurface; 
    LPVOID lpMemory;

    ret = CreateMemoryBuffer(lpDevI->lpDirect3DI, &lpSurface4, &lpSurface, 
                             &lpMemory, bufferSize, 
                             clipCodes ? 0 : D3DDP_DONOTCLIP);
    if (ret != D3D_OK)
        return ret;
// Try to optimize
// If optimized vertex buffer are not supported by the implementation
// it returns E_NOTIMPL. In this case we still set D3DVBCAPS_OPTIMIZED to prevent
// locking of the vertex buffer. But bReallyOptimized is set to FALSE, to use 
// the original buffer.
    ret = lpDevI->pGeometryFuncs->OptimizeVertexBuffer
        (fvf, dwNumVertices, position.dwStride, position.lpvData, 
         lpMemory, dwFlags);

    if (ret)
    {
        lpSurface4->Release();
        lpSurface->Release();
        if (ret == E_NOTIMPL)
        {
            this->dwCaps |= D3DVBCAPS_OPTIMIZED;
            return D3D_OK;
        }
        else
        {
            D3D_ERR("Failed to optimize vertex buffer");
            return ret;
        }
    }
    bReallyOptimized = TRUE;
    legacyVertexType = (D3DVERTEXTYPE)0;
    this->dwPVFlags |= D3DPV_SOA;
    this->dwCaps |= D3DVBCAPS_OPTIMIZED;
// Destroy old surfaces
    lpDDSVB->Release();
    lpDDS1VB->Release();
// And use new ones
    lpDDSVB = lpSurface4;
    lpDDS1VB = lpSurface;
    position.lpvData = lpMemory;
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\vwport.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   vwport.c
 *  Content:    Direct3D viewport functions
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: vwport.c,v 1.25 1995/12/04 11:29:49 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Create an api for the Direct3DViewport object
 */

#include "d3dfei.h"
#include "drawprim.hpp"

extern void UpdateViewportCache(LPDIRECT3DDEVICEI device, D3DVIEWPORT2 *data);

//---------------------------------------------------------------------
//
// Compute inverse Mclip matrix
//
void updateInverseMclip(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_VIEWPORTCACHE& VPORT = lpDevI->vcache;
    VPORT.imclip11 = D3DVAL(1)/VPORT.mclip11;
    VPORT.imclip41 = - VPORT.imclip11 * VPORT.mclip41;
    VPORT.imclip22 = D3DVAL(1)/VPORT.mclip22;
    VPORT.imclip42 = - VPORT.imclip22 * VPORT.mclip42;
    VPORT.imclip33 = D3DVAL(1)/VPORT.mclip33;
    VPORT.imclip43 = VPORT.imclip33 * VPORT.mclip43;
}
//---------------------------------------------------------------------
HRESULT downloadView(LPDIRECT3DVIEWPORTI lpViewI)
{
    HRESULT     err;

    if (!lpViewI->v_data_is_set)
    {
        D3D_ERR("SetViewport not called for viewport yet");
        return D3DERR_VIEWPORTDATANOTSET;
    }

    LPDIRECT3DDEVICEI lpDevI = lpViewI->lpDevI;

        // Update front-end data
    UpdateViewportCache(lpDevI, &lpViewI->v_data);

    // Download viewport data
    if ((err = lpDevI->UpdateDrvViewInfo(&lpViewI->v_data)) != DD_OK)
    {
        return err;
    }

    lpViewI->bLightsChanged = TRUE;         // Force setLights call
    lpDevI->v_id = lpViewI->v_id;

    return (D3D_OK);
}
//---------------------------------------------------------------------
// Viewport ID could be different from Device->v_id, because during Execute call
// Device->v_id is changed to whatever viewport is used as a parameter.
// So we have to make sure that we use the right viewport.
//
inline HRESULT ValidateViewport(LPDIRECT3DDEVICEI lpDevI,
                                LPDIRECT3DVIEWPORTI lpView)
{
#if DBG
    if (!VALID_DIRECT3DDEVICE3_PTR(lpDevI)) {
        D3D_ERR( "Viewport not attached to Device" );
        return D3DERR_VIEWPORTHASNODEVICE;
    }
#endif

    if (lpDevI->v_id != lpView->v_id)
    {
        return downloadView(lpView);
    }
    else
        return D3D_OK;
}

HRESULT hookViewportToD3D(LPDIRECT3DI lpDirect3DI,
                                 LPDIRECT3DVIEWPORTI lpD3DView)
{

    LIST_INSERT_ROOT(&lpDirect3DI->viewports, lpD3DView, list);
    lpD3DView->lpDirect3DI = lpDirect3DI;

    lpDirect3DI->numViewports++;

    return (D3D_OK);
}

HRESULT D3DAPI DIRECT3DVIEWPORTI::Initialize(LPDIRECT3D lpD3D)
{
    return DDERR_ALREADYINITIALIZED;
}

/*
 * Light Management
 */
HRESULT hookLightToViewport(LPDIRECT3DVIEWPORTI lpD3DViewI,
                                   LPDIRECT3DLIGHTI lpD3DLight)
{

    CIRCLE_QUEUE_INSERT_END(&lpD3DViewI->lights, DIRECT3DLIGHTI, lpD3DLight,
                            light_list);
    lpD3DLight->lpD3DViewportI = lpD3DViewI;

    lpD3DViewI->numLights++;

    return (D3D_OK);
}

HRESULT setLights(LPDIRECT3DVIEWPORTI lpView)
{
    LPDIRECT3DDEVICEI   lpDevI;
    LPDIRECT3DLIGHTI    lpD3DLightI;
    int         i;

    lpDevI = lpView->lpDevI;

    lpD3DLightI = (LPDIRECT3DLIGHTI)CIRCLE_QUEUE_FIRST(&lpView->lights);

    D3DFE_LIGHTING& LIGHTING = lpDevI->lighting;
    LIGHTING.activeLights = NULL;

    // Set lights in the device
    for (i = 0; i < lpView->numLights; i++)
    {
        if (lpD3DLightI->diLightData.valid &&
            lpD3DLightI->diLightData.flags & D3DLIGHT_ACTIVE)
        {
            lpD3DLightI->diLightData.next = LIGHTING.activeLights;
            LIGHTING.activeLights = &lpD3DLightI->diLightData;
        }
        lpD3DLightI = CIRCLE_QUEUE_NEXT(&lpView->lights,lpD3DLightI,light_list);
    }
    lpDevI->dwFEFlags |= (D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_LIGHTS_DIRTY);

    return (D3D_OK);
}

/*
 * Create the Viewport
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::CreateViewport"

HRESULT D3DAPI DIRECT3DI::CreateViewport(LPDIRECT3DVIEWPORT* lplpD3DView,
                                         IUnknown *pUnkOuter)
{
    return CreateViewport((LPDIRECT3DVIEWPORT3*)lplpD3DView, NULL);
}

HRESULT D3DAPI DIRECT3DI::CreateViewport(LPDIRECT3DVIEWPORT2* lplpD3DView2,
                                         IUnknown *pUnkOuter)
{
    return CreateViewport((LPDIRECT3DVIEWPORT3*)lplpD3DView2, NULL);
}

HRESULT D3DAPI DIRECT3DI::CreateViewport(LPDIRECT3DVIEWPORT3* lplpD3DView,
                                         IUnknown *pUnkOuter)
{
    LPDIRECT3DVIEWPORTI     lpView;
    HRESULT ret = D3D_OK;

    if(pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    if (!VALID_DIRECT3D3_PTR(this)) {
        D3D_ERR( "Invalid Direct3D pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_OUTPTR(lplpD3DView)) {
        D3D_ERR( "Invalid pointer to pointer pointer" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpD3DView = NULL;

    lpView = new DIRECT3DVIEWPORTI(this);

    if (!lpView) {
        D3D_ERR("failed to allocate space for object");
        return (DDERR_OUTOFMEMORY);
    }

    /*
     * Put this device in the list of those owned by the
     * Direct3D object
     */
    ret = hookViewportToD3D(this, lpView);
    if (ret != D3D_OK) {
        D3D_ERR("failed to associate viewport to Direct3D");
        delete lpView;
        return (ret);
    }
    *lplpD3DView = (LPDIRECT3DVIEWPORT3)lpView;

    return (D3D_OK);
}

DIRECT3DVIEWPORTI::DIRECT3DVIEWPORTI(LPDIRECT3DI lpD3DI)
{
    /*
     * setup the object
     */
    /*** Object Data ***/
    memset(&v_data, 0, sizeof(D3DVIEWPORT2));
    v_data_is_set = FALSE;
    bHaveBackgndMat=FALSE;
    hBackgndMat=NULL;
    lpDDSBackgndDepth=NULL;
    clrCount=0;
    clrRects=NULL;

    refCnt = 1;
    lpDevI=NULL;
    v_id = lpD3DI->v_next++;

    /*
     * Initialise lights
     */
    numLights = 0;
    CIRCLE_QUEUE_INITIALIZE(&lights, DIRECT3DLIGHTI);

    /*
     * Make sure that lights are always downloaded the first time
     */
    bLightsChanged = TRUE;

}

/*
 * IDirect3DViewport members
 */

/*
 * Transform
 */

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::SetViewport"

HRESULT D3DAPI DIRECT3DVIEWPORTI::SetViewport(LPD3DVIEWPORT lpData)
{
    HRESULT ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DVIEWPORT_PTR(lpData)) {
            D3D_ERR( "Invalid D3DVIEWPORT pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    D3DVIEWPORT2 v;
    if (lpData->dvScaleX == 0.0f || lpData->dvScaleY == 0.0f)
    {
        D3D_ERR( "Invalid viewport data" );
        v.dvClipWidth = 0.0f;
        v.dvClipHeight = 0.0f;
    }
    else
    {
        v.dvClipWidth = lpData->dwWidth / lpData->dvScaleX;
        v.dvClipHeight = lpData->dwHeight / lpData->dvScaleY;
    }
    /* Convert D3DVIEWPORT to D3DVIEWPORT2 */
    v.dwSize = sizeof(D3DVIEWPORT2);
    v.dwX = lpData->dwX;
    v.dwY = lpData->dwY;
    v.dwWidth = lpData->dwWidth;
    v.dwHeight = lpData->dwHeight;
    v.dvClipX = -v.dvClipWidth/2.0f;
    v.dvClipY = v.dvClipHeight/2.0f;
    v.dvMinZ = 0.0f;
    v.dvMaxZ = 1.0f;
    ret = SetViewport2(&v);
    return ret;
}

HRESULT D3DAPI DIRECT3DVIEWPORTI::SetViewport2(LPD3DVIEWPORT2 lpData)
{
    HRESULT err;
    DWORD uSurfWidth,uSurfHeight;
    LPDIRECTDRAWSURFACE lpDDS;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport2 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DVIEWPORT2_PTR(lpData)) {
            D3D_ERR( "Invalid D3DVIEWPORT2 pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!VALID_DIRECT3DDEVICE3_PTR(this->lpDevI)) {
        D3D_ERR( "Viewport not attached to Device" );
        return D3DERR_VIEWPORTHASNODEVICE;
    }

    if (IS_DX5_COMPATIBLE_DEVICE(this->lpDevI))
    { /* we're called directly by dx5 app, so validate params */
        if (lpData->dvClipWidth == 0.0f || lpData->dvClipHeight == 0.0f ||
            lpData->dvMinZ == lpData->dvMaxZ)
        {
            D3D_ERR( "Invalid viewport data" );
            return DDERR_INVALIDPARAMS;
        }

        lpDDS = this->lpDevI->lpDDSTarget;

        uSurfWidth=    ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wWidth;
        uSurfHeight=   ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wHeight;

        if (lpData->dwX > uSurfWidth ||
            lpData->dwY > uSurfHeight ||
            lpData->dwX + lpData->dwWidth > uSurfWidth ||
            lpData->dwY + lpData->dwHeight > uSurfHeight)
        {
            D3D_ERR("Viewport outside the render target surface");
            return DDERR_INVALIDPARAMS;
        }
    }

    this->v_data = *lpData;
    this->v_data_is_set = TRUE;
    // If this is the last rendered viewport, update its device
    if (this->v_id == this->lpDevI->v_id)
    {
        err = downloadView(this);
        if (err != D3D_OK)
        {
            return err;
        }
    }

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::GetViewport"

HRESULT D3DAPI DIRECT3DVIEWPORTI::GetViewport(LPD3DVIEWPORT lpData)
{
    HRESULT ret;
    D3DVIEWPORT2 v;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DVIEWPORT_PTR(lpData)) {
            D3D_ERR( "Invalid D3DVIEWPORT pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    v.dwSize = sizeof(D3DVIEWPORT2);
    ret = GetViewport2(&v);
    /* Convert D3DVIEWPORT2 to D3DVIEWPORT */
    lpData->dwSize = sizeof(D3DVIEWPORT);
    lpData->dwX = v.dwX;
    lpData->dwY = v.dwY;
    lpData->dwWidth = v.dwWidth;
    lpData->dwHeight = v.dwHeight;
    lpData->dvMinZ = 0.0f;
    lpData->dvMaxZ = 1.0f;
    lpData->dvScaleX = v.dwWidth / v.dvClipWidth;
    lpData->dvScaleY = v.dwHeight / v.dvClipHeight;
    lpData->dvMaxX = v.dvClipX + v.dvClipWidth;
    lpData->dvMaxY = v.dvClipY;
    return ret;
}


HRESULT D3DAPI DIRECT3DVIEWPORTI::GetViewport2(LPD3DVIEWPORT2 lpData)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DVIEWPORT2_PTR(lpData)) {
            D3D_ERR( "Invalid D3DVIEWPORT2 pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!this->v_data_is_set)
    {
        D3D_ERR("SetViewport not called for viewport yet");
        return D3DERR_VIEWPORTDATANOTSET;
    }

    *lpData = this->v_data;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::TransformVertices"

HRESULT D3DAPI DIRECT3DVIEWPORTI::TransformVertices(DWORD dwVertexCount,
                                                    LPD3DTRANSFORMDATA lpData,
                                                    DWORD dwFlags,
                                                    LPDWORD lpOffScreen)
{
    HRESULT     err;
    D3DTRANSFORMDATAI data;
    LPDIRECT3DVIEWPORTI lpViewOld;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DTRANSFORMDATA_PTR(lpData)) {
            D3D_ERR( "Invalid D3DTRANSFORMDATA pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_DWORD_PTR(lpOffScreen)) {
            D3D_ERR( "Invalid DWORD pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    dwFlags &= (D3DTRANSFORM_CLIPPED | D3DTRANSFORM_UNCLIPPED);
    if (!dwFlags)
    {
        D3D_ERR("invalid flags");
        return (DDERR_INVALIDPARAMS);
    }
    /*
     * Make sure the correct viewport is set up in the driver.
     */
    err = ValidateViewport(this->lpDevI, this);
    if (err != D3D_OK)
    {
        D3D_ERR("failed to set viewport");
        return err;
    }

    lpViewOld = this->lpDevI->lpCurrentViewport;
    lpDevI->lpCurrentViewport = this;

    data = *(LPD3DTRANSFORMDATAI)lpData;
    data.drExtent.x1 = D3DVAL(lpData->drExtent.x1);
    data.drExtent.y1 = D3DVAL(lpData->drExtent.y1);
    data.drExtent.x2 = D3DVAL(lpData->drExtent.x2);
    data.drExtent.y2 = D3DVAL(lpData->drExtent.y2);

    if (lpDevI->dwFEFlags & D3DFE_TRANSFORM_DIRTY)
        updateTransform(lpDevI);

    if (dwFlags == D3DTRANSFORM_CLIPPED)
    {
        if (lpDevI->dwFEFlags & D3DFE_INVERSEMCLIP_DIRTY)
        {
            updateInverseMclip(lpDevI);
            lpDevI->dwFEFlags &= ~D3DFE_INVERSEMCLIP_DIRTY;
        }
        lpDevI->dwFlags &= ~D3DDP_DONOTCLIP;
    }
    else
        lpDevI->dwFlags |= D3DDP_DONOTCLIP;

    *lpOffScreen = lpDevI->pGeometryFuncs->TransformVertices(lpDevI, dwVertexCount, &data);

    *lpData = *(D3DTRANSFORMDATA*)&data;
    D3DFE_ConvertExtent(this->lpDevI, &data.drExtent, &lpData->drExtent);

    this->lpDevI->lpCurrentViewport = lpViewOld;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::LightElements"

HRESULT D3DAPI DIRECT3DVIEWPORTI::LightElements(DWORD dwElementCount,
                                                LPD3DLIGHTDATA lpData)
{
    return E_NOTIMPL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::SetBackground"

HRESULT D3DAPI DIRECT3DVIEWPORTI::SetBackground(D3DMATERIALHANDLE hMat)
{

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!hMat) {
        D3D_ERR("invalid material handle");
        return (DDERR_INVALIDPARAMS);
    }

    this->bHaveBackgndMat = (hMat!=0);
    this->hBackgndMat = hMat;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::GetBackground"

HRESULT D3DAPI DIRECT3DVIEWPORTI::GetBackground(LPD3DMATERIALHANDLE lphMat,
                                                LPBOOL lpValid)
{
    HRESULT err;

    err = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DMATERIALHANDLE_PTR(lphMat)) {
            D3D_ERR( "Invalid D3DMATERIALHANDLE pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_BOOL_PTR(lpValid)) {
            D3D_ERR( "Invalid BOOL pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->bHaveBackgndMat) {
        *lpValid = TRUE;
        *lphMat = this->hBackgndMat;
    } else {
        *lphMat = 0;
        *lpValid = FALSE;
    }

    return (err);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::SetBackgroundDepth"

HRESULT D3DAPI DIRECT3DVIEWPORTI::SetBackgroundDepth(LPDIRECTDRAWSURFACE lpDDS) {

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        // passing NULL is OK
        if ((lpDDS!=NULL) && !VALID_D3D_DIRECTDRAWSURFACE_PTR((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)) {
            D3D_ERR( "Invalid DirectDrawSurface pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if(this->lpDDSBackgndDepth!=NULL) {
      this->lpDDSBackgndDepth->Release();
    }

    this->lpDDSBackgndDepth=lpDDS;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::SetBackgroundDepth2"

HRESULT D3DAPI DIRECT3DVIEWPORTI::SetBackgroundDepth2(LPDIRECTDRAWSURFACE4 lpDDS4)
{
    LPDIRECTDRAWSURFACE lpDDS;
    HRESULT ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }

        // passing NULL is OK
        if ((lpDDS4!=NULL) && !VALID_D3D_DIRECTDRAWSURFACE4_PTR((LPDDRAWI_DDRAWSURFACE_INT)lpDDS4)) {
            D3D_ERR( "Invalid DirectDrawSurface4 pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    lpDDS=NULL;
    if(lpDDS4!=NULL) {
        // QI for DDS interface.  This constitutes an AddRef, which is different from previous DX5 behavior
        ret = lpDDS4->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpDDS);
        if(FAILED(ret))
           return ret;
    }

    if(this->lpDDSBackgndDepth)
      this->lpDDSBackgndDepth->Release();

    this->lpDDSBackgndDepth = lpDDS;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::GetBackgroundDepth2"

HRESULT D3DAPI DIRECT3DVIEWPORTI::GetBackgroundDepth2(LPDIRECTDRAWSURFACE4* lplpDDS,
                                                     LPBOOL lpValid)
{
    LPDIRECTDRAWSURFACE lpDDS;
    HRESULT ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(lplpDDS)) {
            D3D_ERR( "Invalid ptr to LPDIRECTDRAWSURFACE4" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_BOOL_PTR(lpValid)) {
            D3D_ERR( "Invalid BOOL pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpDDS=NULL;

    if(this->lpDDSBackgndDepth!=NULL) {
      // QI for DDS interface.  This constitutes an AddRef, which is different from previous DX5 behavior
      ret = this->lpDDSBackgndDepth->QueryInterface(IID_IDirectDrawSurface4, (LPVOID*)lplpDDS);
    }

    *lpValid = (*lplpDDS!=NULL);
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::GetBackgroundDepth"

HRESULT D3DAPI DIRECT3DVIEWPORTI::GetBackgroundDepth(LPDIRECTDRAWSURFACE* lplpDDS,
                                                     LPBOOL lpValid)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(lplpDDS)) {
            D3D_ERR( "Invalid ptr to LPDIRECTDRAWSURFACE" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_BOOL_PTR(lpValid)) {
            D3D_ERR( "Invalid BOOL pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    // no AddRef taken (this was a DX3 bug)
    *lplpDDS = this->lpDDSBackgndDepth;
    *lpValid = (this->lpDDSBackgndDepth!=NULL);

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::Clear (ProcessRects)"

HRESULT ProcessRects(DIRECT3DVIEWPORTI *pViewport, DWORD dwCount, LPD3DRECT rects) {
    RECT vwport;
    DWORD i,j;

    /*
     * Rip through the rects and validate that they
     * are within the viewport.
     */

#if DBG
    if(dwCount == 0)
    {
        return D3D_OK;
    }
    if(rects == NULL)
    {
        D3D_ERR("invalid clear rectangle parameter rects == NULL");
        return DDERR_INVALIDPARAMS;
    }
#endif

    if (dwCount > pViewport->clrCount) {
        if (D3DRealloc((void**)&pViewport->clrRects, dwCount * sizeof(D3DRECT)) != DD_OK) {
            pViewport->clrCount = 0;
            pViewport->clrRects = NULL;
            D3D_ERR("failed to allocate space for rects");
            return DDERR_OUTOFMEMORY;
        }
    }
    if (IS_DX5_COMPATIBLE_DEVICE(pViewport->lpDevI))
    {
        vwport.left = pViewport->v_data.dwX;
        vwport.top = pViewport->v_data.dwY;
        vwport.right = pViewport->v_data.dwX + pViewport->v_data.dwWidth;
        vwport.bottom = pViewport->v_data.dwY + pViewport->v_data.dwHeight;
    }
    else
    {
        LPDIRECTDRAWSURFACE lpDDS;

        lpDDS = pViewport->lpDevI->lpDDSTarget;

        vwport.right  =   ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wWidth;
        vwport.bottom =   ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wHeight;

        vwport.left = 0;
        vwport.top = 0;

    }
    j=0;
    for (i = 0; i < dwCount; i++) {
        if (IntersectRect((LPRECT)(pViewport->clrRects + j), &vwport, (LPRECT)(rects + i)))
            j++;
    }
    pViewport->clrCount = j;

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::Clear2"

HRESULT D3DAPI DIRECT3DVIEWPORTI::Clear2(DWORD dwCount, LPD3DRECT rects, DWORD dwFlags,
                                         D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil)
{
    LPDIRECT3DVIEWPORTI lpTempVwport;
    HRESULT err;
    BOOL bDoRGBClear,bDoZClear,bDoStencilClear;
    LPDDPIXELFORMAT pZPixFmt=NULL;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALID_DIRECT3DDEVICE3_PTR(this->lpDevI)) {
            D3D_ERR( "Viewport not attached to Device" );
            return D3DERR_VIEWPORTHASNODEVICE;
        }
#if DBG
        if (IsBadWritePtr(rects, dwCount * sizeof(D3DRECT))) {
            D3D_ERR( "Invalid rects pointer" );
            return DDERR_INVALIDPARAMS;
        }
#endif
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    bDoRGBClear=((dwFlags & D3DCLEAR_TARGET)!=0);
    bDoZClear=((dwFlags & D3DCLEAR_ZBUFFER)!=0);
    bDoStencilClear=((dwFlags & D3DCLEAR_STENCIL)!=0);

    if (lpDevI->lpD3DHALGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR)
    {
        if (!(lpDevI->lpD3DHALCallbacks3->Clear2) &&
            !(IS_DX7HAL_DEVICE(lpDevI)))
        {
            if (bDoStencilClear)
            {
                D3D_ERR("Invalid flag D3DCLEAR_STENCIL: this ZBUFFERLESSHSR device doesn't support Clear2()");
                return D3DERR_ZBUFFER_NOTPRESENT;
            }
            if (bDoZClear)
            {
                if (!(lpDevI->lpD3DHALCallbacks2->Clear) || (dvZ!=1.0))
                {
                    D3D_WARN(3,"Ignoring D3DCLEAR_ZBUFFER since this ZBUFFERLESSHSR device doesn't even support Clear() or Z!=1");
                    dwFlags &= ~(D3DCLEAR_ZBUFFER);
                    bDoZClear = FALSE;
                }
            }
        }
    }
    else
    {
        if((this->lpDevI->lpDDSZBuffer==NULL)&&(bDoStencilClear||bDoZClear)) {
            // unlike Clear(), specifying a Zbuffer-clearing flag without a zbuffer will
            // be considered an error

            if(bDoZClear) {
                D3D_ERR("Invalid flag D3DCLEAR_ZBUFFER: no zbuffer is associated with device");
            }
            if(bDoStencilClear) {
                D3D_ERR("Invalid flag D3DCLEAR_STENCIL: no zbuffer is associated with device");
            }
            return D3DERR_ZBUFFER_NOTPRESENT;
        }

        if(bDoStencilClear) {
            pZPixFmt=&((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSZBuffer)->lpLcl->lpGbl->ddpfSurface;
            if(!(pZPixFmt->dwFlags & DDPF_STENCILBUFFER)) {
                D3D_ERR("Invalid flag D3DCLEAR_STENCIL; current zbuffer's pixel format doesnt support stencil bits");
                return D3DERR_STENCILBUFFER_NOTPRESENT;
            }
        }
    }

    if (!(dwFlags & (D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL))) {
        D3D_ERR("no valid flags passed to Clear2");
        err=DDERR_INVALIDPARAMS;
        goto early_out;
    }

#if DBG
// bad clear values just cause wacky results but no crashes, so OK to allow in retail bld

    if(bDoZClear && ((dvZ<0.0) || (dvZ>1.0))) {
        D3D_ERR("clear2 Z value outside legal range (0.0-1.0)");
        err=DDERR_INVALIDPARAMS;
        goto early_out;
    }

    if(bDoStencilClear && pZPixFmt && (dwStencil > (DWORD)((1<<pZPixFmt->dwStencilBitDepth)-1))) {
        D3D_ERR("clear2 stencil value larger than max allowed stencil value for zbuf pixelfmt");
        err=DDERR_INVALIDPARAMS;
        goto early_out;
    }
#endif

    // leave this check in retail build since DDFE_Clear keys off lpDDSBackgndDepth to do textured backg. clrs

    if(bDoZClear && (this->lpDDSBackgndDepth!=NULL)) {
        D3D_ERR("Background Depth Buffer not allowed to be used with Clear2");
        err=DDERR_INVALIDPARAMS;
        goto early_out;
    }

#if DBG
// dont bother with this check for retail, since we can easily ignore existing background material
    if(this->bHaveBackgndMat && bDoRGBClear) {
        D3DMATERIAL dmMat;
        err = D3DHAL_MaterialGetData(this->lpDevI, this->hBackgndMat, &dmMat);
        if (err != D3D_OK) {
            D3D_ERR("Failed to find material from current viewport background material handle");
            goto early_out;
        }
        if(dmMat.hTexture!=0) {
             D3D_ERR("Textured background materials not allowed to be used with Clear2");
             err=DDERR_INVALIDPARAMS;
             goto early_out;
        }
        D3D_WARN(3,"Ignoring current Background Material Color, Clear2 dwColor arg overrides it");
    }
#endif

    // Make sure the correct viewport is set up in the driver.
    err = ValidateViewport(this->lpDevI, this);
    if (err != D3D_OK)
    {
        D3D_ERR("failed to set viewport");
        goto early_out;
    }

    if((err=ProcessRects(this,dwCount,rects))!=D3D_OK)
       goto early_out;

    /* Make sure this viewport is the current viewport for the duration of this call */
    lpTempVwport = this->lpDevI->lpCurrentViewport;
    this->lpDevI->lpCurrentViewport = this;
    if (IS_DX7HAL_DEVICE(lpDevI))
    {
        static_cast<CDirect3DDeviceIDP2*>(lpDevI)->ClearI(dwFlags, clrCount, clrRects, dwColor, dvZ, dwStencil);
    }
    else
    {
        err = D3DFE_Clear2(this->lpDevI, dwFlags, this->clrCount, this->clrRects,
                       dwColor, dvZ, dwStencil);
    }
    /* Restore the original current viewport of the device */
    this->lpDevI->lpCurrentViewport = lpTempVwport;

early_out:
    return err;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::Clear"
extern void TriFillRectsTex(LPDIRECT3DDEVICEI lpDevI, DWORD count, LPD3DRECT rect,D3DTEXTUREHANDLE hTex);

HRESULT D3DAPI DIRECT3DVIEWPORTI::Clear(DWORD dwCount,
                                        LPD3DRECT rects,
                                        DWORD dwFlags)
{
    LPDIRECT3DVIEWPORTI lpTempVwport;
    HRESULT err;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALID_DIRECT3DDEVICE3_PTR(this->lpDevI)) {
            D3D_ERR( "Viewport not attached to Device" );
            return D3DERR_VIEWPORTHASNODEVICE;
        }
#if DBG
        if (IsBadWritePtr(rects, dwCount * sizeof(D3DRECT))) {
            D3D_ERR( "Invalid rects pointer" );
            return DDERR_INVALIDPARAMS;
        }
#endif
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if((dwFlags & D3DCLEAR_ZBUFFER) && (this->lpDevI->lpDDSZBuffer==NULL)) {
        // this is not an error for legacy app compatibility--DX5 allowed this flag
        // to be set even if no ZBuffer exists
        if (!(this->lpDevI->lpD3DHALGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR)
            || !(this->lpDevI->lpD3DHALCallbacks2->Clear || this->lpDevI->lpD3DHALCallbacks3->Clear2
                 || (IS_DX7HAL_DEVICE(lpDevI)))
        )
        {
            D3D_WARN(3,"Ignoring D3DCLEAR_ZBUFFER since no zbuffer associated with device");
            dwFlags &= ~(D3DCLEAR_ZBUFFER);
            if (! dwFlags)
            {
                D3D_WARN(3, "Viewport::Clear: Nothing to do");
                err = D3D_OK;
                goto early_out;
            }
        }
    }

#if DBG
    if (dwFlags & D3DCLEAR_ZBUFFER)
    {
        LPDDPIXELFORMAT pZPixFmt =
            &((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSZBuffer)->lpLcl->lpGbl->ddpfSurface;
        if (pZPixFmt->dwFlags & DDPF_STENCILBUFFER) {
            D3D_ERR("Can't use Clear() on Z buffer with stencil planes. Use Clear2()");
            // No change to execution path.
        }
    }
#endif

    // leave this check until after checks that turn off flags
    if (!(dwFlags & (D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER))) {
        D3D_ERR("no valid flags were passed to Clear");
        err=DDERR_INVALIDPARAMS;
        goto early_out;
    }

    // Make sure the correct viewport is set up in the driver.
    err = ValidateViewport(this->lpDevI, this);
    if (err != D3D_OK)
    {
        D3D_ERR("failed to set viewport");
        goto early_out;
    }

    if((err=ProcessRects(this,dwCount,rects))!=D3D_OK)
       goto early_out;

    D3DMATERIAL dmMat;

    if(this->bHaveBackgndMat) {
        err = D3DHAL_MaterialGetData(lpDevI, this->hBackgndMat, &dmMat);
        if(err != D3D_OK) {
            D3D_ERR("Failed to find material from current background material handle");
            goto early_out;
        }
    } else {
        // DX5 legacy apps expect to Clear to Black if Background not initialized
        dmMat.diffuse.r=dmMat.diffuse.g=dmMat.diffuse.b=dmMat.diffuse.a=0;
        dmMat.hTexture=0;
        D3D_WARN(3,"Background Material is NULL!!  Setting color to black, but please set a valid background");
    }

    /* Make sure this viewport is the current viewport for the duration of this call */
    lpTempVwport = this->lpDevI->lpCurrentViewport;
    this->lpDevI->lpCurrentViewport = this;

    if (IS_DX7HAL_DEVICE(lpDevI))
    {
        if (0 != dmMat.hTexture && (D3DCLEAR_TARGET & dwFlags))
        {
            err = lpDevI->FlushStates();
            if (err != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in Clear");
                goto early_out;
            }
            TriFillRectsTex(lpDevI, clrCount, clrRects, dmMat.hTexture);
            dwFlags &= ~D3DCLEAR_TARGET;
        }
        if ((D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER) & dwFlags)
        {
            static_cast<CDirect3DDeviceIDP2*>(lpDevI)->ClearI(dwFlags, clrCount, clrRects, CVAL_TO_RGBA(dmMat.diffuse), 1.0, 0);
        }
    }
    else
    {
        err = D3DFE_Clear(this->lpDevI, dwFlags, this->clrCount, this->clrRects,
                      &dmMat.diffuse, dmMat.hTexture);
    }
    /* Restore the original current viewport of the device */
    this->lpDevI->lpCurrentViewport = lpTempVwport;

early_out:
    return err;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::AddLight"

HRESULT D3DAPI DIRECT3DVIEWPORTI::AddLight(LPDIRECT3DLIGHT lpD3DLight)
{
    LPDIRECT3DLIGHTI lpLightI;
    HRESULT err = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        lpLightI = (LPDIRECT3DLIGHTI)lpD3DLight;

        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DLIGHT_PTR(lpLightI)) {
            D3D_ERR( "Invalid DIRECT3DLIGHT pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (lpLightI->lpD3DViewportI) {
        D3D_ERR("light already associated with a viewport");
        return (D3DERR_LIGHTHASVIEWPORT);
    }

    err = hookLightToViewport(this, lpLightI);
    if (err != D3D_OK) {
        D3D_ERR("failed to add light to viewport");
        return (err);
    }

    this->bLightsChanged = TRUE;

    /*
     * AddRef the light
     */
    lpD3DLight->AddRef();

    return (err);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::DeleteLight"

HRESULT D3DAPI DIRECT3DVIEWPORTI::DeleteLight(LPDIRECT3DLIGHT lpD3DLight)
{
    LPDIRECT3DLIGHTI lpLightI;
    HRESULT err = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        lpLightI = (LPDIRECT3DLIGHTI)lpD3DLight;
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DLIGHT_PTR(lpLightI)) {
            D3D_ERR( "Invalid DIRECT3DLIGHT pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (lpLightI->lpD3DViewportI != this) {
        D3D_ERR("Light is not associated with this viewport");
        return (D3DERR_LIGHTNOTINTHISVIEWPORT);
    }

    /*
     * Remove this light from the viewport.
     */
    CIRCLE_QUEUE_DELETE(&this->lights, lpLightI, light_list);
    this->numLights--;

    lpLightI->lpD3DViewportI = NULL;

    this->bLightsChanged = TRUE;

    /*
     * Release the light
     */
    lpD3DLight->Release();

    return (err);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::NextLight"

HRESULT D3DAPI DIRECT3DVIEWPORTI::NextLight(LPDIRECT3DLIGHT lpD3DLight,
                                            LPDIRECT3DLIGHT* lplpLight,
                                            DWORD dwFlags)
{
    LPDIRECT3DLIGHTI lpLightI;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_OUTPTR(lplpLight)) {
            D3D_ERR( "Invalid output pointer to LPDIRECT3DLIGHT" );
            return DDERR_INVALIDPARAMS;
        }

        *lplpLight = NULL;

        lpLightI = (LPDIRECT3DLIGHTI)lpD3DLight;
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (dwFlags & D3DNEXT_NEXT) {
            if (!VALID_DIRECT3DLIGHT_PTR(lpLightI)) {
                D3D_ERR( "Invalid Direct3DLight pointer" );
                return DDERR_INVALIDPARAMS;
            }

            if (lpLightI && lpLightI->lpD3DViewportI != this) {
                D3D_ERR("light not associated with this viewport");
                return (D3DERR_LIGHTNOTINTHISVIEWPORT);
            }
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    switch (dwFlags) {
    case D3DNEXT_NEXT:
        *lplpLight = (LPDIRECT3DLIGHT)CIRCLE_QUEUE_NEXT(this,lpLightI,light_list);
        break;
    case D3DNEXT_HEAD:
        *lplpLight = (LPDIRECT3DLIGHT)CIRCLE_QUEUE_FIRST(&this->lights);
        break;
    case D3DNEXT_TAIL:
        *lplpLight = (LPDIRECT3DLIGHT)CIRCLE_QUEUE_LAST(&this->lights);
        break;
    default:
        D3D_ERR("invalid flags");
        return (DDERR_INVALIDPARAMS);
    }
    if (*lplpLight == (LPDIRECT3DLIGHT)&this->lights) {
        *lplpLight = NULL;
    }

    /*
     * Must AddRef the returned object
     */
    if (*lplpLight)
        (*lplpLight)->AddRef();

    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\d3dcom.h ===
/*
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       objbase.h
//
//  Contents:   Component object model defintions.
//
//  History:    02-7-94   terryru           Created.
//
//----------------------------------------------------------------------------
*/
/*
 * Taken from objbase.h
 */
#ifndef _D3DCOM_H
#define _D3DCOM_H

#include "subwtype.h"

#ifndef WIN32
#define __export
#define __stdcall
#endif /* WIN32 */

typedef void    IUnknown;
#ifndef WINAPI
#define WINAPI
#endif
#define FAR
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | \
            ((unsigned long)(fac)<<16) | \
             ((unsigned long)(code))))

/* Component Object Model defines, and macros */

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#ifdef WIN32

/* Win32 doesn't support __export */

#define STDMETHODCALLTYPE       __stdcall
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

/* The 'V' versions allow Variable Argument lists. */

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */


#if defined(__cplusplus) && !defined(CINTERFACE)
/*#define interface               struct FAR */
#define interface struct
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface



#else

#define interface               struct


#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)




#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#define CONST_VTBL const
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#define CONST_VTBL
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)

#endif

#endif /* _D3DCOM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\drawprim.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drawprim.hpp
 *  Content:    DrawPrimitive common defines
 *
 ***************************************************************************/

#ifndef _DRAWPRIM_H_
#define _DRAWPRIM_H_

#define MAX_DX6_PRIMCOUNT   ((1<<16) - 1)
#define MAX_DX6_VERTICES    MAX_DX6_PRIMCOUNT

extern HRESULT DoDrawPrimitive(LPD3DFE_PROCESSVERTICES pv);
extern HRESULT DoDrawIndexedPrimitive(LPD3DFE_PROCESSVERTICES pv);
extern HRESULT downloadView(LPDIRECT3DVIEWPORTI);
extern HRESULT CheckDrawPrimitive(LPDIRECT3DDEVICEI lpDevI);
extern HRESULT CheckDrawIndexedPrimitive(LPDIRECT3DDEVICEI lpDevI);

// All vertices from lpDevI->lpVout are copied to the output buffer, expanding
// to D3DTLVERTEX.
// The output buffer is lpAddress if it is not NULL, otherwise it is TLVbuf
//
extern HRESULT MapFVFtoTLVertex(LPDIRECT3DDEVICEI lpDevI, LPVOID lpAddress);
//---------------------------------------------------------------------
#define FVF_TRANSFORMED(dwFVF) ((dwFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
#define FVF_DRIVERSUPPORTED(lpDevI) (lpDevI->dwDeviceFlags & D3DDEV_FVF)
#define FVF_TEXCOORD_NUMBER(dwFVF) \
    (((dwFVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT)
//---------------------------------------------------------------------
// Input:
//    type      - FVF control word
//
// Returns D3D_OK, if the control word is valid.
// DDERR_INVALIDPARAMS otherwise
//
#undef  DPF_MODNAME
#define DPF_MODNAME "ValidateFVF"

__inline HRESULT ValidateFVF(DWORD type)
{
    DWORD dwTexCoord = FVF_TEXCOORD_NUMBER(type);
    DWORD vertexType = type & D3DFVF_POSITION_MASK;
    // Texture type fields should be 0
    // Reserved field 0 and 2 should be 0
    // Reserved 1 should be set only for LVERTEX
    // Only two vertex position types allowed
    if (type & 0xFFFF0000 ||
        type & (D3DFVF_RESERVED2 | D3DFVF_RESERVED0) ||
        (type & D3DFVF_RESERVED1 && !(type & D3DFVF_LVERTEX)) ||
        !(vertexType == D3DFVF_XYZRHW || vertexType == D3DFVF_XYZ)
        )
        goto error;

    if (vertexType == D3DFVF_XYZRHW && type & D3DFVF_NORMAL)
        goto error;
    return D3D_OK;
error:
    D3D_ERR("ValidateFVF() returns DDERR_INVALIDPARAMS");
    return DDERR_INVALIDPARAMS;
}
//---------------------------------------------------------------------
// Computes vertex size in bytes from the vertex ID
//
__inline DWORD GetVertexSizeFVF(DWORD fvf)
{
    DWORD size = 3;
    if (FVF_TRANSFORMED(fvf))
        size++;
    if (fvf & D3DFVF_NORMAL)
        size += 3;
    if (fvf & D3DFVF_RESERVED1)
        size++;
    size += FVF_TEXCOORD_NUMBER(fvf) << 1;

    if (fvf & D3DFVF_DIFFUSE)
        size++;
    if (fvf & D3DFVF_SPECULAR)
        size++;
    return (size << 2);
}
//---------------------------------------------------------------------
__inline BOOL TextureStageEnabled(LPDIRECT3DDEVICEI lpDevI, DWORD dwStage)
{
    return (lpDevI->tsstates[dwStage][D3DTSS_COLOROP] != D3DTOP_DISABLE &&
            lpDevI->lpD3DMappedTexI[dwStage] != NULL);
}
//---------------------------------------------------------------------
// Computes nTexCoord and dwTextureIndexToCopy in case when a pre-DX6
// driver is used.
__inline void ComputeTCI2CopyLegacy(LPDIRECT3DDEVICEI lpDevI,
                                    DWORD dwNumInpTexCoord,
                                    BOOL bVertexTransformed)
{
    if (lpDevI->dwDeviceFlags & D3DDEV_LEGACYTEXTURE)
    {
        lpDevI->dwTextureIndexToCopy = 0;
        if (dwNumInpTexCoord)
            lpDevI->nTexCoord = 1;
        else
        {
            lpDevI->nTexCoord = 0;
            D3D_WARN(1, "Texture is enabled but vertex has no texture coordinates");
        }
    }
    else
    {
        if (TextureStageEnabled(lpDevI, 0))
        {
            if (lpDevI->tsstates[0][D3DTSS_TEXCOORDINDEX] >= dwNumInpTexCoord)
            {
                lpDevI->nTexCoord = 0;
                lpDevI->dwTextureIndexToCopy = 0;
                D3D_WARN(1, "Texture index in a texture stage is greater than number of texture coord in vertex");
            }
            else
            {
                lpDevI->dwTextureIndexToCopy = lpDevI->tsstates[0][D3DTSS_TEXCOORDINDEX];
                if (bVertexTransformed)
                {
                    // In case of clipping we need to clip as many texture
                    // coordinates as set in the texture stage state.
                    lpDevI->nTexCoord = min(dwNumInpTexCoord,
                                            lpDevI->dwTextureIndexToCopy+1);
                }
                else
                {
                    // Number of output texture coordinates is 1 because we will
                    // build the output buffer in the inner transform & lihgting
                    // loop.
                    lpDevI->nTexCoord = 1;
                }
            }
        }
        else
        {
            lpDevI->nTexCoord = 0;
            lpDevI->dwTextureIndexToCopy = 0;
        }
    }
}
//---------------------------------------------------------------------
// Computes output FVF id, based on input FVF id and device settingd
// Also computes nTexCoord field
// Number of texture coordinates is set based on dwVIDIn. ValidateFVF sould
// make sure that it is not greater than supported by the driver
// Last settings for dwVIDOut and dwVIDIn are saved to speed up processing
//
#undef  DPF_MODNAME
#define DPF_MODNAME "ComputeOutputFVF"
__inline void ComputeOutputFVF(LPDIRECT3DDEVICEI lpDevI)
{
    if (lpDevI->dwVIDIn == lpDevI->dwFVFLastIn)
    {
        lpDevI->dwVIDOut = lpDevI->dwFVFLastOut;
        lpDevI->dwOutputSize = lpDevI->dwFVFLastOutputSize;
        lpDevI->nTexCoord = lpDevI->dwFVFLastTexCoord;
        return;
    }
    DWORD dwNumInpTexCoord = FVF_TEXCOORD_NUMBER(lpDevI->dwVIDIn);
    // Compute how many texture coordinates to copy
    if (lpDevI->dwMaxTextureIndices == 0)
        lpDevI->nTexCoord = 0;
    else
    if (!(lpDevI->dwDeviceFlags & D3DDEV_FVF))
    {
        ComputeTCI2CopyLegacy(lpDevI, dwNumInpTexCoord, FVF_TRANSFORMED(lpDevI->dwVIDIn));
    }
    else
    {
        if (lpDevI->dwDeviceFlags & D3DDEV_LEGACYTEXTURE)
            lpDevI->nTexCoord = 1;
        else
        {
        // Find the max used index
            if (!(lpDevI->dwFEFlags & D3DFE_TSSINDEX_DIRTY))
                lpDevI->nTexCoord = lpDevI->dwMaxUsedTextureIndex;
            else
            {
                lpDevI->dwMaxUsedTextureIndex = 0;
                for (DWORD i=0; i < lpDevI->dwMaxTextureBlendStages; i++)
                {
                    if (lpDevI->tsstates[i][D3DTSS_COLOROP] == D3DTOP_DISABLE)
                        break;

                    if (lpDevI->lpD3DMappedTexI[i] != NULL)
                    {
                        DWORD dwNewMaxTexCoord = lpDevI->tsstates[i][D3DTSS_TEXCOORDINDEX] + 1;
                        if (lpDevI->dwMaxUsedTextureIndex < dwNewMaxTexCoord)
                        {
                            lpDevI->dwMaxUsedTextureIndex = dwNewMaxTexCoord;
                        }
                    }
                }
                lpDevI->nTexCoord = lpDevI->dwMaxUsedTextureIndex;
                lpDevI->dwFEFlags &= ~D3DFE_TSSINDEX_DIRTY;
            }
        }
        if (lpDevI->nTexCoord > dwNumInpTexCoord)
        {
            lpDevI->nTexCoord = dwNumInpTexCoord;
            D3D_WARN(1, "Texture index in a texture stage is greater than number of texture coord in vertex");
        }
    }
    if (!(lpDevI->dwDeviceFlags & D3DDEV_FVF))
    {
        lpDevI->dwVIDOut = D3DFVF_TLVERTEX;
        lpDevI->dwOutputSize = sizeof(D3DTLVERTEX);
    }
    else
    {
        if (lpDevI->dwDeviceFlags & D3DDEV_DONOTSTRIPELEMENTS)
        {   // In this case diffuse, specular and at least one texture
            // should present
            lpDevI->dwVIDOut = D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
            if (lpDevI->nTexCoord == 0)
                lpDevI->dwVIDOut |= 1 << D3DFVF_TEXCOUNT_SHIFT;
            else
                lpDevI->dwVIDOut |= lpDevI->nTexCoord << D3DFVF_TEXCOUNT_SHIFT;
        }
        else
        {
            lpDevI->dwVIDOut = D3DFVF_XYZRHW;
            // If normal present we have to compute specular and duffuse
            // Otherwise set these bits the same as input.
            // Not that normal should not be present for XYZRHW position type
            if (lpDevI->dwVIDIn & D3DFVF_NORMAL)
                lpDevI->dwVIDOut |= D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
            else
                lpDevI->dwVIDOut |= lpDevI->dwVIDIn &
                                    (D3DFVF_DIFFUSE | D3DFVF_SPECULAR);
            // Always set specular flag if fog is enabled
            if (lpDevI->rstates[D3DRENDERSTATE_FOGENABLE])
                lpDevI->dwVIDOut |= D3DFVF_SPECULAR;
            else
            // Clear specular flag if specular disabled
            if (!lpDevI->rstates[D3DRENDERSTATE_SPECULARENABLE])
                lpDevI->dwVIDOut &= ~D3DFVF_SPECULAR;
            lpDevI->dwVIDOut |= lpDevI->nTexCoord << D3DFVF_TEXCOUNT_SHIFT;
        }
        lpDevI->dwOutputSize = GetVertexSizeFVF(lpDevI->dwVIDOut);
    }
    lpDevI->dwFVFLastIn = lpDevI->dwVIDIn;
    lpDevI->dwFVFLastOut = lpDevI->dwVIDOut;
    lpDevI->dwFVFLastOutputSize = lpDevI->dwOutputSize;
    lpDevI->dwFVFLastTexCoord = lpDevI->nTexCoord;
    return;
}
//---------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "CheckDeviceSettings"
inline HRESULT CheckDeviceSettings(LPDIRECT3DDEVICEI lpDevI)
{
    LPDIRECT3DVIEWPORTI lpView = lpDevI->lpCurrentViewport;
#if DBG
    if (!(lpDevI->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE) && IS_DX5_COMPATIBLE_DEVICE(lpDevI))
    {
        D3D_ERR( "Not in scene" );
        return D3DERR_SCENE_NOT_IN_SCENE;
    }

    if (!lpView)
    {
        D3D_ERR( "Current viewport not set" );
        return D3DERR_INVALIDCURRENTVIEWPORT;
    }

    if (!lpView->v_data_is_set)
    {
        D3D_ERR("Viewport data is not set yet");
        return D3DERR_VIEWPORTDATANOTSET;
    }

    if (lpDevI->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "Illegal call between Begin/End" );
        return D3DERR_INBEGIN;
    }
#endif
    // Viewport ID could be different from Device->v_id, because during Execute call
    // Device->v_id is changed to whatever viewport is used as a parameter.
    // So we have to make sure that we use the right viewport.
    //
    if (lpDevI->v_id != lpView->v_id)
    {
        return downloadView(lpView);
    }
    else
        return D3D_OK;
}
//---------------------------------------------------------------------
// Computes the number of primtives and also updates the stats accordingly
// Input:  lpDevI->primType
//         dwNumVertices
// Output: lpDevI->dwNumPrimitives
//         lpDevI->D3DStats
//         return value = dwNumPrimitives
#undef DPF_MODNAME
#define DPF_MODNAME "GetNumPrim"

inline DWORD GetNumPrim(LPDIRECT3DDEVICEI lpDevI, DWORD dwNumVertices)
{
    lpDevI->dwNumPrimitives = 0;
    switch (lpDevI->primType)
    {
    case D3DPT_POINTLIST:
        lpDevI->D3DStats.dwPointsDrawn += lpDevI->dwNumPrimitives = dwNumVertices;
        break;
    case D3DPT_LINELIST:
        lpDevI->D3DStats.dwLinesDrawn += lpDevI->dwNumPrimitives = dwNumVertices >> 1;
        break;
    case D3DPT_LINESTRIP:
        if (dwNumVertices < 2)
            return 0;
        lpDevI->D3DStats.dwLinesDrawn += lpDevI->dwNumPrimitives = dwNumVertices - 1;
        break;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (dwNumVertices < 3)
            return 0;
        lpDevI->D3DStats.dwTrianglesDrawn += lpDevI->dwNumPrimitives = dwNumVertices - 2;
        break;
    case D3DPT_TRIANGLELIST:
#ifdef _X86_
        {
            DWORD tmp;
            __asm
            {
                mov  eax, 0x55555555    // fractional part of 1.0/3.0
                mul  dwNumVertices
                add  eax, 0x80000000    // Rounding
                adc  edx, 0
                mov  tmp, edx
            }
            lpDevI->D3DStats.dwTrianglesDrawn += lpDevI->dwNumPrimitives = tmp;
        }
#else
        lpDevI->D3DStats.dwTrianglesDrawn += lpDevI->dwNumPrimitives = dwNumVertices / 3;
#endif
        break;
    }
    return lpDevI->dwNumPrimitives;
}
//---------------------------------------------------------------------
// Sets front-end flags every time fog state is changed
//
inline void SetFogFlags(LPDIRECT3DDEVICEI lpDevI)
{
    if (lpDevI->lighting.fog_mode != D3DFOG_NONE &&
        lpDevI->rstates[D3DRENDERSTATE_FOGENABLE])
    {
        lpDevI->dwFEFlags |= D3DFE_FOG_DIRTY | D3DFE_FOGENABLED;
    }
    else
        lpDevI->dwFEFlags &= ~D3DFE_FOGENABLED;
    lpDevI->dwFVFLastIn = 0; // Force re-computing of FVF id
}
//---------------------------------------------------------------------
// Validates DrawPrimitive flags
//
inline BOOL IsDPFlagsValid(DWORD dwFlags)
{
    BOOL ret = ((dwFlags & ~(D3DDP_DONOTCLIP | D3DDP_DONOTUPDATEEXTENTS |
                             D3DDP_WAIT | D3DDP_DONOTLIGHT)
                ) == 0);
    if (!ret)
    {
        D3D_ERR( "Invalid bit set in DrawPrimitive flags" );
    }
    return ret;
}
//---------------------------------------------------------------------
// Allocate memory to hold vertex data, assume all vertices are
// of same size
inline HRESULT CheckVertexBatch(LPDIRECT3DDEVICEI lpDevI)
{
    if (!lpDevI->lpvVertexBatch)
    {
        if (D3DMalloc((void**) &lpDevI->lpvVertexBatch,
                       BEGIN_DATA_BLOCK_MEM_SIZE))
        {
            D3D_ERR( "Out of memory" );
            return DDERR_OUTOFMEMORY;
        }
        // Allocate memory to hold index data
        if (D3DMalloc((void**) &lpDevI->lpIndexBatch,
                      BEGIN_DATA_BLOCK_SIZE * sizeof(WORD) * 16))
        {
            D3DFree( lpDevI->lpvVertexBatch );
            D3D_ERR( "Out of memory" );
            return DDERR_OUTOFMEMORY;
        }
    }
    return D3D_OK;
}

#endif _DRAWPRIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\dpgen.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpgen.h
 *  Content:    Generate some functions for Draw Primitive 
 *
 ***************************************************************************/

#ifdef __DRAWPRIMFUNC

//---------------------------------------------------------------------
// Draws indexed and non-indexed primitives which do not require clipping
//
#ifdef  __DRAWPRIMINDEX
HRESULT CDirect3DDeviceIDP::DrawIndexPrim()
{
    D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA dpData;
    DWORD &dwNumElements = this->dwNumIndices;
#else
HRESULT CDirect3DDeviceIDP::DrawPrim()
{
    D3DHAL_DRAWONEPRIMITIVEDATA dpData;
    DWORD &dwNumElements = this->dwNumVertices;
#endif
    const WORD vertexType = D3DVT_TLVERTEX;    // XXX While we do not have DDI
    // Do we need to map new texture stage operations to DX5 renderstates?
    if(this->dwFEFlags & D3DFE_MAP_TSS_TO_RS) {
        MapTSSToRS();
        this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS; // Reset request bit
    }
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        UpdateTextures();
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }
    
    if (dwNumElements < LOWVERTICESNUMBER && 
        this->dwCurrentBatchVID == this->dwVIDOut)
    {
        LPD3DHAL_DRAWPRIMCOUNTS lpPC;
        lpPC = this->lpDPPrimCounts;
        if (lpPC->wNumVertices)
        {
            if ((lpPC->wPrimitiveType!=(WORD) this->primType) ||
                (lpPC->wVertexType != vertexType) ||
                (this->primType==D3DPT_TRIANGLESTRIP) ||
                (this->primType==D3DPT_TRIANGLEFAN) ||
                (this->primType==D3DPT_LINESTRIP))
            {
                lpPC = this->lpDPPrimCounts=(LPD3DHAL_DRAWPRIMCOUNTS)
                       ((LPBYTE)this->lpwDPBuffer + this->dwDPOffset);
                memset( (char *)lpPC, 0, sizeof(D3DHAL_DRAWPRIMCOUNTS));
                // preserve 32 bytes alignment for vertices
                this->dwDPOffset += sizeof(D3DHAL_DRAWPRIMCOUNTS);
                ALIGN32(this->dwDPOffset);
            }
        }
        else
        {
            // 32-byte align offset pointer, just in case states have been
            // recorded.
            ALIGN32(this->dwDPOffset);
        }
        ULONG ByteCount;
        if (FVF_DRIVERSUPPORTED(this))
            ByteCount = dwNumElements * this->dwOutputSize;
        else
            ByteCount = dwNumElements << 5;   // D3DTLVERTEX
        if (this->dwDPOffset + ByteCount  > this->dwDPMaxOffset)
        {
            CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));  // Takes D3D lock (ST only).
            //DPF(0,"overflowed ByteCount=%08lx",ByteCount);
            HRESULT ret;
            ret = this->FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in Draw*Prim");
                return ret;
            }
            lpPC = this->lpDPPrimCounts;
            ALIGN32(this->dwDPOffset);
        }
        lpPC->wPrimitiveType = (WORD)this->primType;
        lpPC->wVertexType = (WORD)vertexType;
        lpPC->wNumVertices += (WORD)dwNumElements;
        BYTE *lpVertex = (BYTE*)((char *)this->lpwDPBuffer + this->dwDPOffset);
#ifdef __DRAWPRIMINDEX
        DWORD  i;
        BYTE *pV = (BYTE*)this->lpvOut;
        if (FVF_DRIVERSUPPORTED(this) || this->dwVIDOut == D3DFVF_TLVERTEX)
            for (i=0; i < this->dwNumIndices; i++)
            {
                memcpy(lpVertex, pV + this->lpwIndices[i] * this->dwOutputSize,
                       this->dwOutputSize);
                lpVertex += this->dwOutputSize;
            }
        else
            for (i=0; i < this->dwNumIndices; i++)
            {
                MapFVFtoTLVertex1(this, (D3DTLVERTEX*)lpVertex, 
                                  (DWORD*)(pV + this->lpwIndices[i] * 
                                           this->dwOutputSize));
                lpVertex += sizeof(D3DTLVERTEX);
            }
#else // !__DRAWPRIMINDEX
        if (FVF_DRIVERSUPPORTED(this) || this->dwVIDOut == D3DFVF_TLVERTEX)
            memcpy(lpVertex, this->lpvOut, ByteCount);
        else
            MapFVFtoTLVertex(this, lpVertex);
#endif //__DRAWPRIMINDEX
        this->dwDPOffset += ByteCount;
        return D3D_OK;
    }
    else
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
        HRESULT ret;
        ret = this->FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in Draw*Prim");
            return ret;
        }
        dpData.dwhContext = this->dwhContext;
        dpData.dwFlags =  this->dwFlags;
        dpData.PrimitiveType = this->primType;
        if (FVF_DRIVERSUPPORTED(this))
        {
            dpData.dwFVFControl = this->dwVIDOut;
            dpData.lpvVertices = this->lpvOut;
        }
        else
        {
            if (this->dwVIDOut == D3DFVF_TLVERTEX)
                dpData.lpvVertices = this->lpvOut;
            else
            {
                HRESULT ret;
                if ((ret = MapFVFtoTLVertex(this, NULL)) != D3D_OK)
                    return ret;
                dpData.lpvVertices = this->TLVbuf.GetAddress();
            }
            dpData.VertexType = (D3DVERTEXTYPE)vertexType;
            if (this->dwDebugFlags & D3DDEBUG_DISABLEFVF)
                dpData.dwFVFControl = D3DFVF_TLVERTEX;
        }
        dpData.dwNumVertices = this->dwNumVertices;
        dpData.ddrval = D3D_OK;
#ifdef __DRAWPRIMINDEX
        dpData.lpwIndices = this->lpwIndices;
        dpData.dwNumIndices = this->dwNumIndices;
#endif
        // Spin waiting on the driver if wait requested
#if _D3D_FORCEDOUBLE
        CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE
        do {
            DWORD dwRet;
        #ifndef WIN95
            if((dwRet = CheckContextSurface(this)) != D3D_OK)
            {
                return (dwRet);
            }
        #endif //WIN95
#ifdef __DRAWPRIMINDEX
            CALL_HAL2ONLY(dwRet, this, DrawOneIndexedPrimitive, &dpData);
#else
            CALL_HAL2ONLY(dwRet, this, DrawOnePrimitive, &dpData);
#endif
            if (dwRet != DDHAL_DRIVER_HANDLED)
            {
                D3D_ERR ( "Driver not handled in DrawOnePrimitive" );
                // Need sensible return value in this case,
                // currently we return whatever the driver stuck in here.
            }

        } while ( (this->dwFlags & D3DDP_WAIT) && (dpData.ddrval == DDERR_WASSTILLDRAWING) );
    }
    return dpData.ddrval;
}

#endif //__DRAWPRIMFUNC

#undef __DRAWPRIMFUNC
#undef __DRAWPRIMINDEX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\d3dpr.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dpr.h
 *  Content:    Direct3D private include file
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *   23/11/95   colinmc Made various Direct3D interfaces queryable off
 *                      DirectDraw.
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *   17/04/96   colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef _D3DPR_H_
#define _D3DPR_H_
#include "d3di.hpp"
#include "texman.hpp"
#include "dpf.h"

/*
 * Texture Manipulation Utils
 */
extern void D3DI_RemoveTextureHandle(LPD3DI_TEXTUREBLOCK);
extern void D3DI_RemoveMaterialBlock(LPD3DI_MATERIALBLOCK);

extern DWORD BitDepthToDDBD(int bpp);
extern BOOL D3DI_isHALValid(LPD3DHAL_CALLBACKS pCallbacks);
extern void FreeDeviceI(LPDIRECT3DDEVICEI pDevI);

extern HRESULT D3DBufFreeBufferMemory(LPDIRECT3DEXECUTEBUFFERI lpBuf, DWORD dwWhere);
extern HRESULT D3DBufAllocateBufferMemory(LPDIRECT3DEXECUTEBUFFERI lpBuf, DWORD dwWhere);
extern HRESULT D3DBufHookBufferToDevice(LPDIRECT3DDEVICEI lpDev, LPDIRECT3DEXECUTEBUFFERI lpBuf);
extern HRESULT HookD3DDeviceToSurface(LPDIRECT3DDEVICEI,LPDDRAWI_DDRAWSURFACE_LCL);
extern void UnHookD3DDeviceFromSurface(LPDIRECT3DDEVICEI,LPDDRAWI_DDRAWSURFACE_LCL);
#define D3DBUCKETBUFFERSIZE 32  //make buffer byte size 2*D3DBUCKETBUFFERSIZE*4
extern HRESULT D3DMallocBucket(LPDIRECT3DI, LPD3DBUCKET *);
extern void D3DFreeBucket(LPDIRECT3DI, LPD3DBUCKET);
extern LPD3DI_TEXTUREBLOCK D3DI_FindTextureBlock(LPDIRECT3DTEXTUREI,LPDIRECT3DDEVICEI);
extern HRESULT CopySurface(LPDIRECTDRAWSURFACE4,LPDIRECTDRAWSURFACE4,LPDIRECTDRAWCLIPPER);
extern HRESULT GetTextureDDIHandle(LPDIRECT3DTEXTUREI,LPDIRECT3DDEVICEI,LPD3DI_TEXTUREBLOCK*);

__inline void
BatchTextureToDevice(LPDIRECT3DDEVICEI lpDevI, LPDDRAWI_DDRAWSURFACE_LCL lpLcl) {
        LPD3DBUCKET   lpTextureBatched;
    if ( D3D_OK != HookD3DDeviceToSurface(lpDevI,lpLcl)) {
        return;
    }
    if (D3DMallocBucket(lpDevI->lpDirect3DI,&lpTextureBatched) != D3D_OK)
    {   //this is left often to happen
        UnHookD3DDeviceFromSurface(lpDevI, lpLcl);
        return;
    }
    lpTextureBatched->lpLcl=lpLcl;
    lpTextureBatched->next=lpDevI->lpTextureBatched;
    lpDevI->lpTextureBatched=lpTextureBatched;
        return;
}

__inline void
FlushTextureFromDevice(LPDIRECT3DDEVICEI lpDevI) 
{
    LPD3DBUCKET   current=lpDevI->lpTextureBatched;
    DWORD   dwStage;
    while(current)
    {
        LPD3DBUCKET   temp;
        temp=current->next;
        UnHookD3DDeviceFromSurface(lpDevI,current->lpLcl);
        D3DFreeBucket(lpDevI->lpDirect3DI,current);
        current=temp;
    }
    lpDevI->lpTextureBatched=NULL;
    if (lpDevI->lpDDSZBuffer && (1==lpDevI->dwVersion))
    {
        if (!lpDevI->lpDDSZBuffer_DDS4) // DDRAW zeroed it ?
        {
            UnHookD3DDeviceFromSurface(lpDevI,((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSZBuffer)->lpLcl);
            lpDevI->lpDDSZBuffer=NULL;
        }
    }
    for (dwStage=0;dwStage < lpDevI->dwMaxTextureBlendStages; dwStage++)
    {
        LPD3DI_TEXTUREBLOCK lpBlock = lpDevI->lpD3DMappedBlock[dwStage];
        LPDIRECT3DTEXTUREI  lpTexI = lpDevI->lpD3DMappedTexI[dwStage];
        if (NULL != lpTexI
            && NULL != lpBlock
            && 0 != lpBlock->hTex)
        {
            if(lpTexI->lpDDS != NULL)
            {
                BatchTextureToDevice(lpDevI, ((LPDDRAWI_DDRAWSURFACE_INT) lpTexI->lpDDS)->lpLcl);
            }
            else
            {
                BatchTextureToDevice(lpDevI, ((LPDDRAWI_DDRAWSURFACE_INT) lpTexI->lpDDSSys)->lpLcl);
            }
        }
    }
    return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VerifyTextureCaps"
__inline HRESULT
VerifyTextureCaps(LPDIRECT3DDEVICEI lpDev, LPDDRAWI_DDRAWSURFACE_INT lpDDS)
{
    DWORD texcap;
    WORD width, height;
    DDASSERT(lpDDS != NULL);
    /* first verify the dimensions */
    if (lpDev->d3dHWDevDesc.dwFlags & D3DDD_TRICAPS)
        texcap = lpDev->d3dHWDevDesc.dpcTriCaps.dwTextureCaps;
    else
        texcap = lpDev->d3dHELDevDesc.dpcTriCaps.dwTextureCaps;
    width = lpDDS->lpLcl->lpGbl->wWidth;
    height = lpDDS->lpLcl->lpGbl->wHeight;
    if (texcap & D3DPTEXTURECAPS_POW2)
    {
        if (width & (width - 1)) // Clear the right most set bit
        {
            if (texcap & D3DPTEXTURECAPS_NONPOW2CONDITIONAL)
            {
                D3D_INFO( 3, "Texture width not a power of two");
                D3D_INFO( 3, "  with D3DPTEXTURECAPS_NONPOW2CONDITIONAL");
            }
            else
            {
                D3D_ERR("Texture width not a power of two");
                return D3DERR_TEXTURE_BADSIZE;
            }
        }
        if (height & (height - 1)) // Clear the right most set bit
        {
            if (texcap & D3DPTEXTURECAPS_NONPOW2CONDITIONAL)
            {
                D3D_INFO( 3, "Texture height not a power of two");
                D3D_INFO( 3, "  with D3DPTEXTURECAPS_NONPOW2CONDITIONAL");
            }
            else
            {
                D3D_ERR("Texture height not a power of two");
                return D3DERR_TEXTURE_BADSIZE;
            }
        }
    }
    if (texcap & D3DPTEXTURECAPS_SQUAREONLY)
    {
        if (width != height)
        {
            D3D_ERR("Texture not square");
            return D3DERR_TEXTURE_BADSIZE;
        }
    }
    return  D3D_OK;
}

#if _D3D_FORCEDOUBLE
class CD3DForceFPUDouble
{
private:
    WORD    wFPUCW;
    WORD    wSaved;
public:
    __inline
    CD3DForceFPUDouble(CDirect3DDeviceIHW * lpDevI)
    {
        wSaved=FALSE;
        if (lpDevI->dwDebugFlags & D3DDEBUG_FORCEDOUBLE)
        {
            WORD    wTemp;
            __asm   fstcw   wTemp
            if (!(wTemp & 0x0200))
            {
                wSaved=TRUE;
                wFPUCW=wTemp;
                wTemp=wFPUCW | 0x0200;  //Enforce Double Precision bit
                __asm   fldcw  wTemp
            }
        }
    }
    __inline
    ~CD3DForceFPUDouble()
    {
        if (wSaved)
        {
            WORD    wTemp = wFPUCW;
            __asm   fldcw  wTemp
        }
    }
};
#endif  //_D3D_FORCEDOUBLE

//---------------------------------------------------------------------
// The CSetD3DFPstate is used to facilitate the changing of FPU settings.
// In the constructor the optimal FPU state is set. In the destructor the
// old state is restored.
//
class CD3DFPstate
{
public:
    CD3DFPstate()
        {
        #ifdef _X86_
            WORD wTemp, wSave;
            wSavedFP = FALSE;
            // Disable floating point exceptions and go to single mode
                __asm fstcw wSave
                if (wSave & 0x300 ||            // Not single mode
                    0x3f != (wSave & 0x3f) ||   // Exceptions enabled
                    wSave & 0xC00)              // Not round to nearest mode
                {
                    __asm {
                        mov ax, wSave
                        and ax, not 300h    ;; single mode
                        or  ax, 3fh         ;; disable all exceptions
                        and ax, not 0xC00   ;; round to nearest mode
                        mov wTemp, ax
                        fldcw   wTemp
                    }
                    wSavedFP = TRUE;
                }
                wSaveFP = wSave;
        #endif
        }
    ~CD3DFPstate()
        {
        #ifdef _X86_
            WORD wSave = wSaveFP;
            if (wSavedFP)
                __asm {
                    fnclex
                    fldcw   wSave
                }
        #endif
        }
protected:
#ifdef _X86_
    WORD wSaveFP;
    WORD wSavedFP;  // WORD-sized to make the data an even DWORD
#endif
};

/*
 * State flushing functions
 */
extern HRESULT FlushStatesHW(LPDIRECT3DDEVICEI);
extern HRESULT FlushStatesDP(LPDIRECT3DDEVICEI);
extern HRESULT FlushStatesCB(LPDIRECT3DDEVICEI);

/*
 * These are used to draw primitives which come out of the clipper
 */
extern HRESULT DrawPrimitivesDP(LPDIRECT3DDEVICEI, LPD3DTLVERTEX lpTLBuf, LPVOID lpTBuf, LPD3DINSTRUCTION ins, DWORD dwNumVertices, D3DVERTEXTYPE VtxType);
extern HRESULT DrawPrimitiveLegacyHalCall(LPDIRECT3DDEVICEI, LPD3DTLVERTEX lpVertices, LPVOID lpvData, LPD3DINSTRUCTION ins, DWORD dwNumVertices, D3DVERTEXTYPE VtxType);
extern HRESULT DrawPrimitivesCB(LPDIRECT3DDEVICEI, LPD3DTLVERTEX lpVertices, LPVOID lpvData, LPD3DINSTRUCTION ins, DWORD dwNumVertices, D3DVERTEXTYPE VtxType);

/*
 * Critical section code.
 * Coarse locking.  All actions require this section.
 * Defined in d3dcreat.c
 */
/*
 * On WINNT critical sections can't be used because synchronization must
 * occur cross process.   DDraw and D3D must share this synchronization so
 * DDraw exports private functions for synchronization that NT D3D must use.
 */
#ifdef WIN95
extern LPCRITICAL_SECTION       lpD3DCSect;
#endif

extern "C" {
#define this _this
#include "ddrawpr.h"
#undef this
};
#if DBG
    extern int iD3DCSCnt;
    #define INCD3DCSCNT() iD3DCSCnt++;
    #define INITD3DCSCNT() iD3DCSCnt = 0;
    #define DECD3DCSCNT() iD3DCSCnt--;
#else
    #define INCD3DCSCNT()
    #define INITD3DCSCNT()
    #define DECD3DCSCNT()
#endif

#ifdef WIN95
#define ENTER_D3D() \
    EnterCriticalSection( lpD3DCSect ); \
    INCD3DCSCNT(); \

#define LEAVE_D3D() \
    DECD3DCSCNT() \
    LeaveCriticalSection( lpD3DCSect );
#else
#define ENTER_D3D() \
        AcquireDDThreadLock(); \
        INCD3DCSCNT(); \

#define LEAVE_D3D() \
        DECD3DCSCNT() \
        ReleaseDDThreadLock();
#endif

// This class is designed to simplify ENTER_D3D() LEAVE_D3D() logic
// If object of this class is instantiated, then internal lock will be taken.
// As soon as object is destroyed lock will be released
//
class CLockD3D
{
public:
    CLockD3D(char *moduleName, char *fileName)
    {
        ENTER_D3D();
#if DBG // Required to eliminate use of moduleName and fileName in retail builds
        D3D_INFO( 6, "*** LOCK_D3D: CNT = %ld %s %s", iD3DCSCnt, moduleName, fileName );
#endif
    }
    ~CLockD3D()
    {
        LEAVE_D3D();
        D3D_INFO( 6, "*** UNLOCK_D3D: CNT = %ld", iD3DCSCnt);
    }
};

class CLockD3DST
{
private:
    bool bEnter;
public:
    CLockD3DST(LPDIRECT3DDEVICEI lpDevI, char *moduleName, char *fileName)
    {
        if (! IS_MT_DEVICE(lpDevI) )
        {
            ENTER_D3D();
#if DBG // Required to eliminate use of moduleName and fileName in retail builds
            D3D_INFO( 6, "*** LOCK_D3D: CNT = %ld %s %s", iD3DCSCnt, moduleName, fileName );
#endif
            bEnter = true;
        }
        else
            bEnter = false;
    }
    ~CLockD3DST()
    {
        if (bEnter)
        {
            LEAVE_D3D();
            D3D_INFO( 6, "*** UNLOCK_D3D: CNT = %ld", iD3DCSCnt);
        }
    }
};

class CLockD3DMT
{
private:
    bool bEnter;
public:
    CLockD3DMT(LPDIRECT3DDEVICEI lpDevI, char *moduleName, char *fileName)
    {
        if ( IS_MT_DEVICE(lpDevI) )
        {
            ENTER_D3D();
#if DBG // Required to eliminate use of moduleName and fileName in retail builds
            D3D_INFO( 6, "*** LOCK_D3D: CNT = %ld %s %s", iD3DCSCnt, moduleName, fileName );
#endif
            bEnter = true;
        }
        else
            bEnter = false;
    }
    ~CLockD3DMT()
    {
        if (bEnter)
        {
            LEAVE_D3D();
            D3D_INFO( 6, "*** UNLOCK_D3D: CNT = %ld", iD3DCSCnt);
        }
    }
};

#define ENTER_CBCSECT(device) EnterCriticalSection(&(device)->CommandBufferCSect)
#define LEAVE_CBCSECT(device) LeaveCriticalSection(&(device)->CommandBufferCSect)

/*
 * Legacy structure sizes
 */
#define D3DFINDDEVICERESULTSIZE_V1 (sizeof(D3DFINDDEVICERESULT)-2*(D3DDEVICEDESCSIZE-D3DDEVICEDESCSIZE_V1) )
#define D3DFINDDEVICERESULTSIZE_V2 (sizeof(D3DFINDDEVICERESULT)-2*(D3DDEVICEDESCSIZE-D3DDEVICEDESCSIZE_V2) )

/*
 * Macros for validating parameters.
 * Only implement those not available in ddrawpr.h.
 */

#define VALID_OUTPTR(x) ((x) && VALID_PTR_PTR(x))

// FAST_CHECKING macro is defined in ddrawpr.h
// so in make sure that ddrawpr.h is always included
// before this header.

#ifndef FAST_CHECKING

#define VALID_DIRECT3D_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DI )))
#define VALID_DIRECT3D2_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DI )))
#define VALID_DIRECT3D3_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DI )))
#define VALID_DIRECT3DDEVICE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DDEVICEI )))
#define VALID_DIRECT3DDEVICE2_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DDEVICEI )))
#define VALID_DIRECT3DDEVICE3_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DDEVICEI )))
#define VALID_DIRECT3DVIEWPORT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DVIEWPORTI )))
#define VALID_DIRECT3DVIEWPORT2_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DVIEWPORTI )))
#define VALID_DIRECT3DVIEWPORT3_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DVIEWPORTI )))
#define VALID_DIRECT3DMATERIAL_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DMATERIALI )))
#define VALID_DIRECT3DMATERIAL2_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DMATERIALI )))
#define VALID_DIRECT3DTEXTURE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DTEXTUREI )))
#define VALID_DIRECT3DTEXTURE2_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DTEXTUREI )))
#define VALID_DIRECT3DLIGHT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DLIGHTI )))
#define VALID_DIRECT3DEXECUTEBUFFER_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DEXECUTEBUFFERI )))
#define VALID_DIRECT3DVERTEXBUFFER_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( CDirect3DVertexBuffer )))

#define VALID_D3DEXECUTEBUFFERDESC_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DEXECUTEBUFFERDESC ) ) && \
    (ptr->dwSize == sizeof( D3DEXECUTEBUFFERDESC )) )
#define VALID_D3DVERTEXBUFFERDESC_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DVERTEXBUFFERDESC ) ) && \
    (ptr->dwSize == sizeof( D3DVERTEXBUFFERDESC )) )
#define VALID_D3DEXECUTEDATA_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DEXECUTEDATA ) ) && \
    (ptr->dwSize == sizeof( D3DEXECUTEDATA )) )
#define VALID_D3DMATERIALHANDLE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DMATERIALHANDLE ) ) )
#define VALID_D3DSTATS_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DSTATS ) ) && \
    (ptr->dwSize == sizeof( D3DSTATS )) )
#define VALID_D3DDEVICEDESC_PTR( ptr ) \
    ( (! IsBadWritePtr(ptr, 4) ) && \
      (ptr->dwSize == D3DDEVICEDESCSIZE     || \
       ptr->dwSize == D3DDEVICEDESCSIZE_V1  || \
       ptr->dwSize == D3DDEVICEDESCSIZE_V2) && \
      (! IsBadWritePtr(ptr, ptr->dwSize) ) )
#define VALID_D3DMATRIXHANDLE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DMATRIXHANDLE ) ))
#define VALID_D3DPICKRECORD_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DPICKRECORD ) ))
#define VALID_D3DRECT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DRECT ) ))
#define VALID_D3DMATRIX_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DMATRIX ) ))
#define VALID_D3DLIGHT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DLIGHT ) ) && \
    (ptr->dwSize == sizeof( D3DLIGHT )) )
#define VALID_D3DLIGHT2_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DLIGHT2 ) ) && \
    (ptr->dwSize == sizeof( D3DLIGHT2 )) )
#define VALID_D3DMATERIAL_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DMATERIAL ) ) && \
    (ptr->dwSize == sizeof( D3DMATERIAL )) )
#define VALID_D3DTEXTUREHANDLE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DTEXTUREHANDLE ) ) )
#define VALID_D3DLIGHTDATA_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DLIGHTDATA ) ) && \
    (ptr->dwSize == sizeof( D3DLIGHTDATA )) )
#define VALID_D3DVIEWPORT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DVIEWPORT ) ) && \
    (ptr->dwSize == sizeof( D3DVIEWPORT )) )
#define VALID_D3DVIEWPORT2_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DVIEWPORT2 ) ) && \
    (ptr->dwSize == sizeof( D3DVIEWPORT2 )) )
#define VALID_D3DTRANSFORMDATA_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DTRANSFORMDATA ) ) && \
    (ptr->dwSize == sizeof( D3DTRANSFORMDATA )) )
#define VALID_D3DFINDDEVICESEARCH_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DFINDDEVICESEARCH ) ) && \
    (ptr->dwSize == sizeof( D3DFINDDEVICESEARCH ) ) )
#define VALID_D3DFINDDEVICERESULT_PTR( ptr ) \
        ( (! IsBadWritePtr( ptr, 4)) &&                  \
          (ptr->dwSize == sizeof(D3DFINDDEVICERESULT) || \
           ptr->dwSize == D3DFINDDEVICERESULTSIZE_V1 || \
           ptr->dwSize == D3DFINDDEVICERESULTSIZE_V2) && \
          (! IsBadWritePtr( ptr, ptr->dwSize) ) )

// Note: these macros are replacements for the VALID_DIRECTDRAWSURFACE_PTR ddraw macros
// because those macros need access to the ddCallbacks ddraw globals.
// At some point these could be replaced with a ddraw exported fn that actually
// verifies the callback table type

#define VALID_D3D_DIRECTDRAWSURFACE_PTR(ptr) (!IsBadWritePtr(ptr, sizeof(DDRAWI_DDRAWSURFACE_INT)))
#define VALID_D3D_DIRECTDRAWSURFACE4_PTR(ptr) (!IsBadWritePtr(ptr, sizeof(DDRAWI_DDRAWSURFACE_INT)))

#else /* !FAST_CHECKING */

#define VALID_DIRECT3D_PTR( ptr ) (ptr)
#define VALID_DIRECT3D2_PTR( ptr ) (ptr)
#define VALID_DIRECT3D3_PTR( ptr ) (ptr)
#define VALID_DIRECT3DDEVICE_PTR( ptr ) (ptr)
#define VALID_DIRECT3DDEVICE2_PTR( ptr ) (ptr)
#define VALID_DIRECT3DDEVICE3_PTR( ptr ) (ptr)
#define VALID_DIRECT3DVIEWPORT_PTR( ptr ) (ptr)
#define VALID_DIRECT3DVIEWPORT2_PTR( ptr ) (ptr)
#define VALID_DIRECT3DVIEWPORT3_PTR( ptr ) (ptr)
#define VALID_DIRECT3DMATERIAL_PTR( ptr ) (ptr)
#define VALID_DIRECT3DMATERIAL2_PTR( ptr ) (ptr)
#define VALID_DIRECT3DTEXTURE_PTR( ptr ) (ptr)
#define VALID_DIRECT3DTEXTURE2_PTR( ptr ) (ptr)
#define VALID_DIRECT3DTEXTURE3_PTR( ptr ) (ptr)
#define VALID_DIRECT3DLIGHT_PTR( ptr ) (ptr)
#define VALID_DIRECT3DEXECUTEBUFFER_PTR( ptr ) (ptr)
#define VALID_DIRECT3DVERTEXBUFFER_PTR( ptr ) (ptr)

#define VALID_D3DEXECUTEBUFFERDESC_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DEXECUTEBUFFERDESC ))
#define VALID_D3DVERTEXBUFFERDESC_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DVERTEXBUFFERDESC ))
#define VALID_D3DEXECUTEDATA_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DEXECUTEDATA ))
#define VALID_D3DMATERIALHANDLE_PTR( ptr ) (ptr)
#define VALID_D3DSTATS_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DSTATS ))
#define VALID_D3DDEVICEDESC_PTR( ptr ) ((ptr) &&                                \
                                        (ptr->dwSize == D3DDEVICEDESCSIZE ||    \
                                         ptr->dwSize == D3DDEVICEDESCSIZE_V1 || \
                                         ptr->dwSize == D3DDEVICEDESCSIZE_V2))
#define VALID_D3DMATRIXHANDLE_PTR( ptr ) (ptr)
#define VALID_D3DPICKRECORD_PTR( ptr ) (ptr)
#define VALID_D3DRECT_PTR( ptr ) (ptr)
#define VALID_D3DMATRIX_PTR( ptr ) (ptr)
#define VALID_D3DLIGHT_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DLIGHT ))
#define VALID_D3DLIGHT2_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DLIGHT2 ))
#define VALID_D3DMATERIAL_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DMATERIAL ))
#define VALID_D3DTEXTUREHANDLE_PTR( ptr ) (ptr)
#define VALID_D3DLIGHTDATA_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DLIGHTDATA ))
#define VALID_D3DVIEWPORT_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DVIEWPORT ))
#define VALID_D3DVIEWPORT2_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DVIEWPORT2 ))
#define VALID_D3DTRANSFORMDATA_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DTRANSFORMDATA ))
#define VALID_D3DFINDDEVICESEARCH_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DFINDDEVICESEARCH ))
#define VALID_D3DFINDDEVICERESULT_PTR( ptr ) \
        ((ptr) && (ptr->dwSize == sizeof( D3DFINDDEVICERESULT ) || \
                   ptr->dwSize == D3DFINDDEVICERESULTSIZE_V1    || \
                   ptr->dwSize == D3DFINDDEVICERESULTSIZE_V2 ) )

#define VALID_D3D_DIRECTDRAWSURFACE_PTR(ptr) (ptr)    // see comment above
#define VALID_D3D_DIRECTDRAWSURFACE4_PTR(ptr) (ptr)

#endif /* !FAST_CHECKING */
#define CVAL_TO_RGBA(rgb) RGBA_MAKE((DWORD)(255.0 * (rgb).r),    \
                                    (DWORD)(255.0 * (rgb).g),    \
                                    (DWORD)(255.0 * (rgb).b),    \
                                    (DWORD)(255.0 * (rgb).a))

#endif /* _D3DPR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\hwprov.h ===
//----------------------------------------------------------------------------
//
// hwprov.h
//
// Base hardware HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _HWPROV_H_
#define _HWPROV_H_

//----------------------------------------------------------------------------
//
// HwHalProvider
//
// Implements the base HAL provider for hardware renderers.
//
//----------------------------------------------------------------------------

class HwHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // IHalProvider.
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion);
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
};

#endif // #ifndef _HWPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\lists.hpp ===
/* Copyright (c) 1997  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef _LISTS_H
#define _LISTS_H

#define LIST_ROOT(name, type) struct name {type *Root;}

#define LIST_MEMBER(type) struct { type **Prev; type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
    (root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    if ((element)->field.Prev)\
    {\
        *(element)->field.Prev = (element)->field.Next;\
        (element)->field.Prev = 0;\
    }\
    (element)->field.Next = 0;\
}

#define LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   type *First;\
    type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   type *Next;\
    type **Prev;    /* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
    (root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   type *Last;\
    type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   type *Prev;\
    type *Next;\
}

#define CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
    (root)->Last->field.Next = (element);\
    else\
    (root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
    (root)->First->field.Prev = (element);\
    else\
    (root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
    (current_element)->field.Prev->field.Next = (element);\
    else\
    (root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
    (root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
    (element)->field.Prev->field.Next = (element)->field.Next;\
    else\
    (root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CIRCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lists.hpp"

void TestList(void)
{
    struct Foo
    {
    int a;
    LIST_MEMBER(Foo) ListStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
    int a;
    TAIL_QUEUE_MEMBER(Foo) TQStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
    int a;
    CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
    CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    
    switch(WhichInsert)
    {
    case END:
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        WhichInsert = ROOT;
        break;
    case ROOT:
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        WhichInsert = PREVIOUS;
        break;
    case PREVIOUS:
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
        WhichInsert = DONE;
        break;
    default:
        assert(0);
    }

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

    pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
    pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
    assert(pFoo == &MyFoo3);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);
    
        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);
    
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        
        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);
    
        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */


#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\tlhal.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       tlhal.h
 *  Content:    Support code for HALs with hardware transform & light
 *
 ***************************************************************************/
#ifndef _TLHAL_H_
#define _TLHAL_H_


//  transform, viewport, light set
HRESULT D3DHALTLTransformSetData( LPDIRECT3DDEVICEI lpDevI, D3DTRANSFORMSTATETYPE dtsType, LPD3DMATRIX lpMatrix );
HRESULT D3DHALTLViewportSetData( LPDIRECT3DDEVICEI lpDevI, D3DVIEWPORT2* pViewport2 );
HRESULT D3DHALTLViewportSetData( LPDIRECT3DDEVICEI lpDevI, D3DVIEWPORT2* pViewport2 );
HRESULT D3DHALTLLightSetData( LPDIRECT3DDEVICEI lpDevI, DWORD dwLightOffset, BOOL bLastLight, D3DLIGHT2* pLight2 );

//  clip status set/get
HRESULT D3DHALTLClipStatusSetData( LPDIRECT3DDEVICEI lpDevI, LPD3DCLIPSTATUS lpClipStatus );
HRESULT D3DHALTLClipStatusGetData( LPDIRECT3DDEVICEI lpDevI, LPD3DCLIPSTATUS lpClipStatus );

//  material management utilities
DWORD   D3DHALTLMaterialCreate( LPDIRECT3DDEVICEI lpDevI );
void    D3DHALTLMaterialDestroy( LPDIRECT3DDEVICEI lpDevI, DWORD hMat );
HRESULT D3DHALTLMaterialSetData( LPDIRECT3DDEVICEI lpDevI, DWORD hMat, D3DMATERIAL* pMat );
DWORD   D3DHALTLMaterialRemapHandle( LPDIRECT3DDEVICEI lpDevI, DWORD hMat );

#endif /* _TLHAL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\cppdbg.cpp ===
//----------------------------------------------------------------------------
//
// cppdbg.cpp
//
// C++-only debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

#include "cppdbg.hpp"

#ifdef _ALPHA_
// On Alpha va_list is a structure so it's not compatible with NULL.
static va_list NULLVA;
#else
#define NULLVA NULL
#endif

static DebugModuleFlags g_FailureFlags[] =
{
    DBG_DECLARE_MODFLAG(DBG_FAILURE, BREAK),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, OUTPUT),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, PROMPT),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, FILENAME_ONLY),
    0, NULL,
};

static DebugModuleFlags g_OutputFlags[] =
{
    DBG_DECLARE_MODFLAG(DBG_OUTPUT, SUPPRESS),
    DBG_DECLARE_MODFLAG(DBG_OUTPUT, ALL_MATCH),
    0, NULL,
};

static char *g_pFlagNames[] =
{
    "AssertFlags",
    "HrFlags",
    "OutputFlags",
    "OutputMask",
    "UserFlags"
};

//----------------------------------------------------------------------------
//
// DebugModule::DebugModule
//
//----------------------------------------------------------------------------

DebugModule::DebugModule(char *pModule, char *pPrefix,
                         DebugModuleFlags *pOutputMasks, UINT uOutputMask,
                         DebugModuleFlags *pUserFlags, UINT uUserFlags)
{
    m_pModule = pModule;
    m_iModuleStartCol = strlen(m_pModule) + 2;
    m_pPrefix = pPrefix;

    m_pModFlags[DBG_ASSERT_FLAGS] = g_FailureFlags;
    m_pModFlags[DBG_HR_FLAGS] = g_FailureFlags;
    m_pModFlags[DBG_OUTPUT_FLAGS] = g_OutputFlags;
    m_pModFlags[DBG_OUTPUT_MASK] = pOutputMasks;
    m_pModFlags[DBG_USER_FLAGS] = pUserFlags;

    m_uFlags[DBG_ASSERT_FLAGS] = DBG_FAILURE_OUTPUT | DBG_FAILURE_BREAK |
        DBG_FAILURE_FILENAME_ONLY;
    m_uFlags[DBG_HR_FLAGS] = DBG_FAILURE_OUTPUT | 
        DBG_FAILURE_FILENAME_ONLY;
    m_uFlags[DBG_OUTPUT_FLAGS] = 0;
    m_uFlags[DBG_OUTPUT_MASK] = uOutputMask;
    m_uFlags[DBG_USER_FLAGS] = uUserFlags;
    
    ReadReg();
}

//----------------------------------------------------------------------------
//
// DebugModule::OutVa
//
// Base debug output method.
//
//----------------------------------------------------------------------------

void DebugModule::OutVa(UINT uMask, char *pFmt, va_list Args)
{
    if (m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_SUPPRESS)
    {
        return;
    }
    
    if ((uMask & DBG_MASK_NO_PREFIX) == 0)
    {
        OutputDebugStringA(m_pModule);
        OutputDebugStringA(": ");
    }

    char chMsg[1024];

    _vsnprintf(chMsg, sizeof(chMsg), pFmt, Args);
    OutputDebugStringA(chMsg);
}

//----------------------------------------------------------------------------
//
// DebugModule::Out
//
// Always-output debug output method.
//
//----------------------------------------------------------------------------

void DebugModule::Out(char *pFmt, ...)
{
    va_list Args;

    va_start(Args, pFmt);
    OutVa(0, pFmt, Args);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailedVa
//
// Handles assertion failure output and interface.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailedVa(char *pFmt, va_list Args, BOOL bNewLine)
{
    if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_OUTPUT)
    {
        if (OutPathFile("Assertion failed", m_uFlags[DBG_ASSERT_FLAGS]))
        {
            OutVa(DBG_MASK_NO_PREFIX, ":\n    ", NULLVA);
        }
        else
        {
            OutVa(DBG_MASK_NO_PREFIX, ": ", NULLVA);
        }
        
        OutVa(DBG_MASK_NO_PREFIX, pFmt, Args);
        if (bNewLine)
        {
            OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
        }
    }

    if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_BREAK)
    {
#if DBG
        DebugBreak();
#endif
    }
    else if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_PROMPT)
    {
        Prompt(NULL);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailed
//
// Handles simple expression assertion failures.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailed(char *pExp)
{
    AssertFailedVa(pExp, NULLVA, TRUE);
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailedMsg
//
// Handles assertion failures with arbitrary debug output.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailedMsg(char *pFmt, ...)
{
    va_list Args;

    va_start(Args, pFmt);
    AssertFailedVa(pFmt, Args, FALSE);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// DebugModule::HrFailure
//
// Handles HRESULT failures.
//
//----------------------------------------------------------------------------

void DebugModule::HrFailure(HRESULT hr, char *pPrefix)
{
    if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_OUTPUT)
    {
        OutPathFile(pPrefix, m_uFlags[DBG_HR_FLAGS]);
        OutMask(DBG_MASK_FORCE_CONT, ": %s\n", HrString(hr));
    }

    if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_BREAK)
    {
#if DBG
        DebugBreak();
#endif
    }
    else if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_PROMPT)
    {
        Prompt(NULL);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::HrStmtFailed
//
// Handles statement-style HRESULT failures.
//
//----------------------------------------------------------------------------

void DebugModule::HrStmtFailed(HRESULT hr)
{
    HrFailure(hr, "HR test fail");
}

//----------------------------------------------------------------------------
//
// DebugModule::ReturnHr
//
// Handles expression-style HRESULT failures.
//
//----------------------------------------------------------------------------

HRESULT DebugModule::HrExpFailed(HRESULT hr)
{
    HrFailure(hr, "HR expr fail");
    return hr;
}

//----------------------------------------------------------------------------
//
// DebugModule::Prompt
//
// Allows control over debug options via interactive input.
//
//----------------------------------------------------------------------------

void DebugModule::Prompt(char *pFmt, ...)
{
    va_list Args;

    if (pFmt != NULL)
    {
        va_start(Args, pFmt);
        OutVa(0, pFmt, Args);
        va_end(Args);
    }

#ifdef WINNT
    char szInput[512];
    char *pIdx;
    int iIdx;
    static char szFlagCommands[] = "ahomu";

    for (;;)
    {
        ULONG uLen;
        
        uLen = DbgPrompt("[bgaAFhHmMoOrRuU] ", szInput, sizeof(szInput) - 1);
        if (uLen < 2)
        {
            Out("DbgPrompt failed\n");
#if DBG
            DebugBreak();
#endif
            return;
        }

        // ATTENTION - Currently DbgPrompt returns a length that is two
        // greater than the actual number of characters.  Presumably this
        // is an artifact of the Unicode/ANSI conversion and should
        // really only be one greater, so attempt to handle both.

        uLen -= 2;
        if (szInput[uLen] != 0)
        {
            uLen++;
            szInput[uLen] = 0;
        }

        if (uLen < 1)
        {
            Out("Empty command ignored\n");
            continue;
        }
        
        switch(szInput[0])
        {
        case 'b':
#if DBG
            DebugBreak();
#endif
            break;
        case 'g':
            return;
            
        case 'r':
            WriteReg();
            break;
        case 'R':
            ReadReg();
            break;

        case 'a':
        case 'A':
        case 'h':
        case 'H':
        case 'm':
        case 'M':
        case 'o':
        case 'O':
        case 'u':
        case 'U':
            char chLower;

            if (szInput[0] >= 'A' && szInput[0] <= 'Z')
            {
                chLower = szInput[0] - 'A' + 'a';
            }
            else
            {
                chLower = szInput[0];
            }

            pIdx = strchr(szFlagCommands, chLower);
            if (pIdx == NULL)
            {
                // Should never happen.
                break;
            }

            iIdx = (int)((ULONG_PTR)(pIdx - szFlagCommands));
            if (szInput[0] == chLower)
            {
                // Set.
                m_uFlags[iIdx] = ParseUint(szInput + 1, m_pModFlags[iIdx]);
            }

            // Set or Get.
            OutUint(g_pFlagNames[iIdx], m_pModFlags[iIdx], m_uFlags[iIdx]);
            break;
            
        case 'F':
            if (uLen < 2)
            {
                Out("'F' must be followed by a flag group specifier\n");
                break;
            }
            
            pIdx = strchr(szFlagCommands, szInput[1]);
            if (pIdx == NULL)
            {
                Out("Unknown flag group '%c'\n", szInput[1]);
            }
            else
            {
                iIdx = (int)((ULONG_PTR)(pIdx - szFlagCommands));
                ShowFlags(g_pFlagNames[iIdx], m_pModFlags[iIdx]);
            }
            break;

        default:
            Out("Unknown command '%c'\n", szInput[0]);
            break;
        }
    }
#else
    OutUint("OutputMask", m_pModFlags[DBG_OUTPUT_MASK],
            m_uFlags[DBG_OUTPUT_MASK]);
    Out("Prompt not available\n");
#if DBG
    DebugBreak();
#endif
#endif
}

//----------------------------------------------------------------------------
//
// DebugModule::OpenDebugKey
//
// Opens the Direct3D\Debug\m_pModule key.
//
//----------------------------------------------------------------------------

HKEY DebugModule::OpenDebugKey(void)
{
    HKEY hKey;
    char szKeyName[128];

    strcpy(szKeyName, "Software\\Microsoft\\Direct3D\\Debug\\");
    strcat(szKeyName, m_pModule);
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_ALL_ACCESS,
                      &hKey) != ERROR_SUCCESS)
    {
        return NULL;
    }
    else
    {
        return hKey;
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::GetRegUint
//
// Gets a UINT value from the given key.
//
//----------------------------------------------------------------------------

UINT DebugModule::GetRegUint(HKEY hKey, char *pValue, UINT uDefault)
{
    DWORD dwType, dwSize;
    DWORD dwVal;

    dwSize = sizeof(dwVal);
    if (RegQueryValueExA(hKey, pValue, NULL, &dwType, (BYTE *)&dwVal,
                         &dwSize) != ERROR_SUCCESS ||
        dwType != REG_DWORD)
    {
        return uDefault;
    }
    else
    {
        return (UINT)dwVal;
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::SetRegUint
//
// Sets a UINT value for the given key.
//
//----------------------------------------------------------------------------

BOOL DebugModule::SetRegUint(HKEY hKey, char *pValue, UINT uValue)
{
    return RegSetValueExA(hKey, pValue, NULL, REG_DWORD, (BYTE *)&uValue,
                          sizeof(uValue)) == ERROR_SUCCESS;
}

//----------------------------------------------------------------------------
//
// DebugModule::ReadReg
//
// Reads settings from the registry.
//
//----------------------------------------------------------------------------

void DebugModule::ReadReg(void)
{
    HKEY hKey;

    hKey = OpenDebugKey();
    if (hKey != NULL)
    {
        int iIdx;

        for (iIdx = 0; iIdx < DBG_FLAGS_COUNT; iIdx++)
        {
            m_uFlags[iIdx] = GetRegUint(hKey, g_pFlagNames[iIdx],
                                        m_uFlags[iIdx]);
        }
        RegCloseKey(hKey);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::WriteReg
//
// Writes values to the registry.
//
//----------------------------------------------------------------------------

void DebugModule::WriteReg(void)
{
    HKEY hKey;

    hKey = OpenDebugKey();
    if (hKey != NULL)
    {
        int iIdx;

        for (iIdx = 0; iIdx < DBG_FLAGS_COUNT; iIdx++)
        {
            if (!SetRegUint(hKey, g_pFlagNames[iIdx], m_uFlags[iIdx]))
            {
                OutputDebugStringA("Error writing registry information\n");
            }
        }
        RegCloseKey(hKey);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::ParseUint
//
// Parses a string for a numeric value or a set of flag strings.
//
//----------------------------------------------------------------------------

UINT DebugModule::ParseUint(char *pString, DebugModuleFlags *pFlags)
{
    UINT uVal;

    uVal = 0;

    for (;;)
    {
        while (*pString != 0 &&
               (*pString == ' ' || *pString == '\t'))
        {
            pString++;
        }

        if (*pString == 0)
        {
            break;
        }

        char *pEnd;
        int iStepAfter;

        pEnd = pString;
        while (*pEnd != 0 && *pEnd != ' ' && *pEnd != '\t')
        {
            pEnd++;
        }
        iStepAfter = *pEnd != 0 ? 1 : 0;
        *pEnd = 0;
        
        if (*pString >= '0' && *pString <= '9')
        {
            uVal |= strtoul(pString, &pString, 0);
            if (*pString != 0 && *pString != ' ' && *pString != '\t')
            {
                Out("Unrecognized characters '%s' after number\n", pString);
            }
        }
        else if (pFlags != NULL)
        {
            DebugModuleFlags *pFlag;
            
            for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
            {
                if (!_stricmp(pString, pFlag->pName))
                {
                    break;
                }
            }

            if (pFlag->uFlag == 0)
            {
                Out("Unrecognized flag string '%s'\n", pString);
            }
            else
            {
                uVal |= pFlag->uFlag;
            }
        }
        else
        {
            Out("No flag definitions, unable to convert '%s'\n", pString);
        }

        pString = pEnd + iStepAfter;
    }

    return uVal;
}

//----------------------------------------------------------------------------
//
// DebugModule::OutUint
//
// Displays a UINT as a set of flag strings.
//
//----------------------------------------------------------------------------

void DebugModule::OutUint(char *pName, DebugModuleFlags *pFlags, UINT uValue)
{
    if (pFlags == NULL || uValue == 0)
    {
        Out("%s: 0x%08X\n", pName, uValue);
        return;
    }

    Out("%s:", pName);
    m_iStartCol = m_iModuleStartCol + strlen(pName) + 1;
    m_iCol = m_iStartCol;
    
    while (uValue != 0)
    {
        DebugModuleFlags *pFlag;

        for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
        {
            if ((pFlag->uFlag & uValue) == pFlag->uFlag)
            {
                AdvanceCols(strlen(pFlag->pName) + 1);
                OutMask(DBG_MASK_FORCE_CONT, " %s", pFlag->pName);
                uValue &= ~pFlag->uFlag;
                break;
            }
        }

        if (pFlag->uFlag == 0)
        {
            AdvanceCols(11);
            OutMask(DBG_MASK_FORCE_CONT, " 0x%X", uValue);
            uValue = 0;
        }
    }

    OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
}

//----------------------------------------------------------------------------
//
// DebugModule::AdvanceCols
//
// Determines if there's enough space on the current line for
// the given number of columns.  If not, a new line is started.
//
//----------------------------------------------------------------------------

void DebugModule::AdvanceCols(int iCols)
{
    static char szSpaces[] = "                                ";

    m_iCol += iCols;
    if (m_iCol >= 79)
    {
        int iSpace;
            
        OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
        // Force a prefix to be printed to start the line.
        Out("");
        
        m_iCol = m_iModuleStartCol;
        while (m_iCol < m_iStartCol)
        {
            iSpace = (int)min(sizeof(szSpaces) - 1, m_iStartCol - m_iCol);
            OutMask(DBG_MASK_FORCE_CONT, "%.*s", iSpace, szSpaces);
            m_iCol += iSpace;
        }
    }
}   

//----------------------------------------------------------------------------
//
// DebugModule::ShowFlags
//
// Shows the given flag set.
//
//----------------------------------------------------------------------------

void DebugModule::ShowFlags(char *pName, DebugModuleFlags *pFlags)
{
    DebugModuleFlags *pFlag;

    Out("%s:\n", pName);
    if (pFlags == NULL)
    {
        Out("    None defined\n");
    }
    else
    {
        for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
        {
            Out("    0x%08X - %s\n", pFlag->uFlag, pFlag->pName);
        }
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::PathFile
//
// Returns the trailing filename component or NULL if the path is
// only a filename.
//
//----------------------------------------------------------------------------

char *DebugModule::PathFile(char *pPath)
{
    char *pFile, *pSlash, *pBack, *pColon;
            
    pBack = strrchr(pPath, '\\');
    pSlash = strrchr(pPath, '/');
    pColon = strrchr(pPath, ':');

    pFile = pBack;
    if (pSlash > pFile)
    {
        pFile = pSlash;
    }
    if (pColon > pFile)
    {
        pFile = pColon;
    }

    return pFile != NULL ? pFile + 1 : NULL;
}

//----------------------------------------------------------------------------
//
// DebugModule::OutPathFile
//
// Outputs the given string plus a path and filename.
// Returns whether the full path was output or not.
//
//----------------------------------------------------------------------------

BOOL DebugModule::OutPathFile(char *pPrefix, UINT uFailureFlags)
{
    char *pFile;
        
    if (uFailureFlags & DBG_FAILURE_FILENAME_ONLY)
    {
        pFile = PathFile(m_pFile);
    }
    else
    {
        pFile = NULL;
    }
        
    if (pFile == NULL)
    {
        Out("%s %s(%d)", pPrefix, m_pFile, m_iLine);
        return TRUE;
    }
    else
    {
        Out("%s <>\\%s(%d)", pPrefix, pFile, m_iLine);
        return FALSE;
    }
}

//----------------------------------------------------------------------------
//
// Global debug module.
//
//----------------------------------------------------------------------------

DBG_DECLARE_ONCE(Global, G, NULL, 0, NULL, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\object.h ===
/*
 * $Id: object.h,v 1.2 1995/06/21 12:38:55 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef _OBJECT_H_
#define _OBJECT_H_

#include <stdlib.h>

#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#include "d3dcom.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Data structures
 */
#ifdef __cplusplus

/* 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined */
struct ID3DObject;
typedef struct ID3DObject   *LPD3DOBJECT;

#else

typedef struct ID3DObject   *LPD3DOBJECT;

#endif

/*
 * ID3DObject
 */
#undef INTERFACE
#define INTERFACE ID3DObject
DECLARE_INTERFACE(ID3DObject)
{
    /*
     * ID3DObject methods
     */
    STDMETHOD(Initialise) (THIS_ LPVOID arg) PURE;
    STDMETHOD(Destroy) (THIS_ LPVOID arg) PURE;
};

#ifdef __cplusplus
};
#endif

#endif /* _OBJECT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\texman.hpp ===
#ifndef TEXMAN_INCLUDED
#define TEXMAN_INCLUDED

#define MAXLOGTEXSIZE 25
typedef class TextureCacheManager *LPTextureCacheManager;

/* 
   The texture cache manager does all cache management. The data structure used is
   a hash table with the hash variable being the log (base 2) of the total size of 
   the texture in pixels. Each bucket corresponding to a texture size is a list of 
   CacheInfos. The LRU algorithm works as follows:
     1. Is the texture corresponding to the GL handle in the cache?
     2. If it is, increment the timestamp and return the D3D handle.
     3. If not, attempt to allocate a DirectDraw surface. If there is no memory,
        we need to free some texture and try again (see step 4), else add a CacheInfo 
        corresponding to this newly allocated DirectDraw surface, QI it for a texture 
        object and return the D3D handle.
     4. We have to reuse some old textures, so try to find the oldest texture of the 
        same size. If we find such a texture, just Blt the new texture onto the old.
        If a texture of the same size is not available, we freeup some bigger textures
        and go to step 3.
*/

class TextureCacheManager {

  LPD3DBUCKET tcm_bucket[MAXLOGTEXSIZE];
  unsigned int tcm_ticks, numvidtex;
  LPDIRECT3DI	lpDirect3DI;
  // Replace a texture of size k with a new texture corresponding to glhandle
  //LPD3DBUCKET replace(int k, LPDIRECT3DTEXTUREI lpD3DTexI);

  // Free the oldest texture of same size as lpD3DTexI 
  BOOL freeNode(LPD3DI_TEXTUREBLOCK lpBlock, LPD3DBUCKET* lplpBucket);

  //remove any HW handle that's not with lpBlock->lpDevI,save lpBlock->hTex,keep surface
  void replace(LPD3DBUCKET bucket,LPD3DI_TEXTUREBLOCK lpBlock);  
  
public:
  HRESULT allocNode(LPD3DI_TEXTUREBLOCK lpBlock);
  TextureCacheManager(LPDIRECT3DI lpD3DI);
  ~TextureCacheManager();
  //remove all HW handles and release surface
  void remove(LPD3DBUCKET bucket);  

  // Empty the entire cache
  void EvictTextures();
  void cleanup();	// clean up invalidated nodes by destructors of texture/texture3
  BOOL CheckIfLost(); // check if any of the managed textures are lost
  inline void TimeStamp(LPD3DBUCKET bucket){bucket->ticks=tcm_ticks++;}
  inline void TimeStamp(){++tcm_ticks;}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\testprov.h ===
//----------------------------------------------------------------------------
//
// testprov.h
//
// Test HAL provider class.
//
// Test HAL provider is an itermediate object between D3DIM and 
// real HAL provider. Itis used to print some data sent to a driver to a 
// file. After that the real HAL driver is called.
// Test HAL provider is enabled by specifying non-empty string key "TestFile"
// under DIRECT3D key in the registry. The specified string is the name for 
// a binary file to output data to. File format is described in TESTFILE.H
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#ifndef _TESTPROV_H_
#define _TESTPROV_H_

class CTestHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // IHalProvider.
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion);
};
//----------------------------------------------------------------------------
//
// GetTestProvider
//
// Input:
//      riid and pCurrentHalProvider are equal to the currently selected provider.
//      GlobalData  - data provided by DDraw
//      fileName    - output file name
//      dwFlags     - currently not used
//
// Returns:
//      the test HAL provider in ppHalProvider.
//      D3D_OK if success
//
//----------------------------------------------------------------------------
STDAPI GetTestHalProvider(REFIID riid, 
                          DDRAWI_DIRECTDRAW_GBL *pGlobalData,
                          IHalProvider **ppHalProvider,
                          IHalProvider * pCurrentHalProvider,
                          DWORD dwFlags);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\cppdbg.hpp ===
//----------------------------------------------------------------------------
//
// cppdbg.hpp
//
// C++-only debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _CPPDBG_HPP_
#define _CPPDBG_HPP_

#if DBG

#include <stdarg.h>

typedef unsigned int UINT;
        
//
// Mask bits common to all modules.
//

#define DBG_MASK_NO_PREFIX              0x80000000
#define DBG_MASK_FORCE                  0x40000000

// Mask bits checked against output mask.
#define DBG_MASK_CHECK                  (~(DBG_MASK_NO_PREFIX | \
                                           DBG_MASK_FORCE))

// Forced continuation mask.
#define DBG_MASK_FORCE_CONT             (DBG_MASK_NO_PREFIX | DBG_MASK_FORCE)

//
// Failure control bits for assert and HRESULT failures.
//

#define DBG_FAILURE_BREAK               0x00000001
#define DBG_FAILURE_OUTPUT              0x00000002
#define DBG_FAILURE_PROMPT              0x00000004
#define DBG_FAILURE_FILENAME_ONLY       0x00000008

//
// Overall output control bits.
//

#define DBG_OUTPUT_SUPPRESS             0x00000001
#define DBG_OUTPUT_ALL_MATCH            0x00000002

//----------------------------------------------------------------------------
//
// DebugModule
//
//----------------------------------------------------------------------------

struct DebugModuleFlags
{
    UINT uFlag;
    char *pName;
};

// Declares a DebugModuleFlags entry.
#define DBG_DECLARE_MODFLAG(Group, Name) \
    Group ## _ ## Name, #Name

enum
{
    DBG_ASSERT_FLAGS,
    DBG_HR_FLAGS,
    DBG_OUTPUT_FLAGS,
    DBG_OUTPUT_MASK,
    DBG_USER_FLAGS,
    DBG_FLAGS_COUNT
};

class DebugModule
{
public:
    DebugModule(char *pModule, char *pPrefix,
                DebugModuleFlags *pOutputMasks, UINT uOutputMask,
                DebugModuleFlags *pUserFlags, UINT uUserFlags);

    void Out(char *pFmt, ...);

    void OutMask(UINT uMask, char *pFmt, ...)
    {
        if ((uMask & DBG_MASK_FORCE) ||
            ((m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_ALL_MATCH) &&
             (uMask & m_uFlags[DBG_OUTPUT_MASK] & DBG_MASK_CHECK) == uMask) ||
            ((m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_ALL_MATCH) == 0 &&
             (uMask & m_uFlags[DBG_OUTPUT_MASK] & DBG_MASK_CHECK) != 0))
        {
            va_list Args;

            va_start(Args, pFmt);
            OutVa(uMask, pFmt, Args);
            va_end(Args);
        }
    }
    
    void AssertFailed(char *pExp);
    void AssertFailedMsg(char *pFmt, ...);

    void HrStmtFailed(HRESULT hr);
    HRESULT HrExpFailed(HRESULT hr);
    
    void SetFileLine(char *pFile, int iLine)
    {
        m_pFile = pFile;
        m_iLine = iLine;
    }

    void Prompt(char *pFmt, ...);

    UINT GetFlags(int iIdx)
    {
        return m_uFlags[iIdx];
    }
    void SetFlags(int iIdx, UINT uValue)
    {
        m_uFlags[iIdx] = uValue;
    }

private:
    void OutVa(UINT uMask, char *pFmt, va_list Args);
    void AssertFailedVa(char *pFmt, va_list Args, BOOL bNewLine);

    HKEY OpenDebugKey(void);
    UINT GetRegUint(HKEY hKey, char *pValue, UINT uDefault);
    BOOL SetRegUint(HKEY hKey, char *pValue, UINT uValue);
    void ReadReg(void);
    void WriteReg(void);

    UINT ParseUint(char *pString, DebugModuleFlags *pFlags);
    void OutUint(char *pName, DebugModuleFlags *pFlags, UINT uValue);

    void AdvanceCols(int iCols);

    void ShowFlags(char *pName, DebugModuleFlags *pFlags);

    char *PathFile(char *pPath);
    BOOL OutPathFile(char *pPrefix, UINT uFailureFlags);

    void HrFailure(HRESULT hr, char *pPrefix);
    char *HrString(HRESULT hr);
    
    // Module information given.
    char *m_pModule;
    char *m_pPrefix;
    
    // Flag descriptions and values.
    DebugModuleFlags *m_pModFlags[DBG_FLAGS_COUNT];
    UINT m_uFlags[DBG_FLAGS_COUNT];

    // Temporary file and line number storage.
    char *m_pFile;
    int m_iLine;

    // Output column during multiline display.
    int m_iModuleStartCol;
    int m_iCol;
    int m_iStartCol;
};

//----------------------------------------------------------------------------
//
// Support macros.
//
//----------------------------------------------------------------------------

#define DBG_MODULE(Prefix) Prefix ## _Debug

// Put this in one source file.
#define DBG_DECLARE_ONCE(Module, Prefix, pOutputMasks, uOutputMask, \
                         pUserFlags, uUserFlags) \
    DebugModule DBG_MODULE(Prefix)(#Module, #Prefix, \
                                   pOutputMasks, uOutputMask, \
                                   pUserFlags, uUserFlags)

// Put this in your derived debugging header.
#define DBG_DECLARE_HEADER(Prefix) \
    extern DebugModule DBG_MODULE(Prefix)

// Put this in every file.
#define DBG_DECLARE_FILE() \
    static char *g_pStaticDebugFile = __FILE__

#define DBG_DECLARE_DPF(Prefix, Args) \
    DBG_MODULE(Prefix).Out Args
#define DBG_DECLARE_DPFM(Prefix, Args) \
    DBG_MODULE(Prefix).OutMask Args

#define DBG_DECLARE_ASSERT(Prefix, Exp) \
    if (!(Exp)) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).AssertFailed(#Exp); } \
    else 0
#define DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args) \
    if (!(Exp)) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).AssertFailedMsg Args ; } \
    else 0
#define DBG_DECLARE_VERIFY(Prefix, Exp) \
    DBG_DECLARE_ASSERT(Prefix, Exp)
#define DBG_DECLARE_VERIFYMSG(Prefix, Exp, Args)\
    DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args)

#define DBG_DECLARE_PROMPT(Prefix, Args) \
    DBG_MODULE(Prefix).Prompt Args

#define DBG_DECLARE_GETFLAGS(Prefix, Idx) \
    DBG_MODULE(Prefix).GetFlags(Idx)
#define DBG_DECLARE_SETFLAGS(Prefix, Idx, Value) \
    DBG_MODULE(Prefix).SetFlags(Idx, Value)

//
// These macros assume a variable 'hr' exists.
//

// HRESULT test in expression form.
#define DBG_DECLARE_HRCHK(Prefix, Exp) \
    ((hr = (Exp)) != S_OK ? \
      (DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__), \
       DBG_MODULE(Prefix).HrExpFailed(hr)) : hr)

// HRESULT test in if/then form.
#define DBGI_DECLARE_HRIF(Prefix, Exp, DoFail) \
    if ((hr = (Exp)) != S_OK) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).HrStmtFailed(hr); \
      DoFail; } \
    else hr

#define DBG_DECLARE_HRGO(Prefix, Exp, Label) \
    DBGI_DECLARE_HRIF(Prefix, Exp, goto Label)
#define DBG_DECLARE_HRERR(Prefix, Exp) \
    DBG_DECLARE_HRGO(Prefix, Exp, HR_Err)
#define DBG_DECLARE_HRRET(Prefix, Exp) \
    DBGI_DECLARE_HRIF(Prefix, Exp, return hr)

#else // #if DBG

//
// Empty macros for free builds.
//

#define DBG_MODULE(Prefix) 0
#define DBG_DECLARE_ONCE(Module, Prefix, pOutputMasks, uOutputMask, \
                         pUserFlags, uUserFlags)
#define DBG_DECLARE_HEADER(Prefix)
#define DBG_DECLARE_FILE()

#define DBG_DECLARE_DPF(Prefix, Args)
#define DBG_DECLARE_DPFM(Prefix, Args)
#define DBG_DECLARE_ASSERT(Prefix, Exp)
#define DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args)
#define DBG_DECLARE_PROMPT(Prefix, Args)
#define DBG_DECLARE_GETFLAGS(Prefix, Idx) 0
#define DBG_DECLARE_SETFLAGS(Prefix, Idx, Value)

//
// Macros which evaluate to code on free builds.
//

#define DBG_DECLARE_VERIFY(Prefix, Exp) (Exp)
#define DBG_DECLARE_VERIFYMSG(Prefix, Exp, Args) (Exp)

#define DBG_DECLARE_HRCHK(Prefix, Exp) \
    (hr = (Exp))
#define DBGI_DECLARE_HRIF(Prefix, Exp, DoFail) \
    if ((hr = (Exp)) != S_OK) DoFail; else hr
#define DBG_DECLARE_HRGO(Prefix, Exp, Label) \
    DBGI_DECLARE_HRIF(Prefix, Exp, goto Label)
#define DBG_DECLARE_HRERR(Prefix, Exp) \
    DBG_DECLARE_HRGO(Prefix, Exp, HR_Err)
#define DBG_DECLARE_HRRET(Prefix, Exp) \
    DBGI_DECLARE_HRIF(Prefix, Exp, return hr)

#endif // #if DBG

//----------------------------------------------------------------------------
//
// Global debug module.
//
//----------------------------------------------------------------------------

DBG_DECLARE_HEADER(G);

#define GDPF(Args)              DBG_DECLARE_DPF(G, Args)
#define GDPFM(Args)             DBG_DECLARE_DPFM(G, Args)
#define GASSERT(Exp)            DBG_DECLARE_ASSERT(G, Exp)
#define GASSERTMSG(Exp, Args)   DBG_DECLARE_ASSERTMSG(G, Exp, Args)
#define GVERIFY(Exp)            DBG_DECLARE_VERIFY(G, Exp)
#define GVERIFYMSG(Exp)         DBG_DECLARE_VERIFYMSG(G, Exp, Args)
#define GPROMPT(Args)           DBG_DECLARE_PROMPT(G, Args)
#define GGETFLAGS(Idx)          DBG_DECLARE_GETFLAGS(G, Idx)
#define GSETFLAGS(Idx, Value)   DBG_DECLARE_SETFLAGS(G, Idx, Value)
#define GHRCHK(Exp)             DBG_DECLARE_HRCHK(G, Exp)
#define GHRGO(Exp, Label)       DBG_DECLARE_HRGO(G, Exp, Label)
#define GHRERR(Exp)             DBG_DECLARE_HRERR(G, Exp)
#define GHRRET(Exp)             DBG_DECLARE_HRRET(G, Exp)

#endif // #ifndef _CPPDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\subwtype.h ===
#if !defined(_SUBWTYPE_H_) && !defined(__wtypes_h__)
#define _SUBWTYPE_H_

#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif // !FALSE
#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
			/* size is 1 */
typedef unsigned char BYTE;

#endif // !_BYTE_DEFINED
#ifndef _WORD_DEFINED
#define _WORD_DEFINED
			/* size is 2 */
typedef unsigned short WORD;

#endif // !_WORD_DEFINED
			/* size is 4 */
typedef /* [transmit] */ unsigned int UINT;

			/* size is 4 */
typedef /* [transmit] */ int INT;

			/* size is 4 */
typedef long BOOL, *LPBOOL;

#ifndef _LONG_DEFINED
#define _LONG_DEFINED
			/* size is 4 */
typedef long LONG;

#endif // !_LONG_DEFINED
#ifndef _WPARAM_DEFINED
#define _WPARAM_DEFINED
			/* size is 4 */
typedef UINT WPARAM;

#endif // _WPARAM_DEFINED
#ifndef _DWORD_DEFINED
#define _DWORD_DEFINED
			/* size is 4 */
typedef unsigned long DWORD;

#endif // !_DWORD_DEFINED
#ifndef _LPARAM_DEFINED
#define _LPARAM_DEFINED
			/* size is 4 */
typedef LONG LPARAM;

#endif // !_LPARAM_DEFINED
#ifndef _LRESULT_DEFINED
#define _LRESULT_DEFINED
			/* size is 4 */
typedef LONG LRESULT;

#endif // !_LRESULT_DEFINED
#ifndef _LPWORD_DEFINED
#define _LPWORD_DEFINED
			/* size is 4 */
typedef WORD *LPWORD;

#endif // !_LPWORD_DEFINED
#ifndef _LPDWORD_DEFINED
#define _LPDWORD_DEFINED
			/* size is 4 */
typedef DWORD *LPDWORD;

#endif // !_LPDWORD_DEFINED
			/* size is 4 */
typedef void*	LPVOID;
typedef void	VOID;

typedef /* [string] */ char *LPSTR;

			/* size is 4 */
typedef /* [string] */ const char *LPCSTR;

			/* size is 1 */
typedef unsigned char UCHAR;

			/* size is 2 */
typedef short SHORT;

			/* size is 2 */
typedef unsigned short USHORT;

			/* size is 4 */
typedef DWORD ULONG;

			/* size is 4 */
typedef LONG HRESULT;

#ifndef GUID_DEFINED
#define GUID_DEFINED
			/* size is 16 */
typedef struct  _GUID
    {
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
    }	GUID;

#endif // !GUID_DEFINED
#if !defined( __LPGUID_DEFINED__ )
#define __LPGUID_DEFINED__
			/* size is 4 */
typedef GUID *LPGUID;

#endif // !__LPGUID_DEFINED__
#ifndef __OBJECTID_DEFINED
#define __OBJECTID_DEFINED
#define _OBJECTID_DEFINED
			/* size is 20 */
typedef struct  _OBJECTID
    {
    GUID Lineage;
    unsigned long Uniquifier;
    }	OBJECTID;

#endif // !_OBJECTID_DEFINED
#if !defined( __IID_DEFINED__ )
#define __IID_DEFINED__
			/* size is 16 */
typedef GUID IID;

			/* size is 4 */
typedef IID *LPIID;

#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
			/* size is 16 */
typedef GUID CLSID;

			/* size is 4 */
typedef CLSID *LPCLSID;

#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#define REFIID              const IID &
#endif // !_REFIID_DEFINED
#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#define REFCLSID            const CLSID &
#endif // !_REFCLSID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#define REFIID              const IID * const
#endif // !_REFIID_DEFINED
#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#define REFCLSID            const CLSID * const
#endif // !_REFCLSID_DEFINED
#endif // !__cplusplus
#endif // !__IID_DEFINED__

#endif /* _SUBWTYPE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\profile.inc ===
IFNDEF __PROFILE_INC__
__PROFILE_INC EQU 1

IFDEF ICAP_PROLOGUE

?WP_REGSAVE = 1
INCLUDE icprof.inc

PROF_ENTRY MACRO
        ENDM
        
ELSE
        
IFDEF PROFILE
EXTRN __penter:NEAR

PROF_ENTRY MACRO
        pushad
        call __penter
        popad
        ENDM
ELSE
PROF_ENTRY MACRO
        ENDM
ENDIF

ENDIF
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\d3dutil.cpp ===
//----------------------------------------------------------------------------
//
// d3dutil.cpp
//
// Miscellanous utility functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <span.h>

DBG_DECLARE_FILE();

// Declare TextureDiff as an out-of-line function.
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
#include <texdiff.h>

//----------------------------------------------------------------------------
//
// DebugBreakFn
//
// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
//
//----------------------------------------------------------------------------

void FASTCALL
DebugBreakFn(void)
{
    GDPF(("!! DebugBreakFn called.  Leaving this function may destroy\n"));
    GDPF(("   the stack frame. !!\n"));
#if DBG
    DebugBreak();
#endif
}

//----------------------------------------------------------------------------
//
// OctagonNorm
//
// Returns a good approximation to sqrt(fX*fX + fY*fY)
//
//----------------------------------------------------------------------------

FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY)
{
    fX = ABSF(fX);
    fY = ABSF(fY);
    return ((11.0f/32.0f)*(fX + fY) + (21.0f/32.0f)*max(fX, fY));
}

//----------------------------------------------------------------------------
//
// ComputeLOD
//
// Computes mipmap level for the given W by deriving U and V and
// then computing LOD from the dU and dV gradients.
//
//----------------------------------------------------------------------------

INT FASTCALL
ComputeLOD(PCD3DI_RASTCTX pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY)
{
    // Compute coverage gradients.
    FLOAT fDUDX = ABSF(fW * (fDUoWDX - fU * fDOoWDX));
    FLOAT fDUDY = ABSF(fW * (fDUoWDY - fU * fDOoWDY));
    FLOAT fDVDX = ABSF(fW * (fDVoWDX - fV * fDOoWDX));
    FLOAT fDVDY = ABSF(fW * (fDVoWDY - fV * fDOoWDY));

    // Scale gradients to texture LOD 0 size.
    fDUDX *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDUDY *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDVDX *= (FLOAT)pCtx->pTexture[0]->iSizeV;
    fDVDY *= (FLOAT)pCtx->pTexture[0]->iSizeV;

    // Determine pixel coverage value to use.
    FLOAT fCoverage;

// too fuzzy
#ifdef COVERAGE_MAXGRAD
    fCoverage = max(fDUDX, fDUDY);
    fCoverage = max(fCoverage, fDVDX);
    fCoverage = max(fCoverage, fDVDY);
#endif
// too sharp, in particular, for aligned cases, fCoverage is always 0
// which leads to iLOD of LOD_MIN regardless of orientation
#ifdef COVERAGE_MINGRAD
    fCoverage = min(fDUDX, fDUDY);
    fCoverage = min(fCoverage, fDVDX);
    fCoverage = min(fCoverage, fDVDY);
#endif
#define COVERAGE_AVERAGE 1
#ifdef COVERAGE_AVERAGE
    // use OctagonNorm to approximate each length of parallelogram
    // approximating texture coverage, and arithmetically average those to
    // get the coverage.
    fCoverage = (OctagonNorm(fDUDX, fDVDX) + OctagonNorm(fDUDY, fDVDY))/2.0f;
#endif


    // Compute approximate log2 of coverage.
    FLOAT fLOD = APPXLG2F(fCoverage);

    // Apply LOD bias.
    fLOD += pCtx->pTexture[0]->fLODBias;

    INT iLOD = FTOI(fLOD * LOD_SCALE);

    // Clamp to available levels.  Not clamped to zero so that the span
    // code can check for magnification cases with a sign check.
    iLOD = min(iLOD, pCtx->pTexture[0]->iMaxScaledLOD);
    return max(LOD_MIN, iLOD);
}

//----------------------------------------------------------------------------
//
// ComputeTableFog
//
// Computes table fog values based on render state and the given Z.
// ATTENTION - Brute force for non-linear modes.  Should be optimized
// to use a table-based approximation.
//
//----------------------------------------------------------------------------

UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState,
                FLOAT fZ)
{
    double dPow;

    switch(pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE])
    {
    case D3DFOG_LINEAR:
        {
            FLOAT fFogStart = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGTABLESTART]);
            FLOAT fFogEnd = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGTABLEEND]);
            if (fZ >= fFogEnd)
            {
                return 0;
            }
            if (fZ <= fFogStart)
            {
                return FTOI(FOG_ONE_SCALE-1.0F);
            }
            return FTOI(((fFogEnd - fZ) / (fFogEnd - fFogStart)) * (FOG_ONE_SCALE-1.0F));
        }

    case D3DFOG_EXP:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY]) * fZ);
        // note that exp(-x) returns a result in the range (0.0, 1.0]
        // for x >= 0
        dPow = exp(-dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));

    case D3DFOG_EXP2:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY]) * fZ);
        dPow = exp(-dPow * dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));
    }

    GASSERTMSG(FALSE, ("ComputeTableFog unreachable\n"));
    return 0;
}

//----------------------------------------------------------------------------
//
// pVecNormalize2
//
// Normalizes the given D3DVECTOR.  Supports in-place operation.
//
//----------------------------------------------------------------------------

void FASTCALL
pVecNormalize2(LPD3DVECTOR pVec, LPD3DVECTOR pRes)
{
    FLOAT fLen;

    fLen = pVecLenSq(pVec);
    if (FLOAT_CMP_POS(fLen, <=, g_fNearZero))
    {
        pVecSet(pRes, 0.0f, 0.0f, 0.0f);
        return;
    }
    fLen = ISQRTF(fLen);
    pVecScale(pVec, fLen, pRes);
}

//-----------------------------------------------------------------------------
//
// IntLog2
//
// Do a quick, integer log2 for exact powers of 2.
//
//-----------------------------------------------------------------------------
UINT32 FASTCALL
IntLog2(UINT32 x)
{
    UINT32 y = 0;

    x >>= 1;
    while(x != 0)
    {
        x >>= 1;
        y++;
    }

    return y;
}
//---------------------------------------------------------------------
// Builds normalized plane equations going through 3 points
//
// Returns:
//      0   - if success
//      -1  - if can not build plane
//
int MakePlane(D3DVECTOR *v1, D3DVECTOR *v2, D3DVECTOR *v3, D3DVECTORH *plane)
{
    D3DVECTOR a;
    D3DVECTOR b;

    pVecSub(v2, v1, &a);
    pVecSub(v3, v1, &b);

    plane->x = a.y*b.z - a.z*b.y;
    plane->y = a.z*b.x - a.x*b.z;
    plane->z = a.x*b.y - a.y*b.x;
    plane->w = - pVecDot(v1, plane);

    double tmp = pVecDot(plane, plane);
    if (tmp <= 0)
        return -1;
    tmp = 1.0/sqrt(tmp);

    plane->x = (D3DVALUE)(plane->x * tmp);
    plane->y = (D3DVALUE)(plane->y * tmp);
    plane->z = (D3DVALUE)(plane->z * tmp);
    plane->w = (D3DVALUE)(plane->w * tmp);
    return 0;
}
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse)
{
    double x00, x01, x02;
    double x10, x11, x12;
    double x20, x21, x22;
    double rcp;
    double x30, x31, x32;
    double y01, y02, y03, y12, y13, y23;
    double z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute 4x4 determinant & its reciprocal */
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
    return -1;
    rcp = (float)1/rcp;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    /* multiply all 3x3 cofactors by reciprocal */
    inverse->_11 = (float)(z00*rcp);
    inverse->_21 = (float)(z01*rcp);
    inverse->_12 = (float)(z10*rcp);
    inverse->_31 = (float)(z02*rcp);
    inverse->_13 = (float)(z20*rcp);
    inverse->_41 = (float)(z03*rcp);
    inverse->_14 = (float)(z30*rcp);
    inverse->_22 = (float)(z11*rcp);
    inverse->_32 = (float)(z12*rcp);
    inverse->_23 = (float)(z21*rcp);
    inverse->_42 = (float)(z13*rcp);
    inverse->_24 = (float)(z31*rcp);
    inverse->_33 = (float)(z22*rcp);
    inverse->_43 = (float)(z23*rcp);
    inverse->_34 = (float)(z32*rcp);
    inverse->_44 = (float)(z33*rcp);
    return 0;
}

//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride)
{
    if (NULL == pdwStride)
    {
        return DDERR_INVALIDPARAMS;
    }
    if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED1 | D3DFVF_RESERVED2 |
         D3DFVF_NORMAL)) ||
         ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
    {
        // can't set reserved bits, shouldn't have normals in
        // output to rasterizers, and must have coordinates
        return DDERR_INVALIDPARAMS;
    }

    DWORD dwStride;
    if (dwFVF != D3DFVF_TLVERTEX)
    {   // New (non TL)FVF vertex
        // XYZ
        dwStride = sizeof(D3DVALUE) * 3;

        if (dwFVF & D3DFVF_XYZRHW)
        {
            dwStride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_DIFFUSE)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        if (dwFVF & D3DFVF_SPECULAR)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        INT iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
        dwStride += sizeof(D3DVALUE) * 2 * iTexCount;
    }
    else
    {   // (Legacy) TL vertex
        dwStride = sizeof(D3DTLVERTEX);
    }

    *pdwStride = dwStride;
    return D3D_OK;
}
//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//
BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize)
{

    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD dwType;
        LONG result;
        result =  RegQueryValueEx(hKey, valueName, NULL, &dwType,
                                  (LPBYTE)value, &dwSize);
        RegCloseKey(hKey);

        return result == ERROR_SUCCESS && dwType == type;
    }
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\hrstr.cpp ===
//----------------------------------------------------------------------------
//
// hrstr.cpp
//
// HRESULT-to-string mapper.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

#include "cppdbg.hpp"

struct HrStringDef
{
    HRESULT hr;
    char *pString;
};

#define HRDEF(Name) \
    Name, #Name

static HrStringDef g_HrStringDefs[] =
{
    // Put specific codes before generic codes so that specific codes
    // are returned in the cases where the HRESULT is the same.
    HRDEF(D3DERR_BADMAJORVERSION),
    HRDEF(D3DERR_BADMINORVERSION),
    HRDEF(D3DERR_EXECUTE_LOCKED),
    HRDEF(D3DERR_EXECUTE_NOT_LOCKED),
    HRDEF(D3DERR_EXECUTE_CREATE_FAILED),
    HRDEF(D3DERR_EXECUTE_DESTROY_FAILED),
    HRDEF(D3DERR_EXECUTE_LOCK_FAILED),
    HRDEF(D3DERR_EXECUTE_UNLOCK_FAILED),
    HRDEF(D3DERR_EXECUTE_FAILED),
    HRDEF(D3DERR_EXECUTE_CLIPPED_FAILED),
    HRDEF(D3DERR_TEXTURE_NO_SUPPORT),
    HRDEF(D3DERR_TEXTURE_NOT_LOCKED),
    HRDEF(D3DERR_TEXTURE_LOCKED),
    HRDEF(D3DERR_TEXTURE_CREATE_FAILED),
    HRDEF(D3DERR_TEXTURE_DESTROY_FAILED),
    HRDEF(D3DERR_TEXTURE_LOCK_FAILED),
    HRDEF(D3DERR_TEXTURE_UNLOCK_FAILED),
    HRDEF(D3DERR_TEXTURE_LOAD_FAILED),
    HRDEF(D3DERR_MATRIX_CREATE_FAILED),
    HRDEF(D3DERR_MATRIX_DESTROY_FAILED),
    HRDEF(D3DERR_MATRIX_SETDATA_FAILED),
    HRDEF(D3DERR_SETVIEWPORTDATA_FAILED),
    HRDEF(D3DERR_MATERIAL_CREATE_FAILED),
    HRDEF(D3DERR_MATERIAL_DESTROY_FAILED),
    HRDEF(D3DERR_MATERIAL_SETDATA_FAILED),
    HRDEF(D3DERR_LIGHT_SET_FAILED),
    HRDEF(DDERR_ALREADYINITIALIZED),
    HRDEF(DDERR_BLTFASTCANTCLIP),
    HRDEF(DDERR_CANNOTATTACHSURFACE),
    HRDEF(DDERR_CANNOTDETACHSURFACE),
    HRDEF(DDERR_CANTCREATEDC),
    HRDEF(DDERR_CANTDUPLICATE),
    HRDEF(DDERR_CLIPPERISUSINGHWND),
    HRDEF(DDERR_COLORKEYNOTSET),
    HRDEF(DDERR_CURRENTLYNOTAVAIL),
    HRDEF(DDERR_DIRECTDRAWALREADYCREATED),
    HRDEF(DDERR_EXCEPTION),
    HRDEF(DDERR_EXCLUSIVEMODEALREADYSET),
    HRDEF(DDERR_GENERIC),
    HRDEF(DDERR_HEIGHTALIGN),
    HRDEF(DDERR_HWNDALREADYSET),
    HRDEF(DDERR_HWNDSUBCLASSED),
    HRDEF(DDERR_IMPLICITLYCREATED),
    HRDEF(DDERR_INCOMPATIBLEPRIMARY),
    HRDEF(DDERR_INVALIDCAPS),
    HRDEF(DDERR_INVALIDCLIPLIST),
    HRDEF(DDERR_INVALIDDIRECTDRAWGUID),
    HRDEF(DDERR_INVALIDMODE),
    HRDEF(DDERR_INVALIDOBJECT),
    HRDEF(DDERR_INVALIDPARAMS),
    HRDEF(DDERR_INVALIDPIXELFORMAT),
    HRDEF(DDERR_INVALIDPOSITION),
    HRDEF(DDERR_INVALIDRECT),
    HRDEF(DDERR_LOCKEDSURFACES),
    HRDEF(DDERR_NO3D),
    HRDEF(DDERR_NOALPHAHW),
    HRDEF(DDERR_NOBLTHW),
    HRDEF(DDERR_NOCLIPLIST),
    HRDEF(DDERR_NOCLIPPERATTACHED),
    HRDEF(DDERR_NOCOLORCONVHW),
    HRDEF(DDERR_NOCOLORKEY),
    HRDEF(DDERR_NOCOLORKEYHW),
    HRDEF(DDERR_NOCOOPERATIVELEVELSET),
    HRDEF(DDERR_NODC),
    HRDEF(DDERR_NODDROPSHW),
    HRDEF(DDERR_NODIRECTDRAWHW),
    HRDEF(DDERR_NOEMULATION),
    HRDEF(DDERR_NOEXCLUSIVEMODE),
    HRDEF(DDERR_NOFLIPHW),
    HRDEF(DDERR_NOGDI),
    HRDEF(DDERR_NOHWND),
    HRDEF(DDERR_NOMIRRORHW),
    HRDEF(DDERR_NOOVERLAYDEST),
    HRDEF(DDERR_NOOVERLAYHW),
    HRDEF(DDERR_NOPALETTEATTACHED),
    HRDEF(DDERR_NOPALETTEHW),
    HRDEF(DDERR_NORASTEROPHW),
    HRDEF(DDERR_NOROTATIONHW),
    HRDEF(DDERR_NOSTRETCHHW),
    HRDEF(DDERR_NOT4BITCOLOR),
    HRDEF(DDERR_NOT4BITCOLORINDEX),
    HRDEF(DDERR_NOT8BITCOLOR),
    HRDEF(DDERR_NOTAOVERLAYSURFACE),
    HRDEF(DDERR_NOTEXTUREHW),
    HRDEF(DDERR_NOTFLIPPABLE),
    HRDEF(DDERR_NOTFOUND),
    HRDEF(DDERR_NOTLOCKED),
    HRDEF(DDERR_NOTPALETTIZED),
    HRDEF(DDERR_NOVSYNCHW),
    HRDEF(DDERR_NOZBUFFERHW),
    HRDEF(DDERR_NOZOVERLAYHW),
    HRDEF(DDERR_OUTOFCAPS),
    HRDEF(DDERR_OUTOFMEMORY),
    HRDEF(DDERR_OUTOFVIDEOMEMORY),
    HRDEF(DDERR_OVERLAYCANTCLIP),
    HRDEF(DDERR_OVERLAYCOLORKEYONLYONEACTIVE),
    HRDEF(DDERR_OVERLAYNOTVISIBLE),
    HRDEF(DDERR_PALETTEBUSY),
    HRDEF(DDERR_PRIMARYSURFACEALREADYEXISTS),
    HRDEF(DDERR_REGIONTOOSMALL),
    HRDEF(DDERR_SURFACEALREADYATTACHED),
    HRDEF(DDERR_SURFACEALREADYDEPENDENT),
    HRDEF(DDERR_SURFACEBUSY),
    HRDEF(DDERR_SURFACEISOBSCURED),
    HRDEF(DDERR_SURFACELOST),
    HRDEF(DDERR_SURFACENOTATTACHED),
    HRDEF(DDERR_TOOBIGHEIGHT),
    HRDEF(DDERR_TOOBIGSIZE),
    HRDEF(DDERR_TOOBIGWIDTH),
    HRDEF(DDERR_UNSUPPORTED),
    HRDEF(DDERR_UNSUPPORTEDFORMAT),
    HRDEF(DDERR_UNSUPPORTEDMASK),
    HRDEF(DDERR_VERTICALBLANKINPROGRESS),
    HRDEF(DDERR_WASSTILLDRAWING),
    HRDEF(DDERR_WRONGMODE),
    HRDEF(DDERR_XALIGN),
    HRDEF(E_OUTOFMEMORY),
    HRDEF(E_INVALIDARG),
    HRDEF(E_FAIL),
    HRDEF(S_FALSE),
    HRDEF(S_OK),
    0, NULL,
};

//----------------------------------------------------------------------------
//
// DebugModule::HrString
//
// Attempts to produce a descriptive string for the given HRESULT.
//
//----------------------------------------------------------------------------

char *DebugModule::HrString(HRESULT hr)
{
    HrStringDef *pHrDef;

    // Look for a defined string.
    for (pHrDef = g_HrStringDefs; pHrDef->pString != NULL; pHrDef++)
    {
        if (pHrDef->hr == hr)
        {
            return pHrDef->pString;
        }
    }

    // It's not a defined string so return the numeric value
    // as a string.  Use a circular buffer of strings so that
    // this routine can be used more than once in a particular output
    // message.
    
#define STATIC_BUFFER 256
#define MAX_STRING 16
    
    static char chBuffer[STATIC_BUFFER];
    static char *pBuf = chBuffer;
    char *pString;

    if (pBuf - chBuffer + MAX_STRING > STATIC_BUFFER)
    {
        pBuf = chBuffer;
    }

    sprintf(pBuf, "0x%08X", hr);

    pString = pBuf;
    pBuf += MAX_STRING;

    return pString;
}

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\d3dutil.h ===
//----------------------------------------------------------------------------
//
// d3dutil.h
//
// Miscellaneous utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DUTIL_H_
#define _D3DUTIL_H_

#include <d3dflt.h>

#ifdef __cplusplus
extern "C" {
#endif

// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
void FASTCALL
DebugBreakFn(void);

// Texture coordinate difference.
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode);

// Inline texture coordinate difference.
__inline FLOAT
InlTextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
#include <texdiff.h>

// Returns a good approximation to sqrt(fX*fX + fY*fY)
FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY);

// LOD computation.
INT FASTCALL
ComputeLOD(CONST struct tagD3DI_RASTCTX *pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY);

// Table fog value computation.
UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState, FLOAT fZ);

// Compute integer log2 for exact powers of 2.
UINT32 FASTCALL
IntLog2(UINT32 x);

//
// D3DVECTOR operations.
//

#define pVecLenSq(pVec)                                                       \
    pVecDot(pVec, pVec)
#define pVecLen(pVec)                                                         \
    SQRTF(pVecLenSq(pVec))

void FASTCALL
pVecNormalize2(LPD3DVECTOR pVec, LPD3DVECTOR pRes);

#define pVecNormalize(pVec)             pVecNormalize2(pVec, pVec)
#define VecNormalize(Vec)               pVecNormalize(&(Vec))
#define VecNormalize2(Vec, Res)         pVecNormalize2(&(Vec), &(Res))

#define pVecDot(pVec1, pVec2)                                                 \
    ((pVec1)->x * (pVec2)->x + (pVec1)->y * (pVec2)->y +                      \
     (pVec1)->z * (pVec2)->z)

#define pVecAdd(pVec1, pVec2, pRes)                                           \
    ((pRes)->x = (pVec1)->x + (pVec2)->x,                                     \
     (pRes)->y = (pVec1)->y + (pVec2)->y,                                     \
     (pRes)->z = (pVec1)->z + (pVec2)->z)

#define pVecSub(pVec1, pVec2, pRes)                                           \
    ((pRes)->x = (pVec1)->x - (pVec2)->x,                                     \
     (pRes)->y = (pVec1)->y - (pVec2)->y,                                     \
     (pRes)->z = (pVec1)->z - (pVec2)->z)

#define pVecScale(pVec, fScale, pRes)                                         \
    ((pRes)->x = (pVec)->x * (fScale),                                        \
     (pRes)->y = (pVec)->y * (fScale),                                        \
     (pRes)->z = (pVec)->z * (fScale))

#define pVecNeg(pVec, pRes)                                                   \
    ((pRes)->x = NEGF((pVec)->x),                                             \
     (pRes)->y = NEGF((pVec)->y),                                             \
     (pRes)->z = NEGF((pVec)->z))

#define pVecSet(pVec, fX, fY, fZ)                                             \
    ((pVec)->x = (fX), (pVec)->y = (fY), (pVec)->z = (fZ))

#define VecLenSq(Vec)                   pVecLenSq(&(Vec))
#define VecLen(Vec)                     pVecLen(&(Vec))

#ifdef _X86_

// Vector normalize through a table
void  FASTCALL TableVecNormalize(float *result, float *normal);
// Vector normalize using Jim Blinn's floating point trick
void  FASTCALL JBVecNormalize(float *result, float *normal);

#define VecNormalizeFast(Vec)          TableVecNormalize((float*)&(Vec), (float*)&(Vec))
#define VecNormalizeFast2(Vec, Res)    TableVecNormalize((float*)&(Res), (float*)&(Vec))
#define pVecNormalizeFast(Vec)         TableVecNormalize((float*)pVec, (float*)pVec)
#define pVecNormalizeFast2(pVec, pRes) TableVecNormalize((float*)pRes, (float*)pVec)

#else

#define VecNormalizeFast(Vec)               pVecNormalize(&(Vec))
#define VecNormalizeFast2(Vec, Res)         pVecNormalize2(&(Vec), &(Res))
#define pVecNormalizeFast(pVec)             pVecNormalize(pVec)
#define pVecNormalizeFast2(pVec, pRes)      pVecNormalize2(pVec, pRes)

#endif // _X86_

#define VecDot(Vec1, Vec2)              pVecDot(&(Vec1), &(Vec2))
#define VecAdd(Vec1, Vec2, Res)         pVecAdd(&(Vec1), &(Vec2), &(Res))
#define VecSub(Vec1, Vec2, Res)         pVecSub(&(Vec1), &(Vec2), &(Res))
#define VecScale(Vec1, fScale, Res)     pVecScale(&(Vec1), fScale, &(Res))
#define VecNeg(Vec, Res)                pVecNeg(&(Vec), &(Res))
#define VecSet(Vec, fX, fY, fZ)         pVecSet(&(Vec), fX, fY, fZ)

//---------------------------------------------------------------------
// Convert homogeneous vector to 3D vector
//
// Returns:
//      0   - if success
//     -1   - v.w == 0
//
__inline int Vector4to3D(D3DVECTORH *v)
{
    if (v->w == 0)
        return -1;
    D3DVALUE k = 1.0f/v->w;
    v->x *= k;
    v->y *= k;
    v->z *= k;
    v->w = (D3DVALUE) 1;
    return 0;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//
__inline void VecMatMul4(D3DVECTOR *v, D3DMATRIX *m, D3DVECTORH *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x3 matrix
//
// res and v should not be the same
//
__inline void VecMatMul(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
}
//---------------------------------------------------------------------
// Builds normalized plane equations going through 3 points
//
// Returns:
//      0   - if success
//      -1  - if can not build plane
//
int MakePlane(D3DVECTOR *v1, D3DVECTOR *v2, D3DVECTOR *v3,
                     D3DVECTORH *plane);
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse);

//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride);

//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//
BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize);

#ifdef __cplusplus
}
#endif

#endif // #ifndef _D3DUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//   
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef WINNT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <ddrawp.h>

#include <d3dp.h>
#include <d3dhal.h>

#include <d3di.hpp>
#include <cppdbg.hpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\d3dflt.cpp ===
//----------------------------------------------------------------------------
//
// d3dflt.cpp
//
// Supporting data and routines for general FP header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#ifdef _X86_

FLOAT g_fE =                    FLOAT_E;
FLOAT g_fZero =                 0.0f;
FLOAT g_fNearZero =             FLOAT_NEARZERO;
FLOAT g_fHalf =                 0.5f;
FLOAT g_fp95 =                  0.95f;
FLOAT g_fOne =                  1.0f;
FLOAT g_fOneMinusEps =          1.0f - FLT_EPSILON;
FLOAT g_fExpScale =             FLOAT_EXPSCALE;
FLOAT g_fOoExpScale =           (FLOAT)(1.0 / (double)FLOAT_EXPSCALE);
FLOAT g_f255oTwoPow15 =         (FLOAT)(255.0 / (double)CONST_TWOPOW15);
FLOAT g_fOo255 =                (FLOAT)(1.0 / 255.0);
FLOAT g_fOo256 =                (FLOAT)(1.0 / 256.0);
FLOAT g_fTwoPow7 =              FLOAT_TWOPOW7;
FLOAT g_fTwoPow8 =              FLOAT_TWOPOW8;
FLOAT g_fTwoPow11 =             FLOAT_TWOPOW11;
FLOAT g_fTwoPow15 =             FLOAT_TWOPOW15;
FLOAT g_fOoTwoPow15 =           (FLOAT)(1.0 / (double)CONST_TWOPOW15);
FLOAT g_fTwoPow16 =             FLOAT_TWOPOW16;
FLOAT g_fOoTwoPow16 =           (FLOAT)(1.0 / (double)CONST_TWOPOW16);
FLOAT g_fTwoPow20 =             FLOAT_TWOPOW20;
FLOAT g_fOoTwoPow20 =           (FLOAT)(1.0 / (double)CONST_TWOPOW20);
FLOAT g_fTwoPow27 =             FLOAT_TWOPOW27;
FLOAT g_fOoTwoPow27 =           (FLOAT)(1.0 / (double)CONST_TWOPOW27);
FLOAT g_fTwoPow30 =             FLOAT_TWOPOW30;
FLOAT g_fTwoPow31 =             FLOAT_TWOPOW31;
FLOAT g_fNearTwoPow31 =         FLOAT_NEARTWOPOW31;
FLOAT g_fOoTwoPow31 =           (FLOAT)(1.0 / (double)CONST_TWOPOW31);
FLOAT g_fOoNearTwoPow31 =       (FLOAT)(1.0 / (double)FLOAT_NEARTWOPOW31);
FLOAT g_fTwoPow32 =             FLOAT_TWOPOW32;
FLOAT g_fNearTwoPow32 =         FLOAT_NEARTWOPOW32;
FLOAT g_fTwoPow39 =             FLOAT_TWOPOW39;
FLOAT g_fTwoPow47 =             FLOAT_TWOPOW47;

#endif // _X86_

FLOAT g_fUInt8ToFloat[257] =
{
    0.0f,
    (FLOAT)(1.0 / 255.0),
    (FLOAT)(2.0 / 255.0),
    (FLOAT)(3.0 / 255.0),
    (FLOAT)(4.0 / 255.0),
    (FLOAT)(5.0 / 255.0),
    (FLOAT)(6.0 / 255.0),
    (FLOAT)(7.0 / 255.0),
    (FLOAT)(8.0 / 255.0),
    (FLOAT)(9.0 / 255.0),
    (FLOAT)(10.0 / 255.0),
    (FLOAT)(11.0 / 255.0),
    (FLOAT)(12.0 / 255.0),
    (FLOAT)(13.0 / 255.0),
    (FLOAT)(14.0 / 255.0),
    (FLOAT)(15.0 / 255.0),
    (FLOAT)(16.0 / 255.0),
    (FLOAT)(17.0 / 255.0),
    (FLOAT)(18.0 / 255.0),
    (FLOAT)(19.0 / 255.0),
    (FLOAT)(20.0 / 255.0),
    (FLOAT)(21.0 / 255.0),
    (FLOAT)(22.0 / 255.0),
    (FLOAT)(23.0 / 255.0),
    (FLOAT)(24.0 / 255.0),
    (FLOAT)(25.0 / 255.0),
    (FLOAT)(26.0 / 255.0),
    (FLOAT)(27.0 / 255.0),
    (FLOAT)(28.0 / 255.0),
    (FLOAT)(29.0 / 255.0),
    (FLOAT)(30.0 / 255.0),
    (FLOAT)(31.0 / 255.0),
    (FLOAT)(32.0 / 255.0),
    (FLOAT)(33.0 / 255.0),
    (FLOAT)(34.0 / 255.0),
    (FLOAT)(35.0 / 255.0),
    (FLOAT)(36.0 / 255.0),
    (FLOAT)(37.0 / 255.0),
    (FLOAT)(38.0 / 255.0),
    (FLOAT)(39.0 / 255.0),
    (FLOAT)(40.0 / 255.0),
    (FLOAT)(41.0 / 255.0),
    (FLOAT)(42.0 / 255.0),
    (FLOAT)(43.0 / 255.0),
    (FLOAT)(44.0 / 255.0),
    (FLOAT)(45.0 / 255.0),
    (FLOAT)(46.0 / 255.0),
    (FLOAT)(47.0 / 255.0),
    (FLOAT)(48.0 / 255.0),
    (FLOAT)(49.0 / 255.0),
    (FLOAT)(50.0 / 255.0),
    (FLOAT)(51.0 / 255.0),
    (FLOAT)(52.0 / 255.0),
    (FLOAT)(53.0 / 255.0),
    (FLOAT)(54.0 / 255.0),
    (FLOAT)(55.0 / 255.0),
    (FLOAT)(56.0 / 255.0),
    (FLOAT)(57.0 / 255.0),
    (FLOAT)(58.0 / 255.0),
    (FLOAT)(59.0 / 255.0),
    (FLOAT)(60.0 / 255.0),
    (FLOAT)(61.0 / 255.0),
    (FLOAT)(62.0 / 255.0),
    (FLOAT)(63.0 / 255.0),
    (FLOAT)(64.0 / 255.0),
    (FLOAT)(65.0 / 255.0),
    (FLOAT)(66.0 / 255.0),
    (FLOAT)(67.0 / 255.0),
    (FLOAT)(68.0 / 255.0),
    (FLOAT)(69.0 / 255.0),
    (FLOAT)(70.0 / 255.0),
    (FLOAT)(71.0 / 255.0),
    (FLOAT)(72.0 / 255.0),
    (FLOAT)(73.0 / 255.0),
    (FLOAT)(74.0 / 255.0),
    (FLOAT)(75.0 / 255.0),
    (FLOAT)(76.0 / 255.0),
    (FLOAT)(77.0 / 255.0),
    (FLOAT)(78.0 / 255.0),
    (FLOAT)(79.0 / 255.0),
    (FLOAT)(80.0 / 255.0),
    (FLOAT)(81.0 / 255.0),
    (FLOAT)(82.0 / 255.0),
    (FLOAT)(83.0 / 255.0),
    (FLOAT)(84.0 / 255.0),
    (FLOAT)(85.0 / 255.0),
    (FLOAT)(86.0 / 255.0),
    (FLOAT)(87.0 / 255.0),
    (FLOAT)(88.0 / 255.0),
    (FLOAT)(89.0 / 255.0),
    (FLOAT)(90.0 / 255.0),
    (FLOAT)(91.0 / 255.0),
    (FLOAT)(92.0 / 255.0),
    (FLOAT)(93.0 / 255.0),
    (FLOAT)(94.0 / 255.0),
    (FLOAT)(95.0 / 255.0),
    (FLOAT)(96.0 / 255.0),
    (FLOAT)(97.0 / 255.0),
    (FLOAT)(98.0 / 255.0),
    (FLOAT)(99.0 / 255.0),
    (FLOAT)(100.0 / 255.0),
    (FLOAT)(101.0 / 255.0),
    (FLOAT)(102.0 / 255.0),
    (FLOAT)(103.0 / 255.0),
    (FLOAT)(104.0 / 255.0),
    (FLOAT)(105.0 / 255.0),
    (FLOAT)(106.0 / 255.0),
    (FLOAT)(107.0 / 255.0),
    (FLOAT)(108.0 / 255.0),
    (FLOAT)(109.0 / 255.0),
    (FLOAT)(110.0 / 255.0),
    (FLOAT)(111.0 / 255.0),
    (FLOAT)(112.0 / 255.0),
    (FLOAT)(113.0 / 255.0),
    (FLOAT)(114.0 / 255.0),
    (FLOAT)(115.0 / 255.0),
    (FLOAT)(116.0 / 255.0),
    (FLOAT)(117.0 / 255.0),
    (FLOAT)(118.0 / 255.0),
    (FLOAT)(119.0 / 255.0),
    (FLOAT)(120.0 / 255.0),
    (FLOAT)(121.0 / 255.0),
    (FLOAT)(122.0 / 255.0),
    (FLOAT)(123.0 / 255.0),
    (FLOAT)(124.0 / 255.0),
    (FLOAT)(125.0 / 255.0),
    (FLOAT)(126.0 / 255.0),
    (FLOAT)(127.0 / 255.0),
    (FLOAT)(128.0 / 255.0),
    (FLOAT)(129.0 / 255.0),
    (FLOAT)(130.0 / 255.0),
    (FLOAT)(131.0 / 255.0),
    (FLOAT)(132.0 / 255.0),
    (FLOAT)(133.0 / 255.0),
    (FLOAT)(134.0 / 255.0),
    (FLOAT)(135.0 / 255.0),
    (FLOAT)(136.0 / 255.0),
    (FLOAT)(137.0 / 255.0),
    (FLOAT)(138.0 / 255.0),
    (FLOAT)(139.0 / 255.0),
    (FLOAT)(140.0 / 255.0),
    (FLOAT)(141.0 / 255.0),
    (FLOAT)(142.0 / 255.0),
    (FLOAT)(143.0 / 255.0),
    (FLOAT)(144.0 / 255.0),
    (FLOAT)(145.0 / 255.0),
    (FLOAT)(146.0 / 255.0),
    (FLOAT)(147.0 / 255.0),
    (FLOAT)(148.0 / 255.0),
    (FLOAT)(149.0 / 255.0),
    (FLOAT)(150.0 / 255.0),
    (FLOAT)(151.0 / 255.0),
    (FLOAT)(152.0 / 255.0),
    (FLOAT)(153.0 / 255.0),
    (FLOAT)(154.0 / 255.0),
    (FLOAT)(155.0 / 255.0),
    (FLOAT)(156.0 / 255.0),
    (FLOAT)(157.0 / 255.0),
    (FLOAT)(158.0 / 255.0),
    (FLOAT)(159.0 / 255.0),
    (FLOAT)(160.0 / 255.0),
    (FLOAT)(161.0 / 255.0),
    (FLOAT)(162.0 / 255.0),
    (FLOAT)(163.0 / 255.0),
    (FLOAT)(164.0 / 255.0),
    (FLOAT)(165.0 / 255.0),
    (FLOAT)(166.0 / 255.0),
    (FLOAT)(167.0 / 255.0),
    (FLOAT)(168.0 / 255.0),
    (FLOAT)(169.0 / 255.0),
    (FLOAT)(170.0 / 255.0),
    (FLOAT)(171.0 / 255.0),
    (FLOAT)(172.0 / 255.0),
    (FLOAT)(173.0 / 255.0),
    (FLOAT)(174.0 / 255.0),
    (FLOAT)(175.0 / 255.0),
    (FLOAT)(176.0 / 255.0),
    (FLOAT)(177.0 / 255.0),
    (FLOAT)(178.0 / 255.0),
    (FLOAT)(179.0 / 255.0),
    (FLOAT)(180.0 / 255.0),
    (FLOAT)(181.0 / 255.0),
    (FLOAT)(182.0 / 255.0),
    (FLOAT)(183.0 / 255.0),
    (FLOAT)(184.0 / 255.0),
    (FLOAT)(185.0 / 255.0),
    (FLOAT)(186.0 / 255.0),
    (FLOAT)(187.0 / 255.0),
    (FLOAT)(188.0 / 255.0),
    (FLOAT)(189.0 / 255.0),
    (FLOAT)(190.0 / 255.0),
    (FLOAT)(191.0 / 255.0),
    (FLOAT)(192.0 / 255.0),
    (FLOAT)(193.0 / 255.0),
    (FLOAT)(194.0 / 255.0),
    (FLOAT)(195.0 / 255.0),
    (FLOAT)(196.0 / 255.0),
    (FLOAT)(197.0 / 255.0),
    (FLOAT)(198.0 / 255.0),
    (FLOAT)(199.0 / 255.0),
    (FLOAT)(200.0 / 255.0),
    (FLOAT)(201.0 / 255.0),
    (FLOAT)(202.0 / 255.0),
    (FLOAT)(203.0 / 255.0),
    (FLOAT)(204.0 / 255.0),
    (FLOAT)(205.0 / 255.0),
    (FLOAT)(206.0 / 255.0),
    (FLOAT)(207.0 / 255.0),
    (FLOAT)(208.0 / 255.0),
    (FLOAT)(209.0 / 255.0),
    (FLOAT)(210.0 / 255.0),
    (FLOAT)(211.0 / 255.0),
    (FLOAT)(212.0 / 255.0),
    (FLOAT)(213.0 / 255.0),
    (FLOAT)(214.0 / 255.0),
    (FLOAT)(215.0 / 255.0),
    (FLOAT)(216.0 / 255.0),
    (FLOAT)(217.0 / 255.0),
    (FLOAT)(218.0 / 255.0),
    (FLOAT)(219.0 / 255.0),
    (FLOAT)(220.0 / 255.0),
    (FLOAT)(221.0 / 255.0),
    (FLOAT)(222.0 / 255.0),
    (FLOAT)(223.0 / 255.0),
    (FLOAT)(224.0 / 255.0),
    (FLOAT)(225.0 / 255.0),
    (FLOAT)(226.0 / 255.0),
    (FLOAT)(227.0 / 255.0),
    (FLOAT)(228.0 / 255.0),
    (FLOAT)(229.0 / 255.0),
    (FLOAT)(230.0 / 255.0),
    (FLOAT)(231.0 / 255.0),
    (FLOAT)(232.0 / 255.0),
    (FLOAT)(233.0 / 255.0),
    (FLOAT)(234.0 / 255.0),
    (FLOAT)(235.0 / 255.0),
    (FLOAT)(236.0 / 255.0),
    (FLOAT)(237.0 / 255.0),
    (FLOAT)(238.0 / 255.0),
    (FLOAT)(239.0 / 255.0),
    (FLOAT)(240.0 / 255.0),
    (FLOAT)(241.0 / 255.0),
    (FLOAT)(242.0 / 255.0),
    (FLOAT)(243.0 / 255.0),
    (FLOAT)(244.0 / 255.0),
    (FLOAT)(245.0 / 255.0),
    (FLOAT)(246.0 / 255.0),
    (FLOAT)(247.0 / 255.0),
    (FLOAT)(248.0 / 255.0),
    (FLOAT)(249.0 / 255.0),
    (FLOAT)(250.0 / 255.0),
    (FLOAT)(251.0 / 255.0),
    (FLOAT)(252.0 / 255.0),
    (FLOAT)(253.0 / 255.0),
    (FLOAT)(254.0 / 255.0),
    1.0f,
    // Extra entry to allow for overflow.
    1.0f,
};

DOUBLE g_dSnap[33] =
{
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW52,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW51,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW50,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW49,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW48,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW47,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW46,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW45,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW44,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW43,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW42,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW41,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW40,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW39,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW38,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW37,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW36,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW35,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW34,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW33,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW31,
    (DOUBLE)CONST_TWOPOW31 + (DOUBLE)CONST_TWOPOW30,
    (DOUBLE)CONST_TWOPOW30 + (DOUBLE)CONST_TWOPOW29,
    (DOUBLE)CONST_TWOPOW29 + (DOUBLE)CONST_TWOPOW28,
    (DOUBLE)CONST_TWOPOW28 + (DOUBLE)CONST_TWOPOW27,
    (DOUBLE)CONST_TWOPOW27 + (DOUBLE)CONST_TWOPOW26,
    (DOUBLE)CONST_TWOPOW26 + (DOUBLE)CONST_TWOPOW25,
    (DOUBLE)CONST_TWOPOW25 + (DOUBLE)CONST_TWOPOW24,
    (DOUBLE)CONST_TWOPOW24 + (DOUBLE)CONST_TWOPOW23,
    (DOUBLE)CONST_TWOPOW23 + (DOUBLE)CONST_TWOPOW22,
    (DOUBLE)CONST_TWOPOW22 + (DOUBLE)CONST_TWOPOW21,
    (DOUBLE)CONST_TWOPOW21 + (DOUBLE)CONST_TWOPOW20,
    (DOUBLE)CONST_TWOPOW20 + (DOUBLE)CONST_TWOPOW19,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\sources.inc ===
TARGETNAME = d3dutil
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = $(INCLUDES);$(D3DROOT)\pipeln\inc
        
SOURCES = \
        ..\cppdbg.cpp\
        ..\d3dflt.cpp\
        ..\d3dutil.cpp\
        ..\_dpf.cpp\
        ..\hrstr.cpp\
        ..\_memalloc.c

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\_dpf.cpp ===
#include "pch.cpp"
#pragma hdrstop

#define PROF_SECT "Direct3D"
#define START_STR "Direct3D: "
#include "..\..\..\misc\dpf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\icprof.inc ===
pushcontext listing
.nolist
;
;	(C) Copyright Microsoft Corporation 1992, 1995

;	This file is used to create the same sets of prologue and epilogue
;	sequences which the Microsoft C 6.00 compiler will produce.  This
;	file would be used for writing windows programs and to provide
;	such features as stack checking in the assembler portions of
;	a C based project.


;	The following global variables will affect the prolog/epilog
;	sequences produced
;
;	PROFILE - If 1 then __penter calls will be inserted in all prologs
;	?WP_DEBUG - If 1 then prolog/epilog sequences will be forced
;	?WP_CHECKSTACK - If 1 then a check stack will be forced on all
;			procedures
;	?WP_INCBP - If 1 then the inc bp sequence will be generated on
;		all far procedures
;	?WP_LOADDS - If 1 then the load ds sequence will be generated on
;		all far procedures
;
ifndef ?WP_DEBUG
?WP_DEBUG = 0
endif
ifndef ?WP_CHECKSTACK
?WP_CHECKSTACK = 0
endif
ifndef ?WP_INCBP
?WP_INCBP = 0
endif
ifndef ?WP_LOADDS
?WP_LOADDS = 0
endif
ifndef PROFILE
PROFILE = 0
endif
ifndef ?WP_REGSAVE
?WP_REGSAVE = 0
endif

;
;	Complain if we are in a segment as this will affect how the
;	externdefs are done and therefore the fixups and code
;	created on the checkstack calls
;
% ifnb	 <@CurSeg>
echo	Include should not be contained in a segment
endif

externdef C	_aNchkstk:near		; Extern the symbols
externdef C	_aFchkstk:far		; for later reference
externdef C	_penter:near

;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP
;	PROFILE

option prologue:cPrologue

cPrologue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
	LOCAL	?cbLocals
	LOCAL	?doProfile
        LOCAL   ?doRegSave
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0
	?cbLocals = cbLocals
	?doProfile = 0
        ?doRegSave = 0

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default if far
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default if far
 if flags AND 020h
  ?loadds = 1
 endif
endif

if	PROFILE NE 0		    ;; profiling wanted
 ?doProfile  = 1			;; turn on profiling
endif

if      ?WP_REGSAVE NE 0
 ?doRegSave = 1
endif
        
;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>		 ;; Is it IncBP
   if flags AND 020h		;;	and far?
    ?incbp = 1			;;	Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

  ifidni <p>, <PROFILE>
   ?doProfile = 1
  endif

  ifidni <p>, <NOPROFILE>
   ?doProfile = 0
  endif

  ifidni <p>, <REGSAVE>
   ?doRegSave = 1
  endif
        
  ifidni <p>, <NOREGSAVE>
   ?doRegSave = 0
  endif
        
 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (?cbLocals NE 0) OR (cbParams NE 0)

if	?doProfile EQ 1 	;; generate profiling call
if      ?doRegSave EQ 1
        pushad
endif
	call	_penter
if      ?doRegSave EQ 1
        popad
endif
endif

if	?doPrologue EQ 0	;; No prolog needed -- so get out of here
;	popcontext listing
	exitm<0>
endif

if	?loadds EQ 1		;; Create the loadds code -- force in
	push	ds		;;	Put DS into AX -- we will place
	pop	ax	     ;;      back in DS later.	This sequence
	nop			;;	is altered by the OS if needed
endif

if	?incbp EQ 1		;; Mark as a far procedure for stack
	inc	bp	     ;;      walking
endif

if @WordSize eq 4
	push	ebp
	mov	ebp, esp
else
	push	bp	     ;; Create the frame
	mov	bp,sp
endif

if	?loadds EQ 1		;; Load up DS with the value in AX
	push	ds		;;
	mov	ds,ax	     ;;
	?cbLocals = ?cbLocals + 2
endif

if	?checkstack EQ 1	;; Now	allocate space for locals
	mov	ax,cbLocals  ;;      # of bytes of locals (unadjusted)
% ifidni <@CurSeg>, <_TEXT>
	call	_aNchkstk	;;	Call run time routine to allocate
 else
	call	_aFchkstk
 endif
else	; ?checkstack NE 1
  if	cbLocals NE 0
    if @WordSize eq 4
	sub	esp, cbLocals
    else
	sub	sp,cbLocals   ;;      make space on the stack for locals
    endif
  endif
endif

ifnb	rgRegs			;; There are registers to be saved.  do so
	for r,rgRegs
		push	r
	endm
endif
;	popcontext listing
	exitm <?cbLocals>

endm



;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP

option epilogue:cEpilogue

cEpilogue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default
 if flags AND 020h
  ?loadds = 1
 endif
endif

;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>	 ;;	 Is it IncBP
   if flags AND 020h
    ?incbp = 1			;;		Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (cbLocals NE 0) OR (cbParams NE 0)

if	?doPrologue EQ 0	;; No epilog needed -- so get out of here
	ret
	exitm
endif

ifnb	rgRegs			;; Pop off the registers -- they are in
	for r,rgRegs		;; inverse order from the prologue call
		pop	r
	endm
endif

if	?loadds 		;;
	dec	bp
	dec	bp
	mov	sp,bp
	pop	ds
	pop	bp
else

  if @WordSize eq 4
	mov	esp, ebp
	pop	ebp
  else
	mov	sp,bp
	pop	bp
  endif
endif

if	?incbp			;; Remove the increment of BP if necessary
	dec	bp
endif

if	flags AND 010h		;; Caller pops stack arguments
	ret
else				;; Callee pops args
 if	cbParams NE 0		;; Put out the correct form of return
	ret	cbParams
 else
	ret
 endif
endif
endm

popcontext	listing
.listmacro
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\d3dflt.h ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997.
//
// d3dflt.h
//
// Floating-point constants and operations on FP values.
//
//----------------------------------------------------------------------------

#ifndef _D3DFLT_H_
#define _D3DFLT_H_

#include <math.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef union tagFLOATINT32
{
    FLOAT f;
    INT32 i;
    UINT32 u;
} FLOATINT32, *PFLOATINT32;

//
// Type-forcing macros to access FP as integer and vice-versa.
// ATTENTION - VC5's optimizer turns these macros into ftol sometimes,
// completely breaking them.
// Using FLOATINT32 works around the problem but is not as flexible,
// so the old code is kept around for the time when the compiler is fixed.
// Note that pointer casting with FLOATINT32 fails just as the direct
// pointer casting does, so it's not a remedy.
//
// Use these macros with extreme care.
//

#define ASFLOAT(i) (*(FLOAT *)&(i))
#define ASINT32(f) (*(INT32 *)&(f))
#define ASUINT32(f) (*(UINT32 *)&(f))

//
// FP constants.
//

// Powers of two for snap values.  These should not be used in code.
#define CONST_TWOPOW0   1
#define CONST_TWOPOW1   2
#define CONST_TWOPOW2   4
#define CONST_TWOPOW3   8
#define CONST_TWOPOW4   16
#define CONST_TWOPOW5   32
#define CONST_TWOPOW6   64
#define CONST_TWOPOW7   128
#define CONST_TWOPOW8   256
#define CONST_TWOPOW9   512
#define CONST_TWOPOW10  1024
#define CONST_TWOPOW11  2048
#define CONST_TWOPOW12  4096
#define CONST_TWOPOW13  8192
#define CONST_TWOPOW14  16384
#define CONST_TWOPOW15  32768
#define CONST_TWOPOW16  65536
#define CONST_TWOPOW17  131072
#define CONST_TWOPOW18  262144
#define CONST_TWOPOW19  524288
#define CONST_TWOPOW20  1048576
#define CONST_TWOPOW21  2097152
#define CONST_TWOPOW22  4194304
#define CONST_TWOPOW23  8388608
#define CONST_TWOPOW24  16777216
#define CONST_TWOPOW25  33554432
#define CONST_TWOPOW26  67108864
#define CONST_TWOPOW27  134217728
#define CONST_TWOPOW28  268435456
#define CONST_TWOPOW29  536870912
#define CONST_TWOPOW30  1073741824
#define CONST_TWOPOW31  2147483648
#define CONST_TWOPOW32  4294967296
#define CONST_TWOPOW33  8589934592
#define CONST_TWOPOW34  17179869184
#define CONST_TWOPOW35  34359738368
#define CONST_TWOPOW36  68719476736
#define CONST_TWOPOW37  137438953472
#define CONST_TWOPOW38  274877906944
#define CONST_TWOPOW39  549755813888
#define CONST_TWOPOW40  1099511627776
#define CONST_TWOPOW41  2199023255552
#define CONST_TWOPOW42  4398046511104
#define CONST_TWOPOW43  8796093022208
#define CONST_TWOPOW44  17592186044416
#define CONST_TWOPOW45  35184372088832
#define CONST_TWOPOW46  70368744177664
#define CONST_TWOPOW47  140737488355328
#define CONST_TWOPOW48  281474976710656
#define CONST_TWOPOW49  562949953421312
#define CONST_TWOPOW50  1125899906842624
#define CONST_TWOPOW51  2251799813685248
#define CONST_TWOPOW52  4503599627370496

#define FLOAT_TWOPOW0   ((FLOAT)(CONST_TWOPOW0))
#define FLOAT_TWOPOW1   ((FLOAT)(CONST_TWOPOW1))
#define FLOAT_TWOPOW2   ((FLOAT)(CONST_TWOPOW2))
#define FLOAT_TWOPOW3   ((FLOAT)(CONST_TWOPOW3))
#define FLOAT_TWOPOW4   ((FLOAT)(CONST_TWOPOW4))
#define FLOAT_TWOPOW5   ((FLOAT)(CONST_TWOPOW5))
#define FLOAT_TWOPOW6   ((FLOAT)(CONST_TWOPOW6))
#define FLOAT_TWOPOW7   ((FLOAT)(CONST_TWOPOW7))
#define FLOAT_TWOPOW8   ((FLOAT)(CONST_TWOPOW8))
#define FLOAT_TWOPOW9   ((FLOAT)(CONST_TWOPOW9))
#define FLOAT_TWOPOW10  ((FLOAT)(CONST_TWOPOW10))
#define FLOAT_TWOPOW11  ((FLOAT)(CONST_TWOPOW11))
#define FLOAT_TWOPOW12  ((FLOAT)(CONST_TWOPOW12))
#define FLOAT_TWOPOW13  ((FLOAT)(CONST_TWOPOW13))
#define FLOAT_TWOPOW14  ((FLOAT)(CONST_TWOPOW14))
#define FLOAT_TWOPOW15  ((FLOAT)(CONST_TWOPOW15))
#define FLOAT_TWOPOW16  ((FLOAT)(CONST_TWOPOW16))
#define FLOAT_TWOPOW17  ((FLOAT)(CONST_TWOPOW17))
#define FLOAT_TWOPOW18  ((FLOAT)(CONST_TWOPOW18))
#define FLOAT_TWOPOW19  ((FLOAT)(CONST_TWOPOW19))
#define FLOAT_TWOPOW20  ((FLOAT)(CONST_TWOPOW20))
#define FLOAT_TWOPOW21  ((FLOAT)(CONST_TWOPOW21))
#define FLOAT_TWOPOW22  ((FLOAT)(CONST_TWOPOW22))
#define FLOAT_TWOPOW23  ((FLOAT)(CONST_TWOPOW23))
#define FLOAT_TWOPOW24  ((FLOAT)(CONST_TWOPOW24))
#define FLOAT_TWOPOW25  ((FLOAT)(CONST_TWOPOW25))
#define FLOAT_TWOPOW26  ((FLOAT)(CONST_TWOPOW26))
#define FLOAT_TWOPOW27  ((FLOAT)(CONST_TWOPOW27))
#define FLOAT_TWOPOW28  ((FLOAT)(CONST_TWOPOW28))
#define FLOAT_TWOPOW29  ((FLOAT)(CONST_TWOPOW29))
#define FLOAT_TWOPOW30  ((FLOAT)(CONST_TWOPOW30))
#define FLOAT_TWOPOW31  ((FLOAT)(CONST_TWOPOW31))
#define FLOAT_TWOPOW32  ((FLOAT)(CONST_TWOPOW32))
#define FLOAT_TWOPOW33  ((FLOAT)(CONST_TWOPOW33))
#define FLOAT_TWOPOW34  ((FLOAT)(CONST_TWOPOW34))
#define FLOAT_TWOPOW35  ((FLOAT)(CONST_TWOPOW35))
#define FLOAT_TWOPOW36  ((FLOAT)(CONST_TWOPOW36))
#define FLOAT_TWOPOW37  ((FLOAT)(CONST_TWOPOW37))
#define FLOAT_TWOPOW38  ((FLOAT)(CONST_TWOPOW38))
#define FLOAT_TWOPOW39  ((FLOAT)(CONST_TWOPOW39))
#define FLOAT_TWOPOW40  ((FLOAT)(CONST_TWOPOW40))
#define FLOAT_TWOPOW41  ((FLOAT)(CONST_TWOPOW41))
#define FLOAT_TWOPOW42  ((FLOAT)(CONST_TWOPOW42))
#define FLOAT_TWOPOW43  ((FLOAT)(CONST_TWOPOW43))
#define FLOAT_TWOPOW44  ((FLOAT)(CONST_TWOPOW44))
#define FLOAT_TWOPOW45  ((FLOAT)(CONST_TWOPOW45))
#define FLOAT_TWOPOW46  ((FLOAT)(CONST_TWOPOW46))
#define FLOAT_TWOPOW47  ((FLOAT)(CONST_TWOPOW47))
#define FLOAT_TWOPOW48  ((FLOAT)(CONST_TWOPOW48))
#define FLOAT_TWOPOW49  ((FLOAT)(CONST_TWOPOW49))
#define FLOAT_TWOPOW50  ((FLOAT)(CONST_TWOPOW50))
#define FLOAT_TWOPOW51  ((FLOAT)(CONST_TWOPOW51))
#define FLOAT_TWOPOW52  ((FLOAT)(CONST_TWOPOW52))

// Values that are smaller than the named value by the smallest
// representable amount.  Since this depends on the type used
// there is no CONST form.
#define FLOAT_NEARTWOPOW31      ((FLOAT)2147483583)
#define FLOAT_NEARTWOPOW32      ((FLOAT)4294967167)

// Value close enough to zero to consider zero.  This can't be too small
// but it can't be too large.  In other words, it's picked by guessing.
#define FLOAT_NEARZERO          (1e-5f)

// General FP constants.
#define FLOAT_E                 ((FLOAT)2.7182818284590452354)

// Integer value of first exponent bit in a float.  Provides a scaling factor
// for exponent values extracted directly from float representation.
#define FLOAT_EXPSCALE          ((FLOAT)0x00800000)
    
// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

#ifdef _X86_

// All FP values are loaded from memory so declare them all as global
// variables.

extern FLOAT g_fE;
extern FLOAT g_fZero;
extern FLOAT g_fNearZero;
extern FLOAT g_fHalf;
extern FLOAT g_fp95;
extern FLOAT g_fOne;
extern FLOAT g_fOneMinusEps;
extern FLOAT g_fExpScale;
extern FLOAT g_fOoExpScale;
extern FLOAT g_f255oTwoPow15;
extern FLOAT g_fOo255;
extern FLOAT g_fOo256;
extern FLOAT g_fTwoPow7;
extern FLOAT g_fTwoPow8;
extern FLOAT g_fTwoPow11;
extern FLOAT g_fTwoPow15;
extern FLOAT g_fOoTwoPow15;
extern FLOAT g_fTwoPow16;
extern FLOAT g_fOoTwoPow16;
extern FLOAT g_fTwoPow20;
extern FLOAT g_fOoTwoPow20;
extern FLOAT g_fTwoPow27;
extern FLOAT g_fOoTwoPow27;
extern FLOAT g_fTwoPow30;
extern FLOAT g_fTwoPow31;
extern FLOAT g_fNearTwoPow31;
extern FLOAT g_fOoTwoPow31;
extern FLOAT g_fOoNearTwoPow31;
extern FLOAT g_fTwoPow32;
extern FLOAT g_fNearTwoPow32;
extern FLOAT g_fTwoPow39;
extern FLOAT g_fTwoPow47;

#else

// Leave FP values as constants.

#define g_fE                    FLOAT_E
#define g_fNearZero             FLOAT_NEARZERO
#define g_fZero                 (0.0f)
#define g_fHalf                 (0.5f)
#define g_fp95                  (0.95f)
#define g_fOne                  (1.0f)
#define g_fOneMinusEps          (1.0f - FLT_EPSILON)
#define g_fExpScale             FLOAT_EXPSCALE
#define g_fOoExpScale           ((FLOAT)(1.0 / (double)FLOAT_EXPSCALE))
#define g_f255oTwoPow15         ((FLOAT)(255.0 / (double)CONST_TWOPOW15))
#define g_fOo255                ((FLOAT)(1.0 / 255.0))
#define g_fOo256                ((FLOAT)(1.0 / 256.0))
#define g_fTwoPow7              FLOAT_TWOPOW7
#define g_fTwoPow8              FLOAT_TWOPOW8
#define g_fTwoPow11             FLOAT_TWOPOW11
#define g_fTwoPow15             FLOAT_TWOPOW15
#define g_fOoTwoPow15           ((FLOAT)(1.0 / (double)CONST_TWOPOW15))
#define g_fTwoPow16             FLOAT_TWOPOW16
#define g_fOoTwoPow16           ((FLOAT)(1.0 / (double)CONST_TWOPOW16))
#define g_fTwoPow20             FLOAT_TWOPOW20
#define g_fOoTwoPow20           ((FLOAT)(1.0 / (double)CONST_TWOPOW20))
#define g_fTwoPow27             FLOAT_TWOPOW27
#define g_fOoTwoPow27           ((FLOAT)(1.0 / (double)CONST_TWOPOW27))
#define g_fTwoPow30             FLOAT_TWOPOW30
#define g_fTwoPow31             FLOAT_TWOPOW31
#define g_fNearTwoPow31         FLOAT_NEARTWOPOW31
#define g_fOoTwoPow31           ((FLOAT)(1.0 / (double)CONST_TWOPOW31))
#define g_fOoNearTwoPow31       ((FLOAT)(1.0 / ((double)FLOAT_NEARTWOPOW31)))
#define g_fTwoPow32             FLOAT_TWOPOW32
#define g_fNearTwoPow32         FLOAT_NEARTWOPOW32
#define g_fTwoPow39             FLOAT_TWOPOW39
#define g_fTwoPow47             FLOAT_TWOPOW47

#endif // _X86_

//
// Conversion tables.
//

// Takes an unsigned byte to a float in [0.0, 1.0].  257'th entry is
// also one to allow overflow.
extern FLOAT g_fUInt8ToFloat[257];

// Floating-point pinning values for float-int conversion.
extern DOUBLE g_dSnap[33];

//
// x86 FP control for optimized FTOI and single-precision divides.
//

#ifdef _X86_

#define FPU_GET_MODE(uMode) \
    __asm fnstcw WORD PTR uMode
#define FPU_SET_MODE(uMode) \
    __asm fldcw WORD PTR uMode
#define FPU_SAFE_SET_MODE(uMode) \
    __asm fnclex \
    __asm fldcw WORD PTR uMode

#define FPU_MODE_CHOP_ROUND(uMode) \
    ((uMode) | 0xc00)
#define FPU_MODE_LOW_PRECISION(uMode) \
    ((uMode) & 0xfcff)
#define FPU_MODE_MASK_EXCEPTIONS(uMode) \
    ((uMode) | 0x3f)

#if DBG

#define ASSERT_CHOP_ROUND()         \
    {                               \
        WORD cw;                    \
        __asm fnstcw cw             \
        DDASSERT((cw & 0xc00) == 0xc00); \
    }

#else

#define ASSERT_CHOP_ROUND()

#endif // DBG

#else

// Initialize with zero to avoid use-before-set errors.
#define FPU_GET_MODE(uMode) \
    ((uMode) = 0)
#define FPU_SET_MODE(uMode)
#define FPU_SAFE_SET_MODE(uMode)

#define FPU_MODE_CHOP_ROUND(uMode) 0
#define FPU_MODE_LOW_PRECISION(uMode) 0
#define FPU_MODE_MASK_EXCEPTIONS(uMode) 0

#define ASSERT_CHOP_ROUND()

#endif // _X86_

//
// Single-precision FP functions.
// May produce invalid results for exceptional or denormal values.
// ATTENTION - Alpha exposes float math routines and they may be a small win.
//

#define COSF(fV)        ((FLOAT)cos((double)(fV)))
#define SINF(fV)        ((FLOAT)sin((double)(fV)))
#define SQRTF(fV)       ((FLOAT)sqrt((double)(fV)))
#define POWF(fV, fE)    ((FLOAT)pow((double)(fV), (double)(fE)))

// Approximate log and power functions using Jim Blinn's CG&A technique.
// Only work for positive values.

#ifdef POINTER_CASTING

__inline FLOAT
APPXLG2F(FLOAT f)
{
    return (FLOAT)(ASINT32(f) - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    INT32 i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    INT32 i = (INT32_FLOAT_ONE << 1) - ASINT32(f);
    return ASFLOAT(i);
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    INT32 i = (ASINT32(f) >> 1) + (INT32_FLOAT_ONE >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    INT32 i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (ASINT32(f) >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    INT32 i = (INT32)(exp * (ASINT32(f) - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

#else

__inline FLOAT
APPXLG2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (FLOAT)(fi.i - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return fi.f;
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32_FLOAT_ONE << 1) - fi.i;
    return fi.f;
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (fi.i >> 1) + (INT32_FLOAT_ONE >> 1);
    return fi.f;
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (fi.i >> 1);
    return fi.f;
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32)(exp * (fi.i - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return fi.f;
}

#endif

#ifdef _X86_

// Uses a table
float __fastcall TableInvSqrt(float value);
// Uses Jim Blinn's floating point trick
float __fastcall JBInvSqrt(float value);

#define ISQRTF(fV)      TableInvSqrt(fV);

#ifdef POINTER_CASTING

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    UINT32 i = ASUINT32(f) & 0x7fffffff;
    return ASFLOAT(i);
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    UINT32 i = ASUINT32(f) ^ 0x80000000;
    return ASFLOAT(i);
}

#else

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u &= 0x7fffffff;
    return fi.f;
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u ^= 0x80000000;
    return fi.f;
}

#endif // POINTER_CASTING

// Requires chop rounding.
__inline INT32
SCALED_FRACTION(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fmul g_fTwoPow31
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
__inline INT
FTOI(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
#define ICEILF(f)       (FLOAT_LEZ(f) ? FTOI(f) : FTOI((f) + g_fOneMinusEps))
#define CEILF(f)        ((FLOAT)ICEILF(f))
#define IFLOORF(f)      (FLOAT_LTZ(f) ? FTOI((f) - g_fOneMinusEps) : FTOI(f))
#define FLOORF(f)       ((FLOAT)IFLOORF(f))

#else // _X86_

#define ISQRTF(fV)              (1.0f / (FLOAT)sqrt((double)(fV)))
#define ABSF(f)                 ((FLOAT)fabs((double)(f)))
#define NEGF(f)                 (-(f))
#define SCALED_FRACTION(f)      ((INT32)((f) * g_fTwoPow31))
#define FTOI(f)                 ((INT)(f))
#define CEILF(f)                ((FLOAT)ceil((double)(f)))
#define ICEILF(f)               ((INT)CEILF(f))
#define FLOORF(f)               ((FLOAT)floor((double)(f)))
#define IFLOORF(f)              ((INT)FLOORF(f))

#endif // _X86_

//
// Overlapped divide support.
//

#ifdef _X86_

// Starts a divide directly from memory.  Result field is provided for
// compatibility with non-x86 code that does the divide immediately.
#define FLD_BEGIN_DIVIDE(Num, Den, Res) { __asm fld Num __asm fdiv Den }
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) { __asm fld Num __asm fidiv Den }
// Store a divide result directly to memory.
#define FSTP_END_DIVIDE(Res)            { __asm fstp Res }

#else // _X86_

#define FLD_BEGIN_DIVIDE(Num, Den, Res) ((Res) = (Num) / (Den))
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) ((Res) = (Num) / (FLOAT)(Den))
#define FSTP_END_DIVIDE(Res)

#endif // _X86_

//
// Specialized FP comparison functions.
//
// On the x86, it's faster to do compares with an integer cast
// than it is to do the fcom.
//
// The zero operations work for all normalized FP numbers, -0 included.
//

#ifdef _X86_

#define FLOAT_CMP_POS(fa, op, fb)       (ASINT32(fa) op ASINT32(fb))
#define FLOAT_CMP_PONE(flt, op)         (ASINT32(flt) op INT32_FLOAT_ONE)

#ifdef POINTER_CASTING

#define FLOAT_GTZ(flt)                  (ASINT32(flt) > 0)
#define FLOAT_LTZ(flt)                  (ASUINT32(flt) > 0x80000000)
#define FLOAT_GEZ(flt)                  (ASUINT32(flt) <= 0x80000000)
#define FLOAT_LEZ(flt)                  (ASINT32(flt) <= 0)
#define FLOAT_EQZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) == 0)
#define FLOAT_NEZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) != 0)

#else

__inline int FLOAT_GTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i > 0;
}
__inline int FLOAT_LTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u > 0x80000000;
}
__inline int FLOAT_GEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u <= 0x80000000;
}
__inline int FLOAT_LEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i <= 0;
}
__inline int FLOAT_EQZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) == 0;
}
__inline int FLOAT_NEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) != 0;
}

#endif // POINTER_CASTING

#else

#define FLOAT_GTZ(flt)                  ((flt) > g_fZero)
#define FLOAT_LTZ(flt)                  ((flt) < g_fZero)
#define FLOAT_GEZ(flt)                  ((flt) >= g_fZero)
#define FLOAT_LEZ(flt)                  ((flt) <= g_fZero)
#define FLOAT_EQZ(flt)                  ((flt) == g_fZero)
#define FLOAT_NEZ(flt)                  ((flt) != g_fZero)
#define FLOAT_CMP_POS(fa, op, fb)       ((fa) op (fb))
#define FLOAT_CMP_PONE(flt, op)         ((flt) op g_fOne)

#endif // _X86_

#ifdef __cplusplus
}
#endif
    
#endif // #ifndef _D3DFLT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\texdiff.inc ===
;----------------------------------------------------------------------------
;
; texdiff.inc
;
; Assembly macro for TextureDiff.
;
; Copyright (C) Microsoft Corporation, 1997.
;
;----------------------------------------------------------------------------

IFNDEF __TEXDIFF_INC__
__TEXDIFF_INC__ EQU 1

;----------------------------------------------------------------------------
;
; TEXTURE_DIFF
;
; Computes difference of two texture coordinates and returns it on
; the top of the FP stack.
;
; Destroys eax and ecx.
;
;----------------------------------------------------------------------------
        
TEXTURE_DIFF MACRO fTb, fTa, iMode, fTmp
        LOCAL L_Exit, L_Ltz, L_Gtz, L_Zero, L_Straight

        ; Start initial fTb - fTa computation.
        fld fTb
        fsub fTa

        ; Check for wrapping.
        cmp iMode, 0
        jz L_Exit

        ; Compute smaller of straight or wrapped difference.
        fst fTmp
        fld st(0)

        ; Adjust straight difference according to sign to compute
        ; wrapped difference.
        mov eax, fTmp
        cmp eax, 080000000h
        ja L_Ltz
        cmp eax, 0
        je L_Zero

        ; Gtz
        fsub _g_fOne
        jmp L_Gtz
        
L_Ltz:
        fadd _g_fOne

L_Zero:
        and eax, 07fffffffh
L_Gtz:
        fst fTmp
        mov ecx, fTmp
        and ecx, 07fffffffh

        ; Pick smaller based on absolute values of differences.
        cmp eax, ecx
        jle L_Straight

        ; Discard straight difference so wrapped difference is
        ; returned.
        fxch st(1)

L_Straight:
        ; Discard wrapped difference so straight difference is
        ; returned.
        fstp st(0)
        
L_Exit:
        ENDM
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\_memalloc.c ===
#include "stdlib.h"
#define __DXGUSEALLOC 1
#include "..\..\..\misc\memalloc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\d3dvec.inl ===
/****************************************************************** 
 *                                                                *
 *   D3DVec.inl                                                   *
 *                                                                *
 *   Float-valued 3D vector class for Direct3D.                   *
 *                                                                *
 *   Copyright (c) 1996-1998 Microsoft Corp. All rights reserved. *
 *                                                                *
 ******************************************************************/

#include <math.h>

// =====================================
// Constructors
// =====================================

inline
_D3DVECTOR::_D3DVECTOR(D3DVALUE f)
{
    x = y = z = f;
}

inline
_D3DVECTOR::_D3DVECTOR(D3DVALUE _x, D3DVALUE _y, D3DVALUE _z)
{
    x = _x; y = _y; z = _z;
}

inline
_D3DVECTOR::_D3DVECTOR(const D3DVALUE f[3])
{
    x = f[0]; y = f[1]; z = f[2];
}

// =====================================
// Access grants
// =====================================

inline const D3DVALUE&
_D3DVECTOR::operator[](int i) const
{
    return (&x)[i];
}

inline D3DVALUE&
_D3DVECTOR::operator[](int i)
{
    return (&x)[i];
}


// =====================================
// Assignment operators
// =====================================

inline _D3DVECTOR&
_D3DVECTOR::operator += (const _D3DVECTOR& v)
{
   x += v.x;   y += v.y;   z += v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator -= (const _D3DVECTOR& v)
{
   x -= v.x;   y -= v.y;   z -= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator *= (const _D3DVECTOR& v)
{
   x *= v.x;   y *= v.y;   z *= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator /= (const _D3DVECTOR& v)
{
   x /= v.x;   y /= v.y;   z /= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator *= (D3DVALUE s)
{
   x *= s;   y *= s;   z *= s;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator /= (D3DVALUE s)
{
   x /= s;   y /= s;   z /= s;
   return *this;
}

inline _D3DVECTOR
operator + (const _D3DVECTOR& v)
{
   return v;
}

inline _D3DVECTOR
operator - (const _D3DVECTOR& v)
{
   return _D3DVECTOR(-v.x, -v.y, -v.z);
}

inline _D3DVECTOR
operator + (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z);
}

inline _D3DVECTOR
operator - (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z);
}

inline _D3DVECTOR
operator * (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x*v2.x, v1.y*v2.y, v1.z*v2.z);
}

inline _D3DVECTOR
operator / (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x/v2.x, v1.y/v2.y, v1.z/v2.z);
}

inline int
operator < (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1[0] < v2[0] && v1[1] < v2[1] && v1[2] < v2[2];
}

inline int
operator <= (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1[0] <= v2[0] && v1[1] <= v2[1] && v1[2] <= v2[2];
}

inline _D3DVECTOR
operator * (const _D3DVECTOR& v, D3DVALUE s)
{
   return _D3DVECTOR(s*v.x, s*v.y, s*v.z);
}

inline _D3DVECTOR
operator * (D3DVALUE s, const _D3DVECTOR& v)
{
   return _D3DVECTOR(s*v.x, s*v.y, s*v.z);
}

inline _D3DVECTOR
operator / (const _D3DVECTOR& v, D3DVALUE s)
{
   return _D3DVECTOR(v.x/s, v.y/s, v.z/s);
}

inline int
operator == (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1.x==v2.x && v1.y==v2.y && v1.z == v2.z;
}

inline D3DVALUE
Magnitude (const _D3DVECTOR& v)
{
   return (D3DVALUE) sqrt(SquareMagnitude(v));
}

inline D3DVALUE
SquareMagnitude (const _D3DVECTOR& v)
{
   return v.x*v.x + v.y*v.y + v.z*v.z;
}

inline _D3DVECTOR
Normalize (const _D3DVECTOR& v)
{
   return v / Magnitude(v);
}

inline D3DVALUE
Min (const _D3DVECTOR& v)
{
   D3DVALUE ret = v.x;
   if (v.y < ret) ret = v.y;
   if (v.z < ret) ret = v.z;
   return ret;
}

inline D3DVALUE
Max (const _D3DVECTOR& v)
{
   D3DVALUE ret = v.x;
   if (ret < v.y) ret = v.y;
   if (ret < v.z) ret = v.z;
   return ret;
}

inline _D3DVECTOR
Minimize (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR( v1[0] < v2[0] ? v1[0] : v2[0],
                   v1[1] < v2[1] ? v1[1] : v2[1],
                   v1[2] < v2[2] ? v1[2] : v2[2]);
}

inline _D3DVECTOR
Maximize (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR( v1[0] > v2[0] ? v1[0] : v2[0],
                   v1[1] > v2[1] ? v1[1] : v2[1],
                   v1[2] > v2[2] ? v1[2] : v2[2]);
}

inline D3DVALUE
DotProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1.x*v2.x + v1.y * v2.y + v1.z*v2.z;
}

inline _D3DVECTOR
CrossProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
	_D3DVECTOR result;

	result[0] = v1[1] * v2[2] - v1[2] * v2[1];
	result[1] = v1[2] * v2[0] - v1[0] * v2[2];
	result[2] = v1[0] * v2[1] - v1[1] * v2[0];

	return result;
}

inline _D3DMATRIX
operator* (const _D3DMATRIX& a, const _D3DMATRIX& b)
{
    _D3DMATRIX ret;
    for (int i=0; i<4; i++) {
        for (int j=0; j<4; j++) {
            ret(i, j) = 0.0f;
            for (int k=0; k<4; k++) {
                ret(i, j) += a(i, k) * b(k, j);
            }
        }
    }
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\texdiff.h ===
//----------------------------------------------------------------------------
//
// texdiff.h
//
// TextureDiff base code for inclusion as an inline function or
// regular function from common code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// TextureDiff
//
// Computes the difference between two texture coordinates according
// to the given texture wrap mode.
//
//----------------------------------------------------------------------------

{
    FLOAT fDiff1 = fTb - fTa;

    if (iMode == 0)
    {
        // Wrap not set, return plain difference.
        return fDiff1;
    }
    else
    {
        FLOAT fDiff2;

        // Wrap set, compute shortest distance of plain difference
        // and wrap difference.

        fDiff2 = fDiff1;
        if (FLOAT_LTZ(fDiff1))
        {
            fDiff2 += g_fOne;
        }
        else if (FLOAT_GTZ(fDiff1))
        {
            fDiff2 -= g_fOne;
        }
        if (ABSF(fDiff1) < ABSF(fDiff2))
        {
            return fDiff1;
        }
        else
        {
            return fDiff2;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\commdrv.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       commdrv.h
 *  Content:    Common driver structures
 *
 ***************************************************************************/

#ifndef _COMMDRV_H_
#define _COMMDRV_H_

#include "haldrv.hpp"

extern int      GenGetExtraVerticesNumber( LPDIRECT3DDEVICEI lpDevI );
extern LPD3DTLVERTEX    GenGetExtraVerticesPointer( LPDIRECT3DDEVICEI lpDevI );
extern HRESULT DrawPrim(LPDIRECT3DDEVICEI);
extern HRESULT DrawIndexPrim(LPDIRECT3DDEVICEI);
extern HRESULT DrawPrimLegacy(LPDIRECT3DDEVICEI);
extern HRESULT DrawIndexPrimLegacy(LPDIRECT3DDEVICEI);
extern HRESULT DrawPrimCB(LPDIRECT3DDEVICEI);
extern HRESULT DrawIndexPrimCB(LPDIRECT3DDEVICEI);
//---------------------------------------------------------------------
// This class builds a DDRAWSURFACE around memory bits
//
class CDDSurfaceFromMem
{
public:
    CDDSurfaceFromMem(LPVOID lpvMemory)
        {
            gblTL.fpVidMem = (ULONG_PTR)lpvMemory;
            lclTL.lpGbl = &gblTL;
            exeTL.lpLcl = &lclTL;
        }
    ~CDDSurfaceFromMem() {};
    LPDIRECTDRAWSURFACE GetSurface() {return (LPDIRECTDRAWSURFACE) &exeTL;}
    void SetBits(LPVOID lpvMemory)   {gblTL.fpVidMem = (ULONG_PTR)lpvMemory;}
protected:
    DDRAWI_DDRAWSURFACE_INT exeTL;
    DDRAWI_DDRAWSURFACE_LCL lclTL;
    DDRAWI_DDRAWSURFACE_GBL gblTL;
};
#endif /* _COMMDRV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\i386\math.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: math.asm
;
; Fast math routines.
;
; Created: 11/1/1996
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .list

; float __fastcall TableInvSqrt(float value);
;
; void  __fastcall TableVecNormalize(float *resultNormal, floar *normal);
;
;           resultNormal and normal could have the same address
;

;
;
; We're trying to solve:
;
;	1/sqrt(x)
;	
; which in IEEE float is:
;
;	1/sqrt(M * 2^[E-127])
;
;	To simplify, substitute e = [E-127]
;
; We can simplify this by pulling a large portion of the exponent out
; by using only that portion of the exponent divisible by two (so we can
; pull it out of the sqrt term):
;
;	1/sqrt(M * 2^(2*[e div 2]) * 2^[e MOD 2])
;	
; which is:
;	
;	1/ (2^[e div 2] * sqrt(M * 2^[e MOD 2]))
;
; or
;
;	(2^[e div 2])^(-1) * 1/sqrt(M * 2^[e MOD 2])
;
; =
;	2^-[e div 2] * 1/sqrt(M * 2^[e MOD 2])
;
; substitute back for e = [E-127]:
;
;	2^-[(E - 127) div 2] * 1/sqrt(M * 2^[(E - 127) MOD 2])
;
; =
;	2^-[(E div 2) - 63] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; =
;	2^[63 - (E div 2)] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; As a floating-point number, 2^[63 - (E div 2)] is just the exponent value:
;
;	[63 - (E div 2)] + 127
;
; or
;	[(127+63) - (E div 2)]
;
; Remembering to account for the implicit '1' im the mantissa of IEEE floating-
; point numbers, the range of (M * 2^[(E - 1) MOD 2]) is 0.800000 to
; 0.ffffff*2, which is the interval [0.5, 2.0).  We can use the fact that this
; is a relatively small range, and therefore can use a table lookup near the
; actual value.  The table will contain values for the piece-wise approximation
; to the curve 1/sqrt(M * 2^[(E - 1) MOD 2]) using an acceptable interval.
; These values can then be used to approximate the desired inverse square root 
; value.  At this point, all that remains is to apply the correct exponent 
; for the number, which is simply [(127+63) - (E div 2)] from the above 
; equations.
;
; To do the piecewise-linear approximation, we can store a table of values at
; the appropriate intervals, and the deltas between them.  However, this
; will require calculating the difference between the interval value and
; x.  We can do a bit better by using slope-intercept (y = mx + b)m so the
; table will store (m, b).
;
; With a 512-entry table, we will get at least 16 bits of precision.  This
; result was obtined using simulations.

.data

; The following 'C' code generates the table below:

;#define SQRT_TAB_SIZE_LOG2	9       // 512-entry table
;
;#define MANTISSA_SIZE          24
;#define SQRT_TAB_SIZE          (1 << SQRT_TAB_SIZE_LOG2)
;#define SQRT_INC               (1 << (MANTISSA_SIZE - SQRT_TAB_SIZE_LOG2))
;#define CASTFIX(a)             (*((LONG *)&(a)))
;
;void genTable()
;{
;    int i;
;    float x;
;    float xNext;
;    float y;
;    float yNext;
;    float xInterval;
;
;    // We will start our table with the case where the exponent is even.
;
;    CASTFIX(x) = 0x3f000000;
;
;    // We will use the current and next values to generate the piece-wise
;    // data for the curve.  The interval between 'current' and 'next' is
;    // based on the smallest change possible in the floating-point value
;    // that also represents a difference of one table-lookup entry.
;
;    // When we switch to the odd-exponent case (at 1.0), we have to adjust
;    // for the fact that effective interval between successive values
;    /  is doubled.
;
;    CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;    y = (float)1.0 / sqrt((double)x);
;
;    // Calculate 1.0 / (piece-wise approximation interval).
;
;    xInterval = xNext - x;
;
;    xInterval = (float)1.0 / xInterval;
;
;    // Now, generate the table:
;
;    for (i = 0; i < SQRT_TAB_SIZE; i++) {
;        float m;
;        float b;
;
;        // We increment our floating-point values using integer operations
;        // to ensure accuracy:
;
;        CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;
;        // Find next point on curve:
;
;        yNext = (float)1.0 / sqrt((double)xNext);
;
;        // Test for odd-exponent case:
;
;        if (CASTFIX(x) == 0x3f800000)
;            xInterval *= (float)0.5;
;
;        m = (yNext - y) * xInterval;
;        b = y - (m * x);
;
;        printf("\t\tdd\t0%8xh, 0%8xh\n", CASTFIX(m), CASTFIX(b));
;
;        y = yNext;
;        x = xNext;
;    }
;}


invSqrtTab	dd	0bfb47e00h, 04007a1fah
		dd	0bfb37000h, 040075e36h
		dd	0bfb26600h, 040071b31h
		dd	0bfb16000h, 04006d8ech
		dd	0bfb05800h, 0400695e4h
		dd	0bfaf5800h, 0400654a4h
		dd	0bfae5600h, 0400612a2h
		dd	0bfad5800h, 04005d165h
		dd	0bfac5e00h, 0400590f1h
		dd	0bfab6400h, 04005503eh
		dd	0bfaa6e00h, 040051058h
		dd	0bfa97800h, 04004d033h
		dd	0bfa88800h, 040049163h
		dd	0bfa79600h, 0400451d0h
		dd	0bfa6aa00h, 040041396h
		dd	0bfa5be00h, 04003d522h
		dd	0bfa4d400h, 0400396fah
		dd	0bfa3ee00h, 0400359a8h
		dd	0bfa30800h, 040031c1dh
		dd	0bfa22400h, 04002dee2h
		dd	0bfa14400h, 04002a282h
		dd	0bfa06600h, 040026674h
		dd	0bf9f8800h, 040022a30h
		dd	0bf9eae00h, 04001eecah
		dd	0bf9dd400h, 04001b32eh
		dd	0bf9cfc00h, 0400177e8h
		dd	0bf9c2800h, 040013d86h
		dd	0bf9b5400h, 0400102efh
		dd	0bf9a8400h, 04000c93fh
		dd	0bf99b400h, 040008f5bh
		dd	0bf98e600h, 0400055d2h
		dd	0bf981800h, 040001c16h
		dd	0bf975000h, 03fffc7abh
		dd	0bf968600h, 03fff55a6h
		dd	0bf95c000h, 03ffee580h
		dd	0bf94fc00h, 03ffe761ah
		dd	0bf943800h, 03ffe0652h
		dd	0bf937400h, 03ffd9628h
		dd	0bf92b600h, 03ffd290eh
		dd	0bf91f800h, 03ffcbb95h
		dd	0bf913a00h, 03ffc4dbdh
		dd	0bf907e00h, 03ffbe0afh
		dd	0bf8fc600h, 03ffb7597h
		dd	0bf8f0c00h, 03ffb08f8h
		dd	0bf8e5800h, 03ffa9f80h
		dd	0bf8da000h, 03ffa3354h
		dd	0bf8cee00h, 03ff9ca56h
		dd	0bf8c3c00h, 03ff960ffh
		dd	0bf8b8a00h, 03ff8f74fh
		dd	0bf8adc00h, 03ff88fa8h
		dd	0bf8a2e00h, 03ff827aah
		dd	0bf898000h, 03ff7bf55h
		dd	0bf88d600h, 03ff75911h
		dd	0bf882e00h, 03ff6f3adh
		dd	0bf878400h, 03ff68cbfh
		dd	0bf86de00h, 03ff627eah
		dd	0bf863600h, 03ff5c18ah
		dd	0bf859400h, 03ff55e81h
		dd	0bf84f000h, 03ff4f9edh
		dd	0bf845000h, 03ff4977dh
		dd	0bf83ae00h, 03ff43381h
		dd	0bf831000h, 03ff3d1aeh
		dd	0bf827200h, 03ff36f8ch
		dd	0bf81d400h, 03ff30d1bh
		dd	0bf813a00h, 03ff2acdbh
		dd	0bf809e00h, 03ff24b0dh
		dd	0bf800600h, 03ff1eb75h
		dd	0bf7edc00h, 03ff18b91h
		dd	0bf7db000h, 03ff12ca5h
		dd	0bf7c8400h, 03ff0cd6eh
		dd	0bf7b5c00h, 03ff06f32h
		dd	0bf7a3400h, 03ff010ach
		dd	0bf791000h, 03fefb324h
		dd	0bf77f000h, 03fef569ch
		dd	0bf76d000h, 03feef9cch
		dd	0bf75b000h, 03fee9cb4h
		dd	0bf749400h, 03fee40a0h
		dd	0bf737c00h, 03fede592h
		dd	0bf726800h, 03fed8b8ch
		dd	0bf714c00h, 03fed2ea3h
		dd	0bf704000h, 03fecd6b3h
		dd	0bf6f2800h, 03fec7a8dh
		dd	0bf6e1c00h, 03fec2217h
		dd	0bf6d1000h, 03febc95eh
		dd	0bf6c0400h, 03feb7062h
		dd	0bf6afc00h, 03feb1878h
		dd	0bf69f400h, 03feac04ch
		dd	0bf68ec00h, 03fea67deh
		dd	0bf67ec00h, 03fea11deh
		dd	0bf66e800h, 03fe9ba45h
		dd	0bf65e800h, 03fe963c5h
		dd	0bf64ec00h, 03fe90e60h
		dd	0bf63f000h, 03fe8b8bch
		dd	0bf62f400h, 03fe862d9h
		dd	0bf620000h, 03fe80f73h
		dd	0bf610400h, 03fe7b912h
		dd	0bf601000h, 03fe76532h
		dd	0bf5f2000h, 03fe71276h
		dd	0bf5e2c00h, 03fe6be1ch
		dd	0bf5d3c00h, 03fe66ae8h
		dd	0bf5c5000h, 03fe618dch
		dd	0bf5b6000h, 03fe5c530h
		dd	0bf5a7800h, 03fe57414h
		dd	0bf598c00h, 03fe52157h
		dd	0bf58a800h, 03fe4d12fh
		dd	0bf57c000h, 03fe47f65h
		dd	0bf56dc00h, 03fe42ecbh
		dd	0bf55f800h, 03fe3ddf8h
		dd	0bf551800h, 03fe38e58h
		dd	0bf543800h, 03fe33e80h
		dd	0bf535c00h, 03fe2efdeh
		dd	0bf527c00h, 03fe29f96h
		dd	0bf51a000h, 03fe25086h
		dd	0bf50c800h, 03fe202b0h
		dd	0bf4ff000h, 03fe1b4a4h
		dd	0bf4f1c00h, 03fe167d5h
		dd	0bf4e4400h, 03fe1195dh
		dd	0bf4d7000h, 03fe0cc24h
		dd	0bf4c9c00h, 03fe07eb6h
		dd	0bf4bcc00h, 03fe0328ah
		dd	0bf4afc00h, 03fdfe62ah
		dd	0bf4a3000h, 03fdf9b0fh
		dd	0bf496000h, 03fdf4e47h
		dd	0bf489800h, 03fdf0441h
		dd	0bf47c800h, 03fdeb711h
		dd	0bf470400h, 03fde6e24h
		dd	0bf463c00h, 03fde2388h
		dd	0bf457400h, 03fddd8bah
		dd	0bf44b000h, 03fdd8f3ah
		dd	0bf43ec00h, 03fdd4589h
		dd	0bf432800h, 03fdcfba7h
		dd	0bf426800h, 03fdcb317h
		dd	0bf41a800h, 03fdc6a57h
		dd	0bf40e800h, 03fdc2167h
		dd	0bf402c00h, 03fdbd9cdh
		dd	0bf3f6c00h, 03fdb907dh
		dd	0bf3eb400h, 03fdb4a0dh
		dd	0bf3dfc00h, 03fdb036fh
		dd	0bf3d4000h, 03fdabb19h
		dd	0bf3c8800h, 03fda741fh
		dd	0bf3bd400h, 03fda2e83h
		dd	0bf3b2000h, 03fd9e8bah
		dd	0bf3a6800h, 03fd9a136h
		dd	0bf39b400h, 03fd95b13h
		dd	0bf390800h, 03fd917e3h
		dd	0bf385000h, 03fd8cfd5h
		dd	0bf37a400h, 03fd88c4fh
		dd	0bf36f800h, 03fd8489eh
		dd	0bf364400h, 03fd8019ah
		dd	0bf359c00h, 03fd7bf28h
		dd	0bf34f000h, 03fd77af6h
		dd	0bf344400h, 03fd73699h
		dd	0bf339c00h, 03fd6f3a9h
		dd	0bf32f400h, 03fd6b08fh
		dd	0bf324c00h, 03fd66d4bh
		dd	0bf31a800h, 03fd62b78h
		dd	0bf310000h, 03fd5e7e0h
		dd	0bf305c00h, 03fd5a5bbh
		dd	0bf2fb800h, 03fd5636dh
		dd	0bf2f1800h, 03fd52295h
		dd	0bf2e7400h, 03fd4dff5h
		dd	0bf2dd800h, 03fd4a06eh
		dd	0bf2d3400h, 03fd45d7ch
		dd	0bf2c9800h, 03fd41da7h
		dd	0bf2bf800h, 03fd3dc07h
		dd	0bf2b6000h, 03fd39d89h
		dd	0bf2ac000h, 03fd35b99h
		dd	0bf2a2800h, 03fd31ccfh
		dd	0bf298c00h, 03fd2dc37h
		dd	0bf28f400h, 03fd29d21h
		dd	0bf285c00h, 03fd25de5h
		dd	0bf27c400h, 03fd21e83h
		dd	0bf273000h, 03fd1e0a7h
		dd	0bf269800h, 03fd1a0f9h
		dd	0bf260400h, 03fd162d3h
		dd	0bf257000h, 03fd12488h
		dd	0bf24e000h, 03fd0e7c8h
		dd	0bf244c00h, 03fd0a933h
		dd	0bf23bc00h, 03fd06c2bh
		dd	0bf232800h, 03fd02d4ch
		dd	0bf229c00h, 03fcff1b0h
		dd	0bf220c00h, 03fcfb43ch
		dd	0bf218000h, 03fcf785ah
		dd	0bf20f400h, 03fcf3c55h
		dd	0bf206400h, 03fcefe75h
		dd	0bf1fdc00h, 03fcec3e3h
		dd	0bf1f4c00h, 03fce85bbh
		dd	0bf1ec800h, 03fce4ca0h
		dd	0bf1e3c00h, 03fce0fech
		dd	0bf1db400h, 03fcdd4d2h
		dd	0bf1d2c00h, 03fcd9996h
		dd	0bf1ca800h, 03fcd5ff7h
		dd	0bf1c2000h, 03fcd2477h
		dd	0bf1b9800h, 03fcce8d5h
		dd	0bf1b1800h, 03fccb095h
		dd	0bf1a9400h, 03fcc7672h
		dd	0bf1a0c00h, 03fcc3a6ah
		dd	0bf199000h, 03fcc038fh
		dd	0bf190800h, 03fcbc743h
		dd	0bf188c00h, 03fcb902ah
		dd	0bf180800h, 03fcb5562h
		dd	0bf178c00h, 03fcb1e0bh
		dd	0bf170c00h, 03fcae4cbh
		dd	0bf168c00h, 03fcaab6bh
		dd	0bf161000h, 03fca73b7h
		dd	0bf159400h, 03fca3be4h
		dd	0bf151800h, 03fca03f2h
		dd	0bf149800h, 03fc9ca12h
		dd	0bf142400h, 03fc99582h
		dd	0bf13a400h, 03fc95b62h
		dd	0bf133000h, 03fc92698h
		dd	0bf12b400h, 03fc8ee0bh
		dd	0bf123c00h, 03fc8b733h
		dd	0bf11c400h, 03fc8803dh
		dd	0bf114c00h, 03fc84929h
		dd	0bf10d800h, 03fc813ceh
		dd	0bf106400h, 03fc7de56h
		dd	0bf0fec00h, 03fc7a6e8h
		dd	0bf0f7800h, 03fc77136h
		dd	0bf0f0400h, 03fc73b67h
		dd	0bf0e9000h, 03fc7057bh
		dd	0bf0e2000h, 03fc6d14fh
		dd	0bf0dac00h, 03fc69b29h
		dd	0bf0d3c00h, 03fc666c5h
		dd	0bf0ccc00h, 03fc63245h
		dd	0bf0c5800h, 03fc5fbc8h
		dd	0bf0bec00h, 03fc5c8f2h
		dd	0bf0b7c00h, 03fc5941eh
		dd	0bf0b0c00h, 03fc55f2eh
		dd	0bf0aa000h, 03fc52c07h
		dd	0bf0a3000h, 03fc4f6dfh
		dd	0bf09c400h, 03fc4c382h
		dd	0bf095c00h, 03fc491f2h
		dd	0bf08ec00h, 03fc45c76h
		dd	0bf088000h, 03fc428c8h
		dd	0bf081800h, 03fc3f6eah
		dd	0bf07b000h, 03fc3c4f2h
		dd	0bf074000h, 03fc38f06h
		dd	0bf06dc00h, 03fc35ec8h
		dd	0bf067400h, 03fc32c82h
		dd	0bf060800h, 03fc2f832h
		dd	0bf05a400h, 03fc2c7a9h
		dd	0bf053c00h, 03fc29515h
		dd	0bf04d800h, 03fc2645ah
		dd	0bf047000h, 03fc23192h
		dd	0bf040800h, 03fc1feb0h
		dd	0bf03a800h, 03fc1cfa0h
		dd	0bf034000h, 03fc19c8ah
		dd	0bf02dc00h, 03fc16b52h
		dd	0bf027c00h, 03fc13bfah
		dd	0bf021800h, 03fc10a90h
		dd	0bf01b400h, 03fc0d90dh
		dd	0bf015000h, 03fc0a771h
		dd	0bf00f400h, 03fc079b6h
		dd	0bf009000h, 03fc047e8h
		dd	0bf003000h, 03fc01800h
		dd	0beff4000h, 03fbfd000h
		dd	0befdc400h, 03fbf70a1h
		dd	0befc4c00h, 03fbf11e5h
		dd	0befad800h, 03fbeb3ceh
		dd	0bef96400h, 03fbe555ah
		dd	0bef7f800h, 03fbdf893h
		dd	0bef68e00h, 03fbd9bf4h
		dd	0bef52600h, 03fbd3f7eh
		dd	0bef3c200h, 03fbce3b6h
		dd	0bef26200h, 03fbc889eh
		dd	0bef10600h, 03fbc2e38h
		dd	0beefac00h, 03fbbd400h
		dd	0beee5400h, 03fbb79f8h
		dd	0beed0200h, 03fbb212eh
		dd	0beebb200h, 03fbac896h
		dd	0beea6600h, 03fba70b9h
		dd	0bee91a00h, 03fba1889h
		dd	0bee7d400h, 03fb9c1a0h
		dd	0bee69000h, 03fb96aeeh
		dd	0bee54e00h, 03fb91474h
		dd	0bee41200h, 03fb8bf48h
		dd	0bee2d400h, 03fb86942h
		dd	0bee19e00h, 03fb8151ah
		dd	0bee06600h, 03fb7c018h
		dd	0bedf3400h, 03fb76c6ch
		dd	0bede0400h, 03fb71900h
		dd	0bedcd600h, 03fb6c5d4h
		dd	0bedbac00h, 03fb67379h
		dd	0beda8400h, 03fb62161h
		dd	0bed95e00h, 03fb5cf8eh
		dd	0bed83a00h, 03fb57e00h
		dd	0bed71a00h, 03fb52d48h
		dd	0bed5fc00h, 03fb4dcd8h
		dd	0bed4e000h, 03fb48cb0h
		dd	0bed3c800h, 03fb43d64h
		dd	0bed2b000h, 03fb3edd2h
		dd	0bed19c00h, 03fb39f1eh
		dd	0bed08a00h, 03fb350b8h
		dd	0becf7c00h, 03fb30333h
		dd	0bece6c00h, 03fb2b4d7h
		dd	0becd6200h, 03fb267f3h
		dd	0becc5a00h, 03fb21b61h
		dd	0becb5200h, 03fb1ce8dh
		dd	0beca4e00h, 03fb182a2h
		dd	0bec94c00h, 03fb1370ch
		dd	0bec84a00h, 03fb0eb36h
		dd	0bec74e00h, 03fb0a0e4h
		dd	0bec65200h, 03fb05652h
		dd	0bec55800h, 03fb00c1ah
		dd	0bec45e00h, 03fafc1a4h
		dd	0bec36a00h, 03faf78bah
		dd	0bec27600h, 03faf2f93h
		dd	0bec18400h, 03faee6c9h
		dd	0bec09600h, 03fae9ef8h
		dd	0bebfa600h, 03fae5650h
		dd	0bebeba00h, 03fae0ea2h
		dd	0bebdd000h, 03fadc756h
		dd	0bebce800h, 03fad806ch
		dd	0bebc0000h, 03fad3948h
		dd	0bebb1e00h, 03facf3c3h
		dd	0beba3a00h, 03facad67h
		dd	0beb95800h, 03fac6770h
		dd	0beb87a00h, 03fac2280h
		dd	0beb79c00h, 03fabdd57h
		dd	0beb6c000h, 03fab9897h
		dd	0beb5e600h, 03fab5440h
		dd	0beb50e00h, 03fab1054h
		dd	0beb43600h, 03faacc32h
		dd	0beb36200h, 03faa891eh
		dd	0beb28e00h, 03faa45d6h
		dd	0beb1bc00h, 03faa02fah
		dd	0beb0ec00h, 03fa9c08eh
		dd	0beb01e00h, 03fa97e92h
		dd	0beaf5000h, 03fa93c63h
		dd	0beae8600h, 03fa8fb4ah
		dd	0beadba00h, 03fa8b959h
		dd	0beacf400h, 03fa87927h
		dd	0beac2a00h, 03fa83776h
		dd	0beab6600h, 03fa7f788h
		dd	0beaaa200h, 03fa7b76ah
		dd	0bea9e000h, 03fa777c2h
		dd	0bea91e00h, 03fa737e9h
		dd	0bea85e00h, 03fa6f889h
		dd	0bea7a000h, 03fa6b9a2h
		dd	0bea6e400h, 03fa67b36h
		dd	0bea62800h, 03fa63c9ch
		dd	0bea56e00h, 03fa5fe7ch
		dd	0bea4b400h, 03fa5c02fh
		dd	0bea3fe00h, 03fa5830bh
		dd	0bea34600h, 03fa5450dh
		dd	0bea29400h, 03fa508e8h
		dd	0bea1de00h, 03fa4cb3ch
		dd	0bea12c00h, 03fa48ebeh
		dd	0bea07c00h, 03fa452c2h
		dd	0be9fcc00h, 03fa4169ah
		dd	0be9f1e00h, 03fa3daf5h
		dd	0be9e7000h, 03fa39f25h
		dd	0be9dc400h, 03fa363dah
		dd	0be9d1a00h, 03fa32915h
		dd	0be9c7000h, 03fa2ee26h
		dd	0be9bc800h, 03fa2b3beh
		dd	0be9b2000h, 03fa2792ch
		dd	0be9a7a00h, 03fa23f22h
		dd	0be99d600h, 03fa205a4h
		dd	0be993200h, 03fa1cbfch
		dd	0be989000h, 03fa192dfh
		dd	0be97ec00h, 03fa158e5h
		dd	0be974e00h, 03fa120e2h
		dd	0be96ae00h, 03fa0e802h
		dd	0be961000h, 03fa0afb1h
		dd	0be957200h, 03fa07738h
		dd	0be94d800h, 03fa04006h
		dd	0be943a00h, 03fa0073eh
		dd	0be93a200h, 03f9fd078h
		dd	0be930a00h, 03f9f998ch
		dd	0be927000h, 03f9f61c1h
		dd	0be91da00h, 03f9f2b43h
		dd	0be914400h, 03f9ef4a0h
		dd	0be90b000h, 03f9ebe92h
		dd	0be901a00h, 03f9e87a3h
		dd	0be8f8a00h, 03f9e52c3h
		dd	0be8ef600h, 03f9e1c46h
		dd	0be8e6600h, 03f9de71eh
		dd	0be8dd600h, 03f9db1d2h
		dd	0be8d4600h, 03f9d7c62h
		dd	0be8cb800h, 03f9d478ch
		dd	0be8c2c00h, 03f9d1352h
		dd	0be8b9e00h, 03f9cde36h
		dd	0be8b1400h, 03f9caa76h
		dd	0be8a8a00h, 03f9c7694h
		dd	0be8a0000h, 03f9c428eh
		dd	0be897600h, 03f9c0e67h
		dd	0be88f000h, 03f9bdba1h
		dd	0be886800h, 03f9ba7f7h
		dd	0be87e200h, 03f9b74eeh
		dd	0be875e00h, 03f9b4287h
		dd	0be86d800h, 03f9b0f3bh
		dd	0be865600h, 03f9add56h
		dd	0be85d200h, 03f9aaa8ch
		dd	0be855200h, 03f9a792ch
		dd	0be84d000h, 03f9a46e6h
		dd	0be844e00h, 03f9a1480h
		dd	0be83d000h, 03f99e387h
		dd	0be835200h, 03f99b26eh
		dd	0be82d400h, 03f998136h
		dd	0be825600h, 03f994fdfh
		dd	0be81da00h, 03f991f31h
		dd	0be816000h, 03f98ef2eh
		dd	0be80e400h, 03f98be42h
		dd	0be806a00h, 03f988e01h
		dd	0be7fe000h, 03f985da2h
		dd	0be7ef400h, 03f982ebch
		dd	0be7e0000h, 03f97fe20h
		dd	0be7d1400h, 03f97cefeh
		dd	0be7c2400h, 03f979ef2h
		dd	0be7b3c00h, 03f977063h
		dd	0be7a5400h, 03f9741b7h
		dd	0be796800h, 03f971220h
		dd	0be788400h, 03f96e408h
		dd	0be779c00h, 03f96b506h
		dd	0be76b800h, 03f9686b6h
		dd	0be75d800h, 03f96591ah
		dd	0be74f400h, 03f962a90h
		dd	0be741400h, 03f95fcbch
		dd	0be733400h, 03f95cecch
		dd	0be725800h, 03f95a193h
		dd	0be717c00h, 03f95743eh
		dd	0be70a400h, 03f9547a1h
		dd	0be6fc800h, 03f951a15h
		dd	0be6ef000h, 03f94ed42h
		dd	0be6e1800h, 03f94c054h
		dd	0be6d4000h, 03f94934bh
		dd	0be6c7000h, 03f9467d3h
		dd	0be6b9c00h, 03f943b6ah
		dd	0be6ac800h, 03f940ee8h
		dd	0be69f800h, 03f93e322h
		dd	0be692800h, 03f93b742h
		dd	0be685c00h, 03f938c20h
		dd	0be678c00h, 03f93600ch
		dd	0be66c000h, 03f9334b8h
		dd	0be65f800h, 03f930a24h
		dd	0be652c00h, 03f92de9ch
		dd	0be646400h, 03f92b3d6h
		dd	0be639c00h, 03f9288f7h
		dd	0be62d400h, 03f925dffh
		dd	0be621000h, 03f9233cah
		dd	0be615000h, 03f920a5ah
		dd	0be608800h, 03f91df18h
		dd	0be5fc800h, 03f91b578h
		dd	0be5f0800h, 03f918bc0h
		dd	0be5e4800h, 03f9161f0h
		dd	0be5d8800h, 03f913808h
		dd	0be5ccc00h, 03f910ee8h
		dd	0be5c0c00h, 03f90e4d0h
		dd	0be5b5400h, 03f90bc62h
		dd	0be5a9800h, 03f9092fbh
		dd	0be59e000h, 03f906a5fh
		dd	0be592800h, 03f9041ach
		dd	0be587000h, 03f9018e2h
		dd	0be57b800h, 03f8ff001h
		dd	0be570400h, 03f8fc7edh
		dd	0be565000h, 03f8f9fc2h
		dd	0be559c00h, 03f8f7782h
		dd	0be54e800h, 03f8f4f2ah
		dd	0be543800h, 03f8f27a2h
		dd	0be538800h, 03f8f0004h
		dd	0be52d800h, 03f8ed850h
		dd	0be522c00h, 03f8eb16eh
		dd	0be517c00h, 03f8e898eh
		dd	0be50d000h, 03f8e6280h
		dd	0be502400h, 03f8e3b5dh
		dd	0be4f7800h, 03f8e1424h
		dd	0be4ecc00h, 03f8decd6h
		dd	0be4e2800h, 03f8dc748h
		dd	0be4d7c00h, 03f8d9fcfh
		dd	0be4cd800h, 03f8d7a18h
		dd	0be4c3000h, 03f8d5360h
		dd	0be4b8800h, 03f8d2c92h
		dd	0be4ae800h, 03f8d078ah
		dd	0be4a4000h, 03f8ce094h
		dd	0be49a000h, 03f8cbb64h
		dd	0be48fc00h, 03f8c9531h
		dd	0be485c00h, 03f8c6fd9h
		dd	0be47bc00h, 03f8c4a6dh
		dd	0be471c00h, 03f8c24edh
		dd	0be467c00h, 03f8bff59h
		dd	0be45e000h, 03f8bdaa2h
		dd	0be454000h, 03f8bb4e6h
		dd	0be44a800h, 03f8b90fah
		dd	0be440800h, 03f8b6b16h
		dd	0be437000h, 03f8b4704h
		dd	0be42d800h, 03f8b22dfh
		dd	0be423c00h, 03f8afdb3h
		dd	0be41a400h, 03f8ad968h
		dd	0be410c00h, 03f8ab50ah
		dd	0be407800h, 03f8a918eh
		dd	0be3fe000h, 03f8a6d0ah
		dd	0be3f4c00h, 03f8a496ah
		dd	0be3eb400h, 03f8a24c0h
		dd	0be3e2400h, 03f8a01f2h
		dd	0be3d9000h, 03f89de1ah
		dd	0be3d0000h, 03f89bb28h
		dd	0be3c6c00h, 03f89972bh
		dd	0be3bd800h, 03f89731ch
		dd	0be3b4c00h, 03f8950eeh
		dd	0be3abc00h, 03f892db4h
		dd	0be3a3000h, 03f890b62h
		dd	0be399c00h, 03f88e709h
		dd	0be391400h, 03f88c591h
		dd	0be388400h, 03f88a20fh
		dd	0be37fc00h, 03f888075h
		dd	0be377000h, 03f885dcch
		dd	0be36e400h, 03f883b12h
		dd	0be365800h, 03f881847h
		dd	0be35d400h, 03f87f768h
		dd	0be354800h, 03f87d47ah

a1  dd 0.47
a2  dd 1.47

.code

SQRT_TAB_LOG2       equ     9           ;; log2 of the lookup-table
MANTISSA_SIZE       equ     24          ;; number if mantissa bits in fp value
                                        ;; number of represented mantissa bits
                                        ;; (one less than total due to hidden
                                        ;; leading one).
MANTISSA_BITS       equ     (MANTISSA_SIZE - 1)
ELEMENT_SIZE_LOG2   equ     3           ;; log2 of each table entry (8 bytes)
                                        ;; shift required to get bits in value
                                        ;; in the correct place to use as an
                                        ;; index for the table lookup
EXPONENT_SHIFT      equ     (MANTISSA_BITS - (SQRT_TAB_LOG2 - 1)\
                             - ELEMENT_SIZE_LOG2)
                                        ;; mask value for clamping to [.5..2)
CLAMP_MASK          equ     ((1 SHL (MANTISSA_BITS+1)) - 1)
                                        ;; mask for sign/exponent bits
MANTISSA_MASK        equ     ((1 SHL MANTISSA_BITS) - 1)
                                        ;; mask for sign/exponent bits
EXPONENT_MASK       equ     (-1 AND (NOT MANTISSA_MASK))
                                        ;; mask for table lookup
TABLE_MASK          equ     ((1 SHL (SQRT_TAB_LOG2 + ELEMENT_SIZE_LOG2)) - 1) \
                            AND (NOT((1 SHL ELEMENT_SIZE_LOG2) - 1))
                                        ;; bias used to represent clamped value
EXPONENT_BIAS_EVEN  equ     3f000000h
                                        ;; bias value used for final exponent
                                        ;; computation
LARGE_EXPONENT_BIAS equ     (((127 + 127/2) SHL (MANTISSA_BITS+1)) OR CLAMP_MASK)


__FLOAT_ONE equ 03F800000h

;----------------------------------------------------------------------
;
; float __fastcall JBInvSqrt(float x);
;
; Input:
;   esp + 4 = x
; Output:
;   result is on the floating point stack
; Algorithm:
;   The floating point trick, described in IEEE Computer Graphics and 
;   Applications v.17 number 4 in Jim Blinn's article, is used.
;
;   ONE_AS_INTEGER = 0x3F800000;
;   int   tmp = (ONE_AS_INTEGER << 1 + ONE_AS_INTEGER - *(long*)&x) >> 1;   
;   float y = *(float*)&tmp;                                             
;   result = y*(1.47f - 0.47f*x*y*y);
;
@JBInvSqrt@4 PROC NEAR
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    sub     eax, [esp+4]
    sub     esp, 4                      ; place for temporary variable "y"
    sar     eax, 1
    mov     [esp], eax                  ; y
    fld     a1
    fmul    DWORD PTR [esp+8]           ; x*0.47
    fld     DWORD PTR [esp]
    fld     st(0)                       ; y y x*0.47
    fmul    st(0), st(1)                ; y*y y x*0.47
    fld     a2                          ; 1.47 y*y y x*0.47
    fxch    st(3)                       ; x*0.47 y*y y 1.47
    fmulp   st(1), st(0)                ; x*0.47*y*y y 1.47
    fsubp   st(2), st(0)                ; y 1.47-x*0.47*y*y
    fmulp   st(1), st(0)                ; result
    add     esp, 4
    ret     4
@JBInvSqrt@4 endp
;----------------------------------------------------------------------
; void __fastcall JBInvSqrt(float *result, float *nomal);
;
; Input:
;   ecx = address of the result
;   edx = address of the normal
;
;
@JBVecNormalize@8 PROC NEAR
    fld     DWORD PTR [edx]
    fmul    st(0), st(0)
    fld     DWORD PTR [edx + 4]
    fmul    st(0), st(0)
    fld     DWORD PTR [edx + 8]
    fmul    st(0), st(0)                ; z y x
    fxch    st(2)			            ; x y z
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len
    sub     esp, 4                      ; Place for temporary variable "y"
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    fst     DWORD PTR [esp]             ; Vector length
    sub     eax, [esp]
    sar     eax, 1
    mov     [esp], eax                  ; y
    fmul    a1                          ; x*0.47
    fld     DWORD PTR [esp]             ; y x*0.47
    fld     st(0)                       ; y y x*0.47
    fmul    st(0), st(1)                ; y*y y x*0.47
    fld     a2                          ; 1.47 y*y y x*0.47
    fxch    st(3)                       ; x*0.47 y*y y 1.47
    fmulp   st(1), st(0)                ; x*0.47*y*y y 1.47
    fsubp   st(2), st(0)                ; y aaa       
    fmulp   st(1), st(0)                ; 1/sqrt(len)
    fld     DWORD PTR [edx]             ; Start normalizing the normal
    fmul    st, st(1)
    fld     DWORD PTR [edx + 4]
    fmul    st, st(2)
    fld     DWORD PTR [edx + 8]
    fmulp   st(3), st(0)                ; y x z
    fxch    st(1)
    add     esp, 4
    fstp    DWORD PTR [ecx]
    fstp    DWORD PTR [ecx + 4]
    fstp    DWORD PTR [ecx + 8]
	ret	
@JBVecNormalize@8 endp
;----------------------------------------------------------------------
; Input:
;     [esp+4] = x
;
;
x 	    equ DWORD PTR [esp + 12]
num 	equ DWORD PTR [esp]

@TableInvSqrt@4 PROC NEAR
    mov     eax, [esp + 4]          ; x
    push    ecx
    mov     ecx, eax
	sub	    esp, 4                  ; Place for num
    shr     ecx, EXPONENT_SHIFT     ;; ecx is table index (8 frac. bits)
    and     eax, CLAMP_MASK		    ;; clamp number to [0.5, 2.0]
    and     ecx, TABLE_MASK		    ;; (8 bytes)/(table entry)
    or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
    mov     num, eax
    fld     num
    fmul    [invSqrtTab+ecx]        ;; find mx
    mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
    sub     eax, x                  ;; divide exponent by 2
    fadd    [invSqrtTab+ecx+4]      ;; get mx + b
    shr     eax, 1
    and     eax, EXPONENT_MASK     	;; mask exponent
    mov     num, eax
    fmul    num                     ;; now adjust for exponent
    add     esp, 4
    pop     ecx
	ret     4
@TableInvSqrt@4 endp
;----------------------------------------------------------------------
;
len 	equ DWORD PTR -4[ebp]
num 	equ DWORD PTR -8[ebp]

@TableVecNormalize@8 PROC NEAR
	push	ebp
	mov	    ebp, esp
	sub	    esp, 8
	fld	    DWORD PTR [edx]
	fmul	DWORD PTR [edx]		;; x
	fld	    DWORD PTR [edx+4]
	fmul	DWORD PTR [edx+4]	;; y x
	fld	    DWORD PTR [edx+8]
	fmul	DWORD PTR [edx+8]	;; z y x
	fxch	ST(2)			;; x y z
	faddp	ST(1), ST		;; xy z
	faddp	ST(1), ST		;; xyz
	fstp	len
	mov	eax, len
	test	eax, eax
	jne	notZeroLen

	mov	[ecx], eax
	mov	[ecx+4], eax
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notZeroLen:

	cmp	eax, __FLOAT_ONE
	jne	notOneLen
	cmp	ecx, edx
	je	normExit
	mov	eax, [edx]
	mov	[ecx], eax
	mov	eax, [edx+4]
	mov	[ecx+4], eax
	mov	eax, [edx+8]
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notOneLen:

	;; eax already has length

	push	edi
    mov     edi, eax
    shr     edi, EXPONENT_SHIFT     ;; edi is table index (8 frac. bits)
    and     eax, CLAMP_MASK		;; clamp number to [0.5, 2.0]
    and     edi, TABLE_MASK		;; (8 bytes)/(table entry)
    or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
    mov     num, eax
    fld     num
    fmul    [invSqrtTab+edi]        ;; find mx
    mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
    sub     eax, len                ;; divide exponent by 2
    fadd    [invSqrtTab+edi+4]      ;; get mx + b
    shr     eax, 1
    and     eax, EXPONENT_MASK     	;; mask exponent
    mov     num, eax
    fmul    num                     ;; now adjust for exponent

	fld	    DWORD PTR [edx]		;; 1/sqrt(len) on stack
	fmul	ST, ST(1)
	fld	    DWORD PTR [edx+4]
	fmul	ST, ST(2)
	fld	    DWORD PTR [edx+8]
	fmul	ST, ST(3)		;; z y x len
	fxch	ST(2)			;; x y z len
	fstp	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ecx+8]
	fstp	ST(0)			;; pop len
	
        pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0

normExit:

	mov	esp, ebp
	pop	ebp
	ret     0

@TableVecNormalize@8 ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\d3ditype.h ===
//----------------------------------------------------------------------------
//
// d3ditype.h
//
// Standard types and supporting declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DITYPE_H_
#define _D3DITYPE_H_

#ifndef FASTCALL
#ifdef _X86_
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif
#endif

#ifndef CDECL
#ifdef _X86_
#define CDECL __cdecl
#else
#define CDECL
#endif
#endif

// Sized types.
#ifndef _BASETSD_H_
typedef signed char             INT8, *PINT8;
typedef short int               INT16, *PINT16;
typedef int                     INT32, *PINT32;
typedef __int64                 INT64, *PINT64;
typedef unsigned char           UINT8, *PUINT8;
typedef unsigned short int      UINT16, *PUINT16;
typedef unsigned int            UINT32, *PUINT32;
typedef unsigned __int64        UINT64, *PUINT64;
#endif

// Basic float types.
typedef float                   FLOAT, *PFLOAT;
typedef double                  DOUBLE, *PDOUBLE;

typedef struct _D3DVECTORH
{
    D3DVALUE x;
    D3DVALUE y;
    D3DVALUE z;
    D3DVALUE w;
} D3DVECTORH, *LPD3DVECTORH;

#endif // #ifndef _D3DITYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\d3di.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3di.hpp
 *  Content:    Direct3D internal include file
 *
 *  $Id:
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *
 ***************************************************************************/

#ifndef _D3DI_HPP
#define _D3DI_HPP

#include "ddrawp.h"
#include "d3dp.h"
#include "d3dmem.h"

#if !defined(BUILD_DDDDK)
extern "C" {
#include "ddrawi.h"
};
#include "object.h"
#include "lists.hpp"

#include <d3ditype.h>
#include <d3dutil.h>

#include <d3dfe.hpp>

//--------------------------------------------------------------------
const DWORD __INIT_VERTEX_NUMBER = 1024;// Initial number of vertices in TL and
                                        // clip flag buffers
const DWORD __MAX_VERTEX_SIZE = 128;    // Max size of FVF vertex in bytes
//--------------------------------------------------------------------
/*
 * Registry defines
 */
#define RESPATH    "Software\\Microsoft\\Direct3D\\Drivers"
#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

extern HINSTANCE hGeometryDLL;

/*
 * CPU family and features flags
 */
extern DWORD dwCPUFamily, dwCPUFeatures;
extern char szCPUString[];

// MMX available
#define D3DCPU_MMX          0x00000001L

// FCOMI and CMOV are both supported
#define D3DCPU_FCOMICMOV    0x00000002L

// Reads block until satisfied
#define D3DCPU_BLOCKINGREAD 0x00000004L

// Extended 3D support available
#define D3DCPU_X3D          0x00000008L

// Pentium II CPU
#define D3DCPU_PII          0x000000010L

// Katmai CPU
#define D3DCPU_KATMAI       0x000000020L


#define IS_OVERRIDE(type)   ((DWORD)(type) > D3DSTATE_OVERRIDE_BIAS)
#define GET_OVERRIDE(type)  ((DWORD)(type) - D3DSTATE_OVERRIDE_BIAS)

#define MAX_STATE   D3DSTATE_OVERRIDE_BIAS

#define DEFAULT_GAMMA   DTOVAL(1.4)

/*
    INDEX_BATCH_SCALE is the constant which is used by DrawIndexedPrim
    to deterimine if the number of primitives being drawn is small
    relative to the number of vertices being passed.  If it is then
    the prims are dereferenced in batches and sent to DrawPrim.
*/
#define INDEX_BATCH_SCALE   2

#endif // BUILD_DDDDK

typedef ULONG_PTR D3DI_BUFFERHANDLE, *LPD3DI_BUFFERHANDLE;

// AnanKan: This should ideally reside in d3dtypes.h, but since we are
// pulling out OptSurface support in DX6 I kept it here (to keep the code
// alive)
typedef HRESULT (WINAPI* LPD3DENUMOPTTEXTUREFORMATSCALLBACK)(LPDDSURFACEDESC2 lpDdsd2, LPDDOPTSURFACEDESC lpDdOsd, LPVOID lpContext);

/*
 * Internal version of executedata
 */
typedef struct _D3DI_ExecuteData {
    DWORD       dwSize;
    D3DI_BUFFERHANDLE dwHandle;     /* Handle allocated by driver */
    DWORD       dwVertexOffset;
    DWORD       dwVertexCount;
    DWORD       dwInstructionOffset;
    DWORD       dwInstructionLength;
    DWORD       dwHVertexOffset;
    D3DSTATUS   dsStatus;       /* Status after execute */
} D3DI_EXECUTEDATA, *LPD3DI_EXECUTEDATA;


#if !defined(BUILD_DDDDK)

class DIRECT3DDEVICEI;
class DIRECT3DVIEWPORTI;

typedef class DIRECT3DI *LPDIRECT3DI;
typedef class DIRECT3DDEVICEI *LPDIRECT3DDEVICEI;
typedef class DIRECT3DEXECUTEBUFFERI *LPDIRECT3DEXECUTEBUFFERI;
typedef class DIRECT3DLIGHTI *LPDIRECT3DLIGHTI;
typedef class DIRECT3DMATERIALI *LPDIRECT3DMATERIALI;
typedef class DIRECT3DTEXTUREI *LPDIRECT3DTEXTUREI;
typedef class DIRECT3DVIEWPORTI *LPDIRECT3DVIEWPORTI;
typedef class CDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFERI;

class CDirect3DUnk : public IUnknown
{
public:
    unsigned refCnt;    /* Reference count object */
public:
    LPDIRECT3DI pD3DI;
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();
};

class CDirect3D : public IDirect3D
{
public:
    HRESULT D3DAPI EnumDevices(LPD3DENUMDEVICESCALLBACK, LPVOID);
    virtual HRESULT EnumDevices(LPD3DENUMDEVICESCALLBACK, LPVOID, DWORD, DWORD)=0;
    HRESULT D3DAPI FindDevice(LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT);
    virtual HRESULT FindDevice(LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT, DWORD)=0;
};

class CDirect3D2 : public IDirect3D2
{
public:
    HRESULT D3DAPI EnumDevices(LPD3DENUMDEVICESCALLBACK, LPVOID);
    virtual HRESULT EnumDevices(LPD3DENUMDEVICESCALLBACK, LPVOID, DWORD, DWORD)=0;
    HRESULT D3DAPI FindDevice(LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT);
    virtual HRESULT FindDevice(LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT, DWORD)=0;
};

class CDirect3D3 : public IDirect3D3
{
public:
    HRESULT D3DAPI EnumDevices(LPD3DENUMDEVICESCALLBACK, LPVOID);
    virtual HRESULT EnumDevices(LPD3DENUMDEVICESCALLBACK, LPVOID, DWORD, DWORD)=0;
    HRESULT D3DAPI FindDevice(LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT);
    virtual HRESULT FindDevice(LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT, DWORD)=0;
};

class DIRECT3DI :  public CDirect3D,
                   public CDirect3D2,
                   public CDirect3D3,
                   public CD3DAlloc
{
public: //Private Data

    /*** Object Relations ***/

    /* Devices */
    int             numDevs;/* Number of devices */
    struct _devices { DIRECT3DDEVICEI* Root;} devices;
    /* Associated IDirect3DDevices */

    /* Viewports */
    int             numViewports; /* Number of viewports */
    LIST_ROOT(_viewports, DIRECT3DVIEWPORTI) viewports;
    /* Created IDirect3DViewports */

    /* Lights */
    int             numLights; /* Number of lights */
    LIST_ROOT(_lights, DIRECT3DLIGHTI) lights;
    /* Created IDirect3DLights */

    /* Materials */
    int             numMaterials; /* Number of materials */
    LIST_ROOT(_materials, DIRECT3DMATERIALI) materials;
    /* Created IDirect3DMaterials */

    /* Vertex Buffers */
    int             numVBufs; /* Number of vertex buffers */
    LIST_ROOT(_vbufs, CDirect3DVertexBuffer) vbufs;
    /* Created IDirect3DVertexBuffers */

    /*** Object Data ***/

    CDirect3DUnk mD3DUnk;

    unsigned long       v_next; /* id of next viewport to be created */

    //RLDDIRegistry*      lpReg;  /* Registry */
    struct _D3DBUCKET  *lpFreeList; /* Free linked list  */
    struct _D3DBUCKET  *lpBufferList;/* link list of headers of big chunks allocated*/
    class TextureCacheManager   *lpTextureManager;
    /*
     * DirectDraw Interface
     */
    LPDIRECTDRAW lpDD;
    LPDIRECTDRAW4 lpDD4;    /* needed for CreateSurface to get LPDIRECTDRAWSURFACE4 */

    // HACK.  D3D needs a DD1 DDRAWI interface because it uses CreateSurface1 internally
    // for exebufs, among other things.   But the D3DI object cannot keep a reference
    // to its parent DD object because it is aggegrated with the DD obj, so that would constitute
    // a circular reference that would prevent deletion. So QI for DD1 interface, copy it into D3DI
    // and release it, then point lpDD at the copy. (disgusting)
    // More disgusting still: These need to be large enough to hold ddrawex interface structs

    DDRAWI_DIRECTDRAW_INT DDInt_DD1;
    DDRAWI_DIRECTDRAW_INT DDInt_DD4;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */

public: //Private methods
    DIRECT3DI(IUnknown* pUnkOuter, LPDDRAWI_DIRECTDRAW_INT pDDrawInt); // Constructor called Direct3DCreate()
    ~DIRECT3DI(); // Destructor called by CDirect3DUnk::Release()
    HRESULT EnumDevices(LPD3DENUMDEVICESCALLBACK, LPVOID, DWORD, DWORD);
    HRESULT FindDevice(LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT, DWORD);
    // Internal CreateVertexBuffer
    HRESULT CreateVertexBufferI(LPD3DVERTEXBUFFERDESC, LPDIRECT3DVERTEXBUFFER*, DWORD);
    // Device flushing
    HRESULT FlushDevicesExcept(LPDIRECT3DDEVICEI pDev);
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3D Methods
    HRESULT D3DAPI Initialize(REFCLSID);
    HRESULT D3DAPI CreateLight(LPDIRECT3DLIGHT*, IUnknown*);
    HRESULT D3DAPI CreateMaterial(LPDIRECT3DMATERIAL*, IUnknown*);
    HRESULT D3DAPI CreateViewport(LPDIRECT3DVIEWPORT*, IUnknown*);
    //IDirect3D2 Methods
    HRESULT D3DAPI CreateMaterial(LPDIRECT3DMATERIAL2*, IUnknown*);
    HRESULT D3DAPI CreateViewport(LPDIRECT3DVIEWPORT2*, IUnknown*);
    HRESULT D3DAPI CreateDevice(REFCLSID, LPDIRECTDRAWSURFACE, LPDIRECT3DDEVICE2*);
    //IDirect3D3 Methods
    HRESULT D3DAPI CreateMaterial(LPDIRECT3DMATERIAL3*, LPUNKNOWN);
    HRESULT D3DAPI CreateViewport(LPDIRECT3DVIEWPORT3*, LPUNKNOWN);
    HRESULT D3DAPI CreateDevice(REFCLSID, LPDIRECTDRAWSURFACE4, LPDIRECT3DDEVICE3*, LPUNKNOWN);
    HRESULT D3DAPI CreateVertexBuffer(LPD3DVERTEXBUFFERDESC, LPDIRECT3DVERTEXBUFFER*, DWORD, LPUNKNOWN);
    HRESULT D3DAPI EnumZBufferFormats(REFCLSID, LPD3DENUMPIXELFORMATSCALLBACK, LPVOID);
    HRESULT D3DAPI EnumOptTextureFormats(REFCLSID, LPD3DENUMOPTTEXTUREFORMATSCALLBACK, LPVOID);  // not exposed by API (yet)
    HRESULT D3DAPI EvictManagedTextures();
};

typedef DIRECT3DI* LPDIRECT3DI;

#include "d3dhal.h"
#include "halprov.h"

//---------------------------------------------------------------------
typedef HRESULT (*PFNDRVSETRENDERTARGET)(LPDIRECTDRAWSURFACE4, LPDIRECTDRAWSURFACE4,
                                         LPDIRECTDRAWPALETTE, LPDIRECT3DDEVICEI);
typedef HRESULT (*PFNDOFLUSHBEGINEND)(LPDIRECT3DDEVICEI);
typedef HRESULT (*PFNDRAWPRIM)(LPDIRECT3DDEVICEI);

typedef struct _D3DBUCKET
{
    struct _D3DBUCKET *next;
    union
    {
    LPVOID  lpD3DDevI;
    LPDDRAWI_DDRAWSURFACE_LCL lpLcl;
    LPVOID  lpBuffer;
    LPDIRECT3DTEXTUREI lpD3DTexI;
    };
    unsigned int ticks;
    LPDIRECTDRAWSURFACE *lplpDDSZBuffer;    //if not NULL, points to lpDDSZBuffer in Direct3DDeviceI
} D3DBUCKET,*LPD3DBUCKET;

typedef struct _D3DI_TEXTUREBLOCK
{
    LIST_MEMBER(_D3DI_TEXTUREBLOCK) list;
    /* Next block in IDirect3DTexture */
    LIST_MEMBER(_D3DI_TEXTUREBLOCK) devList;
    /* Next block in IDirect3DDevice */

    LPDIRECT3DDEVICEI           lpDevI;

    /*  this texture block refers to either an
     * IDirect3DTexture/IDirect3DTexture2, so one of these pointers will
     * always be NULL
     */
    LPDIRECT3DTEXTUREI          lpD3DTextureI;
    /* pointer to internal struct for IDirect3DTexture/IDirect3DTexture2 */

    D3DTEXTUREHANDLE            hTex;
    /* texture handle */
} D3DI_TEXTUREBLOCK;
typedef struct _D3DI_TEXTUREBLOCK *LPD3DI_TEXTUREBLOCK;

typedef struct _D3DI_MATERIALBLOCK
{
    LIST_MEMBER(_D3DI_MATERIALBLOCK)    list;
    /* Next block in IDirect3DMaterial */
    LIST_MEMBER(_D3DI_MATERIALBLOCK)    devList;
    /* Next block in IDirect3DDevice */
    LPDIRECT3DDEVICEI   lpDevI;
    LPDIRECT3DMATERIALI lpD3DMaterialI;
    D3DMATERIALHANDLE   hMat;
    /* material handle */
    DWORD               hMatDDI;
    /* driver handle (for hardware transform & light) */
} D3DI_MATERIALBLOCK;
typedef struct _D3DI_MATERIALBLOCK *LPD3DI_MATERIALBLOCK;

typedef struct _D3DFE_MATERIAL
{
    LIST_MEMBER(_D3DFE_MATERIAL) link;
    D3DMATERIAL         mat;
    // RampRast material if necessary
    LPVOID              pRmMat;
} D3DFE_MATERIAL, *LPD3DFE_MATERIAL;

// Function to compute lighting
//
typedef struct _LIGHT_VERTEX_FUNC_TABLE
{
    LIGHT_VERTEX_FUNC   directional1;
    LIGHT_VERTEX_FUNC   directional2;
    LIGHT_VERTEX_FUNC   spot1;
    LIGHT_VERTEX_FUNC   spot2;
    LIGHT_VERTEX_FUNC   point1;
    LIGHT_VERTEX_FUNC   point2;
} LIGHT_VERTEX_FUNC_TABLE;
//---------------------------------------------------------------------
//
// Bits for D3DFRONTEND flags (dwFEFlags in DIRECT3DDEVICEI)
//
const DWORD D3DFE_VALID                 = 1 << 1;
const DWORD D3DFE_TLVERTEX              = 1 << 2;
const DWORD D3DFE_REALHAL               = 1 << 3;
const DWORD D3DFE_VIEWPORT_DIRTY        = 1 << 4;
const DWORD D3DFE_PROJMATRIX_DIRTY      = 1 << 5;
const DWORD D3DFE_VIEWMATRIX_DIRTY      = 1 << 6;
const DWORD D3DFE_WORLDMATRIX_DIRTY     = 1 << 7;
const DWORD D3DFE_INVERSEMCLIP_DIRTY    = 1 << 8;
const DWORD D3DFE_MCLIP_IDENTITY        = 1 << 9;
const DWORD D3DFE_PROJ_PERSPECTIVE      = 1 << 10;
const DWORD D3DFE_AFFINE_WORLD          = 1 << 11;
const DWORD D3DFE_AFFINE_VIEW           = 1 << 12;
const DWORD D3DFE_AFFINE_WORLD_VIEW     = 1 << 13;
const DWORD D3DFE_NEED_TRANSFORM_LIGHTS = 1 << 14;
const DWORD D3DFE_MATERIAL_DIRTY        = 1 << 15;
const DWORD D3DFE_NEED_TRANSFORM_EYE    = 1 << 16;
const DWORD D3DFE_FOG_DIRTY             = 1 << 17;
const DWORD D3DFE_LIGHTS_DIRTY          = 1 << 18;
// Set if D3DLIGHTSTATE_COLORVERTEX is TRUE
const DWORD D3DFE_COLORVERTEX           = 1 << 19;
// Set if the Current Transformation Matrix has been changed
// Reset when frustum planes in the model space have been computed
const DWORD D3DFE_FRUSTUMPLANES_DIRTY   = 1 << 20;
const DWORD D3DFE_WORLDVIEWMATRIX_DIRTY = 1 << 21;
// This bit is set if fog mode is not FOG_NONE and fog is enabled
const DWORD D3DFE_FOGENABLED            = 1 << 22;
// This bit set if UpdateManagedTextures() needs to be called
const DWORD D3DFE_NEED_TEXTURE_UPDATE   = 1 << 23;
// This bit set if mapping DX6 texture blend modes to renderstates is desired
const DWORD D3DFE_MAP_TSS_TO_RS         = 1 << 24;
// This bit set if we have to compute specular highlights
const DWORD D3DFE_COMPUTESPECULAR       = 1 << 26;
const DWORD D3DFE_LOSTSURFACES          = 1 << 27;
// This bit set if texturing is disabled
const DWORD D3DFE_DISABLE_TEXTURES      = 1 << 28;
// This bit set when D3DTSS_TEXCOORDINDEX is changed
const DWORD D3DFE_TSSINDEX_DIRTY        = 1 << 29;

const DWORD D3DFE_TRANSFORM_DIRTY = D3DFE_VIEWPORT_DIRTY |
                                    D3DFE_PROJMATRIX_DIRTY |
                                    D3DFE_VIEWMATRIX_DIRTY |
                                    D3DFE_WORLDMATRIX_DIRTY;
//---------------------------------------------------------------------
//
// Bits for dwDebugFlags
//
// Set if DisableFVF key is not 0 in registry and driver supports FVF
const DWORD D3DDEBUG_DISABLEFVF = 1 << 0;
// Disable Draw Primitive DDI
const DWORD D3DDEBUG_DISABLEDP  = 1 << 1;
// Disable Draw Primitive 2 DDI
const DWORD D3DDEBUG_DISABLEDP2 = 1 << 2;

#ifdef  WIN95
#define _D3D_FORCEDOUBLE    1
#else   //WIN95
#define _D3D_FORCEDOUBLE    0
#endif  //WIN95
#if _D3D_FORCEDOUBLE
// Set if ForceDouble key is not 0 in the registry and driver is pre-DX6 REALHAL
const DWORD D3DDEBUG_FORCEDOUBLE= 1 << 2;
#endif  //_D3D_FORCEDOUBLE

//---------------------------------------------------------------------
// Bits for transform.dwFlags
//

// Frastum plane equations are valid
const DWORD D3DTRANS_VALIDFRUSTUM   = 1 << 2;
//---------------------------------------------------------------------
typedef struct _D3DFE_TRANSFORM
{
    LIST_ROOT(matlist, _D3DMATRIXI) matrices;
    D3DMATRIXI      proj;
    D3DMATRIXI      view;
    D3DMATRIXI      world;
    D3DMATRIXI      mPC;        // Mproj * Mclip
    D3DMATRIXI      mVPC;       // Mview * PC
    D3DMATRIXHANDLE hProj;
    D3DMATRIXHANDLE hView;
    D3DMATRIXHANDLE hWorld;
    D3DMATRIXI      mCTMI;      // Inverse current transformation matrix
    D3DVECTORH      frustum[6]; // Normalized plane equations for viewing frustum
                                // in the model space
    DWORD           dwFlags;
} D3DFE_TRANSFORM;

typedef void (*D3DFEDestroyProc)(LPDIRECT3DDEVICEI lpD3DDevI);

#define D3D_RSTATEBUF_SIZE 128

#define D3D_MAX_MMX_VERTICES 1024

extern DWORD dwD3DTriBatchSize, dwTriBatchSize, dwLineBatchSize;
extern DWORD dwHWBufferSize, dwHWMaxTris;
extern DWORD dwHWFewVertices;

typedef struct _D3DHAL_DRAWPRIMCOUNTS *LPD3DHAL_DRAWPRIMCOUNTS;

// Legacy HAL batching is done with these structs.
typedef struct _D3DI_HWCOUNTS {
    WORD wNumStateChanges;      // Number of state changes batched
    WORD wNumVertices;          // Number of vertices in tri list
    WORD wNumTriangles;         // Number of triangles in tri list
} D3DI_HWCOUNTS, *LPD3DI_HWCOUNTS;

typedef struct _D3DHAL_EXDATA
{
    LIST_MEMBER(_D3DHAL_EXDATA) link;
    D3DEXECUTEBUFFERDESC        debDesc;
    LPDIRECTDRAWSURFACE         lpDDS;
} D3DHAL_EXDATA;
typedef D3DHAL_EXDATA *LPD3DHAL_EXDATA;

/*
 * Picking stuff.
 */
typedef struct _D3DI_PICKDATA
{
    D3DI_EXECUTEDATA*   exe;
    D3DPICKRECORD*  records;
    int         pick_count;
    D3DRECT     pick;
} D3DI_PICKDATA, *LPD3DI_PICKDATA;

#define DWORD_BITS      32
#define DWORD_SHIFT     5

typedef struct _D3DFE_STATESET
{
    DWORD    bits[MAX_STATE >> DWORD_SHIFT];
} D3DFE_STATESET;

#define STATESET_MASK(set, state)       \
    (set).bits[((state) - 1) >> DWORD_SHIFT]

#define STATESET_BIT(state)     (1 << (((state) - 1) & (DWORD_BITS - 1)))

#define STATESET_ISSET(set, state) \
    STATESET_MASK(set, state) & STATESET_BIT(state)

#define STATESET_SET(set, state) \
    STATESET_MASK(set, state) |= STATESET_BIT(state)

#define STATESET_CLEAR(set, state) \
    STATESET_MASK(set, state) &= ~STATESET_BIT(state)

#define STATESET_INIT(set)      memset(&(set), 0, sizeof(set))

class CDirect3DDeviceUnk : public IUnknown
{
public:
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();
public:
    /* Reference count object */
    unsigned refCnt;
    /* Our Device type */
    LPDIRECT3DDEVICEI pDevI;
};

class CDirect3DDevice : public IDirect3DDevice
{
public:
    HRESULT D3DAPI GetCaps(LPD3DDEVICEDESC, LPD3DDEVICEDESC);
    virtual HRESULT GetCapsI(LPD3DDEVICEDESC, LPD3DDEVICEDESC)=0;
public:
    DWORD   dwVersion;   // represents the version the device was created as  (3==IDirect3DDevice3, etc)
};

typedef enum {
    D3DDEVTYPE_OLDHAL,
    D3DDEVTYPE_DPHAL,
    D3DDEVTYPE_DP2HAL,
    D3DDEVTYPE_DX7HAL
} D3DDEVICETYPE;
//---------------------------------------------------------------------
typedef HRESULT (DIRECT3DDEVICEI::*PFN_DRAWPRIM)();

//---------------------------------------------------------------------
// This type is used to define operation for ProcessPrimitive
//
typedef enum
{
    __PROCPRIMOP_INDEXEDPRIM,       // Process indexed primitive
    __PROCPRIMOP_NONINDEXEDPRIM,    // Process non-indexed primitive
    __PROCPRIMOP_PROCVERONLY,       // Process vertices only
} __PROCPRIMOP;
//---------------------------------------------------------------------
#ifdef _IA64_   // Removes IA64 compiler alignment warnings
  #pragma pack(16)
#endif

#ifdef _AXP64_   // Removes AXP64 compiler alignment warnings
  #pragma pack(16)
#endif

class DIRECT3DDEVICEI : public CDirect3DDevice,
                        public IDirect3DDevice2,
                        public IDirect3DDevice3,
                        public CD3DAlloc,
                        public D3DFE_PROCESSVERTICES
{
public: // Private Data

    HRESULT (*pfnFlushStates)(LPDIRECT3DDEVICEI);

#define D3DDEVBOOL_HINTFLAGS_INSCENE             (0x00000001L)  // Are we between Begin/End?
#define D3DDEVBOOL_HINTFLAGS_INBEGIN             (0x00000002L)  // Are we in a scene?
#define D3DDEVBOOL_HINTFLAGS_INBEGIN_FIRST_FLUSH (0x00000004L)  // Set when first flush occurs
// Set when indexed begin/end primitive is flushed several times
#define D3DDEVBOOL_HINTFLAGS_INBEGIN_BIG_PRIM    (0x00000020L)
#define D3DDEVBOOL_HINTFLAGS_INBEGIN_ALL         (D3DDEVBOOL_HINTFLAGS_INBEGIN | \
                                                  D3DDEVBOOL_HINTFLAGS_INBEGIN_FIRST_FLUSH | \
                                                  D3DDEVBOOL_HINTFLAGS_INBEGIN_BIG_PRIM)
#define D3DDEVBOOL_HINTFLAGS_INTERNAL_BEGIN_END  (0x00000008L)  // Is this an internal (tex fill)
                                                                // begin/end
#define D3DDEVBOOL_HINTFLAGS_MULTITHREADED       (0x00000010L)  // multithreaded device
/* Should be cache line aligned. Now it is not !!! 0f04*/
    DWORD             dwHintFlags;
    // Cache last input->output FVF mapping
    DWORD               dwFVFLastIn;
    DWORD               dwFVFLastOut;
    DWORD               dwFVFLastTexCoord;
    DWORD               dwFVFLastOutputSize;
    DWORD               dwFVFLastInSize;
    DWORD               dwFEFlags;
/*Should be cache line aligned. Now it is not*/
    // Pointer to the PV funcs that we need to call
    LPD3DFE_PVFUNCS pGeometryFuncs;
    // buffers for TL and H vertices
    CAlignedBuffer32  HVbuf;        // Used for clip flags
    CBufferVB         TLVbuf;

/*Should be cache line aligned. Now it is not*/
    PFN_DRAWPRIM            pfnDrawPrim;        // Used by clipper to call HAL
    PFN_DRAWPRIM            pfnDrawIndexedPrim; // Used by clipper to call HAL
    /* Viewports */
    unsigned long       v_id;   /* ID of last viewport rendered */
    /* Associated IDirect3DViewports */
    LPDIRECT3DVIEWPORTI lpCurrentViewport;
    /* Device Type */
    D3DDEVICETYPE deviceType;

    D3DSTATS            D3DStats;

    /*** Object Relations ***/
    LPDIRECT3DI                lpDirect3DI; /* parent */
    LIST_MEMBER(DIRECT3DDEVICEI)list;   /* Next device IDirect3D */

    /* Textures */
    LIST_ROOT(_dmtextures, _D3DI_TEXTUREBLOCK) texBlocks;
    /* Ref to created IDirect3DTextures */

    /* Execute buffers */
    LIST_ROOT(_buffers, DIRECT3DEXECUTEBUFFERI) buffers;
    /* Created IDirect3DExecuteBuffers */

    /* Viewports */
    int             numViewports;
    CIRCLE_QUEUE_ROOT(_dviewports, DIRECT3DVIEWPORTI) viewports;

    /* Materials */
    LIST_ROOT(_dmmaterials, _D3DI_MATERIALBLOCK) matBlocks;
    /* Ref to associated IDirect3DMaterials */

    /*** Object Data ***/
    CDirect3DDeviceUnk mDevUnk;

    // for DX3-style devices aggregated onto ddraw, guid should be IID_IDirect3DRGBDevice,
    // IID_IDirect3DHALDevice, etc.  for DX5 and beyond, guid is IID_IDirect3DDevice,
    // IID_IDirect3DDevice2, etc
    GUID        guid;

    LPD3DHAL_CALLBACKS      lpD3DHALCallbacks; /* HW specific */
    LPD3DHAL_GLOBALDRIVERDATA   lpD3DHALGlobalDriverData; /* HW specific */
    LPD3DHAL_CALLBACKS2         lpD3DHALCallbacks2;    /* HW specific */
    LPD3DHAL_CALLBACKS3         lpD3DHALCallbacks3; /* DX6 DDI */

    /* DirectDraw objects that we are holding references to */

    LPDIRECTDRAW lpDD;    // DirectDraw object
    LPDDRAWI_DIRECTDRAW_GBL lpDDGbl;    //
    LPDIRECTDRAWSURFACE lpDDSTarget;    // Render target
    LPDIRECTDRAWSURFACE lpDDSZBuffer;   // Z buffer
    LPDIRECTDRAWPALETTE lpDDPalTarget;  // Palette for render target (if any)

    // these are saved for use by new GetRenderTarget and anything else that requires DDS4 functionality
    LPDIRECTDRAWSURFACE4 lpDDSTarget_DDS4;
    LPDIRECTDRAWSURFACE4 lpDDSZBuffer_DDS4;

    DWORD               dwWidth, dwHeight;  // dimensions of render target

    // Front end data
    D3DFE_TRANSFORM         transform;

    ULONG_PTR               dwhContext;
    LIST_ROOT(eblist, _D3DHAL_EXDATA) bufferHandles;

// RenderTarget/ZBuf bit depth info used by Clear to Blt
     DWORD                 red_mask;
     DWORD                 red_scale;
     DWORD                 red_shift;
     DWORD                 green_mask;
     DWORD                 green_scale;
     DWORD                 green_shift;
     DWORD                 blue_mask;
     DWORD                 blue_scale;
     DWORD                 blue_shift;
     DWORD                 zmask_shift,stencilmask_shift;
     BOOL                  bDDSTargetIsPalettized;  // true if 4 or 8 bit rendertarget

// Picking info.
    D3DI_PICKDATA       pick_data;
    LPBYTE              lpbClipIns_base;
    DWORD               dwClipIns_offset;

// Pipeline state info
    D3DFE_STATESET      renderstate_overrides;
    D3DFE_STATESET      transformstate_overrides;
    D3DFE_STATESET      lightstate_overrides;
    int                 iClipStatus;

    DWORD               dwDebugFlags;       // See debug bits above

#ifndef WIN95
    ULONG_PTR           hSurfaceTarget;
#else
    DWORD               hSurfaceTarget;
#endif

#ifdef TRACK_HAL_CALLS
    DWORD hal_calls;
#endif


    //--------------- Lights start -----------------------
    int             numLights;  // This indicates the maximum number of lights
                                // that have been set in the device.
    LIST_ROOT(name10,_SpecularTable) specular_tables;
    SpecularTable*    specular_table;
    LIST_ROOT(mtllist, _D3DFE_MATERIAL) materials;
    LIGHT_VERTEX_FUNC_TABLE *lightVertexFuncTable;
    //--------------- Lights end -----------------------

    /* Provider backing this driver */
    IHalProvider*       pHalProv;
    HINSTANCE           hDllProv;

    /*
     * Pointers to functions used by DrawPrim&Begin/End
     */

    PFNDOFLUSHBEGINEND pfnDoFlushBeginEnd;

    /* Device description */
    D3DDEVICEDESC   d3dHWDevDesc;
    D3DDEVICEDESC   d3dHELDevDesc;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */

    /*
     *  Pointer to texture objects for currently installed textures.  NULL indicates
     *  that the texture is either not set (rstate NULL) or that the handle to tex3 pointer
     *  mapping is not done.  This mapping is expensive, so it is deferred until needed.
     *
     *  This is needed for finding the WRAPU,V mode for texture index clipping (since
     *  the WRAPU,V state is part of the device).
     */
    LPDIRECT3DTEXTUREI          lpD3DMappedTexI[D3DHAL_TSS_MAXSTAGES];
    LPD3DI_TEXTUREBLOCK         lpD3DMappedBlock[D3DHAL_TSS_MAXSTAGES];
    LPDIRECTDRAWCLIPPER         lpClipper;

     //---------- Begin-End data start --------------
    char             *lpcCurrentPtr;        // Current ptr to place next vertex
    CRITICAL_SECTION  BeginEndCSect;

    // max number of vertices
#define BEGIN_DATA_BLOCK_SIZE   256
    // size of internal vertex memory pool
#define BEGIN_DATA_BLOCK_MEM_SIZE  BEGIN_DATA_BLOCK_SIZE*__MAX_VERTEX_SIZE

    LPVOID  lpvVertexBatch;
    WORD    *lpIndexBatch;
    LPVOID  lpvVertexData;      // if lpvVertexData is non-NULL if we are
                                // insize Begin-End and indexed.
    DWORD   dwBENumVertices;
    DWORD   dwMaxVertexCount;   // current number of vertices there is space for
    WORD    *lpVertexIndices;
    DWORD   dwBENumIndices;
    DWORD   dwMaxIndexCount;    // current number of indices there is space for
    WORD    wFlushed;
     //---------- Begin-End data end --------------

    /*
     * DrawPrimitives batching
     */


    // Buffer to put DrawPrimitives stuff into
    // Used for both legacy and DrawPrimitive HALs
    struct _D3DBUCKET   *lpTextureBatched;
    WORD *lpwDPBuffer;
    WORD *lpwDPBufferAlloced;
#ifndef WIN95
    DWORD dwDPBufferSize;
#endif
    DWORD dwCurrentBatchVID;        // Current FVF type in the batch buffer


    /* Legacy HALs */
    // pointer to current prim counts struct
    LPD3DHAL_DRAWPRIMCOUNTS lpDPPrimCounts;

    // Buffer of counts structures that keep track of the
    // number of render states and vertices buffered
    LPD3DI_HWCOUNTS lpHWCounts;

    // Buffer of triangle structures.
    LPD3DTRIANGLE lpHWTris;

    // Buffer of interleaved render states and primitives.
    LPD3DTLVERTEX lpHWVertices;

    // Byte offset into lpHWVertices. This gets incremented
    // by 8 when a render state is batched and by 32*dwNumVertices
    // when a primitive is batched.
    DWORD dwHWOffset;

    // Max value of dwHWOffset. Used to decide whether to flush.
    DWORD dwHWMaxOffset;

    // Index into lpHWTris.
    DWORD dwHWTriIndex;

    // Number of counts structures used so far. This actually
    // gives the number of primitives batched and the index of
    // the counts structure to batch render states into.
    DWORD dwHWNumCounts;

    /* DrawPrimitive-aware HALs */

    // Byte offset into buffer (we are currently
    // using the device's wTriIndex)
    DWORD dwDPOffset;

    // Maximum offset. If dwDPOffset exceeds this, it is
    // time to flush.
    DWORD dwDPMaxOffset;

    WORD *wTriIndex;

    LPD3DHAL_D3DEXTENDEDCAPS lpD3DExtendedCaps;  /* HW specific */
    LPDWORD rstates;

    // Runtime copy of texture stage states
    DWORD tsstates[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];

    DWORD dwMaxTextureBlendStages; // Max number of blend stages supported by a driver

    // This is a function provided by ramp rasterizer. It is called to inform
    // ramp about any material changes. The function pointer and service types
    // are defined in halprov.h
    // It should be NULL except for ramp rasterizer.
    PFN_RASTRAMPSERVICE pfnRampService;

    // This is a function provided by sw rasterizers.
    // Currently, its only function is to provide an RGB8 clear color.
    // It should be non-NULL for anything that supports an 8 bit RGB output
    // type.
    PFN_RASTSERVICE pfnRastService;

    //
    // Begin DP2 HAL section
    //


    //
    // End DP2 HAL section
    //

public: // methods
    virtual ~DIRECT3DDEVICEI() { }; // Dummy virtual destructor to ensure the real one gets called
    HRESULT GetCapsI(LPD3DDEVICEDESC, LPD3DDEVICEDESC);
    HRESULT stateInitialize(BOOL bZEnable);
    HRESULT checkDeviceSurface(LPDIRECTDRAWSURFACE lpDDS, LPDIRECTDRAWSURFACE lpZbuffer, LPGUID pGuid);
    HRESULT hookDeviceToD3D(LPDIRECT3DI lpD3DI);
    HRESULT unhookDeviceFromD3D();
    void DIRECT3DDEVICEI::DestroyDevice();
    virtual HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice, DWORD dwVersion);
    HRESULT hookViewportToDevice(LPDIRECT3DVIEWPORTI lpD3DView);
    virtual HRESULT DrawPrim()=0;       // Use to pass non-indexed primitives to the driver
    virtual HRESULT DrawIndexPrim()=0;  // Use to pass indexed primitives to driver
    virtual HRESULT FlushStates()=0;    // Use to flush current batch to the driver
    virtual HRESULT ExecuteI(LPD3DI_EXECUTEDATA lpExData, DWORD flags)=0;
    virtual HRESULT DrawExeBuf() { return D3D_OK; };
    virtual HRESULT ProcessPrimitive(__PROCPRIMOP op = __PROCPRIMOP_NONINDEXEDPRIM);
    virtual HRESULT CheckSurfaces();    // Check if the surfaces necessary for rendering are lost
    HRESULT PickExeBuf();       // Called by the clipper for execute buffer API
    HRESULT UpdateTextures();

    // Function to download viewport info to the driver
    virtual HRESULT UpdateDrvViewInfo(LPD3DVIEWPORT2 lpVwpData) { return D3D_OK; };
    virtual HRESULT UpdateDrvWInfo() { return D3D_OK; };

#if DBG
#define PROF_EXECUTE                        0x0000
#define PROF_BEGIN                          0x0001
#define PROF_BEGININDEXED                   0x0002
#define PROF_DRAWPRIMITIVEDEVICE2           0x0003
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE2    0x0004
#define PROF_DRAWPRIMITIVESTRIDED           0x0005
#define PROF_DRAWINDEXEDPRIMITIVESTRIDED    0x0006
#define PROF_DRAWPRIMITIVEDEVICE3           0x0007
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE3    0x0008
#define PROF_DRAWPRIMITIVEVB                0x0009
#define PROF_DRAWINDEXEDPRIMITIVEVB         0x000a
    DWORD   dwCaller;
    DWORD   dwPrimitiveType[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType1[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType2[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    void    Profile(DWORD, D3DPRIMITIVETYPE, DWORD);
#else
    #define Profile(a,b,c)
#endif
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DDevice Methods
    HRESULT D3DAPI Initialize(LPDIRECT3D, LPGUID, LPD3DDEVICEDESC);
    HRESULT D3DAPI GetCaps(LPD3DDEVICEDESC, LPD3DDEVICEDESC);
    HRESULT D3DAPI SwapTextureHandles(LPDIRECT3DTEXTURE, LPDIRECT3DTEXTURE);
    HRESULT D3DAPI CreateExecuteBuffer(LPD3DEXECUTEBUFFERDESC, LPDIRECT3DEXECUTEBUFFER*, IUnknown*);
    HRESULT D3DAPI GetStats(LPD3DSTATS);
    HRESULT D3DAPI Execute(LPDIRECT3DEXECUTEBUFFER, LPDIRECT3DVIEWPORT, DWORD);
    HRESULT D3DAPI AddViewport(LPDIRECT3DVIEWPORT);
    HRESULT D3DAPI DeleteViewport(LPDIRECT3DVIEWPORT);
    HRESULT D3DAPI NextViewport(LPDIRECT3DVIEWPORT, LPDIRECT3DVIEWPORT*, DWORD);
    HRESULT D3DAPI Pick(LPDIRECT3DEXECUTEBUFFER, LPDIRECT3DVIEWPORT, DWORD, LPD3DRECT);
    HRESULT D3DAPI GetPickRecords(LPDWORD, LPD3DPICKRECORD);
    HRESULT D3DAPI EnumTextureFormats(LPD3DENUMTEXTUREFORMATSCALLBACK, LPVOID);
    HRESULT D3DAPI CreateMatrix(LPD3DMATRIXHANDLE);
    HRESULT D3DAPI SetMatrix(D3DMATRIXHANDLE, const LPD3DMATRIX);
    HRESULT D3DAPI GetMatrix(D3DMATRIXHANDLE, LPD3DMATRIX);
    HRESULT D3DAPI DeleteMatrix(D3DMATRIXHANDLE);
    HRESULT D3DAPI BeginScene();
    HRESULT D3DAPI EndScene();
    HRESULT D3DAPI GetDirect3D(LPDIRECT3D*);

    // IDirect3DDevice2 Methods
    HRESULT D3DAPI SwapTextureHandles(LPDIRECT3DTEXTURE2, LPDIRECT3DTEXTURE2);
    HRESULT D3DAPI AddViewport(LPDIRECT3DVIEWPORT2);
    HRESULT D3DAPI DeleteViewport(LPDIRECT3DVIEWPORT2);
    HRESULT D3DAPI NextViewport(LPDIRECT3DVIEWPORT2, LPDIRECT3DVIEWPORT2*, DWORD);
    HRESULT D3DAPI GetDirect3D(LPDIRECT3D2*);
    HRESULT D3DAPI SetCurrentViewport(LPDIRECT3DVIEWPORT2);
    HRESULT D3DAPI GetCurrentViewport(LPDIRECT3DVIEWPORT2 *);
    HRESULT D3DAPI SetRenderTarget(LPDIRECTDRAWSURFACE, DWORD);
    HRESULT D3DAPI GetRenderTarget(LPDIRECTDRAWSURFACE *);
    HRESULT D3DAPI Begin(D3DPRIMITIVETYPE, D3DVERTEXTYPE, DWORD);
    HRESULT D3DAPI BeginIndexed(D3DPRIMITIVETYPE, D3DVERTEXTYPE, LPVOID, DWORD, DWORD);
    HRESULT D3DAPI Vertex(LPVOID);
    HRESULT D3DAPI Index(WORD);
    HRESULT D3DAPI End(DWORD);
    HRESULT D3DAPI GetRenderState(D3DRENDERSTATETYPE, LPDWORD);
    HRESULT D3DAPI SetRenderState(D3DRENDERSTATETYPE, DWORD);
    virtual HRESULT D3DAPI SetRenderStateI(D3DRENDERSTATETYPE, DWORD) = 0;
    HRESULT D3DAPI GetLightState(D3DLIGHTSTATETYPE, LPDWORD);
    HRESULT D3DAPI SetLightState(D3DLIGHTSTATETYPE, DWORD);
    HRESULT D3DAPI SetTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT D3DAPI GetTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT D3DAPI MultiplyTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT D3DAPI DrawPrimitive(D3DPRIMITIVETYPE, D3DVERTEXTYPE, LPVOID, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitive(D3DPRIMITIVETYPE, D3DVERTEXTYPE, LPVOID, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI SetClipStatus(LPD3DCLIPSTATUS);
    HRESULT D3DAPI GetClipStatus(LPD3DCLIPSTATUS);

    // IDirect3DDevice3 Methods
    HRESULT D3DAPI AddViewport(LPDIRECT3DVIEWPORT3);
    HRESULT D3DAPI DeleteViewport(LPDIRECT3DVIEWPORT3);
    HRESULT D3DAPI NextViewport(LPDIRECT3DVIEWPORT3, LPDIRECT3DVIEWPORT3*, DWORD);
    HRESULT D3DAPI EnumTextureFormats(LPD3DENUMPIXELFORMATSCALLBACK, LPVOID);
    HRESULT D3DAPI GetDirect3D(LPDIRECT3D3*);
    HRESULT D3DAPI SetCurrentViewport(LPDIRECT3DVIEWPORT3);
    HRESULT D3DAPI GetCurrentViewport(LPDIRECT3DVIEWPORT3 *);
    HRESULT D3DAPI SetRenderTarget(LPDIRECTDRAWSURFACE4, DWORD);
    HRESULT D3DAPI GetRenderTarget(LPDIRECTDRAWSURFACE4 *);
    HRESULT D3DAPI DrawPrimitiveStrided(D3DPRIMITIVETYPE, DWORD, LPD3DDRAWPRIMITIVESTRIDEDDATA, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveStrided(D3DPRIMITIVETYPE, DWORD, LPD3DDRAWPRIMITIVESTRIDEDDATA, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawPrimitive(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitive(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI Begin(D3DPRIMITIVETYPE, DWORD, DWORD);
    HRESULT D3DAPI BeginIndexed(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, DWORD);
    HRESULT D3DAPI DrawPrimitiveVB(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER, DWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveVB(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI ComputeSphereVisibility(LPD3DVECTOR, LPD3DVALUE, DWORD, DWORD, LPDWORD);
    HRESULT D3DAPI GetTexture(DWORD, LPDIRECT3DTEXTURE2 *);
    HRESULT D3DAPI SetTexture(DWORD, LPDIRECT3DTEXTURE2);
    HRESULT D3DAPI GetTextureStageState(DWORD dwStage,
                                        D3DTEXTURESTAGESTATETYPE dwState,
                                        LPDWORD pdwValue);
    virtual HRESULT D3DAPI SetTextureStageState(DWORD dwStage,
                                                D3DTEXTURESTAGESTATETYPE dwState,
                                                DWORD dwValue) = 0;
    virtual HRESULT D3DAPI ValidateDevice(LPDWORD lpdwNumPasses) = 0;
};

class CDirect3DDeviceIHW : public DIRECT3DDEVICEI
{
private: // Data
    /* data members of DIRECT3DDEVICEI that are specific to DX3 Legacy HAL drivers
       should go here */
public:
    inline CDirect3DDeviceIHW() { deviceType = D3DDEVTYPE_OLDHAL; }
    inline ~CDirect3DDeviceIHW() { DestroyDevice(); }; // Called by CDirect3DDeviceUnk::Release()
    HRESULT D3DAPI SetRenderStateI(D3DRENDERSTATETYPE, DWORD);
    HRESULT DrawPrim();
    HRESULT DrawIndexPrim();
    HRESULT FlushStates();
    HRESULT DrawExeBuf();       // Called by the clipper for execute buffer API
    HRESULT ExecuteI(LPD3DI_EXECUTEDATA lpExData, DWORD flags);
    HRESULT D3DAPI SetTextureStageState(DWORD dwStage,
                                        D3DTEXTURESTAGESTATETYPE dwState,
                                        DWORD dwValue);
    HRESULT D3DAPI ValidateDevice(LPDWORD lpdwNumPasses);
    HRESULT MapTSSToRS();
};

class CDirect3DDeviceIDP : public CDirect3DDeviceIHW
{
private: // Data
    /* data members of DIRECT3DDEVICEI that are specific to DX5 DrawPrimitive HAL drivers
       should go here */
public:
    CDirect3DDeviceIDP() { deviceType = D3DDEVTYPE_DPHAL; }
    HRESULT D3DAPI SetRenderStateI(D3DRENDERSTATETYPE, DWORD);
    HRESULT DrawPrim();
    HRESULT DrawIndexPrim();
    HRESULT FlushStates();
};

// Flags passed by the runtime to the DDI batching code via PV structure
// to enable new DDI batching to be done efficiently. These flags are
// marked as reserved in d3dfe.hpp
const DWORD D3DPV_WITHINPRIMITIVE = D3DPV_RESERVED1; // This flags that the flush has occured
                                                     // within an primitive. This indicates
                                                     // that we should not flush the vertex buffer

// If execute buffer is currently processed
const DWORD D3DPV_INSIDEEXECUTE  = D3DPV_RESERVED2;
// If the vertices are in user memory
const DWORD D3DPV_USERMEMVERTICES = D3DPV_RESERVED3;
//---------------------------------------------------------------------
class CDirect3DDeviceIDP2 : public DIRECT3DDEVICEI
{
public: // data
    static const DWORD dwD3DDefaultVertexBatchSize;
    static const DWORD dwD3DDefaultCommandBatchSize;
    // The buffer we currently batch into
    LPDIRECTDRAWSURFACE4 lpDDSCB1;
    // Pointer to the actual data in CB1
    LPVOID lpvDP2Commands;
    //Pointer to the current position the CB1 buffer
    LPD3DHAL_DP2COMMAND lpDP2CurrCommand;
    D3DHAL_DRAWPRIMITIVES2DATA dp2data;
    DWORD dwDP2CommandLength;
    DWORD dwDP2CommandBufSize;
    BYTE bDP2CurrCmdOP;  // Mirror of Opcode of the current command
    WORD wDP2CurrCmdCnt; // Mirror of Count field if the current command

    // Flags specific to DP2 device
    DWORD dwDP2Flags;
private: // methods
    inline void CDirect3DDeviceIDP2::ClearBatch();
    HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice, DWORD dwVersion);
    HRESULT GrowCommandBuffer(LPDIRECT3DI lpD3DI, DWORD dwSize);
public:
    CDirect3DDeviceIDP2() { deviceType = D3DDEVTYPE_DP2HAL; }

    ~CDirect3DDeviceIDP2(); // Called by CDirect3DDeviceUnk::Release()
    HRESULT FlushStates();
    HRESULT FlushStates(DWORD dwReqSize);
    HRESULT D3DAPI SetRenderStateI(D3DRENDERSTATETYPE, DWORD);
    HRESULT DrawPrim();
    HRESULT DrawIndexPrim();
    HRESULT ExecuteI(LPD3DI_EXECUTEDATA lpExData, DWORD flags);
    HRESULT D3DAPI SetTextureStageState(DWORD dwStage,
                                        D3DTEXTURESTAGESTATETYPE dwState,
                                        DWORD dwValue);
    HRESULT D3DAPI ValidateDevice(LPDWORD lpdwNumPasses);
    HRESULT SetTSSI(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
    // Called from DrawPrimitiveVB if a vertex buffer or TL buffer is used for rendering
    HRESULT StartPrimVB(LPDIRECT3DVERTEXBUFFERI vb, DWORD dwStartVertex);
    // Called if user memory buffer is used for rendering
    HRESULT StartPrimUserMem(LPVOID memory);
    // Called if TL buffer of used memory was used for rendering
    HRESULT EndPrim(DWORD dwVertexPoolSize);

    HRESULT CheckSurfaces();

    // This is the VB interface corresponding to the dp2data.lpDDVertex
    // This is kept so that the VB can be released when done
    // which cannot be done from just the LCL pointer which is lpDDVertex
    CDirect3DVertexBuffer* lpDP2CurrBatchVBI;

    HRESULT UpdateDrvViewInfo(LPD3DVIEWPORT2 lpVwpData);
    HRESULT UpdateDrvWInfo();
    HRESULT UpdatePalette(DWORD,DWORD,DWORD,LPPALETTEENTRY);
    HRESULT SetPalette(DWORD,DWORD,DWORD);
    void SetRenderTargetI(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
    void ClearI(DWORD, DWORD, LPD3DRECT, D3DCOLOR, D3DVALUE, DWORD);
};

//  macros to characterize device

#define IS_DP2HAL_DEVICE(lpDevI) ((lpDevI)->deviceType >= D3DDEVTYPE_DP2HAL)
#define IS_DX7HAL_DEVICE(lpDevI) ((lpDevI)->deviceType >= D3DDEVTYPE_DX7HAL)
#define IS_DX5_COMPATIBLE_DEVICE(lpDevI) ((lpDevI)->dwVersion >= 2)
#define IS_PRE_DX5_DEVICE(lpDevI) ((lpDevI)->dwVersion < 2)
#define IS_MT_DEVICE(lpDevI) ( (lpDevI)->dwHintFlags & D3DDEVBOOL_HINTFLAGS_MULTITHREADED )
#define IS_HW_DEVICE(lpDevI) ((lpDevI)->dwFEFlags & D3DFE_REALHAL)

/*
 * Internal version of Direct3DExecuteBuffer object;
 * it has data after the vtable
 */
class DIRECT3DEXECUTEBUFFERI : public IDirect3DExecuteBuffer,
                               public CD3DAlloc
{
public:
    int             refCnt; /* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DDEVICEI       lpDevI; /* Parent */
    LIST_MEMBER(DIRECT3DEXECUTEBUFFERI)list;
    /* Next buffer in IDirect3D */

    /*** Object Data ***/
    DWORD           pid;    /* Process locking execute buffer */
    D3DEXECUTEBUFFERDESC    debDesc;
    /* Description of the buffer */
    D3DEXECUTEDATA      exData; /* Execute Data */
    bool            locked; /* Is the buffer locked */

    D3DI_BUFFERHANDLE       hBuf; /* Execute buffer handle */
public:
    DIRECT3DEXECUTEBUFFERI();
    ~DIRECT3DEXECUTEBUFFERI();
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DExecuteBuffer Methods
    HRESULT D3DAPI Initialize(LPDIRECT3DDEVICE, LPD3DEXECUTEBUFFERDESC);
    HRESULT D3DAPI Lock(LPD3DEXECUTEBUFFERDESC);
    HRESULT D3DAPI Unlock();
    HRESULT D3DAPI SetExecuteData(LPD3DEXECUTEDATA);
    HRESULT D3DAPI GetExecuteData(LPD3DEXECUTEDATA);
    HRESULT D3DAPI Validate(LPDWORD, LPD3DVALIDATECALLBACK, LPVOID, DWORD);
    HRESULT D3DAPI Optimize(DWORD);
};

/*
 * Internal version of Direct3DLight object;
 * it has data after the vtable
 */

class DIRECT3DLIGHTI : public IDirect3DLight,
                       public CD3DAlloc
{
public:
    int             refCnt; /* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI         lpDirect3DI; /* Parent */
    LIST_MEMBER(DIRECT3DLIGHTI)list;
    /* Next light in IDirect3D */

    LPDIRECT3DVIEWPORTI lpD3DViewportI; /* Guardian */
    CIRCLE_QUEUE_MEMBER(DIRECT3DLIGHTI)light_list;
    /* Next light in IDirect3DViewport */

    /*** Object Data ***/
    D3DLIGHT2           dlLight;        // Data describing light
    D3DI_LIGHT          diLightData;    // Internal representation of light
public:
    DIRECT3DLIGHTI();
    ~DIRECT3DLIGHTI();
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DLight Methods
    HRESULT D3DAPI Initialize(LPDIRECT3D);
    HRESULT D3DAPI SetLight(LPD3DLIGHT);
    HRESULT D3DAPI GetLight(LPD3DLIGHT);
};


/*
 * Internal version of Direct3DMaterial object;
 * it has data after the vtable
 */
class DIRECT3DMATERIALI : public IDirect3DMaterial,
                          public IDirect3DMaterial2,
                          public IDirect3DMaterial3,
                          public CD3DAlloc
{
public:
    int             refCnt; /* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI                lpDirect3DI; /* Parent */
    LIST_MEMBER(DIRECT3DMATERIALI)list;
    /* Next MATERIAL in IDirect3D */

    LIST_ROOT(_mblocks, _D3DI_MATERIALBLOCK)blocks;
    /* devices we're associated with */

    /*** Object Data ***/
    D3DMATERIAL         dmMaterial; /* Data describing material */
    bool            bRes;   /* Is this material reserved in the driver */
public:
    DIRECT3DMATERIALI();
    ~DIRECT3DMATERIALI();
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DMaterial Methods
    HRESULT D3DAPI Initialize(LPDIRECT3D);
    HRESULT D3DAPI SetMaterial(LPD3DMATERIAL);
    HRESULT D3DAPI GetMaterial(LPD3DMATERIAL);
    HRESULT D3DAPI GetHandle(LPDIRECT3DDEVICE, LPD3DMATERIALHANDLE);
    HRESULT D3DAPI Reserve();
    HRESULT D3DAPI Unreserve();

    // IDirect3DMaterial2 Methods
    HRESULT D3DAPI GetHandle(LPDIRECT3DDEVICE2, LPD3DMATERIALHANDLE);

    // IDirect3DMaterial3 Methods
    HRESULT D3DAPI GetHandle(LPDIRECT3DDEVICE3, LPD3DMATERIALHANDLE);
};

/*
 * If we have an aggreate Direct3DTexture we need a structure
 * to represent an unknown interface distinct from the underlying
 * object. This is that structure.
 */

class CDirect3DTextureUnk : public IUnknown
{
public:
    /* Reference count object */
    unsigned refCnt;
public:
    LPDIRECT3DTEXTUREI pTexI;
public:
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();
};

/*
 * Internal version of Direct3DTexture object; it has data after the vtable
 */
class DIRECT3DTEXTUREI : public IDirect3DTexture,
                         public IDirect3DTexture2,
                         public CD3DAlloc
{
public:
    /*** Object Relations ***/
    LIST_ROOT(_blocks, _D3DI_TEXTUREBLOCK) blocks;
    /* Devices we're associated with */

    /*** Object Data ***/
    CDirect3DTextureUnk mTexUnk;

    DDRAWI_DDRAWSURFACE_INT DDSInt4;
    LPDIRECTDRAWSURFACE     lpDDS1Tex;  //we need to keep the legacy
    LPDIRECTDRAWSURFACE4    lpDDS;
    LPDIRECTDRAWSURFACE     lpDDSSys1Tex;  //we need to keep the legacy
    LPDIRECTDRAWSURFACE4    lpDDSSys;
    struct _D3DBUCKET       *lpTMBucket;
    DDSURFACEDESC2          ddsd;
    int                     LogTexSize;
    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN       lpOwningIUnknown; /* The owning IUnknown    */
    bool            bIsPalettized;
    bool            bInUse;
    BOOL            bDirty;
public:
    DIRECT3DTEXTUREI(LPUNKNOWN);
    ~DIRECT3DTEXTUREI();
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DTexture Methods
    HRESULT D3DAPI Initialize(LPDIRECT3DDEVICE, LPDIRECTDRAWSURFACE);
    HRESULT D3DAPI GetHandle(LPDIRECT3DDEVICE, LPD3DTEXTUREHANDLE);
    HRESULT D3DAPI PaletteChanged(DWORD, DWORD);
    HRESULT D3DAPI Load(LPDIRECT3DTEXTURE);
    HRESULT D3DAPI Unload();

    // IDirect3DTexture2 Methods
    HRESULT D3DAPI GetHandle(LPDIRECT3DDEVICE2, LPD3DTEXTUREHANDLE);
    HRESULT D3DAPI Load(LPDIRECT3DTEXTURE2);
};

/*
 * Internal version of Direct3DViewport object; it has data after the vtable
 */
class DIRECT3DVIEWPORTI : public IDirect3DViewport3,
                          public CD3DAlloc
{
public:
    int             refCnt; /* Reference count */

    /*** Object Relations */
    LPDIRECT3DI                 lpDirect3DI; /* Parent */
    LIST_MEMBER(DIRECT3DVIEWPORTI)list;
    /* Next viewport in IDirect3D */

    LPDIRECT3DDEVICEI       lpDevI; /* Guardian */
    CIRCLE_QUEUE_MEMBER(DIRECT3DVIEWPORTI) vw_list;
    /* Next viewport in IDirect3DDevice */

    /* Lights */
    int             numLights;
    CIRCLE_QUEUE_ROOT(_dlights, DIRECT3DLIGHTI) lights;
    /* Associated IDirect3DLights */

    /*** Object Data ***/
    unsigned long       v_id;   /* Id for this viewport */
    D3DVIEWPORT2        v_data;
    BOOL                v_data_is_set;

    // Background Material
    BOOL                    bHaveBackgndMat;
    D3DMATERIALHANDLE       hBackgndMat;

    // Background Depth Surface
    LPDIRECTDRAWSURFACE     lpDDSBackgndDepth;

    // need to save this version of interface for DX6 GetBackgroundDepth
    LPDIRECTDRAWSURFACE4    lpDDSBackgndDepth_DDS4;

    /* Have the lights changed since they
       were last collected? */
    BOOL            bLightsChanged;

    DWORD           clrCount; /* Number of rects allocated */
    LPD3DRECT           clrRects; /* Rects used for clearing */

public:
    DIRECT3DVIEWPORTI(LPDIRECT3DI lpD3DI);
    ~DIRECT3DVIEWPORTI();
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DViewport Methods
    HRESULT D3DAPI Initialize(LPDIRECT3D);
    HRESULT D3DAPI GetViewport(LPD3DVIEWPORT);
    HRESULT D3DAPI SetViewport(LPD3DVIEWPORT);
    HRESULT D3DAPI TransformVertices(DWORD, LPD3DTRANSFORMDATA, DWORD, LPDWORD);
    HRESULT D3DAPI LightElements(DWORD, LPD3DLIGHTDATA);
    HRESULT D3DAPI SetBackground(D3DMATERIALHANDLE);
    HRESULT D3DAPI GetBackground(LPD3DMATERIALHANDLE, LPBOOL);
    HRESULT D3DAPI SetBackgroundDepth(LPDIRECTDRAWSURFACE);
    HRESULT D3DAPI GetBackgroundDepth(LPDIRECTDRAWSURFACE*, LPBOOL);
    HRESULT D3DAPI SetBackgroundDepth2(LPDIRECTDRAWSURFACE4);
    HRESULT D3DAPI GetBackgroundDepth2(LPDIRECTDRAWSURFACE4*, LPBOOL);
    HRESULT D3DAPI Clear(DWORD, LPD3DRECT, DWORD);
    HRESULT D3DAPI AddLight(LPDIRECT3DLIGHT);
    HRESULT D3DAPI DeleteLight(LPDIRECT3DLIGHT);
    HRESULT D3DAPI NextLight(LPDIRECT3DLIGHT, LPDIRECT3DLIGHT*, DWORD);

    // IDirect3DViewport2 Methods
    HRESULT D3DAPI GetViewport2(LPD3DVIEWPORT2);
    HRESULT D3DAPI SetViewport2(LPD3DVIEWPORT2);

    // IDirect3DViewport3 Methods
    HRESULT D3DAPI Clear2(DWORD, LPD3DRECT, DWORD, D3DCOLOR, D3DVALUE, DWORD);
};

// Internal VB create flag:
#define D3DVBFLAGS_CREATEMULTIBUFFER    0x80000000L

class CDirect3DVertexBuffer : public IDirect3DVertexBuffer,
                              public CD3DAlloc
{
private:
    HRESULT CreateMemoryBuffer(LPDIRECT3DI lpD3DI,
                               LPDIRECTDRAWSURFACE4 *lplpSurface4,
                               LPDIRECTDRAWSURFACE  *lplpS,
                               LPVOID *lplpMemory,
                               DWORD dwBufferSize,
                               DWORD dwFlags);
    int             refCnt; /* Reference count */

    /*** Object Relations */
    LPDIRECT3DI                 lpDirect3DI; /* Parent */
    LIST_MEMBER(CDirect3DVertexBuffer)list;  /* Next vertex buffer in IDirect3D */

    // Internal data
    DWORD dwCaps;
    DWORD dwNumVertices;
    DWORD dwLockCnt;
    DWORD dwMemType;
    DWORD srcVOP, dstVOP;
    D3DVERTEXTYPE legacyVertexType;
    DWORD dwPVFlags;
    DWORD nTexCoord;
    /* position.lpData = start of vertex buffer data
     * position.dwStride = Number of bytes per vertex
     */
    union {
        D3DDP_PTRSTRIDE position;
        D3DDP_PTRSTRIDE SOA;
    };
    DWORD fvf; // Used in Input and Output
    D3DFE_CLIPCODE* clipCodes;
    LPDIRECTDRAWSURFACE4 lpDDSVB; // DDraw Surface containing the actual VB memory
    LPDIRECTDRAWSURFACE lpDDS1VB; // same dds, legacy interface for legacy hal.
    BOOL bReallyOptimized;        // VB could have OPTIMIZED caps set, but be
                                  // not optimized
    LPDIRECT3DDEVICEI lpDevIBatched; // Is this VB batched in a device ? If so we need to flush the device
                                     // on Lock
    // Friends
    friend void hookVertexBufferToD3D(LPDIRECT3DI, LPDIRECT3DVERTEXBUFFERI);
    friend class DIRECT3DDEVICEI;
public:
    CDirect3DVertexBuffer(LPDIRECT3DI);
    ~CDirect3DVertexBuffer();
    HRESULT Init(LPDIRECT3DI, LPD3DVERTEXBUFFERDESC, DWORD);
    LPDIRECTDRAWSURFACE GetDDS() { return lpDDS1VB; }
    HRESULT Restore() { return lpDDSVB->Restore(); }
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DVertexBuffer Methods
    HRESULT D3DAPI Lock(DWORD, LPVOID*, LPDWORD);
    HRESULT D3DAPI Unlock();
    HRESULT D3DAPI ProcessVertices(DWORD, DWORD, DWORD, LPDIRECT3DVERTEXBUFFER, DWORD, LPDIRECT3DDEVICE3, DWORD);
    HRESULT D3DAPI GetVertexBufferDesc(LPD3DVERTEXBUFFERDESC);
    HRESULT D3DAPI Optimize(LPDIRECT3DDEVICE3 lpDevI, DWORD dwFlags);
protected:
    // Internal Lock
    HRESULT D3DAPI LockI(DWORD, LPVOID*, LPDWORD);
};

// Now that LPDIRECT3DVERTEXBUFFERI is defined...
inline CDirect3DVertexBuffer* CBufferVB::GetVBI()
{
    return static_cast<CDirect3DVertexBuffer*>(allocatedBuf);
}

inline LPDIRECTDRAWSURFACE CBufferVB::GetDDS()
{
    return GetVBI()->GetDDS();
}

// The instance of the class providing a guaranteed implementation
// This is defined / instantiated in pipeln\helxfrm.cpp
extern D3DFE_PVFUNCS GeometryFuncsGuaranteed;

extern void
D3DDeviceDescConvert(LPD3DDEVICEDESC lpOut,
                     LPD3DDEVICEDESC_V1 lpV1,
                     LPD3DHAL_D3DEXTENDEDCAPS lpExt);

#endif
// @@END_MSINTERNAL

#endif /* _D3DI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\d3dmem.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dmem.h
 *  Content:    Direct3D memory access include file
 *
 ***************************************************************************/
#ifndef _D3DMEM_H_
#define _D3DMEM_H_

 class DIRECT3DDEVICEI;

 /*
 * Register a set of functions to be used in place of malloc, realloc
 * and free for memory allocation.  The functions D3DMalloc, D3DRealloc
 * and D3DFree will use these functions.  The default is to use the
 * ANSI C library routines malloc, realloc and free.
 */
typedef LPVOID (*D3DMALLOCFUNCTION)(size_t);
typedef LPVOID (*D3DREALLOCFUNCTION)(LPVOID, size_t);
typedef VOID (*D3DFREEFUNCTION)(LPVOID);

/*
 * Allocate size bytes of memory and return a pointer to it in *p_return.
 * Returns D3DERR_BADALLOC with *p_return unchanged if the allocation fails.
 */
HRESULT D3DAPI      D3DMalloc(LPVOID* p_return, size_t size);

/*
 * Change the size of an allocated block of memory.  A pointer to the
 * block is passed in in *p_inout.  If *p_inout is NULL then a new
 * block is allocated.  If the reallocation is successful, *p_inout is
 * changed to point to the new block.  If the allocation fails,
 * *p_inout is unchanged and D3DERR_BADALLOC is returned.
 */
HRESULT D3DAPI      D3DRealloc(LPVOID* p_inout, size_t size);

/*
 * Free a block of memory previously allocated with D3DMalloc or
 * D3DRealloc.
 */
VOID D3DAPI     D3DFree(LPVOID p);

HRESULT MallocAligned(void** p_return, size_t size);
void FreeAligned(void* p);
HRESULT ReallocAligned(void** p_inout, size_t size);

/* Base class for all D3D classes to use our special allocation functions everywhere */
class CD3DAlloc
{
public:
    void* operator new(size_t s)
    {
        void *p;
        MallocAligned(&p,s);
        return p;
    };
    void operator delete(void* p)
    {
        FreeAligned(p);
    };
};
//---------------------------------------------------------------------
// This class manages growing buffer, aligned to 32 byte boundary
// Number if bytes should be power of 2.
// D3DMalloc is used to allocate memory
//
class CAlignedBuffer32
{
public:
    CAlignedBuffer32()  {size = 0; allocatedBuf = 0; alignedBuf = 0;}
    ~CAlignedBuffer32() {if (allocatedBuf) D3DFree(allocatedBuf);}
    // Returns aligned buffer address
    LPVOID GetAddress() {return alignedBuf;}
    // Returns aligned buffer size
    DWORD GetSize() {return size;}
    HRESULT Grow(DWORD dwSize);
    HRESULT CheckAndGrow(DWORD dwSize)
        {
            if (dwSize > size)
                return Grow(dwSize + 1024);
            else
                return D3D_OK;
        }
protected:
    LPVOID allocatedBuf;
    LPVOID alignedBuf;
    DWORD  size;
};

// Forward declarations
class DIRECT3DDEVICEI;
class CDirect3DVertexBuffer;
class CDirect3DDeviceIDP2;
//----------------------------------------------------------------------
// This class manages a growing buffer using DDraw Surfaces.
class CBufferDDS
{
protected:
    LPDIRECTDRAWSURFACE allocatedBuf;
    LPVOID alignedBuf;
    DWORD  size;
public:
    CBufferDDS()
    {
        size = 0;
        allocatedBuf = 0;
        alignedBuf = 0;
    }
    ~CBufferDDS()
    {
        if (allocatedBuf)
            allocatedBuf->Release();
    }
    // Returns aligned buffer address
    LPVOID GetAddress()
    {
        return (LPBYTE)alignedBuf;
    }
    // Returns aligned buffer size
    DWORD GetSize()
    {
        return size;
    }
    LPDIRECTDRAWSURFACE GetDDS()
    {
        return allocatedBuf;
    }
    HRESULT CheckAndGrow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize)
    {
        if (dwSize > size)
            return Grow(lpDevI, dwSize + 1024);
        else
            return D3D_OK;
    }
    HRESULT Grow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize);
    // define these later on in this file after CDirect3DVertexBuffer is defined
};
//----------------------------------------------------------------------
// This class manages a growing vertex buffer.
// Allocate it in driver friendly memory.
// Do not use except for DP2 DDI
class CBufferVB
{
protected:
    LPDIRECT3DVERTEXBUFFER allocatedBuf;
    LPVOID alignedBuf;
    DWORD  size, base;
public:
    CBufferVB()
    {
        size = 0;
        allocatedBuf = 0;
        alignedBuf = 0;
        base = 0;
    }
    ~CBufferVB()
    {
        if (allocatedBuf)
            allocatedBuf->Release();
    }
    // Returns aligned buffer address
    LPVOID GetAddress()
    {
        return (LPBYTE)alignedBuf + base;
    }
    // Returns aligned buffer size
    DWORD GetSize() { return size - base; }
    HRESULT Grow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize);
    DWORD& Base() { return base; }
    // define these later on in this file after CDirect3DVertexBuffer is defined
    inline CDirect3DVertexBuffer* GetVBI();
    inline LPDIRECTDRAWSURFACE GetDDS();
    HRESULT CheckAndGrow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize)
        {
            if (dwSize > size)
                return Grow(lpDevI, dwSize + 1024);
            else
                return D3D_OK;
        }
    friend CDirect3DDeviceIDP2;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\dditypes.hpp ===
/*
 * $Id: dditypes.h,v 1.28 1995/11/21 14:46:07 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef __DDITYPES_H__
#define __DDITYPES_H__

#include "d3di.hpp"


#endif /* dditypes.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\fltval.h ===
/*
 * $Id: fltval.h,v 1.7 1995/12/01 18:07:12 dave Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef __D3DFLOAT__
#define __D3DFLOAT__

/*
 * Convert a value to fixed point at given precision.
 */
#define VALTOFXP(d,prec) ((int)SAFE_FLOAT_TO_INT((d) * (double)(1 << (prec))))
extern double RLDDIConvertIEEE[];

__inline int QVALTOFXP(double d, int prec)
{
    double tmp = d+RLDDIConvertIEEE[prec];
    return *(int *)&tmp;
}

/*
 * Convert from fixed point to value.
 */
#define FXPTOVAL(f,prec) ((float)(((double)(f)) / (double)(1 << (prec))))

/*
 * Convert from integer to fixed point.
 */
#define ITOFXP(i,prec)	((i) << (prec))

/*
 * Convert from fixed point to integer, truncating.
 */
#define FXPTOI(f,prec)	((int)((f) >> (prec)))

/*
 * Convert from fixed point to nearest integer greater or equal to f.
 */
#define FXPCEIL(f,prec) ((int)(((f) + (1 << (prec)) - 1) >> (prec)))

/*
 * Convert a double to fixed point at given precision.
 */
#define DTOVALP(d,prec) ((float) (d))

/*
 * Convert from fixed point to double.
 */
#define VALPTOD(f,prec)	((double) (f))

/*
 * Convert from integer to fixed point.
 */
#define ITOVALP(i,prec) ((float)(i))

/*
 * Convert from fixed point to integer, truncating.
 */
#define VALPTOI(f,prec)	((int)(f))

/*
 * Convert from fixed point to integer, rounding.
 */
#define VALPROUND(f,prec) ((int)((f) + 0.5))

/*
 * Convert between fixed point precisions.
 */
#define VALPTOVALP(f,from,to) (f)

/*
 * Increase the precision of a value.
 */
#define INCPREC(f,amount)	(f)

/*
 * Decrease the precision of a value.
 */
#define DECPREC(f,amount)	(f)

#define RLDDIFMul8(a, b)		((a) * (b))

#define RLDDIFMul12(a, b)		((a) * (b))

#define RLDDIFMul16(a, b)		((a) * (b))

#define RLDDIFMul24(a, b)		((a) * (b))

#define RLDDIFInvert12(a)		(1.0f / (a))

#define RLDDIFInvert16(a)		(1.0f / (a))

#define RLDDIFInvert24(a)		(1.0f / (a))

#define RLDDIFMulDiv(a, b, c)	((a) * (b) / (c))

#define RLDDIFDiv24(a, b)		((a) / (b))

#define RLDDIFDiv16(a, b)		((a) / (b))

#define RLDDIFDiv12(a, b)		((a) / (b))

#define RLDDIFDiv8(a, b)		((a) / (b))

/*
 * RLDDIFDiv8, checking for overflow.
 */
#define RLDDICheckDiv8(a, b)      ((a) / (b))

/*
 * RLDDIFDiv16, checking for overflow.
 */
#define RLDDICheckDiv16(a, b)	((a) / (b))

#define RLDDIGetZStep(zl, zr, zm, h3, h1) \
	(((zr - zm) * h3 - (zl - zm) * h1) / denom)

#if defined(i386)
#include <limits.h>
#define SAFE_FLOAT_TO_INT(f)	((f) > LONG_MAX	   \
				 ? LONG_MAX				           \
				 : (f) < LONG_MIN			       \
				 ? LONG_MIN				           \
                                 : (int)(f))
#else
#define SAFE_FLOAT_TO_INT(f)    ((int)(f))
#endif

/*
 * Normal precision used to store numbers.
 */
#define NORMAL_PREC     16
#define DTOVAL(d)       DTOVALP(d,NORMAL_PREC)
#define VALTOD(f)       VALPTOD(f,NORMAL_PREC)
#define ITOVAL(i)       ITOVALP(i,NORMAL_PREC)
#define VALTOI(f)       VALPTOI(f,NORMAL_PREC)
#define VALROUND(f)     VALPROUND(f,NORMAL_PREC)
#define VALTOFX(f)      VALTOFXP(f,NORMAL_PREC)
#define FXTOVAL(f)      FXPTOVAL(f,NORMAL_PREC)
#define ITOFX(i)        ITOFXP(i,NORMAL_PREC)
#define FXTOI(f)        FXPTOI(f,NORMAL_PREC)
#define FXROUND(f)      FXPROUND(f,NORMAL_PREC)
#define FXFLOOR(f)      FXPTOI(f,NORMAL_PREC)
#define FXCEIL(f)       FXPCEIL(f,NORMAL_PREC)
#define VALTOFX24(f)    VALTOFXP(f,24)
#define FX24TOVAL(f)    FXPTOVAL(f,24)
#define VALTOFX20(f)    VALTOFXP(f,20)
#define FX20TOVAL(f)    FXPTOVAL(f,20)
#define VALTOFX12(f)    VALTOFXP(f,12)
#define FX12TOVAL(f)    FXPTOVAL(f,12)
#define VALTOFX8(f)     VALTOFXP(f,8)
#define FX8TOVAL(f)     FXPTOVAL(f,8)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\d3dfe.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dfe.hpp
 *  Content:    Direct3D internal include file
 *              for geometry pipeline implementations
 *
 ***************************************************************************/
#ifndef _D3DFE_H

// this is not available for alpha or IA64
#ifndef LONG_MAX
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#endif

//--------------------------------------------------------------------
// Base definitions
//

// Default color values that should be used when ther is no lighting and
// color in vertices provided
const DWORD __DEFAULT_DIFFUSE = 0xFFFFFFFF;
const DWORD __DEFAULT_SPECULAR = 0;


typedef WORD D3DFE_CLIPCODE;

//---------------------------------------------------------------------
typedef struct _RECTV
{
    union
    {
        D3DVALUE x1;
        D3DVALUE dvX1;
    };
    union
    {
        D3DVALUE y1;
        D3DVALUE dvY1;
    };
    union
    {
        D3DVALUE x2;
        D3DVALUE dvX2;
    };
    union
    {
        D3DVALUE y2;
        D3DVALUE dvY2;
    };
} D3DRECTV, *LPD3DRECTV;
//---------------------------------------------------------------------
/*
 * Transform defines
 */
/*
 * Internal version of D3DTRANSFORMDATA
 * The difference is that drExtent is D3DRECTV instead of D3DRECT
 */
typedef struct _D3DTRANSFORMDATAI
{
    DWORD        dwSize;
    LPVOID       lpIn;           /* Input vertices */
    DWORD        dwInSize;       /* Stride of input vertices */
    LPVOID       lpOut;          /* Output vertices */
    DWORD        dwOutSize;      /* Stride of output vertices */
    LPD3DHVERTEX lpHOut;         /* Output homogeneous vertices */
    DWORD        dwClip;         /* Clipping hint */
    DWORD        dwClipIntersection;
    DWORD        dwClipUnion;    /* Union of all clip flags */
    D3DRECTV     drExtent;       /* Extent of transformed vertices */
} D3DTRANSFORMDATAI, *LPD3DTRANSFORMDATAI;
//---------------------------------------------------------------------
typedef enum _D3MATRIXTYPEI
{
    D3DIMatrixIdentity,
    D3DIMatrixTranslate,
    D3DIMatrixRotateTranslate,
    D3DIMatrixAffine,
    D3DIMatrixGeneral
} D3DMATRIXTYPEI;
//---------------------------------------------------------------------
// "link" member should be the last, because we copy the structure using
// offsetof(D3DMATRIXI, link)
//
typedef struct _D3DMATRIXI
{
    D3DVALUE            _11, _12, _13, _14;
    D3DVALUE            _21, _22, _23, _24;
    D3DVALUE            _31, _32, _33, _34;
    D3DVALUE            _41, _42, _43, _44;
    D3DMATRIXTYPEI      type;
    LIST_MEMBER(_D3DMATRIXI) link;
} D3DMATRIXI, *LPD3DMATRIXI;
//---------------------------------------------------------------------
struct _D3DFE_LIGHTING;
typedef struct _D3DFE_LIGHTING D3DFE_LIGHTING;

struct _D3DI_LIGHT;
typedef struct _D3DI_LIGHT D3DI_LIGHT;

class D3DFE_PROCESSVERTICES;
typedef class D3DFE_PROCESSVERTICES* LPD3DFE_PROCESSVERTICES;

extern "C"
{
typedef void (*LIGHT_VERTEX_FUNC)(LPD3DFE_PROCESSVERTICES pv,
                                  D3DI_LIGHT *light,
                                  D3DLIGHTINGELEMENT *in);
}
//---------------------------------------------------------------------
/*
 * Lighting defines
 */
typedef struct _SpecularTable
{
    LIST_MEMBER(_SpecularTable) list;
    float   power;          /* shininess power */
    float   table[260];     /* space for overflows */
} SpecularTable;

typedef struct {D3DVALUE r,g,b;} D3DFE_COLOR;
//---------------------------------------------------------------------
// Internal version of lightdata and constants for flags
//
#define D3DLIGHTI_ATT0_IS_NONZERO   (0x00010000)
#define D3DLIGHTI_ATT1_IS_NONZERO   (0x00020000)
#define D3DLIGHTI_ATT2_IS_NONZERO   (0x00040000)
#define D3DLIGHTI_LINEAR_FALLOFF    (0x00080000)
#define D3DLIGHTI_UNIT_SCALE        (0x00100000)
#define D3DLIGHTI_LIGHT_AT_EYE      (0x00200000)
#define D3DLIGHTI_COMPUTE_SPECULAR  (0x00400000)
//--------------------------------------------------------------------
// Members of this structure should be aligned as stated
typedef struct _D3DI_LIGHT
{
    // Should be QWORD aligned
    D3DVECTOR       model_position;
    D3DLIGHTTYPE    type;
    // Should be QWORD aligned
    D3DVECTOR       model_direction;
    DWORD           version;        // matches number on D3DLIGHT struct
    // Should be QWORD aligned
    D3DVECTOR       model_eye;      // direction from eye in model space
    DWORD           flags;
    // Should be QWORD aligned
    D3DVECTOR       model_scale;    // model scale for proper range computations
    D3DVALUE        falloff;
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DVALUE        local_diffR;    // Material diffuse times light color
    D3DVALUE        local_diffG;
    D3DVALUE        local_diffB;
    BOOL            valid;
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DVALUE        local_specR;    // Material specular times light color
    D3DVALUE        local_specG;
    D3DVALUE        local_specB;
    D3DVALUE        inv_theta_minus_phi;
    // Should be QWORD aligned
    D3DVECTOR       halfway;
    struct _D3DI_LIGHT *next;           // Next in the active light list
    // Should be QWORD aligned
    D3DVALUE        red, green, blue, shade;

    LIGHT_VERTEX_FUNC lightVertexFunc;  // Function to light a D3DVERTEX

    D3DVALUE        range_squared;
    D3DVALUE        attenuation0;
    D3DVALUE        attenuation1;
    D3DVALUE        attenuation2;
    D3DVALUE        cos_theta_by_2;
    D3DVALUE        cos_phi_by_2;
    D3DVECTOR       position;
    D3DVECTOR       direction;
    D3DVALUE        range;
} D3DI_LIGHT, *LPD3DI_LIGHT;
//---------------------------------------------------------------------
// Members of this structure should be aligned as stated
//
typedef struct _D3DFE_LIGHTING
{
// Temporary data used when computing lighting
    // Should be QWORD aligned
    D3DFE_COLOR       diffuse;
    int               alpha;          // Alpha to use for output vertex color
                                      // (could be overriden by vertex difuse
                                      // color) (0-255) shifted left by 24 bits
    // Should be QWORD aligned
    D3DFE_COLOR       diffuse0;       // Ca*Cma + Cme
    float            *currentSpecTable;
    // Should be QWORD aligned
    D3DFE_COLOR       specular;
    DWORD             outDiffuse;     // Result of lighting
    // Should be QWORD aligned
    D3DFE_COLOR       vertexDiffuse;  // Provided with a vertex
    DWORD             outSpecular;    // Result of lighting
    // Should be QWORD aligned
    D3DFE_COLOR       vertexSpecular; // Provided with a vertex
    BOOL              specularComputed;
// End of temporary data
    D3DI_LIGHT       *activeLights;
    D3DMATERIAL       material;
    D3DMATERIALHANDLE hMat;
    D3DVALUE          ambient_red;    // Scaled to 0 - 255
    D3DVALUE          ambient_green;  // Scaled to 0 - 255
    D3DVALUE          ambient_blue;   // Scaled to 0 - 255
    int               fog_mode;
    D3DVALUE          fog_density;
    D3DVALUE          fog_start;
    D3DVALUE          fog_end;
    D3DVALUE          fog_factor;     // 255 / (fog_end - fog_start)
    D3DVALUE          fog_factor_ramp;// 1 / (fog_end - fog_start)
    D3DVALUE          specThreshold;  // If a dot product less than this value,
                                      // specular factor is zero
    D3DCOLORMODEL     color_model;
    DWORD             ambient_save;   // Original unscaled color
    int               materialAlpha;  // Current material alpha (0-255) shifted
                                      // left by 24 bits
} D3DFE_LIGHTING;
//---------------------------------------------------------------------
// Some data precomputed for a current viewport
// ATTENTION: If you want to add or re-arrange data, contact IOURIT or ANUJG
//
typedef struct _D3DFE_VIEWPORTCACHE
{
// Coefficients to compute screen coordinates from normalized window
// coordinates
    D3DVALUE scaleX;            // dvWidth/2
    D3DVALUE scaleY;            // dvHeight/2
    D3DVALUE offsetX;           // dvX + scaleX
    D3DVALUE offsetY;           // dvY + scaleY
// Min and max window values with gaurd band in pixels
    D3DVALUE minXgb;
    D3DVALUE minYgb;
    D3DVALUE maxXgb;
    D3DVALUE maxYgb;
// Min and max values for viewport window in pixels
    D3DVALUE minX;              // offsetX - scaleX
    D3DVALUE minY;              // offsetY - scaleY
    D3DVALUE maxX;              // offsetX + scaleX
    D3DVALUE maxY;              // offsetY + scaleY
// Coefficients to transform a vertex to perform the guard band clipping
// x*gb11 + w*gb41
// y*gb22 + w*gb42
//
    D3DVALUE gb11;
    D3DVALUE gb22;
    D3DVALUE gb41;
    D3DVALUE gb42;
// Coefficients to apply clipping rules for the guard band clipping
// They are used by clipping routins
// w*Kgbx1 < x < w*Kgbx2
// w*Kgby1 < y < w*Kgby2
//
    D3DVALUE Kgbx1;
    D3DVALUE Kgby1;
    D3DVALUE Kgbx2;
    D3DVALUE Kgby2;

    D3DVALUE dvX;               // dwX
    D3DVALUE dvY;               // dwY
    D3DVALUE dvWidth;           // dwWidth
    D3DVALUE dvHeight;          // dwHeight
// Coefficients to compute screen coordinates from normalized window
// coordinates
    D3DVALUE scaleXi;           // Inverse of scaleX
    D3DVALUE scaleYi;           // Inverse of scaleY
// Min and max values for viewport window in pixels (integer version)
    int      minXi;             // offsetX - scaleX
    int      minYi;             // offsetY - scaleY
    int      maxXi;             // offsetX + scaleX
    int      maxYi;             // offsetY + scaleY
// Mclip matrix. mclip44=1. Other Mclip(i,j)=0
    D3DVALUE mclip11;           // 2/dvClipWidth
    D3DVALUE mclip41;           // -(1+2*dvClipX/dvClipWidth)
    D3DVALUE mclip22;           // 2/dvClipHeight
    D3DVALUE mclip42;           // (1-2*dvClipY/dvClipHeight)
    D3DVALUE mclip33;           // 1/(dvMaxZ-dvMinZ)
    D3DVALUE mclip43;           // -dvMinZ*mclip33
// Inverse Mclip matrix. We need this matrix to transform vertices from clip
// space to homogineous space (after Mproj). We need this when user calls
// Transform Vertices. This matrix is computed only when it is needed.
    D3DVALUE imclip11;
    D3DVALUE imclip41;
    D3DVALUE imclip22;
    D3DVALUE imclip42;
    D3DVALUE imclip33;
    D3DVALUE imclip43;
} D3DFE_VIEWPORTCACHE;
//---------------------------------------------------------------------
// Process vertices interface
//
// Bits for process vertices flags
// 8 bits are reserved for Draw Primitive flags
//
// D3DPV_STRIDE D3DPV_SOA
//      0         1       position.dwStride = number of vertices in SOA
//      0         0       position.dwStride = contiguous vertex size
//      1         0       vertex is not contiguous, all dwStride fields are used
//      1         1       reserved
//      1         1       reserved
//
const DWORD D3DPV_FOG            = 1 << 8;  // Need to apply fog
const DWORD D3DPV_AFFINEMATRIX   = 1 << 9;  // Last matrix column is (0,0,1,x)
const DWORD D3DPV_LIGHTING       = 1 << 10; // Need to apply lighting
const DWORD D3DPV_SOA            = 1 << 12; // SOA structure is used
const DWORD D3DPV_STRIDE         = 1 << 13; // Strides are used
const DWORD D3DPV_COLORVERTEX    = 1 << 14; // Diffuse color vertex
const DWORD D3DPV_COLORVERTEXS   = 1 << 15; // Specular color vertex
// These two flags should NOT be used. Use D3DDEV_.. instead
const DWORD D3DPV_TRANSFORMDIRTY = 1 << 16; // Transform matrix has been changed
const DWORD D3DPV_LIGHTSDIRTY    = 1 << 17; // Lights have been changed

const DWORD D3DPV_COMPUTESPECULAR= 1 << 18; // Specular highlights are enabled
const DWORD D3DPV_RANGEBASEDFOG  = 1 << 19; // Do range based fog
const DWORD D3DPV_GOODPROJMATRIX = 1 << 20; // "Good" projection matrix (All
                                            // members except M11 M22 M33 M43
                                            // M34 are zero)
const DWORD D3DPV_CLIPPERPRIM    = 1 << 21; // This indicates that the primitive
                                            // was generated by clipping. This allows
                                            // DP2HAL to inline the primitive. Can
                                            // only by tri fan or line list.
const DWORD D3DPV_RESERVED1      = 1 << 22;
const DWORD D3DPV_RESERVED2      = 1 << 23;
const DWORD D3DPV_RESERVED3      = 1 << 24;
// This indicates that the primitive is non clipped, but we pretend that it is
// clipped to generate DP2HAL inline primitive. Can only be set by tri fan.
const DWORD D3DPV_NONCLIPPED     = 1 << 25;
// Propagated from dwFEFlags
const DWORD D3DPV_FRUSTUMPLANES_DIRTY = 1 << 26;
// Set if the geometry loop is called from VertexBuffer::ProcessVertices.
// Processing is different because the output buffer FVF format is defined by
// user, not by ComputeOutputFVF function.
const DWORD D3DPV_VBCALL         = 1 << 27;
const DWORD D3DPV_RAMPSPECULAR   = 1 << 28; // whether ramp map was made with specular
const DWORD D3DPV_TLVCLIP        = 1 << 29; // To mark whether we are doing TLVERTEX clipping or not
// Bits for dwDeviceFlags
//
const DWORD D3DDEV_GUARDBAND     = 1 << 1;  // Use guard band clipping
const DWORD D3DDEV_PREDX5DEVICE  = 1 << 2;  // Device version is older than DX5
const DWORD D3DDEV_RAMP          = 1 << 3;  // Ramp mode is used
const DWORD D3DDEV_FVF           = 1 << 4;  // FVF supported
const DWORD D3DDEV_PREDX6DEVICE  = 1 << 5;  // Device version is older than DX6
const DWORD D3DDEV_DONOTSTRIPELEMENTS = 1 << 6; // Copy of D3DFVFCAPS_DONOTSTRIPELEMENTS

// These are bits in dwDeviceFlags that could be changed, but not
// necessary per every primitive.

// If D3DRENDERSTATE_TEXTUREHANDLE was set by API to not NULL
const DWORD D3DDEV_LEGACYTEXTURE  = 1 << 16;
// These flags should be used instead of D3DPV_...
const DWORD D3DDEV_TRANSFORMDIRTY = 1 << 17; // Transform matrix has been changed
const DWORD D3DDEV_LIGHTSDIRTY    = 1 << 18; // Lights have been changed
//--------------------------------------------------------------------
// Clipper defines
//

// Six standard clipping planes plus six user defined clipping planes.
// See rl\d3d\d3d\d3dtypes.h.
//

#define MAX_CLIPPING_PLANES 12

// Space for vertices generated/copied while clipping one triangle

#define MAX_CLIP_VERTICES   (( 2 * MAX_CLIPPING_PLANES ) + 3 )

// 3 verts. -> 1 tri, 4 v -> 2 t, N vertices -> (N - 2) triangles

#define MAX_CLIP_TRIANGLES  ( MAX_CLIP_VERTICES - 2 )

const DWORD MAX_FVF_TEXCOORD = 8;

typedef struct _CLIP_TEXTURE
{
    D3DVALUE u, v;
} CLIP_TEXTURE;

typedef struct _ClipVertex
{
    D3DCOLOR     color;
    D3DCOLOR     specular;
    D3DVALUE     sx;
    D3DVALUE     sy;
    D3DVALUE     sz;
    D3DVALUE     hx;
    D3DVALUE     hy;
    D3DVALUE     hz;
    D3DVALUE     hw;
    CLIP_TEXTURE tex[MAX_FVF_TEXCOORD];
    int     clip;
} ClipVertex;

typedef struct _ClipTriangle
{
    ClipVertex  *v[3];
    unsigned short flags;
} ClipTriangle;

typedef struct _D3DI_CLIPSTATE
{
    ClipVertex  *clip_vbuf1[MAX_CLIP_VERTICES];
    ClipVertex  *clip_vbuf2[MAX_CLIP_VERTICES];
    ClipVertex **current_vbuf;  // clip_vbuf1 or clip_vbuf2
    ClipVertex  clip_vertices[MAX_CLIP_VERTICES];
    CBufferDDS   clipBuf;      // Used for TL vertices, generated by the clipper
    CBufferDDS   clipBufPrim;  // Used for primitives, generated by the clipper
                              // for execute buffers
    int         clip_vertices_used;
    DWORD       clip_color;
    DWORD       clip_specular;
    LPDIRECTDRAWSURFACE lpDDExeBuf; // Current user execute buffer
    LPVOID      lpvExeBufMem;       // Current memory for user execute buffer
} D3DI_CLIPSTATE, *LPD3DI_CLIPSTATE;
//---------------------------------------------------------------------
// Visible states, input and output data
//
class D3DFE_PROCESSVERTICES
{
public:
// State
    DWORD    dwRampBase;            // Parameters to compute ramp color. They are
    D3DVALUE dvRampScale;           // constant for a material.
    LPVOID   lpvRampTexture;
    // Should be 32 bytes aligned
    D3DMATRIXI mCTM;                // Current Transformation Matrix
    DWORD dwMaxTextureIndices;      // Max number of texture coord sets
                                    // supported by driver
    // Should be QWORD aligned
    D3DFE_LIGHTING lighting;        // Lighting state
    D3DVALUE dvExtentsAdjust;       // Replicated here from device caps
    // Should be QWORD aligned
    D3DFE_VIEWPORTCACHE vcache;     // Data, computed fromto viewport settings
    DWORD   dwClipUnion;            // OR of all vertex clip flags
    DWORD   dwClipIntersection;     // AND of all vertex clip flags
    union
    {
    DWORD   dwTextureIndexToCopy;   // Used for not FVF devices. Used by PSGP
    DWORD   dwMaxUsedTextureIndex;  // Used for FVF devices. PSGP do not use it.
    };

    // Current texture stage vector
    LPVOID   *pD3DMappedTexI;
    D3DI_CLIPSTATE  ClipperState;   // State for triangle/line clipper
    union {
        D3DDP_PTRSTRIDE normal;
        DWORD dwSOAStartVertex;
    };
    D3DDP_PTRSTRIDE diffuse;
    D3DDP_PTRSTRIDE specular;
// Cache line starts here
    // Location of the first vertex in the vertex buffer (DP2 DDI)
    // ATTENTION May be we can get rid of it?
    DWORD dwVertexBase;

// Input
    DWORD   dwDeviceFlags;          // Flags that are constant per device
                                    // D3DPV_.. and primitive flags are combined
    LPVOID  lpvOut;                 // Output pointer (output always packed)
    D3DFE_CLIPCODE* lpClipFlags;          // Clip flags to output
    DWORD   dwNumIndices;           // 0 for non-indexed primitive
    LPWORD  lpwIndices;
    union {
        D3DDP_PTRSTRIDE position;   // dwStride should always be set !!!
        D3DDP_PTRSTRIDE SOA;
    };
// Cache line starts here
    DWORD   dwFlags;                // Flags word describing what to do
    DWORD   dwNumVertices;          // Number of vertices to process
    DWORD   dwNumPrimitives;
    D3DPRIMITIVETYPE primType;
    DWORD   dwVIDIn;                // Vertex ID of input vertices
    DWORD   dwVIDOut;               // Vertex ID of output vertices
    DWORD   dwOutputSize;           // Size of output vertices
    DWORD   nTexCoord;              // Number of the texture coordinate sets
// Cache line starts here
    D3DDP_PTRSTRIDE textures[D3DDP_MAXTEXCOORD];
// Cache line starts here
// Output
    LPDWORD  lpdwRStates;           // Current render state vector
    D3DRECTV rExtents;              // Extents rectangle to update, if required
    D3DMATRIXI mWV;                 // Transforms to camera space (Mworld*Mview)
    virtual HRESULT DrawPrim()=0;             // Use to pass non-indexed primitives to the driver
    virtual HRESULT DrawIndexPrim()=0;      // Use to pass indexed primitives to driver
};
// Prototype for the function to be written for a given processor implementation
//
// Returns clip intersection.
//

class ID3DFE_PVFUNCS
{
public:
    virtual ~ID3DFE_PVFUNCS() { };
    virtual DWORD ProcessVertices(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessPrimitive(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessIndexedPrimitive(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT OptimizeVertexBuffer
        (DWORD  dwFVFID,            // Vertex type. XYZ position is allowed
         DWORD  dwNumVertices,      // Number of vertices
         DWORD  dwVertexSize,       // Vertex size in bytes
         LPVOID lpSrcBuffer,        // Source buffer.
         LPVOID lpDstBuffer,        // Output buffer.
         DWORD  dwFlags)            // Should be zero for now
        {return E_NOTIMPL;}
    // Returns number of bytes to allocate for an optimized vertex buffer
    // This function is called before OptimizeVertexBuffer
    virtual DWORD  ComputeOptimizedVertexBufferSize
        (DWORD dwFVF,               // Vertex type
         DWORD dwVertexSize,        // Vertex size in bytes
         DWORD dwNumVertices)       // Number of vertices
        {return 0;}
    // This function could be used if PSGP doesn't want to implement complete
    // clipping pipeline
    // Parameters:
    //      pv  - state data
    //      tri - triangle to clip
    //      interpolate - interpolation flags
    //      clipVertexPointer - pointer to an array of pointers to
    //                          generated vertices
    // Returns:
    //      Number of vertices in clipped triangle
    //      0, if the triangle is off screen
    virtual int ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                   ClipTriangle *tri,
                                   ClipVertex ***clipVertexPointer,
                                   int interpolate) = 0;
    virtual HRESULT ComputeSphereVisibility( LPD3DFE_PROCESSVERTICES pPV,
                                             LPD3DVECTOR lpCenters,
                                             LPD3DVALUE lpRadii,
                                             DWORD dwNumSpheres,
                                             DWORD dwFlags,
                                             LPDWORD lpdwReturnValues) = 0;
    // Used to generate clip flags for transformed and lit vertices
    // Computes clip status and returns clip intersection code
    virtual DWORD GenClipFlags(D3DFE_PROCESSVERTICES *pv);
    // Used to implement viewport->TransformVertices
    // Returns clip intersection code
    virtual DWORD TransformVertices(D3DFE_PROCESSVERTICES *pv, 
                                    DWORD vertexCount, 
                                    D3DTRANSFORMDATAI* data);
};

typedef ID3DFE_PVFUNCS *LPD3DFE_PVFUNCS;

//---------------------------------------------------------------------
// Direct3D implementation of PVFUNCS
//
class D3DFE_PVFUNCS : public ID3DFE_PVFUNCS
{
public:
    DWORD ProcessVertices(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessPrimitive(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessIndexedPrimitive(LPD3DFE_PROCESSVERTICES);
    virtual int ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                   ClipTriangle *tri,
                                   ClipVertex ***clipVertexPointer,
                                   int interpolate);
    virtual HRESULT ComputeSphereVisibility( LPD3DFE_PROCESSVERTICES pPV,
                                             LPD3DVECTOR lpCenters,
                                             LPD3DVALUE lpRadii,
                                             DWORD dwNumSpheres,
                                             DWORD dwFlags,
                                             LPDWORD lpdwReturnValues);
    // Used to generate clip flags for transformed and lit vertices
    // Computes clip status and returns clip intersection code
    virtual DWORD GenClipFlags(D3DFE_PROCESSVERTICES *pv);
    // Used to implement viewport->TransformVertices
    virtual DWORD TransformVertices(D3DFE_PROCESSVERTICES *pv, 
                                    DWORD vertexCount, 
                                    D3DTRANSFORMDATAI* data);
};

// GeometrySetup function takes a DWORD describing the dirty bits and the new state vector
// and passes back the 3 new leaf routines to use.
typedef HRESULT (D3DAPI *LPD3DFE_CONTEXTCREATE)(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);

// Global pointer to Processor specific PV setup routine
// This is defined in dlld3d.cpp
extern LPD3DFE_CONTEXTCREATE pfnFEContextCreate;

#endif // _D3DFE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\genlight.h ===
#ifndef __GENLIGHT_H__
#define __GENLIGHT_H__

typedef struct _SpecularTable 
{
    LIST_MEMBER(_SpecularTable) list;
    float          power;          /* shininess power */
    unsigned char   table[260]; /* space for overflows */
} SpecularTable;

void RLDDI_DoLights(D3DVALUE ar, D3DVALUE ag, D3DVALUE ab, int count,
                    D3DLIGHTINGELEMENT* elements, size_t in_size,
                    unsigned long *out, size_t out_size, int lightc, 
                    D3DI_LIGHT* lightv, D3DMATERIAL* mat, D3DVALUE gain, 
                    SpecularTable* tab);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\genpick.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   genpick.h
 *  Content:    Generic picking function prototypes
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id: commdrv.h,v 1.2 1995/12/04 11:30:59 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   17/05/96   v-jonsh Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _GENPICK_H_
#define _GENPICK_H_

#include "commdrv.hpp"

extern int  GenPickTriangle(LPDIRECT3DDEVICEI lpDevI,
                            D3DTLVERTEX*   base,
                            D3DTRIANGLE*   tri,
                            D3DRECT*   rect,
                            D3DVALUE*  result);

extern HRESULT  GenPickTriangles(LPDIRECT3DDEVICEI lpDevI,
                                 LPDIRECTDRAWSURFACE lpDDExeBuf,
                                 LPBYTE      lpData,
                                 D3DINSTRUCTION* ins,
                                 D3DTRIANGLE*    tri,
                                 LPD3DRECTV      extent,
                                 D3DRECT*    pick_region);

extern HRESULT  GenAddPickRecord(LPDIRECT3DDEVICEI lpDevI,
                                 D3DOPCODE op,
                                 int offset,
                                 float result);

extern HRESULT  GenGetPickRecords(LPDIRECT3DDEVICEI lpDevI,
                                  D3DI_PICKDATA* pdata);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\handle.hpp ===
/*
 * $Id: handle.hpp,v 1.5 1995/10/24 14:06:26 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef _HANDLE_H_
#define _HANDLE_H_

#include "lists.hpp"

typedef DWORD RLDDIHandle;

typedef void (*RLDDIHandleCallback)(void* lpArg);

typedef struct _RLDDIHandleEntry 
{
    LIST_MEMBER(_RLDDIHandleEntry) link;
    DWORD       hArg;
    RLDDIHandleCallback lpFunc;
    void*       lpArg;
} RLDDIHandleEntry;

typedef struct _handle_chunk 
{
    LIST_MEMBER(_handle_chunk)      link;
} handle_chunk;

typedef struct _handle_pool 
{
    LIST_ROOT(_h, _RLDDIHandleEntry)    free;
    RLDDIHandleEntry*           unallocated;
    int                 num_unallocated;
    LIST_ROOT(_ch, _handle_chunk)   chunks;
} handle_pool;

#define HANDLE_MAX      ((1 << 16) - 1)
#define HANDLE_HASHNUM  251
#define HANDLE_HASH(x)  (x % HANDLE_HASHNUM)

typedef struct _RLDDIHandleTable 
{
    LIST_ROOT(_rthe, _RLDDIHandleEntry) hash[HANDLE_HASHNUM];
    handle_pool pool;
    int next;
} RLDDIHandleTable;

RLDDIHandleTable* RLDDICreateHandleTable(void);
void RLDDIDestroyHandleTable(RLDDIHandleTable*);
RLDDIHandle RLDDIHandleTableCreateHandle(RLDDIHandleTable* table,
                                         void* lpArg,
                                         RLDDIHandleCallback lpFunc);
void*   RLDDIHandleTableFindHandle(RLDDIHandleTable* table,
                                   RLDDIHandle hArg);
BOOL    RLDDIHandleTableReplaceHandle(RLDDIHandleTable* table,
                                      RLDDIHandle hArg,
                                      LPVOID lpArg);
void    RLDDIHandleTableDeleteHandle(RLDDIHandleTable* table,
                                     RLDDIHandle hArg);

#endif /* _HANDLE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\halprov.h ===
//----------------------------------------------------------------------------
//
// halprov.h
//
// Defines the IHalProvider interface.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _HALPROV_H_
#define _HALPROV_H_

// The following stuff is for Ramp Rasterizer.
typedef enum _RastRampServiceType
{
    RAMP_SERVICE_CREATEMAT              = 0,
    RAMP_SERVICE_DESTORYMAT             = 1,
    RAMP_SERVICE_SETMATDATA             = 2,
    RAMP_SERVICE_SETLIGHTSTATE          = 3,
    // This returns base, size, and a texture ramp.
    // Arg1 is a pointer to RAMP_RANGE_INFO.
    RAMP_SERVICE_FIND_LIGHTINGRANGE     = 4,
    // This service only calls BeginSceneHook. Both arg1 and arg2 are ignored.
    RAMP_SERVICE_CLEAR                  = 5,
    // Arg1 is a D3DMATERIALHANDLE, arg2 is a DWORD* to get the pixel value.
    RAMP_SERVICE_MATERIAL_TO_PIXEL      = 6,
    // Arg1 is 0 if end scene, != 0 if begin scene
    RAMP_SERVICE_SCENE_CAPTURE          = 8,
    // Arg1 is hTex
    RAMP_SERVICE_PALETTE_CHANGED        = 9,
    // Arg1 is hMat, Arg2 is RECT*
    RAMP_SERVICE_CLEAR_TEX_RECT        = 10,
} RastRampServiceType;

typedef enum _RastServiceType
{
    // Arg1 is a D3DCOLOR, and Arg2 is a DWORD* to get the pixel value
    RAST_SERVICE_RGB8COLORTOPIXEL              = 0,
} RastServiceType;

typedef HRESULT (*PFN_RASTRAMPSERVICE)
    (ULONG_PTR dwCtx, RastRampServiceType srvType, ULONG_PTR arg1, LPVOID arg2);

typedef HRESULT (*PFN_RASTSERVICE)
    (ULONG_PTR dwCtx, RastServiceType srvType, DWORD arg1, LPVOID arg2);

typedef struct _D3DHALPROVIDER_INTERFACEDATA
{
    DWORD                       dwSize;
    LPD3DHAL_GLOBALDRIVERDATA   pGlobalData;
    LPD3DHAL_D3DEXTENDEDCAPS    pExtCaps;
    LPD3DHAL_CALLBACKS          pCallbacks;
    LPD3DHAL_CALLBACKS2         pCallbacks2;
    LPD3DHAL_CALLBACKS3         pCallbacks3;

    // This function pointer should be NULL except for ramp rasterizer.
    PFN_RASTRAMPSERVICE         pfnRampService;

    PFN_RASTSERVICE             pfnRastService;

} D3DHALPROVIDER_INTERFACEDATA, *LPD3DHALPROVIDER_INTERFACEDATA;


#undef INTERFACE
#define INTERFACE IHalProvider

DECLARE_INTERFACE_(IHalProvider, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IHalProvider.
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion) PURE;
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion) PURE;
};

STDAPI GetHwHalProvider(REFCLSID riid,
                        IHalProvider **ppHalProvider, HINSTANCE *phDll, LPDDRAWI_DIRECTDRAW_GBL pDdGbl);
STDAPI GetSwHalProvider(REFCLSID riid,
                        IHalProvider **ppHalProvider, HINSTANCE *phDll);

STDAPI GetSwZBufferFormats(REFCLSID riid, DDPIXELFORMAT **ppDDPF);
STDAPI GetSwTextureFormats(REFCLSID riid, LPDDSURFACEDESC* lplpddsd, DWORD dwD3DDeviceVersion);

#endif // #ifndef _HALPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\span.h ===
//----------------------------------------------------------------------------
//
// span.h
//
// Structures which define the interface between the edge walker to the
// span interpolator.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPAN_H_
#define _SPAN_H_

#include <d3ditype.h>
#include <d3dhal.h>

#ifdef __cplusplus
extern "C" {
#endif

// TBD make this machine independent
// don't leave any space between the elements of these structures
// currently smallest element is a UINT16, may have to change this to pack(1)
// if UINT8's are used.
#include <pshpack2.h>

// Limits, shifts and scaling factors for RASTSPAN and RASTPRIM data.
// C_*_LIMIT is the constant integer form of the limit for cases where
// direct integer comparisons can be done.
#define Z_LIMIT         g_fTwoPow31
#define C_Z_LIMIT       0x4f000000
#define Z16_FRAC_SHIFT  15
#define Z16_FRAC_SCALE  g_fTwoPow15
#define OO_Z16_FRAC_SCALE g_fOoTwoPow15
#define Z16_SHIFT       31
#define Z16_SCALE       g_fNearTwoPow31
#define OO_Z16_SCALE    g_fOoNearTwoPow31
#define Z32_FRAC_SHIFT  0
#define Z32_FRAC_SCALE  g_fOne
#define OO_Z32_FRAC_SCALE g_fOoNearTwoPow31
#define Z32_SHIFT       31
#define Z32_SCALE       g_fNearTwoPow31
#define OO_Z32_SCALE    g_fOoNearTwoPow31

#define TEX_LIMIT       g_fTwoPow31
#define C_TEX_LIMIT     0x4f000000
#define TEX_SHIFT       20
#define TEX_SCALE       g_fTwoPow20
#define OO_TEX_SCALE    g_fOoTwoPow20

#define COLOR_LIMIT     g_fTwoPow15
#define C_COLOR_LIMIT   0x47000000
#define COLOR_SHIFT     8
#define COLOR_SCALE     g_fTwoPow8

#define INDEX_COLOR_LIMIT   g_fTwoPow30
#define C_INDEX_COLOR_LIMIT 0x4e800000
#define INDEX_COLOR_SHIFT   16
#define INDEX_COLOR_SCALE   g_fTwoPow16
#define INDEX_COLOR_VERTEX_SHIFT 8
// Shift to go from fixed-point value in vertex color to proper shift.
#define INDEX_COLOR_FIXED_SHIFT (INDEX_COLOR_SHIFT - INDEX_COLOR_VERTEX_SHIFT)

#define LOD_LIMIT       g_fTwoPow15
#define C_LOD_LIMIT     0x47000000
#define LOD_SHIFT       11
#define LOD_SCALE       g_fTwoPow11
#define LOD_MIN         (-15)

#define OOW_LIMIT       g_fTwoPow31
#define C_OOW_LIMIT     0x4f000000
#define OOW_SHIFT       31
#define OOW_SCALE       g_fNearTwoPow31
#define OO_OOW_SCALE    g_fOoNearTwoPow31
#define W_SHIFT         16
#define W_SCALE         g_fTwoPow16
#define OO_W_SCALE      g_fOoTwoPow16
#define OOW_W_SHIFT     (OOW_SHIFT + W_SHIFT)
#define OOW_W_SCALE     g_fTwoPow47

#define FOG_LIMIT       g_fTwoPow15
#define C_FOG_LIMIT     0x47000000
#define FOG_SHIFT       8
#define FOG_SCALE       g_fTwoPow8
#define FOG_ONE_SCALE   g_fTwoPow16
#define FOG_255_SCALE   g_fTwoPow8

#define TEX_FINAL_SHIFT 16
#define TEX_FINAL_FRAC_MASK (0xffff)
#define TEX_TO_FINAL_SHIFT (TEX_SHIFT - TEX_FINAL_SHIFT)
// Multiply with span W so that [U|V]oW times resulting W is in the
// final shift position.  1 / (W_SHIFT + TEX_TO_FINAL_SHIFT).
#define TEX_UVW_TO_FINAL_SCALE g_fOoTwoPow20
// Divide by span OoW so that [U|V]oW times resulting W is in the
// final shift position.  OOW_SHIFT - TEX_TO_FINAL_SHIFT.
#define TEX_OOW_TO_FINAL_SCALE g_fTwoPow27

#define RAST_DIRTYBITS_SIZE     ((D3DHAL_MAX_RSTATES_AND_STAGES >> 3) + 1)

/*
 * Macro to compute D3DRENDERSTATE offset for a particular per-stage state.
 * It's moved here after texture3 removal.
 */
#define D3DHAL_TSS_OFFSET( _Stage, _State ) \
    ((D3DRENDERSTATETYPE) \
     (D3DHAL_TSS_RENDERSTATEBASE + \
      ((_Stage) * D3DHAL_TSS_STATESPERSTAGE) + (_State)))

/*
 * Convenience texture map offsets for stages.
 */
#define D3DHAL_TSS_TEXTUREMAP0  D3DHAL_TSS_OFFSET(0, D3DTSS_TEXTUREMAP)
#define D3DHAL_TSS_TEXTUREMAP1  D3DHAL_TSS_OFFSET(1, D3DTSS_TEXTUREMAP)
#define D3DHAL_TSS_TEXTUREMAP2  D3DHAL_TSS_OFFSET(2, D3DTSS_TEXTUREMAP)
#define D3DHAL_TSS_TEXTUREMAP3  D3DHAL_TSS_OFFSET(3, D3DTSS_TEXTUREMAP)
#define D3DHAL_TSS_TEXTUREMAP4  D3DHAL_TSS_OFFSET(4, D3DTSS_TEXTUREMAP)
#define D3DHAL_TSS_TEXTUREMAP5  D3DHAL_TSS_OFFSET(5, D3DTSS_TEXTUREMAP)
#define D3DHAL_TSS_TEXTUREMAP6  D3DHAL_TSS_OFFSET(6, D3DTSS_TEXTUREMAP)
#define D3DHAL_TSS_TEXTUREMAP7  D3DHAL_TSS_OFFSET(7, D3DTSS_TEXTUREMAP)

// General per span data.  This structure is designed to be qword aligned.
typedef struct tagD3DI_RASTSPAN
{
    // Space separated things are quad words and are intended to be
    // quad word aligned.
    UINT16 uPix;            // count of pixels to render
    INT16 iDFog;            // 1.7.8 delta fog
    UINT16 uX;              // 16.0 start X
    UINT16 uY;              // 16.0 start Y

    INT16 iLOD;             // 1.4.11 start LOD
    INT16 iDLOD;            // 1.4.11 delta LOD (so piecewise linear LOD interp
                            //                  is possible)
    union
    {
        UINT32 uZ;          // 16.15 start Z
        FLOAT fZ;
    };

    // If texture stuff (iOoW, iUoW1, etc.) is 32 bits (even if we iterate
    // them at 16 bits under MMX sometimes)
    union
    {
        INT32 iW;           // 1.15.16 first inverted W of span
        FLOAT fW;
    };
    union
    {
        INT32 iOoW;         // 1.31 start 1/W (signed since they are target
                            //                 of MMX multiply)
        FLOAT fOoW;
    };

    union
    {
        INT32 iUoW1;        // 1.11.20 first texture coordinates
        FLOAT fUoW1;
    };
    union
    {
        INT32 iVoW1;        // 1.11.20 first texture coordinates
        FLOAT fVoW1;
    };

    union
    {
        struct
        {
            UINT16 uB, uG, uR, uA;  // 8.8 start colors
        };
        struct
        {
            INT32 iIdx, iIdxA;      // 1.8.16 ramp start color and alpha
        };
    };

    UINT16 uBS, uGS, uRS;  // 8.8 start specular colors
    // Specular alpha is fog.  This prevents specular color from
    // being unioned with the texture 2 coordinates below.
    UINT16 uFog;           // 1.7.8 start fog value

    union
    {
        INT32 iUoW2;    // 1.11.20 second texture coordinates
        FLOAT fUoW2;
    };
    union
    {
        INT32 iVoW2;    // 1.11.20 second texture coordinates
        FLOAT fVoW2;
    };

    // Pointers into surface and Z buffers interpolated by the edge walker.
    PUINT8 pSurface;
    PUINT8 pZ;

#ifdef _IA64_
    UINT8 Padding[24];
#endif // _IA64_

} D3DI_RASTSPAN, *PD3DI_RASTSPAN;   // sizeof(D3DI_RASTSPAN) == 64
typedef CONST D3DI_RASTSPAN *PCD3DI_RASTSPAN;

// D3DI_RASTPRIM uFlags
#define D3DI_RASTPRIM_X_DEC     (0x00000001L)   // Else X increments.

// General per primitive for edge walking and span scanning.
// Can be expanded to suit the edge walker.
// The information the span rasterizer needs is sensitive to qwords for
// the MMX rasterizers.
typedef struct tagD3DI_RASTPRIM
{
    UINT32 uFlags;
    UINT16 uSpans;              // count of spans
    UINT16 uResvd1;             // perhaps we want to expand uSpans to 32 bits,
                                // or perhaps 16 flag bits are enough

    // X gradients
    union
    {
        INT32 iDZDX;            // 1.16.15
        FLOAT fDZDX;
    };
    union
    {
        INT32 iDOoWDX;          // 1.31
        FLOAT fDOoWDX;
    };

    union
    {
        INT32 iDUoW1DX;         // 1.11.20
        FLOAT fDUoW1DX;
    };
    union
    {
        INT32 iDVoW1DX;         // 1.11.20
        FLOAT fDVoW1DX;
    };

    union
    {
        struct
        {
            INT16 iDBDX, iDGDX, iDRDX, iDADX;   // 1.7.8
        };
        struct
        {
            FLOAT fDBDX, fDGDX, fDRDX, fDADX;
        };
        struct
        {
            INT32 iDIdxDX, iDIdxADX;            // 1.8.16
        };
    };

    struct
    {
        union
        {
            struct
            {
                INT16 iDBSDX, iDGSDX, iDRSDX; // 1.7.8
            };
            struct
            {
                FLOAT fDBSDX, fDGSDX, fDRSDX;
                FLOAT fPad; // Padding to keep this set of attributes
                            // an even multiple of quadwords.
            };
        };
    };

    struct
    {
        union
        {
            INT32 iDUoW2DX; // 1.11.20
            FLOAT fDUoW2DX;
        };
        union
        {
            INT32 iDVoW2DX; // 1.11.20
            FLOAT fDVoW2DX;
        };
    };

    // Y gradients for some attributes so that span routines
    // can do per-pixel mipmapping.
    union
    {
        INT32 iDUoW1DY; // 1.11.20
        FLOAT fDUoW1DY;
    };
    union
    {
        INT32 iDVoW1DY; // 1.11.20
        FLOAT fDVoW1DY;
    };

    union
    {
        INT32 iDUoW2DY; // 1.11.20
        FLOAT fDUoW2DY;
    };
    union
    {
        INT32 iDVoW2DY; // 1.11.20
        FLOAT fDVoW2DY;
    };

    union
    {
        INT32 iDOoWDY;          // 1.31
        FLOAT fDOoWDY;
    };

    struct tagD3DI_RASTPRIM *pNext;

    // Pad to an even multiple of 32 bytes for cache alignment.
    DWORD uPad[2];

    // Anything else needed

#ifdef _IA64_
    UINT8 Padding[28];
#endif // _IA64_

} D3DI_RASTPRIM, *PD3DI_RASTPRIM;
typedef CONST D3DI_RASTPRIM *PCD3DI_RASTPRIM;

// D3DI_SPANTEX uFlags
#define D3DI_SPANTEX_HAS_TRANSPARENT    (0x00000001L)
#define D3DI_SPANTEX_SURFACES_LOCKED    (0x00000002L)
#define D3DI_SPANTEX_MAXMIPLEVELS_DIRTY (0x00000004L)
// Palette with alpha
#define D3DI_SPANTEX_ALPHAPALETTE       (0x00000008L)
#define D3DI_SPANTEX_NON_POWER_OF_2     (0x00000010L)

//  D3DI_SPANTEX uFormat - NOTE: these enumerations match the sequence in the
//  array of DDPIXELFORMAT structures defined for matching in texture creation
//
//  NOTE: these must be kept consistent with the RRPixelFormats for the reference rasterizer
typedef enum _D3DI_SPANTEX_FORMAT
{
    D3DI_SPTFMT_NULL     = 0,
    D3DI_SPTFMT_B8G8R8   = 1,
    D3DI_SPTFMT_B8G8R8A8 = 2,
    D3DI_SPTFMT_B8G8R8X8 = 3,
    D3DI_SPTFMT_B5G6R5   = 4,
    D3DI_SPTFMT_B5G5R5   = 5,
    D3DI_SPTFMT_PALETTE4 = 6,
    D3DI_SPTFMT_PALETTE8 = 7,
    D3DI_SPTFMT_B5G5R5A1 = 8,
    D3DI_SPTFMT_B4G4R4   = 9,
    D3DI_SPTFMT_B4G4R4A4 =10,
    D3DI_SPTFMT_L8       =11,       /* 8 bit luminance-only */
    D3DI_SPTFMT_L8A8     =12,       /* 16 bit alpha-luminance */
    D3DI_SPTFMT_U8V8     =13,       /* 16 bit bump map format */
    D3DI_SPTFMT_U5V5L6   =14,       /* 16 bit bump map format with luminance */
    D3DI_SPTFMT_U8V8L8   =15,       /* 24 bit bump map format with luminance */

    D3DI_SPTFMT_UYVY     =16,       /* UYVY format for PC98 compliance */
    D3DI_SPTFMT_YUY2     =17,       /* YUY2 format for PC98 compliance */
    D3DI_SPTFMT_DXT1    =18,       /* S3 texture compression technique 1 */
    D3DI_SPTFMT_DXT2    =19,       /* S3 texture compression technique 2 */
    D3DI_SPTFMT_DXT3    =20,       /* S3 texture compression technique 3 */
    D3DI_SPTFMT_DXT4    =21,       /* S3 texture compression technique 4 */
    D3DI_SPTFMT_DXT5    =22,       /* S3 texture compression technique 5 */
    D3DI_SPTFMT_B2G3R3   =23,       /* 8 bit RGB texture format */

    D3DI_SPTFMT_Z16S0    =32,
    D3DI_SPTFMT_Z24S8    =33,
    D3DI_SPTFMT_Z15S1    =34,
    D3DI_SPTFMT_Z32S0    =35,

    D3DI_SPTFMT_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DI_SPANTEX_FORMAT;


// This encompasses all needed info about a chain of DD surfaces being used
// as a potentially mipmapped texture.
#define SPANTEX_MAXCLOD   11        // up to 2kx2k texture, all we can do with MMX INT16
                                    // U's and V's
typedef struct tagD3DI_SPANTEX
{
    UINT32  dwSize;

    INT32   iGeneration;            // incremented when the texture changes
    UINT32  uFlags;                 // perspective, etc.
    D3DI_SPANTEX_FORMAT  Format;    // pixel format of the texture
    D3DTEXTUREADDRESS TexAddrU, TexAddrV; // texture address mode
    D3DTEXTUREMAGFILTER  uMagFilter;// TEX3 style filter information
    D3DTEXTUREMINFILTER  uMinFilter;// ATTENTION we could express this information more compactly
    D3DTEXTUREMIPFILTER  uMipFilter;
    D3DCOLOR BorderColor;           // border color for the texture
                                    // (for D3DTADDRESS_BORDER)
    D3DCOLOR TransparentColor;      // color key on texture read

    FLOAT fLODBias;                 // Texture3 LOD bias value.

    PUINT8  pBits[SPANTEX_MAXCLOD]; // pointer for each LOD
#if (SPANTEX_MAXCLOD & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT16   iPitchPad;
#endif
    PUINT32 pRampmap;               // set by ramp rasterizer, if necessary
    PUINT32 pPalette;               // pointer to palette, if necessary
    INT32   iPaletteSize;           // size of palette
    INT32   cLOD;                   // contains count of levels - 1 (0 means 1 level)
                                    // to use
    INT32   cLODTex;                // contains count of levels - 1 (0 means 1 level)
                                    // that are actually in the texture
                                    // cLODTex >= cLOD is always true
    INT32   iMaxMipLevel;           // index of largest mip map to use.  0 means use largest.
    INT     iMaxScaledLOD;          // ((cLOD + 1) scaled by LOD_SCALE) - 1.
    INT16   iSizeU, iSizeV;         // LOD 0 size (only support power of 2
                                    // textures)
    INT16   iShiftU, iShiftV;       // LOD 0 log2 size (valid for power-of-2
                                    // size only)
    INT16   iShiftPitch[SPANTEX_MAXCLOD]; // log2 pitch for each LOD
    UINT16  uMaskU, uMaskV;         // LOD 0 (1<<log2(size))-1
    // Variables for arithmetic address computation.  Computed by DoTexAddrSetup.
    INT16   iFlipMaskU, iFlipMaskV;
    INT16   iClampMinU, iClampMinV;
    INT16   iClampMaxU, iClampMaxV;
    INT16   iClampEnU, iClampEnV;

    LPDIRECTDRAWSURFACE pSurf[SPANTEX_MAXCLOD]; // Added for TextureGetSurf
                                                // and Lock/Unlock Texture

} D3DI_SPANTEX, *PD3DI_SPANTEX;

// Color structure for blending etc. with enough room for 8.8 colors.
// Even for 8 bit colors, this is convenient for lining up the colors
// as we desire in MMX for 16 bit multiplies
typedef struct tagD3DI_RASTCOLOR
{
    UINT16 uB, uG, uR, uA;
} D3DI_RASTCOLOR, *PD3DI_RASTCOLOR;

// This structure has all the temporary storage needed for all the iterated
// values to route the span information between the layers.
// TBD there is lots more to add here, do texture mapping first
typedef struct tagD3DI_SPANITER
{
    // make the colors use the same order as RASTCOLOR above
    UINT16 uBB, uBG, uBR, uBA;  // 8.8 blended color
    UINT16 uFogB, uFogG, uFogR, uFog;   // 8.8 fog color, 0.16 fog value
    INT16  iFogBDX, iFogGDX, iFogRDX, iDFog;  // 1.7.8 fog color deltas
    UINT32 uZDeferred;          // storage for Z for deferred Z write
    union
    {
        INT32 iU1;           // 1.15.16
        FLOAT fU1;
    };
    union
    {
        INT32 iV1;           // 1.15.16
        FLOAT fV1;
    };
    union
    {
        INT32 iU2;           // 1.15.16
        FLOAT fU2;
    };
    union
    {
        INT32 iV2;           // 1.15.16
        FLOAT fV2;
    };
    D3DCOLOR    TexCol[2];  // [Texture]
    INT32 iDW;              // to remember last delta W in
    UINT16 uDitherOffset;
    INT16  iXStep;          // 1 or -1
    INT16 iSpecialW;        // negative for first or last 3 pixels of span
    INT16 bStencilPass;     // 1 if stencil test passed, otherwise 0
    union
    {
        INT32 iOoW;         // previous OoW to pass between texaddr stages
        FLOAT fOoW;
    };
} D3DI_SPANITER, *PD3DI_SPANITER;

// Z compare macro
// This does depend on the result of a compare being 0 or 1 (for the final XOR, since C
// doesn't have a logical XOR), but this has been true on all processors and
// compilers for some time.
#define ZCMP16(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Assumes the most significant bit of Z is 0 (31 bit Z)
#define ZCMP32(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Alpha Test compare macro
#define ACMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iAAndMask) - (p)->iANeg) >= 0) ^ (p)->iAXorMask)

// Stencil Test compare macro
#define SCMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iSAndMask) - (p)->iSNeg) >= 0) ^ (p)->iSXorMask)


// Helper macro that converts [0, 0xff] to [0, 5], linearly
#define RGB8_CHANNEL(rgb)   ((((rgb) * 5) + 0x80) >> 8)

// Defines conversion from 24 bit RGB to 8 bit palette index.  Each color has 6 values
// resulting in 6**3 == 216 required colors in the palette.
#define MAKE_RGB8(r, g, b) (RGB8_CHANNEL(r) * 36       \
                 + RGB8_CHANNEL(g) * 6                 \
                 + RGB8_CHANNEL(b))

// forward declaration of D3DI_RASTCTX
struct tagD3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX          D3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX         *PD3DI_RASTCTX;
typedef CONST struct tagD3DI_RASTCTX   *PCD3DI_RASTCTX;

// typedef for old ramp assembly monolithics
typedef void (CDECL *PFNRAMPOLD)(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins,
              D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

// typedef for entry point for old ramp assembly monolithics
typedef HRESULT (CDECL *PFNRAMPOLDTRI)(PD3DI_RASTCTX pCtx,
                   LPD3DTLVERTEX pV0,
                   LPD3DTLVERTEX pV1,
                   LPD3DTLVERTEX pV2);

// typedef for each rendering layer
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef void (CDECL *PFNSPANLAYER)(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                                   PD3DI_RASTSPAN pS);

// typedef texture read functions
// this is an actual function so it can be called multiple times
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef D3DCOLOR (CDECL *PFNTEXREAD)(INT32 iU, INT32 iV, INT32 iShiftU,
                                     PUINT8 pBits, PD3DI_SPANTEX pTex);

// Typedef for span rendering function pointers.
typedef HRESULT (CDECL *PFNRENDERSPANS)(PD3DI_RASTCTX pCtx);

// typedef for alpha blending functions.
typedef void (CDECL *PFNBLENDFUNC)(PUINT16 pR, PUINT16 pG, PUINT16 pB,
                                   PUINT16 pA, D3DCOLOR DestC,
                                   PD3DI_RASTCTX pCtx);

// typedef for buffer read functions.
typedef D3DCOLOR (CDECL *PFNBUFREAD)(PUINT8 pBits);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDGET)(PD3DI_RASTCOLOR pArg1,
                                     PD3DI_RASTCOLOR pArg2,
                                     PD3DI_RASTCOLOR pInput,
                                     PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                     INT32 iTex);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDOP)(PD3DI_RASTCOLOR pOut,
                                    PD3DI_RASTCOLOR pArg1,
                                    PD3DI_RASTCOLOR pArg2,
                                    PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                    INT32 iTex);

// Prototype for set of bead selections.
typedef enum tagD3DI_BEADSET
{
    D3DIBS_CMMX = 1,        // C emulation of MMX beads
    D3DIBS_MMX = 2,         // MMX beads
    D3DIBS_C = 3,           // C beads
    D3DIBS_RAMP = 4,        // Ramp beads
    D3DIBS_MMXASRGB = 5,    // MMX selected for RGB rasterizer
} D3DI_BEADSET;

typedef struct tagD3DI_FILLPARAMS
{
    DWORD   dwWrapU;
    DWORD   dwWrapV;
    DWORD   dwCullCCW;
    DWORD   dwCullCW;
} D3DI_FILLPARAMS, *PD3DI_FILLPARAMS;

// General span scanning context
struct tagD3DI_RASTCTX
{
    UINT32   dwSize;

    //////////////////////////////////////////////////////////////////////
    // Temporary storage for span rendering routines.  Could be global.
    // Not set by caller, and not changed by SpanInit.
    //

    D3DI_SPANITER SI;

    //////////////////////////////////////////////////////////////////////
    // Data that must be set by caller before a SpanInit.
    //

    // we may want to put a pointer to a DDSURFACEDESC or something like it
    // instead of this
    PUINT8 pSurfaceBits;
    INT iSurfaceStride;
    INT iSurfaceStep;
    INT iSurfaceBitCount;
    INT iSurfaceType;     // or however we end up expressing this
    PUINT32 pRampMap;     // pointer to ramp map, if necessary
    LPDIRECTDRAWSURFACE pDDS;

    PUINT8 pZBits;
    INT iZStride;
    INT iZStep;
    INT iZBitCount;
    LPDIRECTDRAWSURFACE pDDSZ;

    // Clip area.
    RECT Clip;

    // Sign of face area that should be culled.  Zero is clockwise,
    // one is CCW and everything else means no culling.
    UINT uCullFaceSign;

    union
    {
        DWORD pdwRenderState[D3DHAL_MAX_RSTATES_AND_STAGES];
        FLOAT pfRenderState[D3DHAL_MAX_RSTATES_AND_STAGES];
    };

    // Since we are adjusting the order of texIdx in the vertex to suit that
    // defined in state TEXCOORDINDEX, we need a copy of adjusted WRAP state.
    // This is declared immediately after pdwRenderState so that we can share
    // a register with it in the assembly code.
    // WARNING WARNING - THIS ABSOLUTELY NEEDS TO BE FOLLOWING pdwRenderState
    // IMMEDIATELY. ASM CODE DEPENDS ON THIS.
    DWORD pdwWrap[2];

    // first texture object contains information for texture for first pair
    // of texture coordinates, second contains texture for second pair of
    // texture coordinates, etc.
    PD3DI_SPANTEX pTexture[2];
    // Number of active textures. 0 - texture off; 1 - pTexture[0] is valid
    // 2 - both pTexture[0] and pTexture[1] are valid
    UINT cActTex;

    // Dirty bits for render states.
    // ATTENTION - We can reduce the size  to have one bit for each group of
    // states when we implement the light weighted beed chooser.
    // Right now, it's set by SetRenderState and cleared after SpanInit is
    // called. The bit corresponding to D3DHAL_MAX_RSTATES_AND_STAGES is set
    // whenever a state is changed.
    UINT8 StatesDirtyBits[RAST_DIRTYBITS_SIZE];

#if (RAST_DIRTYBITS_SIZE & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT8   StatesDirtyBitsPad0;
#endif
#if (RAST_DIRTYBITS_SIZE & 2) != 0
    // Pad following fields to a DWORD boundary.
    INT16   StatesDirtyBitsPad1;
#endif

    // Version# of the D3DDevice corresponding to this Context
    UINT32  uDevVer;

    //////////////////////////////////////////////////////////////////////
    // Data is set by SpanInit given the input above.
    //

    // Triangle entry points for old DX5/DX3 style ramp monolithics
    PFNRAMPOLDTRI   pfnRampOldTri;
    PFNRAMPOLD      pfnRampOld;

    // Span rendering entry point.
    PFNRENDERSPANS  pfnRenderSpans;

    // function pointers for the beads
    PFNSPANLAYER    pfnBegin;
    PFNSPANLAYER    pfnLoopEnd;
    PFNSPANLAYER    pfnTestPassEnd;
    PFNSPANLAYER    pfnTestFailEnd;

    PFNSPANLAYER    pfnTex1AddrEnd;
    PFNTEXREAD      pfnTexRead[2];
    PFNSPANLAYER    pfnTex2AddrEnd;
    PFNSPANLAYER    pfnTexBlendEnd;
    PFNTEXBLENDGET  pfnTexBlendGetColor[2];
    PFNTEXBLENDGET  pfnTexBlendGetAlpha[2];
    PFNTEXBLENDOP   pfnTexBlendOpColor[2];
    PFNTEXBLENDOP   pfnTexBlendOpAlpha[2];

    PFNSPANLAYER    pfnColorGenEnd;
    PFNSPANLAYER    pfnAlphaTestPassEnd;
    PFNSPANLAYER    pfnAlphaTestFailEnd;
    PFNBLENDFUNC    pfnSrcBlend;
    PFNBLENDFUNC    pfnDestBlend;
    PFNBUFREAD      pfnBufRead;
    PFNSPANLAYER    pfnColorBlendEnd;

    // Optional bead that can be called after every pixel for rasterizers
    // which loop beads rather than returning.
    PFNSPANLAYER    pfnPixelEnd;

    // Optional bead that can be called after every span for rasterizers
    // which loop spans rather than returning.
    PFNSPANLAYER    pfnSpanEnd;

    // arithmetic Z variables
    INT32 iZAndMask, iZNeg, iZXorMask;

    // arithmetic Alpha test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iAAndMask, iANeg, iAXorMask;
    // 8.8 Alpha reference value
    INT32 iARef;

    // arithmetic stencil test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iSAndMask, iSNeg, iSXorMask;

    // Pointer to first RASTPRIM.
    PD3DI_RASTPRIM pPrim;

    // Pointer to next context.
    PD3DI_RASTCTX pNext;

    // Current BeadTable to use
    D3DI_BEADSET BeadSet;

    // Bit 0 set disables ml1, etc.
#define MMX_FP_DISABLE_MASK_NUM 1
    DWORD dwMMXFPDisableMask[MMX_FP_DISABLE_MASK_NUM];

    // RampLightingDriver, should be NULL except for RampRast and 8 bit palettized RGB
    // output surface cases.
    LPVOID pRampDrv;
    // RAMP_RANGE_INFO RampInfo;
    DWORD RampBase;
    DWORD RampSize;
    PUINT32 pTexRampMap;
    BOOL bRampSpecular;

    PD3DI_FILLPARAMS pFillParams;
    D3DI_FILLPARAMS FillParams;

    DWORD uFlags;   // misc. flags

#ifdef DBG
#define NAME_LEN    128
    char    szTest[NAME_LEN];
    char    szTestFail[NAME_LEN];
    char    szTex1Addr[NAME_LEN];
    char    szTexRead[2][NAME_LEN];
    char    szTex2Addr[NAME_LEN];
    char    szTexBlend[NAME_LEN];
    char    szColorGen[NAME_LEN];
    char    szAlphaTest[NAME_LEN];
    char    szColorBlend[NAME_LEN];
    char    szSrcBlend[NAME_LEN];
    char    szDestBlend[NAME_LEN];
    char    szBufRead[NAME_LEN];
    char    szBufWrite[NAME_LEN];
#undef  NAME_LEN
#endif
};

#define RASTCTXFLAGS_APPHACK_MSGOLF 0x00000001

// Data passed to the span rendering functions looks like this:
//
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   |   RASTSPAN (as many as RASTPRIM.uSpans says there are)
// |   RASTPRIM
// |   |   RASTSPAN
// |   NULL
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   NULL
// NULL
//
// The given RASTCTX is the head of a list of contexts.  Each context
// points to a list of RASTPRIMs.  Each RASTPRIM structure is immediately
// followed by RASTPRIM.uSpans RASTSPAN structures.

// Prototype for state validation call.
HRESULT SpanInit(PD3DI_RASTCTX pCtx);

// This is used to pack a FVF vertex into one understand by OptRast so it
// does not need to figure out where to get the data it needs. This struct
// can be modified to accommodate more data and it can be broken into more
// specilized and smalled structs.
// Right now, it is an extension of D3DTLVERTEX, and the extra uv is at the
// very end so that OptRast can treat it as a D3DTLVERTEX if only the first
// part of the data needs to be accessed.
typedef struct _RAST_GENERIC_VERTEX {
    union {
    D3DVALUE    sx;             /* Screen coordinates */
    D3DVALUE    dvSX;
    };
    union {
    D3DVALUE    sy;
    D3DVALUE    dvSY;
    };
    union {
    D3DVALUE    sz;
    D3DVALUE    dvSZ;
    };
    union {
    D3DVALUE    rhw;            /* Reciprocal of homogeneous w */
    D3DVALUE    dvRHW;
    };
    union {
    D3DCOLOR    color;          /* Vertex color */
    D3DCOLOR    dcColor;
    };
    union {
    D3DCOLOR    specular;       /* Specular component of vertex */
    D3DCOLOR    dcSpecular;
    };
    union {
    D3DVALUE    tu;             /* Texture coordinates */
    D3DVALUE    dvTU;
    };
    union {
    D3DVALUE    tv;
    D3DVALUE    dvTV;
    };
    union {
    D3DVALUE    tu2;            /* second Texture coordinates */
    D3DVALUE    dvTU2;
    };
    union {
    D3DVALUE    tv2;
    D3DVALUE    dvTV2;
    };
}RAST_GENERIC_VERTEX, *PRAST_GENERIC_VERTEX;

// Vertex types supported by OptRast
typedef enum _RAST_VERTEX_TYPE
{
    RAST_TLVERTEX       = 1,    /* (Legacy) TL vertex */
    RAST_GENVERTEX      = 2,    /* Generic FVF vertex */
    RAST_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
}RAST_VERTEX_TYPE;

#include <poppack.h>

//-----------------------------------------------------------------------------
//
// Surface types for rendering surfaces and textures.  Different subsets are
// supported for render targets and for textures.
//
//-----------------------------------------------------------------------------
typedef enum _RRSurfaceType
{
    RR_STYPE_NULL     = 0,
    RR_STYPE_B8G8R8   = 1,
    RR_STYPE_B8G8R8A8 = 2,
    RR_STYPE_B8G8R8X8 = 3,
    RR_STYPE_B5G6R5   = 4,
    RR_STYPE_B5G5R5   = 5,
    RR_STYPE_PALETTE4 = 6,
    RR_STYPE_PALETTE8 = 7,
    RR_STYPE_B5G5R5A1 = 8,
    RR_STYPE_B4G4R4   = 9,
    RR_STYPE_B4G4R4A4 =10,
    RR_STYPE_L8       =11,          // 8 bit luminance-only
    RR_STYPE_L8A8     =12,          // 16 bit alpha-luminance
    RR_STYPE_U8V8     =13,          // 16 bit bump map format
    RR_STYPE_U5V5L6   =14,          // 16 bit bump map format with luminance
    RR_STYPE_U8V8L8   =15,          // 24 bit bump map format with luminance
    RR_STYPE_UYVY     =16,          // UYVY format (PC98 compliance)
    RR_STYPE_YUY2     =17,          // YUY2 format (PC98 compliance)
    RR_STYPE_DXT1    =18,          // S3 texture compression technique 1
    RR_STYPE_DXT2    =19,          // S3 texture compression technique 2
    RR_STYPE_DXT3    =20,          // S3 texture compression technique 3
    RR_STYPE_DXT4    =21,          // S3 texture compression technique 4
    RR_STYPE_DXT5    =22,          // S3 texture compression technique 5
    RR_STYPE_B2G3R3   =23,          // 8 bit RGB texture format

    RR_STYPE_Z16S0    =32,
    RR_STYPE_Z24S8    =33,
    RR_STYPE_Z15S1    =34,
    RR_STYPE_Z32S0    =35,

} RRSurfaceType;

#ifdef __cplusplus
}
#endif

#endif // _SPAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\testfile.h ===
//----------------------------------------------------------------------------
//
// testfile.h
//
// Defines for file with test data.
//
// File format:
//      File contains chunks of data. Each chunk has four-byte ID, four-byte data size field and
//      "size" number of bytes of data.
//      Chunks:
//          ID          Meaning           Data
//          1       Scene capture       DWORD flags
//          2       Render state        DWORD states count
//                                      States (D3DSTATE*count)
//          3       Render primitive    DWORD status
//                                      D3DPRIMITIVETYPE primitive type
//                                      DWORD number of vertices
//                                      D3DVERTEXTYPE vertex type
//                                      D3DINSTRUCTION
//                                        Primitive record (D3DPOINT, D3DLINE ...)
//                                        Primitive vertices (TLVERTEX)
//                                        ...
//          4       Draw one primitive  D3DPRIMITIVETYPE primitive type
//                                      DWORD number of vertices
//                                      D3DVERTEXTYPE vertex type
//                                      Vertices
//          5       Draw one indexed    D3DPRIMITIVETYPE primitive type
//                      primitive       DWORD number of vertices
//                                      DWORD number of indices
//                                      D3DVERTEXTYPE vertex type
//                                      Vertices
//                                      Indices (WORD)
//          6       Draw primitives     The same as DDI data, but without 32 byte
//                                      alignment.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#ifndef _TESTFILE_H_
#define _TESTFILE_H_

// TF stands for "TestFile"
typedef struct
{
    DWORD id;           // record ID
    DWORD size;         // size of data in bytes (exclude size of REC_HEADER)
} TF_HEADER;

// ID for test file records
const DWORD TFID_SCENECAPTURE               = 1;
const DWORD TFID_RENDERSTATE                = 2;
const DWORD TFID_RENDERPRIMITIVE            = 3;
const DWORD TFID_DRAWONEPRIMITIVE           = 4;
const DWORD TFID_DRAWONEINDEXEDPRIMITIVE    = 5;
const DWORD TFID_DRAWPRIMITIVES             = 6;
const DWORD TFID_DRAWPRIMITIVES2            = 7;

// Fixed size record headers
typedef struct
{
    DWORD               status;
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
} TFREC_RENDERPRIMITIVE;

typedef struct
{
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
    DWORD               dwFlags;
} TFREC_DRAWONEPRIMITIVE;

typedef struct
{
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
    DWORD               indexCount;
    DWORD               dwFlags;
} TFREC_DRAWONEINDEXEDPRIMITIVE;

typedef struct
{
    DWORD               dwFlags;
} TFREC_DRAWPRIMITIVES;

typedef struct
{
    DWORD               dwFlags;
} TFREC_DRAWPRIMITIVES2;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\inc\haldrv.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 - 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3di.h
 *  Content:    Direct3D HAL driver include file
 *
 ***************************************************************************/

#ifndef _HALDRV_H_
#define _HALDRV_H_

#undef DPF_MODNAME
#define DPF_MODNAME     "Direct3D HAL"

#define SURFACE_MEMORY(surf) \
(LPVOID)(((LPDDRAWI_DDRAWSURFACE_INT)(surf))->lpLcl->lpGbl->fpVidMem)

#ifdef TRACK_HAL_CALLS
#define RESET_HAL_CALLS(lpDevI) ((lpDevI)->hal_calls = 0)
#define TRACK_HAL_CALL(lpDevI) ((lpDevI)->hal_calls++)
#else
#define RESET_HAL_CALLS(lpDevI)
#define TRACK_HAL_CALL(lpDevI)
#endif


#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str


#ifdef WIN95

extern void _stdcall    GetpWin16Lock( LPVOID FAR *);
extern void _stdcall    _EnterSysLevel( LPVOID );
extern void _stdcall    _LeaveSysLevel( LPVOID );
extern LPVOID           lpWin16Lock;

#define LOCK_HAL(ret, lpDevI)                                           \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        _EnterSysLevel(lpWin16Lock);                                    \
    }                                                                   \
    ret = D3D_OK;                                                       \
}

#define UNLOCK_HAL(lpDevI)                                              \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        _LeaveSysLevel(lpWin16Lock);                                    \
    }                                                                   \
}

HRESULT D3DHAL_LockDibEngine(LPDIRECT3DDEVICEI lpDevI);
void D3DHAL_UnlockDibEngine(LPDIRECT3DDEVICEI lpDevI);

#define LOCK_DIBENGINE(ret, lpDevI)                                     \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        ret = D3DHAL_LockDibEngine(lpDevI);                             \
    }                                                                   \
    else    {                                                           \
        ret = D3D_OK;                                                   \
    }                                                                   \
}

#define UNLOCK_DIBENGINE(lpDevI)                                        \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        D3DHAL_UnlockDibEngine(lpDevI);                                 \
    }                                                                   \
}

#else // WIN95

#define LOCK_HAL(ret, lpDevI) ret = DD_OK
#define UNLOCK_HAL(lpDevI)
#define LOCK_DIBENGINE(ret, lpDevI) ret = DD_OK
#define UNLOCK_DIBENGINE(lpDevI)

#endif // WIN95


#define CALL_HALONLY_NOLOCK(ret, lpDevI, call, data)                          \
{                                                                             \
    if (lpDevI->lpD3DHALCallbacks->call) {                                    \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCallbacks->call)(data);                   \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}

#define CALL_HAL2ONLY_NOLOCK(ret, lpDevI, call, data)                         \
{                                                                             \
    if (lpDevI->lpD3DHALCallbacks2->call) {                                   \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCallbacks2->call)(data);                  \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}

#define CALL_HALCBONLY_NOLOCK(ret, lpDevI, call, data)                        \
{                                                                             \
    if (lpDevI->lpD3DHALCommandBufferCallbacks->call) {                       \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCommandBufferCallbacks->call)(data);      \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}

#define CALL_HAL3ONLY_NOLOCK(ret, lpDevI, call, data)                         \
{                                                                             \
    if (lpDevI->lpD3DHALCallbacks3->call) {                                   \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCallbacks3->call)(data);                  \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}


#define CALL_HALONLY(ret, lpDevI, call, data)                           \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HALONLY_NOLOCK(ret, lpDevI, call, data);                   \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}

#define CALL_HALCBONLY(ret, lpDevI, call, data)                         \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HALCBONLY_NOLOCK(ret, lpDevI, call, data);                 \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}

#define CALL_HAL2ONLY(ret, lpDevI, call, data)                          \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HAL2ONLY_NOLOCK(ret, lpDevI, call, data);                  \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}
//-----------------------------------------------------------------------
// Call for callbacks that are not required to be implemented
//
#define CALL_HAL3ONLY_OPTIONAL(ret, lpDevI, call, data)                 \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    if (lpDevI->lpD3DHALCallbacks3->call)                               \
    {                                                                   \
        CALL_HAL3ONLY(ret, lpDevI, call, data);                         \
    }                                                                   \
}
//-----------------------------------------------------------------------
#define CALL_HAL3ONLY(ret, lpDevI, call, data)                          \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HAL3ONLY_NOLOCK(ret, lpDevI, call, data);                  \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}

HRESULT D3DHAL_AllocateBuffer(LPDIRECT3DDEVICEI, LPD3DI_BUFFERHANDLE, LPD3DEXECUTEBUFFERDESC, LPDIRECTDRAWSURFACE*);
HRESULT D3DHAL_DeallocateBuffer(LPDIRECT3DDEVICEI, D3DI_BUFFERHANDLE);
HRESULT D3DHAL_DeallocateBuffers(LPDIRECT3DDEVICEI);
HRESULT D3DHAL_LockBuffer(LPDIRECT3DDEVICEI, D3DI_BUFFERHANDLE, LPD3DEXECUTEBUFFERDESC, LPDIRECTDRAWSURFACE*);
HRESULT D3DHAL_UnlockBuffer(LPDIRECT3DDEVICEI, D3DI_BUFFERHANDLE);
HRESULT D3DHAL_ExecuteClipped(LPDIRECT3DDEVICEI, LPD3DI_EXECUTEDATA);
HRESULT D3DHAL_ExecuteUnclipped(LPDIRECT3DDEVICEI, LPD3DI_EXECUTEDATA);
HRESULT D3DHAL_ExecutePick(LPDIRECT3DDEVICEI, LPD3DI_PICKDATA);
HRESULT D3DHAL_TextureCreate(LPDIRECT3DDEVICEI, LPD3DTEXTUREHANDLE, LPDIRECTDRAWSURFACE);
HRESULT D3DHAL_TextureDestroy(LPD3DI_TEXTUREBLOCK);
HRESULT D3DHAL_TextureSwap(LPDIRECT3DDEVICEI, D3DTEXTUREHANDLE, D3DTEXTUREHANDLE);
__declspec(dllexport) HRESULT D3DHAL_TextureGetSurf(LPDIRECT3DDEVICEI, D3DTEXTUREHANDLE, LPDIRECTDRAWSURFACE*);
HRESULT D3DHAL_MatrixCreate(LPDIRECT3DDEVICEI, LPD3DMATRIXHANDLE);
HRESULT D3DHAL_MatrixDestroy(LPDIRECT3DDEVICEI, D3DMATRIXHANDLE);
HRESULT D3DHAL_MatrixSetData(LPDIRECT3DDEVICEI, D3DMATRIXHANDLE, LPD3DMATRIX);
HRESULT D3DHAL_MatrixGetData(LPDIRECT3DDEVICEI, D3DMATRIXHANDLE, LPD3DMATRIX);
HRESULT D3DFE_SetViewportData(LPDIRECT3DDEVICEI, DWORD, LPD3DVIEWPORT2);
HRESULT D3DHAL_MaterialCreate(LPDIRECT3DDEVICEI, LPD3DMATERIALHANDLE, LPD3DMATERIAL);
HRESULT D3DHAL_MaterialDestroy(LPDIRECT3DDEVICEI, D3DMATERIALHANDLE);
HRESULT D3DHAL_MaterialSetData(LPDIRECT3DDEVICEI, D3DMATERIALHANDLE, LPD3DMATERIAL);
HRESULT D3DHAL_MaterialGetData(LPDIRECT3DDEVICEI, D3DMATERIALHANDLE, LPD3DMATERIAL);
HRESULT D3DHAL_LightSet(LPDIRECT3DDEVICEI, DWORD, LPD3DI_LIGHT);
HRESULT D3DHAL_SceneCapture(LPDIRECT3DDEVICEI, BOOL);

HRESULT D3DHAL_GetState(LPDIRECT3DDEVICEI, DWORD, LPD3DSTATE);

/*********************
 * HEL Calls
 *********************/

/*
 * Calls to emulate instructions.
 */
extern HRESULT D3DHELInst_D3DOP_STATELIGHT(LPDIRECT3DDEVICEI, DWORD, LPD3DSTATE);
extern HRESULT D3DHELInst_D3DOP_TEXTURELOAD(LPDIRECT3DDEVICEI, DWORD, LPD3DTEXTURELOAD);


extern HRESULT D3DFE_Create(LPDIRECT3DDEVICEI lpDevI,
                            LPDIRECTDRAW lpDD,
                            LPDIRECTDRAWSURFACE lpDDS,
                            LPDIRECTDRAWSURFACE lpZ,
                            LPDIRECTDRAWPALETTE lpPal);
extern void D3DFE_Destroy(LPDIRECT3DDEVICEI lpDevI);

/*
 * Transform calls.
 */
extern HRESULT D3DFE_TransformUnclippedVp(D3DFE_PROCESSVERTICES*, DWORD, D3DTRANSFORMDATAI*);
extern HRESULT D3DFE_TransformClippedVp(D3DFE_PROCESSVERTICES*, DWORD, D3DTRANSFORMDATAI*);

/*
 * Lighting calls.
 */
extern HRESULT D3DFE_InitRGBLighting(LPDIRECT3DDEVICEI);
extern void D3DFE_DestroyRGBLighting(LPDIRECT3DDEVICEI);

DWORD   D3DFE_QueryTextureFormat (LPDIRECT3DDEVICEI, LPDDSURFACEDESC*);
HRESULT D3DFE_UpdateTexture (LPDIRECT3DDEVICEI, DWORD, D3DTEXTUREHANDLE);
HRESULT D3DFE_Clear(LPDIRECT3DDEVICEI lpDevI, DWORD dwFlags, DWORD numRect, LPD3DRECT lpRect, D3DCOLORVALUE *pFillColor, D3DTEXTUREHANDLE dwTexture);
HRESULT D3DFE_Clear2(LPDIRECT3DDEVICEI lpDevI, DWORD dwFlags,DWORD numRect, LPD3DRECT lpRect, D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);

HRESULT D3DFE_SetMatrixProj(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat);
HRESULT D3DFE_SetMatrixView(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat);
HRESULT D3DFE_SetMatrixWorld(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat);
HRESULT D3DFE_MultMatrixProj(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat);
HRESULT D3DFE_MultMatrixView(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat);
HRESULT D3DFE_MultMatrixWorld(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat);

//---------------------------------------------------------------------
// This function is called from HALEXE.CPP and from device::SetRenderState
// Always use this function to update RSTATES.
//
HRESULT
SetDeviceRenderState(LPDIRECT3DDEVICEI lpDevI, D3DRENDERSTATETYPE type, 
                     DWORD value);

#ifndef WIN95
__inline HRESULT CheckContextSurface(LPDIRECT3DDEVICEI lpDevI)
{
    if(lpDevI->hSurfaceTarget != ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface)
    {
        D3DHAL_SETRENDERTARGETDATA rtData;
        HRESULT ret;

        rtData.dwhContext = lpDevI->dwhContext;
        if (lpDevI->dwFEFlags & D3DFE_REALHAL)
        {
            if (lpDevI->lpDDSTarget)
                rtData.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl;
            else
                rtData.lpDDSLcl = NULL;
            
            if (lpDevI->lpDDSZBuffer)
                rtData.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSZBuffer)->lpLcl;
            else
                rtData.lpDDSZLcl = NULL;
        }
        else
        {
            rtData.lpDDS = lpDevI->lpDDSTarget;
            rtData.lpDDSZ = lpDevI->lpDDSZBuffer;
        }
  
        rtData.ddrval = 0;
        CALL_HAL2ONLY(ret, lpDevI, SetRenderTarget, &rtData);
        if (ret != DDHAL_DRIVER_HANDLED)
        {
            D3D_ERR ( "Driver did not handle SetRenderTarget" );
            // Need sensible return value in this case,
            // currently we return whatever the lpDevI stuck in here.
            return rtData.ddrval;
        }
        lpDevI->hSurfaceTarget = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface;
    }
    return(D3D_OK);
}

__inline HRESULT CheckContextSurfaceNOLOCK (LPDIRECT3DDEVICEI lpDevI)
{
    if(lpDevI->hSurfaceTarget != ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface)
    {
        D3DHAL_SETRENDERTARGETDATA rtData;
        HRESULT ret;

        rtData.dwhContext = lpDevI->dwhContext;
        if (lpDevI->dwFEFlags & D3DFE_REALHAL)
        {
            if (lpDevI->lpDDSTarget)
                rtData.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl;
            else
                rtData.lpDDSLcl = NULL;
            
            if (lpDevI->lpDDSZBuffer)
                rtData.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSZBuffer)->lpLcl;
            else
                rtData.lpDDSZLcl = NULL;
            
        }
        else
        {
            rtData.lpDDS = lpDevI->lpDDSTarget;
            rtData.lpDDSZ = lpDevI->lpDDSZBuffer;
        }
        rtData.ddrval = 0;
        CALL_HAL2ONLY_NOLOCK(ret, lpDevI, SetRenderTarget, &rtData);
        if (ret != DDHAL_DRIVER_HANDLED)
        {
            D3D_ERR( "Driver did not handle SetRenderTarget" );
            // Need sensible return value in this case,
            // currently we return whatever the lpDevI stuck in here.
            return rtData.ddrval;
        }
        lpDevI->hSurfaceTarget = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface;
    }
    return(D3D_OK);
}
#endif //WIN95

// This struct is used for FindLightingRange RampService
typedef struct tagRAMP_RANGE_INFO
{
    DWORD base;
    DWORD size;
    LPVOID pTexRampMap;
    BOOL specular;
}RAMP_RANGE_INFO;

// This inline is for calling RastService when nothing special is required.
inline HRESULT CallRastService(LPDIRECT3DDEVICEI lpDevI,
                               RastServiceType ServiceType,
                               DWORD arg1,
                               LPVOID arg2)
{
    if (lpDevI->pfnRastService != NULL)
    {
        return lpDevI->pfnRastService(lpDevI->dwhContext,
                                     ServiceType, arg1, arg2);
    }
    else
    {
        return D3D_OK;
    }
}

// This inline is for calling RampService.
// bFlush is set to TRUE  when DrawPrims needs to be flushed.
// Right now, it is set for SetMat and LightState-SetMat.
inline HRESULT CallRampService(LPDIRECT3DDEVICEI lpDevI,
                               RastRampServiceType ServiceType,
                               ULONG_PTR arg1,
                               LPVOID arg2,
                               BOOL bFlush = FALSE)
{
    if (lpDevI->pfnRampService != NULL)
    {
        if (bFlush)
        {
            //time to flush DrawPrimitives
            (*lpDevI->pfnFlushStates)( lpDevI );
        }
        // Call the service
        return lpDevI->pfnRampService(lpDevI->dwhContext,
                                     ServiceType, arg1, arg2);
    }
    else
    {
        return D3D_OK;
    }
}

#endif /* _HALDRV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\clipper.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipper.c
 *  Content:    Clipper
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "clipper.h"
#include "d3dfei.h"

#define GET_NEW_CLIP_VERTEX \
&pv->ClipperState.clip_vertices[pv->ClipperState.clip_vertices_used++];
//---------------------------------------------------------------------
int SetInterpolationFlags(D3DFE_PROCESSVERTICES *pv)
{
    // Figure out which pieces need to be interpolated in new vertices.
    int interpolate = 0;
    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_GOURAUD) 
    {
        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            interpolate |= INTERPOLATE_RCOLOR;
        }
        else
        {
            interpolate |= INTERPOLATE_COLOR;
            if (pv->lpdwRStates[D3DRENDERSTATE_SPECULARENABLE] ||
                pv->lpdwRStates[D3DRENDERSTATE_FOGENABLE]) 
            {
                interpolate |= INTERPOLATE_SPECULAR;
            }
        }
    }
    if (pv->dwDeviceFlags & D3DDEV_LEGACYTEXTURE) 
    {
        interpolate |= INTERPOLATE_TEXTUREL;
    }
    else
    for(DWORD i = 0; i < pv->dwMaxTextureIndices; ++i)
    {
        if(pv->pD3DMappedTexI[i])
        {
            interpolate |= INTERPOLATE_TEXTURE3;
            return interpolate;
        } 
    }
    return interpolate;
}
//---------------------------------------------------------------------
__inline void 
InterpolateColor(ClipVertex *p,
                 ClipVertex *p1,
                 ClipVertex *p2,
                 D3DVALUE num_denom )
{
    int r1, g1, b1, a1;
    int r2, g2, b2, a2;

    r1 = RGBA_GETRED(p1->color);
    g1 = RGBA_GETGREEN(p1->color);
    b1 = RGBA_GETBLUE(p1->color);
    a1 = RGBA_GETALPHA(p1->color);
    r2 = RGBA_GETRED(p2->color);
    g2 = RGBA_GETGREEN(p2->color);
    b2 = RGBA_GETBLUE(p2->color);
    a2 = RGBA_GETALPHA(p2->color);
    p->color = RGBA_MAKE((WORD)(r1 + (r2 - r1) * num_denom),
                         (WORD)(g1 + (g2 - g1) * num_denom),
                         (WORD)(b1 + (b2 - b1) * num_denom),
                         (WORD)(a1 + (a2 - a1) * num_denom));
}
//---------------------------------------------------------------------
void InterpolateRampColor(ClipVertex* p,
                          ClipVertex* p1,
                          ClipVertex* p2,
                          D3DVALUE num_denom )
{
    int a, c, c1, c2;
    int a1, a2;

    c1 = CI_MASKALPHA(p1->color);
    a1 = CI_GETALPHA(p1->color);
    c2 = CI_MASKALPHA(p2->color);
    a2 = CI_GETALPHA(p2->color);

    c = (int)(c1 + (c2 - c1) * num_denom);
    a = (int)(a1 + (a2 - a1) * num_denom);

    p->color = CI_MAKE( a, CI_GETINDEX(c), CI_GETFRACTION(c) );
}
//---------------------------------------------------------------------
__inline void
InterpolateSpecular(ClipVertex *p,
                    ClipVertex *p1,
                    ClipVertex *p2,
                    D3DVALUE num_denom )
{
    int r1, g1, b1, a1;
    int r2, g2, b2, a2;

    r1 = RGBA_GETRED(p1->specular);
    g1 = RGBA_GETGREEN(p1->specular);
    b1 = RGBA_GETBLUE(p1->specular);
    a1 = RGBA_GETALPHA(p1->specular);
    r2 = RGBA_GETRED(p2->specular);
    g2 = RGBA_GETGREEN(p2->specular);
    b2 = RGBA_GETBLUE(p2->specular);
    a2 = RGBA_GETALPHA(p2->specular);
    p->specular = RGBA_MAKE((WORD)(r1 + (r2 - r1) * num_denom),
                            (WORD)(g1 + (g2 - g1) * num_denom),
                            (WORD)(b1 + (b2 - b1) * num_denom),
                            (WORD)(a1 + (a2 - a1) * num_denom));
}
//---------------------------------------------------------------------
__inline D3DVALUE
InterpolateTexture(D3DVALUE t1, 
                   D3DVALUE t2,
                   D3DVALUE num_denom,
                   DWORD    bWrap)
{
    if (!bWrap)
        return ((t2 - t1) * num_denom + t1);
    else
    {
        D3DVALUE t = (TextureDiff(t2, t1, 1) * num_denom + t1);
        if (t > 1.0f)
            t -= 1.0f;
        return t;
    }
}
//---------------------------------------------------------------------
void
Interpolate(D3DFE_PROCESSVERTICES *pv,
            ClipVertex *p, 
            ClipVertex *p1,
            ClipVertex *p2,
            int code,
            int interpolate,
            D3DVALUE num, D3DVALUE denom)
{
    D3DVALUE num_denom = num / denom;

    p->clip = (((int)p1->clip & (int)p2->clip) & ~CLIPPED_ENABLE) | code;
    p->hx = p1->hx + (p2->hx - p1->hx) * num_denom;
    p->hy = p1->hy + (p2->hy - p1->hy) * num_denom;
    p->hz = p1->hz + (p2->hz - p1->hz) * num_denom;
    p->hw = p1->hw + (p2->hw - p1->hw) * num_denom;
    p->color = pv->ClipperState.clip_color;
    p->specular = pv->ClipperState.clip_specular;

    /*
     * Interpolate any other color model or quality dependent values.
     */
    if (interpolate & INTERPOLATE_COLOR) 
    {
        InterpolateColor(p, p1, p2, num_denom);
    } 
    else 
        if (interpolate & INTERPOLATE_RCOLOR) 
        {
            InterpolateRampColor(p, p1, p2, num_denom);
        }

    if (interpolate & INTERPOLATE_SPECULAR) 
    {
        InterpolateSpecular(p, p1, p2, num_denom);
    }

    if (interpolate & INTERPOLATE_TEXTUREL) 
    {
        p->tex[0].u = InterpolateTexture(p1->tex[0].u, p2->tex[0].u, 
                                         num_denom,
                                         pv->lpdwRStates[D3DRENDERSTATE_WRAPU]); 
        p->tex[0].v = InterpolateTexture(p1->tex[0].v, p2->tex[0].v, 
                                         num_denom,
                                         pv->lpdwRStates[D3DRENDERSTATE_WRAPV]); 
    }
    else
    if (interpolate & INTERPOLATE_TEXTURE3) 
    {
        // Assume that D3DRENDERSTATE_WRAPi are sequential
        for (DWORD i = 0; i < pv->nTexCoord; i++)
        {
            DWORD wrapState = pv->lpdwRStates[D3DRENDERSTATE_WRAP0 + i];
            p->tex[i].u = InterpolateTexture(p1->tex[i].u, p2->tex[i].u,
                                             num_denom, wrapState & D3DWRAP_U);
            p->tex[i].v = InterpolateTexture(p1->tex[i].v, p2->tex[i].v, 
                                             num_denom, wrapState & D3DWRAP_V);
        }
    }
}
//------------------------------------------------------------------------------
// Functions for clipping by frustum window
//
#define __CLIP_NAME ClipLeft
#define __CLIP_LINE_NAME ClipLineLeft
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipRight
#define __CLIP_LINE_NAME ClipLineRight
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipBottom
#define __CLIP_LINE_NAME ClipLineBottom
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipTop
#define __CLIP_LINE_NAME ClipLineTop
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipBack
#define __CLIP_LINE_NAME ClipLineBack
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_BACK
#define __CLIP_COORD hz
#include "clip.h"

#define __CLIP_NAME ClipFront
#define __CLIP_LINE_NAME ClipLineFront
#define __CLIP_FLAG CLIPPED_FRONT
#define __CLIP_COORD hz
#include "clip.h"
//------------------------------------------------------------------------------
// Functions for guard band clipping
//
#define __CLIP_GUARDBAND
#define __CLIP_NAME ClipLeftGB
#define __CLIP_LINE_NAME ClipLineLeftGB
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgbx1
#include "clip.h"

#define __CLIP_NAME ClipRightGB
#define __CLIP_LINE_NAME ClipLineRightGB
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#define __CLIP_GBCOEF Kgbx2
#define __CLIP_SIGN +
#include "clip.h"

#define __CLIP_NAME ClipBottomGB
#define __CLIP_LINE_NAME ClipLineBottomGB
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgby1
#include "clip.h"

#define __CLIP_NAME ClipTopGB
#define __CLIP_LINE_NAME ClipLineTopGB
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#define __CLIP_GBCOEF Kgby2
#define __CLIP_SIGN +
#include "clip.h"

#undef __CLIP_GUARDBAND
/*------------------------------------------------------------------------
 * Calculate the screen coords for any new vertices
 * introduced into the polygon.
 */
void ComputeScreenCoordinates(D3DFE_PROCESSVERTICES *pv, 
                              ClipVertex **inv, 
                              int count, D3DRECTV *extent)
{
    int i;
    BOOL updateExtent = !(pv->dwFlags & D3DDP_DONOTUPDATEEXTENTS);
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;

    for (i = 0; i < count; i++) 
    {
        ClipVertex *p;
        p = inv[i];

        /*
         * Catch any vertices that need screen co-ordinates generated.
         * There are two possibilities
         * 	1) Vertices generated during interpolation
         *	2) Vertices marked for clipping by the transform but
         *		not clipped here due to the finite precision
         *		of the floating point unit.
         */

        if (p->clip & ~CLIPPED_ENABLE) 
        {
            D3DVALUE w;

            w = D3DVAL(1.0)/p->hw;
            switch ((int)p->clip & (CLIPPED_LEFT|CLIPPED_RIGHT)) 
            {
            case CLIPPED_LEFT:  p->sx = VPORT.minXgb; break;
            case CLIPPED_RIGHT: p->sx = VPORT.maxXgb; break;
            default:   
                p->sx = p->hx * VPORT.scaleX * w + VPORT.offsetX;
				if (p->sx < VPORT.minXgb)
					p->sx = VPORT.minXgb;
				if (p->sx > VPORT.maxXgb)
					p->sx = VPORT.maxXgb;
            }
            switch ((int)p->clip & (CLIPPED_TOP|CLIPPED_BOTTOM)) 
            {
            case CLIPPED_BOTTOM: p->sy = VPORT.maxYgb; break;
            case CLIPPED_TOP:    p->sy = VPORT.minYgb; break;
            default:
                p->sy = p->hy * VPORT.scaleY * w + VPORT.offsetY;
				if (p->sy < VPORT.minYgb)
					p->sy = VPORT.minYgb;
				if (p->sy > VPORT.maxYgb)
					p->sy = VPORT.maxYgb;
            }
            p->sz = p->hz * w;
            if (updateExtent)
            {
                if (p->sx < extent->x1)
                    extent->x1 = p->sx;
                if (p->sy < extent->y1)
                    extent->y1 = p->sy;
                if (p->sx  > extent->x2)
                    extent->x2 = p->sx;
                if (p->sy > extent->y2)
                    extent->y2 = p->sy;
            }
        }
    }
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCodeGB(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    if (p->hx < p->hw * pv->vcache.Kgbx1)
        clip |= __D3DCLIPGB_LEFT;
    if (p->hx > p->hw * pv->vcache.Kgbx2)
        clip |= __D3DCLIPGB_RIGHT;
    if (p->hy < p->hw * pv->vcache.Kgby1)
        clip |= __D3DCLIPGB_BOTTOM;
    if (p->hy > p->hw * pv->vcache.Kgby2)
        clip |= __D3DCLIPGB_TOP;
    if (p->hz > p->hw)
        clip |= D3DCLIP_BACK;
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCode(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    if (FLOAT_LTZ(p->hx))
        clip |= D3DCLIP_LEFT;
    if (p->hx > p->hw)
        clip |= D3DCLIP_RIGHT;
    if (FLOAT_LTZ(p->hy))
        clip |= D3DCLIP_BOTTOM;
    if (p->hy > p->hw)
        clip |= D3DCLIP_TOP;
    if (p->hz > p->hw)
        clip |= D3DCLIP_BACK;
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}
//***********************************************************************
//
//  Returns 0, if triangle is clipped. Number of vertices otherwise.
//
#undef DPF_MODNAME
#define DPF_MODNAME "ClipSingleTriangle"

int D3DFE_PVFUNCS::ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                      ClipTriangle *tri,
                                      ClipVertex ***clipVertexPointer,
                                      int interpolate)
{
    int accept;
    int i;
    int count;
    ClipVertex **inv;
    ClipVertex **outv;
    ClipVertex *p;
    ULONG_PTR swapv;

    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
    {
        // It is easier to set all vertices to the same color here
        D3DCOLOR diffuse  = tri->v[0]->color;        
        D3DCOLOR specular = tri->v[0]->specular;        
        tri->v[1]->color= diffuse;
        tri->v[1]->specular = specular;
        tri->v[2]->color = diffuse;
        tri->v[2]->specular = specular;
    }
    accept = (tri->v[0]->clip | tri->v[1]->clip | tri->v[2]->clip);

    inv = tri->v;

    if (tri->flags & D3DTRIFLAG_EDGEENABLE1)
        tri->v[0]->clip |= CLIPPED_ENABLE;
    if (tri->flags & D3DTRIFLAG_EDGEENABLE2)
        tri->v[1]->clip |= CLIPPED_ENABLE;
    if (tri->flags & D3DTRIFLAG_EDGEENABLE3)
        tri->v[2]->clip |= CLIPPED_ENABLE;

    count = 3;
    outv = pv->ClipperState.clip_vbuf1;
    pv->ClipperState.clip_color = tri->v[0]->color;
    pv->ClipperState.clip_specular = tri->v[0]->specular;

    /*
     * XXX assumes sizeof(void*) == sizeof(unsigned long)
     */
    {
        ULONG_PTR tmp1;
        ULONG_PTR tmp2;

        tmp1 = (ULONG_PTR)pv->ClipperState.clip_vbuf1;
        tmp2 = (ULONG_PTR)pv->ClipperState.clip_vbuf2;

        swapv = tmp1 + tmp2;
    }
    pv->ClipperState.clip_vertices_used = 0;

#define SWAP(inv, outv)     \
    inv = outv;             \
    outv = (ClipVertex**) (swapv - (ULONG_PTR) outv)

    if (accept & D3DCLIP_FRONT) 
    {
        count = ClipFront(pv, inv, outv, count, interpolate);
        if (count < 3)
            goto out_of_here;
        SWAP(inv, outv);
    }
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT) 
        {
            accept = 0;
            for (i = 0; i < count; i++) 
            {
                ClipVertex *p;
                p = inv[i];
                if (p->clip & CLIPPED_FRONT)
                    accept |= ComputeClipCodeGB(pv, p);
                else
                    accept |= p->clip;
            }
        }
        if (accept & D3DCLIP_BACK) 
        {
            count = ClipBack(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_LEFT) 
        {
            count = ClipLeftGB(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_RIGHT) 
        {
            count = ClipRightGB(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_BOTTOM) 
        {
            count = ClipBottomGB(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_TOP) 
        {
            count = ClipTopGB(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT) 
        {
            accept = 0;
            for (i = 0; i < count; i++) 
            {
                ClipVertex *p;
                p = inv[i];
                if (p->clip & (CLIPPED_FRONT))
                    accept |= ComputeClipCode(pv, p);
                else
                    accept |= p->clip;
            }
        }
        if (accept & D3DCLIP_BACK) 
        {
            count = ClipBack(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_LEFT) 
        {
            count = ClipLeft(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_RIGHT) 
        {
            count = ClipRight(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_BOTTOM) 
        {
            count = ClipBottom(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_TOP) 
        {
            count = ClipTop(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }

#undef SWAP

    ComputeScreenCoordinates(pv, inv, count, &pv->rExtents);

    *clipVertexPointer = inv;
    pv->ClipperState.current_vbuf = inv;
    return count;
out_of_here:
    *clipVertexPointer = NULL;
    return 0;
}
//*************************************************************************
//
#undef DPF_MODNAME
#define DPF_MODNAME "ClipSingleLine"

int
ClipSingleLine(D3DFE_PROCESSVERTICES *pv,
               ClipTriangle *line,
               D3DRECTV *extent,
               int interpolate)
{
    int         accept;
    D3DVALUE    in1, in2;

    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    accept = (line->v[0]->clip | line->v[1]->clip);

    pv->ClipperState.clip_color = line->v[0]->color;
    pv->ClipperState.clip_specular = line->v[0]->specular;

    if (accept & D3DCLIP_FRONT) 
        if (ClipLineFront(pv, line, interpolate))
            goto out_of_here;
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT) 
        {
            ClipVertex * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(pv, p);
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(pv, p);
            else
                accept |= p->clip;
        }
        if (accept & D3DCLIP_BACK) 
            if (ClipLineBack(pv, line, interpolate))
                goto out_of_here;
        if (accept & __D3DCLIPGB_LEFT) 
            if (ClipLineLeftGB(pv, line, interpolate))
                goto out_of_here;
        if (accept & __D3DCLIPGB_RIGHT) 
            if (ClipLineRightGB(pv, line, interpolate))
                goto out_of_here;
        if (accept & __D3DCLIPGB_TOP) 
            if (ClipLineTopGB(pv, line, interpolate))
                goto out_of_here;
        if (accept & __D3DCLIPGB_BOTTOM) 
            if (ClipLineBottomGB(pv, line, interpolate))
                goto out_of_here;
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT) 
        {
            ClipVertex * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode(pv, p);
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode(pv, p);
            else
                accept |= p->clip;
        }
        if (accept & D3DCLIP_BACK) 
            if (ClipLineBack(pv, line, interpolate))
                goto out_of_here;
        if (accept & D3DCLIP_LEFT) 
            if (ClipLineLeft(pv, line, interpolate))
                goto out_of_here;
        if (accept & D3DCLIP_RIGHT) 
            if (ClipLineRight(pv, line, interpolate))
                goto out_of_here;
        if (accept & D3DCLIP_TOP) 
            if (ClipLineTop(pv, line, interpolate))
                goto out_of_here;
        if (accept & D3DCLIP_BOTTOM) 
            if (ClipLineBottom(pv, line, interpolate))
                goto out_of_here;
    }

    ComputeScreenCoordinates(pv, line->v, 2, extent);

    return 1;
out_of_here:
    return 0;
} // ClipSingleLine
//----------------------------------------------------------------------
//    GenClipFlags()  Generates clip flags for a set of FVF 
//
#undef DPF_MODNAME
#define DPF_MODNAME "GenClipFlags"

DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv)
{
    DWORD clip_intersection, clip_union;
    float left   = pv->vcache.minX;
    float top    = pv->vcache.minY;
    float right  = pv->vcache.maxX;
    float bottom = pv->vcache.maxY;
    float leftgb  ;         // Guard band window
    float topgb   ;
    float rightgb ;
    float bottomgb;
    DWORD clipZF, clipZB;
    DWORD stride = pv->position.dwStride;

    clipZF = pv->lpdwRStates[D3DRENDERSTATE_ZENABLE] ? D3DCLIP_FRONT : 0;
    clipZB = pv->lpdwRStates[D3DRENDERSTATE_ZENABLE] ? D3DCLIP_BACK : 0;

    clip_intersection = (DWORD)~0;
    clip_union = (DWORD)0;

    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        leftgb   = pv->vcache.minXgb;
        topgb    = pv->vcache.minYgb;
        rightgb  = pv->vcache.maxXgb;
        bottomgb = pv->vcache.maxYgb;
    }
    if (pv->dwFlags & D3DDP_DONOTUPDATEEXTENTS)
    { /* Only generate clip flags */
        D3DTLVERTEX *lpVertices = (D3DTLVERTEX*)pv->position.lpvData;
        D3DFE_CLIPCODE *clipCode = pv->lpClipFlags;
        DWORD i;
        for (i = pv->dwNumVertices; i; i--) 
        {
            DWORD clip = 0;
            D3DVALUE x,y,z;
            if (lpVertices->rhw < 0)
            {
                x = -lpVertices->sx;
                y = -lpVertices->sy;
                z = -lpVertices->sz;
            }
            else
            {
                x = lpVertices->sx;
                y = lpVertices->sy;
                z = lpVertices->sz;
            }

            if (x < left) 
                clip |= D3DCLIP_LEFT;
            else 
            if (x >= right) 
                clip |= D3DCLIP_RIGHT;

            if (y < top) 
                clip |= D3DCLIP_TOP;
            else 
            if (y >= bottom) 
                clip |= D3DCLIP_BOTTOM;

            if (z < 0.0f) 
                clip |= clipZF;
            else 
            if (z >= 1.0f) 
                clip |= clipZB;

            if (pv->dwDeviceFlags & D3DDEV_GUARDBAND && clip)
            {
                if (x < leftgb) 
                    clip |= __D3DCLIPGB_LEFT;
                else 
                if (x >= rightgb) 
                    clip |= __D3DCLIPGB_RIGHT;

                if (y < topgb) 
                    clip |= __D3DCLIPGB_TOP;
                else 
                if (y >= bottomgb) 
                    clip |= __D3DCLIPGB_BOTTOM;
            }

            clip_intersection &= clip;
            clip_union |= clip;
            *clipCode++ = (D3DFE_CLIPCODE)clip;
            lpVertices = (D3DTLVERTEX*)((char*)lpVertices + stride);
        }
    } 
    else
    { /* Generate Clip Flags and Update Extents */
        DWORD i;
        float minx = pv->rExtents.x1;
        float miny = pv->rExtents.y1;
        float maxx = pv->rExtents.x2;
        float maxy = pv->rExtents.y2;
        D3DTLVERTEX *lpVertices = (D3DTLVERTEX*)pv->position.lpvData;
        D3DFE_CLIPCODE *clipCode = pv->lpClipFlags;
        for (i = pv->dwNumVertices; i; i--) 
        {
            DWORD clip = 0;
            D3DVALUE x,y,z;
            if (lpVertices->rhw < 0)
            {
                x = -lpVertices->sx;
                y = -lpVertices->sy;
                z = -lpVertices->sz;
            }
            else
            {
                x = lpVertices->sx;
                y = lpVertices->sy;
                z = lpVertices->sz;
            }

            if (x < left)
                clip |= D3DCLIP_LEFT;
            else 
            if (x >= right)
                clip |= D3DCLIP_RIGHT;

            if (y < top)
                clip |= D3DCLIP_TOP;
            else 
            if (y >= bottom)
                clip |= D3DCLIP_BOTTOM;

            if (z < 0.0f)
                clip |= clipZF;
            else 
            if (z >= 1.0f)
                clip |= clipZB;

            if (pv->dwDeviceFlags & D3DDEV_GUARDBAND && clip)
            {
                if (x < leftgb) 
                    clip |= __D3DCLIPGB_LEFT;
                else 
                if (x >= rightgb) 
                    clip |= __D3DCLIPGB_RIGHT;

                if (y < topgb) 
                    clip |= __D3DCLIPGB_TOP;
                else 
                if (y >= bottomgb) 
                    clip |= __D3DCLIPGB_BOTTOM;
            }
            // Update extents only if the vertex is inside
            if (clip == 0 || 
                ((pv->dwDeviceFlags & D3DDEV_GUARDBAND) && 
                 ((clip & ~__D3DCLIP_INGUARDBAND) == 0)))
            {
                if (x < minx)
                    minx = x;
                if (x > maxx)
                    maxx = x;
                if (y < miny)
                    miny = y;
                if (y > maxy)
                    maxy = y;
            }

            clip_intersection &= clip;
            clip_union |= clip;
            *clipCode++ = (D3DFE_CLIPCODE)clip;
            lpVertices = (D3DTLVERTEX*)((char*)lpVertices + stride);
        }
        pv->rExtents.x1 = minx;
        pv->rExtents.y1 = miny;
        pv->rExtents.x2 = maxx;
        pv->rExtents.y2 = maxy;
    }

    pv->dwClipIntersection = clip_intersection;
    pv->dwClipUnion = clip_union;

    return clip_intersection;
}   // end of GenClipFlags()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\gensym.cpp ===
/*
 * $Id: gensym.cpp,v 1.7 1995/11/21 14:45:51 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#include <stdio.h>
#include "d3di.hpp"

#define DEFINE(type, member) \
    printf(#type "_" #member "  equ 0%xh\n", ((LONG)(&((type *)0)->member)))

#define MACRO(name) \
    printf(#name "  equ 0%xh\n", name)

// pcomment prints a comment.

#define pcomment(s)  printf("; %s\n",s)

// pequate prints an equate statement.

#define pequate(name, value) printf("%s equ 0%lXH\n",name,value);

#define OFFSET(type, field) ((LONG)(&((type *)0)->field))

// pblank prints a blank line.

#define pblank()     printf("\n")

#define printVCACHE(name)  \
{                               \
    printf("%-30s equ 0%LXH\n", "PV_LIGHTING_"#name, OFFSET(D3DFE_PROCESSVERTICES, vcache.##name)); \
} 

#define printD3DI_LIGHT(name)   \
{                               \
    printf("%-30s equ 0%LXH\n", "D3DI_LIGHT_"#name, OFFSET(D3DI_LIGHT, name)); \
} 

#define printD3DFE_LIGHTING(name)  \
{                               \
    printf("%-30s equ 0%LXH\n", "PV_LIGHTING_"#name, OFFSET(D3DFE_PROCESSVERTICES, lighting.##name)); \
} 

#define printDevice(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", "DEVI_"#name, OFFSET(DIRECT3DDEVICEI, name)); \
} 

#define printDeviceDP2(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", #name, OFFSET(CDirect3DDeviceIDP2, name)); \
} 

int main()
{
pcomment("------------------------------------------------------------------");
    pcomment(" Module Name: offsets.asm");
    pcomment("");
    pcomment(" Defines D3D assembly-language structures.");
    pcomment(" This file is generated");
    pcomment("");
    pcomment(" Copyright (c) 1998, 1995 Microsoft Corporation");
pcomment("------------------------------------------------------------------");
    pblank();
    pblank();

    DEFINE(D3DINSTRUCTION, wCount);
    DEFINE(D3DINSTRUCTION, bSize);
    DEFINE(D3DINSTRUCTION, bOpcode);
    
    DEFINE(D3DVERTEX, x);
    DEFINE(D3DVERTEX, y);
    DEFINE(D3DVERTEX, z);
    DEFINE(D3DVERTEX, tu);
    DEFINE(D3DVERTEX, tv);

    DEFINE(D3DLVERTEX, color);
    DEFINE(D3DLVERTEX, specular);

    DEFINE(D3DTLVERTEX, sx);
    DEFINE(D3DTLVERTEX, sy);
    DEFINE(D3DTLVERTEX, sz);
    DEFINE(D3DTLVERTEX, rhw);
    DEFINE(D3DTLVERTEX, color);
    DEFINE(D3DTLVERTEX, specular);
    DEFINE(D3DTLVERTEX, tu);
    DEFINE(D3DTLVERTEX, tv);
    printf("D3DTLVERTEX_size    equ %d\n", sizeof(D3DTLVERTEX));

    DEFINE(D3DHVERTEX, dwFlags);
    DEFINE(D3DHVERTEX, hx);
    DEFINE(D3DHVERTEX, hy);
    DEFINE(D3DHVERTEX, hz);
    printf("D3DHVERTEX_size equ %d\n", sizeof(D3DHVERTEX));
    
    DEFINE(D3DTRIANGLE, v1);
    DEFINE(D3DTRIANGLE, v2);
    DEFINE(D3DTRIANGLE, v3);
    DEFINE(D3DTRIANGLE, wFlags);
    printf("D3DTRIANGLE_size equ %d\n", sizeof(D3DTRIANGLE));

    DEFINE(D3DMATRIXI, _11);
    DEFINE(D3DMATRIXI, _12);
    DEFINE(D3DMATRIXI, _13);
    DEFINE(D3DMATRIXI, _14);
    DEFINE(D3DMATRIXI, _21);
    DEFINE(D3DMATRIXI, _22);
    DEFINE(D3DMATRIXI, _23);
    DEFINE(D3DMATRIXI, _24);
    DEFINE(D3DMATRIXI, _31);
    DEFINE(D3DMATRIXI, _32);
    DEFINE(D3DMATRIXI, _33);
    DEFINE(D3DMATRIXI, _34);
    DEFINE(D3DMATRIXI, _41);
    DEFINE(D3DMATRIXI, _42);
    DEFINE(D3DMATRIXI, _43);
    DEFINE(D3DMATRIXI, _44);
    DEFINE(D3DMATRIXI, type);

    DEFINE(D3DLIGHTINGELEMENT, dvPosition);
    DEFINE(D3DLIGHTINGELEMENT, dvNormal);
    printf("D3DMATRIXI_size equ %d\n", sizeof(D3DMATRIXI));
    printf("D3DFE_LIGHTING_size equ %d\n", sizeof(D3DFE_LIGHTING));
    printf("D3DFE_VIEWPORTCACHE_size equ %d\n", sizeof(D3DFE_VIEWPORTCACHE));

    MACRO(D3DOP_TRIANGLE);

    MACRO(D3DCLIP_LEFT);
    MACRO(D3DCLIP_RIGHT);
    MACRO(D3DCLIP_TOP);
    MACRO(D3DCLIP_BOTTOM);
    MACRO(D3DCLIP_FRONT);
    MACRO(D3DCLIP_BACK);

    MACRO(D3DTBLEND_COPY);
    MACRO(D3DSHADE_FLAT);

    MACRO(D3DCMP_LESSEQUAL);
    MACRO(D3DCMP_GREATEREQUAL);
    MACRO(D3DCMP_ALWAYS);

    MACRO(D3DSTATUS_ZNOTVISIBLE);
    MACRO(D3DDP_DONOTUPDATEEXTENTS);

// Geometry pipeline
pcomment("-------------------- VCACHE ------------------------------------");
    printVCACHE(scaleX);
    printVCACHE(scaleY);
    printVCACHE(offsetX);
    printVCACHE(offsetY);
    printVCACHE(minXgb);
    printVCACHE(minYgb);
    printVCACHE(maxXgb);
    printVCACHE(maxYgb);
    printVCACHE(minX);
    printVCACHE(minY);
    printVCACHE(maxX);
    printVCACHE(maxY);
    printVCACHE(gb11);
    printVCACHE(gb22);
    printVCACHE(gb41);
    printVCACHE(gb42);
    printVCACHE(Kgbx1);
    printVCACHE(Kgby1);
    printVCACHE(Kgbx2);
    printVCACHE(Kgby2);
    printVCACHE(dvX);
    printVCACHE(dvY);
    printVCACHE(dvWidth);
    printVCACHE(dvHeight);
    printVCACHE(scaleXi);
    printVCACHE(scaleYi);
    printVCACHE(minXi);
    printVCACHE(minYi);
    printVCACHE(maxXi);
    printVCACHE(maxYi);
    printVCACHE(mclip11);
    printVCACHE(mclip41);
    printVCACHE(mclip22);
    printVCACHE(mclip42);
    printVCACHE(mclip33);
    printVCACHE(mclip43);
pcomment("---------------- D3DFE_LIGHTING ------------------------------------");
    printD3DFE_LIGHTING(diffuse);
    printD3DFE_LIGHTING(alpha);
    printD3DFE_LIGHTING(diffuse0);
    printD3DFE_LIGHTING(currentSpecTable);
    printD3DFE_LIGHTING(specular);
    printD3DFE_LIGHTING(outDiffuse);
    printD3DFE_LIGHTING(vertexDiffuse);
    printD3DFE_LIGHTING(outSpecular);
    printD3DFE_LIGHTING(vertexSpecular);
    printD3DFE_LIGHTING(specularComputed);
    printD3DFE_LIGHTING(activeLights);
    printD3DFE_LIGHTING(material);
    printD3DFE_LIGHTING(hMat);
    printD3DFE_LIGHTING(ambient_red);
    printD3DFE_LIGHTING(ambient_green);
    printD3DFE_LIGHTING(ambient_blue);
    printD3DFE_LIGHTING(fog_mode);
    printD3DFE_LIGHTING(fog_density);
    printD3DFE_LIGHTING(fog_start);
    printD3DFE_LIGHTING(fog_end);
    printD3DFE_LIGHTING(fog_factor);
    printD3DFE_LIGHTING(fog_factor_ramp);
    printD3DFE_LIGHTING(specThreshold);
    printD3DFE_LIGHTING(color_model);
    printD3DFE_LIGHTING(ambient_save);
pcomment("---------------- D3DI_LIGHT ------------------------------------");
    printD3DI_LIGHT(model_position);
    printD3DI_LIGHT(type);
    printD3DI_LIGHT(model_direction);
    printD3DI_LIGHT(version);
    printD3DI_LIGHT(model_eye);
    printD3DI_LIGHT(flags);
    printD3DI_LIGHT(model_scale);
    printD3DI_LIGHT(falloff);
    printD3DI_LIGHT(local_diffR);
    printD3DI_LIGHT(local_diffG);
    printD3DI_LIGHT(local_diffB);
    printD3DI_LIGHT(valid);
    printD3DI_LIGHT(local_specR);
    printD3DI_LIGHT(local_specG);
    printD3DI_LIGHT(local_specB);
    printD3DI_LIGHT(inv_theta_minus_phi);
    printD3DI_LIGHT(halfway);
    printD3DI_LIGHT(next);
    printD3DI_LIGHT(red);
    printD3DI_LIGHT(green);
    printD3DI_LIGHT(blue);
    printD3DI_LIGHT(shade);
    printD3DI_LIGHT(range_squared);
    printD3DI_LIGHT(attenuation0);
    printD3DI_LIGHT(attenuation1);
    printD3DI_LIGHT(attenuation2);
    printD3DI_LIGHT(cos_theta_by_2);
    printD3DI_LIGHT(cos_phi_by_2);
    printD3DI_LIGHT(position);
    printD3DI_LIGHT(direction);
    printD3DI_LIGHT(range);
  
pcomment("---------------- DIRECT3DDEVICEI ------------------------------------");
    printDevice(dwVersion);
    printDevice(dwRampBase);
    printDevice(dvRampScale);
    printDevice(lpvRampTexture);
    printDevice(mCTM);
    printDevice(dwMaxTextureIndices);
    printDevice(lighting);
    printDevice(vcache);
    printDevice(dvExtentsAdjust);
    printDevice(lpdwRStates);
    printDevice(pD3DMappedTexI);
    printDevice(ClipperState);
    printDevice(dwVertexBase);
    printDevice(dwFlags);
    printDevice(dwDeviceFlags);
    printDevice(dwNumVertices);
    printDevice(dwNumPrimitives);
    printDevice(dwNumIndices);
    printDevice(lpwIndices);
    printDevice(primType);
    printDevice(nTexCoord);
    printDevice(position);
    printDevice(normal);
    printDevice(diffuse);
    printDevice(specular);
    printDevice(textures);
    printDevice(dwVIDIn);
    printDevice(dwVIDOut);
    printDevice(dwOutputSize);
    printDevice(lpvOut);
    printDevice(lpClipFlags);
    printDevice(rExtents);
    printDevice(dwClipUnion);
    printDevice(dwClipIntersection);
    printDevice(pfnFlushStates            );
    printDevice(deviceType                );
    printDevice(lpDirect3DI               );
    printDevice(list                      );
    printDevice(texBlocks                 );
    printDevice(buffers                   );
    printDevice(numViewports              );
    printDevice(viewports                 );
    printDevice(lpCurrentViewport         );
    printDevice(matBlocks                 );
    printDevice(mDevUnk                   );
    printDevice(guid                      );
    printDevice(matBlocks                 );
    printDevice(mDevUnk                   );
    printDevice(guid                      );
    printDevice(lpD3DHALCallbacks         );
    printDevice(lpD3DHALGlobalDriverData  );
    printDevice(lpD3DHALCallbacks2        );
    printDevice(lpD3DHALCallbacks3        );
    printDevice(lpDD                      );
    printDevice(lpDDGbl                   );
    printDevice(lpDDSTarget               );
    printDevice(lpDDSZBuffer              );
    printDevice(lpDDPalTarget             );
    printDevice(lpDDSTarget_DDS4          );
    printDevice(lpDDSZBuffer_DDS4         );
    printDevice(dwWidth                   );
    printDevice(dwHeight                  );
    printDevice(transform                 );
    printDevice(dwhContext                );
    printDevice(bufferHandles             );
    printDevice(pfnDrawPrim               );
    printDevice(pfnDrawIndexedPrim        );
    printDevice(red_mask                  );
    printDevice(red_scale                 );
    printDevice(red_shift                 );
    printDevice(green_mask);
    printDevice(green_scale);
    printDevice(green_shift);
    printDevice(blue_mask);
    printDevice(blue_scale);
    printDevice(blue_shift);
    printDevice(zmask_shift);
    printDevice(stencilmask_shift);
    printDevice(bDDSTargetIsPalettized);
    printDevice(pick_data);
    printDevice(lpbClipIns_base);
    printDevice(dwClipIns_offset);
    printDevice(renderstate_overrides);
    printDevice(transformstate_overrides);
    printDevice(lightstate_overrides);
    printDevice(iClipStatus);
    printDevice(D3DStats);
    printDevice(dwFVFLastIn);
    printDevice(dwFVFLastOut);
    printDevice(dwFVFLastTexCoord);
    printDevice(dwFVFLastOutputSize);
    printDevice(dwFEFlags);
    printDevice(dwDebugFlags);
    printDevice(v_id);
    printDevice(numLights);
    printDevice(specular_tables);
    printDevice(specular_table);
    printDevice(materials);
    printDevice(lightVertexFuncTable);
    printDevice(pHalProv);
    printDevice(hDllProv);
    printDevice(pfnDoFlushBeginEnd);
    printDevice(d3dHWDevDesc);
    printDevice(d3dHELDevDesc);
    printDevice(lpOwningIUnknown);
    printDevice(lpD3DMappedTexI);
    printDevice(lpD3DMappedBlock);
    printDevice(lpClipper);
    printDevice(dwHintFlags);
    printDevice(lpcCurrentPtr);
    printDevice(BeginEndCSect);
    printDevice(lpvVertexBatch);
    printDevice(lpIndexBatch);
    printDevice(lpvVertexData);
    printDevice(dwBENumVertices);
    printDevice(dwMaxVertexCount);
    printDevice(lpVertexIndices);
    printDevice(dwBENumIndices);
    printDevice(dwMaxIndexCount);
    printDevice(wFlushed);
    printDevice(lpTextureBatched);
    printDevice(lpwDPBuffer);
    printDevice(dwCurrentBatchVID);
    printDevice(lpDPPrimCounts);
    printDevice(lpHWCounts);
    printDevice(lpHWTris);
    printDevice(lpHWVertices);
    printDevice(dwHWOffset);
    printDevice(dwHWMaxOffset);
    printDevice(dwHWTriIndex);
    printDevice(dwHWNumCounts);
    printDevice(dwDPOffset);
    printDevice(dwDPMaxOffset);
    printDevice(wTriIndex);
    printDevice(TLVbuf);
    printDevice(HVbuf);
    printDevice(lpD3DExtendedCaps);
    printDevice(rstates);
    printDevice(tsstates);
    printDevice(pfnRampService);
    printDevice(pfnRastService);
    printDevice(pGeometryFuncs);
    printDevice(mWV);
pcomment("---------------- CDirect3DDeviceIDP2 ----------------------");
    printDeviceDP2(lpDDSCB1);
    printDeviceDP2(lpvDP2Commands);
    printDeviceDP2(lpDP2CurrCommand);
    printDeviceDP2(dp2data);
    printDeviceDP2(dwDP2CommandLength);
    printDeviceDP2(dwDP2CommandBufSize);
    printDeviceDP2(bDP2CurrCmdOP);
    printDeviceDP2(wDP2CurrCmdCnt);
    printDeviceDP2(dwDP2Flags);
pcomment("---------------- MISC ------------------------------------");
    /*                                     
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    */
    pequate("_R_", 0);
    pequate("_G_", 4);
    pequate("_B_", 8);

    pequate("_X_", 0);
    pequate("_Y_", 4);
    pequate("_Z_", 8);
    pequate("_W_", 12);
    pequate("D3DLIGHTI_COMPUTE_SPECULAR ", D3DLIGHTI_COMPUTE_SPECULAR);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\dpclip.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpclip.c
 *  Content:    DrawPrimitive clipper
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "clipfunc.h"
#include "drawprim.hpp"

//---------------------------------------------------------------------
inline HRESULT DRAW_PRIM(D3DFE_PROCESSVERTICES *pv, 
                         D3DPRIMITIVETYPE primitiveType, 
                         LPVOID startVertex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpvOut = startVertex;                                    
    pv->primType = primitiveType;                                
    pv->dwNumVertices = vertexCount;                             
    pv->dwNumPrimitives = numPrim;
    // PSGP implementation should not implement INSIDEEXECUTE should do
    // ret = pv->DrawPrim();  !!!
    HRESULT ret = (((LPDIRECT3DDEVICEI)pv)->*(((LPDIRECT3DDEVICEI)pv)->pfnDrawPrim))();                                  
    return ret;   
}
//---------------------------------------------------------------------
inline HRESULT DRAW_INDEX_PRIM(D3DFE_PROCESSVERTICES *pv, 
                               D3DPRIMITIVETYPE primitiveType, 
                               LPWORD startIndex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpwIndices = startIndex;                                     
    pv->primType = primitiveType;                                    
    pv->dwNumIndices = vertexCount;                                  
    pv->dwNumPrimitives = numPrim;                                   
    // PSGP implementation should not implement INSIDEEXECUTE. It should do
    // ret = pv->DrawIndexPrim();  !!!
    HRESULT ret = (((LPDIRECT3DDEVICEI)pv)->*(((LPDIRECT3DDEVICEI)pv)->pfnDrawIndexedPrim))();                                  
    return ret;
}
//----------------------------------------------------------------------
__inline HRESULT Clip(D3DFE_PROCESSVERTICES *pv, 
                      int interpolate, 
                      ClipVertex *cv,
                      WORD wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE)
{
    ClipTriangle newtri;
    LPVOID saveVer = pv->lpvOut;          // For indexed primitive
    DWORD numVer = pv->dwNumVertices;     // For indexed primitive
    newtri.v[0] = &cv[0];
    newtri.v[1] = &cv[1];
    newtri.v[2] = &cv[2];
    newtri.flags = wFlags;

    int count;
    ClipVertex** ver;
    LPDIRECT3DDEVICEI lpDevI = static_cast<LPDIRECT3DDEVICEI>(pv);

    if (count = lpDevI->pGeometryFuncs->ClipSingleTriangle(
                                   pv, &newtri, &ver, interpolate))
    {
        int i;
        HRESULT ret;
        BYTE *pTLV = (BYTE*)pv->ClipperState.clipBuf.GetAddress();
        BYTE *p = pTLV;

        for (i = 0; i < count; i++) 
        {
            MAKE_TL_VERTEX_FVF(pv, p, ver[i]);
            p += pv->dwOutputSize;
        }
        pv->dwFlags |= D3DPV_CLIPPERPRIM; // Mark this call as gen by clipper
        ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, pTLV, count, count-2);
        pv->dwFlags &= ~D3DPV_CLIPPERPRIM;
        if (ret)
            return ret;
    }
    pv->lpvOut = saveVer;
    pv->dwNumVertices = numVer;
    return D3D_OK;
}
//------------------------------------------------------------------------------
HRESULT ProcessClippedTriangleFan(D3DFE_PROCESSVERTICES *pv)
{
    BYTE   *p1;
    DWORD   f1;
    DWORD clipMaskOffScreen;                                
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    int         interpolate;                                
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
    BYTE       *startVertex;                                
    int         vertexCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;;
    clipCode = pv->lpClipFlags;                      
    interpolate = SetInterpolationFlags(pv);            
    vertex = (BYTE*)pv->lpvOut;                      
    startVertex = (BYTE*)pv->lpvOut;                 
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)               
    {                                                       
        clipMaskOffScreen = ~__D3DCLIP_INGUARDBAND;         
    }                                                       
    else                                                    
    {                                                       
        clipMaskOffScreen = 0xFFFFFFFF;                     
    }

    f1 = clipCode[0];
    p1 = vertex;
    clipCode++;
    vertex += vertexSize;
    // In the clipper color from the first vertex is propagated to all
    // vertices for FLAT shade mode. In triangle fans the second vertex defines
    // the color in FLAT shade mode. So we will make the vertex order: 1, 2, 0
    MAKE_CLIP_VERTEX_FVF(pv, cv[2], p1, f1, vertexTransformed, clipMaskOffScreen);
    for (i = pv->dwNumVertices-2; i; i--) 
    {
        DWORD f2, f3;     // vertex clip flags
        f2 = clipCode[0];
        f3 = clipCode[1];

        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & clipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                BYTE tmp[__MAX_VERTEX_SIZE];
                BYTE *pStart = startVertex;
                if (startVertex != p1)
                {
                    pStart -= vertexSize;
                    memcpy (tmp, pStart, vertexSize);
                    memcpy (pStart, p1, vertexSize);
                }
                // Mark this call as gen by clipper, but set non clipped bit
                pv->dwFlags |= D3DPV_CLIPPERPRIM | D3DPV_NONCLIPPED; 
                ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, 
                            vertexCount);
                pv->dwFlags &= ~(D3DPV_CLIPPERPRIM | D3DPV_NONCLIPPED);
                if (ret)
                    return ret;
                if (startVertex != p1)
                    memcpy (pStart, tmp, vertexSize);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            vertexCount = 0;
            startVertex = vertex + vertexSize;

            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p2 = vertex;
                BYTE *p3 = vertex + vertexSize;

                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p2, f2, vertexTransformed, clipMaskOffScreen);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p3, f3, vertexTransformed, clipMaskOffScreen);

                ret = Clip(pv, interpolate, cv);
                if (ret) return ret;
            }
        } else 
            vertexCount++;
        clipCode++;
        vertex += vertexSize;
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        BYTE tmp[__MAX_VERTEX_SIZE];
        BYTE *pStart = startVertex;
        if (startVertex != p1)
        {
            pStart -= vertexSize;
            memcpy(tmp, pStart, vertexSize);
            memcpy(pStart, p1, vertexSize);
        }
        // Mark this call as gen by clipper
        pv->dwFlags |= D3DPV_CLIPPERPRIM | D3DPV_NONCLIPPED; 
        ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
        pv->dwFlags &= ~(D3DPV_CLIPPERPRIM | D3DPV_NONCLIPPED);
        if (ret)
            return ret;

        if (startVertex != p1)
            memcpy(pStart, tmp, vertexSize);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//------------------------------------------------------------------------------
HRESULT ProcessClippedIndexedTriangleFan(D3DFE_PROCESSVERTICES *pv)
{
    WORD        *p1;
    DWORD        f1;
    DWORD clipMaskOffScreen;                                
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    int         interpolate;                                
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
    LPWORD       startVertex;                               
    LPWORD index = pv->lpwIndices;                               \
    int         vertexCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    interpolate = SetInterpolationFlags(pv);            
    vertex = (BYTE*)pv->lpvOut;                      
    startVertex = pv->lpwIndices;                 
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)               
    {                                                       
        clipMaskOffScreen = ~__D3DCLIP_INGUARDBAND;         
    }                                                       
    else                                                    
    {                                                       
        clipMaskOffScreen = 0xFFFFFFFF;                     
    }

    f1 = clipCode[index[0]];
    p1 = index;
    index++;
    BYTE *ver = vertex + p1[0]*vertexSize;
    // In the clipper color from the first vertex is propagated to all
    // vertices for FLAT shade mode. In triangle fans the second vertex defines
    // the color in FLAT shade mode. So we will make the vertex order: 1, 2, 0
    MAKE_CLIP_VERTEX_FVF(pv, cv[2], ver, f1, vertexTransformed, clipMaskOffScreen);
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        DWORD f2, f3;     // vertex clip flags
        WORD  v1, v2;
        v1 = index[0];
        v2 = index[1];
        f2 = clipCode[v1];
        f3 = clipCode[v2];
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & clipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                WORD tmp;
                WORD *pStart = startVertex;
                if (startVertex != p1)
                {
                    pStart--;
                    tmp = *pStart;  // Save old value to restore later
                    *pStart = *p1;
                }
                ret = DRAW_INDEX_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, 
                                  vertexCount);
                if (ret)
                    return ret;
                if (startVertex != p1)
                    *pStart = tmp;   // Restore old value
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            vertexCount = 0;
            startVertex = &index[1];

            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p2 = vertex + v1*vertexSize;
                BYTE *p3 = vertex + v2*vertexSize;

                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p2, f2, vertexTransformed, clipMaskOffScreen);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p3, f3, vertexTransformed, clipMaskOffScreen);

                ret = Clip(pv, interpolate, cv);
                if (ret) return ret;
            }
        } 
        else 
            vertexCount++;
        index++;
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        WORD tmp;
        WORD *pStart = startVertex;
        if (startVertex != p1)
        {
            pStart--;
            tmp = *pStart;  // Save old value to restore later
            *pStart = *p1;
        }
        ret = DRAW_INDEX_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
        if (ret)
            return ret;
        if (startVertex != p1)
            *pStart = tmp;   // Restore old value
        if (ret)
            return ret;
    }
    return D3D_OK;
} 

#define __PROCESS_LINE_NAME ProcessClippedLine
#define __PROCESS_TRI_LIST_NAME ProcessClippedTriangleList
#define __PROCESS_TRI_STRIP_NAME ProcessClippedTriangleStrip
#include "clipprim.h"

#define __INDEX_PRIM
#define __PROCESS_TRI_LIST_NAME ProcessClippedIndexedTriangleList
#define __PROCESS_TRI_STRIP_NAME ProcessClippedIndexedTriangleStrip
#define __PROCESS_LINE_NAME ProcessClippedIndexedLine
#include "clipprim.h"

//---------------------------------------------------------------------
HRESULT ProcessClippedPoints(D3DFE_PROCESSVERTICES *pv)
{
    DWORD           i;
    WORD            count;
    BYTE           *lpStartVertex;
    BYTE           *lpCurVertex;
    HRESULT         ret;
    D3DFE_CLIPCODE *clipCode;
    const DWORD     nVertices = pv->dwNumVertices;

    clipCode = pv->lpClipFlags;                      
    count = 0;
    lpStartVertex = lpCurVertex = (BYTE*)pv->lpvOut;
    DWORD dwVertexBaseOrg = pv->dwVertexBase;
    for (i=0; i < nVertices; i++) 
    {
        if (clipCode[i]) 
        {       // if this point is clipped
            pv->dwVertexBase = dwVertexBaseOrg + i - count;
            if (count) 
            {    // first draw the ones that didn't need clipping
                ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            count = 0;
            lpCurVertex += pv->dwOutputSize;
            lpStartVertex = lpCurVertex;
        } 
        else 
        {
            count++;
            lpCurVertex += pv->dwOutputSize;
        }
    }
    // draw final batch, if any
    if (count) 
    {
        pv->dwVertexBase = dwVertexBaseOrg + nVertices - count;
        ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
        if (ret)
            return ret;
    }
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\pch.cpp ===
#include "ddrawpr.h"
#include <windows.h>
#include <assert.h>
#include <math.h>
#include "d3dpr.hpp"
#include "haldrv.hpp"
#include "fltval.h"
#include "d3dfei.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\sources.inc ===
MAJORCOMP=d3dim
MINORCOMP=pipeln
TARGETNAME=pipeln
TARGETPATH=obj
TARGETTYPE=LIBRARY

USE_MSVCRT=1

INCLUDES=..;$(_OBJ_DIR)\$(TARGET_DIRECTORY);$(D3DDX6)\pipeln\inc;$(INCLUDES)

C_DEFINES = $(C_DEFINES)

ASM_DEFINES = -DNT=1 -DMICROSOFT_NT -DSTACK_CALL  -DD3D -DOTHER_SEG=0 -DWANT_DLL

NTTARGETFILE0= \
             $O\pvvid.cpp \

SOURCES= \
    ..\clipper.cpp   \
    ..\dpclip.cpp   \
    ..\haltrans.cpp  \
    ..\helxfrm.cpp   \
    ..\rgblt.cpp     \
    $O\pvvid.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#

OFFSETS = $(_OBJ_DIR)\$(TARGET_DIRECTORY)\offsets.asm

GENSYMFLAGS = -DWIN32 -D_WIN32 -DD3D -Zp -D__DD_OPT_SURFACE $(GENSYMFLAGS) -DIS_32
GENSYMBASE = $(_OBJ_DIR)\$(TARGET_DIRECTORY)\gensym
GENSYMEXE = $(GENSYMBASE).exe
GENSYMSOURCE = ..\gensym.cpp
GENSYMINCS =

!if $(AXP64)
GENSYMFLAGS = /Ap64 $(GENSYMFLAGS)
!endif

INCPATHS = \
        -I$(BASEDIR)\public\sdk\inc\
        -I$(BASEDIR)\public\sdk\inc\crt\
        -I$(BASEDIR)\public\oak\inc\
        -I$(INCLUDES:;= -I)


$(GENTGT)\pvvid.cpp: ..\pvvid.mcp $(RAST_STD_M4)

$(OFFSETS): $(GENSYMSOURCE) $(GENSYMINCS)
    set PASS0ONLY=
   $(TARGET_CPP) -c $(INCPATHS) $(GENSYMFLAGS) -Fo$(GENSYMBASE).obj $(GENSYMSOURCE)
    -link -out:$(GENSYMEXE) @<<
-machine:$(TARGET_DIRECTORY)
-base:@$(BASEDIR)\PUBLIC\SDK\LIB\coffbase.txt,usermode
-subsystem:console
-entry:mainCRTStartup
-ignore:4078,2001
-force:unresolved
-nodefaultlib
$(GENSYMBASE).obj
$(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\msvcrt.lib
$(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\kernel32.lib
$(PERFLIBS)
<<
    -$(GENSYMEXE) > $(OFFSETS)
#    -erase $(GENSYMBASE).obj
#    -erase $(GENSYMEXE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\haltrans.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   haltrans.cpp
 *  Content:    Direct3D HAL transform handler
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//---------------------------------------------------------------------
// Update pre-computed constants related to viewport
//
// This functions should be called every time the viewport parameters are
// changed
//
// Notes:
//      1. scaleY and offsetY are computed to flip Y axes from up to down.
//      2. Mclip matrix is computed multiplied by Mshift matrix
//
const D3DVALUE SMALL_NUMBER = 0.000001f;

void UpdateViewportCache(LPDIRECT3DDEVICEI device, D3DVIEWPORT2 *data)
{
    // Bail if we are going to cause any divide by zero exceptions.
    // The likely reason is that we have a bogus viewport set by
    // TLVertex execute buffer app.
    if(data->dwWidth == 0 ||
        data->dwHeight == 0 ||
        FLOAT_EQZ(data->dvClipWidth) ||
        FLOAT_EQZ(data->dvClipHeight) ||
        data->dvMaxZ - data->dvMinZ == D3DVAL(0.f))
        return;
    D3DFE_VIEWPORTCACHE *cache = &device->vcache;
    cache->dvX = D3DVAL(data->dwX);
    cache->dvY = D3DVAL(data->dwY);
    cache->dvWidth = D3DVAL(data->dwWidth);
    cache->dvHeight = D3DVAL(data->dwHeight);
    cache->mclip11 = D3DVAL(1.0) / data->dvClipWidth;
    cache->mclip41 = - cache->mclip11 * data->dvClipX;
    cache->mclip22 = D3DVAL(1) / data->dvClipHeight;
    cache->mclip42 = D3DVAL(1) - cache->mclip22 * data->dvClipY;
    cache->mclip33 = D3DVAL(1) / (data->dvMaxZ - data->dvMinZ);
    cache->mclip43 = - data->dvMinZ * cache->mclip33;
    cache->scaleX  = cache->dvWidth;
    cache->scaleY  = - cache->dvHeight;
    cache->offsetX = cache->dvX;
    cache->offsetY = cache->dvY + cache->dvHeight;
    // Small offset is added to prevent generation of negative screen
    // coordinates (this could happen because of precision errors).
    // Not needed (or wanted) for devices which do guardband.
    if (IS_HW_DEVICE(device))
    {
        cache->offsetX += SMALL_NUMBER;
        cache->offsetY += SMALL_NUMBER;
    }
    device->dwFEFlags |= D3DFE_VIEWPORT_DIRTY | D3DFE_INVERSEMCLIP_DIRTY;
    cache->scaleXi = D3DVAL(1) / cache->scaleX;
    cache->scaleYi = D3DVAL(1) / cache->scaleY;
    cache->minX = cache->dvX;
    cache->maxX = cache->dvX + cache->dvWidth;
    cache->minY = cache->dvY;
    cache->maxY = cache->dvY + cache->dvHeight;
    cache->minXi = FTOI(cache->minX);
    cache->maxXi = FTOI(cache->maxX);
    cache->minYi = FTOI(cache->minY);
    cache->maxYi = FTOI(cache->maxY);
    if (device->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        LPD3DHAL_D3DEXTENDEDCAPS lpCaps = device->lpD3DExtendedCaps;

        // Because we clip by guard band window we have to use its extents
        cache->minXgb = lpCaps->dvGuardBandLeft;
        cache->maxXgb = lpCaps->dvGuardBandRight;
        cache->minYgb = lpCaps->dvGuardBandTop;
        cache->maxYgb = lpCaps->dvGuardBandBottom;

        D3DVALUE w = 2.0f / cache->dvWidth;
        D3DVALUE h = 2.0f / cache->dvHeight;
        D3DVALUE ax1 = -lpCaps->dvGuardBandLeft   * w + 1.0f;
        D3DVALUE ax2 =  lpCaps->dvGuardBandRight  * w - 1.0f;
        D3DVALUE ay1 =  lpCaps->dvGuardBandBottom * h - 1.0f;
        D3DVALUE ay2 = -lpCaps->dvGuardBandTop * h + 1.0f;
        cache->gb11 = 2.0f / (ax1 + ax2);
        cache->gb41 = cache->gb11 * (ax1 - 1.0f) * 0.5f;
        cache->gb22 = 2.0f / (ay1 + ay2);
        cache->gb42 = cache->gb22 * (ay1 - 1.0f) * 0.5f;

        cache->Kgbx1 = 0.5f * (1.0f - ax1);
        cache->Kgbx2 = 0.5f * (1.0f + ax2);
        cache->Kgby1 = 0.5f * (1.0f - ay1);
        cache->Kgby2 = 0.5f * (1.0f + ay2);
    }
    else
    {
        cache->minXgb = cache->minX;
        cache->maxXgb = cache->maxX;
        cache->minYgb = cache->minY;
        cache->maxYgb = cache->maxY;
    }
}
//---------------------------------------------------------------------
HRESULT
D3DHAL_MatrixCreate(LPDIRECT3DDEVICEI lpDevI, LPD3DMATRIXHANDLE lphMat)
{
    LPD3DMATRIXI lpMat;
    HRESULT ret;

    if ((ret = D3DMalloc((void**)&lpMat, sizeof(D3DMATRIXI))) != DD_OK)
    {
        return ret;
    }

    setIdentity(lpMat);

    LIST_INSERT_ROOT(&lpDevI->transform.matrices, lpMat, link);
    *lphMat = (DWORD)((ULONG_PTR)lpMat);

    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT
D3DHAL_MatrixDestroy(LPDIRECT3DDEVICEI lpDevI, D3DMATRIXHANDLE hMat)
{
    LPD3DMATRIXI lpMat = (LPD3DMATRIXI)ULongToPtr(hMat);
    LIST_DELETE(lpMat, link);
    D3DFree(lpMat);

    return D3D_OK;
}
//---------------------------------------------------------------------
HRESULT
D3DHAL_MatrixSetData(LPDIRECT3DDEVICEI lpDevI, D3DMATRIXHANDLE hMat,
                     LPD3DMATRIX lpMat)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;

    LPD3DMATRIXI lpDstMat;

    lpDstMat = HANDLE_TO_MAT(lpDevI, hMat);

    if (!lpDstMat)
    {
        return D3DERR_MATRIX_SETDATA_FAILED;
    }

    *(D3DMATRIX*)lpDstMat = *lpMat;

    if (hMat == TRANSFORM.hWorld)
        D3DFE_SetMatrixWorld(lpDevI, lpMat);
    else
        if (hMat == TRANSFORM.hView)
            D3DFE_SetMatrixView(lpDevI, lpMat);
        else
            if (hMat == TRANSFORM.hProj)
                D3DFE_SetMatrixProj(lpDevI, lpMat);

    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT
D3DHAL_MatrixGetData(LPDIRECT3DDEVICEI lpDevI, D3DMATRIXHANDLE hMat,
                     LPD3DMATRIX lpMat)
{
    LPD3DMATRIXI lpSrcMat = HANDLE_TO_MAT(lpDevI, hMat);

    if (!lpSrcMat)
        return D3DERR_MATRIX_GETDATA_FAILED;

    *lpMat = *(D3DMATRIX*)lpSrcMat;
    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\rgblt.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   rgblt.cpp
 *  Content:    Direct3D lighting
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "light.h"
#include "drawprim.hpp"

extern "C"
{
void Directional2(LPD3DFE_PROCESSVERTICES pv,
                  D3DI_LIGHT *light,
                  D3DLIGHTINGELEMENT *in);
void PointSpot2(LPD3DFE_PROCESSVERTICES pv,
                  D3DI_LIGHT *light,
                  D3DLIGHTINGELEMENT *in);
void Directional1C(LPD3DFE_PROCESSVERTICES pv,
                  D3DI_LIGHT *light,
                  D3DLIGHTINGELEMENT *in);
void PointSpot1C(LPD3DFE_PROCESSVERTICES pv,
                  D3DI_LIGHT *light,
                  D3DLIGHTINGELEMENT *in);
void PointSpotXCRamp(LPD3DFE_PROCESSVERTICES pv,
                 D3DI_LIGHT *light,
                 D3DLIGHTINGELEMENT *in);

//#define _USE_ASM_
#ifdef _X86_
#ifdef _USE_ASM_

void Directional2P5S(LPD3DFE_PROCESSVERTICES pv,
                     D3DI_LIGHT *light,
                     D3DLIGHTINGELEMENT *in);
void Directional2P5(LPD3DFE_PROCESSVERTICES pv,
                    D3DI_LIGHT *light,
                    D3DLIGHTINGELEMENT *in);

#endif _X86_
#endif _USE_ASM_
}

static LIGHT_VERTEX_FUNC_TABLE lightVertexTable =
{
    Directional1C,
    Directional2,
    PointSpot1C,
    PointSpot2,
    PointSpot1C,
    PointSpot2
};

HRESULT D3DFE_InitRGBLighting(LPDIRECT3DDEVICEI lpDevI)
{
    LIST_INITIALIZE(&lpDevI->specular_tables);
    lpDevI->specular_table = NULL;

    LIST_INITIALIZE(&lpDevI->materials);

    STATESET_INIT(lpDevI->lightstate_overrides);
    lpDevI->lightVertexFuncTable = &lightVertexTable;

    lpDevI->lighting.activeLights = NULL;

    return (D3D_OK);
}

void D3DFE_DestroyRGBLighting(LPDIRECT3DDEVICEI lpDevI)
{
    SpecularTable *spec;
    SpecularTable *spec_next;

    for (spec = LIST_FIRST(&lpDevI->specular_tables); spec; spec = spec_next)
    {
        spec_next = LIST_NEXT(spec,list);
        D3DFree(spec);
    }

    while (LIST_FIRST(&lpDevI->materials))
    {
        LPD3DFE_MATERIAL lpMat;
        lpMat = LIST_FIRST(&lpDevI->materials);
        LIST_DELETE(lpMat, link);
        D3DFree(lpMat);
    }
}

HRESULT D3DHEL_ApplyFog(D3DFE_LIGHTING* driver, int count, D3DLIGHTDATA* data)
{
    D3DTLVERTEX *v;
    size_t v_size;
    D3DVALUE fog_start = driver->fog_start;
    D3DVALUE fog_end = driver->fog_end;
    D3DVALUE fog_length = RLDDIFInvert16(fog_end - fog_start);
    int i;

    v = (D3DTLVERTEX*)data->lpOut;
    v_size = data->dwOutSize;

    for (i = count; i; i--)
    {
        D3DVALUE w;
        int f;
        if ((v->rhw < D3DVAL(1)) &&  (v->rhw > 0))
            w = RLDDIFInvert24(v->rhw);
        else
            w = v->rhw;
        if (w < fog_start)
            f = 255;
        else if (w >= fog_end)
            f = 0;
        else
            f = VALTOFXP(DECPREC(RLDDIFMul16(fog_end - w, fog_length), 8), 8);
        if (f > 255) f = 255;
        if (f < 0) f = 0;
        v->specular = RGBA_SETALPHA(v->specular, f);
        v = (D3DTLVERTEX*)((char*)v + v_size);
    }
    return D3D_OK;
}

static void inverseRotateVector(D3DVECTOR* d,
                                D3DVECTOR* v, D3DMATRIXI* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    d->x = RLDDIFMul16(vx, M->_11) + RLDDIFMul16(vy, M->_12) + RLDDIFMul16(vz, M->_13);
    d->y = RLDDIFMul16(vx, M->_21) + RLDDIFMul16(vy, M->_22) + RLDDIFMul16(vz, M->_23);
    d->z = RLDDIFMul16(vx, M->_31) + RLDDIFMul16(vy, M->_32) + RLDDIFMul16(vz, M->_33);
}

static void inverseTransformVector(D3DVECTOR* d,
                                   D3DVECTOR* v, D3DMATRIXI* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    vx -= M->_41; vy -= M->_42; vz -= M->_43;
    d->x = RLDDIFMul16(vx, M->_11) + RLDDIFMul16(vy, M->_12) + RLDDIFMul16(vz, M->_13);
    d->y = RLDDIFMul16(vx, M->_21) + RLDDIFMul16(vy, M->_22) + RLDDIFMul16(vz, M->_23);
    d->z = RLDDIFMul16(vx, M->_31) + RLDDIFMul16(vy, M->_32) + RLDDIFMul16(vz, M->_33);
}

/*
 * Every time the world matrix is modified the lighting vectors have to
 * change to match the model space of the new data to be rendered
 */

#define SMALLISH    (1e-2)
#define ONEISH(v)   (fabs(v - 1.0f) < SMALLISH)

static int getMatrixScale(D3DMATRIXI* m, D3DVECTOR* s)
{
    s->x = (m->_11 * m->_11 + m->_12 * m->_12 + m->_13 * m->_13);
    s->y = (m->_21 * m->_21 + m->_22 * m->_22 + m->_23 * m->_23);
    s->z = (m->_31 * m->_31 + m->_32 * m->_32 + m->_33 * m->_33);

    if (ONEISH(s->x) && ONEISH(s->y) && ONEISH(s->z))
        return FALSE;
    else
    {
        s->x = (D3DVALUE)(1.0f / s->x);
        s->y = (D3DVALUE)(1.0f / s->y);
        s->z = (D3DVALUE)(1.0f / s->z);
        return TRUE;
    }
}

static int
getMatrixScale2(D3DMATRIXI *m, D3DVECTOR *s)
{
    float det;

    s->x = (float)sqrt(m->_11*m->_11 + m->_12*m->_12 + m->_13*m->_13);
    s->y = (float)sqrt(m->_21*m->_21 + m->_22*m->_22 + m->_23*m->_23);
    s->z = (float)sqrt(m->_31*m->_31 + m->_32*m->_32 + m->_33*m->_33);

    if (ONEISH(s->x) && ONEISH(s->y) && ONEISH(s->z))
    {
        return FALSE;
    }
    else
    {
        det = m->_11*(m->_22*m->_33 - m->_23*m->_32)
            - m->_12*(m->_21*m->_33 - m->_23*m->_31)
            + m->_13*(m->_21*m->_32 - m->_22*m->_31);

        if (det<0.0)
        {
            s->x = (-s->x);
            s->y = (-s->y);
            s->z = (-s->z);
        }

        // prevent 0 scales from sneaking through
        if (fabs(s->x) < 0.0001)
            s->x = 0.0001f;
        if (fabs(s->y) < 0.0001)
            s->y = 0.0001f;
        if (fabs(s->z) < 0.0001)
            s->z = 0.0001f;

        return TRUE;
    }
}   // end of getMatrixScale2()

//-----------------------------------------------------------------------
// Every time the world matrix is modified or lights data is changed the
// lighting vectors have to change to match the model space of the new data
// to be rendered.
// Every time light data is changed or material data is changed or lighting
// state is changed, some pre-computed lighting values sould be updated
//
void D3DFE_UpdateLights(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_LIGHTING& LIGHTING = lpDevI->lighting;
    D3DI_LIGHT  *light = LIGHTING.activeLights;
    D3DVECTOR   t;
    D3DMATRIXI  *world;
    D3DMATRIXI  *camera;
    D3DMATERIAL *mat;
    D3DVECTOR   cameraModel;
    D3DVECTOR   cameraWorld;
    D3DVECTOR   cameraModelNorm;        // Normalized
    D3DVECTOR   scale1;
    D3DVECTOR   scale2;
    D3DVECTOR   oneOverScale;
    BOOL        cameraModelNormComputed = FALSE;
    BOOL        scale1Computed = FALSE; // For light 1
    BOOL        scale2Computed = FALSE; // For light 2
    BOOL        need_scale1;
    BOOL        need_scale2;
    BOOL        specular;       // TRUE, if specular component sould be computed


    if (lpDevI->dwFEFlags & D3DFE_NEED_TRANSFORM_LIGHTS)
    {
        D3DVECTOR t;

        world  = &lpDevI->transform.world;
        camera = &lpDevI->transform.view;
        t.x = -camera->_41;
        t.y = -camera->_42;
        t.z = -camera->_43;

        // transform the eye into world coords.
        inverseRotateVector(&cameraWorld, &t, camera);

        // now transform eye into model space
        inverseTransformVector(&cameraModel, &cameraWorld, world);
    }

    if (lpDevI->dwFEFlags & (D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY))
    {
        mat = &LIGHTING.material;
        if (lpDevI->specular_table &&
            lpDevI->rstates[D3DRENDERSTATE_SPECULARENABLE])
        {
            specular = TRUE;
            lpDevI->dwFEFlags |= D3DFE_COMPUTESPECULAR;
        }
        else
        {
            specular = FALSE;
            lpDevI->dwFEFlags &= ~D3DFE_COMPUTESPECULAR;
        }

        LIGHTING.materialAlpha = FTOI(D3DVAL(255) * mat->diffuse.a);
        if (LIGHTING.materialAlpha < 0)
            LIGHTING.materialAlpha = 0;
        else
            if (LIGHTING.materialAlpha > 255)
                LIGHTING.materialAlpha = 255 << 24;
            else LIGHTING.materialAlpha <<= 24;

        LIGHTING.currentSpecTable = lpDevI->specular_table->table;

        if (!(lpDevI->dwDeviceFlags & D3DDEV_RAMP))
        {
            LIGHTING.diffuse0.r = LIGHTING.ambient_red   * mat->ambient.r +
                mat->emissive.r * D3DVAL(255);
            LIGHTING.diffuse0.g = LIGHTING.ambient_green * mat->ambient.g +
                mat->emissive.g * D3DVAL(255);
            LIGHTING.diffuse0.b = LIGHTING.ambient_blue  * mat->ambient.b +
                mat->emissive.b * D3DVAL(255);
        }
    }

    while (light)
    {
        if (lpDevI->dwFEFlags & D3DFE_NEED_TRANSFORM_LIGHTS)
        {
            if (light->type != D3DLIGHT_DIRECTIONAL)
            {
                // Transform light position to the model space
                t.x = light->position.x - world->_41;
                t.y = light->position.y - world->_42;
                t.z = light->position.z - world->_43;
                inverseRotateVector(&light->model_position, &t, world);
            }

            if (light->version == 1)
            {
                if (!scale1Computed)
                {
                    need_scale1 = getMatrixScale(world, &scale1);
                    scale1Computed = TRUE;
                }
                if (!need_scale1)
                    light->flags |= D3DLIGHTI_UNIT_SCALE;
                else
                {
                    if (light->type != D3DLIGHT_DIRECTIONAL)
                    {
                        light->model_position.x *= scale1.x;
                        light->model_position.y *= scale1.y;
                        light->model_position.z *= scale1.z;
                    }
                }
            }
            else
            {
                if (!scale2Computed)
                {
                    need_scale2 = getMatrixScale2(world, &scale2);
                    scale2Computed = TRUE;
                }
                if (!need_scale2)
                    light->flags |= D3DLIGHTI_UNIT_SCALE;
                else
                {
                    light->model_scale.x = scale2.x;
                    light->model_scale.y = scale2.y;
                    light->model_scale.z = scale2.z;
                    oneOverScale.x = D3DVAL(1)/scale2.x;
                    oneOverScale.y = D3DVAL(1)/scale2.y;
                    oneOverScale.z = D3DVAL(1)/scale2.z;
                    light->flags &= ~D3DLIGHTI_UNIT_SCALE;
                }
            }

            if (light->type != D3DLIGHT_POINT)
            {
                if (light->type == D3DLIGHT_PARALLELPOINT)
                {
                    light->model_direction = light->model_position;
                }
                else
                {
                    // Transform light direction to the model space
                    inverseRotateVector(&light->model_direction,
                                        &light->direction, world);
                    VecNeg(light->model_direction, light->model_direction);
                }
                if (light->version != 1 && need_scale2)
                {
                    // apply scale here before normalizing
                    light->model_direction.x *= oneOverScale.x;
                    light->model_direction.y *= oneOverScale.y;
                    light->model_direction.z *= oneOverScale.z;
                }
                if (need_scale1 || need_scale2 ||
                    light->type == D3DLIGHT_PARALLELPOINT)
                    VecNormalizeFast(light->model_direction);
            }

            if (light->version == 1)
            {
                if (!cameraModelNormComputed)
                {
                    VecNormalizeFast2(cameraModel, cameraModelNorm);
                    cameraModelNormComputed = TRUE;
                }

                if (light->type == D3DLIGHT_DIRECTIONAL)
                {
                    t = light->model_direction;
                }
                else
                {
                    t = light->model_position;
                }
                // calc halfway vector
                VecNormalizeFast(t);
                VecAdd(t, cameraModelNorm, light->halfway);
                VecNormalizeFast(light->halfway);
            }
            else
            {
                // We want to compare cameraWorld position with the light to
                // see if they match
                if (fabs(light->position.x-cameraWorld.x) < 0.0001 &&
                    fabs(light->position.y-cameraWorld.y) < 0.0001 &&
                    fabs(light->position.z-cameraWorld.z) < 0.0001)
                {
                    light->flags |= D3DLIGHTI_LIGHT_AT_EYE;
                }
                else
                {
                    light->flags &= ~D3DLIGHTI_LIGHT_AT_EYE;
                }

                // store location of eye in model space
                if (light->flags & D3DLIGHTI_UNIT_SCALE)
                {
                    light->model_eye = cameraModel;
                }
                else
                {
                    light->model_eye.x = cameraModel.x * oneOverScale.x;
                    light->model_eye.y = cameraModel.y * oneOverScale.y;
                    light->model_eye.z = cameraModel.z * oneOverScale.z;
                    if (light->type == D3DLIGHT_POINT ||
                        light->type == D3DLIGHT_SPOT)
                    {
                        light->model_position.x *= oneOverScale.x;
                        light->model_position.y *= oneOverScale.y;
                        light->model_position.z *= oneOverScale.z;
                    }
                }
            }
        }

        if (lpDevI->dwFEFlags & (D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY))
        {
            if (!(lpDevI->dwDeviceFlags & D3DDEV_RAMP))
            {
                light->local_diffR = D3DVAL(255) * mat->diffuse.r * light->red;
                light->local_diffG = D3DVAL(255) * mat->diffuse.g * light->green;
                light->local_diffB = D3DVAL(255) * mat->diffuse.b * light->blue;

                light->local_specR = D3DVAL(255) * mat->specular.r * light->red;
                light->local_specG = D3DVAL(255) * mat->specular.g * light->green;
                light->local_specB = D3DVAL(255) * mat->specular.b * light->blue;
            }
            else
            {
                light->local_diffR = light->shade;
                light->local_specR = light->shade;
            }

            if (specular && !(light->flags & D3DLIGHT_NO_SPECULAR))
                light->flags |= D3DLIGHTI_COMPUTE_SPECULAR;
            else
                light->flags &= ~D3DLIGHTI_COMPUTE_SPECULAR;
        }

        if (lpDevI->dwFEFlags & D3DFE_LIGHTS_DIRTY)
        {
            light->lightVertexFunc = NULL;
            if (light->version == 1)
            {
                switch (light->type)
                {
                case D3DLIGHT_PARALLELPOINT:
                case D3DLIGHT_DIRECTIONAL:
                    light->lightVertexFunc =
                        lpDevI->lightVertexFuncTable->directional1;
                    break;
                case D3DLIGHT_POINT:
                    if (lpDevI->dwDeviceFlags & D3DDEV_RAMP)
                    {
                        light->lightVertexFunc = PointSpotXCRamp;
                    }
                    else
                    {
                        light->lightVertexFunc =
                            lpDevI->lightVertexFuncTable->point1;
                    }
                    break;
                case D3DLIGHT_SPOT:
                    if (lpDevI->dwDeviceFlags & D3DDEV_RAMP)
                    {
                        light->lightVertexFunc = PointSpotXCRamp;
                    }
                    else
                    {
                        light->lightVertexFunc =
                            lpDevI->lightVertexFuncTable->spot1;
                    }
                    break;
                }
            }
            else
            {
                switch (light->type)
                {
                case D3DLIGHT_PARALLELPOINT:
                case D3DLIGHT_DIRECTIONAL:
                {
#ifdef _X86_
#ifdef _USE_ASM_
                    if (light->flags & D3DLIGHTI_UNIT_SCALE &&
                        !(lpDevI->dwDeviceFlags & D3DDEV_RAMP) &&
                        !(lpDevI->dwFEFlags & D3DFE_COLORVERTEX))
                    {
                        if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)
                            light->lightVertexFunc = Directional2P5S;
                        else
                            light->lightVertexFunc = Directional2P5;
                    }
                    else
#endif _USE_ASM_
#endif // _X86_
                        light->lightVertexFunc =
                            lpDevI->lightVertexFuncTable->directional2;
                    break;
                }
                case D3DLIGHT_POINT:
                    if (lpDevI->dwDeviceFlags & D3DDEV_RAMP)
                    {
                        light->lightVertexFunc = PointSpotXCRamp;
                    }
                    else
                    {
                        light->lightVertexFunc =
                            lpDevI->lightVertexFuncTable->point2;
                    }
                    break;
                case D3DLIGHT_SPOT:
                    if (lpDevI->dwDeviceFlags & D3DDEV_RAMP)
                    {
                        light->lightVertexFunc = PointSpotXCRamp;
                    }
                    else
                    {
                        light->lightVertexFunc =
                            lpDevI->lightVertexFuncTable->spot2;
                    }
                    break;
                }
            }
        }

        light = light->next;
    }

    lpDevI->dwFEFlags &= ~(D3DFE_MATERIAL_DIRTY |
                    D3DFE_NEED_TRANSFORM_LIGHTS |
                    D3DFE_LIGHTS_DIRTY);
}   // end of updateLights()
//---------------------------------------------------------------------
inline D3DVALUE COMPUTE_DOT_POW(D3DFE_LIGHTING *ldrv, D3DVALUE dot)
{
    ldrv->specularComputed = TRUE;
    if (dot < 1.0f)
    {
        int     indx;
        float   v;
        dot *= 255.0f;
        indx = (int)dot;
        dot -= indx;
        v = ldrv->currentSpecTable[indx];
        return v + (ldrv->currentSpecTable[indx+1] - v)*dot;
    }
    else
        return 1.0f;
}
//---------------------------------------------------------------------
inline void COMPUTE_SPECULAR(LPD3DFE_PROCESSVERTICES pv,
                             D3DVALUE dot,
                             D3DI_LIGHT *light)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    if (FLOAT_CMP_POS(dot, >=, ldrv.specThreshold))
    {
        D3DVALUE power;
        power = COMPUTE_DOT_POW(&ldrv, dot);
        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            ldrv.specular.r += light->shade * power;
        }
        else
        if (!(pv->dwFlags & D3DPV_COLORVERTEXS))
        {
            ldrv.specular.r += light->local_specR * power;
            ldrv.specular.g += light->local_specG * power;
            ldrv.specular.b += light->local_specB * power;
        }
        else
        {
            ldrv.specular.r += light->red   * ldrv.vertexSpecular.r * power;
            ldrv.specular.g += light->green * ldrv.vertexSpecular.g * power;
            ldrv.specular.b += light->blue  * ldrv.vertexSpecular.b * power;
        }
    }
}
//---------------------------------------------------------------------
inline void COMPUTE_SPECULAR_ATT(LPD3DFE_PROCESSVERTICES pv,
                                 D3DVALUE dot,
                                 D3DI_LIGHT *light,
                                 D3DVALUE att)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    if (FLOAT_CMP_POS(dot, >=, ldrv.specThreshold))
    {
        D3DVALUE power;
        power = COMPUTE_DOT_POW(&ldrv, dot);
        power *= att;
        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            ldrv.specular.r += light->shade * power;
        }
        else
        if (!(pv->dwFlags & D3DPV_COLORVERTEXS))
        {
            ldrv.specular.r += light->local_specR * power;
            ldrv.specular.g += light->local_specG * power;
            ldrv.specular.b += light->local_specB * power;
        }
        else
        {
            ldrv.specular.r += light->red   * ldrv.vertexSpecular.r * power;
            ldrv.specular.g += light->green * ldrv.vertexSpecular.g * power;
            ldrv.specular.b += light->blue  * ldrv.vertexSpecular.b * power;
        }
    }
}
//-------------------------------------------------------------------------
void Directional2(LPD3DFE_PROCESSVERTICES pv,
                  D3DI_LIGHT *light,
                  D3DLIGHTINGELEMENT *in)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    D3DVALUE dot;
    dot = VecDot(light->model_direction, in->dvNormal);
    if (FLOAT_GTZ(dot))
    {
        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            ldrv.diffuse.r += light->shade * dot;
        }
        else
        if (!(pv->dwFlags & D3DPV_COLORVERTEX))
        {
            ldrv.diffuse.r += light->local_diffR * dot;
            ldrv.diffuse.g += light->local_diffG * dot;
            ldrv.diffuse.b += light->local_diffB * dot;
        }
        else
        {
            ldrv.diffuse.r += light->red   * ldrv.vertexDiffuse.r * dot;
            ldrv.diffuse.g += light->green * ldrv.vertexDiffuse.g * dot;
            ldrv.diffuse.b += light->blue  * ldrv.vertexDiffuse.b * dot;
        }

        if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)
        {
            D3DVECTOR h;      // halfway vector
            D3DVECTOR eye;    // incident vector ie vector from eye
            // calc incident vector
            if (light->flags & D3DLIGHTI_UNIT_SCALE)
            {
                VecSub(in->dvPosition, light->model_eye, eye);
            }
            else
            {
                // note that model_eye has already been divided by scale
                // in setup
                eye.x = in->dvPosition.x*light->model_scale.x -
                        light->model_eye.x;
                eye.y = in->dvPosition.y*light->model_scale.y -
                        light->model_eye.y;
                eye.z = in->dvPosition.z*light->model_scale.z -
                        light->model_eye.z;
            }
            // normalize
            VecNormalizeFast(eye);

            // calc halfway vector
            VecSub(light->model_direction, eye, h);

            dot = VecDot(h, in->dvNormal);

            if (FLOAT_GTZ(dot))
            {
                dot *= ISQRTF(VecLenSq(h));
                COMPUTE_SPECULAR(pv, dot, light);
            }
        }
    }
}
//-------------------------------------------------------------------------
void PointSpot2(LPD3DFE_PROCESSVERTICES pv,
                D3DI_LIGHT *light,
                D3DLIGHTINGELEMENT *in)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    D3DVALUE dot;
    D3DVALUE dist;  // Distance from light to the vertex
    D3DVALUE dist2;
    D3DVECTOR d;    // Direction to light
    D3DVALUE att;

    if (light->flags & D3DLIGHTI_UNIT_SCALE)
    {
        VecSub(light->model_position, in->dvPosition, d);
    }
    else
    {
        d.x = light->model_position.x - in->dvPosition.x * light->model_scale.x;
        d.y = light->model_position.y - in->dvPosition.y * light->model_scale.y;
        d.z = light->model_position.z - in->dvPosition.z * light->model_scale.z;
    }

    // early out if out of range or exactly on the vertex
    dist2 = d.x*d.x + d.y*d.y + d.z*d.z;
    if (FLOAT_CMP_POS(dist2, >=, light->range_squared) || FLOAT_EQZ(dist2))
        return;

    // Calc dot product of light dir with normal.  Note that since we
    // didn't normalize the direction the result is scaled by the distance.
    dot = VecDot(d, in->dvNormal);

    if (FLOAT_GTZ(dot))
    {
        // ok, so now we actually need the real dist
        dist = SQRTF(dist2);

        // calc attenuation
        att = 0.0f;
        if (light->flags & D3DLIGHTI_ATT0_IS_NONZERO)
        {
            att += light->attenuation0;
        }
        if (light->flags & (D3DLIGHTI_ATT1_IS_NONZERO | D3DLIGHTI_ATT2_IS_NONZERO))
        {
            float att1 = (light->range - dist) / light->range;

            if (light->flags & D3DLIGHTI_ATT1_IS_NONZERO)
            {
                att += light->attenuation1 * att1;
            }
            if (light->flags & D3DLIGHTI_ATT2_IS_NONZERO)
            {
                att += light->attenuation2 * att1 * att1;
            }
        }

        dist = D3DVAL(1)/dist;

        if (light->type == D3DLIGHT_SPOT)
        {
            D3DVALUE cone_dot;
            // Calc dot product of direction to light with light direction to
            // be compared anganst the cone angles to see if we are in the light.
            // Note that cone_dot is still scaled by dist
            cone_dot = VecDot(d, light->model_direction);

            cone_dot*= dist;        // Normalizing
            if (FLOAT_CMP_POS(cone_dot, <=, light->cos_phi_by_2))
                return;

            // modify att if in the region between phi and theta
            if (FLOAT_CMP_POS(cone_dot, <, light->cos_theta_by_2))
            {
                D3DVALUE val;
                val = (cone_dot - light->cos_phi_by_2) * light->inv_theta_minus_phi;
                if (!(light->flags & D3DLIGHTI_LINEAR_FALLOFF))
                {
                    val = POWF(val, light->falloff);
                }
                att *= val;
            }
        }

        dot *= dist*att;

        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            ldrv.diffuse.r += light->shade * dot;
        }
        else
        if (!(pv->dwFlags & D3DPV_COLORVERTEX))
        {
            ldrv.diffuse.r += light->local_diffR * dot;
            ldrv.diffuse.g += light->local_diffG * dot;
            ldrv.diffuse.b += light->local_diffB * dot;
        }
        else
        {
            ldrv.diffuse.r += light->red   * ldrv.vertexDiffuse.r * dot;
            ldrv.diffuse.g += light->green * ldrv.vertexDiffuse.g * dot;
            ldrv.diffuse.b += light->blue  * ldrv.vertexDiffuse.b * dot;
        }

        if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)
        {
            D3DVECTOR eye;
            D3DVECTOR h;
            // normalize light direction
            d.x *= dist;
            d.y *= dist;
            d.z *= dist;

            if (light->flags & D3DLIGHTI_LIGHT_AT_EYE)
            {
                h = d;
            }
            else
            {
                // calc incident vector
                if (light->flags & D3DLIGHTI_UNIT_SCALE)
                {
                    VecSub(in->dvPosition, light->model_eye, eye);
                }
                else
                {
                    // note that model_eye has already been divided by scale in setup
                    eye.x = in->dvPosition.x*light->model_scale.x -
                        light->model_eye.x;
                    eye.y = in->dvPosition.y*light->model_scale.y -
                        light->model_eye.y;
                    eye.z = in->dvPosition.z*light->model_scale.z -
                        light->model_eye.z;
                }
                // normalize
                VecNormalizeFast(eye);

                // calc halfway vector
                VecSub(d, eye, h);
                VecNormalizeFast(h);
            }
            dot = VecDot(h, in->dvNormal);

            COMPUTE_SPECULAR_ATT(pv, dot, light, att);
        }
    }
}       // end of Point2()
//-------------------------------------------------------------------------
void Directional1C(LPD3DFE_PROCESSVERTICES pv,
                 D3DI_LIGHT *light,
                 D3DLIGHTINGELEMENT *in)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    D3DVALUE dot;
    dot = VecDot(light->model_direction, in->dvNormal);
    if (FLOAT_GTZ(dot))
    {
        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            ldrv.diffuse.r += light->shade * dot;
        }
        else
        {
            ldrv.diffuse.r += light->local_diffR * dot;
            ldrv.diffuse.g += light->local_diffG * dot;
            ldrv.diffuse.b += light->local_diffB * dot;
        }
        if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)
        {
            dot = VecDot(light->halfway, in->dvNormal);
            COMPUTE_SPECULAR(pv, dot, light);
        }
    }
}
//-------------------------------------------------------------------------
void PointSpot1C(LPD3DFE_PROCESSVERTICES pv,
                 D3DI_LIGHT *light,
                 D3DLIGHTINGELEMENT *in)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    D3DVECTOR d;
    D3DVALUE  dot;
    VecSub(light->model_position, in->dvPosition, d);
    dot = VecDot(d, in->dvNormal);
    if (FLOAT_GTZ(dot))
    {
        D3DVALUE dist2;
        D3DVALUE dist;
        D3DVALUE att;
        D3DVALUE big = D3DVAL(1000);    // if 1/att < 0.001 do not compute color

        dist2 = VecDot(d, d);
        if (FLOAT_EQZ(dist2))
            return;
        dist = SQRTF(dist2);
        att = light->attenuation0 +
              light->attenuation1 * dist +
              light->attenuation2 * dist2;

        if (FLOAT_CMP_POS(att, >, big))
            return;

        if (FLOAT_CMP_PONE(att, >))
            att *= dist;
        else
            att = dist;
        att = D3DVAL(1) / att;
        if (light->type == D3DLIGHT_SPOT)
        {
            D3DVALUE cone_dot;
            // Calc dot product of direction to light with light direction to
            // be compared anganst the cone angles to see if we are in the light.
            // Note that cone_dot is still scaled by dist
            cone_dot = VecDot(d, light->model_direction);
            cone_dot /= dist;

            if (FLOAT_CMP_POS(cone_dot, <=, light->cos_phi_by_2))
                return;

            if (FLOAT_CMP_POS(cone_dot, <, light->cos_theta_by_2))
            {
                att *= D3DVAL(1)-(light->cos_theta_by_2-cone_dot)*light->falloff;
            }
        }

        dot *= att;

        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            ldrv.diffuse.r += light->shade * dot;
        }
        else
        {
            ldrv.diffuse.r += light->local_diffR * dot;
            ldrv.diffuse.g += light->local_diffG * dot;
            ldrv.diffuse.b += light->local_diffB * dot;
        }

        if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)
        {
            dot = VecDot(light->halfway, in->dvNormal);
            COMPUTE_SPECULAR_ATT(pv, dot, light, att);
        }
    }
}
//-------------------------------------------------------------------------
void PointSpotXCRamp(LPD3DFE_PROCESSVERTICES pv,
                 D3DI_LIGHT *light,
                 D3DLIGHTINGELEMENT *in)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    D3DVECTOR d;
    D3DVALUE  dot;
    VecSub(light->model_position, in->dvPosition, d);
    dot = VecDot(d, in->dvNormal);
    if (FLOAT_GTZ(dot))
    {
        D3DVALUE dist2;
        D3DVALUE dist;
        D3DVALUE att;
        D3DVALUE big = D3DVAL(1000);    // if 1/att < 0.001 do not compute color

        dist2 = VecDot(d, d);
        if (FLOAT_EQZ(dist2))
            return;
        dist = SQRTF(dist2);
        if (light->version == 1)
        {
            att = light->attenuation0 +
                  light->attenuation1 * dist +
                  light->attenuation2 * dist2;

            if (FLOAT_CMP_PONE(att, >))
                att *= dist;
            else
                att = dist;
            att = D3DVAL(1) / att;
        }
        else
        {
            // dist is normalized to light range
            float att1 = (light->range-dist)/light->range;
            att = light->attenuation0 +
                  light->attenuation1 * att1 +
                  light->attenuation2 * att1*att1;
        }

        if (light->type == D3DLIGHT_SPOT)
        {
            D3DVALUE cone_dot;
            // Calc dot product of direction to light with light direction to
            // be compared anganst the cone angles to see if we are in the light.
            // Note that cone_dot is still scaled by dist
            cone_dot = VecDot(d, light->model_direction);
            cone_dot /= dist;

            if (FLOAT_CMP_POS(cone_dot, <=, light->cos_phi_by_2))
                return;

            if (FLOAT_CMP_POS(cone_dot, <, light->cos_theta_by_2))
            {
                att *= D3DVAL(1)-(light->cos_theta_by_2-cone_dot)*light->falloff;
            }
        }

        dot *= att;

        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            ldrv.diffuse.r += light->shade * dot;
        }
        else
        {
            ldrv.diffuse.r += light->local_diffR * dot;
            ldrv.diffuse.g += light->local_diffG * dot;
            ldrv.diffuse.b += light->local_diffB * dot;
        }

        if (light->version == 1)
        {
            // no attenuation of specular for ramp for version == 1
            att = 1.0F;
        }
        if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)
        {
            dot = VecDot(light->halfway, in->dvNormal);
            COMPUTE_SPECULAR_ATT(pv, dot, light, att);
        }
    }
}
//-------------------------------------------------------------------------
SpecularTable* CreateSpecularTable(D3DVALUE power)
{
    SpecularTable* spec;
    int     i;
    float  delta = 1.0f/255.0f;
    float  v;

    D3DMalloc((void**)&spec, sizeof(SpecularTable));

    if (spec == NULL)
        return NULL;

    spec->power = power;

    v = 0.0f;
    for (i = 0; i < 256; i++)
    {
        spec->table[i] = powf(v, power);
        v += delta;
    }

    for (; i < 260; i++)
        spec->table[i] = 1.0f;

    return spec;
}

HRESULT SetMaterial(LPDIRECT3DDEVICEI lpDevI, D3DMATERIALHANDLE hMat)
{
    LPD3DFE_MATERIAL lpMat;
    lpMat = (LPD3DFE_MATERIAL) ULongToPtr(hMat);

    if (!lpMat)
    {
        lpDevI->lighting.hMat = NULL;
        return D3D_OK;
    }

#if DBG
// check for non-null bogus material handle
    TRY
      {
          if (IsBadReadPtr(lpMat,sizeof(D3DFE_MATERIAL)) || (lpMat->mat.dwSize!=sizeof(D3DMATERIAL))) {
              D3D_ERR( "SetLightState: Invalid Material handle" );
              return DDERR_INVALIDPARAMS;
          }
      }
      EXCEPT( EXCEPTION_EXECUTE_HANDLER )
      {
          D3D_ERR( "Exception encountered validating SetLightState material handle" );
          return DDERR_INVALIDPARAMS;
      }
#endif

    D3DFE_LIGHTING& LIGHTING = lpDevI->lighting;
    LIGHTING.material = lpMat->mat;
    LIGHTING.hMat = hMat;
    lpDevI->dwFEFlags |= D3DFE_MATERIAL_DIRTY;

    if (lpMat->mat.power > D3DVAL(0.001))
    {
        SpecularTable* spec;

        for (spec = LIST_FIRST(&lpDevI->specular_tables);
             spec;
             spec = LIST_NEXT(spec,list))
        {
            if (spec->power == lpMat->mat.power)
                break;
        }
        if (spec == NULL)
        {
            spec = CreateSpecularTable(lpMat->mat.power);
            if (spec == NULL)
                return DDERR_INVALIDPARAMS;
            LIST_INSERT_ROOT(&lpDevI->specular_tables, spec, list);
        }
        lpDevI->specular_table = spec;
        LIGHTING.specThreshold = D3DVAL(pow(0.001, 1.0/lpMat->mat.power));
    }
    else
        lpDevI->specular_table = NULL;

    return D3D_OK;
}

/*
 * Instruction emulation.
 */
HRESULT D3DHELInst_D3DOP_STATELIGHT(LPDIRECT3DDEVICEI lpDevI, DWORD dwCount,
                                    LPD3DSTATE lpLset)
{
    DWORD i;

    for (i = 0; i < dwCount; i++)
    {
        DWORD type = (DWORD) lpLset[i].dlstLightStateType;
        HRESULT hr = D3D_OK;

        D3D_INFO(9, "HEL D3DOP_STATELIGHT: state = %d", type);
        if (IS_OVERRIDE(type))
        {
            DWORD override = GET_OVERRIDE(type);
            if (lpLset[i].dwArg[0])
            {
                D3D_INFO(9, "HEL D3DOP_STATELIGHT: setting override for state %d",
                    override);
                STATESET_SET(lpDevI->lightstate_overrides, override);
            }
            else
            {
                D3D_INFO(9, "HEL D3DOP_STATELIGHT: clearing override for state %d",
                    override);
                STATESET_CLEAR(lpDevI->lightstate_overrides, override);
            }
            continue;
        }

        if (STATESET_ISSET(lpDevI->lightstate_overrides, type))
        {
            D3D_INFO(9, "HEL D3DOP_STATELIGHT: state %d is overridden, ignoring",
                type);
            continue;
        }

        D3DFE_LIGHTING& LIGHTING = lpDevI->lighting;
        switch (type)
        {
        case D3DLIGHTSTATE_MATERIAL:
        {
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_MATERIAL found");
            D3DMATERIALHANDLE hMat = (D3DMATERIALHANDLE)lpLset[i].dwArg[0];
            if (hMat != lpDevI->lighting.hMat)
            {
                hr = SetMaterial(lpDevI, hMat);
                if (hr != D3D_OK)
                    return hr;
                // Update ramp rasterizer if necessary
                if(lpDevI->pfnRampService != NULL)
                {
                    hr = CallRampService(lpDevI, RAMP_SERVICE_SETLIGHTSTATE,
                                        (DWORD)type, &(lpLset[i].dvArg[0]), TRUE);
                    if (hr != D3D_OK)
                        return hr;
                }
            }
            continue;
        }
        case D3DLIGHTSTATE_AMBIENT:
        {
            DWORD color = lpLset[i].dwArg[0];
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_AMBIENT found");

            LIGHTING.ambient_red   = D3DVAL(RGBA_GETRED(color));
            LIGHTING.ambient_green = D3DVAL(RGBA_GETGREEN(color));
            LIGHTING.ambient_blue  = D3DVAL(RGBA_GETBLUE(color));
            LIGHTING.ambient_save  = lpLset[i].dwArg[0];
            lpDevI->dwFEFlags |= D3DFE_MATERIAL_DIRTY;
            break;
        }
        case D3DLIGHTSTATE_FOGMODE:
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_FOG_MODE found");
            LIGHTING.fog_mode = (D3DFOGMODE)lpLset[i].dwArg[0];
            SetFogFlags(lpDevI);
            break;
        case D3DLIGHTSTATE_FOGSTART:
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_FOG_START found");
            LIGHTING.fog_start = lpLset[i].dvArg[0];
            if (lpDevI->dwFEFlags & D3DFE_FOGENABLED)
                lpDevI->dwFEFlags |= D3DFE_FOG_DIRTY;
            break;
        case D3DLIGHTSTATE_FOGEND:
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_FOG_END found");
            LIGHTING.fog_end = lpLset[i].dvArg[0];
            if (lpDevI->dwFEFlags & D3DFE_FOGENABLED)
                lpDevI->dwFEFlags |= D3DFE_FOG_DIRTY;
            break;
        case D3DLIGHTSTATE_FOGDENSITY:
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_FOG_DENSITY found");
            LIGHTING.fog_density = lpLset[i].dvArg[0];
            if (lpDevI->dwFEFlags & D3DFE_FOGENABLED)
                lpDevI->dwFEFlags |= D3DFE_FOG_DIRTY;
            break;
        case D3DLIGHTSTATE_COLORMODEL:
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_COLORMODEL found");
            LIGHTING.color_model = (D3DCOLORMODEL)lpLset[i].dwArg[0];
            break;
        case D3DLIGHTSTATE_COLORVERTEX:
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_COLORVERTEX found");
            if (lpLset[i].dwArg[0])
                lpDevI->dwFEFlags |= D3DFE_COLORVERTEX;
            else
                lpDevI->dwFEFlags &= ~D3DFE_COLORVERTEX;
            break;

        default:
            D3D_WARN(1, "in HEL D3DOP_STATELIGHT. Invalid state type %d",
                lpLset[i].dlstLightStateType);
            return (DDERR_INVALIDPARAMS);
        }

        // Update ramp rasterizer if necessary
        hr = CallRampService(lpDevI, RAMP_SERVICE_SETLIGHTSTATE,
                          (DWORD) type, &(lpLset[i].dvArg[0]));
        if (hr != D3D_OK)
        {
            return hr;
        }
    }

    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\helxfrm.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       helxfrm.c
 *  Content:    Direct3D front-end transform and process vertices
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "light.h"

void MatrixProduct2(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b);

D3DFE_PVFUNCS GeometryFuncsGuaranteed; // Our implementation

DWORD   debugFlags = 0;

void SetDebugRenderState(DWORD value)
{
    debugFlags = value;
}
//---------------------------------------------------------------------
void setIdentity(D3DMATRIXI * m)
{
    m->type = D3DIMatrixIdentity;

    m->_11 = D3DVAL(1.0); m->_12 = D3DVAL(0.0); m->_13 = D3DVAL(0.0); m->_14 = D3DVAL(0.0);
    m->_21 = D3DVAL(0.0); m->_22 = D3DVAL(1.0); m->_23 = D3DVAL(0.0); m->_24 = D3DVAL(0.0);
    m->_31 = D3DVAL(0.0); m->_32 = D3DVAL(0.0); m->_33 = D3DVAL(1.0); m->_34 = D3DVAL(0.0);
    m->_41 = D3DVAL(0.0); m->_42 = D3DVAL(0.0); m->_43 = D3DVAL(0.0); m->_44 = D3DVAL(1.0);
}
//---------------------------------------------------------------------
HRESULT D3DFE_InitTransform(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_TRANSFORM *transform = &lpDevI->transform;

    LIST_INITIALIZE(&transform->matrices);

    lpDevI->rExtents.x1 = 0;
    lpDevI->rExtents.y1 = 0;
    lpDevI->rExtents.x2 = 0;
    lpDevI->rExtents.y2 = 0;

    setIdentity(&lpDevI->mCTM);
    setIdentity(&transform->proj);
    setIdentity(&transform->world);
    setIdentity(&transform->view);

    STATESET_INIT(lpDevI->transformstate_overrides);

    return (D3D_OK);
}
//---------------------------------------------------------------------
void D3DFE_DestroyTransform(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_TRANSFORM *transform = &lpDevI->transform;

    while (LIST_FIRST(&transform->matrices)) {
        LPD3DMATRIXI lpMat;
        lpMat = LIST_FIRST(&transform->matrices);
        LIST_DELETE(lpMat, link);
        D3DFree(lpMat);
    }
}
//---------------------------------------------------------------------
/*
 * Combine all matrices.
 */
void updateTransform(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_VIEWPORTCACHE& VPORT = lpDevI->vcache;
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    if (lpDevI->dwFEFlags & (D3DFE_VIEWPORT_DIRTY | D3DFE_PROJMATRIX_DIRTY))
    { // Update Mproj*Mclip
        if (lpDevI->dwFEFlags & D3DFE_PROJ_PERSPECTIVE)
        {
            TRANSFORM.mPC._11 = TRANSFORM.proj._11*VPORT.mclip11;
            TRANSFORM.mPC._12 = D3DVAL(0);
            TRANSFORM.mPC._13 = D3DVAL(0);
            TRANSFORM.mPC._14 = D3DVAL(0);
            TRANSFORM.mPC._21 = D3DVAL(0);
            TRANSFORM.mPC._22 = TRANSFORM.proj._22*VPORT.mclip22;
            TRANSFORM.mPC._23 = D3DVAL(0);
            TRANSFORM.mPC._24 = D3DVAL(0);
            TRANSFORM.mPC._31 = VPORT.mclip41;
            TRANSFORM.mPC._32 = VPORT.mclip42;
            TRANSFORM.mPC._33 = TRANSFORM.proj._33*VPORT.mclip33 +
                TRANSFORM.proj._34*VPORT.mclip43;
            TRANSFORM.mPC._34 = D3DVAL(1);
            TRANSFORM.mPC._41 = TRANSFORM.proj._41*VPORT.mclip11;
            TRANSFORM.mPC._42 = TRANSFORM.proj._42*VPORT.mclip22;
            TRANSFORM.mPC._43 = TRANSFORM.proj._43*VPORT.mclip33;
            TRANSFORM.mPC._44 = TRANSFORM.proj._44;
        }
        else
        {
            TRANSFORM.mPC._11 = TRANSFORM.proj._11*VPORT.mclip11 +
                TRANSFORM.proj._14*VPORT.mclip41;
            TRANSFORM.mPC._12 = TRANSFORM.proj._12*VPORT.mclip22 +
                TRANSFORM.proj._14*VPORT.mclip42;
            TRANSFORM.mPC._13 = TRANSFORM.proj._13*VPORT.mclip33 +
                TRANSFORM.proj._14*VPORT.mclip43;
            TRANSFORM.mPC._14 = TRANSFORM.proj._14;
            TRANSFORM.mPC._21 = TRANSFORM.proj._21*VPORT.mclip11 +
                TRANSFORM.proj._24*VPORT.mclip41;
            TRANSFORM.mPC._22 = TRANSFORM.proj._22*VPORT.mclip22 +
                TRANSFORM.proj._24*VPORT.mclip42;
            TRANSFORM.mPC._23 = TRANSFORM.proj._23*VPORT.mclip33 +
                TRANSFORM.proj._24*VPORT.mclip43;
            TRANSFORM.mPC._24 = TRANSFORM.proj._24;
            TRANSFORM.mPC._31 = TRANSFORM.proj._31*VPORT.mclip11 +
                TRANSFORM.proj._34*VPORT.mclip41;
            TRANSFORM.mPC._32 = TRANSFORM.proj._32*VPORT.mclip22 +
                TRANSFORM.proj._34*VPORT.mclip42;
            TRANSFORM.mPC._33 = TRANSFORM.proj._33*VPORT.mclip33 +
                TRANSFORM.proj._34*VPORT.mclip43;
            TRANSFORM.mPC._34 = TRANSFORM.proj._34;
            TRANSFORM.mPC._41 = TRANSFORM.proj._41*VPORT.mclip11 +
                TRANSFORM.proj._44*VPORT.mclip41;
            TRANSFORM.mPC._42 = TRANSFORM.proj._42*VPORT.mclip22 +
                TRANSFORM.proj._44*VPORT.mclip42;
            TRANSFORM.mPC._43 = TRANSFORM.proj._43*VPORT.mclip33 +
                TRANSFORM.proj._44*VPORT.mclip43;
            TRANSFORM.mPC._44 = TRANSFORM.proj._44;
        }
    }
    if (lpDevI->dwFEFlags & (D3DFE_VIEWMATRIX_DIRTY |
                             D3DFE_VIEWPORT_DIRTY |
                             D3DFE_PROJMATRIX_DIRTY))
    { // Update Mview*Mproj*Mclip
        MatrixProduct(&TRANSFORM.mVPC, &TRANSFORM.view, &TRANSFORM.mPC);
    }

    MatrixProduct(&lpDevI->mCTM, &TRANSFORM.world, &TRANSFORM.mVPC);

    if ((lpDevI->dwFEFlags & (D3DFE_AFFINE_WORLD | D3DFE_AFFINE_VIEW)) ==
        (D3DFE_AFFINE_WORLD | D3DFE_AFFINE_VIEW))
        lpDevI->dwFEFlags |= D3DFE_AFFINE_WORLD_VIEW;
    else
        lpDevI->dwFEFlags &= ~D3DFE_AFFINE_WORLD_VIEW;

    // Set dirty bit for world*view matrix (needed for fog)
    if (lpDevI->dwFEFlags & (D3DFE_VIEWMATRIX_DIRTY |
                             D3DFE_WORLDMATRIX_DIRTY))
        lpDevI->dwFEFlags |= D3DFE_WORLDVIEWMATRIX_DIRTY;
    // All matrices are set up
    lpDevI->dwFEFlags &= ~D3DFE_TRANSFORM_DIRTY;
    // Set dirty bit for lighting
    lpDevI->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS |
                         D3DFE_INVERSEMCLIP_DIRTY |
                         D3DFE_FRUSTUMPLANES_DIRTY;
    lpDevI->dwFlags |= D3DPV_TRANSFORMDIRTY;
    lpDevI->dwDeviceFlags |= D3DDEV_TRANSFORMDIRTY;
}
//---------------------------------------------------------------------
void UpdateMatrixProj(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    lpDevI->dwFEFlags &= ~D3DFE_PROJ_PERSPECTIVE;
    if (FLOAT_EQZ(TRANSFORM.proj._12) &&
        FLOAT_EQZ(TRANSFORM.proj._13) &&
        FLOAT_EQZ(TRANSFORM.proj._14) &&
        FLOAT_EQZ(TRANSFORM.proj._21) &&
        FLOAT_EQZ(TRANSFORM.proj._23) &&
        FLOAT_EQZ(TRANSFORM.proj._24) &&
        FLOAT_EQZ(TRANSFORM.proj._31) &&
        FLOAT_EQZ(TRANSFORM.proj._32) &&
        FLOAT_CMP_PONE(TRANSFORM.proj._34, ==))
    {
        lpDevI->dwFEFlags |= D3DFE_PROJ_PERSPECTIVE;
    }
    lpDevI->dwFEFlags |= D3DFE_PROJMATRIX_DIRTY;
}
//---------------------------------------------------------------------
void UpdateMatrixView(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    lpDevI->dwFEFlags &= ~D3DFE_AFFINE_VIEW;
    if (FLOAT_EQZ(TRANSFORM.view._14) &&
        FLOAT_EQZ(TRANSFORM.view._24) &&
        FLOAT_EQZ(TRANSFORM.view._34) &&
        FLOAT_CMP_PONE(TRANSFORM.view._44, ==))
    {
        lpDevI->dwFEFlags |= D3DFE_AFFINE_VIEW;
    }
    lpDevI->dwFEFlags |= D3DFE_VIEWMATRIX_DIRTY;
}
//---------------------------------------------------------------------
void UpdateMatrixWorld(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    lpDevI->dwFEFlags &= ~D3DFE_AFFINE_WORLD;

    if (FLOAT_EQZ(TRANSFORM.world._14) &&
        FLOAT_EQZ(TRANSFORM.world._24) &&
        FLOAT_EQZ(TRANSFORM.world._34) &&
        FLOAT_CMP_PONE(TRANSFORM.world._44, ==))
    {
        lpDevI->dwFEFlags |= D3DFE_AFFINE_WORLD;
    }
    lpDevI->dwFEFlags |= D3DFE_WORLDMATRIX_DIRTY;
}
//---------------------------------------------------------------------
HRESULT D3DFE_SetMatrixProj(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    *(D3DMATRIX*)&TRANSFORM.proj = *mat;
    UpdateMatrixProj(lpDevI);
    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT D3DFE_SetMatrixView(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    *(D3DMATRIX*)&TRANSFORM.view = *mat;
    UpdateMatrixView(lpDevI);
    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT D3DFE_SetMatrixWorld(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    *(D3DMATRIX*)&TRANSFORM.world = *mat;
    UpdateMatrixWorld(lpDevI);
    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT D3DFE_MultMatrixProj(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    MatrixProduct(&TRANSFORM.proj, (D3DMATRIXI*)mat, &TRANSFORM.proj);
    UpdateMatrixProj(lpDevI);
    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT D3DFE_MultMatrixView(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    MatrixProduct(&TRANSFORM.view, (D3DMATRIXI*)mat, &TRANSFORM.view);
    UpdateMatrixView(lpDevI);
    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT D3DFE_MultMatrixWorld(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    MatrixProduct(&TRANSFORM.world, (D3DMATRIXI*)mat, &TRANSFORM.world);
    UpdateMatrixWorld(lpDevI);
    return (D3D_OK);
}
//---------------------------------------------------------------------
#define MATRIX_PRODUCT(res, a, b)                                           \
res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31 + a->_14*b->_41;   \
res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32 + a->_14*b->_42;   \
res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33 + a->_14*b->_43;   \
res->_14 = a->_11*b->_14 + a->_12*b->_24 + a->_13*b->_34 + a->_14*b->_44;   \
                                                                            \
res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31 + a->_24*b->_41;   \
res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32 + a->_24*b->_42;   \
res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33 + a->_24*b->_43;   \
res->_24 = a->_21*b->_14 + a->_22*b->_24 + a->_23*b->_34 + a->_24*b->_44;   \
                                                                            \
res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31 + a->_34*b->_41;   \
res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32 + a->_34*b->_42;   \
res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33 + a->_34*b->_43;   \
res->_34 = a->_31*b->_14 + a->_32*b->_24 + a->_33*b->_34 + a->_34*b->_44;   \
                                                                            \
res->_41 = a->_41*b->_11 + a->_42*b->_21 + a->_43*b->_31 + a->_44*b->_41;   \
res->_42 = a->_41*b->_12 + a->_42*b->_22 + a->_43*b->_32 + a->_44*b->_42;   \
res->_43 = a->_41*b->_13 + a->_42*b->_23 + a->_43*b->_33 + a->_44*b->_43;   \
res->_44 = a->_41*b->_14 + a->_42*b->_24 + a->_43*b->_34 + a->_44*b->_44;
//---------------------------------------------------------------------
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b)
{
    if (result == a || result == b)
    {
        MatrixProduct2(result, a, b);
        return;
    }
    MATRIX_PRODUCT(result, a, b);
}
//---------------------------------------------------------------------
// result = a*b
// result is the same as a or b
//
void MatrixProduct2(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b)
{
    D3DMATRIX res;
    MATRIX_PRODUCT((&res), a, b);
    *(D3DMATRIX*)result = res;
}
//--------------------------------------------------------------------------
// Transform vertices for viewport
//
#define _PV_NAME D3DFE_TransformClippedVp
#define _PV_VIEWPORT
#define _PV_CLIP
#define _PV_EXTENT
#include "procver.h"
#undef _PV_NAME
#undef _PV_CLIP
#undef _PV_EXTENT
#undef _PV_VIEWPORT

#define _PV_NAME D3DFE_TransformUnclippedVp
#define _PV_VIEWPORT
#define _PV_EXTENT
#include "procver.h"
#undef _PV_NAME
#undef _PV_EXTENT
#undef _PV_VIEWPORT
//---------------------------------------------------------------------------
void D3DFE_UpdateFog(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_LIGHTING& LIGHTING = lpDevI->lighting;
    if (LIGHTING.fog_end == LIGHTING.fog_start)
    {
        LIGHTING.fog_factor = D3DVAL(0.0);
        LIGHTING.fog_factor_ramp = D3DVAL(0.0);
    }
    else
    {
        LIGHTING.fog_factor = D3DVAL(255) / (LIGHTING.fog_end - LIGHTING.fog_start);
        if (lpDevI->dwDeviceFlags & D3DDEV_RAMP)
            LIGHTING.fog_factor_ramp = D3DVAL(1.0/255.0) * LIGHTING.fog_factor;
    }
    lpDevI->dwFEFlags &= ~D3DFE_FOG_DIRTY;
}
//----------------------------------------------------------------------------
void UpdateXfrmLight(LPDIRECT3DDEVICEI lpDevI)
{
    if (lpDevI->dwFEFlags & D3DFE_TRANSFORM_DIRTY)
        updateTransform(lpDevI);

    if (lpDevI->dwDeviceFlags & D3DDEV_RAMP)
    {
        RAMP_RANGE_INFO rampInfo;
        CallRampService(lpDevI, RAMP_SERVICE_FIND_LIGHTINGRANGE,
                           (ULONG_PTR)&rampInfo, 0);
        lpDevI->dwRampBase  = rampInfo.base;
        lpDevI->dvRampScale = D3DVAL(max(min((INT32)rampInfo.size - 1, 0x7fff), 0));
        lpDevI->lpvRampTexture = rampInfo.pTexRampMap;
        if (rampInfo.specular)
            lpDevI->dwFlags |= D3DPV_RAMPSPECULAR;
        else
            lpDevI->dwFlags &= ~D3DPV_RAMPSPECULAR;
    }

    if ((lpDevI->dwFlags & D3DPV_LIGHTING) &&
        lpDevI->dwFEFlags & (D3DFE_NEED_TRANSFORM_LIGHTS |
                             D3DFE_LIGHTS_DIRTY |
                             D3DFE_MATERIAL_DIRTY))
    {
        D3DFE_UpdateLights(lpDevI);
        lpDevI->dwFlags |= D3DPV_LIGHTSDIRTY;
        lpDevI->dwDeviceFlags |= D3DDEV_LIGHTSDIRTY;
    }

    if (lpDevI->dwFEFlags & D3DFE_FOGENABLED)
    {
        lpDevI->dwFlags |= D3DPV_FOG;

        if (lpDevI->rstates[D3DRENDERSTATE_RANGEFOGENABLE])
            lpDevI->dwFlags |= D3DPV_RANGEBASEDFOG;

        if (lpDevI->dwFEFlags & D3DFE_FOG_DIRTY)
            D3DFE_UpdateFog(lpDevI);

        if (lpDevI->dwFEFlags & D3DFE_WORLDVIEWMATRIX_DIRTY)
        {
            MatrixProduct(&lpDevI->mWV, &lpDevI->transform.world,
                                        &lpDevI->transform.view);
            lpDevI->dwFEFlags &= ~D3DFE_WORLDVIEWMATRIX_DIRTY;
        }
    }
}
//---------------------------------------------------------------------
// Convert extents from floating point to integer.
//
#undef DPF_MODNAME
#define DPF_MODNAME "D3DFE_ConvertExtent"

void D3DFE_ConvertExtent(LPDIRECT3DDEVICEI lpDevI, LPD3DRECTV from, LPD3DRECT to)
{
    to->x1 = FTOI(from->x1) - 1;
    to->y1 = FTOI(from->y1) - 1;
    to->x2 = FTOI(from->x2) + 1;
    to->y2 = FTOI(from->y2) + 1;
    if (to->x1 < lpDevI->vcache.minXi)
        to->x1 = lpDevI->vcache.minXi;
    if (to->y1 < lpDevI->vcache.minYi)
        to->y1 = lpDevI->vcache.minYi;
    if (to->x2 > lpDevI->vcache.maxXi)
        to->x2 = lpDevI->vcache.maxXi;
    if (to->y2 > lpDevI->vcache.maxYi)
        to->y2 = lpDevI->vcache.maxYi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\bcnt\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#



GENSYMFLAGS = -DWINNT -DNT
386_ASSEMBLER_NAME=ml611d
RASTROOT= $(D3DDX6)\rast
!include $(RASTROOT)\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\bc9x\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#



GENSYMFLAGS = -DWIN95 
386_ASSEMBLER_NAME=ml611d
RASTROOT= $(D3DDX6)\rast
!include $(RASTROOT)\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\daytona\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#



GENSYMFLAGS = -DWINNT -DNT
386_ASSEMBLER_NAME=ml611d
RASTROOT= $(D3DDX6)\rast
!include $(RASTROOT)\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\i386\light.asm ===
.486p

.model flat

include offsets.asm

.data

one DWORD   3f800000h

a1      dd 0.47                 ; Constants to compute inverse square root
a2      dd 1.47
v255    dd 65280.0              ; 255*256
v1_256  dd 0.00390625           ; 1/255
.code

PUBLIC  _Directional2P5S        ; Pentium optimized, specular, unit scale
PUBLIC  _Directional2P5         ; Pentium optimized, no specular, unit scale
;-------------------------------------------------------------------------
; Jim Blinn's method is used to compute inverse square root s = 1/sqrt(x):
;   ONE_AS_INTEGER = 0x3F800000
;   float y;
;   int tmp = ((ONE_AS_INTEGER << 1 + ONE_AS_INTEGER)  - *(long*)&x) >> 1;   
;   y = *(float*)&tmp;  
;   s = y*(1.47f - 0.47f*x*y*y);
; Input:
;   st(0)   = vector length
;   y, len  = should be defined as DWORD PTR
;   a1, a2  = 0.27 and 1.47
; Output:
;   st(0)   = 1/sqrt(vector length)
;
COMPUTE_ISQRT MACRO
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    fst     len                         ; Vector length (x = len)
    sub     eax, len
    sar     eax, 1
    mov     y, eax                      ; y
    fmul    a1                          ; len*0.47  x y z
    fld     y                           ; y len*0.47 x y z
    fld     st(0)                       ; y y len*0.47 x y z
    fmul    st(0), st(1)                ; y*y y len*0.47 x y z
    fld     a2                          ; 1.47 y*y y len*0.47 x y z
    fxch    st(3)                       ; len*0.47 y*y y 1.47 x y z
    fmulp   st(1), st(0)                ; len*0.47*y*y y 1.47 x y z
    fsubp   st(2), st(0)                ; y aaa x y z
    fmulp   st(1), st(0)                ; 1/sqrt(len) x y z
ENDM
;-------------------------------------------------------------------------
; Exit from the function
;
EXIT_FUNC   MACRO
    pop     edx
    pop     ebx
    pop     ecx
    mov     esp, ebp
    pop     ebp
    ret
ENDM
;-------------------------------------------------------------------------
; void Directional2P5S(LPD3DFE_PROCESSVERTICES pv, 
;                   D3DI_LIGHT *light, 
;                   D3DLIGHTINGELEMENT *vertex)
; Limitations:
;   Transformation matrix should not have a scale
;   Specular is always computed
;   Optimized for Pentium
;
; Input:
;   [esp + 4]   - pv
;   [esp + 8]   - light    
;   [esp + 12]  - vertex
; Output:
;   pv.lighting.diffuse and pv.lighting.specular are updated
;   pv.lighting.specularComputed is set to 1, if there is specular component
;
pv      equ DWORD PTR [ebp + 8]
light   equ DWORD PTR [ebp + 12]
vertex  equ DWORD PTR [ebp + 16]

dot     equ DWORD PTR [ebp - 4]
y       equ DWORD PTR [ebp - 8]     ; temporary variable to compute 
                                    ; inverse square root
len     equ DWORD PTR [ebp - 12]    ; vector length

_Directional2P5S PROC NEAR

    push    ebp
    mov     ebp, esp
    sub     esp, 12

    push    ecx
    mov     ecx, light
    push    ebx
    mov     ebx, vertex

; dot = VecDot(light->model_direction, in->dvNormal)

    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_] ; z y x
    fxch    st(2)       ; x y z
    faddp   st(1), st   ; x+y z
    push    edx
    faddp   st(1), st   ; dot
    mov     edx, pv
    fst     dot
    cmp     dot, 0
    jle     exit1

; ldrv.diffuse.r += light->local_diffR * dot;
; ldrv.diffuse.g += light->local_diffG * dot;
; ldrv.diffuse.b += light->local_diffB * dot;

    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffB]
    fmulp   st(3), st(0)                    ; g r b
    fxch    st(1)                           ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fxch    st(1)                           ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]
    fxch    st(2)                           ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fxch    st(1)                           ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]

; if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)

;    test    DWORD PTR [ecx + D3DI_LIGHT_flags], D3DLIGHTI_COMPUTE_SPECULAR
;    jz      exit

; VecSub(in->dvPosition, light->model_eye, eye);

    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _X_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _X_]
    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _Y_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _Y_]
    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _Z_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _Z_]    ; z y x
    fxch    st(2)                                           ; x y z

; VecNormalizeFast(eye);
;

; Compute vector length. Leave vector on the FPU stack, because we will use it
;
    fld     st(1)                       ; x x y z
    fmul    st(0), st(0)                ; x*x x y z
    fld     st(2)
    fmul    st(0), st(0)                ; y*y x*x x y z
    fld     st(4)
    fmul    st(0), st(0)                ; z*z y*y x*x x y z
    fxch    st(2)			            ; x y z
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len x y z

    COMPUTE_ISQRT                       ; st(0) will be 1/sqrt(len)

; Start normalizing the eye vector
    fmul    st(1), st(0)
    fmul    st(2), st(0)
    fmulp   st(3), st(0)                ; x y z  Normalized "eye" vector

; Calc halfway vector
; VecSub(light->model_direction, eye, h);
;
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fxch    st(1)                       ; y x z
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fxch    st(2)                       ; z x y 
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fxch    st(1)                       ; x z y 

; dot = VecDot(h, in->dvNormal);

    fld     st(0)
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     st(3)
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     st(3)                       ; z*Nz y*Ny x*Nx x z y
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_]
    fxch    st(2)
    faddp   st(1), st(0)
    faddp   st(1), st(0)                ; dot x z y
    fstp    dot                         ; x z y

; if (FLOAT_GTZ(dot)) 

    cmp     dot, 0
    jle     exit2

; dot *= ISQRTF(VecLenSq(h));
;
    fmul    st(0), st(0)                ; x*x y z
    fxch    st(1)                       ; y x*x z
    fmul    st(0), st(0)                ; y*y x*x z
    fxch    st(2)
    fmul    st(0), st(0)                ; z*z y*y x*x
    fxch    st(2)			            ; 
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len

    COMPUTE_ISQRT                       ; st(0) will be 1/sqrt(len)

    fmul    dot                         ; dot
    mov     eax, [edx + PV_LIGHT_specThreshold]
    fst     dot

; if (FLOAT_CMP_POS(dot, >=, ldrv.specThreshold))

    cmp     dot, eax
    jle     exit1

; power = COMPUTE_DOT_POW(&ldrv, dot);
;    int     indx;                
;    float   v;
;    dot *= 255.0f;
;    indx = (int)dot;
;    dot -= indx;                                            
;    ldrv->specularComputed = TRUE;                          
;    v = ldrv->currentSpecTable[indx];
;    return v + (ldrv->currentSpecTable[indx+1] - v)*dot;
;
    fmul    v255            ; dot*255*256
    push    ebx
    fistp   dot             ; indx << 8. 8 bits used to compute dot fraction
    mov     ebx, dot        ; 
    and     dot, 0FFh       ; fractional part of dot
    shr     ebx, 8          ; Table index
    mov     eax, [edx + PV_LIGHT_currentSpecTable]
    lea     eax, [eax + ebx*4]
    fild    dot             ; fractional part of dot
    fmul    v1_256          ; dot*1/256 -> integer fraction to floating point
    fld     DWORD PTR [eax + 4]     ; currentSpecTable[indx+1]
    fsub    DWORD PTR [eax]         ; currentSpecTable[indx]
    fmulp   st(1), st(0)            ; dot*(v2-v1)
    mov     DWORD PTR [edx + PV_LIGHT_specularComputed], 1
    pop     ebx
    fadd    DWORD PTR [eax]

; power = COMPUTE_DOT_POW(&ldrv, dot);
; This is an alternative method to compute x power y.
; Jim Blinn's method is used:
; int tmp = (int)(power*(*(long*)&dot - ONE_AS_INTEGER)) + ONE_AS_INTEGER;
; dot ^ power = *(float*)&tmp;                                           
;
;    sub     dot, 03F800000h
;    fstp    st(0)                       ; Remove dot
;    fld     DWORD PTR [edx + PV_LIGHT_material_power]
;    fimul   dot
;    fistp   dot
;    mov     DWORD PTR [edx + PV_LIGHT_specularComputed], 1
;    add     dot, 03F800000h
;    fld     dot

; ldrv.specular.r += light->local_specR * power;
; ldrv.specular.g += light->local_specG * power;
; ldrv.specular.b += light->local_specB * power;
;
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specB]
    fmulp   st(3), st(0)                ; g r b
    fxch    st(1)                       ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _R_]
    fxch    st(1)                       ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _G_]
    fxch    st(2)                       ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _G_]
    fxch    st(1)                       ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _G_]
exit:
    EXIT_FUNC
exit1:
    fstp    st(0)
    EXIT_FUNC
exit2:
    fstp    st(0)
    fstp    st(0)
    fstp    st(0)
    EXIT_FUNC

_Directional2P5S ENDP
;-------------------------------------------------------------------------
; void Directional2P5(LPD3DFE_PROCESSVERTICES pv, 
;                   D3DI_LIGHT *light, 
;                   D3DLIGHTINGELEMENT *vertex)
; Limitations:
;   Transformation matrix should not have a scale
;   Only diffuse component is computed
;   Optimized for Pentium
;
; Input:
;   [esp + 4]   - pv
;   [esp + 8]   - light    
;   [esp + 12]  - vertex
; Output:
;   pv.lighting.diffuse is updated
;
pv      equ DWORD PTR [ebp + 8]
light   equ DWORD PTR [ebp + 12]
vertex  equ DWORD PTR [ebp + 16]

dot     equ DWORD PTR [ebp - 4]
y       equ DWORD PTR [ebp - 8]     ; temporary variable to compute 
                                    ; inverse square root
len     equ DWORD PTR [ebp - 12]    ; vector length

_Directional2P5 PROC NEAR

    push    ebp
    mov     ebp, esp
    sub     esp, 12

    push    ecx
    mov     ecx, light
    push    ebx
    mov     ebx, vertex

; dot = VecDot(light->model_direction, in->dvNormal)

    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_] ; z y x
    fxch    st(2)       ; x y z
    faddp   st(1), st   ; x+y z
    push    edx
    faddp   st(1), st   ; dot
    mov     edx, pv
    fst     dot
    cmp     dot, 0
    jle     exit3

; ldrv.diffuse.r += light->local_diffR * dot;
; ldrv.diffuse.g += light->local_diffG * dot;
; ldrv.diffuse.b += light->local_diffB * dot;

    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffB]
    fmulp   st(3), st(0)                    ; g r b
    fxch    st(1)                           ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fxch    st(1)                           ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]
    fxch    st(2)                           ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fxch    st(1)                           ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]

    EXIT_FUNC
exit3:
    fstp    st(0)
    EXIT_FUNC

_Directional2P5 ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\i386\tclipp5.asm ===
.486p

.model flat

include offsets.asm
include pentium2.inc

.code

if 0
D3DVERTEX_x	equ	0
D3DVERTEX_y	equ	4
D3DVERTEX_z	equ	8

D3DTLVERTEX_sx  equ 0
D3DTLVERTEX_sy  equ 4
D3DTLVERTEX_sz  equ 8
D3DTLVERTEX_rhw equ 12
D3DTLVERTEX_color   equ 16
D3DTLVERTEX_specular    equ 20
D3DTLVERTEX_tu  equ 24
D3DTLVERTEX_tv  equ 28

D3DFE_PROCESSVERTICES_rExtents equ 16*4
D3DFE_PROCESSVERTICES_vcache equ 20*4
D3DFE_PROCESSVERTICES_dwFlags equ 24*4

D3DFE_VIEWPORTCACHE_scaleX equ 0
D3DFE_VIEWPORTCACHE_scaleY equ 4
D3DFE_VIEWPORTCACHE_offsetX equ 8
D3DFE_VIEWPORTCACHE_offsetY equ 12

D3DDP_DONOTUPDATEEXTENTS equ 1

D3DMATRIXI__11 equ 0
D3DMATRIXI__12 equ 4
D3DMATRIXI__13 equ 8
D3DMATRIXI__14 equ 12
D3DMATRIXI__21 equ 16
D3DMATRIXI__22 equ 20
D3DMATRIXI__23 equ 24
D3DMATRIXI__24 equ 28
D3DMATRIXI__31 equ 32
D3DMATRIXI__32 equ 36
D3DMATRIXI__33 equ 40
D3DMATRIXI__34 equ 44
D3DMATRIXI__41 equ 48
D3DMATRIXI__42 equ 52
D3DMATRIXI__43 equ 56
D3DMATRIXI__44 equ 60
endif

PUBLIC  _matmul5

_matmul5  PROC    

    pout    equ     dword ptr [esp+44]
    pin     equ     dword ptr [esp+48]
    pmat    equ     dword ptr [esp+52]
    hout    equ     dword ptr [esp+56]

    tempxx  equ     dword ptr [esp+16]
    tempyy  equ     dword ptr [esp+20]
    tempzz  equ     dword ptr [esp+24]
    tempx   equ     dword ptr [esp+28]
    tempy   equ     dword ptr [esp+32]
    tempz   equ     dword ptr [esp+36]

        sub     esp,24          ; Make room for locals

        push    ebx             ; Save regs
        push    esi             ;
        push    edi             ;
        push    ebp             ;


        mov     eax,pin         ; Get in ptr
        mov     ecx,pmat        ; Get mat ptr
        mov     ebp,pout        ; Get out ptr
        mov     esi,80000000h   ; Ready to compute clip codes

; float x, y, z, w, we;
; x = in->x*pv->mCTM._11 + in->y*pv-mCTM._21 + in->z*pv->mCTM._31 + pv->mCTM._41;
; y = in->x*pv->mCTM._12 + in->y*pv->mCTM._22 + in->z*pv->mCTM._32 + pv->mCTM._42;
; z = in->x*pv->mCTM._13 + in->y*pv->mCTM._23 + in->z*pv->mCTM._33 + pv->mCTM._43;
; we= in->x*pv->mCTM._14 + in->y*pv->mCTM._24 + in->z*pv->mCTM._34 + pv->mCTM._44;


; notation in comments on stack gives the progress on the element.
; x, y, z mean input x y z
; x1-4 means x*_11, x*_11+y*_21, x*_11+y*_21+z*_31, x*_11+y*_21+z*_31+_41
; Some intermediate results x*_11+_41 and y*_21+z*_31 are denoted as x2

        fld     dword ptr [eax+D3DVERTEX_x]     ; x1
        fmul    dword ptr [ecx+D3DMATRIXI__11]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__14]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__21]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_24 y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__24]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_31 y*_24 y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__31]  ;
        fxch    st(2)                           ; y*_21 y*_24 z*_31 w1 x1
        faddp   st(4),st                        ; y*_24 z*_31 w1 x2
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_34 y*_24 z*_31 w1 x2
        fmul    dword ptr [ecx+D3DMATRIXI__34]  ;
        fxch    st(1)                           ; y*_24 z*_34 z*_31 w1 x2
        faddp   st(3),st                        ; z*_34 z*_31 w2 x2
        fxch    st(1)                           ; z*_31 z*_34 w2 x2
        faddp   st(3),st                        ; z*_34 w2 x3
        fld     dword ptr [eax+D3DVERTEX_x]     ; y1 z*_34 w2 x3
        fmul    dword ptr [ecx+D3DMATRIXI__12]  ;
        fxch    st(1)                           ; z*_34 y1 w2 x3
        faddp   st(2),st                        ; y1 w3 x3
        fxch    st(2)                           ; x3 w3 y1
        fadd    dword ptr [ecx+D3DMATRIXI__41]  ; x4 w3 y1
        fld     dword ptr [eax+D3DVERTEX_x]     ; z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__13]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_22 z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__22]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_23 y*_22 z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__23]  ;
        fxch    st(4)                           ; w3 y*_22 z1 x4 y*_23 y1
        fadd    dword ptr [ecx+D3DMATRIXI__44]  ; w4 y*_22 z1 x4 y*_23 y1
        fxch    st(3)                           ; x4 y*_22 z1 w4 y*_23 y1
        fst     dword ptr [ebp]                 ;
        fxch    st(1)                           ; y*_22 x4 z1 w4 y*_23 y1
        faddp   st(5),st                        ; x4 z1 w4 y*_23 y2
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_32 x4 z1 w4 y*_23 y2
        fmul    dword ptr [ecx+D3DMATRIXI__32]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_33 z*_32 x4 z1 w4 y*_23 y2
        fmul    dword ptr [ecx+D3DMATRIXI__33]  ;
        fxch    st(6)                           ; y2 z*_32 x4 z1 w4 y*_23 z*_33
        fadd    dword ptr [ecx+D3DMATRIXI__42]  ; y3 z*_32 x4 z1 w4 y*_23 z*_33
        fxch    st(3)                           ; z1 z*_32 x4 y3 w4 y*_23 z*_33
        fadd    dword ptr [ecx+D3DMATRIXI__43]  ; z2 z*_32 x4 y3 w4 y*_23 z*_33
        fxch    st(5)                           ; y*_23 z*_32 x4 y3 w4 z2 z*_33
        faddp   st(6),st                        ; z*_32 x4 y3 w4 z2 z2
        faddp   st(2),st                        ; x4 y4 w4 z2 z2

;;
        fsubr   st,st(2)                        ; xx y4 w4 z2 z2
        fxch    st(4)                           ; z2 y4 w4 z2 xx
        faddp   st(3),st                        ; y4 w4 z4 xx
        fld     st                              ; y4 y4 w4 z4 xx
        fsubr   st,st(2)                        ; yy y4 w4 z4 xx
        fxch    st(1)                           ; y4 yy w4 z4 xx
        fstp    dword ptr [ebp+4]               ; yy w4 z4 xx
        fxch    st(3)                           ; xx w4 z4 yy
        fstp    tempxx                          ; w4 z4 yy
        fxch    st(1)                           ; z4 w4 yy
        fst     dword ptr [ebp+8]               ;
        fsubr   st,st(1)                        ; zz w4 yy
        fxch    st(2)                           ; yy w4 zz
        fstp    tempyy                          ; w4 zz
        fxch    st(1)                           ; zz w4
        fstp    tempzz                          ;

        fld1                                    ; 1 w4
        fdiv	st,st(1)                        ; 1/w w

;; Now compute the clipcodes.


;           D3DVALUE xx = we - x;
;           D3DVALUE yy = we - y;
;           D3DVALUE zz = we - z;
;           clip = ((ASINT32(x)  & 0x80000000) >> (32-1)) | // D3DCLIP_LEFT
;                  ((ASINT32(y)  & 0x80000000) >> (32-4)) | // D3DCLIP_BOTTOM
;                  ((ASINT32(z)  & 0x80000000) >> (32-5)) | // D3DCLIP_FRONT 
;                  ((ASINT32(xx) & 0x80000000) >> (32-2)) | // D3DCLIP_RIGHT
;                  ((ASINT32(yy) & 0x80000000) >> (32-3)) | // D3DCLIP_TOP   
;                  ((ASINT32(zz) & 0x80000000) >> (32-6));  // D3DCLIP_BACK

        mov     eax,dword ptr [ebp]     ; Get x
        mov     ebx,dword ptr [ebp+4]   ; Get y

        and     eax,esi                 ;
        and     ebx,esi                 ;

        shr     eax,32-1                ; D3DCLIP_LEFT
        mov     ecx,dword ptr [ebp+8]   ; Get z

        shr     ebx,32-4		; D3DCLIP_BOTTOM
        mov     edx,tempxx		;

        or      eax,ebx			; OR together clip flags
        and     ecx,esi			;

        shr     ecx,32-5		; D3DCLIP_FRONT
        and     edx,esi                 ;

        shr     edx,32-2                ; D3DCLIP_RIGHT
        mov     ebx,tempyy		;

        or      eax,ecx                 ;
        and     ebx,esi                 ;

        shr     ebx,32-3                ; D3DCLIP_TOP
        or      eax,edx                 ;

        mov     edx,tempzz
        or      eax,ebx                 ;

        and     edx,esi                 ;

        shr     edx,32-6                ; D3DCLIP_BACK
        mov     esi,hout                ; Propagate diffuse, specular, tu, tv

        or      eax,edx                 ; Finish clip flag generation
        mov     ebx,pmat                ;

        mov     word ptr [esi],ax       ; Output clip flags
        mov     esi,pin                 ;

        test    eax,eax                 ; Bail if clip!=0
        jnz     ClipNonzero             ;

        push    eax                     ; Save clip flags
                                        ; ax gets trashed by fstsw in min/max calcs

        mov     ecx,[esi+D3DTLVERTEX_color]
        mov     edx,[esi+D3DTLVERTEX_specular]

        mov     [ebp+D3DTLVERTEX_color],ecx
        mov     [ebp+D3DTLVERTEX_specular],edx

        mov     ecx,[esi+D3DTLVERTEX_tu]
        mov     edx,[esi+D3DTLVERTEX_tv]

        mov     [ebp+D3DTLVERTEX_tu],ecx
        mov     [ebp+D3DTLVERTEX_tv],edx


        fxch    st(1)                   ; we w
        fstp    st                      ;
                                        ; w
        fld     dword ptr [ebp]         ; x w
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleX]
        fld     dword ptr [ebp+4]       ; y x*scaleX w
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleY]
        fxch    st(1)                   ; x*scaleX y*scaleY w
        fmul    st,st(2)                ; x*w*scaleX y*scaleY w
        fxch    st(1)                   ; y*scaleY x*w*scaleX w
        fmul    st,st(2)                ; y*w*scaleY x*w*scaleX w
        fxch    st(1)                   ; x*w*scaleX y*w*scaleY w
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetX]
        fxch    st(1)                   ; y x w
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetY]
        fld     dword ptr [ebp+8]       ; z y x w
        fmul    st,st(3)                ; z y x w
        fxch    st(2)                   ; x y z w

        test    dword ptr [ebx+D3DFE_PROCESSVERTICES_dwFlags], D3DDP_DONOTUPDATEEXTENTS
        jnz     NoExtents

;; update extents rect in PV structure

    ; x y z w
        fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
        fstsw   ax
        sahf
        ja      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
@@:     fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
        fstsw   ax
        sahf
        jb      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
@@:     fxch    st(1)
        fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
        fstsw   ax
        sahf
        ja      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
@@:     fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
        fstsw   ax
        sahf
        jb      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
@@:     fxch    st(1)
NoExtents:
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]

        pop     eax         ; Get clip flags back
Return:
        pop     ebp         ; Restore registers
        pop     edi         ;
        pop     esi         ;
        pop     ebx         ;
        add     esp,24      ; Locals

        ret                 ; Return

ClipNonZero:
        fstp    st          ; Get rid of 1/w
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw] ; store we
        jmp     short Return

_matmul5  ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\i386\tclipp6.asm ===
.486p

.model flat

include offsets.asm
include pentium2.inc

.data

gD3DCLIP_LEFT   dd  01h
gD3DCLIP_RIGHT  dd  02h
gD3DCLIP_TOP    dd  04h
gD3DCLIP_BOTTOM dd  08h
gD3DCLIP_FRONT  dd  10h
gD3DCLIP_BACK   dd  20h

.code

if 0
D3DVERTEX_x	equ	0
D3DVERTEX_y	equ	4
D3DVERTEX_z	equ	8

D3DTLVERTEX_sx  equ 0
D3DTLVERTEX_sy  equ 4
D3DTLVERTEX_sz  equ 8
D3DTLVERTEX_rhw equ 12
D3DTLVERTEX_color   equ 16
D3DTLVERTEX_specular    equ 20
D3DTLVERTEX_tu  equ 24
D3DTLVERTEX_tv  equ 28

D3DFE_PROCESSVERTICES_rExtents equ 16*4
D3DFE_PROCESSVERTICES_vcache equ 20*4
D3DFE_PROCESSVERTICES_dwFlags equ 24*4

D3DFE_VIEWPORTCACHE_scaleX equ 0
D3DFE_VIEWPORTCACHE_scaleY equ 4
D3DFE_VIEWPORTCACHE_offsetX equ 8
D3DFE_VIEWPORTCACHE_offsetY equ 12

D3DDP_DONOTUPDATEEXTENTS equ 1

D3DMATRIXI__11 equ 0
D3DMATRIXI__12 equ 4
D3DMATRIXI__13 equ 8
D3DMATRIXI__14 equ 12
D3DMATRIXI__21 equ 16
D3DMATRIXI__22 equ 20
D3DMATRIXI__23 equ 24
D3DMATRIXI__24 equ 28
D3DMATRIXI__31 equ 32
D3DMATRIXI__32 equ 36
D3DMATRIXI__33 equ 40
D3DMATRIXI__34 equ 44
D3DMATRIXI__41 equ 48
D3DMATRIXI__42 equ 52
D3DMATRIXI__43 equ 56
D3DMATRIXI__44 equ 60
endif

PUBLIC  _matmul6

_matmul6  PROC

    pout    equ     dword ptr [esp+44]
    pin     equ     dword ptr [esp+48]
    pmat    equ     dword ptr [esp+52]
    hout    equ     dword ptr [esp+56]

    tempxx  equ     dword ptr [esp+16]
    tempyy  equ     dword ptr [esp+20]
    tempzz  equ     dword ptr [esp+24]
    tempx   equ     dword ptr [esp+28]
    tempy   equ     dword ptr [esp+32]
    tempz   equ     dword ptr [esp+36]

        sub     esp,24          ; Make room for locals

        push    ebx             ; Save regs
        push    esi             ;
        push    edi             ;
        push    ebp             ;

        mov     eax,pin         ; Get in ptr
        mov     ecx,pmat        ; Get mat ptr
        mov     ebp,pout        ; Get out ptr
        mov     esi,80000000h   ; Ready to compute clip codes

; float x, y, z, w, we;
; x = in->x*pv->mCTM._11 + in->y*pv-mCTM._21 + in->z*pv->mCTM._31 + pv->mCTM._41;
; y = in->x*pv->mCTM._12 + in->y*pv->mCTM._22 + in->z*pv->mCTM._32 + pv->mCTM._42;
; z = in->x*pv->mCTM._13 + in->y*pv->mCTM._23 + in->z*pv->mCTM._33 + pv->mCTM._43;
; we= in->x*pv->mCTM._14 + in->y*pv->mCTM._24 + in->z*pv->mCTM._34 + pv->mCTM._44;

        fld     dword ptr [eax+D3DVERTEX_x]     ; x1
        fmul    dword ptr [ecx+D3DMATRIXI__11]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__14]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; y1 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__12]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; z1 y1 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__13]  ;

        fxch    st(3)                           ; x1 y1 w1 z1
        fadd    dword ptr [ecx+D3DMATRIXI__41]  ; x2 y1 w1 z1
        fxch    st(2)                           ; w1 y1 x2 z1
        fadd    dword ptr [ecx+D3DMATRIXI__44]  ; w2 y1 x2 z1
        fxch    st(1)                           ; y1 w2 x2 z1
        fadd    dword ptr [ecx+D3DMATRIXI__42]  ; y2 w2 x2 z1
        fxch    st(3)                           ; z1 w2 x2 y2
        fadd    dword ptr [ecx+D3DMATRIXI__43]  ; z2 w2 x2 y2

        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_21
        fmul    dword ptr [ecx+D3DMATRIXI__21]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_24
        fmul    dword ptr [ecx+D3DMATRIXI__24]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_22
        fmul    dword ptr [ecx+D3DMATRIXI__22]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_23
        fmul    dword ptr [ecx+D3DMATRIXI__23]  ;

        fxch    st(3)       ; y*_21 y*_22 y*_24 y*_23 z2 w2 x2 y2
        faddp   st(6),st    ; y*_22 y*_24 y*_23 z2 w2 x3 y2
        fxch    st(1)       ; y*_24 y*_22 y*_23 z2 w2 x3 y2
        faddp   st(4),st    ; y*_22 y*_23 z2 w3 x3 y2
        faddp   st(5),st    ; y*_23 z2 w3 x3 y3
        faddp   st(1),st    ; z3 w3 x3 y3

        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_31
        fmul    dword ptr [ecx+D3DMATRIXI__31]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_34
        fmul    dword ptr [ecx+D3DMATRIXI__34]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_32
        fmul    dword ptr [ecx+D3DMATRIXI__32]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_33
        fmul    dword ptr [ecx+D3DMATRIXI__33]  ;

        fxch    st(3)       ; z*_31 z*_32 z*_34 z*_33 z3 w3 x3 y3
        faddp   st(6),st    ; z*_32 z*_34 z*_33 z3 w3 x4 y3
        fxch    st(1)       ; z*_34 z*_32 z*_33 z3 w3 x4 y3
        faddp   st(4),st    ; z*_32 z*_33 z3 w4 x4 y3
        faddp   st(5),st    ; z*_33 z3 w4 x4 y4
        faddp   st(1),st    ; z4 w4 x4 y4

        fldz                ; 0 z4 w4 x4 y4
        fxch    st(4)       ; y4 z4 w4 x4 0
        fxch    st(3)       ; x4 z4 w4 y4 0
        xor     eax,eax     ;
        xor     ebx,ebx     ;
        xor     ecx,ecx     ;
        xor     edx,edx     ;
        fcomi   st,st(4)    ;
        cmovb   eax,gD3DCLIP_LEFT
        fcomi   st,st(2)    ;
        cmovnb  ebx,gD3DCLIP_RIGHT
        fxch    st(3)       ; y4 z4 w4 x4 0
        or      eax,ebx
        xor     ebx,ebx
        fcomi   st,st(4)    ;
        cmovb   ecx,gD3DCLIP_BOTTOM
        fcomi   st,st(2)    ;
        cmovnb  edx,gD3DCLIP_TOP
        or      eax,ecx
        xor     ecx,ecx
        fxch    st(1)       ; z4 y4 w4 x4 0
        fcomi   st,st(4)    ;
        or      edx,edx
        cmovb   ebx,gD3DCLIP_FRONT
        fcomi   st,st(2)    ;
        cmovnb  ecx,gD3DCLIP_BACK
        or      eax,ebx
        mov     esi,hout                ; Propagate diffuse, specular, tu, tv
        or      eax,ecx
        mov     ebx,pmat                ;
        mov     word ptr [esi],ax       ; Output clip flags
        mov     esi,pin                 ;
        fxch    st(4)   ; 0 y4 w4 x4 z4
        fstp    st      ; y4 w4 x4 z4

;; Now compute the clipcodes.

;           D3DVALUE xx = we - x;
;           D3DVALUE yy = we - y;
;           D3DVALUE zz = we - z;
;           clip = ((ASINT32(x)  & 0x80000000) >> (32-1)) | // D3DCLIP_LEFT
;                  ((ASINT32(y)  & 0x80000000) >> (32-4)) | // D3DCLIP_BOTTOM
;                  ((ASINT32(z)  & 0x80000000) >> (32-5)) | // D3DCLIP_FRONT 
;                  ((ASINT32(xx) & 0x80000000) >> (32-2)) | // D3DCLIP_RIGHT
;                  ((ASINT32(yy) & 0x80000000) >> (32-3)) | // D3DCLIP_TOP   
;                  ((ASINT32(zz) & 0x80000000) >> (32-6));  // D3DCLIP_BACK

;; actually the flags have not been touched since the final OR so we don't 
;; need to test this explicitly
;;      test    eax,eax
        jnz     ClipNonzero             ; jump if clip flags nonzero

        fld1                ; 1 y w x z
        fdivrp  st(2),st    ; y w x z

        mov     ecx,[esi+D3DTLVERTEX_color]
        mov     edx,[esi+D3DTLVERTEX_specular]

        mov     [ebp+D3DTLVERTEX_color],ecx
        mov     [ebp+D3DTLVERTEX_specular],edx

        mov     ecx,[esi+D3DTLVERTEX_tu]
        mov     edx,[esi+D3DTLVERTEX_tv]

        mov     [ebp+D3DTLVERTEX_tu],ecx
        mov     [ebp+D3DTLVERTEX_tv],edx

        ; y w x z
        fabs
        fxch    st(2)
        fabs
        fxch    st(2)

        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleY]
        fxch    st(2)   ;
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleX]
        fxch    st(2)   ; y w x z
        fmul    st,st(1)
        fxch    st(2)   ; x w y z
        fmul    st,st(1) ;
        fxch    st(2)   ; y w x z
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetY]
        fxch    st(2)   ; x w y z
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetX]
        fxch    st(3)   ; z w y x
        fmul    st,st(1)
        fxch    st(3)   ; x w y z

        test    dword ptr [ebx+D3DFE_PROCESSVERTICES_dwFlags], D3DDP_DONOTUPDATEEXTENTS
        jnz     NoExtents

;; update extents rect in PV structure

    ; minx x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
        fcomi   st,st(1)
        fcmovnb st,st(1)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]

    ; maxx x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
        fcomi   st,st(1)
        fcmovb  st,st(1)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]

    ; miny x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
        fcomi   st,st(3)
        fcmovnb st,st(3)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]

    ; maxy x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
        fcomi   st,st(3)
        fcmovb  st,st(3)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]

NoExtents:
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
Return:
        pop     ebp         ; Restore registers
        pop     edi         ;
        pop     esi         ;
        pop     ebx         ;
        add     esp,24      ; Locals

        ret                 ; Return

ClipNonZero:
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
        jmp     short Return

_matmul6  ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\i386\ftrans.asm ===
; $Id: ftrans.asm,v 1.3 1995/10/20 15:14:41 james Exp $
;
; Up to 165K from 143K
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994, 1995
; Version 1.0
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
; NOTE: Need to set integer pop precision...
;
OPTION NOM510
.386p
;.radix  16
                NAME    transform

                include macros.asm
                include offsets.asm

procstart	macro	prefix, xfrm_class

	    ifdef STACK_CALL
	    ifdef NT
_&prefix&xfrm_class		proc
	    else
&prefix&xfrm_class		proc
	    endif
	    else
&prefix&xfrm_class&_		proc
	    endif
		endm

procend		macro	prefix, xfrm_class

	    ifdef STACK_CALL
	    ifdef NT
_&prefix&xfrm_class		endp
	    else
&prefix&xfrm_class		endp
	    endif
	    else
&prefix&xfrm_class&_		endp
	    endif
		endm
		
if GEN_XFRM eq 1
xfrmName	equ	General
else
xfrmName	equ	Affine
endif


;ifndef WINNT
;DGROUP          GROUP   _DATA
;endif

_DATA           SEGMENT PARA PUBLIC USE32 'DATA'

; These two are in the same cache line
tx              dq	0
ty		dq	0

_DATA           ENDS

_TEXT           SEGMENT DWORD PUBLIC USE32 'CODE'
;ifdef WINNT
                ASSUME  CS:_TEXT ,DS:_DATA,SS:_DATA
;else
;               ASSUME  CS:_TEXT ,DS:DGROUP,SS:DGROUP
;endif

FDROP   macro
        fstp    st(0)
        endm

fmat	macro	op,row,col
	op	dword ptr [ebp + 4 * ((4 * row) + col)]
	endm

column	macro	i,depth
	fld	dword ptr [esi + D3DVERTEX_x]	; [1]	x

	fmat	fmul,0,i			; [2]	x

	fld	dword ptr [esi + D3DVERTEX_y]	; [3]	y	x

	fmat	fmul,1,i			; [4]	y	x

	fld	dword ptr [esi + D3DVERTEX_z]	; [5]	z	y	x

	fmat	fmul,2,i			; [6]	z	y	x
	fxch	st(2)				; 	x	y	z

	fmat	fadd,3,i			; [7]	x	y	z
	endm
		
	procstart	RLDDITransformUnclippedLoop,%xfrmName

;
; Set up equates for arguments and automatic storage
;
        beginargs
        saveregs <ebp,esi,edi,ebx,ecx>
        regargs <x_offset, y_offset, count, vout>
	defargs	<vin, m, in_size, out_size, z_scale, z_offset>
	defargs	<minx, maxx, miny, maxy>
        endargs

; Ensure arguments are accessible from the stack, to free the registers

        ifndef      STACK_CALL
		mov     [esp + x_offset], eax
		mov     [esp + y_offset], edx
		mov     [esp + count], ebx
		mov     [esp + vout], ecx
        endif

	mov     ebx,[esp + count]
	test	ebx,ebx
	je	alldone

	;{ Pick up old extents

	mov	esi,[esp + minx]
	mov	edi,[esp + miny]

	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]
	fadd	[_g_dSnap + (16 * 8)]

	mov	esi,[esp + maxx]
	mov	edi,[esp + maxy]
	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]		; maxy maxx miny minx
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(3)				; minx maxx miny maxy

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	eax,dword ptr [tx]
	mov	ebx,dword ptr [ty]

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	ecx,dword ptr [tx]
	mov	edx,dword ptr [ty]
	;}

	mov	esi,[esp + vin]
	mov     edi,[esp + vout]

	mov	ebp,[esp + m]

	;	eax	ebx	ecx	edx
	;	minx	maxx	miny	maxy

	; Need to do first loop iteration
	column	0,0
	fadd			; x'+y' z' x y z
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	fadd			; x'+y' z' tx x y z
	jmp	smaxy

transloop:
	column	0,0		; 2 cycle wait here
	 cmp	eax,dword ptr [tx]
	 jg	setminx
	
sminx:	fadd			; x'+y' z' x y z
	 cmp	ebx,dword ptr [tx]
	 jl	setmaxx
	
smaxx:	fadd			; tx
	
	column	1,1		;	x'	y'	z'	x
	 cmp	ecx,dword ptr [ty]
	 jg	setminy
	
sminy:	fadd			;	x'+y'	z'	tx
	 cmp	edx,dword ptr [ty]
	 jl	setmaxy
	
smaxy:	fadd			; ty tx

	column	2,2
	 push	eax
	 push	ebx
	 mov	eax,[esi + D3DLVERTEX_color]
	 mov	ebx,[esi + D3DLVERTEX_specular]
	fadd
	 mov	[edi + D3DTLVERTEX_color],eax
	 mov	[edi + D3DTLVERTEX_specular],ebx
	 mov	eax,[esi + D3DVERTEX_tu]
	 mov	ebx,[esi + D3DVERTEX_tv]
	fadd			; tz ty tx
	 mov	[edi + D3DTLVERTEX_tu],eax
	 mov	[edi + D3DTLVERTEX_tv],ebx
	
if GEN_XFRM
	column	3,3
	fadd
	fadd			; tw tz ty tx
endif

	fld	[_g_fOne]
	fdiv	st,st(1)	; 1/tw (tw) tz ty tx
	
if GEN_XFRM
	fxch	st(1)
	FDROP
endif

	; Do the cache read here, plus anything else?
	cmp	dword ptr [esp + count + 8],1
	je	dontscan
	mov	eax,[esi + 32]
	mov	ebx,[edi + 32]
dontscan:
	pop	ebx
	pop	eax

	fxch	st(3)		; tx tz ty 1/tz

	fmul	st,st(3)	; tx/w tz ty 1/tz
	fxch	st(2)		; ty tz tx/w 1/tz

	fmul	st,st(3)	; ty/w tz tx/w 1/tz
	fxch	st(2)		; tx/w tz ty/w 1/tz

	fadd	dword ptr [esp + x_offset]
	fxch	st(1)		; tz sx ty/w 1/tz
	
if GEN_XFRM eq 0
	fmul	dword ptr [esp + z_scale]
endif
	fxch	st(2)		; ty/w sx tz 1/tz
	fsubr	dword ptr [esp + y_offset]
	fxch	st(2)		; tz sx sy 1/tz
if GEN_XFRM eq 0
	fadd	dword ptr [esp + z_offset]
endif
	fxch	st(2)		; sy sx sz 1/tz

	fst	dword ptr [edi + D3DTLVERTEX_sy]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)
	fst	dword ptr [edi + D3DTLVERTEX_sx]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)

	fstp	qword ptr [ty]
	fstp	qword ptr [tx]	; sz 1/tz

	fmul	st,st(1)
	fxch	st(1)

	fstp	dword ptr [edi + D3DTLVERTEX_rhw]

	fstp	dword ptr [edi + D3DTLVERTEX_sz]

	add	edi,32
	add	esi,32

	dec	dword ptr [esp + count]
	jnz	transloop

	cmp	eax,dword ptr [tx]
	jl	e1
	mov	eax,dword ptr [tx]
e1:	cmp	ebx,dword ptr [tx]
	jg	e2
	mov	ebx,dword ptr [tx]
e2:	cmp	ecx,dword ptr [ty]
	jl	e3
	mov	ecx,dword ptr [ty]
e3:	cmp	edx,dword ptr [ty]
	jg	e4
	mov	edx,dword ptr [ty]
e4:

	mov	dword ptr [tx],eax
	mov	dword ptr [ty],ecx
	mov	edi,[esp + minx]
	mov	esi,[esp + miny]
	fld	[tx]
	fld	[ty]			;	c	a
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	a	c
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	c	a
	; XXX fp slot
	fstp	dword ptr [esi]		;	a
	fstp	dword ptr [edi]		;

	mov	dword ptr [tx],ebx
	mov	dword ptr [ty],edx
	mov	edi,[esp + maxx]
	mov	esi,[esp + maxy]
	fld	[tx]
	fld	[ty]			;	c	a
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	a	c
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	c	a
	; XXX fp slot
	fstp	dword ptr [esi]		;	a
	fstp	dword ptr [edi]		;

alldone:
	add     esp, vars
	pop	ecx
	pop	ebx
	pop     edi
	pop     esi
	pop     ebp

        return

setminx:
	mov	eax,dword ptr [tx]
	jmp	sminx
setmaxx:
	mov	ebx,dword ptr [tx]
	jmp	smaxx
setminy:
	mov	ecx,dword ptr [ty]
	jmp	sminy
setmaxy:
	mov	edx,dword ptr [ty]
	jmp	smaxy
	
	procend	RLDDITransformUnclippedLoop,%xfrmName


cpick	macro	dst,c0,c1			; NO CARRY	CARRY
	sbb	dst,dst				; 0		~0
	and	dst,c0 xor c1			; 0		c0^c1
	xor	dst,c0				; c0		c1
	endm

;************************************************************************

		
	procstart	RLDDITransformClippedLoop,%xfrmName
		

;
; Set up equates for arguments and automatic storage
;
        beginargs
        saveregs <ebp,esi,edi,ebx,ecx>
        regargs <x_offset, y_offset, count, vout>
	defargs	<vin, hout, m, in_size, out_size, z_scale, z_offset>
	defargs	<x_bound, y_bound, r_scale_x, r_scale_y>
	defargs	<minx, maxx, miny, maxy>
	defargs	<clip_intersection, clip_union>
        endargs

; Ensure arguments are accessible from the stack, to free the registers

        ifndef      STACK_CALL
		mov     [esp + x_offset], eax
		mov     [esp + y_offset], edx
		mov     [esp + count], ebx
		mov     [esp + vout], ecx
        else
		mov     ebx,[esp + count]
		mov     ecx,[esp + vout]
        endif

	fldpi

	test	ebx,ebx
	je	alldone

	;{ Pick up old extents

	mov	esi,[esp + minx]
	mov	edi,[esp + miny]

	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]
	fadd	[_g_dSnap + (16 * 8)]

	mov	esi,[esp + maxx]
	mov	edi,[esp + maxy]
	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]		; maxy maxx miny minx
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(3)				; minx maxx miny maxy

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	eax,dword ptr [tx]
	mov	ebx,dword ptr [ty]

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	ecx,dword ptr [tx]
	mov	edx,dword ptr [ty]
	;}

	mov	esi,[esp + vin]
	mov	ebp,[esp + m]
	mov	edi,[esp + vout]

	; Need to do first loop iteration

	column	0,0		; 2 cycle wait here
	fadd			; x'+y' z' x y z
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	fadd			; x'+y' z' tx x y z
	jmp	smaxy

transloop:
	column	0,0		; 2 cycle wait here
	 cmp	eax,dword ptr [tx]
	 jg	setminx
	
sminx:	fadd			; x'+y' z'
	 cmp	ebx,dword ptr [tx]
	 jl	setmaxx
	
smaxx:	fadd			; x'+y'+z'
	
	column	1,1		; 2 cycle wait here
	 cmp	ecx,dword ptr [ty]
	 jg	setminy
	
sminy:	fadd			; x'+y' z'
	 cmp	edx,dword ptr [ty]
	 jl	setmaxy
	
smaxy:	fadd			; ty tx

	column	2,2
	 push	eax
	 push	ebx
	 mov	eax,[esi + D3DLVERTEX_color]
	 mov	ebx,[esi + D3DLVERTEX_specular]
	fadd
	 mov	[edi + D3DTLVERTEX_color],eax
	 mov	[edi + D3DTLVERTEX_specular],ebx
	 mov	eax,[esi + D3DVERTEX_tu]
	 mov	ebx,[esi + D3DVERTEX_tv]
	fadd			; tz ty tx
	 mov	[edi + D3DTLVERTEX_tu],eax
	 mov	[edi + D3DTLVERTEX_tv],ebx
	
if GEN_XFRM
	column	3,3
	fadd
	fadd			; tw tz ty tx
endif

	; Now set up the clip flags in ebp
	xor	ebp,ebp
	fld	dword ptr [esp + 8 + x_bound]
	fmul	st,st(1)	; tmp (tw) tz ty tx
	fcom	st(3+GEN_XFRM)
	fnstsw	ax
	sahf
	ja	x1		; Skip this if (tmp > tx)
	or	ebp,D3DCLIP_RIGHT
x1:	fchs			; -tmp (tw) tz ty tx
	fcomp	st(3+GEN_XFRM)	; (tw) tz ty tx
	fnstsw	ax
	sahf
	jbe	xpasses		; Skip this if (-tmp <= tx)
	or	ebp,D3DCLIP_LEFT
xpasses:
	fld	dword ptr [esp + 8 + y_bound]
	fmul	st,st(1)	; tmp (tw) tz ty tx
	fcom	st(2+GEN_XFRM)
	fnstsw	ax
	sahf
	ja	y1		; Skip this if (tmp > ty)
	or	ebp,D3DCLIP_TOP
y1:	fchs			; -tmp (tw) tz ty tx
	fcomp	st(2+GEN_XFRM)
	fnstsw	ax
	sahf
	jbe	ypasses		; Skip this if (-tmp <= ty)
	or	ebp,D3DCLIP_BOTTOM
ypasses:
	fst	[ty]		; ty will hold tw for a while...
	
	; if GEN_XFRM eq 0 then tw == tz
	; if GEN_XFRM eq 1 then tw != tz in general, so we
	; calculate a true 1/tw and then drop the extra tw
	; off the FP stack

	fld	[_g_fOne]
	fdiv	st,st(1)	; 1/tw (tw) tz ty tx

if GEN_XFRM
	fxch	st(1)
	FDROP
endif

	; Do the cache read here, plus anything else?
	cmp	dword ptr [esp + count],1
	je	dontscan
	mov	eax,[esp + in_size + 8]
	mov	ebx,[esp + out_size + 8]
	mov	eax,[esi + eax]
	mov	ebx,[edi + ebx]
dontscan:
	pop	ebx
	pop	eax

	mov	[esp + vout],edi		
	mov	edi,[esp + hout]
				; 1/tw tz ty tx
	fxch	st(3)		; tx tz ty 1/tw

	fld	dword ptr [esp + r_scale_x]
	fmul	st,st(1)	; hx tx tz ty 1/tw
	fld	dword ptr [esp + r_scale_y]
	fmul	st,st(4)	; hy hx tx tz ty 1/tw
	fxch	st(1)		; hx hy tx tz ty 1/tw

	fstp	dword ptr [edi + D3DHVERTEX_hx]
	fstp	dword ptr [edi + D3DHVERTEX_hy]

	fmul	st,st(3)	; tx/w tz ty 1/tw
	fxch	st(2)		; ty tz tx/w 1/tw

	fmul	st,st(3)	; ty/w tz tx/w 1/tw
	fxch	st(2)		; tx/w tz ty/w 1/tw

	fadd	dword ptr [esp + x_offset]
	fxch	st(1)		; tz sx ty/w 1/tw
	
if GEN_XFRM eq 0
	fmul	dword ptr [esp + z_scale]
endif
	fxch	st(2)		; ty/w sx tz 1/tw
	fsubr	dword ptr [esp + y_offset]
	fxch	st(2)		; tz sx sy 1/tw
if GEN_XFRM eq 0
	fadd	dword ptr [esp + z_offset]
endif

	; Last clipping flags
	fst	dword ptr [edi + D3DHVERTEX_hz]
	test	byte ptr [edi + D3DHVERTEX_hz + 3],80h
	jz	nofront
	or	ebp,D3DCLIP_FRONT
nofront:
	fcom	[ty]
	push	eax		;[
	fnstsw	ax
	sahf
	pop	eax		;]
	jb	noback
	or	ebp,D3DCLIP_BACK
noback:
	mov	[edi + D3DHVERTEX_dwFlags],ebp
	mov	edi,[esp + clip_intersection]
	and	[edi],ebp
	mov	edi,[esp + clip_union]
	or	[edi],ebp

	test	ebp,ebp
	jnz	outofplay

	mov	edi,[esp + vout]

	fxch	st(2)		; sy sx sz 1/tz

	fst	dword ptr [edi + D3DTLVERTEX_sy]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)
	fst	dword ptr [edi + D3DTLVERTEX_sx]
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)

	fstp	qword ptr [ty]
	fstp	qword ptr [tx]	; sz 1/tz y

	fmul	st,st(1)

	fstp	dword ptr [edi + D3DTLVERTEX_sz]
				; 1/tz y

	fstp	dword ptr [edi + D3DTLVERTEX_rhw]
				; y

	add	esi,[esp + in_size]

	add	edi,[esp + out_size]
	mov	ebp,[esp + hout]
	add	ebp,D3DHVERTEX_size
	mov	[esp + hout],ebp
	mov	ebp,[esp + m]

	dec	dword ptr [esp + count]
	jnz	transloop
	jmp	cleanup

outofplay:				; tz sx sy 1/tz
	FDROP				; sx sy 1/tz
	FDROP				; sy 1/tz y
	FDROP				; 1/tz y
	mov	edi,[esp + vout]
	fstp	dword ptr [edi + D3DTLVERTEX_rhw]	

	add	esi,[esp + in_size]
	add	edi,[esp + out_size]
	mov	ebp,[esp + hout]
	add	ebp,D3DHVERTEX_size
	mov	[esp + hout],ebp

	mov	ebp,[esp + m]

	dec	dword ptr [esp + count]
	jz	calcminmax

	column	0,0		; 2 cycle wait here
	
	fadd			; x'+y' z' x y z
	
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	
	fadd			; x'+y' z' x y z
	
	jmp	smaxy


cleanup:
	cmp	eax,dword ptr [tx]
	jl	e1
	mov	eax,dword ptr [tx]
e1:	cmp	ebx,dword ptr [tx]
	jg	e2
	mov	ebx,dword ptr [tx]
e2:	cmp	ecx,dword ptr [ty]
	jl	e3
	mov	ecx,dword ptr [ty]
e3:	cmp	edx,dword ptr [ty]
	jg	e4
	mov	edx,dword ptr [ty]
e4:

calcminmax:
	mov	dword ptr [tx],eax
	mov	dword ptr [ty],ecx
	fild	dword ptr [tx]
	fmul	dword ptr [_g_fOoTwoPow16]
	fild	dword ptr [ty]
	fmul	dword ptr [_g_fOoTwoPow16]
	fxch	st(1)				; x y
	mov	edi,[esp + minx]
	mov	esi,[esp + miny]
	fstp	dword ptr [edi]
	fstp	dword ptr [esi]

	mov	dword ptr [tx],ebx
	mov	dword ptr [ty],edx
	fild	dword ptr [tx]
	fmul	dword ptr [_g_fOoTwoPow16]
	fild	dword ptr [ty]
	fmul	dword ptr [_g_fOoTwoPow16]
	fxch	st(1)				; x y
	mov	edi,[esp + maxx]
	mov	esi,[esp + maxy]
	fstp	dword ptr [edi]
	fstp	dword ptr [esi]

alldone:
	add     esp, vars
	pop	ecx
	pop	ebx
	pop     edi
	pop     esi
	pop     ebp

	FDROP

        return

setminx:
	mov	eax,dword ptr [tx]
	jmp	sminx
setmaxx:
	mov	ebx,dword ptr [tx]
	jmp	smaxx
setminy:
	mov	ecx,dword ptr [ty]
	jmp	sminy
setmaxy:
	mov	edx,dword ptr [ty]
	jmp	smaxy
	
	procend	RLDDITransformClippedLoop,%xfrmName

		
if GEN_XFRM
_Rdtsc	proc
	db	0fh,31h
	shrd	eax,edx,10
	ret
	
_Rdtsc	endp
endif

_TEXT           ENDS

        extrn	_g_fOne:dword
        extrn	_g_fOoTwoPow16:dword
	extrn	_g_dSnap:qword

                END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\i386\macros.asm ===
; $Id: macros.asm,v 1.4 1995/09/27 09:26:54 james Exp $
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994
; Version 1.0beta2
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
;
;the 8086 macros...
;the general purpose macros just so you can write code more easily

	ifdef INTEL
func	macro	name
	public	name
name:
	endm
	else
func	macro	name
	public	_&name
name:			;lay down both labels so I have one I know will
_&name:			;always be available for asm to call.
	endm
	endif

push_all	macro
	irp	z,<edi,esi,edx,ecx,ebx,eax>
	push	z
	endm
	endm

pop_all		macro
	irp	z,<eax,ebx,ecx,edx,esi,edi>
	pop	z
	endm
	endm

push_m	macro	list
	irp	z,<list>
	push	z
	endm
	endm
	
pop_m	macro	list
	irp	z,<list>
	pop	z
	endm
	endm

byte_eax	equ	al
byte_ebx	equ	bl
byte_ecx	equ	cl
byte_edx	equ	dl

word_eax	equ	ax
word_ebx	equ	bx
word_ecx	equ	cx
word_edx	equ	dx
word_edi	equ	di
word_esi	equ	si
word_ebp	equ	bp

; Divide eax by divisor, an 8 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div8	macro	divisor
	local	divide, nodivide
	cdq
	xor	edx, eax
	sar	edx, 017H
	cmp	divisor, edx
	jg	divide
	sar	eax, 1fH
	xor	eax, 7fffffffH
	jmp	nodivide
divide:
	mov	edx, eax
	sar	edx, 018h
	shl	eax, 008h
	idiv	divisor
nodivide:
	endm

; Divide eax by divisor, an 16 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div16	macro	divisor
	local	divide, nodivide
	cdq
	xor	edx, eax
	sar	edx, 0fH
	cmp	divisor, edx
	jg	divide
	sar	eax, 1fH
	xor	eax, 7fffffffH
	jmp	nodivide
divide:
	mov	edx, eax
	sar	edx, 010h
	shl	eax, 010h
	idiv	divisor
nodivide:
	endm

ES_PREFIX	macro
    ifndef	NT
	db	26h
    endif
	endm

beginargs macro
	align	4
stack	=	4	;return address
vars	=	0	;no vars yet
args	=	0	;no args yet
	endm

endargs	macro
	sub	esp, vars
	endm

savereg	macro	arg
	push	arg
stack	=	stack + 4
	endm

saveregs macro	arglist
	irp	z,<arglist>
	savereg	z
	endm
	endm

defvar  macro	name
name	=	vars
vars	=	vars + 4
stack	=	stack + 4
	endm

defvars	macro	arglist
	irp	z,<arglist>
	defvar	z
	endm
	endm

defarg	macro	name
name	=	stack + args
args	=	args + 4
	endm

defargs	macro	arglist
	irp	z,<arglist>
	defarg	z
	endm
	endm

regarg	macro	name
	ifdef	STACK_CALL
	defarg	name
	else
	defvar	name
	endif
	endm

regargs	macro	arglist
	irp	z,<arglist>
	regarg	z
	endm
	endm

return	macro
	ifdef	STACK_CALL
	ret
	else
	ret	args
	endif
	endm

    ifdef	BCC		;{

beginproc macro	prefix,GF,Te,Tr,name	;{
	align	4
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the beginproc macro"
	endif
	if DEPTH eq 0
prefix&name	equ	_&prefix&GF&Tr&Te&name
	else
	  if DEPTH eq 8
prefix&name	equ	_&prefix&8&GF&Tr&Te&name
	  else
prefix&name	equ	_&prefix&16&GF&Tr&Te&name
	  endif
	endif
	public	prefix&name
prefix&name proc
	endm			;}

    else			;} ifndef BCC {

beginproc macro	prefix,GF,Z,Te,Tr,name	;{
	align	4
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the beginproc macro"
	endif
	ifdef	STACK_CALL	;{
	if DEPTH eq 0
prefix&name	equ	prefix&GF&Z&Tr&Te&name
	else
	    if DEPTH eq 8
prefix&name	equ	prefix&8_&GF&Z&Tr&Te&name
	    else
prefix&name	equ	prefix&16_&GF&Z&Tr&Te&name
	    endif
	endif
	else			;} else {
	if DEPTH eq 0
prefix&name	equ	prefix&GF&Tr&Te&name&_
	else
	    if DEPTH eq 8
prefix&name	equ	prefix&8&GF&Tr&Te&name&_
	    else
prefix&name	equ	prefix&16&GF&Tr&Te&name&_
	    endif
	endif
	endif			;}
	public	prefix&name
prefix&name proc
	endm			;}
    endif		;}

    ifdef	BCC	;{
endproc	macro prefix,name	;{
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the endproc macro"
	endif
	if	DEPTH eq 8
_&prefix&name endp
	else
_&prefix&name endp
	endif
	endm			;}

    else		;} ifndef BCC {

endproc	macro prefix,GF,Z,Te,Tr,name	;{
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the endproc macro"
	endif
	ifdef	STACK_CALL
	    if	DEPTH eq 0
prefix&GF&Tr&Te&name endp
	    else
	    if	DEPTH eq 8
prefix&8_&GF&Z&Tr&Te&name endp
	    else
prefix&16_&GF&Z&Tr&Te&name endp
	    endif
	    endif
	else
	    if	DEPTH eq 0
prefix&GF&Tr&Te&name&_ endp
	    else
	    if	DEPTH eq 8
prefix&8&GF&Tr&Te&name&_ endp
	    else
prefix&16&GF&Tr&Te&name&_ endp
	    endif
	    endif
	endif
	endm			;}

    endif		;}

; ************************************************************************
itoval	macro	reg
	shl	reg,10h
	endm

FDUP	macro
	fld	st(0)
	endm

FDROP	macro
	fstp	st(0)
	endm

FRECIPROCAL	macro
	fld1
	fdivrp	st(1),st
	endm

; MASM 6.11d used in NT has native support for fcomi so this macro can't be
; called fcomi

MACRO_FCOMI macro v
	fcom	v
	fnstsw	ax
	sahf
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\i386\_ftransg.asm ===
GEN_XFRM = 1
include ftrans.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\i386\_ftransa.asm ===
GEN_XFRM = 0
include ftrans.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\clip.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip by a frustum side
 *
 * The following symbol should be defined before included this file:
 * __CLIP_NAME 	    - name for a function to clip triangles
 * __CLIP_LINE_NAME - name for a function to clip lines
 * __CLIP_W         - if this functions are for Coord <= W. Otherwise they 
 *                    are for 0 < Coord
 * __CLIP_COORD     - should be hx, hy or hz
 * __CLIP_FLAG      - clipping flag to set
 * __CLIP_GUARDBAND - defined when clipping by guardband window
 * __CLIP_SIGN      - "-" if clipping by left or bottom sides of guard band 
 *                    window
 * __CLIP_GBCOEF    - coefficient to multiply W when clipping by guard band
 *                    window
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
//
// Clipping for triangle
//
// Returns number of vertices in the clipped triangle
//
int 
__CLIP_NAME(D3DFE_PROCESSVERTICES *pv,
            ClipVertex **inv, 
            ClipVertex **outv,
            int count,
            int interpolate)
{
    int i;
    int out_count = 0;
    ClipVertex *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
#ifdef __CLIP_GUARDBAND
    prev_inside = __CLIP_SIGN(prev->hw * pv->vcache.__CLIP_GBCOEF - 
                              prev->__CLIP_COORD);
#else
#ifdef __CLIP_W
    prev_inside = prev->hw - prev->__CLIP_COORD;
#else
    prev_inside = prev->__CLIP_COORD;
#endif
#endif
    for (i = count; i; i--) 
    {
#ifdef __CLIP_GUARDBAND
        curr_inside = __CLIP_SIGN(curr->hw * pv->vcache.__CLIP_GBCOEF - 
                                  curr->__CLIP_COORD);
#else
#ifdef __CLIP_W
        curr_inside = curr->hw - curr->__CLIP_COORD;
#else
        curr_inside = curr->__CLIP_COORD;
#endif
#endif
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside)) 
        { // first point is outside
            if (FLOAT_GEZ(curr_inside)) 
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv,
                            outv[out_count],
                            curr, prev, 
                            (prev->clip & CLIPPED_ENABLE) | __CLIP_FLAG,
                            interpolate,
                            curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } else 
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside)) 
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv, 
                            outv[out_count],
                            prev, curr,
                            __CLIP_FLAG,
                            interpolate,
                            prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clipping for lines
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int __CLIP_LINE_NAME(D3DFE_PROCESSVERTICES *pv, ClipTriangle *line, 
                     int interpolate)
{
    D3DVALUE in1, in2;
    ClipVertex outv;
#ifdef __CLIP_GUARDBAND
    in1 = __CLIP_SIGN(line->v[0]->hw * pv->vcache.__CLIP_GBCOEF - 
                      line->v[0]->__CLIP_COORD);
    in2 = __CLIP_SIGN(line->v[1]->hw * pv->vcache.__CLIP_GBCOEF - 
                      line->v[1]->__CLIP_COORD);
#else
#ifdef __CLIP_W
    in1 = line->v[0]->hw - line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->hw - line->v[1]->__CLIP_COORD;
#else
    in1 = line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->__CLIP_COORD;
#endif
#endif
    if (in1 < 0) 
    {
        if (in2 < 0) 
            return 1;
        Interpolate(pv, &outv, line->v[0], line->v[1], 
                    __CLIP_FLAG, interpolate, in1, in1 - in2);
        *line->v[0] = outv;
    } 
    else 
    {
        if (in2 < 0) 
        {
            Interpolate(pv,  &outv, line->v[0], line->v[1],
                        __CLIP_FLAG, interpolate, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}

#undef __CLIP_FLAG
#undef __CLIP_COORD
#undef __CLIP_NAME
#undef __CLIP_LINE_NAME
#undef __CLIP_W
#undef __CLIP_SIGN
#undef __CLIP_GBCOEF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\win9x\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#



GENSYMFLAGS = -DWIN95 
386_ASSEMBLER_NAME=ml611d
RASTROOT= $(D3DDX6)\rast
!include $(RASTROOT)\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\clipfunc.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipfunc.h
 *  Content:    Clipper functions
 *
 ***************************************************************************/

#ifndef _CLIPFUNC_H_
#define _CLIPFUNC_H_

#include "clipper.h"

int SetInterpolationFlags(D3DFE_PROCESSVERTICES *pv);

int ClipSingleLine(D3DFE_PROCESSVERTICES *pv,
                   ClipTriangle *line,
                   D3DRECTV *extent,
                   int interpolate);

HRESULT ProcessClippedPoints(D3DFE_PROCESSVERTICES*);
HRESULT ProcessClippedTriangleList (D3DFE_PROCESSVERTICES*);
HRESULT ProcessClippedTriangleStrip(D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedTriangleFan  (D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedLine(D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedTriangleStrip(D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedTriangleFan  (D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedTriangleList (D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedLine(D3DFE_PROCESSVERTICES *pv);
DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv);

#endif // _CLIPFUNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\clipper.h ===
/*============================  ==============================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipper.h
 *  Content:    Clipper definitions
 *
 ***************************************************************************/
#ifndef _CLIPPER_H_
#define _CLIPPER_H_

#define INTERPOLATE_COLOR       (1<< 0)
#define INTERPOLATE_SPECULAR    (1<< 1)
#define INTERPOLATE_TEXTUREL    (1<< 2) // legacy-related texture
#define INTERPOLATE_RCOLOR      (1<< 3)
#define INTERPOLATE_TEXTURE3    (1<< 4) //  interpolate Texture3

#define CLIPPED_LEFT    (D3DCLIP_GEN5 << 1)
#define CLIPPED_RIGHT   (D3DCLIP_GEN5 << 2)
#define CLIPPED_TOP     (D3DCLIP_GEN5 << 3)
#define CLIPPED_BOTTOM  (D3DCLIP_GEN5 << 4)
#define CLIPPED_FRONT   (D3DCLIP_GEN5 << 5)
#define CLIPPED_BACK    (D3DCLIP_GEN5 << 6)

#define CLIPPED_ENABLE  (D3DCLIP_GEN5 << 7) /* wireframe enable flag */

#define CLIPPED_ALL (CLIPPED_LEFT|CLIPPED_RIGHT     \
             |CLIPPED_TOP|CLIPPED_BOTTOM            \
             |CLIPPED_FRONT|CLIPPED_BACK)
//---------------------------------------------------------------------
// Guard band clipping bits
//
// A guard bit is set when a point is out of guard band
// Guard bits should be cleared before a call to clip a triangle, because
// they are the same as CLIPPED_... bits
//
// Example of clipping bits setting for X coordinate:
//
// if -w < x < w           no clipping bit is set
// if -w*ax1 < x <= -w     D3DCLIP_LEFT bit is set
// if x < -w*ax1           __D3DCLIPGB_LEFT bit is set
//
#define __D3DCLIPGB_LEFT    (D3DCLIP_GEN5 << 1)
#define __D3DCLIPGB_RIGHT   (D3DCLIP_GEN5 << 2)
#define __D3DCLIPGB_TOP     (D3DCLIP_GEN5 << 3)
#define __D3DCLIPGB_BOTTOM  (D3DCLIP_GEN5 << 4)
#define __D3DCLIPGB_ALL (__D3DCLIPGB_LEFT | __D3DCLIPGB_RIGHT | \
                         __D3DCLIPGB_TOP | __D3DCLIPGB_BOTTOM)

// If only these bits are set, then this point is inside the guard band
//
#define __D3DCLIP_INGUARDBAND (D3DCLIP_LEFT | D3DCLIP_RIGHT | \
                               D3DCLIP_TOP  | D3DCLIP_BOTTOM)

//---------------------------------------------------------------------
// Bit numbers for each clip flag
//
#define D3DCLIP_LEFTBIT     1
#define D3DCLIP_RIGHTBIT    2
#define D3DCLIP_TOPBIT      3
#define D3DCLIP_BOTTOMBIT   4
#define D3DCLIP_FRONTBIT    5
#define D3DCLIP_BACKBIT     6
#define D3DCLIPGB_LEFTBIT   13
#define D3DCLIPGB_RIGHTBIT  14
#define D3DCLIPGB_TOPBIT    15
#define D3DCLIPGB_BOTTOMBIT 16

//---------------------------------------------------------------------
// Make clip vertex from D3D vertex
//
// device - DIRECT3DDEVICEI *
// pp1    - clipVertex
// p1     - TL vertex
// clipMask is set to the guard band bits or 0xFFFFFFFFF
//
inline void MAKE_CLIP_VERTEX(D3DFE_PROCESSVERTICES *pv, ClipVertex& pp1, 
                             D3DTLVERTEX* p1, DWORD clipFlag, 
                             BOOL transformed, DWORD clipMaskOffScreen)
{
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;
    if (transformed || !(clipFlag & clipMaskOffScreen))         
    {                                                           
        pp1.sx  = p1->sx;                                       
        pp1.sy  = p1->sy;                                       
        pp1.sz  = p1->sz;                                       
        pp1.hw  = 1.0f / p1->rhw;                               
        pp1.hx  = (pp1.sx - VPORT.offsetX) * pp1.hw *           
                  VPORT.scaleXi;                                
        pp1.hy  = (pp1.sy - VPORT.offsetY) * pp1.hw *           
                  VPORT.scaleYi;                                
        pp1.hz  = pp1.sz * pp1.hw;                              
    }                                                           
    else                                                        
    {                                                           
        pp1.hx = p1->sx;                                        
        pp1.hy = p1->sy;                                        
        pp1.hz = p1->sz;                                        
        pp1.hw = p1->rhw;                                       
    }                                                           
    pp1.color   = p1->color;                                    
    pp1.specular= p1->specular;                                 
    pp1.tex[0].u  = p1->tu;                                     
    pp1.tex[0].v  = p1->tv;                                     
    pp1.clip = clipFlag & D3DSTATUS_CLIPUNIONALL;
}
//---------------------------------------------------------------------
// Make TL vertex from clip vertex
//
// device - DIRECT3DDEVICEI *
// in    - clipVertex
// out   - TL vertex
//
inline void MAKE_TL_VERTEX(D3DTLVERTEX* out, ClipVertex* in)
{
    (out)->sx  = (in)->sx;              
    (out)->sy  = (in)->sy;              
    (out)->sz  = (in)->sz;              
    (out)->rhw = D3DVAL(1)/(in)->hw;    
    (out)->color   = (in)->color;       
    (out)->specular= (in)->specular;    
    (out)->tu   = (in)->tex[0].u;       
    (out)->tv   = (in)->tex[0].v;       
}
//---------------------------------------------------------------------
// Make clip vertex from D3D vertex
//
// device - DIRECT3DDEVICEI *
// pp1    - clipVertex
// p1     - TL vertex
//
inline void MAKE_CLIP_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, ClipVertex& pp1, BYTE* p1,                   
                            DWORD clipFlag, BOOL transformed, DWORD clipMaskOffScreen)              
{                                                               
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;
    BYTE *v = (BYTE*)p1;                                               
    if (transformed || !(clipFlag & clipMaskOffScreen))         
    {                                                           
        pp1.sx  = ((D3DVALUE*)v)[0];                            
        pp1.sy  = ((D3DVALUE*)v)[1];                            
        pp1.sz  = ((D3DVALUE*)v)[2];                            
        pp1.hw  = 1.0f / ((D3DVALUE*)v)[3];                     
        pp1.hx  = (pp1.sx - VPORT.offsetX) * pp1.hw *           
                  VPORT.scaleXi;                                
        pp1.hy  = (pp1.sy - VPORT.offsetY) * pp1.hw *           
                  VPORT.scaleYi;                                
        pp1.hz  = pp1.sz * pp1.hw;                              
    }                                                           
    else                                                        
    {                                                           
        pp1.hx = ((D3DVALUE*)v)[0];                             
        pp1.hy = ((D3DVALUE*)v)[1];                             
        pp1.hz = ((D3DVALUE*)v)[2];                             
        pp1.hw = ((D3DVALUE*)v)[3];                             
    }                                                           
    v += sizeof(D3DVALUE) * 4;                                  
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)                   
    {                                                           
        pp1.color   = *(DWORD*)v;                               
        v += sizeof(D3DVALUE);                                  
                                                                
    }                                                           
    if (pv->dwVIDOut & D3DFVF_SPECULAR)                  
    {                                                           
        pp1.specular= *(DWORD*)v;                               
        v += sizeof(DWORD);                                     
    }                                                           
    for (DWORD ii=0; ii < pv->nTexCoord; ii++)           
    {                                                           
        pp1.tex[ii].u  = *(D3DVALUE*)v;
        v += sizeof(D3DVALUE);                                  
        pp1.tex[ii].v  = *(D3DVALUE*)v;                         
        v += sizeof(D3DVALUE);                                  
    }                                                           
    pp1.clip = clipFlag; // & D3DSTATUS_CLIPUNIONALL;               
}
//---------------------------------------------------------------------
// Make TL vertex from clip vertex
//
// device - DIRECT3DDEVICEI *
// in    - clipVertex
// out   - TL vertex
//
inline void MAKE_TL_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, BYTE* out, ClipVertex* in)
{                                               
    BYTE *v = out;                              
    ((D3DVALUE*)v)[0] = (in)->sx;               
    ((D3DVALUE*)v)[1] = (in)->sy;               
    ((D3DVALUE*)v)[2] = (in)->sz;               
    ((D3DVALUE*)v)[3] = D3DVAL(1)/(in)->hw;     
    v += sizeof(D3DVALUE)*4;                    
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)   
    {                                           
        *(DWORD*)v = (in)->color;               
        v += sizeof(DWORD);                     
    }                                           
    if (pv->dwVIDOut & D3DFVF_SPECULAR)  
    {                                           
        *(DWORD*)v = (in)->specular;            
        v += sizeof(DWORD);                     
    }                                           
    for (DWORD ii=0; ii < pv->nTexCoord; ii++)
    {                                           
        *(D3DVALUE*)v = (in)->tex[ii].u;        
        v += sizeof(D3DVALUE);                  
        *(D3DVALUE*)v = (in)->tex[ii].v;        
        v += sizeof(D3DVALUE);                  
    }                                           
}
#endif // _CLIPPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\clipprim.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip primitives
 *
 * The following symbol should be defined before included this file:
 * __PROCESS_LINE_NAME  - name for a function to clip triangles
 * __INDEX_PRIM         - name for a function to clip lines
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
#ifdef __INDEX_PRIM
#define __DRAW DRAW_INDEX_PRIM
#else
#define __DRAW DRAW_PRIM
#endif

//*********************************************************************
HRESULT __PROCESS_TRI_LIST_NAME(D3DFE_PROCESSVERTICES *pv)
{
    int vertexSize3;
    DWORD clipMaskOffScreen;                                
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    int         interpolate;                                
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    LPWORD      startVertex = pv->lpwIndices;
    LPWORD      index = pv->lpwIndices;
    DWORD       triangleSize;   // 3 for DrawPrimitives, 
                                // 4 for ExecuteBuffers (include wFlags)
    if (pv->dwFlags & D3DPV_INSIDEEXECUTE)
        triangleSize = 4;
    else
        triangleSize = 3;
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int         primitiveCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    interpolate = SetInterpolationFlags(pv);            
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    primitiveCount = 0;                                        
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)               
    {                                                       
        clipMaskOffScreen = ~__D3DCLIP_INGUARDBAND;         
    }                                                       
    else                                                    
    {                                                       
        clipMaskOffScreen = 0xFFFFFFFF;                     
    }

    vertexSize3 = vertexSize*3;
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        DWORD f1, f2, f3;     // vertex clip flags
#ifdef __INDEX_PRIM
        DWORD v1, v2, v3;
        v1 = index[0];
        v2 = index[1];
        v3 = index[2];
        f1 = clipCode[v1];
        f2 = clipCode[v2];
        f3 = clipCode[v3];
        // PSGP implementation should not implement INSIDEEXECUTE
        if (pv->dwFlags & D3DPV_INSIDEEXECUTE)
            // Offset to the current triangle in the execute buffer
            ((LPDIRECT3DDEVICEI)pv)->dwClipIns_offset = 
                (DWORD)((BYTE*)index - (BYTE*)((LPDIRECT3DDEVICEI)pv)->lpbClipIns_base);
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
        f3 = clipCode[2];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & clipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {// This tri does need clipping
            if (primitiveCount) 
            {   // first draw the ones that didn't need clipping
                DWORD vertexCount = primitiveCount*3;
                ret = __DRAW(pv, D3DPT_TRIANGLELIST, startVertex, 
                             vertexCount, primitiveCount);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                pv->dwVertexBase += vertexCount;
#endif
            }
            // reset count and start ptr
            primitiveCount = 0;
#ifdef __INDEX_PRIM
            startVertex = index + triangleSize;
#else
            pv->dwVertexBase += 3;
            D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
            startVertex = vertex + vertexSize3;
#endif
            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped
            if (!offFrustum) 
            {
                BYTE *p1;
                BYTE *p2;
                BYTE *p3;
#ifdef __INDEX_PRIM
                p1 = vertex + v1*vertexSize;
                p2 = vertex + v2*vertexSize;
                p3 = vertex + v3*vertexSize;
#else
                p1 = vertex;
                p2 = vertex + vertexSize;
                p3 = p2 + vertexSize;
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed, clipMaskOffScreen);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed, clipMaskOffScreen);
                MAKE_CLIP_VERTEX_FVF(pv, cv[2], p3, f3, vertexTransformed, clipMaskOffScreen);

#ifdef __INDEX_PRIM
                if (pv->dwFlags & D3DPV_INSIDEEXECUTE)
                    // Pass triangle flags for execute buffers
                    ret = Clip(pv, interpolate, cv, index[3]);
                else
#endif
                    ret = Clip(pv, interpolate, cv);
                if (ret) return ret;
            }
        } 
        else 
            primitiveCount++;
#ifdef __INDEX_PRIM
        index += triangleSize;
#else
        clipCode += 3;
        vertex += vertexSize3;
#endif
    }
    // draw final batch, if any
    if (primitiveCount) 
    {
        ret = __DRAW(pv, D3DPT_TRIANGLELIST, startVertex, 
                     primitiveCount*3, primitiveCount);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//------------------------------------------------------------------------------
HRESULT __PROCESS_TRI_STRIP_NAME(D3DFE_PROCESSVERTICES *pv)
{
    DWORD lastIndex;
    DWORD clipMaskOffScreen;                                
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    int         interpolate;                                
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    LPWORD       startVertex = pv->lpwIndices;                               
    LPWORD index = pv->lpwIndices;
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int           primitiveCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    interpolate = SetInterpolationFlags(pv);            
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    primitiveCount = 0;                                        
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)               
    {                                                       
        clipMaskOffScreen = ~__D3DCLIP_INGUARDBAND;         
    }                                                       
    else                                                    
    {                                                       
        clipMaskOffScreen = 0xFFFFFFFF;                     
    }

    lastIndex = pv->dwNumPrimitives;
    for (i=0; i < lastIndex; i++) 
    {
        DWORD f1, f2, f3;     // vertex clip flags
#ifdef __INDEX_PRIM
        DWORD v1, v2, v3;
        v1 = index[0];
        v2 = index[1];
        v3 = index[2];
        f1 = clipCode[v1];
        f2 = clipCode[v2];
        f3 = clipCode[v3];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
        f3 = clipCode[2];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & clipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (primitiveCount) 
            {   // first draw the ones that didn't need clipping
                ret = __DRAW(pv, D3DPT_TRIANGLESTRIP, startVertex, 
                             primitiveCount+2, primitiveCount);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                pv->dwVertexBase += primitiveCount;
#endif
            }
            // reset count and start ptr
            primitiveCount = 0;
#ifdef __INDEX_PRIM
            startVertex = &index[1];
#else
            pv->dwVertexBase++;
            D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
            startVertex = vertex + vertexSize;
#endif
            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p1;
                BYTE *p2;
                BYTE *p3;
#ifdef __INDEX_PRIM
                if (i & 1)
                { // For odd triangles we have to change orientation
                  // First vertex should remain the first, because it defines
                  // the color in FLAT shade mode
                    DWORD tmp = f2;
                    f2 = f3;
                    f3 = tmp;
                    p1 = vertex + v1*vertexSize;
                    p2 = vertex + v3*vertexSize;
                    p3 = vertex + v2*vertexSize;
                }
                else
                {
                    p1 = vertex + v1*vertexSize;
                    p2 = vertex + v2*vertexSize;
                    p3 = vertex + v3*vertexSize;
                }

#else
                p1 = vertex;
                if (i & 1)
                { // For odd triangles we have to change orientation
                    DWORD tmp = f2;
                    f2 = f3;
                    f3 = tmp;
                    p3 = vertex + vertexSize;
                    p2 = p3 + vertexSize;
                }
                else
                {
                    p2 = vertex + vertexSize;
                    p3 = p2 + vertexSize;
                }
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed, clipMaskOffScreen);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed, clipMaskOffScreen);
                MAKE_CLIP_VERTEX_FVF(pv, cv[2], p3, f3, vertexTransformed, clipMaskOffScreen);

                ret = Clip(pv, interpolate, cv);
                if (ret) return ret;
            }
        } 
        else 
        {
            if (primitiveCount == 0 && i & 1)
            { // Triangle strip can not start from an odd triangle
              // Because we use triangle fan, first vertex in the strip
              // should be the second in the fan. 
              // This vertex defines the color in FLAT shading case.
                BYTE tmp[__MAX_VERTEX_SIZE*3];
                BYTE *p = tmp;
#ifdef __INDEX_PRIM
                BYTE *saveVer = (BYTE*)pv->lpvOut;   
                DWORD numVer = pv->dwNumVertices;  
                memcpy (p, vertex + v2*vertexSize, vertexSize);
                p += vertexSize;
                memcpy (p, vertex + v1*vertexSize, vertexSize);
                p += vertexSize;
                memcpy (p, vertex + v3*vertexSize, vertexSize);
#else
                memcpy(p, vertex + vertexSize, vertexSize);
                p += vertexSize;
                memcpy(p, vertex, vertexSize);
                p += vertexSize;
                memcpy(p, vertex + vertexSize + vertexSize, vertexSize);
#endif
                pv->dwFlags |= D3DPV_CLIPPERPRIM | D3DPV_NONCLIPPED; // Mark this call as gen by clipper
                ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, tmp, 3, 1);
                pv->dwFlags &= ~(D3DPV_CLIPPERPRIM | D3DPV_NONCLIPPED);
                if (ret)
                    return ret;
                primitiveCount = 0;
#ifdef __INDEX_PRIM
                startVertex = &index[1];
                pv->lpvOut = saveVer;
                pv->dwNumVertices = numVer;
#else
                pv->dwVertexBase++;
                D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
                startVertex = vertex + vertexSize;
#endif
            }   
            else
                primitiveCount++;
        }
#ifdef __INDEX_PRIM
        index++;
#else
        clipCode++;
        vertex += vertexSize;
#endif
    }
    // draw final batch, if any
    if (primitiveCount) 
    {
        ret = __DRAW(pv, D3DPT_TRIANGLESTRIP, startVertex, 
                     primitiveCount+2, primitiveCount);
        if (ret)
            return ret;
#ifndef __INDEX_PRIM
        pv->dwVertexBase += primitiveCount;
#endif
    }
    return D3D_OK;
} 
//-----------------------------------------------------------------------------
// The same functions is used for line lists and line strips
//
HRESULT __PROCESS_LINE_NAME(D3DFE_PROCESSVERTICES *pv)
{
    DWORD nextLineOffset;       // How many vertices to skip, when going to 
                                // next primitive (1 for strips, 2 for lists)
    DWORD countAdd;             // Used to compute "real" number of vertices
                                // from the vertexCount
    D3DPRIMITIVETYPE primType;
    int numPrim = 0;
    DWORD clipMaskOffScreen;                                
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    int         interpolate;                                
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    LPWORD       startVertex = pv->lpwIndices;                               
    LPWORD index = pv->lpwIndices;                               
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int         vertexCount;    // Primitive count for line strips, 
                                // vertex count for line lists
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    interpolate = SetInterpolationFlags(pv);            
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)               
    {                                                       
        clipMaskOffScreen = ~__D3DCLIP_INGUARDBAND;         
    }                                                       
    else                                                    
    {                                                       
        clipMaskOffScreen = 0xFFFFFFFF;                     
    }

    primType = pv->primType;
    if (primType == D3DPT_LINESTRIP)
    {
        nextLineOffset = 1;
        countAdd = 1;
    }
    else
    {
        nextLineOffset = 2;
        countAdd = 0;
    }
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        WORD f1, f2;
#ifdef __INDEX_PRIM
        WORD v1, v2;
        v1 = index[0];
        v2 = index[1];
        f1 = clipCode[v1];
        f2 = clipCode[v2];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2) 
            offFrustum = TRUE;
        else
        if ((f1 | f2) & clipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {      // if this line does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                ret = __DRAW(pv, primType, startVertex, vertexCount+countAdd, numPrim);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                pv->dwVertexBase += vertexCount;
#endif
            }
            // reset count and start ptr
            vertexCount = 0;
            numPrim = 0;
#ifdef __INDEX_PRIM
            startVertex = &index[nextLineOffset];
#else
            pv->dwVertexBase += nextLineOffset;
            D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
            startVertex = vertex + nextLineOffset*vertexSize;
#endif

            // now deal with the single clipped line
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
#ifdef __INDEX_PRIM
                BYTE *p1 = vertex + v1*vertexSize;
                BYTE *p2 = vertex + v2*vertexSize;
#else
                BYTE *p1 = vertex;
                BYTE *p2 = vertex + vertexSize;
#endif
                ClipTriangle newline;

                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed, clipMaskOffScreen);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed, clipMaskOffScreen);

                newline.v[0] = &cv[0];
                newline.v[1] = &cv[1];

                if (ClipSingleLine(pv, &newline, &pv->rExtents, interpolate))
                {
                    BYTE *pTLV = (BYTE*)pv->ClipperState.clipBuf.GetAddress();
                    BYTE *p = pTLV;
#ifdef __INDEX_PRIM
                    BYTE *saveVer = (BYTE*)pv->lpvOut;  
                    DWORD numVer = pv->dwNumVertices; 
#endif
                    MAKE_TL_VERTEX_FVF(pv, p, newline.v[0]);
                    p += vertexSize;
                    MAKE_TL_VERTEX_FVF(pv, p, newline.v[1]);
                    pv->dwFlags |= D3DPV_CLIPPERPRIM; // Mark this call as gen by clipper
                    ret = DRAW_PRIM(pv, D3DPT_LINELIST, pTLV, 2, 1);
                    pv->dwFlags &= ~D3DPV_CLIPPERPRIM;
                    if (ret)
                        return ret;

#ifdef __INDEX_PRIM
                    pv->lpvOut = saveVer;
                    pv->dwNumVertices = numVer;
#endif
                }
            }
        } 
        else 
        {
            vertexCount += nextLineOffset;
            numPrim++;
        }
#ifdef __INDEX_PRIM
        index += nextLineOffset;
#else
        vertex += nextLineOffset*vertexSize;
        clipCode += nextLineOffset;
#endif
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        ret = __DRAW(pv, primType, startVertex, vertexCount+countAdd, numPrim);
        if (ret)
            return ret;
    }
    return D3D_OK;
}

#undef __DRAW
#undef __INDEX_PRIM
#undef __PROCESS_LINE_NAME
#undef __PROCESS_TRI_LIST_NAME
#undef __PROCESS_TRI_STRIP_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\light.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       light.h
 *  Content:    Direct3D lighting include file
 *
 ***************************************************************************/

#ifndef __LIGHT_H__
#define __LIGHT_H__
//-----------------------------------------------------------------------
inline void LIGHT_VERTEX(LPD3DFE_PROCESSVERTICES pv, void *in)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    D3DI_LIGHT  *light;
    ldrv.specularComputed = FALSE;
    ldrv.diffuse = ldrv.diffuse0;
    ldrv.specular.r = D3DVAL(0);
    ldrv.specular.g = D3DVAL(0);
    ldrv.specular.b = D3DVAL(0);

    light = ldrv.activeLights;
    while (light)
    {
        (*light->lightVertexFunc)(pv, light, (D3DLIGHTINGELEMENT*)in);
        light = light->next;
    }
    {
        int r = FTOI(ldrv.diffuse.r);
        int g = FTOI(ldrv.diffuse.g);
        int b = FTOI(ldrv.diffuse.b);
        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;
        ldrv.outDiffuse =  ldrv.alpha + (r<<16) + (g<<8) + b;
        if (ldrv.specularComputed)
        {
            r = FTOI(ldrv.specular.r);
            g = FTOI(ldrv.specular.g);
            b = FTOI(ldrv.specular.b);
            if (r < 0) r = 0; else if (r > 255) r = 255;
            if (g < 0) g = 0; else if (g > 255) g = 255;
            if (b < 0) b = 0; else if (b > 255) b = 255;
            if (!(pv->dwDeviceFlags & D3DDEV_PREDX6DEVICE))
                ldrv.outSpecular =  (r<<16) + (g<<8) + b;
            else
                // DX5 used to copy diffuse alpha to the specular alpha
                // Nobody knows why, but we have to preserve the behavior
                ldrv.outSpecular =  (r<<16) + (g<<8) + b + ldrv.alpha;
        }
        else
        {
            if (!(pv->dwDeviceFlags & D3DDEV_PREDX6DEVICE))
                ldrv.outSpecular =  0;
            else
                ldrv.outSpecular =  ldrv.alpha;
        }
    }
}
//-----------------------------------------------------------------------
inline void LIGHT_VERTEX_RAMP(LPD3DFE_PROCESSVERTICES pv, void *in)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    D3DI_LIGHT  *light;
    ldrv.specularComputed = FALSE;
    ldrv.diffuse.r = D3DVAL(0);
    ldrv.specular.r = D3DVAL(0);

    light = ldrv.activeLights;
    while (light)
    {
        (*light->lightVertexFunc)(pv, light, (D3DLIGHTINGELEMENT*)in);
        light = light->next;
    }
}
//--------------------------------------------------------------------------
#define D3DFE_SET_ALPHA(color, a) ((char*)&color)[3] = (unsigned char)a;
//--------------------------------------------------------------------------
inline void FOG_VERTEX(D3DFE_LIGHTING *ldrv, D3DVALUE z)
{
    int f;
    if (z < ldrv->fog_start)
        D3DFE_SET_ALPHA(ldrv->outSpecular, 255)
    else
    if (z >= ldrv->fog_end)
        D3DFE_SET_ALPHA(ldrv->outSpecular, 0)
    else
    {
        D3DVALUE v = (ldrv->fog_end - z) * ldrv->fog_factor;
        f = FTOI(v);
        D3DFE_SET_ALPHA(ldrv->outSpecular, f)
    }
}
//--------------------------------------------------------------------------
inline void FOG_VERTEX_RAMP(D3DFE_LIGHTING *ldrv, D3DVALUE z)
{
    int f;
    if (z > ldrv->fog_start)
    {
        if (z >= ldrv->fog_end)
        {
            ldrv->specular.r = D3DVAL(0);
            ldrv->diffuse.r = D3DVAL(0);
        }
        else
        {
            D3DVALUE v = (ldrv->fog_end - z) * ldrv->fog_factor_ramp;
            ldrv->specular.r *= v;
            ldrv->diffuse.r *= v;
        }
    }
}
//--------------------------------------------------------------------------
inline void MAKE_VERTEX_COLOR_RAMP(D3DFE_PROCESSVERTICES *pv, D3DTLVERTEX *vertex)
{
    D3DVALUE v;
    if (pv->lighting.diffuse.r > 1.0f)
        pv->lighting.diffuse.r = 1.0f;
    else
    if (FLOAT_LEZ(pv->lighting.diffuse.r))
        pv->lighting.diffuse.r = 0.0f;

    if (pv->dwFlags & D3DPV_RAMPSPECULAR)
    {
        if (pv->lighting.specular.r > 1.0f)
            pv->lighting.specular.r = 1.0f;
        else
        if (FLOAT_LEZ(pv->lighting.specular.r))
            pv->lighting.specular.r = 0.0f;

        v = 0.75f * pv->lighting.diffuse.r * (1.0f - pv->lighting.specular.r) +
            pv->lighting.specular.r;
    }
    else
        v = pv->lighting.diffuse.r;
    // Should be consistent with CI_MAKE macro
    vertex->color = pv->lighting.alpha + (((DWORD)(v * pv->dvRampScale) +
                    pv->dwRampBase) << 8);
    vertex->specular = PtrToUlong(pv->lpvRampTexture);
}
//---------------------------------------------------------------------
inline void MakeColor(D3DFE_COLOR *out, DWORD inputColor)
{
    out->r = (D3DVALUE)RGB_GETRED(inputColor);
    out->g = (D3DVALUE)RGB_GETGREEN(inputColor);
    out->b = (D3DVALUE)RGB_GETBLUE(inputColor);
}

extern void D3DFE_UpdateLights(LPDIRECT3DDEVICEI);

#endif  /* __LIGHT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\d3dfei.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dfei.hpp
 *  Content:    Direct3D frontend internal include file
 *
 ***************************************************************************/
#ifndef _D3DFEI_H_
#define _D3DFEI_H_

#include "clipper.h"

#define HANDLE_TO_MAT(lpDevI, h) ((LPD3DMATRIXI) ULongToPtr(h))

void  setIdentity(D3DMATRIXI * m);

extern void UpdateXfrmLight(LPDIRECT3DDEVICEI lpDevI);
extern void MatrixProduct(D3DMATRIXI *d, D3DMATRIXI *a, D3DMATRIXI *b);
extern void  D3DFE_updateExtents(LPDIRECT3DDEVICEI lpDevI);
extern void  D3DFE_ConvertExtent(LPDIRECT3DDEVICEI lpDevI, LPD3DRECTV from, LPD3DRECT to);
extern HRESULT D3DFE_InitTransform(LPDIRECT3DDEVICEI lpDevI);
extern void D3DFE_DestroyTransform(LPDIRECT3DDEVICEI lpDevI);

// Goes through all vertices and computes ramp color and texture.
// If pIn == pOut coordinates are not copied
//
extern void ConvertColorsToRamp(LPDIRECT3DDEVICEI lpDevI, D3DTLVERTEX *pIn,
                         D3DTLVERTEX *pOut, DWORD count);
//---------------------------------------------------------------------
// Maps legacy vertex formats (D3DVERTEX, D3DTLVERTEX, D3DLVERTEX) to
// FVF vertex ID.
//
extern DWORD d3dVertexToFVF[4];
//---------------------------------------------------------------------
// Computes the Current Transformation Matrix (lpDevI->mCTM) by combining
// all matrices together
//
extern void updateTransform(LPDIRECT3DDEVICEI lpDevI);
//---------------------------------------------------------------------
// Clamp extents to viewport window.
// For guard band it is possible that extents are outside viewport window
// after clipping
//
inline void ClampExtents(LPD3DFE_PROCESSVERTICES pv)
{
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND &&
        !(pv->dwFlags & D3DDP_DONOTUPDATEEXTENTS))
    {
        if (pv->rExtents.x1 < pv->vcache.minX)
            pv->rExtents.x1 = pv->vcache.minX;
        if (pv->rExtents.x2 > pv->vcache.maxX)
            pv->rExtents.x2 = pv->vcache.maxX;
        if (pv->rExtents.y1 < pv->vcache.minY)
            pv->rExtents.y1 = pv->vcache.minY;
        if (pv->rExtents.y2 > pv->vcache.maxY)
            pv->rExtents.y2 = pv->vcache.maxY;
    }
}
//---------------------------------------------------------------------
// Returns TRUE if cipping is needed
//
inline BOOL CheckIfNeedClipping(LPD3DFE_PROCESSVERTICES pv)
{
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        if (pv->dwClipUnion & ~__D3DCLIP_INGUARDBAND)
            return  TRUE;
    }
    else
        if (pv->dwClipUnion)
            return  TRUE;
    return FALSE;
}
//---------------------------------------------------------------------
// Updates lighting and computes process vertices flags
//
inline HRESULT DoUpdateState(LPDIRECT3DDEVICEI lpDevI)
{
    if (lpDevI->dwFlags & D3DPV_LIGHTING)
    {
        if (!(lpDevI->dwFlags & D3DDP_DONOTLIGHT ||
              lpDevI->lighting.hMat == NULL))
        {
            HRESULT ret;
            extern HRESULT setLights(LPDIRECT3DVIEWPORTI);
            LPDIRECT3DVIEWPORTI lpViewI = (LPDIRECT3DVIEWPORTI)
                                          (lpDevI->lpCurrentViewport);
            // only set up lights if something has changed
            if (lpViewI->bLightsChanged)
            {
                if ((ret = setLights(lpViewI)) != D3D_OK)
                {
                    D3D_ERR("failed to setup lights");
                    return ret;
                }
                lpViewI->bLightsChanged = FALSE;
            }
            lpDevI->dwFlags |= D3DPV_LIGHTING;
            if (lpDevI->dwFEFlags & D3DFE_COMPUTESPECULAR &&
                lpDevI->dwVIDOut & D3DFVF_SPECULAR)
                lpDevI->dwFlags |= D3DPV_COMPUTESPECULAR;
        }
        else
            lpDevI->dwFlags &= ~D3DPV_LIGHTING;
    }
    if (lpDevI->dwFEFlags & D3DFE_COLORVERTEX)
    {
        if (lpDevI->dwVIDIn & D3DFVF_DIFFUSE)
            lpDevI->dwFlags |= D3DPV_COLORVERTEX;
        if (lpDevI->dwVIDIn & D3DFVF_SPECULAR)
            lpDevI->dwFlags |= D3DPV_COLORVERTEXS;
    }

    UpdateXfrmLight(lpDevI);
// In case if COLORVERTEX is TRUE, the vertexAlpha could be overriden
// by vertex alpha
    lpDevI->lighting.alpha = lpDevI->lighting.materialAlpha;

    return D3D_OK;
}
//---------------------------------------------------------------------
// The following bits should be set in dwFlags before calling this function:
//
//  D3DPV_STRIDE        - if strides are used
//  D3DPV_SOA           - if SOA is used
//
inline long D3DFE_ProcessVertices(LPDIRECT3DDEVICEI lpDevI)
{
    // Update Lighting and related flags
    DoUpdateState(lpDevI);
    return lpDevI->pGeometryFuncs->ProcessVertices(lpDevI);
}
//---------------------------------------------------------------------
// Updates clip status in the device
//
// We have to mask all guard band bits
//
inline void D3DFE_UpdateClipStatus(LPDIRECT3DDEVICEI lpDevI)
{
    lpDevI->iClipStatus |= lpDevI->dwClipUnion & D3DSTATUS_CLIPUNIONALL;
    lpDevI->iClipStatus &= (~D3DSTATUS_CLIPINTERSECTIONALL |
                         ((lpDevI->dwClipIntersection & D3DSTATUS_CLIPUNIONALL) << 12));
}
#endif // _D3DFEI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\pentium2.inc ===
;/*
;*    INTEL CORPORATION PROPRIETARY INFORMATION 
;*
;*    This software is supplied under the terms of a license
;*    agreement or nondisclosure agreement with Intel Corporation 
;*    and may not be copied or disclosed except in accordance with 
;*    the terms of that agreement.
;*    Copyright (c) 1991,1992,1993,1994,1995,1996,1997  Intel Corporation. 
;*
;*/

.486P

;RDPMC
rdpmc macro 
		db 0Fh
		db 033h
endm

;UD2
ud2 macro 
		db 0Fh
		db 0Bh
endm

;FCOMI Compare Real and Set EFLAGS
OPTION NOKEYWORD:<fcomi>
fcomi macro dst:req, src:req
	local x, y
	
	IF (OPATTR(src)) AND 00010000y ; register
		freg = @SubStr(src,4,1)
	ELSE
		ERROR INVALID SOURCE REGISTER (src)
	ENDIF

x:
		FADD dst, src
		org x
		db 0DBh
		db 0F0h + freg
y:
endm

;FCOMIP Compare Real and Set EFLAGS
OPTION NOKEYWORD:<fcomip>
fcomip macro dst:req, src:req
	local x, y
	
	IF (OPATTR(src)) AND 00010000y ; register
		freg = @SubStr(src,4,1)
	ELSE
		ERROR INVALID SOURCE REGISTER (src)
	ENDIF

x:
		FADD dst, src
		org x
		db 0DFh
		db 0F0h + freg
y:
endm

;FUCOMI Compare Real and Set EFLAGS
OPTION NOKEYWORD:<fucomi>
fucomi macro dst:req, src:req
	local x, y
	
	IF (OPATTR(src)) AND 00010000y ; register
		freg = @SubStr(src,4,1)
	ELSE
		ERROR INVALID SOURCE REGISTER (src)
	ENDIF

x:
		FADD dst, src
		org x
		db 0DBh
		db 0E8h + freg
y:
endm

;FUCOMIP Compare Real and Set EFLAGS
OPTION NOKEYWORD:<fucomip>
fucomip macro dst:req, src:req
	local x, y
	
	IF (OPATTR(src)) AND 00010000y ; register
		freg = @SubStr(src,4,1)
	ELSE
		ERROR INVALID SOURCE REGISTER (src)
	ENDIF

x:
		FADD dst, src
		org x
		db 0DFh
		db 0E8h + freg
y:
endm


;FCMOVB FCMOVE FCMOVBE FCMOVU FCMOVNB FCMOVNE FCMOVNBE FCMOVNU
;These instructions are reserved by the assembler but complains if
;you try use them.  Undefine them before we build the macros
OPTION NOKEYWORD:<fcmovb fcmove fcmovbe fcmovu fcmovnb fcmovne fcmovnbe fcmovnu>
Mfcmov macro dst:req, src:req, op1, op2
	local x, y

	IF (OPATTR(src)) AND 00010000y ; register
		freg = @SubStr(src,4,1)
	ELSE
		ERROR INVALID SOURCE REGISTER (src)
	ENDIF

x:
		FADD dst, src
		org x
		db op1
		db op2 + freg
y:
endm

;Need to validate arguments 
MDfcmovd macro op1:req, op2:req, ex1:req
	fcmov&ex1 macro dst:req, src:req
		Mfcmov dst, src, op1, op2
	endm
endm

MDfcmovd 0DAh, 0C0h, b
MDfcmovd 0DAh, 0C8h, e
MDfcmovd 0DAh, 0D0h, be
MDfcmovd 0DAh, 0D8h, u
MDfcmovd 0DBh, 0C0h, nb
MDfcmovd 0DBh, 0C8h, ne
MDfcmovd 0DBh, 0D0h, nbe
MDfcmovd 0DBh, 0D8h, nu


;CMOVxxx
cmovop_   macro   op:req, dst:req, src:req
        local   x, y

	IF (OPATTR(dst)) AND 00010000y ; register
x:
		bsf	dst, src
y:
   		org     x+1
		db	op
		org     y
	ELSE
		ERROR INVALID DESTINATION REGISTER (dst)
	ENDIF
endm

cmovdf_ macro   code:req, ex1:req, ex2, ex3

	cmov&ex1    macro   dst:req, src:req
		cmovop_ code, dst, src
	endm

    ifnb  <ex2>

	cmov&ex2    macro   dst:req, src:req
		cmovop_ code, dst, src
	endm

    endif

    ifnb  <ex3>

	cmov&ex3    macro   dst:req, src:req
		cmovop_ code, dst, src
	endm

    endif

endm

cmovdf_	040h,	o
cmovdf_ 041h,   no
cmovdf_ 042h,   b,	nae,	c
cmovdf_ 043h,   ae,	nb,	nc
cmovdf_ 044h,   e,	z
cmovdf_ 045h,   ne,	nz
cmovdf_ 046h,   be,	na
cmovdf_ 047h,   a,	nbe
cmovdf_ 048h,   s
cmovdf_ 049h,   ns
cmovdf_ 04Ah,   p,	pe
cmovdf_ 04Bh,   np,	po
cmovdf_ 04Ch,   l,	nge
cmovdf_ 04Dh,   ge,	nl
cmovdf_ 04Eh,   le,	ng
cmovdf_ 04Fh,   g,	nle
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\procver.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       procver.h
 *  Content:    Generic implementation for process vertices function
 *
 * This file is included several times with different defines:
 * _PV_NAME     - function name
 * _PV_EXTENT   - if updating extent is required
 * _PV_CLIP     - if clipping is required
 * _PV_VIEWPORT - if the function is used by TransformVertices call
 * _PV_LVERTEX  - if D3DLVERTEX is used as input
 * _PV_APPLY_LIGHT  - if lighting is required
 * _PV_FOG      - if fog is required
 *
 ***************************************************************************/

//--------------------------------------------------------------------------
// Viewport->TransformVertices
// For clipped and unclipped cases
// for unclipped case H vertices should not be written
//
long _PV_NAME(D3DFE_PROCESSVERTICES *pv, DWORD count, LPD3DTRANSFORMDATAI data)
{
    // We use power of 2 because it preserves the mantissa when we multiply
    const D3DVALUE __HUGE_PWR2 = 1024.0f*1024.0f*2.0f;
    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    D3DLVERTEX* in  = (LPD3DLVERTEX)data->lpIn;
    size_t in_size = data->dwInSize;
    D3DTLVERTEX *out  =(LPD3DTLVERTEX) data->lpOut;
    size_t out_size =  data->dwOutSize;
    DWORD i;
    DWORD flags = pv->dwFlags;
#ifdef _PV_CLIP
    D3DHVERTEX *hout = data->lpHOut;
    int clip_intersection = ~0;
    int clip_union = 0;
#endif // _PV_CLIP
    D3DVALUE minx, maxx, miny, maxy;

    minx = data->drExtent.x1;
    miny = data->drExtent.y1;
    maxx = data->drExtent.x2;
    maxy = data->drExtent.y2;
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;
    for (i = count; i; i--) 
    {
#ifdef _PV_CLIP
        int clip;
#endif // _PV_CLIP
        float x, y, z, w, we;

        x = in->x*pv->mCTM._11 + in->y*pv->mCTM._21 + 
            in->z*pv->mCTM._31 + pv->mCTM._41;
        y = in->x*pv->mCTM._12 + in->y*pv->mCTM._22 + 
            in->z*pv->mCTM._32 + pv->mCTM._42;
        z = in->x*pv->mCTM._13 + in->y*pv->mCTM._23 + 
            in->z*pv->mCTM._33 + pv->mCTM._43;
        we= in->x*pv->mCTM._14 + in->y*pv->mCTM._24 + 
            in->z*pv->mCTM._34 + pv->mCTM._44;
#ifdef _PV_CLIP
        hout->hx = x * VPORT.imclip11 + we * VPORT.imclip41;
        hout->hy = y * VPORT.imclip22 + we * VPORT.imclip42;
        hout->hz = z * VPORT.imclip33 + we * VPORT.imclip43;
        {
            D3DVALUE xx = we - x;
            D3DVALUE yy = we - y;
            D3DVALUE zz = we - z;
            clip = ((ASINT32(x)  & 0x80000000) >> (32-1)) | // D3DCLIP_LEFT
                   ((ASINT32(y)  & 0x80000000) >> (32-4)) | // D3DCLIP_BOTTOM
                   ((ASINT32(z)  & 0x80000000) >> (32-5)) | // D3DCLIP_FRONT 
                   ((ASINT32(xx) & 0x80000000) >> (32-2)) | // D3DCLIP_RIGHT
                   ((ASINT32(yy) & 0x80000000) >> (32-3)) | // D3DCLIP_TOP   
                   ((ASINT32(zz) & 0x80000000) >> (32-6));  // D3DCLIP_BACK
        }

        if (clip == 0) 
#endif // _PV_CLIP
        {
            w = D3DVAL(1)/we;
#ifdef _PV_CLIP
            clip_intersection = 0;
#endif // _PV_CLIP
            x = x * w * VPORT.scaleX + VPORT.offsetX;
            y = y * w * VPORT.scaleY + VPORT.offsetY;
            if (x < minx) minx = x;
            if (x > maxx) maxx = x;
            if (y < miny) miny = y;
            if (y > maxy) maxy = y;
            out->sx = x;
            out->sy = y;
            out->sz = z*w;
            out->rhw = w;
        }
#ifdef _PV_CLIP
        else
        {
            if (!FLOAT_EQZ(we))
                out->rhw = D3DVAL(1)/we;
            else
                out->rhw = __HUGE_PWR2;
            clip_intersection &= clip;
            clip_union |= clip;
        }
        hout->dwFlags = clip;
        hout++;
#endif // !_PV_CLIP

        out->tu = in->tu;
        out->tv = in->tv;
        out->color = in->color;
        out->specular = in->specular;

        in = (D3DLVERTEX*) ((char*) in + in_size);
        out = (D3DTLVERTEX*) ((char*) out + out_size);
    }

    /*
     * extend to cover lines. XXX
     */
    maxx += pv->dvExtentsAdjust;
    maxy += pv->dvExtentsAdjust;
    minx -= pv->dvExtentsAdjust;
    miny -= pv->dvExtentsAdjust;
#ifndef _PV_CLIP
    /* Clamp to viewport */
    /* Clamp for legacy apps */
    if (minx < VPORT.minX || miny < VPORT.minY || 
        maxx > VPORT.maxX || maxy > VPORT.maxY)
#endif // _PV_CLIP
    {
        /* Clamp to viewport */
        if (minx < VPORT.minX)
            minx = VPORT.minX;
        if (miny < VPORT.minY)
            miny = VPORT.minY;
        if (maxx > VPORT.maxX)
            maxx = VPORT.maxX;
        if (maxy > VPORT.maxY)
            maxy = VPORT.maxY;
#ifndef _PV_CLIP
        if(pv->dwDeviceFlags & D3DDEV_PREDX5DEVICE)
        { /* Clamp vertices */
            int i;
            D3D_WARN(4, "Old semantics: Clamping Vertices");
            for (i = count, out = (LPD3DTLVERTEX)data->lpOut; i; i--)
            {
                if (out->sx < VPORT.minX) out->sx = VPORT.minX;
                if (out->sx > VPORT.maxX) out->sx = VPORT.maxX;
                if (out->sy < VPORT.minY) out->sy = VPORT.minY;
                if (out->sy > VPORT.maxY) out->sy = VPORT.maxY;

                out = (D3DTLVERTEX*) ((char*) out + out_size);
            }
        }
#endif // _PV_CLIP
    }
    data->drExtent.x1 = minx;   
    data->drExtent.y1 = miny;
    data->drExtent.x2 = maxx;
    data->drExtent.y2 = maxy;
#ifdef _PV_CLIP
    data->dwClipIntersection = clip_intersection;
    data->dwClipUnion = clip_union;
    return clip_intersection;
#else
    return 0;
#endif // _PVCLIP
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\makefile.inc ===
$(GENTGT)\mcrbd_mh.h: ..\mcrbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\mcrgn_mh.h: ..\mcrgn_mh.mh $(RAST_STD_M4)

$(GENTGT)\mtest_mh.h: ..\mtest_mh.mh $(RAST_STD_M4)

$(GENTGT)\mtx1a_mh.h: ..\mtx1a_mh.mh ..\mtexaddr.mh $(RAST_STD_M4)

$(GENTGT)\mtx2a_mh.h: ..\mtx2a_mh.mh ..\mtexaddr.mh $(RAST_STD_M4)

$(GENTGT)\mtxbd_mh.h: ..\mtxbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\mtxrd_mh.h: ..\mtxrd_mh.mh $(RAST_STD_M4)

$(GENTGT)\mtstf_mh.h: ..\mtstf_mh.mh $(RAST_STD_M4)

$(GENTGT)\matest_mh.h: ..\matest_mh.mh $(RAST_STD_M4)

$(GENTGT)\mbeadtbl.cpp: ..\mbeadtbl.mcp $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)

$(GENTGT)\mclrbld.cpp: ..\mclrbld.mcp $(RAST_STD_M4)

$(GENTGT)\mclrgen.cpp: ..\mclrgen.mcp $(RAST_STD_M4)

$(GENTGT)\mloop.cpp: ..\mloop.mcp ..\mtexaddr.mh $(RAST_STD_M4)

$(GENTGT)\mtest.cpp: ..\mtest.mcp $(RAST_STD_M4)

$(GENTGT)\mtx1addr.cpp: ..\mtx1addr.mcp ..\mtexaddr.mh $(RAST_STD_M4)

$(GENTGT)\mtx2addr.cpp: ..\mtx2addr.mcp ..\mtexaddr.mh $(RAST_STD_M4)

$(GENTGT)\mtxblend.cpp: ..\mtxblend.mcp $(RAST_STD_M4)

$(GENTGT)\mtexread.cpp: ..\mtexread.mcp $(RAST_STD_M4)

$(GENTGT)\matest.cpp: ..\matest.mcp $(RAST_STD_M4)

$(GENTGT)\mtstfail.cpp: ..\mtstfail.mcp ..\mtexaddr.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mbldfncs.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "mbldfncs.h"

//-----------------------------------------------------------------------------
//
// SrcBlendZero
//
// (0, 0, 0, 0) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// SrcBlendOne
//
// (1, 1, 1, 1) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = pCtx->SI.uBR;
    *pG = pCtx->SI.uBG;
    *pB = pCtx->SI.uBB;
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcColor
//
// (Rs, Gs, Bs, As) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*(pCtx->SI.uBR>>8);
    *pG = (pCtx->SI.uBG>>8)*(pCtx->SI.uBG>>8);
    *pB = (pCtx->SI.uBB>>8)*(pCtx->SI.uBB>>8);
    *pA = (pCtx->SI.uBA>>8)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*(pCtx->SI.uBR>>8);
    *pG = (0xff - (pCtx->SI.uBG>>8))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (pCtx->SI.uBB>>8))*(pCtx->SI.uBB>>8);
    *pA = (0xff - (pCtx->SI.uBA>>8))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlpha
//
// (As, As, As, As) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (UINT16)RGBA_GETRED(DestC)  *(pCtx->SI.uBR>>8);
    *pG = (UINT16)RGBA_GETGREEN(DestC)*(pCtx->SI.uBG>>8);
    *pB = (UINT16)RGBA_GETBLUE(DestC) *(pCtx->SI.uBB>>8);
    *pA = (UINT16)RGBA_GETALPHA(DestC)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*(pCtx->SI.uBR>>8);
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*(pCtx->SI.uBB>>8);
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlphaSat
//
// f = min(as, 1-Ad); (f, f, f, 1) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// DestBlendZero
//
// (0, 0, 0, 0) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// DestBlendOne
//
// (1, 1, 1, 1) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  <<8);
    *pG = ((UINT16)RGBA_GETGREEN(DestC)<<8);
    *pB = ((UINT16)RGBA_GETBLUE(DestC) <<8);
    *pA = ((UINT16)RGBA_GETALPHA(DestC)<<8);
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcColor
//
// (Rs, Gs, Bs, As) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (pCtx->SI.uBG>>8)*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (pCtx->SI.uBB>>8)*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (pCtx->SI.uBA>>8)*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (pCtx->SI.uBG>>8))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (pCtx->SI.uBB>>8))*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (pCtx->SI.uBA>>8))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlpha
//
// (As, As, As, As) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = ((UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = ((UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = ((UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlphaSat
//
// f = min(As, 1-Ad); (f, f, f, 1) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (UINT16)RGBA_GETALPHA(DestC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mbufread.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color reading routines for Blending.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "mbufread.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

//-----------------------------------------------------------------------------
//
// Read_B8G8R8
//
// Reads output buffer in BGR-888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR CMMX_BufRead_B8G8R8(PUINT8 pBits)
{
    return (*pBits | (*(pBits+1))<<8 | (*(pBits+2))<<16 | 0xff000000);
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8X8
//
// Reads output buffer in BGR-888x format.
//
//-----------------------------------------------------------------------------
D3DCOLOR CMMX_BufRead_B8G8R8X8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface | 0xff000000;
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8A8
//
// Reads output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR CMMX_BufRead_B8G8R8A8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface;
}

//-----------------------------------------------------------------------------
//
// Read_B5G6R5
//
// Reads output in BGR-565 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR CMMX_BufRead_B5G6R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 8 ) & 0xf8,
                (( uPixel >> 3) & 0xfc ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5
//
// Reads output in BGR-555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR CMMX_BufRead_B5G5R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 7 ) & 0xf8,
                (( uPixel >> 2) & 0xf8 ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5A1
//
// Reads output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR CMMX_BufRead_B5G5R5A1(PUINT8 pBits)
{
    UINT16 iPixel = *(PINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( iPixel >> 7 ) & 0xf8,
                (( iPixel >> 2) & 0xf8 ),
                (( iPixel << 3) & 0xf8 ),
                (iPixel >> 15) & 0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_Palette8
//
// Reads output in Palette8 format. 
//
//-----------------------------------------------------------------------------
D3DCOLOR CMMX_BufRead_Palette8(PUINT8 pBits)
{
    // ATTENTION - This is not correct. But We assume Palette8 format will 
    // normally not be used for alpha blending.
    return (D3DCOLOR)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mbldfncs.h ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void CMMX_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

void CMMX_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mbufwrt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color writing routines.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "mbufwrt.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

extern UINT16 g_uDitherTable[16];

//-----------------------------------------------------------------------------
//
// Write_B8G8R8X8_NoDither
//
// Writes output in BGR-888 format, aligned to 32 bits.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, 0xff);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8A8_NoDither
//
// Writes output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, pCtx->SI.uBA>>8);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_NoDither
//
// Writes output in BGR-565 format.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  0) & 0xf800) |
        ((pCtx->SI.uBG >>  5) & 0x07e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_Dither
//
// Writes output in BGR-565 format, dithered.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 2;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x3f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 11);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_NoDither
//
// Writes output in BGR-555 format.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f) |
        0x8000;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_Dither
//
// Writes output in BGR-555 format, dithered.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10) | 0x8000;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_NoDither
//
// Writes output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f) |
        ((pCtx->SI.uBA >>  0) & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_Dither
//
// Writes output in BGRA-1555 format, dithered.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10) | (pCtx->SI.uBA & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8_NoDither
//
// Writes output in BGR-888 format.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    PUINT8 pSurface = (PUINT8)pS->pSurface;
    *pSurface++ = pCtx->SI.uBB>>8;
    *pSurface++ = pCtx->SI.uBG>>8;
    *pSurface++ = pCtx->SI.uBR>>8;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_Palette8_NoDither
//
// Writes output to the RGB8 palette format.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uMapIdx = MAKE_RGB8(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8, pCtx->SI.uBB>>8);

    *(PUINT8)pS->pSurface = (UINT8)(pCtx->pRampMap[uMapIdx]);

    // just returns for C, since we really can't loop with function calls
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mspnpars.h ===
//----------------------------------------------------------------------------
//
// mspnpars.h
//
// Top-level span rendering routine declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANPARS_H_
#define _SPANPARS_H_

HRESULT CMMX_RenderSpansAny(PD3DI_RASTCTX pCtx);

#endif // #ifndef _SPANPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mspnpars.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// CMMX_RenderSpansAny
//
// All mode general span routine.
//
//-----------------------------------------------------------------------------
HRESULT CMMX_RenderSpansAny(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            pCtx->pfnBegin(pCtx, pP, pS);

            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mloop.h ===
//-----------------------------------------------------------------------------
//
// This file contains C span loop headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void CMMX_LoopAny(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mspnutil.cpp ===
//----------------------------------------------------------------------------
//
// mspnutil.cpp
//
// Sundry span utilities.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// don't have anything to put in this file, yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mbufread.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color buffer reading routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
D3DCOLOR CMMX_BufRead_B8G8R8(PUINT8 pBits);
D3DCOLOR CMMX_BufRead_B8G8R8X8(PUINT8 pBits);
D3DCOLOR CMMX_BufRead_B8G8R8A8(PUINT8 pBits);
D3DCOLOR CMMX_BufRead_B5G6R5(PUINT8 pBits);
D3DCOLOR CMMX_BufRead_B5G5R5(PUINT8 pBits);
D3DCOLOR CMMX_BufRead_B5G5R5A1(PUINT8 pBits);
D3DCOLOR CMMX_BufRead_Palette8(PUINT8 pBits);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mbufwrt.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color writing routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
void CMMX_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mspnutil.h ===
//----------------------------------------------------------------------------
//
// mspnutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

//-----------------------------------------------------------------------------
//
// imul32h_s20
//
// Returns (x*y)>>20
//
//-----------------------------------------------------------------------------
inline INT32 imul32h_s20(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        shrd eax, edx, 20
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 20);
#endif
}


#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mtexfilt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "mtexfilt.h"

//-----------------------------------------------------------------------------
//
// TexFiltBilinear
//
// Given the basic bilinear equations
//
// A = C00 + U*(C10 - C00)
// B = C01 + U*(C11 - C01)
// C = A + V*(B-A)
//
// This routine is based on the re-arrangement of this equation into
//
// C = C00*(1-U-V+U*V) + C10*(U-U*V) + C10(V-U*V) + C11*(U*V)
// or
// C = C00*s1 + C10*s2 + C10*s3 + C11*s4
//
//-----------------------------------------------------------------------------
void TexFiltBilinear(D3DCOLOR *pOut, INT32 iU, INT32 iV, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11)
{
#define SIMPLE_BILINEAR 1
#ifdef SIMPLE_BILINEAR
    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    // can be MMX_mulhw's
    r00 = r00 + ((iU*(r10 - r00)) >> 16);
    g00 = g00 + ((iU*(g10 - g00)) >> 16);
    b00 = b00 + ((iU*(b10 - b00)) >> 16);
    a00 = a00 + ((iU*(a10 - a00)) >> 16);

    r01 = r01 + ((iU*(r11 - r01)) >> 16);
    g01 = g01 + ((iU*(g11 - g01)) >> 16);
    b01 = b01 + ((iU*(b11 - b01)) >> 16);
    a01 = a01 + ((iU*(a11 - a01)) >> 16);

    r00 = r00 + ((iV*(r01 - r00)) >> 16);
    g00 = g00 + ((iV*(g01 - g00)) >> 16);
    b00 = b00 + ((iV*(b01 - b00)) >> 16);
    a00 = a00 + ((iV*(a01 - a00)) >> 16);

#else
    // another potential MMX implementation
    INT32 s1, s2, s3, s4;
    s4 = (iU * iV)>>16;         // (0.16 * 0.16) >> 16 = 0.16
    s3 = iV - s4;
    s2 = iU - s4;
    s1 = 0x10000 - iV - s2;

    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    // 8.0 * 0.16 == 8.16 >> 16 == 8.0
    r00 = (r00*s1 + r10*s2 + r01*s3 + r11*s4)>>16;
    g00 = (g00*s1 + g10*s2 + g01*s3 + g11*s4)>>16;
    b00 = (b00*s1 + b10*s2 + b01*s3 + b11*s4)>>16;
    a00 = (a00*s1 + a10*s2 + a01*s3 + a11*s4)>>16;
#endif

    *pOut = RGBA_MAKE(r00, g00, b00, a00);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <wi